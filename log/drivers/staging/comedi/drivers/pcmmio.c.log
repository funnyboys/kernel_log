commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3f339cf7e36f..72af1776f785 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2007 Calin A. Culianu <calin@ajvar.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 70ad497dd20b..3f339cf7e36f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * pcmmio.c
  * Driver for Winsystems PC-104 based multifunction IO board.

commit 1694830640d4573e8535dd6798b6f4cf00f680fd
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Wed May 18 10:27:29 2016 +0530

    Staging: comedi: fix CHECK: Prefer using the BIT macro issues in pcmmio.c
    
    This patch Replace all occurences of (1<<x) by BIT(x) in the file pcmmio.c to
    get rid of checkpatch.pl "CHECK" output "Prefer using the BIT macro"
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 10472e6dd002..70ad497dd20b 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -84,25 +84,25 @@
 #define PCMMIO_AI_LSB_REG			0x00
 #define PCMMIO_AI_MSB_REG			0x01
 #define PCMMIO_AI_CMD_REG			0x02
-#define PCMMIO_AI_CMD_SE			(1 << 7)
-#define PCMMIO_AI_CMD_ODD_CHAN			(1 << 6)
+#define PCMMIO_AI_CMD_SE			BIT(7)
+#define PCMMIO_AI_CMD_ODD_CHAN			BIT(6)
 #define PCMMIO_AI_CMD_CHAN_SEL(x)		(((x) & 0x3) << 4)
 #define PCMMIO_AI_CMD_RANGE(x)			(((x) & 0x3) << 2)
 #define PCMMIO_RESOURCE_REG			0x02
 #define PCMMIO_RESOURCE_IRQ(x)			(((x) & 0xf) << 0)
 #define PCMMIO_AI_STATUS_REG			0x03
-#define PCMMIO_AI_STATUS_DATA_READY		(1 << 7)
-#define PCMMIO_AI_STATUS_DATA_DMA_PEND		(1 << 6)
-#define PCMMIO_AI_STATUS_CMD_DMA_PEND		(1 << 5)
-#define PCMMIO_AI_STATUS_IRQ_PEND		(1 << 4)
-#define PCMMIO_AI_STATUS_DATA_DRQ_ENA		(1 << 2)
-#define PCMMIO_AI_STATUS_REG_SEL		(1 << 3)
-#define PCMMIO_AI_STATUS_CMD_DRQ_ENA		(1 << 1)
-#define PCMMIO_AI_STATUS_IRQ_ENA		(1 << 0)
+#define PCMMIO_AI_STATUS_DATA_READY		BIT(7)
+#define PCMMIO_AI_STATUS_DATA_DMA_PEND		BIT(6)
+#define PCMMIO_AI_STATUS_CMD_DMA_PEND		BIT(5)
+#define PCMMIO_AI_STATUS_IRQ_PEND		BIT(4)
+#define PCMMIO_AI_STATUS_DATA_DRQ_ENA		BIT(2)
+#define PCMMIO_AI_STATUS_REG_SEL		BIT(3)
+#define PCMMIO_AI_STATUS_CMD_DRQ_ENA		BIT(1)
+#define PCMMIO_AI_STATUS_IRQ_ENA		BIT(0)
 #define PCMMIO_AI_RES_ENA_REG			0x03
 #define PCMMIO_AI_RES_ENA_CMD_REG_ACCESS	(0 << 3)
-#define PCMMIO_AI_RES_ENA_AI_RES_ACCESS		(1 << 3)
-#define PCMMIO_AI_RES_ENA_DIO_RES_ACCESS	(1 << 4)
+#define PCMMIO_AI_RES_ENA_AI_RES_ACCESS		BIT(3)
+#define PCMMIO_AI_RES_ENA_DIO_RES_ACCESS	BIT(4)
 #define PCMMIO_AI_2ND_ADC_OFFSET		0x04
 
 #define PCMMIO_AO_LSB_REG			0x08
@@ -125,14 +125,14 @@
 #define PCMMIO_AO_CMD_CHAN_SEL(x)		(((x) & 0x03) << 1)
 #define PCMMIO_AO_CMD_CHAN_SEL_ALL		(0x0f << 0)
 #define PCMMIO_AO_STATUS_REG			0x0b
-#define PCMMIO_AO_STATUS_DATA_READY		(1 << 7)
-#define PCMMIO_AO_STATUS_DATA_DMA_PEND		(1 << 6)
-#define PCMMIO_AO_STATUS_CMD_DMA_PEND		(1 << 5)
-#define PCMMIO_AO_STATUS_IRQ_PEND		(1 << 4)
-#define PCMMIO_AO_STATUS_DATA_DRQ_ENA		(1 << 2)
-#define PCMMIO_AO_STATUS_REG_SEL		(1 << 3)
-#define PCMMIO_AO_STATUS_CMD_DRQ_ENA		(1 << 1)
-#define PCMMIO_AO_STATUS_IRQ_ENA		(1 << 0)
+#define PCMMIO_AO_STATUS_DATA_READY		BIT(7)
+#define PCMMIO_AO_STATUS_DATA_DMA_PEND		BIT(6)
+#define PCMMIO_AO_STATUS_CMD_DMA_PEND		BIT(5)
+#define PCMMIO_AO_STATUS_IRQ_PEND		BIT(4)
+#define PCMMIO_AO_STATUS_DATA_DRQ_ENA		BIT(2)
+#define PCMMIO_AO_STATUS_REG_SEL		BIT(3)
+#define PCMMIO_AO_STATUS_CMD_DRQ_ENA		BIT(1)
+#define PCMMIO_AO_STATUS_IRQ_ENA		BIT(0)
 #define PCMMIO_AO_RESOURCE_ENA_REG		0x0b
 #define PCMMIO_AO_2ND_DAC_OFFSET		0x04
 

commit b21a766f7c5476db7730653bee2915ff0a9e40a8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:32 2015 +0000

    staging: comedi: pcmmio: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 2c0e7ecbf494..10472e6dd002 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -78,8 +78,6 @@
 
 #include "../comedidev.h"
 
-#include "comedi_fc.h"
-
 /*
  * Register I/O map
  */
@@ -483,19 +481,19 @@ static int pcmmio_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -504,15 +502,16 @@ static int pcmmio_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c07e5ede8f00a9a66147f8f461e69828deb3029a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:05 2015 +0000

    staging: comedi: pcmmio: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f0059e935da0..2c0e7ecbf494 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -19,7 +19,7 @@
 /*
  * Driver: pcmmio
  * Description: A driver for the PCM-MIO multifunction board
- * Devices: (Winsystems) PCM-MIO [pcmmio]
+ * Devices: [Winsystems] PCM-MIO (pcmmio)
  * Author: Calin Culianu <calin@ajvar.org>
  * Updated: Wed, May 16 2007 16:21:10 -0500
  * Status: works

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 985fabd879aa..f0059e935da0 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -732,7 +732,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= 0xffff;
 	s->range_table	= &pcmmio_ao_ranges;
 	s->insn_write	= pcmmio_ao_insn_write;
-	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 09959d658ce9049579561c7cb6acedaae74f5222
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:01 2014 -0700

    staging: comedi: pcmmio: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index df47967c2650..985fabd879aa 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -190,7 +190,6 @@ struct pcmmio_private {
 	spinlock_t pagelock;	/* protects the page registers */
 	spinlock_t spinlock;	/* protects the member variables */
 	unsigned int enabled_mask;
-	unsigned int stop_count;
 	unsigned int active:1;
 };
 
@@ -358,12 +357,9 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 
 	comedi_buf_write_samples(s, &val, 1);
 
-	/* Check for end of acquisition. */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count > 0) {
-		devpriv->stop_count--;
-		if (devpriv->stop_count == 0)
-			s->async->events |= COMEDI_CB_EOA;
-	}
+	if (cmd->stop_src == TRIG_COUNT &&
+	    s->async->scans_done >= cmd->stop_arg)
+		s->async->events |= COMEDI_CB_EOA;
 
 done:
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
@@ -468,8 +464,6 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	spin_lock_irqsave(&devpriv->spinlock, flags);
 	devpriv->active = 1;
 
-	devpriv->stop_count = cmd->stop_arg;
-
 	/* Set up start of acquisition. */
 	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmmio_inttrig_start_intr;

commit ff5eb046cf43726f961644b84aa416960e0f2824
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:13 2014 -0700

    staging: comedi: pcmmio: use comedi_buf_write_samples()
    
    The dev->read_subdev used in this driver for async commands returns 32-bit samples
    and should have the SDF_LSAMPL subdev_flag set. It also returns the full scan with
    each sample so it should have the SDF_PACKED subdev_flag set.
    
    Add the missing subdev_flags and use comedi_buf_write_samples() to add the sample
    to the async buffer.
    
    The COMEDI_CB_BLOCK and COMEDI_CB_EOS events will be automatically handled by the
    core. Remove the unnecessary events in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6d60d40733f4..df47967c2650 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -356,10 +356,7 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 			val |= (1 << i);
 	}
 
-	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s, val) &&
-	    comedi_buf_put(s, val >> 16))
-		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	comedi_buf_write_samples(s, &val, 1);
 
 	/* Check for end of acquisition. */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count > 0) {
@@ -764,7 +761,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_config	= pcmmio_dio_insn_config;
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->subdev_flags	|= SDF_CMD_READ;
+		s->subdev_flags	|= SDF_CMD_READ | SDF_LSAMPL | SDF_PACKED;
 		s->len_chanlist	= s->n_chan;
 		s->cancel	= pcmmio_cancel;
 		s->do_cmd	= pcmmio_cmd;

commit c746db4e2b92ee603e8071302fbe56700c05aa61
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:37 2014 -0700

    staging: comedi: pcmmio: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Also, comedi_handle_events() does nothing if no events are set so the
    local variable 'oldevents' can be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index fc40ee2b34e9..6d60d40733f4 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -337,7 +337,6 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 {
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int oldevents = s->async->events;
 	unsigned int val = 0;
 	unsigned long flags;
 	int i;
@@ -359,29 +358,20 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 
 	/* Write the scan to the buffer. */
 	if (comedi_buf_put(s, val) &&
-	    comedi_buf_put(s, val >> 16)) {
+	    comedi_buf_put(s, val >> 16))
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-	} else {
-		/* Overflow! Stop acquisition!! */
-		/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-		pcmmio_stop_intr(dev, s);
-	}
 
 	/* Check for end of acquisition. */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count > 0) {
 		devpriv->stop_count--;
-		if (devpriv->stop_count == 0) {
+		if (devpriv->stop_count == 0)
 			s->async->events |= COMEDI_CB_EOA;
-			/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-			pcmmio_stop_intr(dev, s);
-		}
 	}
 
 done:
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
-	if (oldevents != s->async->events)
-		comedi_event(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d)

commit 22499048e328469d228bbcbeb32e6c7de3322025
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:55 2014 -0700

    staging: comedi: pcmmio: return void from pcmmio_start_intr()
    
    This function always returns '0' so the comedi_event() is never done by the
    callers.
    
    Change the return type to void and remove the comedi_event() dead code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 244cadf0b13d..fc40ee2b34e9 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -406,8 +406,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 }
 
 /* devpriv->spinlock is already locked */
-static int pcmmio_start_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
+static void pcmmio_start_intr(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -434,8 +434,6 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 	/* set polarity and enable interrupts */
 	pcmmio_dio_write(dev, pol_bits, PCMMIO_PAGE_POL, 0);
 	pcmmio_dio_write(dev, bits, PCMMIO_PAGE_ENAB, 0);
-
-	return 0;
 }
 
 static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -458,7 +456,6 @@ static int pcmmio_inttrig_start_intr(struct comedi_device *dev,
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
-	int event = 0;
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
@@ -466,12 +463,9 @@ static int pcmmio_inttrig_start_intr(struct comedi_device *dev,
 	spin_lock_irqsave(&devpriv->spinlock, flags);
 	s->async->inttrig = NULL;
 	if (devpriv->active)
-		event = pcmmio_start_intr(dev, s);
+		pcmmio_start_intr(dev, s);
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
-	if (event)
-		comedi_event(dev, s);
-
 	return 1;
 }
 
@@ -483,7 +477,6 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
-	int event = 0;
 
 	spin_lock_irqsave(&devpriv->spinlock, flags);
 	devpriv->active = 1;
@@ -494,13 +487,10 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmmio_inttrig_start_intr;
 	else	/* TRIG_NOW */
-		event = pcmmio_start_intr(dev, s);
+		pcmmio_start_intr(dev, s);
 
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
-	if (event)
-		comedi_event(dev, s);
-
 	return 0;
 }
 

commit 811ba919e469b2c96562119dfee3f93a490f4990
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:54 2014 -0700

    staging: comedi: pcmmio: 'stop_count' is always 'stop_arg'
    
    When the cmd->stop_src == TRIG_COUNT, the 'stop_count' is the cmd->stop_arg.
    For any other stop_src the 'stop_count' is 0, which is also the cmd->stop_arg.
    
    Simplify the 'stop_count' initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 67b66baf49ba..244cadf0b13d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -488,11 +488,7 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	spin_lock_irqsave(&devpriv->spinlock, flags);
 	devpriv->active = 1;
 
-	/* Set up end of acquisition. */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->stop_count = cmd->stop_arg;
-	else	/* TRIG_NONE */
-		devpriv->stop_count = 0;
+	devpriv->stop_count = cmd->stop_arg;
 
 	/* Set up start of acquisition. */
 	if (cmd->start_src == TRIG_INT)

commit 1ea37fd27a453e48dab31bdd3843d8569857f1e6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:53 2014 -0700

    staging: comedi: pcmmio: remove "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediately generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 2c9a842c5e46..67b66baf49ba 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -415,13 +415,6 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 	unsigned int pol_bits = 0;
 	int i;
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count == 0) {
-		/* An empty acquisition! */
-		s->async->events |= COMEDI_CB_EOA;
-		devpriv->active = 0;
-		return 1;
-	}
-
 	devpriv->enabled_mask = 0;
 	devpriv->active = 1;
 	if (cmd->chanlist) {
@@ -549,16 +542,10 @@ static int pcmmio_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-	default:
-		break;
-	}
 
 	if (err)
 		return 3;

commit 4b01383a66e36a42af803a14de36ed7de179024a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:14 2014 -0700

    staging: comedi: pcmmio: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index fed7e77e0305..2c9a842c5e46 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -192,8 +192,6 @@ struct pcmmio_private {
 	unsigned int enabled_mask;
 	unsigned int stop_count;
 	unsigned int active:1;
-
-	unsigned int ao_readback[8];
 };
 
 static void pcmmio_dio_write(struct comedi_device *dev, unsigned int val,
@@ -655,21 +653,6 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int pcmmio_ao_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
-{
-	struct pcmmio_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
-
-	return insn->n;
-}
-
 static int pcmmio_ao_eoc(struct comedi_device *dev,
 			 struct comedi_subdevice *s,
 			 struct comedi_insn *insn,
@@ -688,11 +671,9 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-	struct pcmmio_private *devpriv = dev->private;
 	unsigned long iobase = dev->iobase;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
-	unsigned int val = devpriv->ao_readback[chan];
 	unsigned char cmd = 0;
 	int ret;
 	int i;
@@ -719,7 +700,7 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 		return ret;
 
 	for (i = 0; i < insn->n; i++) {
-		val = data[i];
+		unsigned int val = data[i];
 
 		/* write the data to the channel */
 		outb(val & 0xff, iobase + PCMMIO_AO_LSB_REG);
@@ -731,7 +712,7 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 		if (ret)
 			return ret;
 
-		devpriv->ao_readback[chan] = val;
+		s->readback[chan] = val;
 	}
 
 	return insn->n;
@@ -796,8 +777,12 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan	= 8;
 	s->maxdata	= 0xffff;
 	s->range_table	= &pcmmio_ao_ranges;
-	s->insn_read	= pcmmio_ao_insn_read;
 	s->insn_write	= pcmmio_ao_insn_write;
+	s->insn_read	= comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
 
 	/* initialize the resource enable register by clearing it */
 	outb(0, dev->iobase + PCMMIO_AO_RESOURCE_ENA_REG);

commit 29791cf5cc0a5d1c7b14dd6b8d31ff584c4b02af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:57 2014 -0700

    staging: comedi: pcmmio: remove 'continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead and remove the member.
    
    Refactor pcmmio_handle_dio_intr() to remove an indent level.
    
    For aesthetics, change the switch in pcmmio_cmd() to an if/else.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 76b67a6e8ca8..fed7e77e0305 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -192,7 +192,6 @@ struct pcmmio_private {
 	unsigned int enabled_mask;
 	unsigned int stop_count;
 	unsigned int active:1;
-	unsigned int continuous:1;
 
 	unsigned int ao_readback[8];
 };
@@ -371,15 +370,12 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 	}
 
 	/* Check for end of acquisition. */
-	if (!devpriv->continuous) {
-		/* stop_src == TRIG_COUNT */
-		if (devpriv->stop_count > 0) {
-			devpriv->stop_count--;
-			if (devpriv->stop_count == 0) {
-				s->async->events |= COMEDI_CB_EOA;
-				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-				pcmmio_stop_intr(dev, s);
-			}
+	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count > 0) {
+		devpriv->stop_count--;
+		if (devpriv->stop_count == 0) {
+			s->async->events |= COMEDI_CB_EOA;
+			/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+			pcmmio_stop_intr(dev, s);
 		}
 	}
 
@@ -421,7 +417,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 	unsigned int pol_bits = 0;
 	int i;
 
-	if (!devpriv->continuous && devpriv->stop_count == 0) {
+	if (cmd->stop_src == TRIG_COUNT && devpriv->stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
 		devpriv->active = 0;
@@ -502,17 +498,10 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->active = 1;
 
 	/* Set up end of acquisition. */
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		devpriv->continuous = 0;
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->stop_count = cmd->stop_arg;
-		break;
-	default:
-		/* TRIG_NONE */
-		devpriv->continuous = 1;
+	else	/* TRIG_NONE */
 		devpriv->stop_count = 0;
-		break;
-	}
 
 	/* Set up start of acquisition. */
 	if (cmd->start_src == TRIG_INT)

commit aecbc17285caeae98d5e729d02fdc93ded7a0186
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:56 2014 -0700

    staging: comedi: pcmmio: use comedi_cmd pointer
    
    Use a local variable to access the comedi_cmd as a pointer instead
    of getting to from the comedi_subdevice pointer.
    
    Remove the unnecessary local variables used for the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 2d185136db78..76b67a6e8ca8 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -339,8 +339,8 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 				   unsigned int triggered)
 {
 	struct pcmmio_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int oldevents = s->async->events;
-	unsigned int len = s->async->cmd.chanlist_len;
 	unsigned int val = 0;
 	unsigned long flags;
 	int i;
@@ -353,8 +353,8 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 	if (!(triggered & devpriv->enabled_mask))
 		goto done;
 
-	for (i = 0; i < len; i++) {
-		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 
 		if (triggered & (1 << chan))
 			val |= (1 << i);

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index bb29ecfcfef4..2d185136db78 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -361,8 +361,8 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 	}
 
 	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s->async, val) &&
-	    comedi_buf_put(s->async, val >> 16)) {
+	if (comedi_buf_put(s, val) &&
+	    comedi_buf_put(s, val >> 16)) {
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 	} else {
 		/* Overflow! Stop acquisition!! */

commit 725ce0d4738172c1cccea233111bf078785d660a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:05 2014 -0700

    staging: comedi: pcmmio: fix the cmd->start_arg use for TRIG_INT
    
    This driver supports a cmd->start_src of TRIG_NOW or TRIG_INT. The
    cmd->start_arg is trivially validated for both sources to be 0.
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid
    trig_num that is used by the async (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used
    to check the trig_num instead of the open coded value.
    
    For aesthetics, refactor the (*do_cmd) to use if/else instead if the
    switch when handling the cmd->start_src.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index e89bca845349..bb29ecfcfef4 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -464,18 +464,16 @@ static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
- */
-static int
-pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-			  unsigned int trignum)
+static int pcmmio_inttrig_start_intr(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int trig_num)
 {
 	struct pcmmio_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	spin_lock_irqsave(&devpriv->spinlock, flags);
@@ -517,15 +515,11 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Set up start of acquisition. */
-	switch (cmd->start_src) {
-	case TRIG_INT:
+	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmmio_inttrig_start_intr;
-		break;
-	default:
-		/* TRIG_NOW */
+	else	/* TRIG_NOW */
 		event = pcmmio_start_intr(dev, s);
-		break;
-	}
+
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 	if (event)

commit 6fd13f761ca2e1747e0b136e241fb4aaab29f593
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:10 2014 -0700

    staging: comedi: pcmmio: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input and output end-of-
    conversions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index c388f7f32227..e89bca845349 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -589,16 +589,17 @@ static int pcmmio_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static int pcmmio_ai_wait_for_eoc(unsigned long iobase, unsigned int timeout)
+static int pcmmio_ai_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
 {
 	unsigned char status;
 
-	while (timeout--) {
-		status = inb(iobase + PCMMIO_AI_STATUS_REG);
-		if (status & PCMMIO_AI_STATUS_DATA_READY)
-			return 0;
-	}
-	return -ETIME;
+	status = inb(dev->iobase + PCMMIO_AI_STATUS_REG);
+	if (status & PCMMIO_AI_STATUS_DATA_READY)
+		return 0;
+	return -EBUSY;
 }
 
 static int pcmmio_ai_insn_read(struct comedi_device *dev,
@@ -643,7 +644,8 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 	cmd |= PCMMIO_AI_CMD_RANGE(range);
 
 	outb(cmd, iobase + PCMMIO_AI_CMD_REG);
-	ret = pcmmio_ai_wait_for_eoc(iobase, 100000);
+
+	ret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);
 	if (ret)
 		return ret;
 
@@ -652,7 +654,8 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		outb(cmd, iobase + PCMMIO_AI_CMD_REG);
-		ret = pcmmio_ai_wait_for_eoc(iobase, 100000);
+
+		ret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);
 		if (ret)
 			return ret;
 
@@ -684,16 +687,17 @@ static int pcmmio_ao_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int pcmmio_ao_wait_for_eoc(unsigned long iobase, unsigned int timeout)
+static int pcmmio_ao_eoc(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
 {
 	unsigned char status;
 
-	while (timeout--) {
-		status = inb(iobase + PCMMIO_AO_STATUS_REG);
-		if (status & PCMMIO_AO_STATUS_DATA_READY)
-			return 0;
-	}
-	return -ETIME;
+	status = inb(dev->iobase + PCMMIO_AO_STATUS_REG);
+	if (status & PCMMIO_AO_STATUS_DATA_READY)
+		return 0;
+	return -EBUSY;
 }
 
 static int pcmmio_ao_insn_write(struct comedi_device *dev,
@@ -726,7 +730,8 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 	outb(PCMMIO_AO_LSB_SPAN(range), iobase + PCMMIO_AO_LSB_REG);
 	outb(0, iobase + PCMMIO_AO_MSB_REG);
 	outb(cmd | PCMMIO_AO_CMD_WR_SPAN_UPDATE, iobase + PCMMIO_AO_CMD_REG);
-	ret = pcmmio_ao_wait_for_eoc(iobase, 100000);
+
+	ret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);
 	if (ret)
 		return ret;
 
@@ -738,7 +743,8 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 		outb((val >> 8) & 0xff, iobase + PCMMIO_AO_MSB_REG);
 		outb(cmd | PCMMIO_AO_CMD_WR_CODE_UPDATE,
 		     iobase + PCMMIO_AO_CMD_REG);
-		ret = pcmmio_ao_wait_for_eoc(iobase, 100000);
+
+		ret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);
 		if (ret)
 			return ret;
 

commit a92fe15636a06d2d6c6d1b046ca13f41322c4556
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:24 2013 -0700

    staging: comedi: pcmmio: fix final checkpatch warning
    
    Fis the last checkpatch.pl warning in this driver:
    
    WARNING: space prohibited between function name and open parenthesis '('
    +           comedi_buf_put (s->async, val >> 16)) {
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 8f79cdc00672..c388f7f32227 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -362,7 +362,7 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 
 	/* Write the scan to the buffer. */
 	if (comedi_buf_put(s->async, val) &&
-	    comedi_buf_put (s->async, val >> 16)) {
+	    comedi_buf_put(s->async, val >> 16)) {
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 	} else {
 		/* Overflow! Stop acquisition!! */

commit a88a6376de3e2faebbeb1afdb8ab9bad49676ce4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:23 2013 -0700

    staging: comedi: pcmmio: tidy up the multi-line comments
    
    Tidy up the multi-line comments are the beginning of the file to follow
    the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3bdbebe5d21d..8f79cdc00672 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1,76 +1,76 @@
 /*
-    comedi/drivers/pcmmio.c
-    Driver for Winsystems PC-104 based multifunction IO board.
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2007 Calin A. Culianu <calin@ajvar.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * pcmmio.c
+ * Driver for Winsystems PC-104 based multifunction IO board.
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2007 Calin A. Culianu <calin@ajvar.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
 /*
-Driver: pcmmio
-Description: A driver for the PCM-MIO multifunction board
-Devices: [Winsystems] PCM-MIO (pcmmio)
-Author: Calin Culianu <calin@ajvar.org>
-Updated: Wed, May 16 2007 16:21:10 -0500
-Status: works
-
-A driver for the relatively new PCM-MIO multifunction board from
-Winsystems.  This board is a PC-104 based I/O board.  It contains
-four subdevices:
-  subdevice 0 - 16 channels of 16-bit AI
-  subdevice 1 - 8 channels of 16-bit AO
-  subdevice 2 - first 24 channels of the 48 channel of DIO
-	(with edge-triggered interrupt support)
-  subdevice 3 - last 24 channels of the 48 channel DIO
-	(no interrupt support for this bank of channels)
-
-  Some notes:
-
-  Synchronous reads and writes are the only things implemented for AI and AO,
-  even though the hardware itself can do streaming acquisition, etc.  Anyone
-  want to add asynchronous I/O for AI/AO as a feature?  Be my guest...
-
-  Asynchronous I/O for the DIO subdevices *is* implemented, however!  They are
-  basically edge-triggered interrupts for any configuration of the first
-  24 DIO-lines.
-
-  Also note that this interrupt support is untested.
-
-  A few words about edge-detection IRQ support (commands on DIO):
-
-  * To use edge-detection IRQ support for the DIO subdevice, pass the IRQ
-    of the board to the comedi_config command.  The board IRQ is not jumpered
-    but rather configured through software, so any IRQ from 1-15 is OK.
-
-  * Due to the genericity of the comedi API, you need to create a special
-    comedi_command in order to use edge-triggered interrupts for DIO.
-
-  * Use comedi_commands with TRIG_NOW.  Your callback will be called each
-    time an edge is detected on the specified DIO line(s), and the data
-    values will be two sample_t's, which should be concatenated to form
-    one 32-bit unsigned int.  This value is the mask of channels that had
-    edges detected from your channel list.  Note that the bits positions
-    in the mask correspond to positions in your chanlist when you
-    specified the command and *not* channel id's!
-
- *  To set the polarity of the edge-detection interrupts pass a nonzero value
-    for either CR_RANGE or CR_AREF for edge-up polarity, or a zero
-    value for both CR_RANGE and CR_AREF if you want edge-down polarity.
-
-Configuration Options:
-  [0] - I/O port base address
-  [1] - IRQ (optional -- for edge-detect interrupt support only,
-	leave out if you don't need this feature)
-*/
+ * Driver: pcmmio
+ * Description: A driver for the PCM-MIO multifunction board
+ * Devices: (Winsystems) PCM-MIO [pcmmio]
+ * Author: Calin Culianu <calin@ajvar.org>
+ * Updated: Wed, May 16 2007 16:21:10 -0500
+ * Status: works
+ *
+ * A driver for the PCM-MIO multifunction board from Winsystems. This
+ * is a PC-104 based I/O board. It contains four subdevices:
+ *
+ *	subdevice 0 - 16 channels of 16-bit AI
+ *	subdevice 1 - 8 channels of 16-bit AO
+ *	subdevice 2 - first 24 channels of the 48 channel of DIO
+ *			(with edge-triggered interrupt support)
+ *	subdevice 3 - last 24 channels of the 48 channel DIO
+ *			(no interrupt support for this bank of channels)
+ *
+ * Some notes:
+ *
+ * Synchronous reads and writes are the only things implemented for analog
+ * input and output. The hardware itself can do streaming acquisition, etc.
+ *
+ * Asynchronous I/O for the DIO subdevices *is* implemented, however! They
+ * are basically edge-triggered interrupts for any configuration of the
+ * channels in subdevice 2.
+ *
+ * Also note that this interrupt support is untested.
+ *
+ * A few words about edge-detection IRQ support (commands on DIO):
+ *
+ * To use edge-detection IRQ support for the DIO subdevice, pass the IRQ
+ * of the board to the comedi_config command. The board IRQ is not jumpered
+ * but rather configured through software, so any IRQ from 1-15 is OK.
+ *
+ * Due to the genericity of the comedi API, you need to create a special
+ * comedi_command in order to use edge-triggered interrupts for DIO.
+ *
+ * Use comedi_commands with TRIG_NOW.  Your callback will be called each
+ * time an edge is detected on the specified DIO line(s), and the data
+ * values will be two sample_t's, which should be concatenated to form
+ * one 32-bit unsigned int. This value is the mask of channels that had
+ * edges detected from your channel list. Note that the bits positions
+ * in the mask correspond to positions in your chanlist when you
+ * specified the command and *not* channel id's!
+ *
+ * To set the polarity of the edge-detection interrupts pass a nonzero value
+ * for either CR_RANGE or CR_AREF for edge-up polarity, or a zero
+ * value for both CR_RANGE and CR_AREF if you want edge-down polarity.
+ *
+ * Configuration Options:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional -- for edge-detect interrupt support only,
+ *		leave out if you don't need this feature)
+ */
 
 #include <linux/module.h>
 #include <linux/interrupt.h>

commit 500821f3125b4f679a87f32aa34993f47bfb3c96
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:22 2013 -0700

    staging: comedi: pcmmio: update the MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something more usefull than the
    generic "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6fd79a7002ed..3bdbebe5d21d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -856,5 +856,5 @@ static struct comedi_driver pcmmio_driver = {
 module_comedi_driver(pcmmio_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for Winsystems PCM-MIO PC/104 board");
 MODULE_LICENSE("GPL");

commit 748cfd987bc93c7af88d19e206226a307a3e0b76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:21 2013 -0700

    staging: comedi: pcmmio: return '0' after successful attach
    
    The comedi core expects the (*attach) functions to return < 0 to indicate
    an error or >= 0 for success. Change the return to '0' as that is more
    typical.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f3cfe7b14adf..6fd79a7002ed 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -320,6 +320,7 @@ static void pcmmio_reset(struct comedi_device *dev)
 	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);
 }
 
+/* devpriv->spinlock is already locked */
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -410,6 +411,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+/* devpriv->spinlock is already locked */
 static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -842,7 +844,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits	= pcmmio_dio_insn_bits;
 	s->insn_config	= pcmmio_dio_insn_config;
 
-	return 1;
+	return 0;
 }
 
 static struct comedi_driver pcmmio_driver = {

commit 23bafad0d12e4a6cc903d0955be359b9509dc5ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:20 2013 -0700

    staging: comedi: pcmmio: cleanup the private data
    
    Fix the types of some of the private data members. The 'enabled_mask' and
    'stop_count' should be unsigned int values. The 'active' and 'continuous'
    members are flags, change them to unsigned int bit fields.
    
    Remove the 'sprivs' pointer. This should have been removed when the subdevice
    private data was removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 486fa69c4639..f3cfe7b14adf 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -189,12 +189,11 @@ static const struct comedi_lrange pcmmio_ao_ranges = {
 struct pcmmio_private {
 	spinlock_t pagelock;	/* protects the page registers */
 	spinlock_t spinlock;	/* protects the member variables */
-	int enabled_mask;
-	int active;
-	int stop_count;
-	int continuous;
+	unsigned int enabled_mask;
+	unsigned int stop_count;
+	unsigned int active:1;
+	unsigned int continuous:1;
 
-	struct pcmmio_subdev_private *sprivs;
 	unsigned int ao_readback[8];
 };
 

commit f41520de5b42c45dc036bf6017e9af522ce562c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:19 2013 -0700

    staging: comedi: pcmmio: remove unused defines
    
    These defines are not longer used in the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index ed91b027dacb..486fa69c4639 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -166,26 +166,6 @@ Configuration Options:
 #define PCMMIO_PAGE_INT_ID			3
 #define PCMMIO_PAGE_REG(x)			(0x18 + (x))
 
-/* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
-#define CHANS_PER_PORT   8
-#define PORTS_PER_ASIC   6
-#define INTR_PORTS_PER_ASIC   3
-#define MAX_CHANS_PER_SUBDEV 24	/* number of channels per comedi subdevice */
-#define PORTS_PER_SUBDEV (MAX_CHANS_PER_SUBDEV/CHANS_PER_PORT)
-#define CHANS_PER_ASIC (CHANS_PER_PORT*PORTS_PER_ASIC)
-#define INTR_CHANS_PER_ASIC 24
-#define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
-#define MAX_DIO_CHANS   (PORTS_PER_ASIC*1*CHANS_PER_PORT)
-#define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
-#define CALC_N_DIO_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
-/* IO Memory sizes */
-#define ASIC_IOSIZE (0x0B)
-#define PCMMIO48_IOSIZE ASIC_IOSIZE
-
-#define NUM_PAGED_REGS 3
-#define NUM_PAGES 4
-#define FIRST_PAGED_REG 0x8
-
 static const struct comedi_lrange pcmmio_ai_ranges = {
 	4, {
 		BIP_RANGE(5),

commit c5b970aeb9c19208abeabcb675194d5d6e9cfe68
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:18 2013 -0700

    staging: comedi: pcmmio: tidy up pcmmio_start_intr()
    
    Refactor the function to remove some indent levels.
    
    Use pcmmio_dio_write() to write the polarity and enable paged registers
    instead of using the for () loop to write each register in the pages.
    
    The for () loop actually has a bug. It switches the page to the 'enab'
    registers for the first port then switches to the 'pol' registers for
    all remaining writes. It also was not using the pagelock spinlock to
    protect the writes to the page registers. Using the pcmmio_dio_write()
    helper ensures that the writes to the paged registers complete correctly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f61f9ced5d8f..ed91b027dacb 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -329,11 +329,6 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void switch_page(struct comedi_device *dev, int page)
-{
-	outb(PCMMIO_PAGE(page), dev->iobase + PCMMIO_PAGE_LOCK_REG);
-}
-
 static void pcmmio_reset(struct comedi_device *dev)
 {
 	/* Clear all the DIO port bits */
@@ -440,46 +435,38 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmmio_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int bits = 0;
+	unsigned int pol_bits = 0;
+	int i;
 
 	if (!devpriv->continuous && devpriv->stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
 		devpriv->active = 0;
 		return 1;
-	} else {
-		unsigned bits = 0, pol_bits = 0, n;
-		int nports, firstport, port;
-		struct comedi_cmd *cmd = &s->async->cmd;
-
-		devpriv->enabled_mask = 0;
-		devpriv->active = 1;
-		nports = 24 / CHANS_PER_PORT;
-		firstport = 0 / CHANS_PER_PORT;
-		if (cmd->chanlist) {
-			for (n = 0; n < cmd->chanlist_len; n++) {
-				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
-				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					     || CR_RANGE(cmd->
-							 chanlist[n]) ? 1U : 0U)
-				    << CR_CHAN(cmd->chanlist[n]);
-			}
-		}
-		bits &= ((0x1 << 24) - 1) << 0;
-		devpriv->enabled_mask = bits;
-
-		switch_page(dev, PCMMIO_PAGE_ENAB);
-		for (port = firstport; port < firstport + nports; ++port) {
-			unsigned enab, pol;
-
-			enab = bits >> (0 + (port - firstport) * 8) & 0xff;
-			pol = pol_bits >> (0 + (port - firstport) * 8) & 0xff;
+	}
 
-			/* set enab intrs for this subdev.. */
-			outb(enab, dev->iobase + PCMMIO_PAGE_REG(port));
-			switch_page(dev, PCMMIO_PAGE_POL);
-			outb(pol, dev->iobase + PCMMIO_PAGE_REG(port));
+	devpriv->enabled_mask = 0;
+	devpriv->active = 1;
+	if (cmd->chanlist) {
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int chanspec = cmd->chanlist[i];
+			unsigned int chan = CR_CHAN(chanspec);
+			unsigned int range = CR_RANGE(chanspec);
+			unsigned int aref = CR_AREF(chanspec);
+
+			bits |= (1 << chan);
+			pol_bits |= (((aref || range) ? 1 : 0) << chan);
 		}
 	}
+	bits &= ((1 << s->n_chan) - 1);
+	devpriv->enabled_mask = bits;
+
+	/* set polarity and enable interrupts */
+	pcmmio_dio_write(dev, pol_bits, PCMMIO_PAGE_POL, 0);
+	pcmmio_dio_write(dev, bits, PCMMIO_PAGE_ENAB, 0);
+
 	return 0;
 }
 

commit 2eb6b51822ab1c3b7e8b62564ba86fed6c629297
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:17 2013 -0700

    staging: comedi: pcmmio: setup irq routing during (*attach)
    
    To use interrupts the IRQ routing must be configured and interrupts
    enabled. Currently both steps are being handled in pcmmio_start_intr().
    
    Move the code that sets the IRQ routing into the attach of the board.
    At this point interrupts are still disabled. The enable and polarity
    bits just need to be set in pcmmio_start_intr() to enable them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a5b81ef2771f..f61f9ced5d8f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -90,6 +90,8 @@ Configuration Options:
 #define PCMMIO_AI_CMD_ODD_CHAN			(1 << 6)
 #define PCMMIO_AI_CMD_CHAN_SEL(x)		(((x) & 0x3) << 4)
 #define PCMMIO_AI_CMD_RANGE(x)			(((x) & 0x3) << 2)
+#define PCMMIO_RESOURCE_REG			0x02
+#define PCMMIO_RESOURCE_IRQ(x)			(((x) & 0xf) << 0)
 #define PCMMIO_AI_STATUS_REG			0x03
 #define PCMMIO_AI_STATUS_DATA_READY		(1 << 7)
 #define PCMMIO_AI_STATUS_DATA_DMA_PEND		(1 << 6)
@@ -99,7 +101,10 @@ Configuration Options:
 #define PCMMIO_AI_STATUS_REG_SEL		(1 << 3)
 #define PCMMIO_AI_STATUS_CMD_DRQ_ENA		(1 << 1)
 #define PCMMIO_AI_STATUS_IRQ_ENA		(1 << 0)
-#define PCMMIO_AI_RESOURCE_REG			0x03
+#define PCMMIO_AI_RES_ENA_REG			0x03
+#define PCMMIO_AI_RES_ENA_CMD_REG_ACCESS	(0 << 3)
+#define PCMMIO_AI_RES_ENA_AI_RES_ACCESS		(1 << 3)
+#define PCMMIO_AI_RES_ENA_DIO_RES_ACCESS	(1 << 4)
 #define PCMMIO_AI_2ND_ADC_OFFSET		0x04
 
 #define PCMMIO_AO_LSB_REG			0x08
@@ -462,23 +467,6 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 		bits &= ((0x1 << 24) - 1) << 0;
 		devpriv->enabled_mask = bits;
 
-		{
-			/*
-			 * the below code configures the board
-			 * to use a specific IRQ from 0-15.
-			 */
-			unsigned char b;
-			/*
-			 * set resource enable register
-			 * to enable IRQ operation
-			 */
-			outb(1 << 4, dev->iobase + 3);
-			/* set bits 0-3 of b to the irq number from 0-15 */
-			b = dev->irq & ((1 << 4) - 1);
-			outb(b, dev->iobase + 2);
-			/* done, we told the board what irq to use */
-		}
-
 		switch_page(dev, PCMMIO_PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab, pol;
@@ -814,8 +802,15 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (it->options[1]) {
 		ret = request_irq(it->options[1], interrupt_pcmmio, 0,
 				  dev->board_name, dev);
-		if (ret == 0)
+		if (ret == 0) {
 			dev->irq = it->options[1];
+
+			/* configure the interrupt routing on the board */
+			outb(PCMMIO_AI_RES_ENA_DIO_RES_ACCESS,
+			     dev->iobase + PCMMIO_AI_RES_ENA_REG);
+			outb(PCMMIO_RESOURCE_IRQ(dev->irq),
+			     dev->iobase + PCMMIO_RESOURCE_REG);
+		}
 	}
 
 	ret = comedi_alloc_subdevices(dev, 4);
@@ -832,9 +827,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_read	= pcmmio_ai_insn_read;
 
 	/* initialize the resource enable register by clearing it */
-	outb(0, dev->iobase + PCMMIO_AI_RESOURCE_REG);
-	outb(0,
-	     dev->iobase + PCMMIO_AI_2ND_ADC_OFFSET + PCMMIO_AI_RESOURCE_REG);
+	outb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,
+	     dev->iobase + PCMMIO_AI_RES_ENA_REG);
+	outb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,
+	     dev->iobase + PCMMIO_AI_RES_ENA_REG + PCMMIO_AI_2ND_ADC_OFFSET);
 
 	/* Analog Output subdevice */
 	s = &dev->subdevices[1];

commit 5181886e781d0abf58b6f229c205238f17ec788b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:16 2013 -0700

    staging: comedi: pcmmio: only hook up async command support if irq is available
    
    Refactor the board attach so that the async commands support is only
    hooked up if the irq is actually available.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 055781dc7875..a5b81ef2771f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -807,6 +807,16 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	spin_lock_init(&devpriv->pagelock);
+	spin_lock_init(&devpriv->spinlock);
+
+	pcmmio_reset(dev);
+
+	if (it->options[1]) {
+		ret = request_irq(it->options[1], interrupt_pcmmio, 0,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = it->options[1];
+	}
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
@@ -851,18 +861,14 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table	= &range_digital;
 	s->insn_bits	= pcmmio_dio_insn_bits;
 	s->insn_config	= pcmmio_dio_insn_config;
-
-	dev->read_subdev = s;
-	s->subdev_flags	|= SDF_CMD_READ;
-	s->len_chanlist	= s->n_chan;
-	s->cancel	= pcmmio_cancel;
-	s->do_cmd	= pcmmio_cmd;
-	s->do_cmdtest	= pcmmio_cmdtest;
-
-	devpriv->active = 0;
-	devpriv->stop_count = 0;
-
-	spin_lock_init(&devpriv->spinlock);
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->cancel	= pcmmio_cancel;
+		s->do_cmd	= pcmmio_cmd;
+		s->do_cmdtest	= pcmmio_cmdtest;
+	}
 
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[3];
@@ -874,15 +880,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits	= pcmmio_dio_insn_bits;
 	s->insn_config	= pcmmio_dio_insn_config;
 
-	pcmmio_reset(dev);
-
-	if (it->options[1]) {
-		ret = request_irq(it->options[1], interrupt_pcmmio, 0,
-				  dev->board_name, dev);
-		if (ret == 0)
-			dev->irq = it->options[1];
-	}
-
 	return 1;
 }
 

commit d7c41e83e2c3ae970d41187ae31fad50ccd63856
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:15 2013 -0700

    staging: comedi: pcmmio: tidy up pcmmio_handle_dio_intr()
    
    Refactor the code to remove some of the indent levels.
    
    Remove 'mytrig', the shift and mask end up making it the same as 'triggered'
    anyway.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 37471bb3d99c..055781dc7875 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -359,50 +359,51 @@ static void pcmmio_handle_dio_intr(struct comedi_device *dev,
 				   unsigned int triggered)
 {
 	struct pcmmio_private *devpriv = dev->private;
+	unsigned int oldevents = s->async->events;
+	unsigned int len = s->async->cmd.chanlist_len;
+	unsigned int val = 0;
 	unsigned long flags;
-	unsigned oldevents;
+	int i;
 
 	spin_lock_irqsave(&devpriv->spinlock, flags);
 
-	oldevents = s->async->events;
+	if (!devpriv->active)
+		goto done;
 
-	if (devpriv->active) {
-		unsigned mytrig = ((triggered >> 0) & ((1 << 24) - 1)) << 0;
-		if (mytrig & devpriv->enabled_mask) {
-			unsigned int val = 0;
-			unsigned int n, ch, len;
+	if (!(triggered & devpriv->enabled_mask))
+		goto done;
 
-			len = s->async->cmd.chanlist_len;
-			for (n = 0; n < len; n++) {
-				ch = CR_CHAN(s->async->cmd.chanlist[n]);
-				if (mytrig & (1U << ch))
-					val |= (1U << n);
-			}
-			/* Write the scan to the buffer. */
-			if (comedi_buf_put(s->async, val) &&
-				comedi_buf_put (s->async, val >> 16)) {
-				s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-			} else {
-				/* Overflow! Stop acquisition!! */
+	for (i = 0; i < len; i++) {
+		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);
+
+		if (triggered & (1 << chan))
+			val |= (1 << i);
+	}
+
+	/* Write the scan to the buffer. */
+	if (comedi_buf_put(s->async, val) &&
+	    comedi_buf_put (s->async, val >> 16)) {
+		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	} else {
+		/* Overflow! Stop acquisition!! */
+		/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+		pcmmio_stop_intr(dev, s);
+	}
+
+	/* Check for end of acquisition. */
+	if (!devpriv->continuous) {
+		/* stop_src == TRIG_COUNT */
+		if (devpriv->stop_count > 0) {
+			devpriv->stop_count--;
+			if (devpriv->stop_count == 0) {
+				s->async->events |= COMEDI_CB_EOA;
 				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 				pcmmio_stop_intr(dev, s);
 			}
-
-			/* Check for end of acquisition. */
-			if (!devpriv->continuous) {
-				/* stop_src == TRIG_COUNT */
-				if (devpriv->stop_count > 0) {
-					devpriv->stop_count--;
-					if (devpriv->stop_count == 0) {
-						s->async->events |= COMEDI_CB_EOA;
-						/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-						pcmmio_stop_intr(dev, s);
-					}
-				}
-			}
 		}
 	}
 
+done:
 	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 	if (oldevents != s->async->events)

commit 967e7e5a99cfdbc8a22e491a006875328e9875b1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:14 2013 -0700

    staging: comedi: pcmmio: factor the trigger handling out of interrupt_pcmmio()
    
    Factor the code that actually handles the digital input triggers out of
    the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 850a6d03ef60..37471bb3d99c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -354,10 +354,64 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);
 }
 
+static void pcmmio_handle_dio_intr(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int triggered)
+{
+	struct pcmmio_private *devpriv = dev->private;
+	unsigned long flags;
+	unsigned oldevents;
+
+	spin_lock_irqsave(&devpriv->spinlock, flags);
+
+	oldevents = s->async->events;
+
+	if (devpriv->active) {
+		unsigned mytrig = ((triggered >> 0) & ((1 << 24) - 1)) << 0;
+		if (mytrig & devpriv->enabled_mask) {
+			unsigned int val = 0;
+			unsigned int n, ch, len;
+
+			len = s->async->cmd.chanlist_len;
+			for (n = 0; n < len; n++) {
+				ch = CR_CHAN(s->async->cmd.chanlist[n]);
+				if (mytrig & (1U << ch))
+					val |= (1U << n);
+			}
+			/* Write the scan to the buffer. */
+			if (comedi_buf_put(s->async, val) &&
+				comedi_buf_put (s->async, val >> 16)) {
+				s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+			} else {
+				/* Overflow! Stop acquisition!! */
+				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+				pcmmio_stop_intr(dev, s);
+			}
+
+			/* Check for end of acquisition. */
+			if (!devpriv->continuous) {
+				/* stop_src == TRIG_COUNT */
+				if (devpriv->stop_count > 0) {
+					devpriv->stop_count--;
+					if (devpriv->stop_count == 0) {
+						s->async->events |= COMEDI_CB_EOA;
+						/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+						pcmmio_stop_intr(dev, s);
+					}
+				}
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&devpriv->spinlock, flags);
+
+	if (oldevents != s->async->events)
+		comedi_event(dev, s);
+}
+
 static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int triggered;
 	unsigned char int_pend;
@@ -371,57 +425,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	triggered = pcmmio_dio_read(dev, PCMMIO_PAGE_INT_ID, 0);
 	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);
 
-	if (triggered) {
-		/* TODO here: dispatch io lines to subdevs with commands */
-		unsigned long flags;
-		unsigned oldevents;
-
-		spin_lock_irqsave(&devpriv->spinlock, flags);
-
-		oldevents = s->async->events;
-
-		if (devpriv->active) {
-			unsigned mytrig = ((triggered >> 0) & ((1 << 24) - 1)) << 0;
-			if (mytrig & devpriv->enabled_mask) {
-				unsigned int val = 0;
-				unsigned int n, ch, len;
-
-				len = s->async->cmd.chanlist_len;
-				for (n = 0; n < len; n++) {
-					ch = CR_CHAN(s->async->cmd.chanlist[n]);
-					if (mytrig & (1U << ch))
-						val |= (1U << n);
-				}
-				/* Write the scan to the buffer. */
-				if (comedi_buf_put(s->async, val) &&
-				    comedi_buf_put (s->async, val >> 16)) {
-					s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-				} else {
-					/* Overflow! Stop acquisition!! */
-					/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-					pcmmio_stop_intr(dev, s);
-				}
-
-				/* Check for end of acquisition. */
-				if (!devpriv->continuous) {
-					/* stop_src == TRIG_COUNT */
-					if (devpriv->stop_count > 0) {
-						devpriv->stop_count--;
-						if (devpriv->stop_count == 0) {
-							s->async->events |= COMEDI_CB_EOA;
-							/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-							pcmmio_stop_intr(dev, s);
-						}
-					}
-				}
-			}
-		}
-
-		spin_unlock_irqrestore(&devpriv->spinlock, flags);
-
-		if (oldevents != s->async->events)
-			comedi_event(dev, s);
-	}
+	pcmmio_handle_dio_intr(dev, s, triggered);
 
 	return IRQ_HANDLED;
 }

commit eacc792d2c6441570d90dec274a5379f562cd40b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:13 2013 -0700

    staging: comedi: pcmmio: use pcmmio_dio_{read, write}() in interrupt_pcmmio()
    
    Use the helper functions to read/write the PCMMIO_PAGE_INT_ID registers. This
    allows removing the need to lock/unlock the spinlock 'pagelock' and removes the
    need for the for () loop that did the read/write of the 3 paged registers.
    
    Also, remove the need for the 'got1' local variable by just returning 'IRQ_NONE'
    if there are not interrupts pending.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5543ac959c94..850a6d03ef60 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -359,38 +359,17 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	unsigned triggered = 0;
-	int got1 = 0;
-	unsigned long flags;
+	unsigned int triggered;
 	unsigned char int_pend;
 
-	spin_lock_irqsave(&devpriv->pagelock, flags);
-
-	int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG);
-	int_pend &= 0x07;
-
-	if (int_pend) {
-		int port;
-		for (port = 0; port < INTR_PORTS_PER_ASIC; ++port) {
-			if (int_pend & (0x1 << port)) {
-				unsigned char io_lines_with_edges = 0;
-				switch_page(dev, PCMMIO_PAGE_INT_ID);
-				io_lines_with_edges = inb(dev->iobase +
-							PCMMIO_PAGE_REG(port));
-
-				/* clear pending interrupt */
-				if (io_lines_with_edges)
-					outb(0, dev->iobase +
-					     PCMMIO_PAGE_REG(port));
-
-				triggered |= io_lines_with_edges << port * 8;
-			}
-		}
-
-		++got1;
-	}
+	/* are there any interrupts pending */
+	int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG) & 0x07;
+	if (!int_pend)
+		return IRQ_NONE;
 
-	spin_unlock_irqrestore(&devpriv->pagelock, flags);
+	/* get, and clear, the pending interrupts */
+	triggered = pcmmio_dio_read(dev, PCMMIO_PAGE_INT_ID, 0);
+	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);
 
 	if (triggered) {
 		/* TODO here: dispatch io lines to subdevs with commands */
@@ -444,8 +423,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 			comedi_event(dev, s);
 	}
 
-	if (!got1)
-		return IRQ_NONE;	/* interrupt from other source */
 	return IRQ_HANDLED;
 }
 

commit cd756e3d1b95e8082c001bb75f8cbe2d67be86bd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:12 2013 -0700

    staging: comedi: pcmmio: cleanup indent levels in interrupt_pcmmio()
    
    Remove the extra indent levels in this function that resulted from
    code removed in previous patches.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 60463ecef47f..5543ac959c94 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -359,126 +359,90 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	unsigned triggered = 0;
 	int got1 = 0;
+	unsigned long flags;
+	unsigned char int_pend;
+
+	spin_lock_irqsave(&devpriv->pagelock, flags);
 
-			unsigned long flags;
-			unsigned triggered = 0;
-			/* it is an interrupt for ASIC #asic */
-			unsigned char int_pend;
-
-			spin_lock_irqsave(&devpriv->pagelock, flags);
-
-			int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG);
-			int_pend &= 0x07;
-
-			if (int_pend) {
-				int port;
-				for (port = 0; port < INTR_PORTS_PER_ASIC;
-				     ++port) {
-					if (int_pend & (0x1 << port)) {
-						unsigned char
-						    io_lines_with_edges = 0;
-						switch_page(dev, PCMMIO_PAGE_INT_ID);
-						io_lines_with_edges =
-						    inb(dev->iobase +
+	int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG);
+	int_pend &= 0x07;
+
+	if (int_pend) {
+		int port;
+		for (port = 0; port < INTR_PORTS_PER_ASIC; ++port) {
+			if (int_pend & (0x1 << port)) {
+				unsigned char io_lines_with_edges = 0;
+				switch_page(dev, PCMMIO_PAGE_INT_ID);
+				io_lines_with_edges = inb(dev->iobase +
 							PCMMIO_PAGE_REG(port));
 
-						if (io_lines_with_edges)
-							/*
-							 * clear pending
-							 * interrupt
-							 */
-							outb(0, dev->iobase +
-							     PCMMIO_PAGE_REG(port));
-
-						triggered |=
-						    io_lines_with_edges <<
-						    port * 8;
-					}
-				}
+				/* clear pending interrupt */
+				if (io_lines_with_edges)
+					outb(0, dev->iobase +
+					     PCMMIO_PAGE_REG(port));
 
-				++got1;
+				triggered |= io_lines_with_edges << port * 8;
 			}
+		}
 
-			spin_unlock_irqrestore(&devpriv->pagelock, flags);
-
-			if (triggered) {
-				/*
-				 * TODO here: dispatch io lines to subdevs
-				 * with commands..
-				 */
-						unsigned long flags;
-						unsigned oldevents;
-
-						spin_lock_irqsave(&devpriv->spinlock,
-								  flags);
-
-						oldevents = s->async->events;
-
-						if (devpriv->active) {
-							unsigned mytrig =
-							    ((triggered >> 0)
-							     &
-							     ((0x1 << 24) -
-							      1)) << 0;
-							if (mytrig &
-							    devpriv->enabled_mask) {
-								unsigned int val
-								    = 0;
-								unsigned int n,
-								    ch, len;
-
-								len =
-								    s->
-								    async->cmd.chanlist_len;
-								for (n = 0;
-								     n < len;
-								     n++) {
-									ch = CR_CHAN(s->async->cmd.chanlist[n]);
-									if (mytrig & (1U << ch))
-										val |= (1U << n);
-								}
-								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, val)
-								    &&
-								    comedi_buf_put
-								    (s->async,
-								     val >> 16)) {
-									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-								} else {
-									/* Overflow! Stop acquisition!! */
-									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-									pcmmio_stop_intr
-									    (dev,
-									     s);
-								}
-
-								/* Check for end of acquisition. */
-								if (!devpriv->continuous) {
-									/* stop_src == TRIG_COUNT */
-									if (devpriv->stop_count > 0) {
-										devpriv->stop_count--;
-										if (devpriv->stop_count == 0) {
-											s->async->events |= COMEDI_CB_EOA;
-											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-											pcmmio_stop_intr
-											    (dev,
-											     s);
-										}
-									}
-								}
-							}
-						}
+		++got1;
+	}
 
-						spin_unlock_irqrestore
-						    (&devpriv->spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->pagelock, flags);
 
-						if (oldevents !=
-						    s->async->events) {
-							comedi_event(dev, s);
-						}
+	if (triggered) {
+		/* TODO here: dispatch io lines to subdevs with commands */
+		unsigned long flags;
+		unsigned oldevents;
+
+		spin_lock_irqsave(&devpriv->spinlock, flags);
 
+		oldevents = s->async->events;
+
+		if (devpriv->active) {
+			unsigned mytrig = ((triggered >> 0) & ((1 << 24) - 1)) << 0;
+			if (mytrig & devpriv->enabled_mask) {
+				unsigned int val = 0;
+				unsigned int n, ch, len;
+
+				len = s->async->cmd.chanlist_len;
+				for (n = 0; n < len; n++) {
+					ch = CR_CHAN(s->async->cmd.chanlist[n]);
+					if (mytrig & (1U << ch))
+						val |= (1U << n);
+				}
+				/* Write the scan to the buffer. */
+				if (comedi_buf_put(s->async, val) &&
+				    comedi_buf_put (s->async, val >> 16)) {
+					s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+				} else {
+					/* Overflow! Stop acquisition!! */
+					/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+					pcmmio_stop_intr(dev, s);
+				}
+
+				/* Check for end of acquisition. */
+				if (!devpriv->continuous) {
+					/* stop_src == TRIG_COUNT */
+					if (devpriv->stop_count > 0) {
+						devpriv->stop_count--;
+						if (devpriv->stop_count == 0) {
+							s->async->events |= COMEDI_CB_EOA;
+							/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+							pcmmio_stop_intr(dev, s);
+						}
+					}
+				}
 			}
+		}
+
+		spin_unlock_irqrestore(&devpriv->spinlock, flags);
+
+		if (oldevents != s->async->events)
+			comedi_event(dev, s);
+	}
 
 	if (!got1)
 		return IRQ_NONE;	/* interrupt from other source */

commit 0cc9a4e4b65ffbd9668d31b2d59356b362c9ae39
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:11 2013 -0700

    staging: comedi: pcmmio: use comedi_legacy_detach() for (*detach)
    
    The (*detach) of this driver just calls comedi_legacy_detach(). Use that
    directly for the (*detach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 1e1f57ee8934..60463ecef47f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -940,16 +940,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-static void pcmmio_detach(struct comedi_device *dev)
-{
-	comedi_legacy_detach(dev);
-}
-
 static struct comedi_driver pcmmio_driver = {
 	.driver_name	= "pcmmio",
 	.module		= THIS_MODULE,
 	.attach		= pcmmio_attach,
-	.detach		= pcmmio_detach,
+	.detach		= comedi_legacy_detach,
 };
 module_comedi_driver(pcmmio_driver);
 

commit 35c5e88498a8856475f8001389020f47f36d9002
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:10 2013 -0700

    staging: comedi: pcmmio: remove subdevice private data
    
    Only subdevice[2], the dio interrupt subdevice, uses the subdevice private data.
    Move the members from struct pcmmio_subdev_private to struct pcmmio_private and
    remove the subdevice private data. This also allows removing the allocation and
    freeing of devpriv->sprivs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 8e00d12d7b1b..1e1f57ee8934 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -201,35 +201,13 @@ static const struct comedi_lrange pcmmio_ao_ranges = {
 	}
 };
 
-/* this structure is for data unique to this subdevice.  */
-struct pcmmio_subdev_private {
-
-	union {
-		struct {
-
-			/* The below is only used for intr subdevices */
-			struct {
-				/*
-				 * subdev-relative channel mask for channels
-				 * we are interested in
-				 */
-				int enabled_mask;
-				int active;
-				int stop_count;
-				int continuous;
-				spinlock_t spinlock;
-			} intr;
-		} dio;
-	};
-};
-
-/*
- * this structure is for data unique to this hardware driver.  If
- * several hardware drivers keep similar information in this structure,
- * feel free to suggest moving the variable to the struct comedi_device struct.
- */
 struct pcmmio_private {
 	spinlock_t pagelock;	/* protects the page registers */
+	spinlock_t spinlock;	/* protects the member variables */
+	int enabled_mask;
+	int active;
+	int stop_count;
+	int continuous;
 
 	struct pcmmio_subdev_private *sprivs;
 	unsigned int ao_readback[8];
@@ -366,10 +344,10 @@ static void pcmmio_reset(struct comedi_device *dev)
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
+	struct pcmmio_private *devpriv = dev->private;
 
-	subpriv->dio.intr.enabled_mask = 0;
-	subpriv->dio.intr.active = 0;
+	devpriv->enabled_mask = 0;
+	devpriv->active = 0;
 	s->async->inttrig = NULL;
 
 	/* disable all dio interrupts */
@@ -381,7 +359,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct pcmmio_subdev_private *subpriv = s->private;
 	int got1 = 0;
 
 			unsigned long flags;
@@ -433,21 +410,19 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 						unsigned long flags;
 						unsigned oldevents;
 
-						spin_lock_irqsave(&subpriv->dio.
-								  intr.spinlock,
+						spin_lock_irqsave(&devpriv->spinlock,
 								  flags);
 
 						oldevents = s->async->events;
 
-						if (subpriv->dio.intr.active) {
+						if (devpriv->active) {
 							unsigned mytrig =
 							    ((triggered >> 0)
 							     &
 							     ((0x1 << 24) -
 							      1)) << 0;
 							if (mytrig &
-							    subpriv->dio.
-							    intr.enabled_mask) {
+							    devpriv->enabled_mask) {
 								unsigned int val
 								    = 0;
 								unsigned int n,
@@ -479,11 +454,11 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 								}
 
 								/* Check for end of acquisition. */
-								if (!subpriv->dio.intr.continuous) {
+								if (!devpriv->continuous) {
 									/* stop_src == TRIG_COUNT */
-									if (subpriv->dio.intr.stop_count > 0) {
-										subpriv->dio.intr.stop_count--;
-										if (subpriv->dio.intr.stop_count == 0) {
+									if (devpriv->stop_count > 0) {
+										devpriv->stop_count--;
+										if (devpriv->stop_count == 0) {
 											s->async->events |= COMEDI_CB_EOA;
 											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 											pcmmio_stop_intr
@@ -496,8 +471,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 						}
 
 						spin_unlock_irqrestore
-						    (&subpriv->dio.intr.
-						     spinlock, flags);
+						    (&devpriv->spinlock, flags);
 
 						if (oldevents !=
 						    s->async->events) {
@@ -514,20 +488,20 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
+	struct pcmmio_private *devpriv = dev->private;
 
-	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
+	if (!devpriv->continuous && devpriv->stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
-		subpriv->dio.intr.active = 0;
+		devpriv->active = 0;
 		return 1;
 	} else {
 		unsigned bits = 0, pol_bits = 0, n;
 		int nports, firstport, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		subpriv->dio.intr.enabled_mask = 0;
-		subpriv->dio.intr.active = 1;
+		devpriv->enabled_mask = 0;
+		devpriv->active = 1;
 		nports = 24 / CHANS_PER_PORT;
 		firstport = 0 / CHANS_PER_PORT;
 		if (cmd->chanlist) {
@@ -540,7 +514,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			}
 		}
 		bits &= ((0x1 << 24) - 1) << 0;
-		subpriv->dio.intr.enabled_mask = bits;
+		devpriv->enabled_mask = bits;
 
 		{
 			/*
@@ -577,13 +551,13 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 
 static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
+	struct pcmmio_private *devpriv = dev->private;
 	unsigned long flags;
 
-	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
-	if (subpriv->dio.intr.active)
+	spin_lock_irqsave(&devpriv->spinlock, flags);
+	if (devpriv->active)
 		pcmmio_stop_intr(dev, s);
-	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 	return 0;
 }
@@ -595,18 +569,18 @@ static int
 pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
+	struct pcmmio_private *devpriv = dev->private;
 	unsigned long flags;
 	int event = 0;
 
 	if (trignum != 0)
 		return -EINVAL;
 
-	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&devpriv->spinlock, flags);
 	s->async->inttrig = NULL;
-	if (subpriv->dio.intr.active)
+	if (devpriv->active)
 		event = pcmmio_start_intr(dev, s);
-	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 	if (event)
 		comedi_event(dev, s);
@@ -619,24 +593,24 @@ pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
+	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
 
-	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
-	subpriv->dio.intr.active = 1;
+	spin_lock_irqsave(&devpriv->spinlock, flags);
+	devpriv->active = 1;
 
 	/* Set up end of acquisition. */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		subpriv->dio.intr.continuous = 0;
-		subpriv->dio.intr.stop_count = cmd->stop_arg;
+		devpriv->continuous = 0;
+		devpriv->stop_count = cmd->stop_arg;
 		break;
 	default:
 		/* TRIG_NONE */
-		subpriv->dio.intr.continuous = 1;
-		subpriv->dio.intr.stop_count = 0;
+		devpriv->continuous = 1;
+		devpriv->stop_count = 0;
 		break;
 	}
 
@@ -650,7 +624,7 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		event = pcmmio_start_intr(dev, s);
 		break;
 	}
-	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 	if (event)
 		comedi_event(dev, s);
@@ -875,7 +849,6 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pcmmio_private *devpriv;
-	struct pcmmio_subdev_private *subpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
@@ -889,11 +862,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	spin_lock_init(&devpriv->pagelock);
 
-	devpriv->sprivs = kcalloc(4, sizeof(struct pcmmio_subdev_private),
-				  GFP_KERNEL);
-	if (!devpriv->sprivs)
-		return -ENOMEM;
-
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
@@ -945,12 +913,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->do_cmd	= pcmmio_cmd;
 	s->do_cmdtest	= pcmmio_cmdtest;
 
-	s->private = &devpriv->sprivs[2];
-	subpriv = s->private;
-	subpriv->dio.intr.active = 0;
-	subpriv->dio.intr.stop_count = 0;
+	devpriv->active = 0;
+	devpriv->stop_count = 0;
 
-	spin_lock_init(&subpriv->dio.intr.spinlock);
+	spin_lock_init(&devpriv->spinlock);
 
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[3];
@@ -976,10 +942,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmmio_detach(struct comedi_device *dev)
 {
-	struct pcmmio_private *devpriv = dev->private;
-
-	if (devpriv)
-		kfree(devpriv->sprivs);
 	comedi_legacy_detach(dev);
 }
 

commit 518bf39f74b2a2493c1023bed556ee65a282c098
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:09 2013 -0700

    staging: comedi: pcmmio: remove 'num_asic_chans' from subdevice private data
    
    The 'num_asic_chans' that support interrupts in the interrupt subdevice is
    always initialized to '24'. Remove this unneeded information from the subdevice
    private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 0a6eb50a722e..8e00d12d7b1b 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -209,11 +209,6 @@ struct pcmmio_subdev_private {
 
 			/* The below is only used for intr subdevices */
 			struct {
-				/*
-				 * the number of asic channels in this subdev
-				 * that have interrutps
-				 */
-				int num_asic_chans;
 				/*
 				 * subdev-relative channel mask for channels
 				 * we are interested in
@@ -448,9 +443,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 							unsigned mytrig =
 							    ((triggered >> 0)
 							     &
-							     ((0x1 << subpriv->
-							       dio.intr.
-							       num_asic_chans) -
+							     ((0x1 << 24) -
 							      1)) << 0;
 							if (mytrig &
 							    subpriv->dio.
@@ -535,7 +528,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 
 		subpriv->dio.intr.enabled_mask = 0;
 		subpriv->dio.intr.active = 1;
-		nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
+		nports = 24 / CHANS_PER_PORT;
 		firstport = 0 / CHANS_PER_PORT;
 		if (cmd->chanlist) {
 			for (n = 0; n < cmd->chanlist_len; n++) {
@@ -546,7 +539,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
-		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) - 1) << 0;
+		bits &= ((0x1 << 24) - 1) << 0;
 		subpriv->dio.intr.enabled_mask = bits;
 
 		{
@@ -956,7 +949,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	subpriv = s->private;
 	subpriv->dio.intr.active = 0;
 	subpriv->dio.intr.stop_count = 0;
-	subpriv->dio.intr.num_asic_chans = 24;
 
 	spin_lock_init(&subpriv->dio.intr.spinlock);
 

commit 8fba3e5b1fd9c615f607f87bbf2682c45ec7d31d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:08 2013 -0700

    staging: comedi: pcmmio: remove 'asic_chan' from subdevice private data
    
    The first 'asic_chan' that supports interrupts in the interrupt subdevice is
    always initialized to '0'. Remove this unneeded information from the subdevice
    private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index cbc81a7e8270..0a6eb50a722e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -214,11 +214,6 @@ struct pcmmio_subdev_private {
 				 * that have interrutps
 				 */
 				int num_asic_chans;
-				/*
-				 * if nonnegative, the first channel id with
-				 * respect to the asic that has interrupts
-				 */
-				int asic_chan;
 				/*
 				 * subdev-relative channel mask for channels
 				 * we are interested in
@@ -451,8 +446,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 
 						if (subpriv->dio.intr.active) {
 							unsigned mytrig =
-							    ((triggered >>
-							      subpriv->dio.intr.asic_chan)
+							    ((triggered >> 0)
 							     &
 							     ((0x1 << subpriv->
 							       dio.intr.
@@ -542,7 +536,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 		subpriv->dio.intr.enabled_mask = 0;
 		subpriv->dio.intr.active = 1;
 		nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
-		firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
+		firstport = 0 / CHANS_PER_PORT;
 		if (cmd->chanlist) {
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
@@ -962,7 +956,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	subpriv = s->private;
 	subpriv->dio.intr.active = 0;
 	subpriv->dio.intr.stop_count = 0;
-	subpriv->dio.intr.asic_chan = 0;
 	subpriv->dio.intr.num_asic_chans = 24;
 
 	spin_lock_init(&subpriv->dio.intr.spinlock);

commit b346c318b7e1ec33149f79af3040b28bf3d74e39
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:07 2013 -0700

    staging: comedi: pcmmio: remove 'first_chan' from subdevice private data
    
    The 'first_chan' that supports interrupts in the interrupt subdevice is always
    initialized to '0'. Remove this unneeded information from the subdevice private
    data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 0364bc1cfa3d..cbc81a7e8270 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -209,11 +209,6 @@ struct pcmmio_subdev_private {
 
 			/* The below is only used for intr subdevices */
 			struct {
-				/*
-				 * if nonnegative, the first channel id for
-				 * interrupts.
-				 */
-				int first_chan;
 				/*
 				 * the number of asic channels in this subdev
 				 * that have interrutps
@@ -462,8 +457,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 							     ((0x1 << subpriv->
 							       dio.intr.
 							       num_asic_chans) -
-							      1)) << subpriv->
-							    dio.intr.first_chan;
+							      1)) << 0;
 							if (mytrig &
 							    subpriv->dio.
 							    intr.enabled_mask) {
@@ -558,8 +552,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
-		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) -
-			 1) << subpriv->dio.intr.first_chan;
+		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) - 1) << 0;
 		subpriv->dio.intr.enabled_mask = bits;
 
 		{
@@ -581,12 +574,11 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 
 		switch_page(dev, PCMMIO_PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
-			unsigned enab =
-			    bits >> (subpriv->dio.intr.first_chan + (port -
-								     firstport)
-				     * 8) & 0xff, pol =
-			    pol_bits >> (subpriv->dio.intr.first_chan +
-					 (port - firstport) * 8) & 0xff;
+			unsigned enab, pol;
+
+			enab = bits >> (0 + (port - firstport) * 8) & 0xff;
+			pol = pol_bits >> (0 + (port - firstport) * 8) & 0xff;
+
 			/* set enab intrs for this subdev.. */
 			outb(enab, dev->iobase + PCMMIO_PAGE_REG(port));
 			switch_page(dev, PCMMIO_PAGE_POL);
@@ -970,7 +962,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	subpriv = s->private;
 	subpriv->dio.intr.active = 0;
 	subpriv->dio.intr.stop_count = 0;
-	subpriv->dio.intr.first_chan = 0;
 	subpriv->dio.intr.asic_chan = 0;
 	subpriv->dio.intr.num_asic_chans = 24;
 

commit 8c41e9f41bd5543cb14e617b9626d2640ce3240f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:06 2013 -0700

    staging: comedi: pcmmio: remove 'asic' member from subdevice private data
    
    This member of the subdevice private data is always initialized to '0' by
    the only subdevice that uses it. Since we only have one asic on the board
    it's really not needed. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index c5f8bb26acdb..0364bc1cfa3d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -209,11 +209,6 @@ struct pcmmio_subdev_private {
 
 			/* The below is only used for intr subdevices */
 			struct {
-				/*
-				 * if non-negative, this subdev has an
-				 * interrupt asic
-				 */
-				int asic;
 				/*
 				 * if nonnegative, the first channel id for
 				 * interrupts.
@@ -450,11 +445,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				 * TODO here: dispatch io lines to subdevs
 				 * with commands..
 				 */
-					/*
-					 * this is an interrupt subdev,
-					 * and it matches this asic!
-					 */
-					if (subpriv->dio.intr.asic == 0) {
 						unsigned long flags;
 						unsigned oldevents;
 
@@ -533,8 +523,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 							comedi_event(dev, s);
 						}
 
-					}
-
 			}
 
 	if (!got1)
@@ -554,13 +542,9 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 		return 1;
 	} else {
 		unsigned bits = 0, pol_bits = 0, n;
-		int nports, firstport, asic, port;
+		int nports, firstport, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		asic = subpriv->dio.intr.asic;
-		if (asic < 0)
-			return 1;	/* not an interrupt
-					   subdev */
 		subpriv->dio.intr.enabled_mask = 0;
 		subpriv->dio.intr.active = 1;
 		nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
@@ -984,7 +968,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s->private = &devpriv->sprivs[2];
 	subpriv = s->private;
-	subpriv->dio.intr.asic = 0;
 	subpriv->dio.intr.active = 0;
 	subpriv->dio.intr.stop_count = 0;
 	subpriv->dio.intr.first_chan = 0;

commit 1786bd7503cfe5dfdb57b6b965cfb9a092b04df0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:05 2013 -0700

    staging: comedi: pcmmio: remove unnecessary for () loop and sanity check
    
    There is only one asic on the board so the for () loop in the interrupt
    handler to check multiple asics is not needed.
    
    The sanity check of the 'irq' in the interrupt handler is also not needed.
    If it _is_ wrong we have bigger problems in the kernel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 7026ebcc2c7c..c5f8bb26acdb 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -402,10 +402,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	struct pcmmio_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct pcmmio_subdev_private *subpriv = s->private;
-	int asic, got1 = 0;
+	int got1 = 0;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		if (irq == dev->irq) {
 			unsigned long flags;
 			unsigned triggered = 0;
 			/* it is an interrupt for ASIC #asic */
@@ -456,7 +454,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 					 * this is an interrupt subdev,
 					 * and it matches this asic!
 					 */
-					if (subpriv->dio.intr.asic == asic) {
+					if (subpriv->dio.intr.asic == 0) {
 						unsigned long flags;
 						unsigned oldevents;
 
@@ -539,8 +537,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 
 			}
 
-		}
-	}
 	if (!got1)
 		return IRQ_NONE;	/* interrupt from other source */
 	return IRQ_HANDLED;

commit 19e0bf12358e5914db07a9026135b5b37aa408ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:04 2013 -0700

    staging: comedi: pcmmio: unwind the digital i/o subdevice init
    
    The board supported by this driver only has one asic that provides the
    two digital i/o subdevices. The first dio subdevice has 24 channels that
    support interrupts. The second dio subdevice also has 24 channels but no
    interrupt support.
    
    To make the code clearer and easier to maintain, remove the for () loop
    that initialized these subdevices.
    
    Also, correctly initialize the interrupt subdevice. The current code does
    not set the SDF_CMD_READ subdev_flag and does not set the dev->read_subdev
    pointer in the comedi_device.
    
    Use the dev->read_subdev pointer in the interrupt handler to get the
    interrupt subdevice and private data pointer instead of searching for
    them. To keep this patch reviewable, the extra indents in interrupt_pcmmio()
    will be removed later.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 4da5e5864047..7026ebcc2c7c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -398,10 +398,11 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
-	int asic, got1 = 0;
-	struct comedi_device *dev = (struct comedi_device *)d;
+	struct comedi_device *dev = d;
 	struct pcmmio_private *devpriv = dev->private;
-	int i;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct pcmmio_subdev_private *subpriv = s->private;
+	int asic, got1 = 0;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == dev->irq) {
@@ -447,19 +448,10 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 			spin_unlock_irqrestore(&devpriv->pagelock, flags);
 
 			if (triggered) {
-				struct comedi_subdevice *s;
 				/*
 				 * TODO here: dispatch io lines to subdevs
 				 * with commands..
 				 */
-				dev_dbg(dev->class_dev,
-					"got edge detect interrupt %d asic %d which_chans: %06x\n",
-					irq, asic, triggered);
-				for (i = 2; i < dev->n_subdevices; i++) {
-					struct pcmmio_subdev_private *subpriv;
-
-					s = &dev->subdevices[i];
-					subpriv = s->private;
 					/*
 					 * this is an interrupt subdev,
 					 * and it matches this asic!
@@ -545,7 +537,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 
 					}
 
-				}
 			}
 
 		}
@@ -927,8 +918,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pcmmio_private *devpriv;
 	struct pcmmio_subdev_private *subpriv;
 	struct comedi_subdevice *s;
-	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
-	    thisasic_chanct = 0;
 	int ret;
 
 	ret = comedi_request_region(dev, it->options[0], 32);
@@ -941,16 +930,12 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	spin_lock_init(&devpriv->pagelock);
 
-	chans_left = CHANS_PER_ASIC * 1;
-	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
-	n_subdevs = n_dio_subdevs + 2;
-	devpriv->sprivs =
-	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
-		    GFP_KERNEL);
+	devpriv->sprivs = kcalloc(4, sizeof(struct pcmmio_subdev_private),
+				  GFP_KERNEL);
 	if (!devpriv->sprivs)
 		return -ENOMEM;
 
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
 
@@ -983,73 +968,44 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outb(0, dev->iobase + PCMMIO_AO_2ND_DAC_OFFSET +
 		PCMMIO_AO_RESOURCE_ENA_REG);
 
-	port = 0;
-	asic = 0;
-	for (sdev_no = 2; sdev_no < dev->n_subdevices; ++sdev_no) {
-		int byte_no;
-
-		s = &dev->subdevices[sdev_no];
-		subpriv = &devpriv->sprivs[sdev_no];
-		s->private = subpriv;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->type = COMEDI_SUBD_DIO;
-		s->insn_bits = pcmmio_dio_insn_bits;
-		s->insn_config = pcmmio_dio_insn_config;
-		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
-		subpriv->dio.intr.asic = -1;
-		subpriv->dio.intr.first_chan = -1;
-		subpriv->dio.intr.asic_chan = -1;
-		subpriv->dio.intr.num_asic_chans = -1;
-		subpriv->dio.intr.active = 0;
-		s->len_chanlist = 1;
-
-		/* save the ioport address for each 'port' of 8 channels in the
-		   subdevice */
-		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
-			if (port >= PORTS_PER_ASIC) {
-				port = 0;
-				++asic;
-				thisasic_chanct = 0;
-			}
-
-			if (thisasic_chanct <
-			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-			    && subpriv->dio.intr.asic < 0) {
-				/*
-				 * this is an interrupt subdevice,
-				 * so setup the struct
-				 */
-				subpriv->dio.intr.asic = asic;
-				subpriv->dio.intr.active = 0;
-				subpriv->dio.intr.stop_count = 0;
-				subpriv->dio.intr.first_chan = byte_no * 8;
-				subpriv->dio.intr.asic_chan = thisasic_chanct;
-				subpriv->dio.intr.num_asic_chans =
-				    s->n_chan - subpriv->dio.intr.first_chan;
-				s->cancel = pcmmio_cancel;
-				s->do_cmd = pcmmio_cmd;
-				s->do_cmdtest = pcmmio_cmdtest;
-				s->len_chanlist =
-				    subpriv->dio.intr.num_asic_chans;
-			}
-			thisasic_chanct += CHANS_PER_PORT;
-		}
-		spin_lock_init(&subpriv->dio.intr.spinlock);
-
-		chans_left -= s->n_chan;
-
-		if (!chans_left) {
-			/*
-			 * reset the asic to our first asic,
-			 * to do intr subdevs
-			 */
-			asic = 0;
-			port = 0;
-		}
-
-	}
+	/* Digital I/O subdevice with interrupt support */
+	s = &dev->subdevices[2];
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 24;
+	s->maxdata	= 1;
+	s->len_chanlist	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcmmio_dio_insn_bits;
+	s->insn_config	= pcmmio_dio_insn_config;
+
+	dev->read_subdev = s;
+	s->subdev_flags	|= SDF_CMD_READ;
+	s->len_chanlist	= s->n_chan;
+	s->cancel	= pcmmio_cancel;
+	s->do_cmd	= pcmmio_cmd;
+	s->do_cmdtest	= pcmmio_cmdtest;
+
+	s->private = &devpriv->sprivs[2];
+	subpriv = s->private;
+	subpriv->dio.intr.asic = 0;
+	subpriv->dio.intr.active = 0;
+	subpriv->dio.intr.stop_count = 0;
+	subpriv->dio.intr.first_chan = 0;
+	subpriv->dio.intr.asic_chan = 0;
+	subpriv->dio.intr.num_asic_chans = 24;
+
+	spin_lock_init(&subpriv->dio.intr.spinlock);
+
+	/* Digital I/O subdevice */
+	s = &dev->subdevices[3];
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 24;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pcmmio_dio_insn_bits;
+	s->insn_config	= pcmmio_dio_insn_config;
 
 	pcmmio_reset(dev);
 

commit 29947fd6310292ce81d1ea4e0b56978a4a921b19
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:03 2013 -0700

    staging: comedi: pcmmio: simplify pcmmio_stop_intr()
    
    This function is only called by the interrupt subdevice so the sanity
    check of the 'asic' is not necessary. Remove it.
    
    The 'nports' is always 3 and the 'firstport' is always 0. Remove the
    for () loop that clears the registers to disable the interrupts and
    just use the pcmmio_dio_write() helper to write to the three page
    registers.
    
    This also fixes a bug where the write to the page registers is not
    protected with the spinlock.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 7e1117fe4360..4da5e5864047 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -387,22 +387,13 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmmio_subdev_private *subpriv = s->private;
-	int nports, firstport, asic, port;
-
-	asic = subpriv->dio.intr.asic;
-	if (asic < 0)
-		return;		/* not an interrupt subdev */
 
 	subpriv->dio.intr.enabled_mask = 0;
 	subpriv->dio.intr.active = 0;
 	s->async->inttrig = NULL;
-	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
-	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, PCMMIO_PAGE_ENAB);
-	for (port = firstport; port < firstport + nports; ++port) {
-		/* disable all intrs for this subdev.. */
-		outb(0, dev->iobase + PCMMIO_PAGE_REG(port));
-	}
+
+	/* disable all dio interrupts */
+	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);
 }
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d)

commit 62957c98679e3eef7a9e052c75b2ee891e419125
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:02 2013 -0700

    staging: comedi: pcmmio: remove 'iobases' from the subdevice private data
    
    This member of the subdevice private data is not longer used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index da9209b2006c..7e1117fe4360 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -204,11 +204,6 @@ static const struct comedi_lrange pcmmio_ao_ranges = {
 /* this structure is for data unique to this subdevice.  */
 struct pcmmio_subdev_private {
 
-	union {
-		/* for DIO: mapping of halfwords (bytes)
-		   in port/chanarray to iobase */
-		unsigned long iobases[PORTS_PER_SUBDEV];
-	};
 	union {
 		struct {
 
@@ -1027,8 +1022,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				++asic;
 				thisasic_chanct = 0;
 			}
-			subpriv->iobases[byte_no] = dev->iobase +
-						    PCMMIO_PORT_REG(port);
 
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC

commit 0398606c1863f8a91b6a75d33a2d5a6131250be7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:01 2013 -0700

    staging: comedi: pcmmio: simplify pcmmio_dio_insn_bits()
    
    Currently this function uses the subdevice private data to get the
    iobase address needed to update the dio output channel state and
    read the current state of the input channels. This subdevice private
    data is in the process of being removed.
    
    Use the subdevice 'index' to determine the base 'port' needed to
    access the correct digital i/o registers. The pcmmio_dio_write()
    function can then be used to update the outputs.
    
    Introduce a new helper function, pcmmio_dio_read(), to read the
    current state of the input channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 84be517bb237..da9209b2006c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -282,63 +282,72 @@ static void pcmmio_dio_write(struct comedi_device *dev, unsigned int val,
 	spin_unlock_irqrestore(&devpriv->pagelock, flags);
 }
 
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The
- * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+static unsigned int pcmmio_dio_read(struct comedi_device *dev,
+				    int page, int port)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
-	int byte_no;
-
-	/* NOTE:
-	   reading a 0 means this channel was high
-	   writine a 0 sets the channel high
-	   reading a 1 means this channel was low
-	   writing a 1 means set this channel low
-
-	   Therefore everything is always inverted. */
-
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
+	struct pcmmio_private *devpriv = dev->private;
+	unsigned long iobase = dev->iobase;
+	unsigned long flags;
+	unsigned int val;
 
-	s->state = 0;
+	spin_lock_irqsave(&devpriv->pagelock, flags);
+	if (page == 0) {
+		/* Port registers are valid for any page */
+		val = inb(iobase + PCMMIO_PORT_REG(port + 0));
+		val |= (inb(iobase + PCMMIO_PORT_REG(port + 1)) << 8);
+		val |= (inb(iobase + PCMMIO_PORT_REG(port + 2)) << 16);
+	} else {
+		outb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);
+		val = inb(iobase + PCMMIO_PAGE_REG(0));
+		val |= (inb(iobase + PCMMIO_PAGE_REG(1)) << 8);
+		val |= (inb(iobase + PCMMIO_PAGE_REG(2)) << 16);
+	}
+	spin_unlock_irqrestore(&devpriv->pagelock, flags);
 
-	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
-		/* address of 8-bit port */
-		unsigned long ioaddr = subpriv->iobases[byte_no],
-		    /* bit offset of port in 32-bit doubleword */
-		    offset = byte_no * 8;
-		/* this 8-bit port's data */
-		unsigned char byte = 0,
-		    /* The write mask for this port (if any) */
-		    write_mask_byte = (data[0] >> offset) & 0xff,
-		    /* The data byte for this port */
-		    data_byte = (data[1] >> offset) & 0xff;
+	return val;
+}
 
-		byte = inb(ioaddr);	/* read all 8-bits for this port */
+/*
+ * Each channel can be individually programmed for input or output.
+ * Writing a '0' to a channel causes the corresponding output pin
+ * to go to a high-z state (pulled high by an external 10K resistor).
+ * This allows it to be used as an input. When used in the input mode,
+ * a read reflects the inverted state of the I/O pin, such that a
+ * high on the pin will read as a '0' in the register. Writing a '1'
+ * to a bit position causes the pin to sink current (up to 12mA),
+ * effectively pulling it low.
+ */
+static int pcmmio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+	/* subdevice 2 uses ports 0-2, subdevice 3 uses ports 3-5 */
+	int port = s->index == 2 ? 0 : 3;
+	unsigned int chanmask = (1 << s->n_chan) - 1;
+	unsigned int mask;
+	unsigned int val;
 
-		if (write_mask_byte) {
-			/*
-			 * this byte has some write_bits
-			 * -- so set the output lines
-			 */
-			/* clear bits for write mask */
-			byte &= ~write_mask_byte;
-			/* set to inverted data_byte */
-			byte |= ~data_byte & write_mask_byte;
-			/* Write out the new digital output state */
-			outb(byte, ioaddr);
-		}
-		/* save the digital input lines for this byte.. */
-		s->state |= ((unsigned int)byte) << offset;
+	mask = comedi_dio_update_state(s, data);
+	if (mask) {
+		/*
+		 * Outputs are inverted, invert the state and
+		 * update the channels.
+		 *
+		 * The s->io_bits mask makes sure the input channels
+		 * are '0' so that the outputs pins stay in a high
+		 * z-state.
+		 */
+		val = ~s->state & chanmask;
+		val &= s->io_bits;
+		pcmmio_dio_write(dev, val, 0, port);
 	}
 
-	/* now return the DIO lines to data[1] - note they came inverted! */
-	data[1] = ~s->state;
+	/* get inverted state of the channels from the port */
+	val = pcmmio_dio_read(dev, 0, port);
+
+	/* return the true state of the channels */
+	data[1] = ~val & chanmask;
 
 	return insn->n;
 }

commit 72c7692a9d737926090b51fd132ae816d1556713
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:31:00 2013 -0700

    staging: comedi: pcmmio: simplify pcmmio_dio_insn_config()
    
    Currently this function uses the subdevice private data to get the
    iobase address needed to update the channel configuration. This
    subdevice private data is in the process of being removed.
    
    Use the subdevice 'index' to determine the base 'port' needed to
    access the correct digital i/o registers. The pcmmio_dio_write()
    function can then be used to update the configuration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 873fcf3e87aa..84be517bb237 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -348,24 +348,16 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
-	struct pcmmio_subdev_private *subpriv = s->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int byte_no = chan / 8;
-	int bit_no = chan % 8;
+	/* subdevice 2 uses ports 0-2, subdevice 3 uses ports 3-5 */
+	int port = s->index == 2 ? 0 : 3;
 	int ret;
 
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;
 
-	if (data[0] == INSN_CONFIG_DIO_INPUT) {
-		unsigned long ioaddr = subpriv->iobases[byte_no];
-		unsigned char val;
-
-		val = inb(ioaddr);
-		val &= ~(1 << bit_no);
-		outb(val, ioaddr);
-	}
+	if (data[0] == INSN_CONFIG_DIO_INPUT)
+		pcmmio_dio_write(dev, s->io_bits, 0, port);
 
 	return insn->n;
 }

commit 4edac4a4da158869bb41392939f3933bf8f8d46d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:59 2013 -0700

    staging: comedi: pcmmio: introduce pcmmio_dio_write()
    
    The paged registers in the asic need to be spinlock protected to
    ensure that the page is not changed while writing to the registers.
    
    Introduce a helper function to make sure the spinlock is used.
    
    Use the new helper in pcmmio_reset(). This is one of the places where
    the spinlock is not used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3f1fb9b1432d..873fcf3e87aa 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -260,6 +260,28 @@ struct pcmmio_private {
 	unsigned int ao_readback[8];
 };
 
+static void pcmmio_dio_write(struct comedi_device *dev, unsigned int val,
+			     int page, int port)
+{
+	struct pcmmio_private *devpriv = dev->private;
+	unsigned long iobase = dev->iobase;
+	unsigned long flags;
+
+	spin_lock_irqsave(&devpriv->pagelock, flags);
+	if (page == 0) {
+		/* Port registers are valid for any page */
+		outb(val & 0xff, iobase + PCMMIO_PORT_REG(port + 0));
+		outb((val >> 8) & 0xff, iobase + PCMMIO_PORT_REG(port + 1));
+		outb((val >> 16) & 0xff, iobase + PCMMIO_PORT_REG(port + 2));
+	} else {
+		outb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);
+		outb(val & 0xff, iobase + PCMMIO_PAGE_REG(0));
+		outb((val >> 8) & 0xff, iobase + PCMMIO_PAGE_REG(1));
+		outb((val >> 16) & 0xff, iobase + PCMMIO_PAGE_REG(2));
+	}
+	spin_unlock_irqrestore(&devpriv->pagelock, flags);
+}
+
 /* DIO devices are slightly special.  Although it is possible to
  * implement the insn_read/insn_write interface, it is much more
  * useful to applications if you implement the insn_bits interface.
@@ -355,25 +377,14 @@ static void switch_page(struct comedi_device *dev, int page)
 
 static void pcmmio_reset(struct comedi_device *dev)
 {
-	int port, page;
-
-	switch_page(dev, 0);	/* switch back to page 0 */
-
-	/* first, clear all the DIO port bits */
-	for (port = 0; port < PORTS_PER_ASIC; ++port)
-		outb(0, dev->iobase + PCMMIO_PORT_REG(port));
-
-	/* Next, clear all the paged registers for each page */
-	for (page = 1; page < NUM_PAGES; ++page) {
-		int reg;
-		/* now clear all the paged registers */
-		switch_page(dev, page);
-		for (reg = 0; reg < NUM_PAGED_REGS; ++reg)
-			outb(0, dev->iobase + PCMMIO_PAGE_REG(reg));
-	}
-
-	/* switch back to default page 0 */
-	switch_page(dev, 0);
+	/* Clear all the DIO port bits */
+	pcmmio_dio_write(dev, 0, 0, 0);
+	pcmmio_dio_write(dev, 0, 0, 3);
+
+	/* Clear all the paged registers */
+	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_POL, 0);
+	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);
+	pcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);
 }
 
 static void pcmmio_stop_intr(struct comedi_device *dev,

commit 83d55bd03f8a37e3a8ba4d24da2a274231a485e5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:58 2013 -0700

    staging: comedi: pcmmio: rename 'spinlock' in the private data
    
    This spinlock_t is meant to protect the page registers in the asic.
    Rename it to make this clear.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index be0990fc8370..3f1fb9b1432d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -254,7 +254,7 @@ struct pcmmio_subdev_private {
  * feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct pcmmio_private {
-	spinlock_t spinlock;
+	spinlock_t pagelock;	/* protects the page registers */
 
 	struct pcmmio_subdev_private *sprivs;
 	unsigned int ao_readback[8];
@@ -412,7 +412,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->spinlock, flags);
+			spin_lock_irqsave(&devpriv->pagelock, flags);
 
 			int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG);
 			int_pend &= 0x07;
@@ -446,7 +446,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->pagelock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -941,7 +941,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	spin_lock_init(&devpriv->spinlock);
+	spin_lock_init(&devpriv->pagelock);
 
 	chans_left = CHANS_PER_ASIC * 1;
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);

commit 20218e6a3c180b3814bd1600737c5ab26508b47b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:57 2013 -0700

    staging: comedi: pcmmio: remove 'subpriv' macro
    
    This macro relies on a local variable having a specific name. Remove
    the macro and add a local variable where used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 7dc14fa9a987..be0990fc8370 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -260,8 +260,6 @@ struct pcmmio_private {
 	unsigned int ao_readback[8];
 };
 
-#define subpriv ((struct pcmmio_subdev_private *)s->private)
-
 /* DIO devices are slightly special.  Although it is possible to
  * implement the insn_read/insn_write interface, it is much more
  * useful to applications if you implement the insn_bits interface.
@@ -271,6 +269,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	int byte_no;
 
 	/* NOTE:
@@ -327,6 +326,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	int byte_no = chan / 8;
 	int bit_no = chan % 8;
@@ -379,6 +379,7 @@ static void pcmmio_reset(struct comedi_device *dev)
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	int nports, firstport, asic, port;
 
 	asic = subpriv->dio.intr.asic;
@@ -457,7 +458,10 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 					"got edge detect interrupt %d asic %d which_chans: %06x\n",
 					irq, asic, triggered);
 				for (i = 2; i < dev->n_subdevices; i++) {
+					struct pcmmio_subdev_private *subpriv;
+
 					s = &dev->subdevices[i];
+					subpriv = s->private;
 					/*
 					 * this is an interrupt subdev,
 					 * and it matches this asic!
@@ -556,6 +560,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
+
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
@@ -623,6 +629,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 
 static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
@@ -640,6 +647,7 @@ static int
 pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	unsigned long flags;
 	int event = 0;
 
@@ -663,6 +671,7 @@ pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcmmio_subdev_private *subpriv = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
@@ -918,6 +927,7 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pcmmio_private *devpriv;
+	struct pcmmio_subdev_private *subpriv;
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
@@ -981,7 +991,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		int byte_no;
 
 		s = &dev->subdevices[sdev_no];
-		s->private = &devpriv->sprivs[sdev_no];
+		subpriv = &devpriv->sprivs[sdev_no];
+		s->private = subpriv;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;

commit 03a36f172bf0e249b2671fe1f0d7e4552048f417
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:56 2013 -0700

    staging: comedi: pcmmio: cleanup the digital i/o register defines
    
    Redefine the registers used to access the digital i/o so that they
    are based on the dev->iobase of the board instead of the 'asic_iobase'
    that is stored in the private data.
    
    Remove the then unused 'asic_iobase'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index af06062c15d3..7dc14fa9a987 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -133,6 +133,34 @@ Configuration Options:
 #define PCMMIO_AO_RESOURCE_ENA_REG		0x0b
 #define PCMMIO_AO_2ND_DAC_OFFSET		0x04
 
+/*
+ * WinSystems WS16C48
+ *
+ * Offset    Page 0       Page 1       Page 2       Page 3
+ * ------  -----------  -----------  -----------  -----------
+ *  0x10   Port 0 I/O   Port 0 I/O   Port 0 I/O   Port 0 I/O
+ *  0x11   Port 1 I/O   Port 1 I/O   Port 1 I/O   Port 1 I/O
+ *  0x12   Port 2 I/O   Port 2 I/O   Port 2 I/O   Port 2 I/O
+ *  0x13   Port 3 I/O   Port 3 I/O   Port 3 I/O   Port 3 I/O
+ *  0x14   Port 4 I/O   Port 4 I/O   Port 4 I/O   Port 4 I/O
+ *  0x15   Port 5 I/O   Port 5 I/O   Port 5 I/O   Port 5 I/O
+ *  0x16   INT_PENDING  INT_PENDING  INT_PENDING  INT_PENDING
+ *  0x17    Page/Lock    Page/Lock    Page/Lock    Page/Lock
+ *  0x18       N/A         POL_0       ENAB_0       INT_ID0
+ *  0x19       N/A         POL_1       ENAB_1       INT_ID1
+ *  0x1a       N/A         POL_2       ENAB_2       INT_ID2
+ */
+#define PCMMIO_PORT_REG(x)			(0x10 + (x))
+#define PCMMIO_INT_PENDING_REG			0x16
+#define PCMMIO_PAGE_LOCK_REG			0x17
+#define PCMMIO_LOCK_PORT(x)			((1 << (x)) & 0x3f)
+#define PCMMIO_PAGE(x)				(((x) & 0x3) << 6)
+#define PCMMIO_PAGE_MASK			PCMUIO_PAGE(3)
+#define PCMMIO_PAGE_POL				1
+#define PCMMIO_PAGE_ENAB			2
+#define PCMMIO_PAGE_INT_ID			3
+#define PCMMIO_PAGE_REG(x)			(0x18 + (x))
+
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
@@ -149,51 +177,9 @@ Configuration Options:
 #define ASIC_IOSIZE (0x0B)
 #define PCMMIO48_IOSIZE ASIC_IOSIZE
 
-/* Some offsets - these are all in the 16byte IO memory offset from
-   the base address.  Note that there is a paging scheme to swap out
-   offsets 0x8-0xA using the PAGELOCK register.  See the table below.
-
-  Register(s)       Pages        R/W?        Description
-  --------------------------------------------------------------
-  REG_PORTx         All          R/W         Read/Write/Configure IO
-  REG_INT_PENDING   All          ReadOnly    Quickly see which INT_IDx has int.
-  REG_PAGELOCK      All          WriteOnly   Select a page
-  REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
-  REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect. int.
-  REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
- */
-#define REG_PORT0 0x0
-#define REG_PORT1 0x1
-#define REG_PORT2 0x2
-#define REG_PORT3 0x3
-#define REG_PORT4 0x4
-#define REG_PORT5 0x5
-#define REG_INT_PENDING 0x6
-#define REG_PAGELOCK 0x7	/*
-				 * page selector register, upper 2 bits select
-				 * a page and bits 0-5 are used to 'lock down'
-				 * a particular port above to make it readonly.
-				 */
-#define REG_POL0 0x8
-#define REG_POL1 0x9
-#define REG_POL2 0xA
-#define REG_ENAB0 0x8
-#define REG_ENAB1 0x9
-#define REG_ENAB2 0xA
-#define REG_INT_ID0 0x8
-#define REG_INT_ID1 0x9
-#define REG_INT_ID2 0xA
-
 #define NUM_PAGED_REGS 3
 #define NUM_PAGES 4
 #define FIRST_PAGED_REG 0x8
-#define REG_PAGE_BITOFFSET 6
-#define REG_LOCK_BITOFFSET 0
-#define REG_PAGE_MASK (~((0x1<<REG_PAGE_BITOFFSET)-1))
-#define REG_LOCK_MASK (~(REG_PAGE_MASK))
-#define PAGE_POL 1
-#define PAGE_ENAB 2
-#define PAGE_INT_ID 3
 
 static const struct comedi_lrange pcmmio_ai_ranges = {
 	4, {
@@ -268,7 +254,6 @@ struct pcmmio_subdev_private {
  * feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct pcmmio_private {
-	unsigned long asic_iobase;
 	spinlock_t spinlock;
 
 	struct pcmmio_subdev_private *sprivs;
@@ -365,31 +350,26 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int page)
 {
-	struct pcmmio_private *devpriv = dev->private;
-
-	outb(page << REG_PAGE_BITOFFSET, devpriv->asic_iobase + REG_PAGELOCK);
+	outb(PCMMIO_PAGE(page), dev->iobase + PCMMIO_PAGE_LOCK_REG);
 }
 
 static void pcmmio_reset(struct comedi_device *dev)
 {
-	struct pcmmio_private *devpriv = dev->private;
-	unsigned long baseaddr = devpriv->asic_iobase;
 	int port, page;
 
 	switch_page(dev, 0);	/* switch back to page 0 */
 
 	/* first, clear all the DIO port bits */
 	for (port = 0; port < PORTS_PER_ASIC; ++port)
-		outb(0, baseaddr + REG_PORT0 + port);
+		outb(0, dev->iobase + PCMMIO_PORT_REG(port));
 
 	/* Next, clear all the paged registers for each page */
 	for (page = 1; page < NUM_PAGES; ++page) {
 		int reg;
 		/* now clear all the paged registers */
 		switch_page(dev, page);
-		for (reg = FIRST_PAGED_REG;
-		     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
-			outb(0, baseaddr + reg);
+		for (reg = 0; reg < NUM_PAGED_REGS; ++reg)
+			outb(0, dev->iobase + PCMMIO_PAGE_REG(reg));
 	}
 
 	/* switch back to default page 0 */
@@ -399,7 +379,6 @@ static void pcmmio_reset(struct comedi_device *dev)
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmmio_private *devpriv = dev->private;
 	int nports, firstport, asic, port;
 
 	asic = subpriv->dio.intr.asic;
@@ -411,10 +390,10 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
 	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, PAGE_ENAB);
+	switch_page(dev, PCMMIO_PAGE_ENAB);
 	for (port = firstport; port < firstport + nports; ++port) {
 		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asic_iobase + REG_ENAB0 + port);
+		outb(0, dev->iobase + PCMMIO_PAGE_REG(port));
 	}
 }
 
@@ -429,13 +408,13 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 		if (irq == dev->irq) {
 			unsigned long flags;
 			unsigned triggered = 0;
-			unsigned long iobase = devpriv->asic_iobase;
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
 			spin_lock_irqsave(&devpriv->spinlock, flags);
 
-			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
+			int_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG);
+			int_pend &= 0x07;
 
 			if (int_pend) {
 				int port;
@@ -444,19 +423,18 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 					if (int_pend & (0x1 << port)) {
 						unsigned char
 						    io_lines_with_edges = 0;
-						switch_page(dev, PAGE_INT_ID);
+						switch_page(dev, PCMMIO_PAGE_INT_ID);
 						io_lines_with_edges =
-						    inb(iobase +
-							REG_INT_ID0 + port);
+						    inb(dev->iobase +
+							PCMMIO_PAGE_REG(port));
 
 						if (io_lines_with_edges)
 							/*
 							 * clear pending
 							 * interrupt
 							 */
-							outb(0, iobase +
-							     REG_INT_ID0 +
-							     port);
+							outb(0, dev->iobase +
+							     PCMMIO_PAGE_REG(port));
 
 						triggered |=
 						    io_lines_with_edges <<
@@ -578,8 +556,6 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmmio_private *devpriv = dev->private;
-
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
@@ -628,7 +604,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			/* done, we told the board what irq to use */
 		}
 
-		switch_page(dev, PAGE_ENAB);
+		switch_page(dev, PCMMIO_PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
 			    bits >> (subpriv->dio.intr.first_chan + (port -
@@ -637,9 +613,9 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			    pol_bits >> (subpriv->dio.intr.first_chan +
 					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
-			outb(enab, devpriv->asic_iobase + REG_ENAB0 + port);
-			switch_page(dev, PAGE_POL);
-			outb(pol, devpriv->asic_iobase + REG_ENAB0 + port);
+			outb(enab, dev->iobase + PCMMIO_PAGE_REG(port));
+			switch_page(dev, PCMMIO_PAGE_POL);
+			outb(pol, dev->iobase + PCMMIO_PAGE_REG(port));
 		}
 	}
 	return 0;
@@ -955,7 +931,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	devpriv->asic_iobase = dev->iobase + 16;
 	spin_lock_init(&devpriv->spinlock);
 
 	chans_left = CHANS_PER_ASIC * 1;
@@ -1029,7 +1004,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				++asic;
 				thisasic_chanct = 0;
 			}
-			subpriv->iobases[byte_no] = devpriv->asic_iobase + port;
+			subpriv->iobases[byte_no] = dev->iobase +
+						    PCMMIO_PORT_REG(port);
 
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC

commit 0cc4f3bd5f562a391375a2187e411b6a037b29ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:55 2013 -0700

    staging: comedi: pcmmio: tidy up init_asics()
    
    Rename this function so it has namespace associated with the driver.
    
    The board supported by this driver only has one WinSystems WS16C48 asic
    on it that handles the digital i/o. Remove the unnecessary for () loop
    that would reset multiple asics.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3e3f4c9b8877..af06062c15d3 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -370,35 +370,30 @@ static void switch_page(struct comedi_device *dev, int page)
 	outb(page << REG_PAGE_BITOFFSET, devpriv->asic_iobase + REG_PAGELOCK);
 }
 
-static void init_asics(struct comedi_device *dev)
-{				/* sets up an
-				   ASIC chip to defaults */
+static void pcmmio_reset(struct comedi_device *dev)
+{
 	struct pcmmio_private *devpriv = dev->private;
-	int asic;
-
-	for (asic = 0; asic < 1; ++asic) {
-		int port, page;
-		unsigned long baseaddr = devpriv->asic_iobase;
-
-		switch_page(dev, 0);	/* switch back to page 0 */
-
-		/* first, clear all the DIO port bits */
-		for (port = 0; port < PORTS_PER_ASIC; ++port)
-			outb(0, baseaddr + REG_PORT0 + port);
-
-		/* Next, clear all the paged registers for each page */
-		for (page = 1; page < NUM_PAGES; ++page) {
-			int reg;
-			/* now clear all the paged registers */
-			switch_page(dev, page);
-			for (reg = FIRST_PAGED_REG;
-			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
-				outb(0, baseaddr + reg);
-		}
-
-		/* switch back to default page 0 */
-		switch_page(dev, 0);
+	unsigned long baseaddr = devpriv->asic_iobase;
+	int port, page;
+
+	switch_page(dev, 0);	/* switch back to page 0 */
+
+	/* first, clear all the DIO port bits */
+	for (port = 0; port < PORTS_PER_ASIC; ++port)
+		outb(0, baseaddr + REG_PORT0 + port);
+
+	/* Next, clear all the paged registers for each page */
+	for (page = 1; page < NUM_PAGES; ++page) {
+		int reg;
+		/* now clear all the paged registers */
+		switch_page(dev, page);
+		for (reg = FIRST_PAGED_REG;
+		     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+			outb(0, baseaddr + reg);
 	}
+
+	/* switch back to default page 0 */
+	switch_page(dev, 0);
 }
 
 static void pcmmio_stop_intr(struct comedi_device *dev,
@@ -1073,7 +1068,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	}
 
-	init_asics(dev);	/* clear out all the registers, basically */
+	pcmmio_reset(dev);
 
 	if (it->options[1]) {
 		ret = request_irq(it->options[1], interrupt_pcmmio, 0,

commit 8657fed873905aaf4267e96c8381ece77927caf0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:54 2013 -0700

    staging: comedi: pcmmio: remove 'asic' parameter from switch_page()
    
    The board supported by this driver only has one WinSystems WS16C48 asic
    on it that handles the digital i/o.
    
    Remove the unnecessary 'asic' parameter that is passed to switch_page().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 25b37f10f1cf..3e3f4c9b8877 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -363,7 +363,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void switch_page(struct comedi_device *dev, int asic, int page)
+static void switch_page(struct comedi_device *dev, int page)
 {
 	struct pcmmio_private *devpriv = dev->private;
 
@@ -380,7 +380,7 @@ static void init_asics(struct comedi_device *dev)
 		int port, page;
 		unsigned long baseaddr = devpriv->asic_iobase;
 
-		switch_page(dev, asic, 0);	/* switch back to page 0 */
+		switch_page(dev, 0);	/* switch back to page 0 */
 
 		/* first, clear all the DIO port bits */
 		for (port = 0; port < PORTS_PER_ASIC; ++port)
@@ -390,14 +390,14 @@ static void init_asics(struct comedi_device *dev)
 		for (page = 1; page < NUM_PAGES; ++page) {
 			int reg;
 			/* now clear all the paged registers */
-			switch_page(dev, asic, page);
+			switch_page(dev, page);
 			for (reg = FIRST_PAGED_REG;
 			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
 				outb(0, baseaddr + reg);
 		}
 
 		/* switch back to default page 0 */
-		switch_page(dev, asic, 0);
+		switch_page(dev, 0);
 	}
 }
 
@@ -416,7 +416,7 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
 	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, asic, PAGE_ENAB);
+	switch_page(dev, PAGE_ENAB);
 	for (port = firstport; port < firstport + nports; ++port) {
 		/* disable all intrs for this subdev.. */
 		outb(0, devpriv->asic_iobase + REG_ENAB0 + port);
@@ -449,8 +449,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 					if (int_pend & (0x1 << port)) {
 						unsigned char
 						    io_lines_with_edges = 0;
-						switch_page(dev, asic,
-							    PAGE_INT_ID);
+						switch_page(dev, PAGE_INT_ID);
 						io_lines_with_edges =
 						    inb(iobase +
 							REG_INT_ID0 + port);
@@ -634,7 +633,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			/* done, we told the board what irq to use */
 		}
 
-		switch_page(dev, asic, PAGE_ENAB);
+		switch_page(dev, PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
 			    bits >> (subpriv->dio.intr.first_chan + (port -
@@ -644,7 +643,7 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab, devpriv->asic_iobase + REG_ENAB0 + port);
-			switch_page(dev, asic, PAGE_POL);
+			switch_page(dev, PAGE_POL);
 			outb(pol, devpriv->asic_iobase + REG_ENAB0 + port);
 		}
 	}

commit d65bd16d056774ba5fa648111be9905d46d5b925
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:53 2013 -0700

    staging: comedi: pcmmio: there is only one asic
    
    The board supported by this driver only has one WinSystems WS16C48 asic
    on it that handles the digital i/o.
    
    Remove the 'asics' struct array in the private data and add members for
    the single 'asic_iobase' and the spinlock used by the asic.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 1ae5ffb08a77..25b37f10f1cf 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -268,11 +268,9 @@ struct pcmmio_subdev_private {
  * feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct pcmmio_private {
-	/* stuff for DIO */
-	struct {
-		unsigned long iobase;
-		spinlock_t spinlock;
-	} asics[MAX_ASICS];
+	unsigned long asic_iobase;
+	spinlock_t spinlock;
+
 	struct pcmmio_subdev_private *sprivs;
 	unsigned int ao_readback[8];
 };
@@ -369,8 +367,7 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 {
 	struct pcmmio_private *devpriv = dev->private;
 
-	outb(page << REG_PAGE_BITOFFSET,
-	     devpriv->asics[asic].iobase + REG_PAGELOCK);
+	outb(page << REG_PAGE_BITOFFSET, devpriv->asic_iobase + REG_PAGELOCK);
 }
 
 static void init_asics(struct comedi_device *dev)
@@ -381,7 +378,7 @@ static void init_asics(struct comedi_device *dev)
 
 	for (asic = 0; asic < 1; ++asic) {
 		int port, page;
-		unsigned long baseaddr = devpriv->asics[asic].iobase;
+		unsigned long baseaddr = devpriv->asic_iobase;
 
 		switch_page(dev, asic, 0);	/* switch back to page 0 */
 
@@ -422,7 +419,7 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 	switch_page(dev, asic, PAGE_ENAB);
 	for (port = firstport; port < firstport + nports; ++port) {
 		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+		outb(0, devpriv->asic_iobase + REG_ENAB0 + port);
 	}
 }
 
@@ -437,12 +434,11 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 		if (irq == dev->irq) {
 			unsigned long flags;
 			unsigned triggered = 0;
-			unsigned long iobase = devpriv->asics[asic].iobase;
+			unsigned long iobase = devpriv->asic_iobase;
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-					  flags);
+			spin_lock_irqsave(&devpriv->spinlock, flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
@@ -477,8 +473,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
-					       flags);
+			spin_unlock_irqrestore(&devpriv->spinlock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -648,11 +643,9 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			    pol_bits >> (subpriv->dio.intr.first_chan +
 					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
-			outb(enab,
-			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			outb(enab, devpriv->asic_iobase + REG_ENAB0 + port);
 			switch_page(dev, asic, PAGE_POL);
-			outb(pol,
-			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			outb(pol, devpriv->asic_iobase + REG_ENAB0 + port);
 		}
 	}
 	return 0;
@@ -968,11 +961,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].iobase =
-		    dev->iobase + 16 + asic * ASIC_IOSIZE;
-		spin_lock_init(&devpriv->asics[asic].spinlock);
-	}
+	devpriv->asic_iobase = dev->iobase + 16;
+	spin_lock_init(&devpriv->spinlock);
 
 	chans_left = CHANS_PER_ASIC * 1;
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
@@ -1045,8 +1035,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				++asic;
 				thisasic_chanct = 0;
 			}
-			subpriv->iobases[byte_no] =
-			    devpriv->asics[asic].iobase + port;
+			subpriv->iobases[byte_no] = devpriv->asic_iobase + port;
 
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC

commit b16f405a6b12ba7b31db931759921f17a2b53105
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:52 2013 -0700

    staging: comedi: pcmmio: remove unused members in private data
    
    The 'pol' and 'enab' members in the private data are never used. The
    'num' member is set during the attach but never used. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a31a2b796519..1ae5ffb08a77 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -270,11 +270,6 @@ struct pcmmio_subdev_private {
 struct pcmmio_private {
 	/* stuff for DIO */
 	struct {
-		/* shadow of POLx registers */
-		unsigned char pol[NUM_PAGED_REGS];
-		/* shadow of ENABx registers */
-		unsigned char enab[NUM_PAGED_REGS];
-		int num;
 		unsigned long iobase;
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
@@ -974,7 +969,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase =
 		    dev->iobase + 16 + asic * ASIC_IOSIZE;
 		spin_lock_init(&devpriv->asics[asic].spinlock);

commit 6e6bed0b523717aa93f08ce8fe679a5c48c81cfd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:51 2013 -0700

    staging: comedi: pcmmio: tidy up the irq request
    
    The for () loop that does the request_irq() in this driver is a bit of
    an overkill. The code appears to have been copied from the pcmuio driver
    which supports boards with 1 or 2 ASIC devices. The board supported by
    this driver only has 1 ASIC.
    
    Simplify the code and store the irq number in the comedi_device. This
    allows the core to automatically do the free_irq() when the driver is
    detached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 39dff77c3655..a31a2b796519 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -276,7 +276,6 @@ struct pcmmio_private {
 		unsigned char enab[NUM_PAGED_REGS];
 		int num;
 		unsigned long iobase;
-		unsigned int irq;
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
 	struct pcmmio_subdev_private *sprivs;
@@ -440,7 +439,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		if (irq == devpriv->asics[asic].irq) {
+		if (irq == dev->irq) {
 			unsigned long flags;
 			unsigned triggered = 0;
 			unsigned long iobase = devpriv->asics[asic].iobase;
@@ -964,11 +963,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
-	unsigned int irq[MAX_ASICS];
 	int ret;
 
-	irq[0] = it->options[1];
-
 	ret = comedi_request_region(dev, it->options[0], 32);
 	if (ret)
 		return ret;
@@ -981,11 +977,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase =
 		    dev->iobase + 16 + asic * ASIC_IOSIZE;
-		/*
-		 * this gets actually set at the end of this function when we
-		 * request_irqs
-		 */
-		devpriv->asics[asic].irq = 0;
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -1102,19 +1093,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	init_asics(dev);	/* clear out all the registers, basically */
 
-	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
-		if (irq[asic]
-		    && request_irq(irq[asic], interrupt_pcmmio,
-				   IRQF_SHARED, dev->board_name, dev)) {
-			int i;
-			/* unroll the allocated irqs.. */
-			for (i = asic - 1; i >= 0; --i) {
-				free_irq(irq[i], dev);
-				devpriv->asics[i].irq = irq[i] = 0;
-			}
-			irq[asic] = 0;
-		}
-		devpriv->asics[asic].irq = irq[asic];
+	if (it->options[1]) {
+		ret = request_irq(it->options[1], interrupt_pcmmio, 0,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = it->options[1];
 	}
 
 	return 1;
@@ -1123,15 +1106,9 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void pcmmio_detach(struct comedi_device *dev)
 {
 	struct pcmmio_private *devpriv = dev->private;
-	int i;
 
-	if (devpriv) {
-		for (i = 0; i < MAX_ASICS; ++i) {
-			if (devpriv->asics[i].irq)
-				free_irq(devpriv->asics[i].irq, dev);
-		}
+	if (devpriv)
 		kfree(devpriv->sprivs);
-	}
 	comedi_legacy_detach(dev);
 }
 

commit 5d4997bbfa3bb7ed4786bd96bfcc756b02f9551a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:50 2013 -0700

    staging: comedi: pcmmio: tidy up the ao subdevice init
    
    Add some whitespace to the analog output subdevice init and reorder the
    init to follow the "norm" in comedi drivers.
    
    Remove the init of len_chanlist. This member is only used for subdevices
    the support async commands. The core will default the value correctly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9338f0c95f9f..39dff77c3655 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1016,16 +1016,15 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outb(0,
 	     dev->iobase + PCMMIO_AI_2ND_ADC_OFFSET + PCMMIO_AI_RESOURCE_REG);
 
-	/* Next, AO */
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	s->maxdata = 0xffff;
-	s->range_table = &pcmmio_ao_ranges;
-	s->subdev_flags = SDF_READABLE;
-	s->type = COMEDI_SUBD_AO;
-	s->n_chan = 8;
-	s->len_chanlist = s->n_chan;
-	s->insn_read = pcmmio_ao_insn_read;
-	s->insn_write = pcmmio_ao_insn_write;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 8;
+	s->maxdata	= 0xffff;
+	s->range_table	= &pcmmio_ao_ranges;
+	s->insn_read	= pcmmio_ao_insn_read;
+	s->insn_write	= pcmmio_ao_insn_write;
 
 	/* initialize the resource enable register by clearing it */
 	outb(0, dev->iobase + PCMMIO_AO_RESOURCE_ENA_REG);

commit 7af64f9acb2b13f24dfbb1c0aac91229671314d6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:49 2013 -0700

    staging: comedi: pcmmio: tidy up ao_rinsn()
    
    Rename this function so it has namespace associated with the driver.
    
    Move the 'chan' local variable out of the for () loop. The 'chan' is
    constant for the comedi_insn and only needs to be fetched once from
    the insn->chanspec.
    
    Also, remove the sanity check of the chan. The comedi core will ensure
    that the chan is valid for the subdevice before calling this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index d51fa69a89ac..9338f0c95f9f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -879,18 +879,19 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	struct pcmmio_private *devpriv = dev->private;
-	int n;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
 
-	for (n = 0; n < insn->n; n++) {
-		unsigned chan = CR_CHAN(insn->chanspec);
-		if (chan < s->n_chan)
-			data[n] = devpriv->ao_readback[chan];
-	}
-	return n;
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
+
+	return insn->n;
 }
 
 static int pcmmio_ao_wait_for_eoc(unsigned long iobase, unsigned int timeout)
@@ -1023,7 +1024,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->type = COMEDI_SUBD_AO;
 	s->n_chan = 8;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = ao_rinsn;
+	s->insn_read = pcmmio_ao_insn_read;
 	s->insn_write = pcmmio_ao_insn_write;
 
 	/* initialize the resource enable register by clearing it */

commit 6f216c966cfc0fb585fd8f628287d3c5100b38fa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:48 2013 -0700

    staging: comedi: pcmmio: return error if ao conversion times out
    
    Rename wait_dac_ready() so it has namespace associated with the
    driver.
    
    Fix the function so it returns an errno if the conversion times
    out. Propogate this errno if it happens.
    
    Define the analog output status register to remove the magic numbers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 42d7f1479323..d51fa69a89ac 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -122,6 +122,14 @@ Configuration Options:
 #define PCMMIO_AO_CMD_CHAN_SEL(x)		(((x) & 0x03) << 1)
 #define PCMMIO_AO_CMD_CHAN_SEL_ALL		(0x0f << 0)
 #define PCMMIO_AO_STATUS_REG			0x0b
+#define PCMMIO_AO_STATUS_DATA_READY		(1 << 7)
+#define PCMMIO_AO_STATUS_DATA_DMA_PEND		(1 << 6)
+#define PCMMIO_AO_STATUS_CMD_DMA_PEND		(1 << 5)
+#define PCMMIO_AO_STATUS_IRQ_PEND		(1 << 4)
+#define PCMMIO_AO_STATUS_DATA_DRQ_ENA		(1 << 2)
+#define PCMMIO_AO_STATUS_REG_SEL		(1 << 3)
+#define PCMMIO_AO_STATUS_CMD_DRQ_ENA		(1 << 1)
+#define PCMMIO_AO_STATUS_IRQ_ENA		(1 << 0)
 #define PCMMIO_AO_RESOURCE_ENA_REG		0x0b
 #define PCMMIO_AO_2ND_DAC_OFFSET		0x04
 
@@ -885,22 +893,16 @@ static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-static int wait_dac_ready(unsigned long iobase)
+static int pcmmio_ao_wait_for_eoc(unsigned long iobase, unsigned int timeout)
 {
-	unsigned long retry = 100000L;
-
-	/* This may seem like an absurd way to handle waiting and violates the
-	   "no busy waiting" policy. The fact is that the hardware is
-	   normally so fast that we usually only need one time through the loop
-	   anyway. The longer timeout is for rare occasions and for detecting
-	   non-existent hardware.  */
+	unsigned char status;
 
-	while (retry--) {
-		if (inb(iobase + 3) & 0x80)
+	while (timeout--) {
+		status = inb(iobase + PCMMIO_AO_STATUS_REG);
+		if (status & PCMMIO_AO_STATUS_DATA_READY)
 			return 0;
-
 	}
-	return 1;
+	return -ETIME;
 }
 
 static int pcmmio_ao_insn_write(struct comedi_device *dev,
@@ -914,6 +916,7 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int val = devpriv->ao_readback[chan];
 	unsigned char cmd = 0;
+	int ret;
 	int i;
 
 	/*
@@ -932,7 +935,9 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 	outb(PCMMIO_AO_LSB_SPAN(range), iobase + PCMMIO_AO_LSB_REG);
 	outb(0, iobase + PCMMIO_AO_MSB_REG);
 	outb(cmd | PCMMIO_AO_CMD_WR_SPAN_UPDATE, iobase + PCMMIO_AO_CMD_REG);
-	wait_dac_ready(iobase);
+	ret = pcmmio_ao_wait_for_eoc(iobase, 100000);
+	if (ret)
+		return ret;
 
 	for (i = 0; i < insn->n; i++) {
 		val = data[i];
@@ -942,7 +947,9 @@ static int pcmmio_ao_insn_write(struct comedi_device *dev,
 		outb((val >> 8) & 0xff, iobase + PCMMIO_AO_MSB_REG);
 		outb(cmd | PCMMIO_AO_CMD_WR_CODE_UPDATE,
 		     iobase + PCMMIO_AO_CMD_REG);
-		wait_dac_ready(iobase);
+		ret = pcmmio_ao_wait_for_eoc(iobase, 100000);
+		if (ret)
+			return ret;
 
 		devpriv->ao_readback[chan] = val;
 	}

commit 68533c7b8e87a907babab1da39652f1fa518697d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:47 2013 -0700

    staging: comedi: pcmmio: cleanup ao_winsn()
    
    Rename this function to have namespace associated with the driver.
    
    Refactor the function to remove the extra write to the command register
    to set the range before writing the DAC value. Since the range is constant
    for the entire comedi_insn it only needs to be set once. All writes to the
    DAC after that will use the same range.
    
    Define the register map for the analog output registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5726ded45f92..42d7f1479323 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -83,24 +83,47 @@ Configuration Options:
 /*
  * Register I/O map
  */
-#define PCMMIO_AI_LSB_REG		0x00
-#define PCMMIO_AI_MSB_REG		0x01
-#define PCMMIO_AI_CMD_REG		0x02
-#define PCMMIO_AI_CMD_SE		(1 << 7)
-#define PCMMIO_AI_CMD_ODD_CHAN		(1 << 6)
-#define PCMMIO_AI_CMD_CHAN_SEL(x)	(((x) & 0x3) << 4)
-#define PCMMIO_AI_CMD_RANGE(x)		(((x) & 0x3) << 2)
-#define PCMMIO_AI_STATUS_REG		0x03
-#define PCMMIO_AI_STATUS_DATA_READY	(1 << 7)
-#define PCMMIO_AI_STATUS_DATA_DMA_PEND	(1 << 6)
-#define PCMMIO_AI_STATUS_CMD_DMA_PEND	(1 << 5)
-#define PCMMIO_AI_STATUS_IRQ_PEND	(1 << 4)
-#define PCMMIO_AI_STATUS_DATA_DRQ_ENA	(1 << 2)
-#define PCMMIO_AI_STATUS_REG_SEL	(1 << 3)
-#define PCMMIO_AI_STATUS_CMD_DRQ_ENA	(1 << 1)
-#define PCMMIO_AI_STATUS_IRQ_ENA	(1 << 0)
-#define PCMMIO_AI_RESOURCE_REG		0x03
-#define PCMMIO_AI_2ND_ADC_OFFSET	0x04
+#define PCMMIO_AI_LSB_REG			0x00
+#define PCMMIO_AI_MSB_REG			0x01
+#define PCMMIO_AI_CMD_REG			0x02
+#define PCMMIO_AI_CMD_SE			(1 << 7)
+#define PCMMIO_AI_CMD_ODD_CHAN			(1 << 6)
+#define PCMMIO_AI_CMD_CHAN_SEL(x)		(((x) & 0x3) << 4)
+#define PCMMIO_AI_CMD_RANGE(x)			(((x) & 0x3) << 2)
+#define PCMMIO_AI_STATUS_REG			0x03
+#define PCMMIO_AI_STATUS_DATA_READY		(1 << 7)
+#define PCMMIO_AI_STATUS_DATA_DMA_PEND		(1 << 6)
+#define PCMMIO_AI_STATUS_CMD_DMA_PEND		(1 << 5)
+#define PCMMIO_AI_STATUS_IRQ_PEND		(1 << 4)
+#define PCMMIO_AI_STATUS_DATA_DRQ_ENA		(1 << 2)
+#define PCMMIO_AI_STATUS_REG_SEL		(1 << 3)
+#define PCMMIO_AI_STATUS_CMD_DRQ_ENA		(1 << 1)
+#define PCMMIO_AI_STATUS_IRQ_ENA		(1 << 0)
+#define PCMMIO_AI_RESOURCE_REG			0x03
+#define PCMMIO_AI_2ND_ADC_OFFSET		0x04
+
+#define PCMMIO_AO_LSB_REG			0x08
+#define PCMMIO_AO_LSB_SPAN(x)			(((x) & 0xf) << 0)
+#define PCMMIO_AO_MSB_REG			0x09
+#define PCMMIO_AO_CMD_REG			0x0a
+#define PCMMIO_AO_CMD_WR_SPAN			(0x2 << 4)
+#define PCMMIO_AO_CMD_WR_CODE			(0x3 << 4)
+#define PCMMIO_AO_CMD_UPDATE			(0x4 << 4)
+#define PCMMIO_AO_CMD_UPDATE_ALL		(0x5 << 4)
+#define PCMMIO_AO_CMD_WR_SPAN_UPDATE		(0x6 << 4)
+#define PCMMIO_AO_CMD_WR_CODE_UPDATE		(0x7 << 4)
+#define PCMMIO_AO_CMD_WR_SPAN_UPDATE_ALL	(0x8 << 4)
+#define PCMMIO_AO_CMD_WR_CODE_UPDATE_ALL	(0x9 << 4)
+#define PCMMIO_AO_CMD_RD_B1_SPAN		(0xa << 4)
+#define PCMMIO_AO_CMD_RD_B1_CODE		(0xb << 4)
+#define PCMMIO_AO_CMD_RD_B2_SPAN		(0xc << 4)
+#define PCMMIO_AO_CMD_RD_B2_CODE		(0xd << 4)
+#define PCMMIO_AO_CMD_NOP			(0xf << 4)
+#define PCMMIO_AO_CMD_CHAN_SEL(x)		(((x) & 0x03) << 1)
+#define PCMMIO_AO_CMD_CHAN_SEL_ALL		(0x0f << 0)
+#define PCMMIO_AO_STATUS_REG			0x0b
+#define PCMMIO_AO_RESOURCE_ENA_REG		0x0b
+#define PCMMIO_AO_2ND_DAC_OFFSET		0x04
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
@@ -880,53 +903,51 @@ static int wait_dac_ready(unsigned long iobase)
 	return 1;
 }
 
-static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct pcmmio_private *devpriv = dev->private;
-	unsigned long iobase = dev->iobase + 8;
-	unsigned int iooffset = 0;
-	int n;
-
-	for (n = 0; n < insn->n; n++) {
-		unsigned chan = CR_CHAN(insn->chanspec), range =
-		    CR_RANGE(insn->chanspec);
-		if (chan < s->n_chan) {
-			unsigned char command_byte = 0, range_byte =
-			    range & ((1 << 4) - 1);
-			if (chan >= 4)
-				chan -= 4, iooffset += 4;
-			/* set the range.. */
-			outb(range_byte, iobase + iooffset + 0);
-			outb(0, iobase + iooffset + 1);
-
-			/* tell it to begin */
-			command_byte = (chan << 1) | 0x60;
-			outb(command_byte, iobase + iooffset + 2);
+	unsigned long iobase = dev->iobase;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = devpriv->ao_readback[chan];
+	unsigned char cmd = 0;
+	int i;
 
-			wait_dac_ready(iobase + iooffset);
+	/*
+	 * The PCM-MIO has two Linear Tech LTC2704 DAC devices. Each device
+	 * is a 4-channel converter with software-selectable output range.
+	 */
 
-			/* low order byte */
-			outb(data[n] & 0xff, iobase + iooffset + 0);
+	if (chan > 3) {
+		cmd |= PCMMIO_AO_CMD_CHAN_SEL(chan - 4);
+		iobase += PCMMIO_AO_2ND_DAC_OFFSET;
+	} else {
+		cmd |= PCMMIO_AO_CMD_CHAN_SEL(chan);
+	}
 
-			/* high order byte */
-			outb((data[n] >> 8) & 0xff, iobase + iooffset + 1);
+	/* set the range for the channel */
+	outb(PCMMIO_AO_LSB_SPAN(range), iobase + PCMMIO_AO_LSB_REG);
+	outb(0, iobase + PCMMIO_AO_MSB_REG);
+	outb(cmd | PCMMIO_AO_CMD_WR_SPAN_UPDATE, iobase + PCMMIO_AO_CMD_REG);
+	wait_dac_ready(iobase);
 
-			/*
-			 * set bit 4 of command byte to indicate
-			 * data is loaded and trigger conversion
-			 */
-			command_byte = 0x70 | (chan << 1);
-			/* trigger converion */
-			outb(command_byte, iobase + iooffset + 2);
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
 
-			wait_dac_ready(iobase + iooffset);
+		/* write the data to the channel */
+		outb(val & 0xff, iobase + PCMMIO_AO_LSB_REG);
+		outb((val >> 8) & 0xff, iobase + PCMMIO_AO_MSB_REG);
+		outb(cmd | PCMMIO_AO_CMD_WR_CODE_UPDATE,
+		     iobase + PCMMIO_AO_CMD_REG);
+		wait_dac_ready(iobase);
 
-			/* save to shadow register for ao_rinsn */
-			devpriv->ao_readback[chan] = data[n];
-		}
+		devpriv->ao_readback[chan] = val;
 	}
-	return n;
+
+	return insn->n;
 }
 
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -996,11 +1017,12 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan = 8;
 	s->len_chanlist = s->n_chan;
 	s->insn_read = ao_rinsn;
-	s->insn_write = ao_winsn;
+	s->insn_write = pcmmio_ao_insn_write;
 
 	/* initialize the resource enable register by clearing it */
-	outb(0, dev->iobase + 8 + 3);
-	outb(0, dev->iobase + 8 + 4 + 3);
+	outb(0, dev->iobase + PCMMIO_AO_RESOURCE_ENA_REG);
+	outb(0, dev->iobase + PCMMIO_AO_2ND_DAC_OFFSET +
+		PCMMIO_AO_RESOURCE_ENA_REG);
 
 	port = 0;
 	asic = 0;

commit a81f87e9a08bae7a906a5cedae1ce100773c77df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:46 2013 -0700

    staging: comedi: pcmmio: remove 'iobase' from subdevice private data
    
    The 'iobase' is only used to pass the iobase address of the analog output
    registers to ao_winsn(). This address is simply dev->iobase + 8.
    
    Use that instead and remove the 'iobase' from the subdevice private data.
    This removes a couple more uses of the ugly 'subpriv' macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f889e0f9c674..5726ded45f92 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -191,9 +191,6 @@ struct pcmmio_subdev_private {
 		/* for DIO: mapping of halfwords (bytes)
 		   in port/chanarray to iobase */
 		unsigned long iobases[PORTS_PER_SUBDEV];
-
-		/* for AI/AO */
-		unsigned long iobase;
 	};
 	union {
 		struct {
@@ -887,8 +884,9 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
 	struct pcmmio_private *devpriv = dev->private;
+	unsigned long iobase = dev->iobase + 8;
+	unsigned int iooffset = 0;
 	int n;
-	unsigned iobase = subpriv->iobase, iooffset = 0;
 
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec), range =
@@ -991,7 +989,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* Next, AO */
 	s = &dev->subdevices[1];
-	s->private = &devpriv->sprivs[1];
 	s->maxdata = 0xffff;
 	s->range_table = &pcmmio_ao_ranges;
 	s->subdev_flags = SDF_READABLE;
@@ -1000,10 +997,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->len_chanlist = s->n_chan;
 	s->insn_read = ao_rinsn;
 	s->insn_write = ao_winsn;
-	subpriv->iobase = dev->iobase + 8;
+
 	/* initialize the resource enable register by clearing it */
-	outb(0, subpriv->iobase + 3);
-	outb(0, subpriv->iobase + 4 + 3);
+	outb(0, dev->iobase + 8 + 3);
+	outb(0, dev->iobase + 8 + 4 + 3);
 
 	port = 0;
 	asic = 0;

commit e83d5f266199dfdfb1761a6d2a406450e80bfac0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:45 2013 -0700

    staging: comedi: pcmmio: move ao shadow data to device private data
    
    There is only one ai subdevice in this driver so there is no reason
    to hold the last sample written to each channel in the subdevice
    private data. Move the data into the device private data,
    
    This gets some of the data out of the subdevice private data union
    and removes some of the uses of the ugly 'subpriv' macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 704911cccaf4..f889e0f9c674 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -231,10 +231,6 @@ struct pcmmio_subdev_private {
 				spinlock_t spinlock;
 			} intr;
 		} dio;
-		struct {
-			/* the last unsigned int data written */
-			unsigned int shadow_samples[8];
-		} ao;
 	};
 };
 
@@ -256,6 +252,7 @@ struct pcmmio_private {
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
 	struct pcmmio_subdev_private *sprivs;
+	unsigned int ao_readback[8];
 };
 
 #define subpriv ((struct pcmmio_subdev_private *)s->private)
@@ -857,11 +854,13 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcmmio_private *devpriv = dev->private;
 	int n;
+
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec);
 		if (chan < s->n_chan)
-			data[n] = subpriv->ao.shadow_samples[chan];
+			data[n] = devpriv->ao_readback[chan];
 	}
 	return n;
 }
@@ -887,6 +886,7 @@ static int wait_dac_ready(unsigned long iobase)
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcmmio_private *devpriv = dev->private;
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;
 
@@ -925,7 +925,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			wait_dac_ready(iobase + iooffset);
 
 			/* save to shadow register for ao_rinsn */
-			subpriv->ao.shadow_samples[chan] = data[n];
+			devpriv->ao_readback[chan] = data[n];
 		}
 	}
 	return n;

commit 170f13cca869605bd77150cb931a8cd8d35e73e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:44 2013 -0700

    staging: comedi: pcmmio: tidy up the ai subdevice init
    
    Add some whitespace to the ai subdevice init and reorder it a bit
    to follow the "norm" in comedi drivers.
    
    Remove the init of s->len_chanlist. This member is only used with
    subdevices that support async commands. The core will default the
    value correctly..
    
    The ai subdevice only uses the s->private member to pass the iobase
    to the analog input registers. It's just a copy of the dev->iobase,
    use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 52f10851fef2..704911cccaf4 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -99,6 +99,7 @@ Configuration Options:
 #define PCMMIO_AI_STATUS_REG_SEL	(1 << 3)
 #define PCMMIO_AI_STATUS_CMD_DRQ_ENA	(1 << 1)
 #define PCMMIO_AI_STATUS_IRQ_ENA	(1 << 0)
+#define PCMMIO_AI_RESOURCE_REG		0x03
 #define PCMMIO_AI_2ND_ADC_OFFSET	0x04
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
@@ -790,7 +791,7 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_insn *insn,
 			       unsigned int *data)
 {
-	unsigned long iobase = subpriv->iobase;
+	unsigned long iobase = dev->iobase;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int aref = CR_AREF(insn->chanspec);
@@ -974,20 +975,19 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	/* First, AI */
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	s->private = &devpriv->sprivs[0];
-	s->maxdata = 0xffff;
-	s->range_table = &pcmmio_ai_ranges;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
-	s->type = COMEDI_SUBD_AI;
-	s->n_chan = 16;
-	s->len_chanlist = s->n_chan;
-	s->insn_read = pcmmio_ai_insn_read;
-	subpriv->iobase = dev->iobase + 0;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF;
+	s->n_chan	= 16;
+	s->maxdata	= 0xffff;
+	s->range_table	= &pcmmio_ai_ranges;
+	s->insn_read	= pcmmio_ai_insn_read;
+
 	/* initialize the resource enable register by clearing it */
-	outb(0, subpriv->iobase + 3);
-	outb(0, subpriv->iobase + 4 + 3);
+	outb(0, dev->iobase + PCMMIO_AI_RESOURCE_REG);
+	outb(0,
+	     dev->iobase + PCMMIO_AI_2ND_ADC_OFFSET + PCMMIO_AI_RESOURCE_REG);
 
 	/* Next, AO */
 	s = &dev->subdevices[1];

commit 2d314558d7748b233305f9719a4208640c831054
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:43 2013 -0700

    staging: comedi: pcmmio: define the offset to the 2nd ADC device
    
    There are two ADC devices on this board. The first one handles ai
    channels 0-7 and the second one channels 8-15.
    
    Define the offset that is added to the iobase to access the 2nd
    ADC device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5ff0e3ad4c1c..52f10851fef2 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -99,6 +99,7 @@ Configuration Options:
 #define PCMMIO_AI_STATUS_REG_SEL	(1 << 3)
 #define PCMMIO_AI_STATUS_CMD_DRQ_ENA	(1 << 1)
 #define PCMMIO_AI_STATUS_IRQ_ENA	(1 << 0)
+#define PCMMIO_AI_2ND_ADC_OFFSET	0x04
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
@@ -815,7 +816,7 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 
 	if (chan > 7) {
 		chan -= 8;
-		iobase += 0x4;
+		iobase += PCMMIO_AI_2ND_ADC_OFFSET;
 	}
 
 	if (aref == AREF_GROUND)

commit 7ce69685a365d31184b6fd1a2cc8d96510cfbea3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:42 2013 -0700

    staging: comedi: pcmmio: return error if ai conversion times out
    
    Rename adc_wait_ready() so it has namespace associated with the
    driver.
    
    Fix the function so it returns an errno if the conversion times
    out. Propogate this errno if it happens.
    
    Define the analog input status register to remove the magic numbers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index bd45b84a3769..5ff0e3ad4c1c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -90,6 +90,15 @@ Configuration Options:
 #define PCMMIO_AI_CMD_ODD_CHAN		(1 << 6)
 #define PCMMIO_AI_CMD_CHAN_SEL(x)	(((x) & 0x3) << 4)
 #define PCMMIO_AI_CMD_RANGE(x)		(((x) & 0x3) << 2)
+#define PCMMIO_AI_STATUS_REG		0x03
+#define PCMMIO_AI_STATUS_DATA_READY	(1 << 7)
+#define PCMMIO_AI_STATUS_DATA_DMA_PEND	(1 << 6)
+#define PCMMIO_AI_STATUS_CMD_DMA_PEND	(1 << 5)
+#define PCMMIO_AI_STATUS_IRQ_PEND	(1 << 4)
+#define PCMMIO_AI_STATUS_DATA_DRQ_ENA	(1 << 2)
+#define PCMMIO_AI_STATUS_REG_SEL	(1 << 3)
+#define PCMMIO_AI_STATUS_CMD_DRQ_ENA	(1 << 1)
+#define PCMMIO_AI_STATUS_IRQ_ENA	(1 << 0)
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
@@ -763,13 +772,16 @@ static int pcmmio_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static int adc_wait_ready(unsigned long iobase)
+static int pcmmio_ai_wait_for_eoc(unsigned long iobase, unsigned int timeout)
 {
-	unsigned long retry = 100000;
-	while (retry--)
-		if (inb(iobase + 3) & 0x80)
+	unsigned char status;
+
+	while (timeout--) {
+		status = inb(iobase + PCMMIO_AI_STATUS_REG);
+		if (status & PCMMIO_AI_STATUS_DATA_READY)
 			return 0;
-	return 1;
+	}
+	return -ETIME;
 }
 
 static int pcmmio_ai_insn_read(struct comedi_device *dev,
@@ -783,6 +795,7 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 	unsigned int aref = CR_AREF(insn->chanspec);
 	unsigned char cmd = 0;
 	unsigned int val;
+	int ret;
 	int i;
 
 	/*
@@ -813,14 +826,18 @@ static int pcmmio_ai_insn_read(struct comedi_device *dev,
 	cmd |= PCMMIO_AI_CMD_RANGE(range);
 
 	outb(cmd, iobase + PCMMIO_AI_CMD_REG);
-	adc_wait_ready(iobase);
+	ret = pcmmio_ai_wait_for_eoc(iobase, 100000);
+	if (ret)
+		return ret;
 
 	val = inb(iobase + PCMMIO_AI_LSB_REG);
 	val |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;
 
 	for (i = 0; i < insn->n; i++) {
 		outb(cmd, iobase + PCMMIO_AI_CMD_REG);
-		adc_wait_ready(iobase);
+		ret = pcmmio_ai_wait_for_eoc(iobase, 100000);
+		if (ret)
+			return ret;
 
 		val = inb(iobase + PCMMIO_AI_LSB_REG);
 		val |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;

commit 8b0fcb59922dae8215ae0380c3a41c5affca02da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:41 2013 -0700

    staging: comedi: pcmmio: cleanup ai_rinsn()
    
    Rename this function to have namespace associated with the driver.
    
    Refactor the function to remove the extra write to the command register
    between each ADC conversion. We only need to do one dummy conversion in
    order to flush the serial ADC. After that each command will return the
    result of the previous conversion.
    
    Define the register map for the analog input registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index eb6139570f3e..bd45b84a3769 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -80,6 +80,17 @@ Configuration Options:
 
 #include "comedi_fc.h"
 
+/*
+ * Register I/O map
+ */
+#define PCMMIO_AI_LSB_REG		0x00
+#define PCMMIO_AI_MSB_REG		0x01
+#define PCMMIO_AI_CMD_REG		0x02
+#define PCMMIO_AI_CMD_SE		(1 << 7)
+#define PCMMIO_AI_CMD_ODD_CHAN		(1 << 6)
+#define PCMMIO_AI_CMD_CHAN_SEL(x)	(((x) & 0x3) << 4)
+#define PCMMIO_AI_CMD_RANGE(x)		(((x) & 0x3) << 2)
+
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
@@ -761,85 +772,67 @@ static int adc_wait_ready(unsigned long iobase)
 	return 1;
 }
 
-/* All this is for AI and AO */
-static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
-	int n;
 	unsigned long iobase = subpriv->iobase;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int aref = CR_AREF(insn->chanspec);
+	unsigned char cmd = 0;
+	unsigned int val;
+	int i;
 
 	/*
-	   1. write the CMD byte (to BASE+2)
-	   2. read junk lo byte (BASE+0)
-	   3. read junk hi byte (BASE+1)
-	   4. (mux settled so) write CMD byte again (BASE+2)
-	   5. read valid lo byte(BASE+0)
-	   6. read valid hi byte(BASE+1)
-
-	   Additionally note that the BASE += 4 if the channel >= 8
+	 * The PCM-MIO uses two Linear Tech LTC1859CG 8-channel A/D converters.
+	 * The devices use a full duplex serial interface which transmits and
+	 * receives data simultaneously. An 8-bit command is shifted into the
+	 * ADC interface to configure it for the next conversion. At the same
+	 * time, the data from the previous conversion is shifted out of the
+	 * device. Consequently, the conversion result is delayed by one
+	 * conversion from the command word.
+	 *
+	 * Setup the cmd for the conversions then do a dummy conversion to
+	 * flush the junk data. Then do each conversion requested by the
+	 * comedi_insn. Note that the last conversion will leave junk data
+	 * in ADC which will get flushed on the next comedi_insn.
 	 */
 
-	/* convert n samples */
-	for (n = 0; n < insn->n; n++) {
-		unsigned chan = CR_CHAN(insn->chanspec), range =
-		    CR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);
-		unsigned char command_byte = 0;
-		unsigned iooffset = 0;
-		unsigned int val;
-
-		if (chan > 7)
-			chan -= 8, iooffset = 4;	/*
-							 * use the second dword
-							 * for channels > 7
-							 */
-
-		if (aref != AREF_DIFF) {
-			aref = AREF_GROUND;
-			command_byte |= 1 << 7;	/*
-						 * set bit 7 to indicate
-						 * single-ended
-						 */
-		}
-
-		if (chan % 2) {
-			command_byte |= 1 << 6;	/*
-						 * odd-numbered channels
-						 * have bit 6 set
-						 */
-		}
-
-		/* select the channel, bits 4-5 == chan/2 */
-		command_byte |= ((chan / 2) & 0x3) << 4;
-
-		/* set the range, bits 2-3 */
-		command_byte |= (range & 0x3) << 2;
-
-		/* need to do this twice to make sure mux settled */
-		/* chan/range/aref select */
-		outb(command_byte, iobase + iooffset + 2);
+	if (chan > 7) {
+		chan -= 8;
+		iobase += 0x4;
+	}
 
-		/* wait for the adc to say it finised the conversion */
-		adc_wait_ready(iobase + iooffset);
+	if (aref == AREF_GROUND)
+		cmd |= PCMMIO_AI_CMD_SE;
+	if (chan % 2)
+		cmd |= PCMMIO_AI_CMD_ODD_CHAN;
+	cmd |= PCMMIO_AI_CMD_CHAN_SEL(chan / 2);
+	cmd |= PCMMIO_AI_CMD_RANGE(range);
 
-		/* select the chan/range/aref AGAIN */
-		outb(command_byte, iobase + iooffset + 2);
+	outb(cmd, iobase + PCMMIO_AI_CMD_REG);
+	adc_wait_ready(iobase);
 
-		adc_wait_ready(iobase + iooffset);
+	val = inb(iobase + PCMMIO_AI_LSB_REG);
+	val |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;
 
-		/* read data lo byte */
-		val = inb(iobase + iooffset + 0);
+	for (i = 0; i < insn->n; i++) {
+		outb(cmd, iobase + PCMMIO_AI_CMD_REG);
+		adc_wait_ready(iobase);
 
-		/* read data hi byte */
-		val |= inb(iobase + iooffset + 1) << 8;
+		val = inb(iobase + PCMMIO_AI_LSB_REG);
+		val |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;
 
 		/* bipolar data is two's complement */
 		if (comedi_range_is_bipolar(s, range))
 			val = comedi_offset_munge(s, val);
 
-		data[n] = val;
+		data[i] = val;
 	}
-	/* return the number of samples read/written */
-	return n;
+
+	return insn->n;
 }
 
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -972,7 +965,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->type = COMEDI_SUBD_AI;
 	s->n_chan = 16;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = ai_rinsn;
+	s->insn_read = pcmmio_ai_insn_read;
 	subpriv->iobase = dev->iobase + 0;
 	/* initialize the resource enable register by clearing it */
 	outb(0, subpriv->iobase + 3);

commit 5fde07640cc9905f961afd5b78d2269e157eea7c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:40 2013 -0700

    staging: comedi: pcmmio: use core helpers to munge bipolar ai data
    
    Use the comedi_range_is_bipolar() and comedi_offset_munge() helpers to
    munge the bipolar analog input data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9394782fb74b..eb6139570f3e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -785,7 +785,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    CR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);
 		unsigned char command_byte = 0;
 		unsigned iooffset = 0;
-		unsigned short sample, adc_adjust = 0;
+		unsigned int val;
 
 		if (chan > 7)
 			chan -= 8, iooffset = 4;	/*
@@ -800,14 +800,6 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 						 * single-ended
 						 */
 		}
-		if (range < 2)
-			adc_adjust = 0x8000;	/*
-						 * bipolar ranges
-						 * (-5,5 .. -10,10 need to be
-						 * adjusted -- that is.. they
-						 * need to wrap around by
-						 * adding 0x8000
-						 */
 
 		if (chan % 2) {
 			command_byte |= 1 << 6;	/*
@@ -835,12 +827,16 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		adc_wait_ready(iobase + iooffset);
 
 		/* read data lo byte */
-		sample = inb(iobase + iooffset + 0);
+		val = inb(iobase + iooffset + 0);
 
 		/* read data hi byte */
-		sample |= inb(iobase + iooffset + 1) << 8;
-		sample += adc_adjust;	/* adjustment .. munge data */
-		data[n] = sample;
+		val |= inb(iobase + iooffset + 1) << 8;
+
+		/* bipolar data is two's complement */
+		if (comedi_range_is_bipolar(s, range))
+			val = comedi_offset_munge(s, val);
+
+		data[n] = val;
 	}
 	/* return the number of samples read/written */
 	return n;

commit f9ec4efd3c5ffd9b9ea58fe85b395c54600006b6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:39 2013 -0700

    staging: comedi: pcmmio: cleanup comedi_lrange tables
    
    Use the BIP_RANGE and UNI_RANGE macros where appropriate instead of
    the more generic RANGE macro.
    
    Rename the range tables so they have namespace associated with the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a27992098916..9394782fb74b 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -142,13 +142,24 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-static const struct comedi_lrange ranges_ai = {
-	4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0., 10.)}
+static const struct comedi_lrange pcmmio_ai_ranges = {
+	4, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(10)
+	}
 };
 
-static const struct comedi_lrange ranges_ao = {
-	6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
-	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
+static const struct comedi_lrange pcmmio_ao_ranges = {
+	6, {
+		UNI_RANGE(5),
+		UNI_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		BIP_RANGE(2.5),
+		RANGE(-2.5, 7.5)
+	}
 };
 
 /* this structure is for data unique to this subdevice.  */
@@ -960,7 +971,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s = &dev->subdevices[0];
 	s->private = &devpriv->sprivs[0];
 	s->maxdata = 0xffff;
-	s->range_table = &ranges_ai;
+	s->range_table = &pcmmio_ai_ranges;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
 	s->type = COMEDI_SUBD_AI;
 	s->n_chan = 16;
@@ -975,7 +986,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s = &dev->subdevices[1];
 	s->private = &devpriv->sprivs[1];
 	s->maxdata = 0xffff;
-	s->range_table = &ranges_ao;
+	s->range_table = &pcmmio_ao_ranges;
 	s->subdev_flags = SDF_READABLE;
 	s->type = COMEDI_SUBD_AO;
 	s->n_chan = 8;

commit 7645694c697cb0425a3590620d0673aa88dc6105
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:38 2013 -0700

    staging: comedi: pcmmio: tidy up switch_page()
    
    All the I/O ports are left unlocked in the driver so the 'pagelock'
    in the private data is not necessary. The paranoia sanity checks
    are also unnecessary, Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 850b8f152a0b..a27992098916 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -213,7 +213,6 @@ struct pcmmio_subdev_private {
 struct pcmmio_private {
 	/* stuff for DIO */
 	struct {
-		unsigned char pagelock;	/* current page and lock */
 		/* shadow of POLx registers */
 		unsigned char pol[NUM_PAGED_REGS];
 		/* shadow of ENABx registers */
@@ -318,16 +317,7 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 {
 	struct pcmmio_private *devpriv = dev->private;
 
-	if (asic < 0 || asic >= 1)
-		return;		/* paranoia */
-	if (page < 0 || page >= NUM_PAGES)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
-	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
-
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
+	outb(page << REG_PAGE_BITOFFSET,
 	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 }
 

commit 2ab62fdfc3bc68060300182a335daab1422df14c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 15:30:37 2013 -0700

    staging: comedi: pcmmio: remove unused {lock, unlock}_port()
    
    These functions are #ifdef'ed out and not needed in the driver.
    Just remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index ec098d883eb7..850b8f152a0b 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -362,38 +362,6 @@ static void init_asics(struct comedi_device *dev)
 	}
 }
 
-#ifdef notused
-static void lock_port(struct comedi_device *dev, int asic, int port)
-{
-	struct pcmmio_private *devpriv = dev->private;
-
-	if (asic < 0 || asic >= 1)
-		return;		/* paranoia */
-	if (port < 0 || port >= PORTS_PER_ASIC)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock |= 0x1 << port;
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     devpriv->asics[asic].iobase + REG_PAGELOCK);
-	return;
-}
-
-static void unlock_port(struct comedi_device *dev, int asic, int port)
-{
-	struct pcmmio_private *devpriv = dev->private;
-
-	if (asic < 0 || asic >= 1)
-		return;		/* paranoia */
-	if (port < 0 || port >= PORTS_PER_ASIC)
-		return;		/* more paranoia */
-	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     devpriv->asics[asic].iobase + REG_PAGELOCK);
-}
-#endif /* notused */
-
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {

commit 15d2006970edfc580e1508f96bbbf788ffb991e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:32 2013 -0700

    staging: comedi: pcmmio.c: remove kcalloc() failure message
    
    An allocation failure will have already displayed a message.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 063496d6c00e..ec098d883eb7 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -991,11 +991,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->sprivs =
 	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
 		    GFP_KERNEL);
-	if (!devpriv->sprivs) {
-		printk(KERN_ERR "comedi%d: cannot allocate subdevice private data structures\n",
-				dev->minor);
+	if (!devpriv->sprivs)
 		return -ENOMEM;
-	}
 
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret)

commit c4815b3d2cf43b9136e356839ed71847ad042b65
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:26 2013 -0700

    staging: comedi: pcmmio: convert a KERN_DEBUG message to dev_dbg()
    
    Convert a printk(KERN_DEBUG ... message to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6da836e8caf1..063496d6c00e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -476,9 +476,9 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				 * TODO here: dispatch io lines to subdevs
 				 * with commands..
 				 */
-				printk
-				    (KERN_DEBUG "got edge detect interrupt %d asic %d which_chans: %06x\n",
-				     irq, asic, triggered);
+				dev_dbg(dev->class_dev,
+					"got edge detect interrupt %d asic %d which_chans: %06x\n",
+					irq, asic, triggered);
 				for (i = 2; i < dev->n_subdevices; i++) {
 					s = &dev->subdevices[i];
 					/*

commit 733cde0ef1c2b8a44ab32c27b9f0c508a2e6c67f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:24 2013 -0700

    staging: comedi: pcmmio: remove commented out debug code
    
    Remove the commented out code in init_asics() that enables the rising
    edge interrupts on port0 of both asics.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 1ebc9d2df67d..6da836e8caf1 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -357,13 +357,6 @@ static void init_asics(struct comedi_device *dev)
 				outb(0, baseaddr + reg);
 		}
 
-		/* DEBUG  set rising edge interrupts on port0 of both asics */
-		/*switch_page(dev, asic, PAGE_POL);
-		   outb(0xff, baseaddr + REG_POL0);
-		   switch_page(dev, asic, PAGE_ENAB);
-		   outb(0xff, baseaddr + REG_ENAB0); */
-		/* END DEBUG */
-
 		/* switch back to default page 0 */
 		switch_page(dev, asic, 0);
 	}

commit 4bb82d647dad7be06341ffdb9f07a56a387e213f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:23 2013 -0700

    staging: comedi: pcmmio: remove DAMMIT_ITS_BROKEN debug
    
    These debug messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 14cee3ac92c5..1ebc9d2df67d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -250,11 +250,6 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 
-#ifdef DAMMIT_ITS_BROKEN
-	/* DEBUG */
-	printk(KERN_DEBUG "write mask: %08x  data: %08x\n", data[0], data[1]);
-#endif
-
 	s->state = 0;
 
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
@@ -271,14 +266,6 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
-#ifdef DAMMIT_ITS_BROKEN
-		/* DEBUG */
-		printk
-		    (KERN_DEBUG "byte %d wmb %02x db %02x offset %02d io %04x,"
-		     " data_in %02x ", byte_no, (unsigned)write_mask_byte,
-		     (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
-#endif
-
 		if (write_mask_byte) {
 			/*
 			 * this byte has some write_bits
@@ -291,10 +278,6 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 			/* Write out the new digital output state */
 			outb(byte, ioaddr);
 		}
-#ifdef DAMMIT_ITS_BROKEN
-		/* DEBUG */
-		printk(KERN_DEBUG "data_out_byte %02x\n", (unsigned)byte);
-#endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
 	}
@@ -302,11 +285,6 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 	/* now return the DIO lines to data[1] - note they came inverted! */
 	data[1] = ~s->state;
 
-#ifdef DAMMIT_ITS_BROKEN
-	/* DEBUG */
-	printk(KERN_DEBUG "s->state %08x data_out %08x\n", s->state, data[1]);
-#endif
-
 	return insn->n;
 }
 

commit f23b65a58888555524851086d0fa418525650c83
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:32 2013 +0100

    staging: comedi: pcmmio: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change `interrupt_pcmmio()` and `ai_rinsn()` in the "pcmmio" module to
    use unsigned sample values for consistency.
    
    Also, make the order in which `interrupt_pcmmio()` writes the two sample
    values (each actually containing up to 16 1-bit sample values)
    independent of the host byte ordering.
    
    Note that this module is a mess, so please excuse the checkpatch
    warnings.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 574443df42da..14cee3ac92c5 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -553,12 +553,11 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 										val |= (1U << n);
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *)&val)[0])
+								if (comedi_buf_put(s->async, val)
 								    &&
 								    comedi_buf_put
 								    (s->async,
-								     ((short *)
-								      &val)[1])) {
+								     val >> 16)) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
@@ -846,7 +845,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		    CR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);
 		unsigned char command_byte = 0;
 		unsigned iooffset = 0;
-		short sample, adc_adjust = 0;
+		unsigned short sample, adc_adjust = 0;
 
 		if (chan > 7)
 			chan -= 8, iooffset = 4;	/*

commit b88e75bb6576d99e0ba4f6edc978293d1ff9c01b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 20 16:55:41 2013 +0100

    staging: comedi: pcmmio: remove unneeded checks on detach
    
    As pointed out by Dan carpenter for the similar pcmuio driver, there is
    no need to check the pointer passed to `kfree()`, so remove that check
    from `pcmmio_detach()`.
    
    Also, check the `devpriv` (`dev->private`) pointer once, outside the
    `for` loop.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index aa3c0307483d..574443df42da 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1156,12 +1156,13 @@ static void pcmmio_detach(struct comedi_device *dev)
 	struct pcmmio_private *devpriv = dev->private;
 	int i;
 
-	for (i = 0; i < MAX_ASICS; ++i) {
-		if (devpriv && devpriv->asics[i].irq)
-			free_irq(devpriv->asics[i].irq, dev);
-	}
-	if (devpriv && devpriv->sprivs)
+	if (devpriv) {
+		for (i = 0; i < MAX_ASICS; ++i) {
+			if (devpriv->asics[i].irq)
+				free_irq(devpriv->asics[i].irq, dev);
+		}
 		kfree(devpriv->sprivs);
+	}
 	comedi_legacy_detach(dev);
 }
 

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index fab93a73651d..aa3c0307483d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -310,68 +310,27 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* The input or output configuration of each digital line is
- * configured by a special insn_config instruction.  chanspec
- * contains the channel to be changed, and data[0] contains the
- * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmmio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
-	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-	    chan % 8;
-	unsigned long ioaddr;
-	unsigned char byte;
-
-	/* Compute ioaddr for this channel */
-	ioaddr = subpriv->iobases[byte_no];
-
-	/* NOTE:
-	   writing a 0 an IO channel's bit sets the channel to INPUT
-	   and pulls the line high as well
-
-	   writing a 1 to an IO channel's  bit pulls the line low
-
-	   All channels are implicitly always in OUTPUT mode -- but when
-	   they are high they can be considered to be in INPUT mode..
-
-	   Thus, we only force channels low if the config request was INPUT,
-	   otherwise we do nothing to the hardware.    */
-
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		/* save to io_bits -- don't actually do anything since
-		   all input channels are also output channels... */
-		s->io_bits |= 1 << chan;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		/* write a 0 to the actual register representing the channel
-		   to set it to 'input'.  0 means "float high". */
-		byte = inb(ioaddr);
-		byte &= ~(1 << bit_no);
-				/**< set input channel to '0' */
-
-		/*
-		 * write out byte -- this is the only time we actually affect
-		 * the hardware as all channels are implicitly output
-		 * -- but input channels are set to float-high
-		 */
-		outb(byte, ioaddr);
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int byte_no = chan / 8;
+	int bit_no = chan % 8;
+	int ret;
 
-		/* save to io_bits */
-		s->io_bits &= ~(1 << chan);
-		break;
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
-	case INSN_CONFIG_DIO_QUERY:
-		/* retrieve from shadow register */
-		data[1] =
-		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-		break;
+	if (data[0] == INSN_CONFIG_DIO_INPUT) {
+		unsigned long ioaddr = subpriv->iobases[byte_no];
+		unsigned char val;
 
-	default:
-		return -EINVAL;
-		break;
+		val = inb(ioaddr);
+		val &= ~(1 << bit_no);
+		outb(val, ioaddr);
 	}
 
 	return insn->n;

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index feb83caef26f..fab93a73651d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -72,6 +72,7 @@ Configuration Options:
 	leave out if you don't need this feature)
 */
 
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9f76b1f59983..feb83caef26f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1039,10 +1039,9 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5a236cd5b33d..9f76b1f59983 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -14,10 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 /*
 Driver: pcmmio

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index d06e18191281..5a236cd5b33d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1193,11 +1193,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].irq = irq[asic];
 	}
 
-	dev->irq = irq[0];	/*
-				 * grr.. wish comedi dev struct supported
-				 * multiple irqs..
-				 */
-
 	return 1;
 }
 

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9166af996f16..d06e18191281 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1206,14 +1206,13 @@ static void pcmmio_detach(struct comedi_device *dev)
 	struct pcmmio_private *devpriv = dev->private;
 	int i;
 
-	if (dev->iobase)
-		release_region(dev->iobase, 32);
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
 	}
 	if (devpriv && devpriv->sprivs)
 		kfree(devpriv->sprivs);
+	comedi_legacy_detach(dev);
 }
 
 static struct comedi_driver pcmmio_driver = {

commit 1bdf7c2edfd2aa00f2a016fe997eb3297a02e1e5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:27:27 2013 -0700

    staging: comedi: pcmmio: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a342e3799c51..9166af996f16 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1034,22 +1034,14 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
-	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
-	iobase = it->options[0];
 	irq[0] = it->options[1];
 
-	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
-			dev->board_name, iobase);
-
-	dev->iobase = iobase;
-
-	if (!iobase || !request_region(iobase, 32, dev->board_name)) {
-		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
-		return -EIO;
-	}
+	ret = comedi_request_region(dev, it->options[0], 32);
+	if (ret)
+		return ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -1206,8 +1198,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 * multiple irqs..
 				 */
 
-	printk(KERN_INFO "comedi%d: attached\n", dev->minor);
-
 	return 1;
 }
 

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5fa1fe08eb97..a342e3799c51 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1038,8 +1038,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	iobase = it->options[0];
 	irq[0] = it->options[1];
 

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index d6d3d9584ea4..5fa1fe08eb97 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -78,9 +78,9 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-#include <linux/pci.h>
 
 #include "../comedidev.h"
+
 #include "comedi_fc.h"
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */

commit 90a35c15c5d7d5c6254772d2752975dda185710c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 17:27:02 2012 -0700

    staging: comedi: store the 'index' for each subdevice
    
    Store the 'index' for each comedi_subdevice when they are initially
    allocated by comedi_alloc_subdevice(). This allows removing the
    pointer math in comedi_fops.c which is used to figure out the
    index that user space uses to access the individual subdevices.
    
    Fix the ni_mio_common driver so it also uses the 'index' instead
    of doing the pointer math.
    
    Also, remove a couple unused macros in the pcmda12, pcmmio, and
    pcmuio drivers which also do the pointer math to figure out the
    index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 045f44201958..d6d3d9584ea4 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -94,7 +94,6 @@ Configuration Options:
 #define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
 #define MAX_DIO_CHANS   (PORTS_PER_ASIC*1*CHANS_PER_PORT)
 #define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
-#define SDEV_NO ((int)(s - dev->subdevices))
 #define CALC_N_DIO_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
 /* IO Memory sizes */
 #define ASIC_IOSIZE (0x0B)

commit f95d45d114e1fd024bdee67beb80fce9b9c96126
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Dec 4 15:47:14 2012 -0700

    staging: comedi: pcm_common: remove module
    
    This module is built whenever CONFIG_COMEDI is enabled but it is
    only used by the pcmmio and pcmuio drivers. The pcm_common module
    consists of one exported function. Put a local copy of the function
    in the pcmmio and pcmuio drivers.
    
    This removes the need for the pcm_common module and the now unused
    pcm_common.[ch] files can be deleted and removed from the Makefile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 7522bfb6db08..045f44201958 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -78,9 +78,10 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/pci.h>
+
 #include "../comedidev.h"
-#include "pcm_common.h"
-#include <linux/pci.h>		/* for PCI devices */
+#include "comedi_fc.h"
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
@@ -802,11 +803,59 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int
-pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	       struct comedi_cmd *cmd)
+static int pcmmio_cmdtest(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_cmd *cmd)
 {
-	return comedi_pcm_cmdtest(dev, s, cmd);
+	int err = 0;
+
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+
+	if (err)
+		return 1;
+
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
 }
 
 static int adc_wait_ready(unsigned long iobase)

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 616652e00ef9..7522bfb6db08 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1005,10 +1005,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6ab45dfe68f0..616652e00ef9 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -229,11 +229,6 @@ struct pcmmio_private {
 	struct pcmmio_subdev_private *sprivs;
 };
 
-/*
- * most drivers define the following macro to make it easy to
- * access the private structure.
- */
-#define devpriv ((struct pcmmio_private *)dev->private)
 #define subpriv ((struct pcmmio_subdev_private *)s->private)
 
 /* DIO devices are slightly special.  Although it is possible to
@@ -387,6 +382,8 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
+	struct pcmmio_private *devpriv = dev->private;
+
 	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (page < 0 || page >= NUM_PAGES)
@@ -403,6 +400,7 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
+	struct pcmmio_private *devpriv = dev->private;
 	int asic;
 
 	for (asic = 0; asic < 1; ++asic) {
@@ -440,6 +438,8 @@ static void init_asics(struct comedi_device *dev)
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
+	struct pcmmio_private *devpriv = dev->private;
+
 	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
@@ -454,6 +454,8 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
+	struct pcmmio_private *devpriv = dev->private;
+
 	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
@@ -468,6 +470,7 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 static void pcmmio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pcmmio_private *devpriv = dev->private;
 	int nports, firstport, asic, port;
 
 	asic = subpriv->dio.intr.asic;
@@ -490,6 +493,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *)d;
+	struct pcmmio_private *devpriv = dev->private;
 	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
@@ -649,6 +653,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 static int pcmmio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pcmmio_private *devpriv = dev->private;
+
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
@@ -976,6 +982,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct pcmmio_private *devpriv;
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
@@ -998,15 +1005,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
-		printk(KERN_ERR "comedi%d: cannot allocate private data structure\n",
-				dev->minor);
-		return -ENOMEM;
-	}
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;
@@ -1165,6 +1167,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmmio_detach(struct comedi_device *dev)
 {
+	struct pcmmio_private *devpriv = dev->private;
 	int i;
 
 	if (dev->iobase)

commit 16339125416f9d41f24f4ea1e10819ccdb3c8937
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 8 10:43:43 2012 -0700

    staging: comedi: pcmmio: remove boardinfo
    
    This driver only supports a single "boardtype". Remove the unneeded
    boardinfo struct and its use in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a10bf0a2987f..6ab45dfe68f0 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -145,35 +145,6 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-/*
- * Board descriptions for two imaginary boards.  Describing the
- * boards in this way is optional, and completely driver-dependent.
- * Some drivers use arrays such as this, other do not.
- */
-struct pcmmio_board {
-	const char *name;
-	const int dio_num_asics;
-	const int dio_num_ports;
-	const int total_iosize;
-	const int ai_bits;
-	const int ao_bits;
-	const int n_ai_chans;
-	const int n_ao_chans;
-	const struct comedi_lrange *ai_range_table, *ao_range_table;
-	int (*ai_rinsn) (struct comedi_device *dev,
-			struct comedi_subdevice *s,
-			struct comedi_insn *insn,
-			unsigned int *data);
-	int (*ao_rinsn) (struct comedi_device *dev,
-			struct comedi_subdevice *s,
-			struct comedi_insn *insn,
-			unsigned int *data);
-	int (*ao_winsn) (struct comedi_device *dev,
-			struct comedi_subdevice *s,
-			struct comedi_insn *insn,
-			unsigned int *data);
-};
-
 static const struct comedi_lrange ranges_ai = {
 	4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0., 10.)}
 };
@@ -416,9 +387,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
-	const struct pcmmio_board *board = comedi_board(dev);
-
-	if (asic < 0 || asic >= board->dio_num_asics)
+	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (page < 0 || page >= NUM_PAGES)
 		return;		/* more paranoia */
@@ -434,10 +403,9 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
-	const struct pcmmio_board *board = comedi_board(dev);
 	int asic;
 
-	for (asic = 0; asic < board->dio_num_asics; ++asic) {
+	for (asic = 0; asic < 1; ++asic) {
 		int port, page;
 		unsigned long baseaddr = devpriv->asics[asic].iobase;
 
@@ -472,9 +440,7 @@ static void init_asics(struct comedi_device *dev)
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
-	const struct pcmmio_board *board = comedi_board(dev);
-
-	if (asic < 0 || asic >= board->dio_num_asics)
+	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -488,9 +454,7 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
-	const struct pcmmio_board *board = comedi_board(dev);
-
-	if (asic < 0 || asic >= board->dio_num_asics)
+	if (asic < 0 || asic >= 1)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -1012,7 +976,6 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct pcmmio_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
@@ -1020,23 +983,21 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
+	dev->board_name = dev->driver->driver_name;
+
 	iobase = it->options[0];
 	irq[0] = it->options[1];
 
 	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
-			dev->driver->driver_name, iobase);
+			dev->board_name, iobase);
 
 	dev->iobase = iobase;
 
-	if (!iobase || !request_region(iobase,
-				       board->total_iosize,
-				       dev->driver->driver_name)) {
+	if (!iobase || !request_region(iobase, 32, dev->board_name)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
 		return -EIO;
 	}
 
-	dev->board_name = board->name;
-
 /*
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
@@ -1059,7 +1020,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
-	chans_left = CHANS_PER_ASIC * board->dio_num_asics;
+	chans_left = CHANS_PER_ASIC * 1;
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
 	n_subdevs = n_dio_subdevs + 2;
 	devpriv->sprivs =
@@ -1078,13 +1039,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* First, AI */
 	s = &dev->subdevices[0];
 	s->private = &devpriv->sprivs[0];
-	s->maxdata = (1 << board->ai_bits) - 1;
-	s->range_table = board->ai_range_table;
+	s->maxdata = 0xffff;
+	s->range_table = &ranges_ai;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
 	s->type = COMEDI_SUBD_AI;
-	s->n_chan = board->n_ai_chans;
+	s->n_chan = 16;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = board->ai_rinsn;
+	s->insn_read = ai_rinsn;
 	subpriv->iobase = dev->iobase + 0;
 	/* initialize the resource enable register by clearing it */
 	outb(0, subpriv->iobase + 3);
@@ -1093,14 +1054,14 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Next, AO */
 	s = &dev->subdevices[1];
 	s->private = &devpriv->sprivs[1];
-	s->maxdata = (1 << board->ao_bits) - 1;
-	s->range_table = board->ao_range_table;
+	s->maxdata = 0xffff;
+	s->range_table = &ranges_ao;
 	s->subdev_flags = SDF_READABLE;
 	s->type = COMEDI_SUBD_AO;
-	s->n_chan = board->n_ao_chans;
+	s->n_chan = 8;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = board->ao_rinsn;
-	s->insn_write = board->ao_winsn;
+	s->insn_read = ao_rinsn;
+	s->insn_write = ao_winsn;
 	subpriv->iobase = dev->iobase + 8;
 	/* initialize the resource enable register by clearing it */
 	outb(0, subpriv->iobase + 3);
@@ -1180,7 +1141,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
 		    && request_irq(irq[asic], interrupt_pcmmio,
-				   IRQF_SHARED, board->name, dev)) {
+				   IRQF_SHARED, dev->board_name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -1204,11 +1165,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmmio_detach(struct comedi_device *dev)
 {
-	const struct pcmmio_board *board = comedi_board(dev);
 	int i;
 
 	if (dev->iobase)
-		release_region(dev->iobase, board->total_iosize);
+		release_region(dev->iobase, 32);
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
@@ -1217,32 +1177,11 @@ static void pcmmio_detach(struct comedi_device *dev)
 		kfree(devpriv->sprivs);
 }
 
-static const struct pcmmio_board pcmmio_boards[] = {
-	{
-		.name		= "pcmmio",
-		.dio_num_asics	= 1,
-		.dio_num_ports	= 6,
-		.total_iosize	= 32,
-		.ai_bits	= 16,
-		.ao_bits	= 16,
-		.n_ai_chans	= 16,
-		.n_ao_chans	= 8,
-		.ai_range_table	= &ranges_ai,
-		.ao_range_table	= &ranges_ao,
-		.ai_rinsn	= ai_rinsn,
-		.ao_rinsn	= ao_rinsn,
-		.ao_winsn	= ao_winsn
-	},
-};
-
 static struct comedi_driver pcmmio_driver = {
 	.driver_name	= "pcmmio",
 	.module		= THIS_MODULE,
 	.attach		= pcmmio_attach,
 	.detach		= pcmmio_detach,
-	.board_name	= &pcmmio_boards[0].name,
-	.offset		= sizeof(struct pcmmio_board),
-	.num_names	= ARRAY_SIZE(pcmmio_boards),
 };
 module_comedi_driver(pcmmio_driver);
 

commit 765c3c64f76a786cd01f3b479ee63b79cb9343d0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 17 13:16:45 2012 -0700

    staging: comedi: pcmmio: remove kernel messages about IRQ
    
    These messages are just added noise.
    
    They also cause some sparse warnings due to MAX_ASICS evaluating
    as 1. This causes the local variable 'irq' to be 'unsigned int irq[1]',
    which makes the 'irq[1]' access invalid.
    
    Just remove the messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9a9af0be473a..a10bf0a2987f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1197,15 +1197,6 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 * multiple irqs..
 				 */
 
-	if (irq[0]) {
-		printk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);
-		if (board->dio_num_asics == 2 && irq[1])
-			printk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",
-					dev->minor, irq[1]);
-	} else {
-		printk(KERN_INFO "comedi%d: (IRQ mode disabled)\n", dev->minor);
-	}
-
 	printk(KERN_INFO "comedi%d: attached\n", dev->minor);
 
 	return 1;

commit 33e101ad9d6f8d23fb67d92081e8c2a5b695d83c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:54:46 2012 -0700

    staging: comedi: pcmmio: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3d2e6f01c4b7..9a9af0be473a 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -526,6 +526,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *)d;
+	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -583,9 +584,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				printk
 				    (KERN_DEBUG "got edge detect interrupt %d asic %d which_chans: %06x\n",
 				     irq, asic, triggered);
-				for (s = dev->subdevices + 2;
-				     s < dev->subdevices + dev->n_subdevices;
-				     ++s) {
+				for (i = 2; i < dev->n_subdevices; i++) {
+					s = &dev->subdevices[i];
 					/*
 					 * this is an interrupt subdev,
 					 * and it matches this asic!
@@ -1076,9 +1076,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	/* First, AI */
-	sdev_no = 0;
-	s = dev->subdevices + sdev_no;
-	s->private = devpriv->sprivs + sdev_no;
+	s = &dev->subdevices[0];
+	s->private = &devpriv->sprivs[0];
 	s->maxdata = (1 << board->ai_bits) - 1;
 	s->range_table = board->ai_range_table;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
@@ -1092,9 +1091,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outb(0, subpriv->iobase + 4 + 3);
 
 	/* Next, AO */
-	++sdev_no;
-	s = dev->subdevices + sdev_no;
-	s->private = devpriv->sprivs + sdev_no;
+	s = &dev->subdevices[1];
+	s->private = &devpriv->sprivs[1];
 	s->maxdata = (1 << board->ao_bits) - 1;
 	s->range_table = board->ao_range_table;
 	s->subdev_flags = SDF_READABLE;
@@ -1108,14 +1106,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outb(0, subpriv->iobase + 3);
 	outb(0, subpriv->iobase + 4 + 3);
 
-	++sdev_no;
 	port = 0;
 	asic = 0;
-	for (; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
+	for (sdev_no = 2; sdev_no < dev->n_subdevices; ++sdev_no) {
 		int byte_no;
 
-		s = dev->subdevices + sdev_no;
-		s->private = devpriv->sprivs + sdev_no;
+		s = &dev->subdevices[sdev_no];
+		s->private = &devpriv->sprivs[sdev_no];
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;

commit 76728a93a70f23c6376c728e337fb26473737e7f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 17:03:17 2012 -0700

    staging: comedi: pcmmio: quiet NULL pointer sparse noise
    
    The comedi_async 'inttrig' member is a pointer to a callback
    function. NULL should be used to clear it not 0.
    
    This quiets a number of sparse warnings about:
    
    Warning: Using plain integer as NULL pointer
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 82a60d681eb4..3d2e6f01c4b7 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -512,7 +512,7 @@ static void pcmmio_stop_intr(struct comedi_device *dev,
 
 	subpriv->dio.intr.enabled_mask = 0;
 	subpriv->dio.intr.active = 0;
-	s->async->inttrig = 0;
+	s->async->inttrig = NULL;
 	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
 	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
 	switch_page(dev, asic, PAGE_ENAB);
@@ -778,7 +778,7 @@ pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 		return -EINVAL;
 
 	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
-	s->async->inttrig = 0;
+	s->async->inttrig = NULL;
 	if (subpriv->dio.intr.active)
 		event = pcmmio_start_intr(dev, s);
 	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a918cc087708..82a60d681eb4 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -344,7 +344,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 	printk(KERN_DEBUG "s->state %08x data_out %08x\n", s->state, data[1]);
 #endif
 
-	return 2;
+	return insn->n;
 }
 
 /* The input or output configuration of each digital line is

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 0e64d848a2a8..a918cc087708 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -275,8 +275,6 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
-	if (insn->n != 2)
-		return -EINVAL;
 
 	/* NOTE:
 	   reading a 0 means this channel was high

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 31053034b073..0e64d848a2a8 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1020,6 +1020,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    thisasic_chanct = 0;
 	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
+	int ret;
 
 	iobase = it->options[0];
 	irq[0] = it->options[1];
@@ -1072,8 +1073,9 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	}
 
-	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	if (ret)
+		return ret;
 
 	/* First, AI */
 	sdev_no = 0;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index abaf6c758baf..31053034b073 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1071,12 +1071,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				dev->minor);
 		return -ENOMEM;
 	}
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 *
-	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
-	 */
+
 	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
 		return -ENOMEM;
 

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 67fdac5b81d6..abaf6c758baf 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1077,11 +1077,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 *
 	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
 	 */
-	if (comedi_alloc_subdevices(dev, n_subdevs) < 0) {
-		printk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",
-				dev->minor);
+	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
 		return -ENOMEM;
-	}
 
 	/* First, AI */
 	sdev_no = 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index c4482ae9d08b..67fdac5b81d6 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1077,7 +1077,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 *
 	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
 	 */
-	if (alloc_subdevices(dev, n_subdevs) < 0) {
+	if (comedi_alloc_subdevices(dev, n_subdevs) < 0) {
 		printk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",
 				dev->minor);
 		return -ENOMEM;

commit 57bbeb3b9bc32f1ee4b14439e11ed475deab1263
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 17:46:56 2012 -0700

    staging: comedi: remove this_board macro in the pcmmio driver
    
    The 'thisboard' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index efed168d2bac..c4482ae9d08b 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -183,11 +183,6 @@ static const struct comedi_lrange ranges_ao = {
 	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct pcmmio_board *)dev->board_ptr)
-
 /* this structure is for data unique to this subdevice.  */
 struct pcmmio_subdev_private {
 
@@ -423,7 +418,9 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
-	if (asic < 0 || asic >= thisboard->dio_num_asics)
+	const struct pcmmio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->dio_num_asics)
 		return;		/* paranoia */
 	if (page < 0 || page >= NUM_PAGES)
 		return;		/* more paranoia */
@@ -439,9 +436,10 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
+	const struct pcmmio_board *board = comedi_board(dev);
 	int asic;
 
-	for (asic = 0; asic < thisboard->dio_num_asics; ++asic) {
+	for (asic = 0; asic < board->dio_num_asics; ++asic) {
 		int port, page;
 		unsigned long baseaddr = devpriv->asics[asic].iobase;
 
@@ -476,7 +474,9 @@ static void init_asics(struct comedi_device *dev)
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
-	if (asic < 0 || asic >= thisboard->dio_num_asics)
+	const struct pcmmio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->dio_num_asics)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -490,7 +490,9 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
-	if (asic < 0 || asic >= thisboard->dio_num_asics)
+	const struct pcmmio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->dio_num_asics)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -1012,6 +1014,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct pcmmio_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 	    thisasic_chanct = 0;
@@ -1027,17 +1030,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-				       thisboard->total_iosize,
+				       board->total_iosize,
 				       dev->driver->driver_name)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
 		return -EIO;
 	}
 
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 /*
  * Allocate the private structure area.  alloc_private() is a
@@ -1061,7 +1060,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
-	chans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;
+	chans_left = CHANS_PER_ASIC * board->dio_num_asics;
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
 	n_subdevs = n_dio_subdevs + 2;
 	devpriv->sprivs =
@@ -1088,13 +1087,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	sdev_no = 0;
 	s = dev->subdevices + sdev_no;
 	s->private = devpriv->sprivs + sdev_no;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ai_range_table;
+	s->maxdata = (1 << board->ai_bits) - 1;
+	s->range_table = board->ai_range_table;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
 	s->type = COMEDI_SUBD_AI;
-	s->n_chan = thisboard->n_ai_chans;
+	s->n_chan = board->n_ai_chans;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = thisboard->ai_rinsn;
+	s->insn_read = board->ai_rinsn;
 	subpriv->iobase = dev->iobase + 0;
 	/* initialize the resource enable register by clearing it */
 	outb(0, subpriv->iobase + 3);
@@ -1104,14 +1103,14 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	++sdev_no;
 	s = dev->subdevices + sdev_no;
 	s->private = devpriv->sprivs + sdev_no;
-	s->maxdata = (1 << thisboard->ao_bits) - 1;
-	s->range_table = thisboard->ao_range_table;
+	s->maxdata = (1 << board->ao_bits) - 1;
+	s->range_table = board->ao_range_table;
 	s->subdev_flags = SDF_READABLE;
 	s->type = COMEDI_SUBD_AO;
-	s->n_chan = thisboard->n_ao_chans;
+	s->n_chan = board->n_ao_chans;
 	s->len_chanlist = s->n_chan;
-	s->insn_read = thisboard->ao_rinsn;
-	s->insn_write = thisboard->ao_winsn;
+	s->insn_read = board->ao_rinsn;
+	s->insn_write = board->ao_winsn;
 	subpriv->iobase = dev->iobase + 8;
 	/* initialize the resource enable register by clearing it */
 	outb(0, subpriv->iobase + 3);
@@ -1192,7 +1191,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
 		    && request_irq(irq[asic], interrupt_pcmmio,
-				   IRQF_SHARED, thisboard->name, dev)) {
+				   IRQF_SHARED, board->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -1211,7 +1210,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (irq[0]) {
 		printk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);
-		if (thisboard->dio_num_asics == 2 && irq[1])
+		if (board->dio_num_asics == 2 && irq[1])
 			printk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",
 					dev->minor, irq[1]);
 	} else {
@@ -1225,10 +1224,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmmio_detach(struct comedi_device *dev)
 {
+	const struct pcmmio_board *board = comedi_board(dev);
 	int i;
 
 	if (dev->iobase)
-		release_region(dev->iobase, thisboard->total_iosize);
+		release_region(dev->iobase, board->total_iosize);
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index a977acbf9416..efed168d2bac 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1223,24 +1223,18 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-static int pcmmio_detach(struct comedi_device *dev)
+static void pcmmio_detach(struct comedi_device *dev)
 {
 	int i;
 
-	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor,
-		dev->driver->driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, thisboard->total_iosize);
-
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
 	}
-
 	if (devpriv && devpriv->sprivs)
 		kfree(devpriv->sprivs);
-
-	return 0;
 }
 
 static const struct pcmmio_board pcmmio_boards[] = {

commit 294f930d98be86fb4f34302c718a49719650857f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 3 15:09:40 2012 -0700

    staging: comedi: use module_comedi_driver
    
    Convert the refactored comedi drivers to use the module_comedi_driver()
    macro which makes the code smaller and a bit simpler.
    
    In the process, rename the driver variables from driver_* to *_driver,
    as is more typical with other subsystems, and make sure they are all
    static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9ee1da531b61..a977acbf9416 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1261,7 +1261,7 @@ static const struct pcmmio_board pcmmio_boards[] = {
 	},
 };
 
-static struct comedi_driver driver = {
+static struct comedi_driver pcmmio_driver = {
 	.driver_name	= "pcmmio",
 	.module		= THIS_MODULE,
 	.attach		= pcmmio_attach,
@@ -1270,18 +1270,7 @@ static struct comedi_driver driver = {
 	.offset		= sizeof(struct pcmmio_board),
 	.num_names	= ARRAY_SIZE(pcmmio_boards),
 };
-
-static int __init driver_init_module(void)
-{
-	return comedi_driver_register(&driver);
-}
-module_init(driver_init_module);
-
-static void __exit driver_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver);
-}
-module_exit(driver_cleanup_module);
+module_comedi_driver(pcmmio_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 2d2111ea2cf25cc60f7027130ceb34af2d03745d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 1 17:03:48 2012 -0700

    staging: comedi: fix build errors caused by module_init/module_exit refactor
    
    A couple build errors were introduced with the module_init/module_exit
    refactor.
    
    The struct comedi_driver variable was being accessed directly in the
    attach and detach routines. Instead of doing this, access the variable
    indirectly using the driver pointer in struct comedi_device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index d7f98d575f45..9ee1da531b61 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1022,13 +1022,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[0] = it->options[1];
 
 	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
-			driver.driver_name, iobase);
+			dev->driver->driver_name, iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
 				       thisboard->total_iosize,
-				       driver.driver_name)) {
+				       dev->driver->driver_name)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
 		return -EIO;
 	}
@@ -1227,7 +1227,8 @@ static int pcmmio_detach(struct comedi_device *dev)
 {
 	int i;
 
-	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor,
+		dev->driver->driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, thisboard->total_iosize);
 

commit 6a8576360a77be2c39ef2e151b5a60b214f67fd6
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue May 1 11:55:07 2012 +0530

    Staging: comedi: fix printk issue in pcmmio.c
    
    This is a patch to the pcmmio.c file that fixes up a printk warning
    found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index e05d1572e27c..d7f98d575f45 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -337,7 +337,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 		}
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("data_out_byte %02x\n", (unsigned)byte);
+		printk(KERN_DEBUG "data_out_byte %02x\n", (unsigned)byte);
 #endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;

commit b2bb98e179cb06590aa86be5ff12e53ab382c926
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 27 15:39:37 2012 -0700

    staging: comedi: refactor pcmmio driver to remove forward declarations
    
    Refactor the switch_page and pcmmio_stop_intr functions to avoid
    needing the forward declarations.
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index eddac00e4e29..e05d1572e27c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -145,13 +145,6 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *,
-		    struct comedi_insn *, unsigned int *);
-static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *,
-		    struct comedi_insn *, unsigned int *);
-static int ao_winsn(struct comedi_device *, struct comedi_subdevice *,
-		    struct comedi_insn *, unsigned int *);
-
 /*
  * Board descriptions for two imaginary boards.  Describing the
  * boards in this way is optional, and completely driver-dependent.
@@ -190,23 +183,6 @@ static const struct comedi_lrange ranges_ao = {
 	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
-static const struct pcmmio_board pcmmio_boards[] = {
-	{
-	 .name = "pcmmio",
-	 .dio_num_asics = 1,
-	 .dio_num_ports = 6,
-	 .total_iosize = 32,
-	 .ai_bits = 16,
-	 .ao_bits = 16,
-	 .n_ai_chans = 16,
-	 .n_ao_chans = 8,
-	 .ai_range_table = &ranges_ai,
-	 .ao_range_table = &ranges_ao,
-	 .ai_rinsn = ai_rinsn,
-	 .ao_rinsn = ao_rinsn,
-	 .ao_winsn = ao_winsn},
-};
-
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -293,312 +269,6 @@ struct pcmmio_private {
  */
 #define devpriv ((struct pcmmio_private *)dev->private)
 #define subpriv ((struct pcmmio_subdev_private *)s->private)
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int pcmmio_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pcmmio_detach(struct comedi_device *dev);
-
-static struct comedi_driver driver = {
-	.driver_name = "pcmmio",
-	.module = THIS_MODULE,
-	.attach = pcmmio_attach,
-	.detach = pcmmio_detach,
-/* It is not necessary to implement the following members if you are
- * writing a driver for a ISA PnP or PCI card */
-	/* Most drivers will support multiple types of boards by
-	 * having an array of board structures.  These were defined
-	 * in pcmmio_boards[] above.  Note that the element 'name'
-	 * was first in the structure -- Comedi uses this fact to
-	 * extract the name of the board without knowing any details
-	 * about the structure except for its length.
-	 * When a device is attached (by comedi_config), the name
-	 * of the device is given to Comedi, and Comedi tries to
-	 * match it by going through the list of board names.  If
-	 * there is a match, the address of the pointer is put
-	 * into dev->board_ptr and driver->attach() is called.
-	 *
-	 * Note that these are not necessary if you can determine
-	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
-	 * devices are such boards.
-	 */
-	.board_name = &pcmmio_boards[0].name,
-	.offset = sizeof(struct pcmmio_board),
-	.num_names = ARRAY_SIZE(pcmmio_boards),
-};
-
-static int pcmmio_dio_insn_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-static int pcmmio_dio_insn_config(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data);
-
-static irqreturn_t interrupt_pcmmio(int irq, void *d);
-static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
-static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_cmd *cmd);
-
-/* some helper functions to deal with specifics of this device's registers */
-/* sets up/clears ASIC chips to defaults */
-static void init_asics(struct comedi_device *dev);
-static void switch_page(struct comedi_device *dev, int asic, int page);
-#ifdef notused
-static void lock_port(struct comedi_device *dev, int asic, int port);
-static void unlock_port(struct comedi_device *dev, int asic, int port);
-#endif
-
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	struct comedi_subdevice *s;
-	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
-	    thisasic_chanct = 0;
-	unsigned long iobase;
-	unsigned int irq[MAX_ASICS];
-
-	iobase = it->options[0];
-	irq[0] = it->options[1];
-
-	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
-			driver.driver_name, iobase);
-
-	dev->iobase = iobase;
-
-	if (!iobase || !request_region(iobase,
-				       thisboard->total_iosize,
-				       driver.driver_name)) {
-		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
-		return -EIO;
-	}
-
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_name = thisboard->name;
-
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
-		printk(KERN_ERR "comedi%d: cannot allocate private data structure\n",
-				dev->minor);
-		return -ENOMEM;
-	}
-
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].num = asic;
-		devpriv->asics[asic].iobase =
-		    dev->iobase + 16 + asic * ASIC_IOSIZE;
-		/*
-		 * this gets actually set at the end of this function when we
-		 * request_irqs
-		 */
-		devpriv->asics[asic].irq = 0;
-		spin_lock_init(&devpriv->asics[asic].spinlock);
-	}
-
-	chans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;
-	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
-	n_subdevs = n_dio_subdevs + 2;
-	devpriv->sprivs =
-	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
-		    GFP_KERNEL);
-	if (!devpriv->sprivs) {
-		printk(KERN_ERR "comedi%d: cannot allocate subdevice private data structures\n",
-				dev->minor);
-		return -ENOMEM;
-	}
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 *
-	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
-	 */
-	if (alloc_subdevices(dev, n_subdevs) < 0) {
-		printk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",
-				dev->minor);
-		return -ENOMEM;
-	}
-
-	/* First, AI */
-	sdev_no = 0;
-	s = dev->subdevices + sdev_no;
-	s->private = devpriv->sprivs + sdev_no;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ai_range_table;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
-	s->type = COMEDI_SUBD_AI;
-	s->n_chan = thisboard->n_ai_chans;
-	s->len_chanlist = s->n_chan;
-	s->insn_read = thisboard->ai_rinsn;
-	subpriv->iobase = dev->iobase + 0;
-	/* initialize the resource enable register by clearing it */
-	outb(0, subpriv->iobase + 3);
-	outb(0, subpriv->iobase + 4 + 3);
-
-	/* Next, AO */
-	++sdev_no;
-	s = dev->subdevices + sdev_no;
-	s->private = devpriv->sprivs + sdev_no;
-	s->maxdata = (1 << thisboard->ao_bits) - 1;
-	s->range_table = thisboard->ao_range_table;
-	s->subdev_flags = SDF_READABLE;
-	s->type = COMEDI_SUBD_AO;
-	s->n_chan = thisboard->n_ao_chans;
-	s->len_chanlist = s->n_chan;
-	s->insn_read = thisboard->ao_rinsn;
-	s->insn_write = thisboard->ao_winsn;
-	subpriv->iobase = dev->iobase + 8;
-	/* initialize the resource enable register by clearing it */
-	outb(0, subpriv->iobase + 3);
-	outb(0, subpriv->iobase + 4 + 3);
-
-	++sdev_no;
-	port = 0;
-	asic = 0;
-	for (; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
-		int byte_no;
-
-		s = dev->subdevices + sdev_no;
-		s->private = devpriv->sprivs + sdev_no;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->type = COMEDI_SUBD_DIO;
-		s->insn_bits = pcmmio_dio_insn_bits;
-		s->insn_config = pcmmio_dio_insn_config;
-		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
-		subpriv->dio.intr.asic = -1;
-		subpriv->dio.intr.first_chan = -1;
-		subpriv->dio.intr.asic_chan = -1;
-		subpriv->dio.intr.num_asic_chans = -1;
-		subpriv->dio.intr.active = 0;
-		s->len_chanlist = 1;
-
-		/* save the ioport address for each 'port' of 8 channels in the
-		   subdevice */
-		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
-			if (port >= PORTS_PER_ASIC) {
-				port = 0;
-				++asic;
-				thisasic_chanct = 0;
-			}
-			subpriv->iobases[byte_no] =
-			    devpriv->asics[asic].iobase + port;
-
-			if (thisasic_chanct <
-			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-			    && subpriv->dio.intr.asic < 0) {
-				/*
-				 * this is an interrupt subdevice,
-				 * so setup the struct
-				 */
-				subpriv->dio.intr.asic = asic;
-				subpriv->dio.intr.active = 0;
-				subpriv->dio.intr.stop_count = 0;
-				subpriv->dio.intr.first_chan = byte_no * 8;
-				subpriv->dio.intr.asic_chan = thisasic_chanct;
-				subpriv->dio.intr.num_asic_chans =
-				    s->n_chan - subpriv->dio.intr.first_chan;
-				s->cancel = pcmmio_cancel;
-				s->do_cmd = pcmmio_cmd;
-				s->do_cmdtest = pcmmio_cmdtest;
-				s->len_chanlist =
-				    subpriv->dio.intr.num_asic_chans;
-			}
-			thisasic_chanct += CHANS_PER_PORT;
-		}
-		spin_lock_init(&subpriv->dio.intr.spinlock);
-
-		chans_left -= s->n_chan;
-
-		if (!chans_left) {
-			/*
-			 * reset the asic to our first asic,
-			 * to do intr subdevs
-			 */
-			asic = 0;
-			port = 0;
-		}
-
-	}
-
-	init_asics(dev);	/* clear out all the registers, basically */
-
-	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
-		if (irq[asic]
-		    && request_irq(irq[asic], interrupt_pcmmio,
-				   IRQF_SHARED, thisboard->name, dev)) {
-			int i;
-			/* unroll the allocated irqs.. */
-			for (i = asic - 1; i >= 0; --i) {
-				free_irq(irq[i], dev);
-				devpriv->asics[i].irq = irq[i] = 0;
-			}
-			irq[asic] = 0;
-		}
-		devpriv->asics[asic].irq = irq[asic];
-	}
-
-	dev->irq = irq[0];	/*
-				 * grr.. wish comedi dev struct supported
-				 * multiple irqs..
-				 */
-
-	if (irq[0]) {
-		printk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);
-		if (thisboard->dio_num_asics == 2 && irq[1])
-			printk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",
-					dev->minor, irq[1]);
-	} else {
-		printk(KERN_INFO "comedi%d: (IRQ mode disabled)\n", dev->minor);
-	}
-
-	printk(KERN_INFO "comedi%d: attached\n", dev->minor);
-
-	return 1;
-}
-
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int pcmmio_detach(struct comedi_device *dev)
-{
-	int i;
-
-	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor, driver.driver_name);
-	if (dev->iobase)
-		release_region(dev->iobase, thisboard->total_iosize);
-
-	for (i = 0; i < MAX_ASICS; ++i) {
-		if (devpriv && devpriv->asics[i].irq)
-			free_irq(devpriv->asics[i].irq, dev);
-	}
-
-	if (devpriv && devpriv->sprivs)
-		kfree(devpriv->sprivs);
-
-	return 0;
-}
 
 /* DIO devices are slightly special.  Although it is possible to
  * implement the insn_read/insn_write interface, it is much more
@@ -751,6 +421,21 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void switch_page(struct comedi_device *dev, int asic, int page)
+{
+	if (asic < 0 || asic >= thisboard->dio_num_asics)
+		return;		/* paranoia */
+	if (page < 0 || page >= NUM_PAGES)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
+	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
+
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
+}
+
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
@@ -788,21 +473,6 @@ static void init_asics(struct comedi_device *dev)
 	}
 }
 
-static void switch_page(struct comedi_device *dev, int asic, int page)
-{
-	if (asic < 0 || asic >= thisboard->dio_num_asics)
-		return;		/* paranoia */
-	if (page < 0 || page >= NUM_PAGES)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
-	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
-
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     devpriv->asics[asic].iobase + REG_PAGELOCK);
-}
-
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
@@ -831,6 +501,27 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 }
 #endif /* notused */
 
+static void pcmmio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
+{
+	int nports, firstport, asic, port;
+
+	asic = subpriv->dio.intr.asic;
+	if (asic < 0)
+		return;		/* not an interrupt subdev */
+
+	subpriv->dio.intr.enabled_mask = 0;
+	subpriv->dio.intr.active = 0;
+	s->async->inttrig = 0;
+	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
+	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
+	switch_page(dev, asic, PAGE_ENAB);
+	for (port = firstport; port < firstport + nports; ++port) {
+		/* disable all intrs for this subdev.. */
+		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+	}
+}
+
 static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
@@ -981,35 +672,14 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 
 					}
 
-				}
-			}
-
-		}
-	}
-	if (!got1)
-		return IRQ_NONE;	/* interrupt from other source */
-	return IRQ_HANDLED;
-}
-
-static void pcmmio_stop_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	int nports, firstport, asic, port;
-
-	asic = subpriv->dio.intr.asic;
-	if (asic < 0)
-		return;		/* not an interrupt subdev */
-
-	subpriv->dio.intr.enabled_mask = 0;
-	subpriv->dio.intr.active = 0;
-	s->async->inttrig = 0;
-	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
-	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, asic, PAGE_ENAB);
-	for (port = firstport; port < firstport + nports; ++port) {
-		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+				}
+			}
+
+		}
 	}
+	if (!got1)
+		return IRQ_NONE;	/* interrupt from other source */
+	return IRQ_HANDLED;
 }
 
 static int pcmmio_start_intr(struct comedi_device *dev,
@@ -1340,21 +1010,276 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
+static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct comedi_subdevice *s;
+	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
+	    thisasic_chanct = 0;
+	unsigned long iobase;
+	unsigned int irq[MAX_ASICS];
+
+	iobase = it->options[0];
+	irq[0] = it->options[1];
+
+	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
+			driver.driver_name, iobase);
+
+	dev->iobase = iobase;
+
+	if (!iobase || !request_region(iobase,
+				       thisboard->total_iosize,
+				       driver.driver_name)) {
+		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
+		return -EIO;
+	}
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_name = thisboard->name;
+
 /*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
  */
+	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
+		printk(KERN_ERR "comedi%d: cannot allocate private data structure\n",
+				dev->minor);
+		return -ENOMEM;
+	}
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		devpriv->asics[asic].num = asic;
+		devpriv->asics[asic].iobase =
+		    dev->iobase + 16 + asic * ASIC_IOSIZE;
+		/*
+		 * this gets actually set at the end of this function when we
+		 * request_irqs
+		 */
+		devpriv->asics[asic].irq = 0;
+		spin_lock_init(&devpriv->asics[asic].spinlock);
+	}
+
+	chans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;
+	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
+	n_subdevs = n_dio_subdevs + 2;
+	devpriv->sprivs =
+	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
+		    GFP_KERNEL);
+	if (!devpriv->sprivs) {
+		printk(KERN_ERR "comedi%d: cannot allocate subdevice private data structures\n",
+				dev->minor);
+		return -ENOMEM;
+	}
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 *
+	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
+	 */
+	if (alloc_subdevices(dev, n_subdevs) < 0) {
+		printk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",
+				dev->minor);
+		return -ENOMEM;
+	}
+
+	/* First, AI */
+	sdev_no = 0;
+	s = dev->subdevices + sdev_no;
+	s->private = devpriv->sprivs + sdev_no;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ai_range_table;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
+	s->type = COMEDI_SUBD_AI;
+	s->n_chan = thisboard->n_ai_chans;
+	s->len_chanlist = s->n_chan;
+	s->insn_read = thisboard->ai_rinsn;
+	subpriv->iobase = dev->iobase + 0;
+	/* initialize the resource enable register by clearing it */
+	outb(0, subpriv->iobase + 3);
+	outb(0, subpriv->iobase + 4 + 3);
+
+	/* Next, AO */
+	++sdev_no;
+	s = dev->subdevices + sdev_no;
+	s->private = devpriv->sprivs + sdev_no;
+	s->maxdata = (1 << thisboard->ao_bits) - 1;
+	s->range_table = thisboard->ao_range_table;
+	s->subdev_flags = SDF_READABLE;
+	s->type = COMEDI_SUBD_AO;
+	s->n_chan = thisboard->n_ao_chans;
+	s->len_chanlist = s->n_chan;
+	s->insn_read = thisboard->ao_rinsn;
+	s->insn_write = thisboard->ao_winsn;
+	subpriv->iobase = dev->iobase + 8;
+	/* initialize the resource enable register by clearing it */
+	outb(0, subpriv->iobase + 3);
+	outb(0, subpriv->iobase + 4 + 3);
+
+	++sdev_no;
+	port = 0;
+	asic = 0;
+	for (; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
+		int byte_no;
+
+		s = dev->subdevices + sdev_no;
+		s->private = devpriv->sprivs + sdev_no;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->type = COMEDI_SUBD_DIO;
+		s->insn_bits = pcmmio_dio_insn_bits;
+		s->insn_config = pcmmio_dio_insn_config;
+		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
+		subpriv->dio.intr.asic = -1;
+		subpriv->dio.intr.first_chan = -1;
+		subpriv->dio.intr.asic_chan = -1;
+		subpriv->dio.intr.num_asic_chans = -1;
+		subpriv->dio.intr.active = 0;
+		s->len_chanlist = 1;
+
+		/* save the ioport address for each 'port' of 8 channels in the
+		   subdevice */
+		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
+			if (port >= PORTS_PER_ASIC) {
+				port = 0;
+				++asic;
+				thisasic_chanct = 0;
+			}
+			subpriv->iobases[byte_no] =
+			    devpriv->asics[asic].iobase + port;
+
+			if (thisasic_chanct <
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->dio.intr.asic < 0) {
+				/*
+				 * this is an interrupt subdevice,
+				 * so setup the struct
+				 */
+				subpriv->dio.intr.asic = asic;
+				subpriv->dio.intr.active = 0;
+				subpriv->dio.intr.stop_count = 0;
+				subpriv->dio.intr.first_chan = byte_no * 8;
+				subpriv->dio.intr.asic_chan = thisasic_chanct;
+				subpriv->dio.intr.num_asic_chans =
+				    s->n_chan - subpriv->dio.intr.first_chan;
+				s->cancel = pcmmio_cancel;
+				s->do_cmd = pcmmio_cmd;
+				s->do_cmdtest = pcmmio_cmdtest;
+				s->len_chanlist =
+				    subpriv->dio.intr.num_asic_chans;
+			}
+			thisasic_chanct += CHANS_PER_PORT;
+		}
+		spin_lock_init(&subpriv->dio.intr.spinlock);
+
+		chans_left -= s->n_chan;
+
+		if (!chans_left) {
+			/*
+			 * reset the asic to our first asic,
+			 * to do intr subdevs
+			 */
+			asic = 0;
+			port = 0;
+		}
+
+	}
+
+	init_asics(dev);	/* clear out all the registers, basically */
+
+	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
+		if (irq[asic]
+		    && request_irq(irq[asic], interrupt_pcmmio,
+				   IRQF_SHARED, thisboard->name, dev)) {
+			int i;
+			/* unroll the allocated irqs.. */
+			for (i = asic - 1; i >= 0; --i) {
+				free_irq(irq[i], dev);
+				devpriv->asics[i].irq = irq[i] = 0;
+			}
+			irq[asic] = 0;
+		}
+		devpriv->asics[asic].irq = irq[asic];
+	}
+
+	dev->irq = irq[0];	/*
+				 * grr.. wish comedi dev struct supported
+				 * multiple irqs..
+				 */
+
+	if (irq[0]) {
+		printk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);
+		if (thisboard->dio_num_asics == 2 && irq[1])
+			printk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",
+					dev->minor, irq[1]);
+	} else {
+		printk(KERN_INFO "comedi%d: (IRQ mode disabled)\n", dev->minor);
+	}
+
+	printk(KERN_INFO "comedi%d: attached\n", dev->minor);
+
+	return 1;
+}
+
+static int pcmmio_detach(struct comedi_device *dev)
+{
+	int i;
+
+	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	if (dev->iobase)
+		release_region(dev->iobase, thisboard->total_iosize);
+
+	for (i = 0; i < MAX_ASICS; ++i) {
+		if (devpriv && devpriv->asics[i].irq)
+			free_irq(devpriv->asics[i].irq, dev);
+	}
+
+	if (devpriv && devpriv->sprivs)
+		kfree(devpriv->sprivs);
+
+	return 0;
+}
+
+static const struct pcmmio_board pcmmio_boards[] = {
+	{
+		.name		= "pcmmio",
+		.dio_num_asics	= 1,
+		.dio_num_ports	= 6,
+		.total_iosize	= 32,
+		.ai_bits	= 16,
+		.ao_bits	= 16,
+		.n_ai_chans	= 16,
+		.n_ao_chans	= 8,
+		.ai_range_table	= &ranges_ai,
+		.ao_range_table	= &ranges_ao,
+		.ai_rinsn	= ai_rinsn,
+		.ao_rinsn	= ao_rinsn,
+		.ao_winsn	= ao_winsn
+	},
+};
+
+static struct comedi_driver driver = {
+	.driver_name	= "pcmmio",
+	.module		= THIS_MODULE,
+	.attach		= pcmmio_attach,
+	.detach		= pcmmio_detach,
+	.board_name	= &pcmmio_boards[0].name,
+	.offset		= sizeof(struct pcmmio_board),
+	.num_names	= ARRAY_SIZE(pcmmio_boards),
+};
+
 static int __init driver_init_module(void)
 {
 	return comedi_driver_register(&driver);
 }
+module_init(driver_init_module);
 
 static void __exit driver_cleanup_module(void)
 {
 	comedi_driver_unregister(&driver);
 }
-
-module_init(driver_init_module);
 module_exit(driver_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit cf5682788f2cc35643f0bc1898646e2cff4af7f3
Author: Johannes Thumshirn <morbidrsa@googlemail.com>
Date:   Mon Oct 24 19:52:31 2011 +0200

    staging: comedi: Unbreak output of printk()s in pcmmio
    
    Unbreak the output of some printk()s I broke.
    
    Signed-off-by: Johannes Thumshirn <morbidrsa@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3ad04aaa1e3c..eddac00e4e29 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -371,15 +371,15 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	iobase = it->options[0];
 	irq[0] = it->options[1];
 
-	printk(KERN_INFO "comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-	       iobase);
+	printk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,
+			driver.driver_name, iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
 				       thisboard->total_iosize,
 				       driver.driver_name)) {
-		printk(KERN_ERR "I/O port conflict\n");
+		printk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);
 		return -EIO;
 	}
 
@@ -394,7 +394,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * convenient macro defined in comedidev.h.
  */
 	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
-		printk(KERN_ERR "cannot allocate private data structure\n");
+		printk(KERN_ERR "comedi%d: cannot allocate private data structure\n",
+				dev->minor);
 		return -ENOMEM;
 	}
 
@@ -417,7 +418,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
 		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
-		printk(KERN_ERR "cannot allocate subdevice private data structures\n");
+		printk(KERN_ERR "comedi%d: cannot allocate subdevice private data structures\n",
+				dev->minor);
 		return -ENOMEM;
 	}
 	/*
@@ -427,7 +429,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
 	 */
 	if (alloc_subdevices(dev, n_subdevs) < 0) {
-		printk(KERN_ERR "cannot allocate subdevice data structures\n");
+		printk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",
+				dev->minor);
 		return -ENOMEM;
 	}
 
@@ -557,14 +560,15 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 */
 
 	if (irq[0]) {
-		printk(KERN_DEBUG "irq: %u ", irq[0]);
+		printk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);
 		if (thisboard->dio_num_asics == 2 && irq[1])
-			printk(KERN_DEBUG "second ASIC irq: %u ", irq[1]);
+			printk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",
+					dev->minor, irq[1]);
 	} else {
-		printk(KERN_INFO "(IRQ mode disabled) ");
+		printk(KERN_INFO "comedi%d: (IRQ mode disabled)\n", dev->minor);
 	}
 
-	printk(KERN_INFO "attached\n");
+	printk(KERN_INFO "comedi%d: attached\n", dev->minor);
 
 	return 1;
 }
@@ -663,7 +667,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 		}
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk(KERN_DEBUG "data_out_byte %02x\n", (unsigned)byte);
+		printk("data_out_byte %02x\n", (unsigned)byte);
 #endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;

commit bcd9a1e91fbc293bbbbddd98df687ad2e8027c89
Author: Johannes Thumshirn <morbidrsa@googlemail.com>
Date:   Sun Sep 25 06:49:12 2011 +0200

    staging: comedi: Added log subjects to printk()s in pcmmio
    
    Added log subject to printk()s in drivers/staging/comedi/drivers/pcmmio.c.
    
    Signed-off-by: Johannes Thumshirn <morbidrsa@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f2e88e57d558..3ad04aaa1e3c 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -371,7 +371,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	iobase = it->options[0];
 	irq[0] = it->options[1];
 
-	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
+	printk(KERN_INFO "comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
 	       iobase);
 
 	dev->iobase = iobase;
@@ -379,7 +379,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!iobase || !request_region(iobase,
 				       thisboard->total_iosize,
 				       driver.driver_name)) {
-		printk("I/O port conflict\n");
+		printk(KERN_ERR "I/O port conflict\n");
 		return -EIO;
 	}
 
@@ -394,7 +394,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * convenient macro defined in comedidev.h.
  */
 	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
-		printk("cannot allocate private data structure\n");
+		printk(KERN_ERR "cannot allocate private data structure\n");
 		return -ENOMEM;
 	}
 
@@ -417,7 +417,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
 		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
-		printk("cannot allocate subdevice private data structures\n");
+		printk(KERN_ERR "cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
 	}
 	/*
@@ -427,7 +427,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
 	 */
 	if (alloc_subdevices(dev, n_subdevs) < 0) {
-		printk("cannot allocate subdevice data structures\n");
+		printk(KERN_ERR "cannot allocate subdevice data structures\n");
 		return -ENOMEM;
 	}
 
@@ -557,14 +557,14 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 */
 
 	if (irq[0]) {
-		printk("irq: %u ", irq[0]);
+		printk(KERN_DEBUG "irq: %u ", irq[0]);
 		if (thisboard->dio_num_asics == 2 && irq[1])
-			printk("second ASIC irq: %u ", irq[1]);
+			printk(KERN_DEBUG "second ASIC irq: %u ", irq[1]);
 	} else {
-		printk("(IRQ mode disabled) ");
+		printk(KERN_INFO "(IRQ mode disabled) ");
 	}
 
-	printk("attached\n");
+	printk(KERN_INFO "attached\n");
 
 	return 1;
 }
@@ -581,7 +581,7 @@ static int pcmmio_detach(struct comedi_device *dev)
 {
 	int i;
 
-	printk("comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	printk(KERN_INFO "comedi%d: %s: remove\n", dev->minor, driver.driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, thisboard->total_iosize);
 
@@ -622,7 +622,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	printk("write mask: %08x  data: %08x\n", data[0], data[1]);
+	printk(KERN_DEBUG "write mask: %08x  data: %08x\n", data[0], data[1]);
 #endif
 
 	s->state = 0;
@@ -644,9 +644,9 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
 		printk
-		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
-		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
-		     offset, ioaddr, (unsigned)byte);
+		    (KERN_DEBUG "byte %d wmb %02x db %02x offset %02d io %04x,"
+		     " data_in %02x ", byte_no, (unsigned)write_mask_byte,
+		     (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
 #endif
 
 		if (write_mask_byte) {
@@ -663,7 +663,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 		}
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("data_out_byte %02x\n", (unsigned)byte);
+		printk(KERN_DEBUG "data_out_byte %02x\n", (unsigned)byte);
 #endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
@@ -674,7 +674,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	printk("s->state %08x data_out %08x\n", s->state, data[1]);
+	printk(KERN_DEBUG "s->state %08x data_out %08x\n", s->state, data[1]);
 #endif
 
 	return 2;
@@ -886,7 +886,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				 * with commands..
 				 */
 				printk
-				    ("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
+				    (KERN_DEBUG "got edge detect interrupt %d asic %d which_chans: %06x\n",
 				     irq, asic, triggered);
 				for (s = dev->subdevices + 2;
 				     s < dev->subdevices + dev->n_subdevices;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5c832d7ed45d..f2e88e57d558 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -733,7 +733,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 		break;
 
 	case INSN_CONFIG_DIO_QUERY:
-		/* retreive from shadow register */
+		/* retrieve from shadow register */
 		data[1] =
 		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
@@ -1279,7 +1279,7 @@ static int wait_dac_ready(unsigned long iobase)
 	   "no busy waiting" policy. The fact is that the hardware is
 	   normally so fast that we usually only need one time through the loop
 	   anyway. The longer timeout is for rare occasions and for detecting
-	   non-existant hardware.  */
+	   non-existent hardware.  */
 
 	while (retry--) {
 		if (inb(iobase + 3) & 0x80)

commit 56b8421ceef7f2dae95b882034ebf6958bad58f6
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Thu Jun 10 23:38:29 2010 +0200

    Staging: comedi: Remove typedefs
    
    Remove all remaining typedefs from comedi drivers
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f0df9d1e4fec..5c832d7ed45d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -145,10 +145,6 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-typedef int (*comedi_insn_fn_t) (struct comedi_device *,
-				 struct comedi_subdevice *,
-				 struct comedi_insn *, unsigned int *);
-
 static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *,
 		    struct comedi_insn *, unsigned int *);
 static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *,
@@ -171,7 +167,18 @@ struct pcmmio_board {
 	const int n_ai_chans;
 	const int n_ao_chans;
 	const struct comedi_lrange *ai_range_table, *ao_range_table;
-	comedi_insn_fn_t ai_rinsn, ao_rinsn, ao_winsn;
+	int (*ai_rinsn) (struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned int *data);
+	int (*ao_rinsn) (struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned int *data);
+	int (*ao_winsn) (struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned int *data);
 };
 
 static const struct comedi_lrange ranges_ai = {

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 3e80da04277f..f0df9d1e4fec 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1333,7 +1333,18 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver);
+static int __init driver_init_module(void)
+{
+	return comedi_driver_register(&driver);
+}
+
+static void __exit driver_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver);
+}
+
+module_init(driver_init_module);
+module_exit(driver_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 025a52e8981d..3e80da04277f 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -1334,3 +1334,7 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
  * as necessary.
  */
 COMEDI_INITCLEANUP(driver);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6ca4105610c1..025a52e8981d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -77,6 +77,7 @@ Configuration Options:
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include "../comedidev.h"
 #include "pcm_common.h"
 #include <linux/pci.h>		/* for PCI devices */

commit 4b2ba24399cfcd7c80a20cd3bbedc5df0ebd4345
Author: Dan Carpenter <error27@gmail.com>
Date:   Mon Dec 28 18:59:01 2009 +0200

    Staging: comedi: reorder check in pcmmio_attach()
    
    The check for dio_num_asics is used to determine if there is more than 1 irq.
    If it is false then irq[1] is past the end of the array.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 35ba93989a36..6ca4105610c1 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -550,7 +550,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (irq[0]) {
 		printk("irq: %u ", irq[0]);
-		if (irq[1] && thisboard->dio_num_asics == 2)
+		if (thisboard->dio_num_asics == 2 && irq[1])
 			printk("second ASIC irq: %u ", irq[1]);
 	} else {
 		printk("(IRQ mode disabled) ");

commit 013f230c4f2622cbbc736c50223b49bced024655
Author: Daniel Patrick Johnson <teknotus@teknot.us>
Date:   Wed Oct 14 02:04:24 2009 +0000

    Staging: comedi: pcmmio: more coding style cleanup
    
    Signed-off-by: Daniel Patrick Johnson <teknotus@teknot.us>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index c764b28fb319..35ba93989a36 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -713,9 +713,11 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 		byte &= ~(1 << bit_no);
 				/**< set input channel to '0' */
 
-		/* write out byte -- this is the only time we actually affect the
-		   hardware as all channels are implicitly output -- but input
-		   channels are set to float-high */
+		/*
+		 * write out byte -- this is the only time we actually affect
+		 * the hardware as all channels are implicitly output
+		 * -- but input channels are set to float-high
+		 */
 		outb(byte, ioaddr);
 
 		/* save to io_bits */
@@ -769,8 +771,8 @@ static void init_asics(struct comedi_device *dev)
 		   outb(0xff, baseaddr + REG_ENAB0); */
 		/* END DEBUG */
 
-		switch_page(dev, asic, 0);	/* switch back to default page 0 */
-
+		/* switch back to default page 0 */
+		switch_page(dev, asic, 0);
 	}
 }
 
@@ -849,7 +851,10 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 							REG_INT_ID0 + port);
 
 						if (io_lines_with_edges)
-							/* clear pending interrupt */
+							/*
+							 * clear pending
+							 * interrupt
+							 */
 							outb(0, iobase +
 							     REG_INT_ID0 +
 							     port);
@@ -868,14 +873,21 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 
 			if (triggered) {
 				struct comedi_subdevice *s;
-				/* TODO here: dispatch io lines to subdevs with commands.. */
+				/*
+				 * TODO here: dispatch io lines to subdevs
+				 * with commands..
+				 */
 				printk
 				    ("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
 				     irq, asic, triggered);
 				for (s = dev->subdevices + 2;
 				     s < dev->subdevices + dev->n_subdevices;
 				     ++s) {
-					if (subpriv->dio.intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
+					/*
+					 * this is an interrupt subdev,
+					 * and it matches this asic!
+					 */
+					if (subpriv->dio.intr.asic == asic) {
 						unsigned long flags;
 						unsigned oldevents;
 
@@ -910,9 +922,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 								     n < len;
 								     n++) {
 									ch = CR_CHAN(s->async->cmd.chanlist[n]);
-									if (mytrig & (1U << ch)) {
+									if (mytrig & (1U << ch))
 										val |= (1U << n);
-									}
 								}
 								/* Write the scan to the buffer. */
 								if (comedi_buf_put(s->async, ((short *)&val)[0])
@@ -920,8 +931,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 								    comedi_buf_put
 								    (s->async,
 								     ((short *)
-								      &val)[1]))
-								{
+								      &val)[1])) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
@@ -1024,9 +1034,16 @@ static int pcmmio_start_intr(struct comedi_device *dev,
 			 1) << subpriv->dio.intr.first_chan;
 		subpriv->dio.intr.enabled_mask = bits;
 
-		{		/* the below code configures the board to use a specific IRQ from 0-15. */
+		{
+			/*
+			 * the below code configures the board
+			 * to use a specific IRQ from 0-15.
+			 */
 			unsigned char b;
-			/* set resource enable register to enable IRQ operation */
+			/*
+			 * set resource enable register
+			 * to enable IRQ operation
+			 */
 			outb(1 << 4, dev->iobase + 3);
 			/* set bits 0-3 of b to the irq number from 0-15 */
 			b = dev->irq & ((1 << 4) - 1);
@@ -1080,14 +1097,12 @@ pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	s->async->inttrig = 0;
-	if (subpriv->dio.intr.active) {
+	if (subpriv->dio.intr.active)
 		event = pcmmio_start_intr(dev, s);
-	}
 	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 1;
 }
@@ -1129,9 +1144,8 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 0;
 }
@@ -1179,17 +1193,32 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		short sample, adc_adjust = 0;
 
 		if (chan > 7)
-			chan -= 8, iooffset = 4;	/* use the second dword for channels > 7 */
+			chan -= 8, iooffset = 4;	/*
+							 * use the second dword
+							 * for channels > 7
+							 */
 
 		if (aref != AREF_DIFF) {
 			aref = AREF_GROUND;
-			command_byte |= 1 << 7;	/* set bit 7 to indicate single-ended */
+			command_byte |= 1 << 7;	/*
+						 * set bit 7 to indicate
+						 * single-ended
+						 */
 		}
 		if (range < 2)
-			adc_adjust = 0x8000;	/* bipolar ranges (-5,5 .. -10,10 need to be adjusted -- that is.. they need to wrap around by adding 0x8000 */
+			adc_adjust = 0x8000;	/*
+						 * bipolar ranges
+						 * (-5,5 .. -10,10 need to be
+						 * adjusted -- that is.. they
+						 * need to wrap around by
+						 * adding 0x8000
+						 */
 
 		if (chan % 2) {
-			command_byte |= 1 << 6;	/* odd-numbered channels have bit 6 set */
+			command_byte |= 1 << 6;	/*
+						 * odd-numbered channels
+						 * have bit 6 set
+						 */
 		}
 
 		/* select the channel, bits 4-5 == chan/2 */
@@ -1199,16 +1228,22 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		command_byte |= (range & 0x3) << 2;
 
 		/* need to do this twice to make sure mux settled */
-		outb(command_byte, iobase + iooffset + 2);	/* chan/range/aref select */
+		/* chan/range/aref select */
+		outb(command_byte, iobase + iooffset + 2);
 
-		adc_wait_ready(iobase + iooffset);	/* wait for the adc to say it finised the conversion */
+		/* wait for the adc to say it finised the conversion */
+		adc_wait_ready(iobase + iooffset);
 
-		outb(command_byte, iobase + iooffset + 2);	/* select the chan/range/aref AGAIN */
+		/* select the chan/range/aref AGAIN */
+		outb(command_byte, iobase + iooffset + 2);
 
 		adc_wait_ready(iobase + iooffset);
 
-		sample = inb(iobase + iooffset + 0);	/* read data lo byte */
-		sample |= inb(iobase + iooffset + 1) << 8;	/* read data hi byte */
+		/* read data lo byte */
+		sample = inb(iobase + iooffset + 0);
+
+		/* read data hi byte */
+		sample |= inb(iobase + iooffset + 1) << 8;
 		sample += adc_adjust;	/* adjustment .. munge data */
 		data[n] = sample;
 	}
@@ -1270,15 +1305,24 @@ static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 			wait_dac_ready(iobase + iooffset);
 
-			outb(data[n] & 0xff, iobase + iooffset + 0);	/* low order byte */
-			outb((data[n] >> 8) & 0xff, iobase + iooffset + 1);	/* high order byte */
-			command_byte = 0x70 | (chan << 1);	/* set bit 4 of command byte to indicate data is loaded and trigger conversion */
+			/* low order byte */
+			outb(data[n] & 0xff, iobase + iooffset + 0);
+
+			/* high order byte */
+			outb((data[n] >> 8) & 0xff, iobase + iooffset + 1);
+
+			/*
+			 * set bit 4 of command byte to indicate
+			 * data is loaded and trigger conversion
+			 */
+			command_byte = 0x70 | (chan << 1);
 			/* trigger converion */
 			outb(command_byte, iobase + iooffset + 2);
 
 			wait_dac_ready(iobase + iooffset);
 
-			subpriv->ao.shadow_samples[chan] = data[n];	/* save to shadow register for ao_rinsn */
+			/* save to shadow register for ao_rinsn */
+			subpriv->ao.shadow_samples[chan] = data[n];
 		}
 	}
 	return n;

commit d2d08955e77a84a0a022dfa9e6f4b4b6c6773281
Author: Daniel Patrick Johnson <teknotus@teknot.us>
Date:   Wed Oct 14 02:04:23 2009 +0000

    Staging: comedi: pcmmio: Coding style cleanup
    
    Signed-off-by: Daniel Patrick Johnson <teknotus@teknot.us>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index d812c2c3af12..c764b28fb319 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -32,8 +32,10 @@ Winsystems.  This board is a PC-104 based I/O board.  It contains
 four subdevices:
   subdevice 0 - 16 channels of 16-bit AI
   subdevice 1 - 8 channels of 16-bit AO
-  subdevice 2 - first 24 channels of the 48 channel of DIO (with edge-triggered interrupt support)
-  subdevice 3 - last 24 channels of the 48 channel DIO (no interrupt support for this bank of channels)
+  subdevice 2 - first 24 channels of the 48 channel of DIO
+	(with edge-triggered interrupt support)
+  subdevice 3 - last 24 channels of the 48 channel DIO
+	(no interrupt support for this bank of channels)
 
   Some notes:
 
@@ -70,7 +72,8 @@ four subdevices:
 
 Configuration Options:
   [0] - I/O port base address
-  [1] - IRQ (optional -- for edge-detect interrupt support only, leave out if you don't need this feature)
+  [1] - IRQ (optional -- for edge-detect interrupt support only,
+	leave out if you don't need this feature)
 */
 
 #include <linux/interrupt.h>
@@ -115,9 +118,11 @@ Configuration Options:
 #define REG_PORT4 0x4
 #define REG_PORT5 0x5
 #define REG_INT_PENDING 0x6
-#define REG_PAGELOCK 0x7	/* page selector register, upper 2 bits select a page
-				   and bits 0-5 are used to 'lock down' a particular
-				   port above to make it readonly.  */
+#define REG_PAGELOCK 0x7	/*
+				 * page selector register, upper 2 bits select
+				 * a page and bits 0-5 are used to 'lock down'
+				 * a particular port above to make it readonly.
+				 */
 #define REG_POL0 0x8
 #define REG_POL1 0x9
 #define REG_POL2 0xA
@@ -134,7 +139,7 @@ Configuration Options:
 #define REG_PAGE_BITOFFSET 6
 #define REG_LOCK_BITOFFSET 0
 #define REG_PAGE_MASK (~((0x1<<REG_PAGE_BITOFFSET)-1))
-#define REG_LOCK_MASK ~(REG_PAGE_MASK)
+#define REG_LOCK_MASK (~(REG_PAGE_MASK))
 #define PAGE_POL 1
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
@@ -168,13 +173,12 @@ struct pcmmio_board {
 	comedi_insn_fn_t ai_rinsn, ao_rinsn, ao_winsn;
 };
 
-static const struct comedi_lrange ranges_ai =
-    { 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
-								 10.)}
+static const struct comedi_lrange ranges_ai = {
+	4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0., 10.)}
 };
 
-static const struct comedi_lrange ranges_ao =
-    { 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
+static const struct comedi_lrange ranges_ao = {
+	6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
 	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
@@ -204,7 +208,8 @@ static const struct pcmmio_board pcmmio_boards[] = {
 struct pcmmio_subdev_private {
 
 	union {
-		/* for DIO: mapping of halfwords (bytes) in port/chanarray to iobase */
+		/* for DIO: mapping of halfwords (bytes)
+		   in port/chanarray to iobase */
 		unsigned long iobases[PORTS_PER_SUBDEV];
 
 		/* for AI/AO */
@@ -215,15 +220,31 @@ struct pcmmio_subdev_private {
 
 			/* The below is only used for intr subdevices */
 			struct {
-				int asic;	/* if non-negative, this subdev has an interrupt asic */
-				int first_chan;	/* if nonnegative, the first channel id for
-						   interrupts. */
-				int num_asic_chans;	/* the number of asic channels in this subdev
-							   that have interrutps */
-				int asic_chan;	/* if nonnegative, the first channel id with
-						   respect to the asic that has interrupts */
-				int enabled_mask;	/* subdev-relative channel mask for channels
-							   we are interested in */
+				/*
+				 * if non-negative, this subdev has an
+				 * interrupt asic
+				 */
+				int asic;
+				/*
+				 * if nonnegative, the first channel id for
+				 * interrupts.
+				 */
+				int first_chan;
+				/*
+				 * the number of asic channels in this subdev
+				 * that have interrutps
+				 */
+				int num_asic_chans;
+				/*
+				 * if nonnegative, the first channel id with
+				 * respect to the asic that has interrupts
+				 */
+				int asic_chan;
+				/*
+				 * subdev-relative channel mask for channels
+				 * we are interested in
+				 */
+				int enabled_mask;
 				int active;
 				int stop_count;
 				int continuous;
@@ -231,20 +252,25 @@ struct pcmmio_subdev_private {
 			} intr;
 		} dio;
 		struct {
-			unsigned int shadow_samples[8];	/* the last unsigned int data written */
+			/* the last unsigned int data written */
+			unsigned int shadow_samples[8];
 		} ao;
 	};
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
+/*
+ * this structure is for data unique to this hardware driver.  If
+ * several hardware drivers keep similar information in this structure,
+ * feel free to suggest moving the variable to the struct comedi_device struct.
+ */
 struct pcmmio_private {
 	/* stuff for DIO */
 	struct {
 		unsigned char pagelock;	/* current page and lock */
-		unsigned char pol[NUM_PAGED_REGS];	/* shadow of POLx registers */
-		unsigned char enab[NUM_PAGED_REGS];	/* shadow of ENABx registers */
+		/* shadow of POLx registers */
+		unsigned char pol[NUM_PAGED_REGS];
+		/* shadow of ENABx registers */
+		unsigned char enab[NUM_PAGED_REGS];
 		int num;
 		unsigned long iobase;
 		unsigned int irq;
@@ -312,7 +338,8 @@ static int pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
-static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
+/* sets up/clears ASIC chips to defaults */
+static void init_asics(struct comedi_device *dev);
 static void switch_page(struct comedi_device *dev, int asic, int page);
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port);
@@ -367,9 +394,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase =
 		    dev->iobase + 16 + asic * ASIC_IOSIZE;
-		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
-						   this function when we
-						   request_irqs */
+		/*
+		 * this gets actually set at the end of this function when we
+		 * request_irqs
+		 */
+		devpriv->asics[asic].irq = 0;
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -463,7 +492,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
 			    && subpriv->dio.intr.asic < 0) {
-				/* this is an interrupt subdevice, so setup the struct */
+				/*
+				 * this is an interrupt subdevice,
+				 * so setup the struct
+				 */
 				subpriv->dio.intr.asic = asic;
 				subpriv->dio.intr.active = 0;
 				subpriv->dio.intr.stop_count = 0;
@@ -484,7 +516,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		chans_left -= s->n_chan;
 
 		if (!chans_left) {
-			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
+			/*
+			 * reset the asic to our first asic,
+			 * to do intr subdevs
+			 */
+			asic = 0;
 			port = 0;
 		}
 
@@ -507,8 +543,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].irq = irq[asic];
 	}
 
-	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
-				   irqs.. */
+	dev->irq = irq[0];	/*
+				 * grr.. wish comedi dev struct supported
+				 * multiple irqs..
+				 */
 
 	if (irq[0]) {
 		printk("irq: %u ", irq[0]);
@@ -604,9 +642,14 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev,
 #endif
 
 		if (write_mask_byte) {
-			/* this byte has some write_bits -- so set the output lines */
-			byte &= ~write_mask_byte;	/* clear bits for write mask */
-			byte |= ~data_byte & write_mask_byte;	/* set to inverted data_byte */
+			/*
+			 * this byte has some write_bits
+			 * -- so set the output lines
+			 */
+			/* clear bits for write mask */
+			byte &= ~write_mask_byte;
+			/* set to inverted data_byte */
+			byte |= ~data_byte & write_mask_byte;
 			/* Write out the new digital output state */
 			outb(byte, ioaddr);
 		}

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index cdf501afa14e..d812c2c3af12 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -139,15 +139,16 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-typedef int (*comedi_insn_fn_t) (struct comedi_device *, struct comedi_subdevice *,
-	struct comedi_insn *, unsigned int *);
+typedef int (*comedi_insn_fn_t) (struct comedi_device *,
+				 struct comedi_subdevice *,
+				 struct comedi_insn *, unsigned int *);
 
-static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
-static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
-static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
-	unsigned int *);
+static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
+static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
+static int ao_winsn(struct comedi_device *, struct comedi_subdevice *,
+		    struct comedi_insn *, unsigned int *);
 
 /*
  * Board descriptions for two imaginary boards.  Describing the
@@ -168,30 +169,30 @@ struct pcmmio_board {
 };
 
 static const struct comedi_lrange ranges_ai =
-	{ 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
-		10.)}
+    { 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
+								 10.)}
 };
 
 static const struct comedi_lrange ranges_ao =
-	{ 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
-	RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
+    { 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
+	  RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
 static const struct pcmmio_board pcmmio_boards[] = {
 	{
-	.name = "pcmmio",
-	.dio_num_asics = 1,
-	.dio_num_ports = 6,
-	.total_iosize = 32,
-	.ai_bits = 16,
-	.ao_bits = 16,
-	.n_ai_chans = 16,
-	.n_ao_chans = 8,
-	.ai_range_table = &ranges_ai,
-	.ao_range_table = &ranges_ao,
-	.ai_rinsn = ai_rinsn,
-	.ao_rinsn = ao_rinsn,
-	.ao_winsn = ao_winsn},
+	 .name = "pcmmio",
+	 .dio_num_asics = 1,
+	 .dio_num_ports = 6,
+	 .total_iosize = 32,
+	 .ai_bits = 16,
+	 .ao_bits = 16,
+	 .n_ai_chans = 16,
+	 .n_ao_chans = 8,
+	 .ai_range_table = &ranges_ai,
+	 .ao_range_table = &ranges_ao,
+	 .ai_rinsn = ai_rinsn,
+	 .ao_rinsn = ao_rinsn,
+	 .ao_winsn = ao_winsn},
 };
 
 /*
@@ -264,7 +265,8 @@ struct pcmmio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmmio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcmmio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
@@ -295,17 +297,19 @@ static struct comedi_driver driver = {
 	.num_names = ARRAY_SIZE(pcmmio_boards),
 };
 
-static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pcmmio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int pcmmio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d);
 static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
@@ -325,7 +329,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
-		thisasic_chanct = 0;
+	    thisasic_chanct = 0;
 	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
 
@@ -333,12 +337,13 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[0] = it->options[1];
 
 	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-			thisboard->total_iosize, driver.driver_name)) {
+				       thisboard->total_iosize,
+				       driver.driver_name)) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -361,7 +366,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase =
-			dev->iobase + 16 + asic * ASIC_IOSIZE;
+		    dev->iobase + 16 + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
 						   request_irqs */
@@ -372,7 +377,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
 	n_subdevs = n_dio_subdevs + 2;
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private), GFP_KERNEL);
+	    kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),
+		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
@@ -452,11 +458,11 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				thisasic_chanct = 0;
 			}
 			subpriv->iobases[byte_no] =
-				devpriv->asics[asic].iobase + port;
+			    devpriv->asics[asic].iobase + port;
 
 			if (thisasic_chanct <
-				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-				&& subpriv->dio.intr.asic < 0) {
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->dio.intr.asic < 0) {
 				/* this is an interrupt subdevice, so setup the struct */
 				subpriv->dio.intr.asic = asic;
 				subpriv->dio.intr.active = 0;
@@ -464,13 +470,12 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				subpriv->dio.intr.first_chan = byte_no * 8;
 				subpriv->dio.intr.asic_chan = thisasic_chanct;
 				subpriv->dio.intr.num_asic_chans =
-					s->n_chan -
-					subpriv->dio.intr.first_chan;
+				    s->n_chan - subpriv->dio.intr.first_chan;
 				s->cancel = pcmmio_cancel;
 				s->do_cmd = pcmmio_cmd;
 				s->do_cmdtest = pcmmio_cmdtest;
 				s->len_chanlist =
-					subpriv->dio.intr.num_asic_chans;
+				    subpriv->dio.intr.num_asic_chans;
 			}
 			thisasic_chanct += CHANS_PER_PORT;
 		}
@@ -489,8 +494,8 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& request_irq(irq[asic], interrupt_pcmmio,
-				IRQF_SHARED, thisboard->name, dev)) {
+		    && request_irq(irq[asic], interrupt_pcmmio,
+				   IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -550,8 +555,9 @@ static int pcmmio_detach(struct comedi_device *dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -578,20 +584,23 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
 		/* address of 8-bit port */
 		unsigned long ioaddr = subpriv->iobases[byte_no],
-			/* bit offset of port in 32-bit doubleword */
-			offset = byte_no * 8;
+		    /* bit offset of port in 32-bit doubleword */
+		    offset = byte_no * 8;
 		/* this 8-bit port's data */
 		unsigned char byte = 0,
-			/* The write mask for this port (if any) */
-			write_mask_byte = (data[0] >> offset) & 0xff,
-			/* The data byte for this port */
-			data_byte = (data[1] >> offset) & 0xff;
+		    /* The write mask for this port (if any) */
+		    write_mask_byte = (data[0] >> offset) & 0xff,
+		    /* The data byte for this port */
+		    data_byte = (data[1] >> offset) & 0xff;
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+		printk
+		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
+		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
+		     offset, ioaddr, (unsigned)byte);
 #endif
 
 		if (write_mask_byte) {
@@ -624,11 +633,12 @@ static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmmio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-		chan % 8;
+	    chan % 8;
 	unsigned long ioaddr;
 	unsigned char byte;
 
@@ -672,8 +682,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subde
 	case INSN_CONFIG_DIO_QUERY:
 		/* retreive from shadow register */
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 
@@ -706,7 +715,7 @@ static void init_asics(struct comedi_device *dev)
 			/* now clear all the paged registers */
 			switch_page(dev, asic, page);
 			for (reg = FIRST_PAGED_REG;
-				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
 				outb(0, baseaddr + reg);
 		}
 
@@ -734,7 +743,7 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 }
 
 #ifdef notused
@@ -748,7 +757,7 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 	devpriv->asics[asic].pagelock |= 0x1 << port;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 	return;
 }
 
@@ -761,14 +770,14 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	     devpriv->asics[asic].iobase + REG_PAGELOCK);
 }
 #endif /* notused */
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -778,124 +787,130 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+					  flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
 			if (int_pend) {
 				int port;
 				for (port = 0; port < INTR_PORTS_PER_ASIC;
-					++port) {
+				     ++port) {
 					if (int_pend & (0x1 << port)) {
 						unsigned char
-							io_lines_with_edges = 0;
+						    io_lines_with_edges = 0;
 						switch_page(dev, asic,
-							PAGE_INT_ID);
+							    PAGE_INT_ID);
 						io_lines_with_edges =
-							inb(iobase +
+						    inb(iobase +
 							REG_INT_ID0 + port);
 
 						if (io_lines_with_edges)
 							/* clear pending interrupt */
 							outb(0, iobase +
-								REG_INT_ID0 +
-								port);
+							     REG_INT_ID0 +
+							     port);
 
 						triggered |=
-							io_lines_with_edges <<
-							port * 8;
+						    io_lines_with_edges <<
+						    port * 8;
 					}
 				}
 
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].  spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
+					       flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
-				printk("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				printk
+				    ("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
+				     irq, asic, triggered);
 				for (s = dev->subdevices + 2;
-					s < dev->subdevices + dev->n_subdevices;
-					++s) {
+				     s < dev->subdevices + dev->n_subdevices;
+				     ++s) {
 					if (subpriv->dio.intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
 
-						spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+						spin_lock_irqsave(&subpriv->dio.
+								  intr.spinlock,
+								  flags);
 
 						oldevents = s->async->events;
 
 						if (subpriv->dio.intr.active) {
 							unsigned mytrig =
-								((triggered >>
-									subpriv->
-									dio.
-									intr.
-									asic_chan)
-								& ((0x1 << subpriv->dio.intr.num_asic_chans) - 1)) << subpriv->dio.intr.first_chan;
-							if (mytrig & subpriv->
-								dio.intr.
-								enabled_mask) {
-								unsigned int val =
-									0;
+							    ((triggered >>
+							      subpriv->dio.intr.asic_chan)
+							     &
+							     ((0x1 << subpriv->
+							       dio.intr.
+							       num_asic_chans) -
+							      1)) << subpriv->
+							    dio.intr.first_chan;
+							if (mytrig &
+							    subpriv->dio.
+							    intr.enabled_mask) {
+								unsigned int val
+								    = 0;
 								unsigned int n,
-									ch, len;
+								    ch, len;
 
-								len = s->async->
-									cmd.
-									chanlist_len;
+								len =
+								    s->
+								    async->cmd.chanlist_len;
 								for (n = 0;
-									n < len;
-									n++) {
+								     n < len;
+								     n++) {
 									ch = CR_CHAN(s->async->cmd.chanlist[n]);
 									if (mytrig & (1U << ch)) {
 										val |= (1U << n);
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) &val)[0])
-									&&
-									comedi_buf_put
-									(s->async, ((short *) &val)[1])) {
+								if (comedi_buf_put(s->async, ((short *)&val)[0])
+								    &&
+								    comedi_buf_put
+								    (s->async,
+								     ((short *)
+								      &val)[1]))
+								{
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
 									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 									pcmmio_stop_intr
-										(dev,
-										s);
+									    (dev,
+									     s);
 								}
 
 								/* Check for end of acquisition. */
-								if (!subpriv->
-									dio.
-									intr.
-									continuous)
-								{
+								if (!subpriv->dio.intr.continuous) {
 									/* stop_src == TRIG_COUNT */
 									if (subpriv->dio.intr.stop_count > 0) {
-										subpriv->
-											dio.
-											intr.
-											stop_count--;
+										subpriv->dio.intr.stop_count--;
 										if (subpriv->dio.intr.stop_count == 0) {
 											s->async->events |= COMEDI_CB_EOA;
 											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 											pcmmio_stop_intr
-												(dev,
-												s);
+											    (dev,
+											     s);
 										}
 									}
 								}
 							}
 						}
 
-						spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+						spin_unlock_irqrestore
+						    (&subpriv->dio.intr.
+						     spinlock, flags);
 
 						if (oldevents !=
-							s->async->events) {
+						    s->async->events) {
 							comedi_event(dev, s);
 						}
 
@@ -911,7 +926,8 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcmmio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pcmmio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -931,7 +947,8 @@ static void pcmmio_stop_intr(struct comedi_device *dev, struct comedi_subdevice
 	}
 }
 
-static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcmmio_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -944,7 +961,7 @@ static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 		struct comedi_cmd *cmd = &s->async->cmd;
 
 		asic = subpriv->dio.intr.asic;
-		if (asic  < 0)
+		if (asic < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->dio.intr.enabled_mask = 0;
@@ -955,12 +972,13 @@ static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
 				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
-					<< CR_CHAN(cmd->chanlist[n]);
+					     || CR_RANGE(cmd->
+							 chanlist[n]) ? 1U : 0U)
+				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
 		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) -
-			1) << subpriv->dio.intr.first_chan;
+			 1) << subpriv->dio.intr.first_chan;
 		subpriv->dio.intr.enabled_mask = bits;
 
 		{		/* the below code configures the board to use a specific IRQ from 0-15. */
@@ -976,16 +994,17 @@ static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 		switch_page(dev, asic, PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
-				bits >> (subpriv->dio.intr.first_chan + (port -
-					firstport) * 8) & 0xff, pol =
-				pol_bits >> (subpriv->dio.intr.first_chan +
-				(port - firstport) * 8) & 0xff;
+			    bits >> (subpriv->dio.intr.first_chan + (port -
+								     firstport)
+				     * 8) & 0xff, pol =
+			    pol_bits >> (subpriv->dio.intr.first_chan +
+					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 			switch_page(dev, asic, PAGE_POL);
 			outb(pol,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 		}
 	}
 	return 0;
@@ -1008,7 +1027,7 @@ static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  */
 static int
 pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	unsigned long flags;
 	int event = 0;
@@ -1075,7 +1094,8 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int
-pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	       struct comedi_cmd *cmd)
 {
 	return comedi_pcm_cmdtest(dev, s, cmd);
 }
@@ -1091,7 +1111,7 @@ static int adc_wait_ready(unsigned long iobase)
 
 /* All this is for AI and AO */
 static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned long iobase = subpriv->iobase;
@@ -1110,8 +1130,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec), range =
-			CR_RANGE(insn->chanspec), aref =
-			CR_AREF(insn->chanspec);
+		    CR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);
 		unsigned char command_byte = 0;
 		unsigned iooffset = 0;
 		short sample, adc_adjust = 0;
@@ -1155,7 +1174,7 @@ static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	for (n = 0; n < insn->n; n++) {
@@ -1185,17 +1204,17 @@ static int wait_dac_ready(unsigned long iobase)
 }
 
 static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;
 
 	for (n = 0; n < insn->n; n++) {
 		unsigned chan = CR_CHAN(insn->chanspec), range =
-			CR_RANGE(insn->chanspec);
+		    CR_RANGE(insn->chanspec);
 		if (chan < s->n_chan) {
 			unsigned char command_byte = 0, range_byte =
-				range & ((1 << 4) - 1);
+			    range & ((1 << 4) - 1);
 			if (chan >= 4)
 				chan -= 4, iooffset += 4;
 			/* set the range.. */

commit 0b8f754a6220158f2348bc6eae2772bc64bc98a2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu May 14 15:24:29 2009 -0400

    staging: comedi: Move pcm do_cmdtest function into a single source file
    
    Many of the comedi source code has functions that were created with
    cut and paste, this moves the do_cmdtest function into a single file.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index e1ad03e234b7..cdf501afa14e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -75,6 +75,7 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include "../comedidev.h"
+#include "pcm_common.h"
 #include <linux/pci.h>		/* for PCI devices */
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
@@ -1073,110 +1074,10 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
- */
 static int
 pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0;
-	unsigned int tmp;
-
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= (TRIG_NOW | TRIG_INT);
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
-
-	if (err)
-		return 1;
-
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
-
-	if (err)
-		return 2;
-
-	/* step 3: make sure arguments are trivially compatible */
-
-	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_begin_src == TRIG_EXT */
-	if (cmd->scan_begin_arg != 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
-
-	/* cmd->convert_src == TRIG_NOW */
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_end_src == TRIG_COUNT */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	/* if (err) return 4; */
-
-	return 0;
+	return comedi_pcm_cmdtest(dev, s, cmd);
 }
 
 static int adc_wait_ready(unsigned long iobase)

commit 214e7b5c8281bf41238f575128e4fec5652ed797
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu May 14 15:24:28 2009 -0400

    staging: comedi: Remove MIN macro
    
    Remove the MIN() macro and instead use the min() provided by kernel.h
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6931f1075089..e1ad03e234b7 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -77,8 +77,6 @@ Configuration Options:
 #include "../comedidev.h"
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a, b) (((a) < (b)) ? (a) : (b))
-
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
@@ -436,7 +434,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_DIO;
 		s->insn_bits = pcmmio_dio_insn_bits;
 		s->insn_config = pcmmio_dio_insn_config;
-		s->n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->dio.intr.asic = -1;
 		subpriv->dio.intr.first_chan = -1;
 		subpriv->dio.intr.asic_chan = -1;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 55a2d1d0408d..6931f1075089 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -73,6 +73,7 @@ Configuration Options:
   [1] - IRQ (optional -- for edge-detect interrupt support only, leave out if you don't need this feature)
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/pci.h>		/* for PCI devices */
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 2ff2fe94b704..55a2d1d0408d 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -364,7 +364,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->iobase + 16 + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
-						   comedi_request_irqs */
+						   request_irqs */
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -489,12 +489,12 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& comedi_request_irq(irq[asic], interrupt_pcmmio,
+			&& request_irq(irq[asic], interrupt_pcmmio,
 				IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
-				comedi_free_irq(irq[i], dev);
+				free_irq(irq[i], dev);
 				devpriv->asics[i].irq = irq[i] = 0;
 			}
 			irq[asic] = 0;
@@ -536,7 +536,7 @@ static int pcmmio_detach(struct comedi_device *dev)
 
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv && devpriv->asics[i].irq)
-			comedi_free_irq(devpriv->asics[i].irq, dev);
+			free_irq(devpriv->asics[i].irq, dev);
 	}
 
 	if (devpriv && devpriv->sprivs)
@@ -778,8 +778,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-				flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
@@ -811,8 +810,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 				++got1;
 			}
 
-			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
-				spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].  spinlock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -825,9 +823,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 						unsigned long flags;
 						unsigned oldevents;
 
-						comedi_spin_lock_irqsave
-							(&subpriv->dio.intr.
-							spinlock, flags);
+						spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 
 						oldevents = s->async->events;
 
@@ -896,9 +892,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 							}
 						}
 
-						comedi_spin_unlock_irqrestore
-							(&subpriv->dio.intr.
-							spinlock, flags);
+						spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 						if (oldevents !=
 							s->async->events) {
@@ -1001,10 +995,10 @@ static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	if (subpriv->dio.intr.active)
 		pcmmio_stop_intr(dev, s);
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	return 0;
 }
@@ -1022,12 +1016,12 @@ pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->dio.intr.active) {
 		event = pcmmio_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -1045,7 +1039,7 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
 	subpriv->dio.intr.active = 1;
 
 	/* Set up end of acquisition. */
@@ -1071,7 +1065,7 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		event = pcmmio_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9d025ab5b9f3..2ff2fe94b704 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -292,7 +292,7 @@ static struct comedi_driver driver = {
 	 */
 	.board_name = &pcmmio_boards[0].name,
 	.offset = sizeof(struct pcmmio_board),
-	.num_names = sizeof(pcmmio_boards) / sizeof(struct pcmmio_board),
+	.num_names = ARRAY_SIZE(pcmmio_boards),
 };
 
 static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index de444fff8d3e..9d025ab5b9f3 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -295,24 +295,24 @@ static struct comedi_driver driver = {
 	.num_names = sizeof(pcmmio_boards) / sizeof(struct pcmmio_board),
 };
 
-static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d);
 static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
-static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
+static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
-static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
-static void switch_page(struct comedi_device * dev, int asic, int page);
+static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(struct comedi_device *dev, int asic, int page);
 #ifdef notused
-static void lock_port(struct comedi_device * dev, int asic, int port);
-static void unlock_port(struct comedi_device * dev, int asic, int port);
+static void lock_port(struct comedi_device *dev, int asic, int port);
+static void unlock_port(struct comedi_device *dev, int asic, int port);
 #endif
 
 /*

commit 9b9bcba0cafa2578cebbe0eca01eaafd49f3e43b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:53 2009 -0400

    Staging: comedi: remove space after ampersand
    
    Change calses of & foo to &foo as suggested by checkpatch.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index b9e8a1757365..de444fff8d3e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -859,10 +859,10 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) & val)[0])
+								if (comedi_buf_put(s->async, ((short *) &val)[0])
 									&&
 									comedi_buf_put
-									(s->async, ((short *) & val)[1])) {
+									(s->async, ((short *) &val)[1])) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 82da558fc8f7..b9e8a1757365 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -179,19 +179,19 @@ static const struct comedi_lrange ranges_ao =
 
 static const struct pcmmio_board pcmmio_boards[] = {
 	{
-	      name:	"pcmmio",
-	      dio_num_asics:1,
-	      dio_num_ports:6,
-	      total_iosize:32,
-	      ai_bits:	16,
-	      ao_bits:	16,
-	      n_ai_chans:16,
-	      n_ao_chans:8,
-	      ai_range_table:&ranges_ai,
-	      ao_range_table:&ranges_ao,
-	      ai_rinsn:ai_rinsn,
-	      ao_rinsn:ao_rinsn,
-      ao_winsn:ao_winsn},
+	.name = "pcmmio",
+	.dio_num_asics = 1,
+	.dio_num_ports = 6,
+	.total_iosize = 32,
+	.ai_bits = 16,
+	.ao_bits = 16,
+	.n_ai_chans = 16,
+	.n_ao_chans = 8,
+	.ai_range_table = &ranges_ai,
+	.ao_range_table = &ranges_ao,
+	.ai_rinsn = ai_rinsn,
+	.ao_rinsn = ao_rinsn,
+	.ao_winsn = ao_winsn},
 };
 
 /*
@@ -268,10 +268,10 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static int pcmmio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
-      driver_name:"pcmmio",
-      module:THIS_MODULE,
-      attach:pcmmio_attach,
-      detach:pcmmio_detach,
+	.driver_name = "pcmmio",
+	.module = THIS_MODULE,
+	.attach = pcmmio_attach,
+	.detach = pcmmio_detach,
 /* It is not necessary to implement the following members if you are
  * writing a driver for a ISA PnP or PCI card */
 	/* Most drivers will support multiple types of boards by
@@ -290,9 +290,9 @@ static struct comedi_driver driver = {
 	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
 	 * devices are such boards.
 	 */
-      board_name:&pcmmio_boards[0].name,
-      offset:sizeof(struct pcmmio_board),
-      num_names:sizeof(pcmmio_boards) / sizeof(struct pcmmio_board),
+	.board_name = &pcmmio_boards[0].name,
+	.offset = sizeof(struct pcmmio_board),
+	.num_names = sizeof(pcmmio_boards) / sizeof(struct pcmmio_board),
 };
 
 static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 849fa4fa4ced..82da558fc8f7 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -921,7 +921,8 @@ static void pcmmio_stop_intr(struct comedi_device *dev, struct comedi_subdevice
 {
 	int nports, firstport, asic, port;
 
-	if ((asic = subpriv->dio.intr.asic) < 0)
+	asic = subpriv->dio.intr.asic;
+	if (asic < 0)
 		return;		/* not an interrupt subdev */
 
 	subpriv->dio.intr.enabled_mask = 0;
@@ -948,7 +949,8 @@ static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 		int nports, firstport, asic, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		if ((asic = subpriv->dio.intr.asic) < 0)
+		asic = subpriv->dio.intr.asic;
+		if (asic  < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->dio.intr.enabled_mask = 0;

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 0dc51f62bac5..849fa4fa4ced 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -76,7 +76,7 @@ Configuration Options:
 #include "../comedidev.h"
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8

commit f7cbd7aad063b2a4b7aff6a743b2b00015ce3c3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:16 2009 -0400

    Staging: comedi: Add spaces after commas
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 9afd51ff9074..0dc51f62bac5 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -76,7 +76,7 @@ Configuration Options:
 #include "../comedidev.h"
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
+#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 8c332c2f421a..9afd51ff9074 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -264,8 +264,8 @@ struct pcmmio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pcmmio_detach(struct comedi_device * dev);
+static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmmio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
       driver_name:"pcmmio",
@@ -321,7 +321,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
@@ -526,7 +526,7 @@ static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pcmmio_detach(struct comedi_device * dev)
+static int pcmmio_detach(struct comedi_device *dev)
 {
 	int i;
 
@@ -550,8 +550,8 @@ static int pcmmio_detach(struct comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcmmio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -624,8 +624,8 @@ static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcmmio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;
@@ -685,7 +685,7 @@ static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subd
 	return insn->n;
 }
 
-static void init_asics(struct comedi_device * dev)
+static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
 	int asic;
@@ -722,7 +722,7 @@ static void init_asics(struct comedi_device * dev)
 	}
 }
 
-static void switch_page(struct comedi_device * dev, int asic, int page)
+static void switch_page(struct comedi_device *dev, int asic, int page)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -738,7 +738,7 @@ static void switch_page(struct comedi_device * dev, int asic, int page)
 }
 
 #ifdef notused
-static void lock_port(struct comedi_device * dev, int asic, int port)
+static void lock_port(struct comedi_device *dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -752,7 +752,7 @@ static void lock_port(struct comedi_device * dev, int asic, int port)
 	return;
 }
 
-static void unlock_port(struct comedi_device * dev, int asic, int port)
+static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -917,7 +917,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcmmio_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pcmmio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -936,7 +936,7 @@ static void pcmmio_stop_intr(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static int pcmmio_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmmio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -995,7 +995,7 @@ static int pcmmio_start_intr(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -1011,7 +1011,7 @@ static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
+pcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -1037,7 +1037,7 @@ pcmmio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -1082,7 +1082,7 @@ static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
+pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1194,8 +1194,8 @@ static int adc_wait_ready(unsigned long iobase)
 }
 
 /* All this is for AI and AO */
-static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned long iobase = subpriv->iobase;
@@ -1258,8 +1258,8 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	return n;
 }
 
-static int ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	for (n = 0; n < insn->n; n++) {
@@ -1288,8 +1288,8 @@ static int wait_dac_ready(unsigned long iobase)
 	return 1;
 }
 
-static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 01e40f1b5628..8c332c2f421a 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -300,7 +300,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
 static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data);
 
-static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
+static irqreturn_t interrupt_pcmmio(int irq, void *d);
 static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -765,7 +765,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port)
 }
 #endif /* notused */
 
-static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
+static irqreturn_t interrupt_pcmmio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *) d;

commit e56ab7156f5f4918eb89a19b3061de1a7fe69354
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:20:30 2009 -0400

    Staging: comedi: Remove pcmmio_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 2d4f9689dd84..01e40f1b5628 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -238,7 +238,7 @@ struct pcmmio_subdev_private {
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct pcmmio_private {
 	/* stuff for DIO */
 	struct {
 		unsigned char pagelock;	/* current page and lock */
@@ -250,13 +250,13 @@ typedef struct {
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
 	struct pcmmio_subdev_private *sprivs;
-} pcmmio_private;
+};
 
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
-#define devpriv ((pcmmio_private *)dev->private)
+#define devpriv ((struct pcmmio_private *)dev->private)
 #define subpriv ((struct pcmmio_subdev_private *)s->private)
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -353,7 +353,7 @@ static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_private(dev, sizeof(pcmmio_private)) < 0) {
+	if (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {
 		printk("cannot allocate private data structure\n");
 		return -ENOMEM;
 	}

commit 4467df9406bc40fdbc9cf64cfb2e95cba8f77e1e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:37 2009 -0400

    Staging: comedi: Remove pcmmio_subdev_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 75db61055db3..2d4f9689dd84 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -200,7 +200,7 @@ static const struct pcmmio_board pcmmio_boards[] = {
 #define thisboard ((const struct pcmmio_board *)dev->board_ptr)
 
 /* this structure is for data unique to this subdevice.  */
-typedef struct {
+struct pcmmio_subdev_private {
 
 	union {
 		/* for DIO: mapping of halfwords (bytes) in port/chanarray to iobase */
@@ -233,7 +233,7 @@ typedef struct {
 			unsigned int shadow_samples[8];	/* the last unsigned int data written */
 		} ao;
 	};
-} pcmmio_subdev_private;
+};
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -249,7 +249,7 @@ typedef struct {
 		unsigned int irq;
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
-	pcmmio_subdev_private *sprivs;
+	struct pcmmio_subdev_private *sprivs;
 } pcmmio_private;
 
 /*
@@ -257,7 +257,7 @@ typedef struct {
  * access the private structure.
  */
 #define devpriv ((pcmmio_private *)dev->private)
-#define subpriv ((pcmmio_subdev_private *)s->private)
+#define subpriv ((struct pcmmio_subdev_private *)s->private)
 /*
  * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
@@ -372,7 +372,7 @@ static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
 	n_subdevs = n_dio_subdevs + 2;
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(pcmmio_subdev_private), GFP_KERNEL);
+		kcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private), GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;

commit 657f81ec27758ddb859ea9c74929996bea607194
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:04 2009 -0400

    Staging: comedi: Remove pcmmio_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 85c205418703..75db61055db3 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -154,7 +154,7 @@ static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, struct co
  * boards in this way is optional, and completely driver-dependent.
  * Some drivers use arrays such as this, other do not.
  */
-typedef struct pcmmio_board_struct {
+struct pcmmio_board {
 	const char *name;
 	const int dio_num_asics;
 	const int dio_num_ports;
@@ -165,7 +165,7 @@ typedef struct pcmmio_board_struct {
 	const int n_ao_chans;
 	const struct comedi_lrange *ai_range_table, *ao_range_table;
 	comedi_insn_fn_t ai_rinsn, ao_rinsn, ao_winsn;
-} pcmmio_board;
+};
 
 static const struct comedi_lrange ranges_ai =
 	{ 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
@@ -177,7 +177,7 @@ static const struct comedi_lrange ranges_ao =
 	RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };
 
-static const pcmmio_board pcmmio_boards[] = {
+static const struct pcmmio_board pcmmio_boards[] = {
 	{
 	      name:	"pcmmio",
 	      dio_num_asics:1,
@@ -197,7 +197,7 @@ static const pcmmio_board pcmmio_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const pcmmio_board *)dev->board_ptr)
+#define thisboard ((const struct pcmmio_board *)dev->board_ptr)
 
 /* this structure is for data unique to this subdevice.  */
 typedef struct {
@@ -291,8 +291,8 @@ static struct comedi_driver driver = {
 	 * devices are such boards.
 	 */
       board_name:&pcmmio_boards[0].name,
-      offset:sizeof(pcmmio_board),
-      num_names:sizeof(pcmmio_boards) / sizeof(pcmmio_board),
+      offset:sizeof(struct pcmmio_board),
+      num_names:sizeof(pcmmio_boards) / sizeof(struct pcmmio_board),
 };
 
 static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index e44dee964aaa..85c205418703 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -264,7 +264,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pcmmio_detach(struct comedi_device * dev);
 
 static struct comedi_driver driver = {
@@ -321,7 +321,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pcmmio_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index f428f6923f59..e44dee964aaa 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -140,13 +140,13 @@ Configuration Options:
 #define PAGE_INT_ID 3
 
 typedef int (*comedi_insn_fn_t) (struct comedi_device *, struct comedi_subdevice *,
-	comedi_insn *, unsigned int *);
+	struct comedi_insn *, unsigned int *);
 
-static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
+static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
 	unsigned int *);
-static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
+static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
 	unsigned int *);
-static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
+static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, struct comedi_insn *,
 	unsigned int *);
 
 /*
@@ -296,9 +296,9 @@ static struct comedi_driver driver = {
 };
 
 static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
 static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
@@ -551,7 +551,7 @@ static int pcmmio_detach(struct comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -625,7 +625,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;
@@ -1195,7 +1195,7 @@ static int adc_wait_ready(unsigned long iobase)
 
 /* All this is for AI and AO */
 static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	unsigned long iobase = subpriv->iobase;
@@ -1259,7 +1259,7 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	for (n = 0; n < insn->n; n++) {
@@ -1289,7 +1289,7 @@ static int wait_dac_ready(unsigned long iobase)
 }
 
 static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 780de845034a..f428f6923f59 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -305,7 +305,7 @@ static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
@@ -946,7 +946,7 @@ static int pcmmio_start_intr(struct comedi_device * dev, struct comedi_subdevice
 	} else {
 		unsigned bits = 0, pol_bits = 0, n;
 		int nports, firstport, asic, port;
-		comedi_cmd *cmd = &s->async->cmd;
+		struct comedi_cmd *cmd = &s->async->cmd;
 
 		if ((asic = subpriv->dio.intr.asic) < 0)
 			return 1;	/* not an interrupt
@@ -1039,7 +1039,7 @@ pcmmio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
  */
 static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
 
@@ -1082,7 +1082,7 @@ static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
+pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 0dcc09982fa6..780de845034a 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -163,16 +163,16 @@ typedef struct pcmmio_board_struct {
 	const int ao_bits;
 	const int n_ai_chans;
 	const int n_ao_chans;
-	const comedi_lrange *ai_range_table, *ao_range_table;
+	const struct comedi_lrange *ai_range_table, *ao_range_table;
 	comedi_insn_fn_t ai_rinsn, ao_rinsn, ao_winsn;
 } pcmmio_board;
 
-static const comedi_lrange ranges_ai =
+static const struct comedi_lrange ranges_ai =
 	{ 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
 		10.)}
 };
 
-static const comedi_lrange ranges_ao =
+static const struct comedi_lrange ranges_ao =
 	{ 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
 	RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
 };

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6af8637880c0..0dcc09982fa6 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -259,7 +259,7 @@ typedef struct {
 #define devpriv ((pcmmio_private *)dev->private)
 #define subpriv ((pcmmio_subdev_private *)s->private)
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
@@ -267,7 +267,7 @@ typedef struct {
 static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int pcmmio_detach(struct comedi_device * dev);
 
-static comedi_driver driver = {
+static struct comedi_driver driver = {
       driver_name:"pcmmio",
       module:THIS_MODULE,
       attach:pcmmio_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 77f62cddddb3..6af8637880c0 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -139,14 +139,14 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-typedef int (*comedi_insn_fn_t) (struct comedi_device *, comedi_subdevice *,
+typedef int (*comedi_insn_fn_t) (struct comedi_device *, struct comedi_subdevice *,
 	comedi_insn *, unsigned int *);
 
-static int ai_rinsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ai_rinsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
 	unsigned int *);
-static int ao_rinsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ao_rinsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
 	unsigned int *);
-static int ao_winsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ao_winsn(struct comedi_device *, struct comedi_subdevice *, comedi_insn *,
 	unsigned int *);
 
 /*
@@ -295,16 +295,16 @@ static comedi_driver driver = {
       num_names:sizeof(pcmmio_boards) / sizeof(pcmmio_board),
 };
 
-static int pcmmio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pcmmio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
-static void pcmmio_stop_intr(struct comedi_device *, comedi_subdevice *);
-static int pcmmio_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static int pcmmio_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int pcmmio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static void pcmmio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
+static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
@@ -323,7 +323,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  */
 static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
 		thisasic_chanct = 0;
 	unsigned long iobase;
@@ -550,7 +550,7 @@ static int pcmmio_detach(struct comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
@@ -624,7 +624,7 @@ static int pcmmio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmmio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
@@ -815,7 +815,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 				spinlock, flags);
 
 			if (triggered) {
-				comedi_subdevice *s;
+				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
 				printk("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
 				for (s = dev->subdevices + 2;
@@ -917,7 +917,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pcmmio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
+static void pcmmio_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int nports, firstport, asic, port;
 
@@ -936,7 +936,7 @@ static void pcmmio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pcmmio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -995,7 +995,7 @@ static int pcmmio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcmmio_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1011,7 +1011,7 @@ static int pcmmio_cancel(struct comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
+pcmmio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -1037,7 +1037,7 @@ pcmmio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmmio_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -1082,7 +1082,7 @@ static int pcmmio_cmd(struct comedi_device * dev, comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pcmmio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1194,7 +1194,7 @@ static int adc_wait_ready(unsigned long iobase)
 }
 
 /* All this is for AI and AO */
-static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -1258,7 +1258,7 @@ static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -1288,7 +1288,7 @@ static int wait_dac_ready(unsigned long iobase)
 	return 1;
 }
 
-static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 739959cd2cfd..77f62cddddb3 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -139,14 +139,14 @@ Configuration Options:
 #define PAGE_ENAB 2
 #define PAGE_INT_ID 3
 
-typedef int (*comedi_insn_fn_t) (comedi_device *, comedi_subdevice *,
+typedef int (*comedi_insn_fn_t) (struct comedi_device *, comedi_subdevice *,
 	comedi_insn *, unsigned int *);
 
-static int ai_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ai_rinsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
 	unsigned int *);
-static int ao_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ao_rinsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
 	unsigned int *);
-static int ao_winsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+static int ao_winsn(struct comedi_device *, comedi_subdevice *, comedi_insn *,
 	unsigned int *);
 
 /*
@@ -237,7 +237,7 @@ typedef struct {
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 	/* stuff for DIO */
 	struct {
@@ -264,8 +264,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmmio_attach(comedi_device * dev, comedi_devconfig * it);
-static int pcmmio_detach(comedi_device * dev);
+static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcmmio_detach(struct comedi_device * dev);
 
 static comedi_driver driver = {
       driver_name:"pcmmio",
@@ -295,24 +295,24 @@ static comedi_driver driver = {
       num_names:sizeof(pcmmio_boards) / sizeof(pcmmio_board),
 };
 
-static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
-static void pcmmio_stop_intr(comedi_device *, comedi_subdevice *);
-static int pcmmio_cancel(comedi_device * dev, comedi_subdevice * s);
-static int pcmmio_cmd(comedi_device * dev, comedi_subdevice * s);
-static int pcmmio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static void pcmmio_stop_intr(struct comedi_device *, comedi_subdevice *);
+static int pcmmio_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int pcmmio_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int pcmmio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
-static void init_asics(comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
-static void switch_page(comedi_device * dev, int asic, int page);
+static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(struct comedi_device * dev, int asic, int page);
 #ifdef notused
-static void lock_port(comedi_device * dev, int asic, int port);
-static void unlock_port(comedi_device * dev, int asic, int port);
+static void lock_port(struct comedi_device * dev, int asic, int port);
+static void unlock_port(struct comedi_device * dev, int asic, int port);
 #endif
 
 /*
@@ -321,7 +321,7 @@ static void unlock_port(comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmmio_attach(comedi_device * dev, comedi_devconfig * it)
+static int pcmmio_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
@@ -526,7 +526,7 @@ static int pcmmio_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pcmmio_detach(comedi_device * dev)
+static int pcmmio_detach(struct comedi_device * dev)
 {
 	int i;
 
@@ -550,7 +550,7 @@ static int pcmmio_detach(comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
@@ -624,7 +624,7 @@ static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int pcmmio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
@@ -685,7 +685,7 @@ static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-static void init_asics(comedi_device * dev)
+static void init_asics(struct comedi_device * dev)
 {				/* sets up an
 				   ASIC chip to defaults */
 	int asic;
@@ -722,7 +722,7 @@ static void init_asics(comedi_device * dev)
 	}
 }
 
-static void switch_page(comedi_device * dev, int asic, int page)
+static void switch_page(struct comedi_device * dev, int asic, int page)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -738,7 +738,7 @@ static void switch_page(comedi_device * dev, int asic, int page)
 }
 
 #ifdef notused
-static void lock_port(comedi_device * dev, int asic, int port)
+static void lock_port(struct comedi_device * dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -752,7 +752,7 @@ static void lock_port(comedi_device * dev, int asic, int port)
 	return;
 }
 
-static void unlock_port(comedi_device * dev, int asic, int port)
+static void unlock_port(struct comedi_device * dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->dio_num_asics)
 		return;		/* paranoia */
@@ -768,7 +768,7 @@ static void unlock_port(comedi_device * dev, int asic, int port)
 static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 {
 	int asic, got1 = 0;
-	comedi_device *dev = (comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *) d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -917,7 +917,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pcmmio_stop_intr(comedi_device * dev, comedi_subdevice * s)
+static void pcmmio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int nports, firstport, asic, port;
 
@@ -936,7 +936,7 @@ static void pcmmio_stop_intr(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pcmmio_start_intr(comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -995,7 +995,7 @@ static int pcmmio_start_intr(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcmmio_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1011,7 +1011,7 @@ static int pcmmio_cancel(comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+pcmmio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -1037,7 +1037,7 @@ pcmmio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmmio_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pcmmio_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -1082,7 +1082,7 @@ static int pcmmio_cmd(comedi_device * dev, comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmmio_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pcmmio_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1194,7 +1194,7 @@ static int adc_wait_ready(unsigned long iobase)
 }
 
 /* All this is for AI and AO */
-static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -1258,7 +1258,7 @@ static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;
@@ -1288,7 +1288,7 @@ static int wait_dac_ready(unsigned long iobase)
 	return 1;
 }
 
-static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5673b664ca20..739959cd2cfd 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -140,14 +140,14 @@ Configuration Options:
 #define PAGE_INT_ID 3
 
 typedef int (*comedi_insn_fn_t) (comedi_device *, comedi_subdevice *,
-	comedi_insn *, lsampl_t *);
+	comedi_insn *, unsigned int *);
 
 static int ai_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
-	lsampl_t *);
+	unsigned int *);
 static int ao_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
-	lsampl_t *);
+	unsigned int *);
 static int ao_winsn(comedi_device *, comedi_subdevice *, comedi_insn *,
-	lsampl_t *);
+	unsigned int *);
 
 /*
  * Board descriptions for two imaginary boards.  Describing the
@@ -230,7 +230,7 @@ typedef struct {
 			} intr;
 		} dio;
 		struct {
-			lsampl_t shadow_samples[8];	/* the last lsampl_t data written */
+			unsigned int shadow_samples[8];	/* the last unsigned int data written */
 		} ao;
 	};
 } pcmmio_subdev_private;
@@ -296,9 +296,9 @@ static comedi_driver driver = {
 };
 
 static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
 static void pcmmio_stop_intr(comedi_device *, comedi_subdevice *);
@@ -551,7 +551,7 @@ static int pcmmio_detach(comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -625,7 +625,7 @@ static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;
@@ -842,7 +842,7 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 							if (mytrig & subpriv->
 								dio.intr.
 								enabled_mask) {
-								lsampl_t val =
+								unsigned int val =
 									0;
 								unsigned int n,
 									ch, len;
@@ -859,10 +859,10 @@ static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((sampl_t *) & val)[0])
+								if (comedi_buf_put(s->async, ((short *) & val)[0])
 									&&
 									comedi_buf_put
-									(s->async, ((sampl_t *) & val)[1])) {
+									(s->async, ((short *) & val)[1])) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
@@ -1195,7 +1195,7 @@ static int adc_wait_ready(unsigned long iobase)
 
 /* All this is for AI and AO */
 static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	unsigned long iobase = subpriv->iobase;
@@ -1218,7 +1218,7 @@ static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 			CR_AREF(insn->chanspec);
 		unsigned char command_byte = 0;
 		unsigned iooffset = 0;
-		sampl_t sample, adc_adjust = 0;
+		short sample, adc_adjust = 0;
 
 		if (chan > 7)
 			chan -= 8, iooffset = 4;	/* use the second dword for channels > 7 */
@@ -1259,7 +1259,7 @@ static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	for (n = 0; n < insn->n; n++) {
@@ -1289,7 +1289,7 @@ static int wait_dac_ready(unsigned long iobase)
 }
 
 static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n;
 	unsigned iobase = subpriv->iobase, iooffset = 0;

commit 6baef150380d561a4d695a6be4fc509821c23611
Author: Calin Culianu <calin@ajvar.org>
Date:   Thu Feb 19 09:13:10 2009 -0800

    Staging: comedi: add pcmmio and pcmuio drivers
    
    Drivers for Winsystems PC-104 based multifunction IO board and 48
    channel and 98 channel dio boards
    
    From: Calin Culianu <calin@ajvar.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
new file mode 100644
index 000000000000..5673b664ca20
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -0,0 +1,1333 @@
+/*
+    comedi/drivers/pcmmio.c
+    Driver for Winsystems PC-104 based multifunction IO board.
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2007 Calin A. Culianu <calin@ajvar.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+/*
+Driver: pcmmio
+Description: A driver for the PCM-MIO multifunction board
+Devices: [Winsystems] PCM-MIO (pcmmio)
+Author: Calin Culianu <calin@ajvar.org>
+Updated: Wed, May 16 2007 16:21:10 -0500
+Status: works
+
+A driver for the relatively new PCM-MIO multifunction board from
+Winsystems.  This board is a PC-104 based I/O board.  It contains
+four subdevices:
+  subdevice 0 - 16 channels of 16-bit AI
+  subdevice 1 - 8 channels of 16-bit AO
+  subdevice 2 - first 24 channels of the 48 channel of DIO (with edge-triggered interrupt support)
+  subdevice 3 - last 24 channels of the 48 channel DIO (no interrupt support for this bank of channels)
+
+  Some notes:
+
+  Synchronous reads and writes are the only things implemented for AI and AO,
+  even though the hardware itself can do streaming acquisition, etc.  Anyone
+  want to add asynchronous I/O for AI/AO as a feature?  Be my guest...
+
+  Asynchronous I/O for the DIO subdevices *is* implemented, however!  They are
+  basically edge-triggered interrupts for any configuration of the first
+  24 DIO-lines.
+
+  Also note that this interrupt support is untested.
+
+  A few words about edge-detection IRQ support (commands on DIO):
+
+  * To use edge-detection IRQ support for the DIO subdevice, pass the IRQ
+    of the board to the comedi_config command.  The board IRQ is not jumpered
+    but rather configured through software, so any IRQ from 1-15 is OK.
+
+  * Due to the genericity of the comedi API, you need to create a special
+    comedi_command in order to use edge-triggered interrupts for DIO.
+
+  * Use comedi_commands with TRIG_NOW.  Your callback will be called each
+    time an edge is detected on the specified DIO line(s), and the data
+    values will be two sample_t's, which should be concatenated to form
+    one 32-bit unsigned int.  This value is the mask of channels that had
+    edges detected from your channel list.  Note that the bits positions
+    in the mask correspond to positions in your chanlist when you
+    specified the command and *not* channel id's!
+
+ *  To set the polarity of the edge-detection interrupts pass a nonzero value
+    for either CR_RANGE or CR_AREF for edge-up polarity, or a zero
+    value for both CR_RANGE and CR_AREF if you want edge-down polarity.
+
+Configuration Options:
+  [0] - I/O port base address
+  [1] - IRQ (optional -- for edge-detect interrupt support only, leave out if you don't need this feature)
+*/
+
+#include "../comedidev.h"
+#include <linux/pci.h>		/* for PCI devices */
+
+#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
+
+/* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
+#define CHANS_PER_PORT   8
+#define PORTS_PER_ASIC   6
+#define INTR_PORTS_PER_ASIC   3
+#define MAX_CHANS_PER_SUBDEV 24	/* number of channels per comedi subdevice */
+#define PORTS_PER_SUBDEV (MAX_CHANS_PER_SUBDEV/CHANS_PER_PORT)
+#define CHANS_PER_ASIC (CHANS_PER_PORT*PORTS_PER_ASIC)
+#define INTR_CHANS_PER_ASIC 24
+#define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
+#define MAX_DIO_CHANS   (PORTS_PER_ASIC*1*CHANS_PER_PORT)
+#define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
+#define SDEV_NO ((int)(s - dev->subdevices))
+#define CALC_N_DIO_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
+/* IO Memory sizes */
+#define ASIC_IOSIZE (0x0B)
+#define PCMMIO48_IOSIZE ASIC_IOSIZE
+
+/* Some offsets - these are all in the 16byte IO memory offset from
+   the base address.  Note that there is a paging scheme to swap out
+   offsets 0x8-0xA using the PAGELOCK register.  See the table below.
+
+  Register(s)       Pages        R/W?        Description
+  --------------------------------------------------------------
+  REG_PORTx         All          R/W         Read/Write/Configure IO
+  REG_INT_PENDING   All          ReadOnly    Quickly see which INT_IDx has int.
+  REG_PAGELOCK      All          WriteOnly   Select a page
+  REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
+  REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect. int.
+  REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
+ */
+#define REG_PORT0 0x0
+#define REG_PORT1 0x1
+#define REG_PORT2 0x2
+#define REG_PORT3 0x3
+#define REG_PORT4 0x4
+#define REG_PORT5 0x5
+#define REG_INT_PENDING 0x6
+#define REG_PAGELOCK 0x7	/* page selector register, upper 2 bits select a page
+				   and bits 0-5 are used to 'lock down' a particular
+				   port above to make it readonly.  */
+#define REG_POL0 0x8
+#define REG_POL1 0x9
+#define REG_POL2 0xA
+#define REG_ENAB0 0x8
+#define REG_ENAB1 0x9
+#define REG_ENAB2 0xA
+#define REG_INT_ID0 0x8
+#define REG_INT_ID1 0x9
+#define REG_INT_ID2 0xA
+
+#define NUM_PAGED_REGS 3
+#define NUM_PAGES 4
+#define FIRST_PAGED_REG 0x8
+#define REG_PAGE_BITOFFSET 6
+#define REG_LOCK_BITOFFSET 0
+#define REG_PAGE_MASK (~((0x1<<REG_PAGE_BITOFFSET)-1))
+#define REG_LOCK_MASK ~(REG_PAGE_MASK)
+#define PAGE_POL 1
+#define PAGE_ENAB 2
+#define PAGE_INT_ID 3
+
+typedef int (*comedi_insn_fn_t) (comedi_device *, comedi_subdevice *,
+	comedi_insn *, lsampl_t *);
+
+static int ai_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+	lsampl_t *);
+static int ao_rinsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+	lsampl_t *);
+static int ao_winsn(comedi_device *, comedi_subdevice *, comedi_insn *,
+	lsampl_t *);
+
+/*
+ * Board descriptions for two imaginary boards.  Describing the
+ * boards in this way is optional, and completely driver-dependent.
+ * Some drivers use arrays such as this, other do not.
+ */
+typedef struct pcmmio_board_struct {
+	const char *name;
+	const int dio_num_asics;
+	const int dio_num_ports;
+	const int total_iosize;
+	const int ai_bits;
+	const int ao_bits;
+	const int n_ai_chans;
+	const int n_ao_chans;
+	const comedi_lrange *ai_range_table, *ao_range_table;
+	comedi_insn_fn_t ai_rinsn, ao_rinsn, ao_winsn;
+} pcmmio_board;
+
+static const comedi_lrange ranges_ai =
+	{ 4, {RANGE(-5., 5.), RANGE(-10., 10.), RANGE(0., 5.), RANGE(0.,
+		10.)}
+};
+
+static const comedi_lrange ranges_ao =
+	{ 6, {RANGE(0., 5.), RANGE(0., 10.), RANGE(-5., 5.), RANGE(-10., 10.),
+	RANGE(-2.5, 2.5), RANGE(-2.5, 7.5)}
+};
+
+static const pcmmio_board pcmmio_boards[] = {
+	{
+	      name:	"pcmmio",
+	      dio_num_asics:1,
+	      dio_num_ports:6,
+	      total_iosize:32,
+	      ai_bits:	16,
+	      ao_bits:	16,
+	      n_ai_chans:16,
+	      n_ao_chans:8,
+	      ai_range_table:&ranges_ai,
+	      ao_range_table:&ranges_ao,
+	      ai_rinsn:ai_rinsn,
+	      ao_rinsn:ao_rinsn,
+      ao_winsn:ao_winsn},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const pcmmio_board *)dev->board_ptr)
+
+/* this structure is for data unique to this subdevice.  */
+typedef struct {
+
+	union {
+		/* for DIO: mapping of halfwords (bytes) in port/chanarray to iobase */
+		unsigned long iobases[PORTS_PER_SUBDEV];
+
+		/* for AI/AO */
+		unsigned long iobase;
+	};
+	union {
+		struct {
+
+			/* The below is only used for intr subdevices */
+			struct {
+				int asic;	/* if non-negative, this subdev has an interrupt asic */
+				int first_chan;	/* if nonnegative, the first channel id for
+						   interrupts. */
+				int num_asic_chans;	/* the number of asic channels in this subdev
+							   that have interrutps */
+				int asic_chan;	/* if nonnegative, the first channel id with
+						   respect to the asic that has interrupts */
+				int enabled_mask;	/* subdev-relative channel mask for channels
+							   we are interested in */
+				int active;
+				int stop_count;
+				int continuous;
+				spinlock_t spinlock;
+			} intr;
+		} dio;
+		struct {
+			lsampl_t shadow_samples[8];	/* the last lsampl_t data written */
+		} ao;
+	};
+} pcmmio_subdev_private;
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+	/* stuff for DIO */
+	struct {
+		unsigned char pagelock;	/* current page and lock */
+		unsigned char pol[NUM_PAGED_REGS];	/* shadow of POLx registers */
+		unsigned char enab[NUM_PAGED_REGS];	/* shadow of ENABx registers */
+		int num;
+		unsigned long iobase;
+		unsigned int irq;
+		spinlock_t spinlock;
+	} asics[MAX_ASICS];
+	pcmmio_subdev_private *sprivs;
+} pcmmio_private;
+
+/*
+ * most drivers define the following macro to make it easy to
+ * access the private structure.
+ */
+#define devpriv ((pcmmio_private *)dev->private)
+#define subpriv ((pcmmio_subdev_private *)s->private)
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int pcmmio_attach(comedi_device * dev, comedi_devconfig * it);
+static int pcmmio_detach(comedi_device * dev);
+
+static comedi_driver driver = {
+      driver_name:"pcmmio",
+      module:THIS_MODULE,
+      attach:pcmmio_attach,
+      detach:pcmmio_detach,
+/* It is not necessary to implement the following members if you are
+ * writing a driver for a ISA PnP or PCI card */
+	/* Most drivers will support multiple types of boards by
+	 * having an array of board structures.  These were defined
+	 * in pcmmio_boards[] above.  Note that the element 'name'
+	 * was first in the structure -- Comedi uses this fact to
+	 * extract the name of the board without knowing any details
+	 * about the structure except for its length.
+	 * When a device is attached (by comedi_config), the name
+	 * of the device is given to Comedi, and Comedi tries to
+	 * match it by going through the list of board names.  If
+	 * there is a match, the address of the pointer is put
+	 * into dev->board_ptr and driver->attach() is called.
+	 *
+	 * Note that these are not necessary if you can determine
+	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
+	 * devices are such boards.
+	 */
+      board_name:&pcmmio_boards[0].name,
+      offset:sizeof(pcmmio_board),
+      num_names:sizeof(pcmmio_boards) / sizeof(pcmmio_board),
+};
+
+static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG);
+static void pcmmio_stop_intr(comedi_device *, comedi_subdevice *);
+static int pcmmio_cancel(comedi_device * dev, comedi_subdevice * s);
+static int pcmmio_cmd(comedi_device * dev, comedi_subdevice * s);
+static int pcmmio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+
+/* some helper functions to deal with specifics of this device's registers */
+static void init_asics(comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(comedi_device * dev, int asic, int page);
+#ifdef notused
+static void lock_port(comedi_device * dev, int asic, int port);
+static void unlock_port(comedi_device * dev, int asic, int port);
+#endif
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int pcmmio_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	int sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,
+		thisasic_chanct = 0;
+	unsigned long iobase;
+	unsigned int irq[MAX_ASICS];
+
+	iobase = it->options[0];
+	irq[0] = it->options[1];
+
+	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
+		iobase);
+
+	dev->iobase = iobase;
+
+	if (!iobase || !request_region(iobase,
+			thisboard->total_iosize, driver.driver_name)) {
+		printk("I/O port conflict\n");
+		return -EIO;
+	}
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(pcmmio_private)) < 0) {
+		printk("cannot allocate private data structure\n");
+		return -ENOMEM;
+	}
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		devpriv->asics[asic].num = asic;
+		devpriv->asics[asic].iobase =
+			dev->iobase + 16 + asic * ASIC_IOSIZE;
+		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
+						   this function when we
+						   comedi_request_irqs */
+		spin_lock_init(&devpriv->asics[asic].spinlock);
+	}
+
+	chans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;
+	n_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);
+	n_subdevs = n_dio_subdevs + 2;
+	devpriv->sprivs =
+		kcalloc(n_subdevs, sizeof(pcmmio_subdev_private), GFP_KERNEL);
+	if (!devpriv->sprivs) {
+		printk("cannot allocate subdevice private data structures\n");
+		return -ENOMEM;
+	}
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 *
+	 * Allocate 1 AI + 1 AO + 2 DIO subdevs (24 lines per DIO)
+	 */
+	if (alloc_subdevices(dev, n_subdevs) < 0) {
+		printk("cannot allocate subdevice data structures\n");
+		return -ENOMEM;
+	}
+
+	/* First, AI */
+	sdev_no = 0;
+	s = dev->subdevices + sdev_no;
+	s->private = devpriv->sprivs + sdev_no;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ai_range_table;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
+	s->type = COMEDI_SUBD_AI;
+	s->n_chan = thisboard->n_ai_chans;
+	s->len_chanlist = s->n_chan;
+	s->insn_read = thisboard->ai_rinsn;
+	subpriv->iobase = dev->iobase + 0;
+	/* initialize the resource enable register by clearing it */
+	outb(0, subpriv->iobase + 3);
+	outb(0, subpriv->iobase + 4 + 3);
+
+	/* Next, AO */
+	++sdev_no;
+	s = dev->subdevices + sdev_no;
+	s->private = devpriv->sprivs + sdev_no;
+	s->maxdata = (1 << thisboard->ao_bits) - 1;
+	s->range_table = thisboard->ao_range_table;
+	s->subdev_flags = SDF_READABLE;
+	s->type = COMEDI_SUBD_AO;
+	s->n_chan = thisboard->n_ao_chans;
+	s->len_chanlist = s->n_chan;
+	s->insn_read = thisboard->ao_rinsn;
+	s->insn_write = thisboard->ao_winsn;
+	subpriv->iobase = dev->iobase + 8;
+	/* initialize the resource enable register by clearing it */
+	outb(0, subpriv->iobase + 3);
+	outb(0, subpriv->iobase + 4 + 3);
+
+	++sdev_no;
+	port = 0;
+	asic = 0;
+	for (; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
+		int byte_no;
+
+		s = dev->subdevices + sdev_no;
+		s->private = devpriv->sprivs + sdev_no;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->type = COMEDI_SUBD_DIO;
+		s->insn_bits = pcmmio_dio_insn_bits;
+		s->insn_config = pcmmio_dio_insn_config;
+		s->n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		subpriv->dio.intr.asic = -1;
+		subpriv->dio.intr.first_chan = -1;
+		subpriv->dio.intr.asic_chan = -1;
+		subpriv->dio.intr.num_asic_chans = -1;
+		subpriv->dio.intr.active = 0;
+		s->len_chanlist = 1;
+
+		/* save the ioport address for each 'port' of 8 channels in the
+		   subdevice */
+		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
+			if (port >= PORTS_PER_ASIC) {
+				port = 0;
+				++asic;
+				thisasic_chanct = 0;
+			}
+			subpriv->iobases[byte_no] =
+				devpriv->asics[asic].iobase + port;
+
+			if (thisasic_chanct <
+				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+				&& subpriv->dio.intr.asic < 0) {
+				/* this is an interrupt subdevice, so setup the struct */
+				subpriv->dio.intr.asic = asic;
+				subpriv->dio.intr.active = 0;
+				subpriv->dio.intr.stop_count = 0;
+				subpriv->dio.intr.first_chan = byte_no * 8;
+				subpriv->dio.intr.asic_chan = thisasic_chanct;
+				subpriv->dio.intr.num_asic_chans =
+					s->n_chan -
+					subpriv->dio.intr.first_chan;
+				s->cancel = pcmmio_cancel;
+				s->do_cmd = pcmmio_cmd;
+				s->do_cmdtest = pcmmio_cmdtest;
+				s->len_chanlist =
+					subpriv->dio.intr.num_asic_chans;
+			}
+			thisasic_chanct += CHANS_PER_PORT;
+		}
+		spin_lock_init(&subpriv->dio.intr.spinlock);
+
+		chans_left -= s->n_chan;
+
+		if (!chans_left) {
+			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
+			port = 0;
+		}
+
+	}
+
+	init_asics(dev);	/* clear out all the registers, basically */
+
+	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
+		if (irq[asic]
+			&& comedi_request_irq(irq[asic], interrupt_pcmmio,
+				IRQF_SHARED, thisboard->name, dev)) {
+			int i;
+			/* unroll the allocated irqs.. */
+			for (i = asic - 1; i >= 0; --i) {
+				comedi_free_irq(irq[i], dev);
+				devpriv->asics[i].irq = irq[i] = 0;
+			}
+			irq[asic] = 0;
+		}
+		devpriv->asics[asic].irq = irq[asic];
+	}
+
+	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
+				   irqs.. */
+
+	if (irq[0]) {
+		printk("irq: %u ", irq[0]);
+		if (irq[1] && thisboard->dio_num_asics == 2)
+			printk("second ASIC irq: %u ", irq[1]);
+	} else {
+		printk("(IRQ mode disabled) ");
+	}
+
+	printk("attached\n");
+
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int pcmmio_detach(comedi_device * dev)
+{
+	int i;
+
+	printk("comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	if (dev->iobase)
+		release_region(dev->iobase, thisboard->total_iosize);
+
+	for (i = 0; i < MAX_ASICS; ++i) {
+		if (devpriv && devpriv->asics[i].irq)
+			comedi_free_irq(devpriv->asics[i].irq, dev);
+	}
+
+	if (devpriv && devpriv->sprivs)
+		kfree(devpriv->sprivs);
+
+	return 0;
+}
+
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The
+ * comedi core can convert between insn_bits and insn_read/write */
+static int pcmmio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int byte_no;
+	if (insn->n != 2)
+		return -EINVAL;
+
+	/* NOTE:
+	   reading a 0 means this channel was high
+	   writine a 0 sets the channel high
+	   reading a 1 means this channel was low
+	   writing a 1 means set this channel low
+
+	   Therefore everything is always inverted. */
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+
+#ifdef DAMMIT_ITS_BROKEN
+	/* DEBUG */
+	printk("write mask: %08x  data: %08x\n", data[0], data[1]);
+#endif
+
+	s->state = 0;
+
+	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
+		/* address of 8-bit port */
+		unsigned long ioaddr = subpriv->iobases[byte_no],
+			/* bit offset of port in 32-bit doubleword */
+			offset = byte_no * 8;
+		/* this 8-bit port's data */
+		unsigned char byte = 0,
+			/* The write mask for this port (if any) */
+			write_mask_byte = (data[0] >> offset) & 0xff,
+			/* The data byte for this port */
+			data_byte = (data[1] >> offset) & 0xff;
+
+		byte = inb(ioaddr);	/* read all 8-bits for this port */
+
+#ifdef DAMMIT_ITS_BROKEN
+		/* DEBUG */
+		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+#endif
+
+		if (write_mask_byte) {
+			/* this byte has some write_bits -- so set the output lines */
+			byte &= ~write_mask_byte;	/* clear bits for write mask */
+			byte |= ~data_byte & write_mask_byte;	/* set to inverted data_byte */
+			/* Write out the new digital output state */
+			outb(byte, ioaddr);
+		}
+#ifdef DAMMIT_ITS_BROKEN
+		/* DEBUG */
+		printk("data_out_byte %02x\n", (unsigned)byte);
+#endif
+		/* save the digital input lines for this byte.. */
+		s->state |= ((unsigned int)byte) << offset;
+	}
+
+	/* now return the DIO lines to data[1] - note they came inverted! */
+	data[1] = ~s->state;
+
+#ifdef DAMMIT_ITS_BROKEN
+	/* DEBUG */
+	printk("s->state %08x data_out %08x\n", s->state, data[1]);
+#endif
+
+	return 2;
+}
+
+/* The input or output configuration of each digital line is
+ * configured by a special insn_config instruction.  chanspec
+ * contains the channel to be changed, and data[0] contains the
+ * value COMEDI_INPUT or COMEDI_OUTPUT. */
+static int pcmmio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
+		chan % 8;
+	unsigned long ioaddr;
+	unsigned char byte;
+
+	/* Compute ioaddr for this channel */
+	ioaddr = subpriv->iobases[byte_no];
+
+	/* NOTE:
+	   writing a 0 an IO channel's bit sets the channel to INPUT
+	   and pulls the line high as well
+
+	   writing a 1 to an IO channel's  bit pulls the line low
+
+	   All channels are implicitly always in OUTPUT mode -- but when
+	   they are high they can be considered to be in INPUT mode..
+
+	   Thus, we only force channels low if the config request was INPUT,
+	   otherwise we do nothing to the hardware.    */
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		/* save to io_bits -- don't actually do anything since
+		   all input channels are also output channels... */
+		s->io_bits |= 1 << chan;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		/* write a 0 to the actual register representing the channel
+		   to set it to 'input'.  0 means "float high". */
+		byte = inb(ioaddr);
+		byte &= ~(1 << bit_no);
+				/**< set input channel to '0' */
+
+		/* write out byte -- this is the only time we actually affect the
+		   hardware as all channels are implicitly output -- but input
+		   channels are set to float-high */
+		outb(byte, ioaddr);
+
+		/* save to io_bits */
+		s->io_bits &= ~(1 << chan);
+		break;
+
+	case INSN_CONFIG_DIO_QUERY:
+		/* retreive from shadow register */
+		data[1] =
+			(s->
+			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+		break;
+
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return insn->n;
+}
+
+static void init_asics(comedi_device * dev)
+{				/* sets up an
+				   ASIC chip to defaults */
+	int asic;
+
+	for (asic = 0; asic < thisboard->dio_num_asics; ++asic) {
+		int port, page;
+		unsigned long baseaddr = devpriv->asics[asic].iobase;
+
+		switch_page(dev, asic, 0);	/* switch back to page 0 */
+
+		/* first, clear all the DIO port bits */
+		for (port = 0; port < PORTS_PER_ASIC; ++port)
+			outb(0, baseaddr + REG_PORT0 + port);
+
+		/* Next, clear all the paged registers for each page */
+		for (page = 1; page < NUM_PAGES; ++page) {
+			int reg;
+			/* now clear all the paged registers */
+			switch_page(dev, asic, page);
+			for (reg = FIRST_PAGED_REG;
+				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+				outb(0, baseaddr + reg);
+		}
+
+		/* DEBUG  set rising edge interrupts on port0 of both asics */
+		/*switch_page(dev, asic, PAGE_POL);
+		   outb(0xff, baseaddr + REG_POL0);
+		   switch_page(dev, asic, PAGE_ENAB);
+		   outb(0xff, baseaddr + REG_ENAB0); */
+		/* END DEBUG */
+
+		switch_page(dev, asic, 0);	/* switch back to default page 0 */
+
+	}
+}
+
+static void switch_page(comedi_device * dev, int asic, int page)
+{
+	if (asic < 0 || asic >= thisboard->dio_num_asics)
+		return;		/* paranoia */
+	if (page < 0 || page >= NUM_PAGES)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
+	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
+
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		devpriv->asics[asic].iobase + REG_PAGELOCK);
+}
+
+#ifdef notused
+static void lock_port(comedi_device * dev, int asic, int port)
+{
+	if (asic < 0 || asic >= thisboard->dio_num_asics)
+		return;		/* paranoia */
+	if (port < 0 || port >= PORTS_PER_ASIC)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock |= 0x1 << port;
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		devpriv->asics[asic].iobase + REG_PAGELOCK);
+	return;
+}
+
+static void unlock_port(comedi_device * dev, int asic, int port)
+{
+	if (asic < 0 || asic >= thisboard->dio_num_asics)
+		return;		/* paranoia */
+	if (port < 0 || port >= PORTS_PER_ASIC)
+		return;		/* more paranoia */
+	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		devpriv->asics[asic].iobase + REG_PAGELOCK);
+}
+#endif /* notused */
+
+static irqreturn_t interrupt_pcmmio(int irq, void *d PT_REGS_ARG)
+{
+	int asic, got1 = 0;
+	comedi_device *dev = (comedi_device *) d;
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		if (irq == devpriv->asics[asic].irq) {
+			unsigned long flags;
+			unsigned triggered = 0;
+			unsigned long iobase = devpriv->asics[asic].iobase;
+			/* it is an interrupt for ASIC #asic */
+			unsigned char int_pend;
+
+			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+				flags);
+
+			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
+
+			if (int_pend) {
+				int port;
+				for (port = 0; port < INTR_PORTS_PER_ASIC;
+					++port) {
+					if (int_pend & (0x1 << port)) {
+						unsigned char
+							io_lines_with_edges = 0;
+						switch_page(dev, asic,
+							PAGE_INT_ID);
+						io_lines_with_edges =
+							inb(iobase +
+							REG_INT_ID0 + port);
+
+						if (io_lines_with_edges)
+							/* clear pending interrupt */
+							outb(0, iobase +
+								REG_INT_ID0 +
+								port);
+
+						triggered |=
+							io_lines_with_edges <<
+							port * 8;
+					}
+				}
+
+				++got1;
+			}
+
+			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
+				spinlock, flags);
+
+			if (triggered) {
+				comedi_subdevice *s;
+				/* TODO here: dispatch io lines to subdevs with commands.. */
+				printk("PCMMIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				for (s = dev->subdevices + 2;
+					s < dev->subdevices + dev->n_subdevices;
+					++s) {
+					if (subpriv->dio.intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
+						unsigned long flags;
+						unsigned oldevents;
+
+						comedi_spin_lock_irqsave
+							(&subpriv->dio.intr.
+							spinlock, flags);
+
+						oldevents = s->async->events;
+
+						if (subpriv->dio.intr.active) {
+							unsigned mytrig =
+								((triggered >>
+									subpriv->
+									dio.
+									intr.
+									asic_chan)
+								& ((0x1 << subpriv->dio.intr.num_asic_chans) - 1)) << subpriv->dio.intr.first_chan;
+							if (mytrig & subpriv->
+								dio.intr.
+								enabled_mask) {
+								lsampl_t val =
+									0;
+								unsigned int n,
+									ch, len;
+
+								len = s->async->
+									cmd.
+									chanlist_len;
+								for (n = 0;
+									n < len;
+									n++) {
+									ch = CR_CHAN(s->async->cmd.chanlist[n]);
+									if (mytrig & (1U << ch)) {
+										val |= (1U << n);
+									}
+								}
+								/* Write the scan to the buffer. */
+								if (comedi_buf_put(s->async, ((sampl_t *) & val)[0])
+									&&
+									comedi_buf_put
+									(s->async, ((sampl_t *) & val)[1])) {
+									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+								} else {
+									/* Overflow! Stop acquisition!! */
+									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+									pcmmio_stop_intr
+										(dev,
+										s);
+								}
+
+								/* Check for end of acquisition. */
+								if (!subpriv->
+									dio.
+									intr.
+									continuous)
+								{
+									/* stop_src == TRIG_COUNT */
+									if (subpriv->dio.intr.stop_count > 0) {
+										subpriv->
+											dio.
+											intr.
+											stop_count--;
+										if (subpriv->dio.intr.stop_count == 0) {
+											s->async->events |= COMEDI_CB_EOA;
+											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+											pcmmio_stop_intr
+												(dev,
+												s);
+										}
+									}
+								}
+							}
+						}
+
+						comedi_spin_unlock_irqrestore
+							(&subpriv->dio.intr.
+							spinlock, flags);
+
+						if (oldevents !=
+							s->async->events) {
+							comedi_event(dev, s);
+						}
+
+					}
+
+				}
+			}
+
+		}
+	}
+	if (!got1)
+		return IRQ_NONE;	/* interrupt from other source */
+	return IRQ_HANDLED;
+}
+
+static void pcmmio_stop_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	int nports, firstport, asic, port;
+
+	if ((asic = subpriv->dio.intr.asic) < 0)
+		return;		/* not an interrupt subdev */
+
+	subpriv->dio.intr.enabled_mask = 0;
+	subpriv->dio.intr.active = 0;
+	s->async->inttrig = 0;
+	nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
+	firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
+	switch_page(dev, asic, PAGE_ENAB);
+	for (port = firstport; port < firstport + nports; ++port) {
+		/* disable all intrs for this subdev.. */
+		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+	}
+}
+
+static int pcmmio_start_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	if (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {
+		/* An empty acquisition! */
+		s->async->events |= COMEDI_CB_EOA;
+		subpriv->dio.intr.active = 0;
+		return 1;
+	} else {
+		unsigned bits = 0, pol_bits = 0, n;
+		int nports, firstport, asic, port;
+		comedi_cmd *cmd = &s->async->cmd;
+
+		if ((asic = subpriv->dio.intr.asic) < 0)
+			return 1;	/* not an interrupt
+					   subdev */
+		subpriv->dio.intr.enabled_mask = 0;
+		subpriv->dio.intr.active = 1;
+		nports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;
+		firstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;
+		if (cmd->chanlist) {
+			for (n = 0; n < cmd->chanlist_len; n++) {
+				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
+				pol_bits |= (CR_AREF(cmd->chanlist[n])
+					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
+					<< CR_CHAN(cmd->chanlist[n]);
+			}
+		}
+		bits &= ((0x1 << subpriv->dio.intr.num_asic_chans) -
+			1) << subpriv->dio.intr.first_chan;
+		subpriv->dio.intr.enabled_mask = bits;
+
+		{		/* the below code configures the board to use a specific IRQ from 0-15. */
+			unsigned char b;
+			/* set resource enable register to enable IRQ operation */
+			outb(1 << 4, dev->iobase + 3);
+			/* set bits 0-3 of b to the irq number from 0-15 */
+			b = dev->irq & ((1 << 4) - 1);
+			outb(b, dev->iobase + 2);
+			/* done, we told the board what irq to use */
+		}
+
+		switch_page(dev, asic, PAGE_ENAB);
+		for (port = firstport; port < firstport + nports; ++port) {
+			unsigned enab =
+				bits >> (subpriv->dio.intr.first_chan + (port -
+					firstport) * 8) & 0xff, pol =
+				pol_bits >> (subpriv->dio.intr.first_chan +
+				(port - firstport) * 8) & 0xff;
+			/* set enab intrs for this subdev.. */
+			outb(enab,
+				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			switch_page(dev, asic, PAGE_POL);
+			outb(pol,
+				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+		}
+	}
+	return 0;
+}
+
+static int pcmmio_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	if (subpriv->dio.intr.active)
+		pcmmio_stop_intr(dev, s);
+	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+
+	return 0;
+}
+
+/*
+ * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
+ */
+static int
+pcmmio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	unsigned long flags;
+	int event = 0;
+
+	if (trignum != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	s->async->inttrig = 0;
+	if (subpriv->dio.intr.active) {
+		event = pcmmio_start_intr(dev, s);
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 1;
+}
+
+/*
+ * 'do_cmd' function for an 'INTERRUPT' subdevice.
+ */
+static int pcmmio_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+	int event = 0;
+
+	comedi_spin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);
+	subpriv->dio.intr.active = 1;
+
+	/* Set up end of acquisition. */
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		subpriv->dio.intr.continuous = 0;
+		subpriv->dio.intr.stop_count = cmd->stop_arg;
+		break;
+	default:
+		/* TRIG_NONE */
+		subpriv->dio.intr.continuous = 1;
+		subpriv->dio.intr.stop_count = 0;
+		break;
+	}
+
+	/* Set up start of acquisition. */
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		s->async->inttrig = pcmmio_inttrig_start_intr;
+		break;
+	default:
+		/* TRIG_NOW */
+		event = pcmmio_start_intr(dev, s);
+		break;
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 0;
+}
+
+/*
+ * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
+ */
+static int
+pcmmio_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= (TRIG_NOW | TRIG_INT);
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_begin_src == TRIG_EXT */
+	if (cmd->scan_begin_arg != 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+
+	/* cmd->convert_src == TRIG_NOW */
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_end_src == TRIG_COUNT */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
+}
+
+static int adc_wait_ready(unsigned long iobase)
+{
+	unsigned long retry = 100000;
+	while (retry--)
+		if (inb(iobase + 3) & 0x80)
+			return 0;
+	return 1;
+}
+
+/* All this is for AI and AO */
+static int ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	unsigned long iobase = subpriv->iobase;
+
+	/*
+	   1. write the CMD byte (to BASE+2)
+	   2. read junk lo byte (BASE+0)
+	   3. read junk hi byte (BASE+1)
+	   4. (mux settled so) write CMD byte again (BASE+2)
+	   5. read valid lo byte(BASE+0)
+	   6. read valid hi byte(BASE+1)
+
+	   Additionally note that the BASE += 4 if the channel >= 8
+	 */
+
+	/* convert n samples */
+	for (n = 0; n < insn->n; n++) {
+		unsigned chan = CR_CHAN(insn->chanspec), range =
+			CR_RANGE(insn->chanspec), aref =
+			CR_AREF(insn->chanspec);
+		unsigned char command_byte = 0;
+		unsigned iooffset = 0;
+		sampl_t sample, adc_adjust = 0;
+
+		if (chan > 7)
+			chan -= 8, iooffset = 4;	/* use the second dword for channels > 7 */
+
+		if (aref != AREF_DIFF) {
+			aref = AREF_GROUND;
+			command_byte |= 1 << 7;	/* set bit 7 to indicate single-ended */
+		}
+		if (range < 2)
+			adc_adjust = 0x8000;	/* bipolar ranges (-5,5 .. -10,10 need to be adjusted -- that is.. they need to wrap around by adding 0x8000 */
+
+		if (chan % 2) {
+			command_byte |= 1 << 6;	/* odd-numbered channels have bit 6 set */
+		}
+
+		/* select the channel, bits 4-5 == chan/2 */
+		command_byte |= ((chan / 2) & 0x3) << 4;
+
+		/* set the range, bits 2-3 */
+		command_byte |= (range & 0x3) << 2;
+
+		/* need to do this twice to make sure mux settled */
+		outb(command_byte, iobase + iooffset + 2);	/* chan/range/aref select */
+
+		adc_wait_ready(iobase + iooffset);	/* wait for the adc to say it finised the conversion */
+
+		outb(command_byte, iobase + iooffset + 2);	/* select the chan/range/aref AGAIN */
+
+		adc_wait_ready(iobase + iooffset);
+
+		sample = inb(iobase + iooffset + 0);	/* read data lo byte */
+		sample |= inb(iobase + iooffset + 1) << 8;	/* read data hi byte */
+		sample += adc_adjust;	/* adjustment .. munge data */
+		data[n] = sample;
+	}
+	/* return the number of samples read/written */
+	return n;
+}
+
+static int ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	for (n = 0; n < insn->n; n++) {
+		unsigned chan = CR_CHAN(insn->chanspec);
+		if (chan < s->n_chan)
+			data[n] = subpriv->ao.shadow_samples[chan];
+	}
+	return n;
+}
+
+static int wait_dac_ready(unsigned long iobase)
+{
+	unsigned long retry = 100000L;
+
+	/* This may seem like an absurd way to handle waiting and violates the
+	   "no busy waiting" policy. The fact is that the hardware is
+	   normally so fast that we usually only need one time through the loop
+	   anyway. The longer timeout is for rare occasions and for detecting
+	   non-existant hardware.  */
+
+	while (retry--) {
+		if (inb(iobase + 3) & 0x80)
+			return 0;
+
+	}
+	return 1;
+}
+
+static int ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n;
+	unsigned iobase = subpriv->iobase, iooffset = 0;
+
+	for (n = 0; n < insn->n; n++) {
+		unsigned chan = CR_CHAN(insn->chanspec), range =
+			CR_RANGE(insn->chanspec);
+		if (chan < s->n_chan) {
+			unsigned char command_byte = 0, range_byte =
+				range & ((1 << 4) - 1);
+			if (chan >= 4)
+				chan -= 4, iooffset += 4;
+			/* set the range.. */
+			outb(range_byte, iobase + iooffset + 0);
+			outb(0, iobase + iooffset + 1);
+
+			/* tell it to begin */
+			command_byte = (chan << 1) | 0x60;
+			outb(command_byte, iobase + iooffset + 2);
+
+			wait_dac_ready(iobase + iooffset);
+
+			outb(data[n] & 0xff, iobase + iooffset + 0);	/* low order byte */
+			outb((data[n] >> 8) & 0xff, iobase + iooffset + 1);	/* high order byte */
+			command_byte = 0x70 | (chan << 1);	/* set bit 4 of command byte to indicate data is loaded and trigger conversion */
+			/* trigger converion */
+			outb(command_byte, iobase + iooffset + 2);
+
+			wait_dac_ready(iobase + iooffset);
+
+			subpriv->ao.shadow_samples[chan] = data[n];	/* save to shadow register for ao_rinsn */
+		}
+	}
+	return n;
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver);
