commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 74a3545e2d35..743fb226e2e4 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2006 Calin A. Culianu <calin@ajvar.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8ad64f2625fe..74a3545e2d35 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * pcmuio.c
  * Comedi driver for Winsystems PC-104 based 48/96-channel DIO boards.

commit f7ede00d609d24dae6ef47d294630e81b8ce3091
Author: Nikita Eshkeev <kastolom@gmail.com>
Date:   Tue May 3 18:22:23 2016 +0300

    staging:comedi:Use unsigned int instead of unsigned
    
    This patch fixed the checkpatch.pl warning:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Nikita Eshkeev <kastolom@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7ea813022ff6..8ad64f2625fe 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -307,7 +307,7 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 
 static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
-				      unsigned triggered)
+				      unsigned int triggered)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	int asic = pcmuio_subdevice_to_asic(s);

commit 21de3b8d84dd8ec0e129c7d2909e135e8af6f58e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:33 2015 +0000

    staging: comedi: pcmuio: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 213457286031..7ea813022ff6 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -77,8 +77,6 @@
 
 #include "../comedidev.h"
 
-#include "comedi_fc.h"
-
 /*
  * Register I/O map
  *
@@ -486,19 +484,19 @@ static int pcmuio_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -507,15 +505,16 @@ static int pcmuio_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 1a4a1f589a56..213457286031 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -568,7 +568,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		} else if (it->options[2]) {
 			/* request the irq for the 2nd asic */
 			ret = request_irq(it->options[2], pcmuio_interrupt, 0,
-					dev->board_name, dev);
+					  dev->board_name, dev);
 			if (ret == 0)
 				devpriv->irq2 = it->options[2];
 		}

commit 9949595c0da61ff2aecc90c3a8e924848e6ac03b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:15 2015 -0700

    staging: comedi: drivers/*.c: fix common misspellings
    
    Fix these common misspellings:
      s/dependancy/dependency
      s/occured/occurred
      s/informations/information
      s/intialize/initialize
      s/serveral/several
      s/interrups/interrupts
      s/acknowledgement/acknowledgment
      s/suppport/support
      s/writting/writing
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index a1641d981812..1a4a1f589a56 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -588,7 +588,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_bits	= pcmuio_dio_insn_bits;
 		s->insn_config	= pcmuio_dio_insn_config;
 
-		/* subdevices 0 and 2 can suppport interrupts */
+		/* subdevices 0 and 2 can support interrupts */
 		if ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {
 			/* setup the interrupt subdevice */
 			dev->read_subdev = s;

commit daea70e488bd2e2a6df6f1ba7304ed31b4bb79cb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:06 2015 +0000

    staging: comedi: pcmuio: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 0f5483b6147f..a1641d981812 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -19,8 +19,7 @@
 /*
  * Driver: pcmuio
  * Description: Winsystems PC-104 based 48/96-channel DIO boards.
- * Devices: (Winsystems) PCM-UIO48A [pcmuio48]
- *	    (Winsystems) PCM-UIO96A [pcmuio96]
+ * Devices: [Winsystems] PCM-UIO48A (pcmuio48), PCM-UIO96A (pcmuio96)
  * Author: Calin Culianu <calin@ajvar.org>
  * Updated: Fri, 13 Jan 2006 12:01:01 -0500
  * Status: works

commit b03130b649840f5a25941a7e8ae78dea6d750c85
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:02 2014 -0700

    staging: comedi: pcmuio: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'stop_count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 18c2ac28e34a..0f5483b6147f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -130,7 +130,6 @@ struct pcmuio_asic {
 	spinlock_t pagelock;	/* protects the page registers */
 	spinlock_t spinlock;	/* protects member variables */
 	unsigned int enabled_mask;
-	unsigned int stop_count;
 	unsigned int active:1;
 };
 
@@ -338,14 +337,9 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 	comedi_buf_write_samples(s, &val, 1);
 
-	/* Check for end of acquisition. */
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (chip->stop_count > 0) {
-			chip->stop_count--;
-			if (chip->stop_count == 0)
-				s->async->events |= COMEDI_CB_EOA;
-		}
-	}
+	if (cmd->stop_src == TRIG_COUNT &&
+	    s->async->scans_done >= cmd->stop_arg)
+		s->async->events |= COMEDI_CB_EOA;
 
 done:
 	spin_unlock_irqrestore(&chip->spinlock, flags);
@@ -474,8 +468,6 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	spin_lock_irqsave(&chip->spinlock, flags);
 	chip->active = 1;
 
-	chip->stop_count = cmd->stop_arg;
-
 	/* Set up start of acquisition. */
 	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmuio_inttrig_start_intr;

commit 7dd1b528c1008f65653b0bdc027a90fd24ddc2eb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:14 2014 -0700

    staging: comedi: pcmuio: use comedi_buf_write_samples()
    
    The dev->read_subdev used in this driver for async commands returns 32-bit samples
    and should have the SDF_LSAMPL subdev_flag set. It also returns the full scan with
    each sample so it should have the SDF_PACKED subdev_flag set.
    
    Add the missing subdev_flags and use comedi_buf_write_samples() to add the sample
    to the async buffer.
    
    The COMEDI_CB_BLOCK and COMEDI_CB_EOS events will be automatically handled by the
    core. Remove the unnecessary events in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 28e659889e4f..18c2ac28e34a 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -336,10 +336,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 			val |= (1 << i);
 	}
 
-	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s, val) &&
-	    comedi_buf_put(s, val >> 16))
-		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	comedi_buf_write_samples(s, &val, 1);
 
 	/* Check for end of acquisition. */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -604,7 +601,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {
 			/* setup the interrupt subdevice */
 			dev->read_subdev = s;
-			s->subdev_flags	|= SDF_CMD_READ;
+			s->subdev_flags	|= SDF_CMD_READ | SDF_LSAMPL |
+					   SDF_PACKED;
 			s->len_chanlist	= s->n_chan;
 			s->cancel	= pcmuio_cancel;
 			s->do_cmd	= pcmuio_cmd;

commit bc43ae066239c122d643f4fefac38b03221be6d1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:38 2014 -0700

    staging: comedi: pcmuio: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Also, comedi_handle_events() does nothing if no events are set so the
    local variable 'oldevents' can be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index d4fe2ec25ecf..28e659889e4f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -317,7 +317,6 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned oldevents = s->async->events;
 	unsigned int val = 0;
 	unsigned long flags;
 	unsigned int i;
@@ -339,31 +338,22 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 	/* Write the scan to the buffer. */
 	if (comedi_buf_put(s, val) &&
-	    comedi_buf_put(s, val >> 16)) {
+	    comedi_buf_put(s, val >> 16))
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-	} else {
-		/* Overflow! Stop acquisition!! */
-		/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-		pcmuio_stop_intr(dev, s);
-	}
 
 	/* Check for end of acquisition. */
 	if (cmd->stop_src == TRIG_COUNT) {
 		if (chip->stop_count > 0) {
 			chip->stop_count--;
-			if (chip->stop_count == 0) {
+			if (chip->stop_count == 0)
 				s->async->events |= COMEDI_CB_EOA;
-				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-				pcmuio_stop_intr(dev, s);
-			}
 		}
 	}
 
 done:
 	spin_unlock_irqrestore(&chip->spinlock, flags);
 
-	if (oldevents != s->async->events)
-		comedi_event(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)

commit 1e2e39effd11ca7c09cc47aff9e99d976109bbe8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:59 2014 -0700

    staging: comedi: pcmuio: return void from pcmuio_start_intr()
    
    This function always returns '0' so the comedi_event() is never done by the
    callers.
    
    Change the return type to void and remove the comedi_event() dead code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index a0d31718a096..d4fe2ec25ecf 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -403,8 +403,8 @@ static irqreturn_t pcmuio_interrupt(int irq, void *d)
 }
 
 /* chip->spinlock is already locked */
-static int pcmuio_start_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
+static void pcmuio_start_intr(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	int asic = pcmuio_subdevice_to_asic(s);
@@ -433,8 +433,6 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 	/* set pol and enab intrs for this subdev.. */
 	pcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);
 	pcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);
-
-	return 0;
 }
 
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -461,7 +459,6 @@ static int pcmuio_inttrig_start_intr(struct comedi_device *dev,
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
-	int event = 0;
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
@@ -469,13 +466,10 @@ static int pcmuio_inttrig_start_intr(struct comedi_device *dev,
 	spin_lock_irqsave(&chip->spinlock, flags);
 	s->async->inttrig = NULL;
 	if (chip->active)
-		event = pcmuio_start_intr(dev, s);
+		pcmuio_start_intr(dev, s);
 
 	spin_unlock_irqrestore(&chip->spinlock, flags);
 
-	if (event)
-		comedi_event(dev, s);
-
 	return 1;
 }
 
@@ -489,7 +483,6 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
-	int event = 0;
 
 	spin_lock_irqsave(&chip->spinlock, flags);
 	chip->active = 1;
@@ -500,13 +493,10 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmuio_inttrig_start_intr;
 	else	/* TRIG_NOW */
-		event = pcmuio_start_intr(dev, s);
+		pcmuio_start_intr(dev, s);
 
 	spin_unlock_irqrestore(&chip->spinlock, flags);
 
-	if (event)
-		comedi_event(dev, s);
-
 	return 0;
 }
 

commit 8e7fed7ed760275c3e8e73e4328751fcb8f21642
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:58 2014 -0700

    staging: comedi: pcmuio: 'stop_count' is always 'stop_arg'
    
    When the cmd->stop_src == TRIG_COUNT, the 'stop_count' is the cmd->stop_arg.
    For any other stop_src the 'stop_count' is 0, which is also the cmd->stop_arg.
    
    Simplify the 'stop_count' initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 2452775acf12..a0d31718a096 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -494,16 +494,7 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	spin_lock_irqsave(&chip->spinlock, flags);
 	chip->active = 1;
 
-	/* Set up end of acquisition. */
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		chip->stop_count = cmd->stop_arg;
-		break;
-	default:
-		/* TRIG_NONE */
-		chip->stop_count = 0;
-		break;
-	}
+	chip->stop_count = cmd->stop_arg;
 
 	/* Set up start of acquisition. */
 	if (cmd->start_src == TRIG_INT)

commit 75d46fd7816ea5a22971b05e59c356f3964754a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:57 2014 -0700

    staging: comedi: pcmuio: remove 'continuous' from private data
    
    This member of the private data is set based on the cmd->stop_src. Just use the
    cmd->stop_src directly and remove the member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index eb606639c535..2452775acf12 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -132,7 +132,6 @@ struct pcmuio_asic {
 	unsigned int enabled_mask;
 	unsigned int stop_count;
 	unsigned int active:1;
-	unsigned int continuous:1;
 };
 
 struct pcmuio_private {
@@ -349,8 +348,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	}
 
 	/* Check for end of acquisition. */
-	if (!chip->continuous) {
-		/* stop_src == TRIG_COUNT */
+	if (cmd->stop_src == TRIG_COUNT) {
 		if (chip->stop_count > 0) {
 			chip->stop_count--;
 			if (chip->stop_count == 0) {
@@ -499,12 +497,10 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* Set up end of acquisition. */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		chip->continuous = 0;
 		chip->stop_count = cmd->stop_arg;
 		break;
 	default:
 		/* TRIG_NONE */
-		chip->continuous = 1;
 		chip->stop_count = 0;
 		break;
 	}

commit 71731264847096ab2d2045601b96c9c341a6ae12
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:56 2014 -0700

    staging: comedi: pcmuio: remove "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediately generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 3aedeca32513..eb606639c535 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -416,13 +416,6 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 	unsigned int pol_bits = 0;
 	int i;
 
-	if (!chip->continuous && chip->stop_count == 0) {
-		/* An empty acquisition! */
-		s->async->events |= COMEDI_CB_EOA;
-		chip->active = 0;
-		return 1;
-	}
-
 	chip->enabled_mask = 0;
 	chip->active = 1;
 	if (cmd->chanlist) {
@@ -564,16 +557,10 @@ static int pcmuio_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-	default:
-		break;
-	}
 
 	if (err)
 		return 3;

commit 3bb221694eb419c3dcbe665cbc77c5dd70f447f8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:54 2014 +0100

    staging: comedi: pcmuio: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 1bca3fba0950..3aedeca32513 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -279,7 +279,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 
 static void pcmuio_reset(struct comedi_device *dev)
 {
-	const struct pcmuio_board *board = comedi_board(dev);
+	const struct pcmuio_board *board = dev->board_ptr;
 	int asic;
 
 	for (asic = 0; asic < board->num_asics; ++asic) {
@@ -587,7 +587,7 @@ static int pcmuio_cmdtest(struct comedi_device *dev,
 
 static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct pcmuio_board *board = comedi_board(dev);
+	const struct pcmuio_board *board = dev->board_ptr;
 	struct comedi_subdevice *s;
 	struct pcmuio_private *devpriv;
 	int ret;

commit c1f946a24042fceae52a879166e7c314a8a3415e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:02:04 2014 -0700

    staging: comedi: pcmuio: checkpatch.pl cleanup (missing blank line)
    
    Fix the checkpatch.pl warning:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 62914bb342d2..1bca3fba0950 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -333,6 +333,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
 		if (triggered & (1 << chan))
 			val |= (1 << i);
 	}

commit 3516a5ef16500aa49b4a5ea7a8a2c7147fd2fbfb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:55 2014 -0700

    staging: comedi: pcmuio: tidy up local variables in pcmuio_handle_intr_subdev()
    
    Tidy up the local variables so that the comedi_cmd is accessed as a pointer
    instead of getting to it from the comedi_subdevice pointer.
    
    Remove the local variable 'len' and use the cmd->chanlist_len directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 182b48a3e88b..62914bb342d2 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -317,7 +317,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	struct pcmuio_private *devpriv = dev->private;
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
-	unsigned int len = s->async->cmd.chanlist_len;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned oldevents = s->async->events;
 	unsigned int val = 0;
 	unsigned long flags;
@@ -331,8 +331,8 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	if (!(triggered & chip->enabled_mask))
 		goto done;
 
-	for (i = 0; i < len; i++) {
-		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 		if (triggered & (1 << chan))
 			val |= (1 << i);
 	}

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index ea45424e8410..182b48a3e88b 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -338,8 +338,8 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	}
 
 	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s->async, val) &&
-	    comedi_buf_put(s->async, val >> 16)) {
+	if (comedi_buf_put(s, val) &&
+	    comedi_buf_put(s, val >> 16)) {
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 	} else {
 		/* Overflow! Stop acquisition!! */

commit cb789b8014dc4b35622d9ed18fb1b492a0f43355
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:06 2014 -0700

    staging: comedi: pcmuio: fix the cmd->start_arg use for TRIG_INT
    
    This driver supports a cmd->start_src of TRIG_NOW or TRIG_INT. The
    cmd->start_arg is trivially validated for both sources to be 0.
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid
    trig_num that is used by the async (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used
    to check the trig_num instead of the open coded value.
    
    For aesthetics, refactor the (*do_cmd) to use if/else instead if the
    switch when handling the cmd->start_src.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index a8f390f7a874..ea45424e8410 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -460,20 +460,18 @@ static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
- */
-static int
-pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-			  unsigned int trignum)
+static int pcmuio_inttrig_start_intr(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned int trig_num)
 {
 	struct pcmuio_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 	int event = 0;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	spin_lock_irqsave(&chip->spinlock, flags);
@@ -518,15 +516,11 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Set up start of acquisition. */
-	switch (cmd->start_src) {
-	case TRIG_INT:
+	if (cmd->start_src == TRIG_INT)
 		s->async->inttrig = pcmuio_inttrig_start_intr;
-		break;
-	default:
-		/* TRIG_NOW */
+	else	/* TRIG_NOW */
 		event = pcmuio_start_intr(dev, s);
-		break;
-	}
+
 	spin_unlock_irqrestore(&chip->spinlock, flags);
 
 	if (event)

commit bf4063e6f4a33b8f7ec067e6f180b1daa03c951a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:16 2013 -0700

    staging: comedi: pcmuio: tidy up pcmuio_start_intr()
    
    Refactor this function a bit to remove the need for an extra indent
    level and cleanup some of the odd line breaks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index edcac2679c40..a8f390f7a874 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -410,34 +410,38 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 	struct pcmuio_private *devpriv = dev->private;
 	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int bits = 0;
+	unsigned int pol_bits = 0;
+	int i;
 
 	if (!chip->continuous && chip->stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
 		chip->active = 0;
 		return 1;
-	} else {
-		struct comedi_cmd *cmd = &s->async->cmd;
-		unsigned bits = 0, pol_bits = 0, n;
-
-		chip->enabled_mask = 0;
-		chip->active = 1;
-		if (cmd->chanlist) {
-			for (n = 0; n < cmd->chanlist_len; n++) {
-				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
-				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					     || CR_RANGE(cmd->
-							 chanlist[n]) ? 1U : 0U)
-				    << CR_CHAN(cmd->chanlist[n]);
-			}
-		}
-		bits &= ((0x1 << s->n_chan) - 1);
-		chip->enabled_mask = bits;
+	}
 
-		/* set pol and enab intrs for this subdev.. */
-		pcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);
-		pcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);
+	chip->enabled_mask = 0;
+	chip->active = 1;
+	if (cmd->chanlist) {
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int chanspec = cmd->chanlist[i];
+			unsigned int chan = CR_CHAN(chanspec);
+			unsigned int range = CR_RANGE(chanspec);
+			unsigned int aref = CR_AREF(chanspec);
+
+			bits |= (1 << chan);
+			pol_bits |= ((aref || range) ? 1 : 0) << chan;
+		}
 	}
+	bits &= ((1 << s->n_chan) - 1);
+	chip->enabled_mask = bits;
+
+	/* set pol and enab intrs for this subdev.. */
+	pcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);
+	pcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);
+
 	return 0;
 }
 

commit fc5ba1bd717b1daad46bb990f86cb30b2f2e219e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:15 2013 -0700

    staging: comedi: pcmuio: tidy up pcmuio_attach()
    
    Clean up the local variables, 'sdev_no' and 'asic' are both used in
    simple for () loops. Use the local variable 'i' for both cases. The
    'n_subdevs' variable is only used in one place, just remove it.
    
    For aesthetics, add some whitespace to the subdevice init and reorder
    it to follow the more typical style in comedi drivers.
    
    Remove the unnecessary init of s->len_chanlist for subdevices that do
    not support async commands (interrupts). The core will default it to
    the correct value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 32da92f45b40..edcac2679c40 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -591,8 +591,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcmuio_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	struct pcmuio_private *devpriv;
-	int sdev_no, n_subdevs, asic;
 	int ret;
+	int i;
 
 	ret = comedi_request_region(dev, it->options[0],
 				    board->num_asics * PCMUIO_ASIC_IOSIZE);
@@ -603,8 +603,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic) {
-		struct pcmuio_asic *chip = &devpriv->asics[asic];
+	for (i = 0; i < PCMUIO_MAX_ASICS; ++i) {
+		struct pcmuio_asic *chip = &devpriv->asics[i];
 
 		spin_lock_init(&chip->pagelock);
 		spin_lock_init(&chip->spinlock);
@@ -633,34 +633,29 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	n_subdevs = board->num_asics * 2;
-
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	ret = comedi_alloc_subdevices(dev, board->num_asics * 2);
 	if (ret)
 		return ret;
 
-	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
-		s = &dev->subdevices[sdev_no];
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->type = COMEDI_SUBD_DIO;
-		s->insn_bits = pcmuio_dio_insn_bits;
-		s->insn_config = pcmuio_dio_insn_config;
-		s->n_chan = 24;
+	for (i = 0; i < dev->n_subdevices; ++i) {
+		s = &dev->subdevices[i];
+		s->type		= COMEDI_SUBD_DIO;
+		s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+		s->n_chan	= 24;
+		s->maxdata	= 1;
+		s->range_table	= &range_digital;
+		s->insn_bits	= pcmuio_dio_insn_bits;
+		s->insn_config	= pcmuio_dio_insn_config;
 
 		/* subdevices 0 and 2 can suppport interrupts */
-		if ((sdev_no == 0 && dev->irq) ||
-		    (sdev_no == 2 && devpriv->irq2)) {
+		if ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {
 			/* setup the interrupt subdevice */
 			dev->read_subdev = s;
-			s->subdev_flags |= SDF_CMD_READ;
-			s->cancel = pcmuio_cancel;
-			s->do_cmd = pcmuio_cmd;
-			s->do_cmdtest = pcmuio_cmdtest;
-			s->len_chanlist = s->n_chan;
-		} else {
-			s->len_chanlist = 1;
+			s->subdev_flags	|= SDF_CMD_READ;
+			s->len_chanlist	= s->n_chan;
+			s->cancel	= pcmuio_cancel;
+			s->do_cmd	= pcmuio_cmd;
+			s->do_cmdtest	= pcmuio_cmdtest;
 		}
 	}
 

commit fbd66a7e87e0289f389d20f385bb3062d617f2d3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:14 2013 -0700

    staging: comedi: pcmuio: remove unneeded include
    
    The <linux/slab.h> header is no longer needed by this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b86eb1e8d35c..32da92f45b40 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -75,7 +75,6 @@
 
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include <linux/slab.h>
 
 #include "../comedidev.h"
 

commit d5f81755d6f650881a7ee0ee4498d4a1a7540c49
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:12 2013 -0700

    staging: comedi: pcmuio: fix types of some private data variables
    
    The 'enabled_mask' is a bit mask of the channels that are enabled
    for interrupt detection and should be an unsigned int.
    
    The 'stop_count' is a >= 0 value that is set by the unsigned int
    cmd->stop_arg. Make it an unsigned int.
    
    The 'active' and 'continuous' members are flags. Make them unsigned
    int bit-fields to save a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c83f5bd686cc..b86eb1e8d35c 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -130,10 +130,10 @@ static const struct pcmuio_board pcmuio_boards[] = {
 struct pcmuio_asic {
 	spinlock_t pagelock;	/* protects the page registers */
 	spinlock_t spinlock;	/* protects member variables */
-	int enabled_mask;
-	int active;
-	int stop_count;
-	int continuous;
+	unsigned int enabled_mask;
+	unsigned int stop_count;
+	unsigned int active:1;
+	unsigned int continuous:1;
 };
 
 struct pcmuio_private {

commit 25ad998892c05cf1a3f14ac882af8edbb8f62cc8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:11 2013 -0700

    staging: comedi: pcmuio: document the spinlock_t variables
    
    Add some comments about the two spinlock_t variables in the private
    data. Also, add come comments for the functions that do not need to
    lock/unlock the spinlock.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 6ee876d9905a..c83f5bd686cc 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -128,8 +128,8 @@ static const struct pcmuio_board pcmuio_boards[] = {
 };
 
 struct pcmuio_asic {
-	spinlock_t pagelock;
-	spinlock_t spinlock;
+	spinlock_t pagelock;	/* protects the page registers */
+	spinlock_t spinlock;	/* protects member variables */
 	int enabled_mask;
 	int active;
 	int stop_count;
@@ -295,6 +295,7 @@ static void pcmuio_reset(struct comedi_device *dev)
 	}
 }
 
+/* chip->spinlock is already locked */
 static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -403,6 +404,7 @@ static irqreturn_t pcmuio_interrupt(int irq, void *d)
 	return handled ? IRQ_HANDLED : IRQ_NONE;
 }
 
+/* chip->spinlock is already locked */
 static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {

commit 4344158f3ea32eefd4942915c76d35afdc11b76e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:10 2013 -0700

    staging: comedi: pcmuio: add inline helpers to get the 'iobase', 'asic', and 'port'
    
    To reduce the potential for bugs, and better document the code, introduce
    some inline helper functions to consolidate the calculations needed to get
    the 'iobase' for a given asic and the 'asic' and 'port' associated with a
    given subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 3dbc1d3e1bdd..6ee876d9905a 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -141,12 +141,36 @@ struct pcmuio_private {
 	unsigned int irq2;
 };
 
+static inline unsigned long pcmuio_asic_iobase(struct comedi_device *dev,
+					       int asic)
+{
+	return dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+}
+
+static inline int pcmuio_subdevice_to_asic(struct comedi_subdevice *s)
+{
+	/*
+	 * subdevice 0 and 1 are handled by the first asic
+	 * subdevice 2 and 3 are handled by the second asic
+	 */
+	return s->index / 2;
+}
+
+static inline int pcmuio_subdevice_to_port(struct comedi_subdevice *s)
+{
+	/*
+	 * subdevice 0 and 2 use port registers 0-2
+	 * subdevice 1 and 3 use port registers 3-5
+	 */
+	return (s->index % 2) ? 3 : 0;
+}
+
 static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 			 int asic, int page, int port)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
-	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+	unsigned long iobase = pcmuio_asic_iobase(dev, asic);
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->pagelock, flags);
@@ -169,7 +193,7 @@ static unsigned int pcmuio_read(struct comedi_device *dev,
 {
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
-	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+	unsigned long iobase = pcmuio_asic_iobase(dev, asic);
 	unsigned long flags;
 	unsigned int val;
 
@@ -205,9 +229,9 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
+	int asic = pcmuio_subdevice_to_asic(s);
+	int port = pcmuio_subdevice_to_port(s);
 	unsigned int chanmask = (1 << s->n_chan) - 1;
-	int asic = s->index / 2;
-	int port = (s->index % 2) ? 3 : 0;
 	unsigned int mask;
 	unsigned int val;
 
@@ -240,8 +264,8 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
-	int asic = s->index / 2;
-	int port = (s->index % 2) ? 3 : 0;
+	int asic = pcmuio_subdevice_to_asic(s);
+	int port = pcmuio_subdevice_to_port(s);
 	int ret;
 
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
@@ -275,7 +299,7 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 
 	chip->enabled_mask = 0;
@@ -291,7 +315,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 				      unsigned triggered)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned int len = s->async->cmd.chanlist_len;
 	unsigned oldevents = s->async->events;
@@ -347,7 +371,7 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
 	/* there are could be two asics so we can't use dev->read_subdev */
 	struct comedi_subdevice *s = &dev->subdevices[asic * 2];
-	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+	unsigned long iobase = pcmuio_asic_iobase(dev, asic);
 	unsigned int val;
 
 	/* are there any interrupts pending */
@@ -383,7 +407,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 
 	if (!chip->continuous && chip->stop_count == 0) {
@@ -419,7 +443,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 
@@ -439,7 +463,7 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 	int event = 0;
@@ -467,7 +491,7 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int asic = s->index / 2;
+	int asic = pcmuio_subdevice_to_asic(s);
 	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 	int event = 0;

commit d3d2d75da52982968ddb25f715c86c65dde04903
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:09 2013 -0700

    staging: comedi: pcmuio: remove unnecessary mask of triggered channels
    
    The 'triggered' value is read directly from the three trigger id
    registers and does not have any extra data that needs masked off.
    Remove the 'mytrig' local variable and just use 'triggered' directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 2dca1199d175..3dbc1d3e1bdd 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -297,7 +297,6 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	unsigned oldevents = s->async->events;
 	unsigned int val = 0;
 	unsigned long flags;
-	unsigned mytrig;
 	unsigned int i;
 
 	spin_lock_irqsave(&chip->spinlock, flags);
@@ -305,16 +304,13 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	if (!chip->active)
 		goto done;
 
-	mytrig = triggered;
-	mytrig &= ((0x1 << s->n_chan) - 1);
-
-	if (!(mytrig & chip->enabled_mask))
+	if (!(triggered & chip->enabled_mask))
 		goto done;
 
 	for (i = 0; i < len; i++) {
 		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);
-		if (mytrig & (1U << chan))
-			val |= (1U << i);
+		if (triggered & (1 << chan))
+			val |= (1 << i);
 	}
 
 	/* Write the scan to the buffer. */

commit beecd01b720f3d907a5eacfc142090cf06326836
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:08 2013 -0700

    staging: comedi: pcmuio: fix pcmuio_dio_insn_bits()
    
    This dio subdevice (*insn_bits) function does not follow the "norm"
    for comedi drivers. It also _appears_ to return the incorrect state
    of the channels.
    
    Use the comedi_dio_update_state() helper to handle the boilerplate
    for updating the output channel state. Due to the hardware we then
    need to invert the state and mask the input channels before updating
    the outputs.
    
    Then read the hardware and invert the result to get the current true
    state of the dio channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index fb0cbf047501..2dca1199d175 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -202,30 +202,35 @@ static unsigned int pcmuio_read(struct comedi_device *dev,
  */
 static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	unsigned int mask = data[0] & s->io_bits;	/* outputs only */
-	unsigned int bits = data[1];
+	unsigned int chanmask = (1 << s->n_chan) - 1;
 	int asic = s->index / 2;
 	int port = (s->index % 2) ? 3 : 0;
+	unsigned int mask;
 	unsigned int val;
 
-	/* get inverted state of the channels from the port */
-	val = pcmuio_read(dev, asic, 0, port);
-
-	/* get the true state of the channels */
-	s->state = val ^ ((0x1 << s->n_chan) - 1);
-
+	mask = comedi_dio_update_state(s, data);
 	if (mask) {
-		s->state &= ~mask;
-		s->state |= (mask & bits);
-
-		/* invert the state and update the channels */
-		val = s->state ^ ((0x1 << s->n_chan) - 1);
+		/*
+		 * Outputs are inverted, invert the state and
+		 * update the channels.
+		 *
+		 * The s->io_bits mask makes sure the input channels
+		 * are '0' so that the outputs pins stay in a high
+		 * z-state.
+		 */
+		val = ~s->state & chanmask;
+		val &= s->io_bits;
 		pcmuio_write(dev, val, asic, 0, port);
 	}
 
-	data[1] = s->state;
+	/* get inverted state of the channels from the port */
+	val = pcmuio_read(dev, asic, 0, port);
+
+	/* return the true state of the channels */
+	data[1] = ~val & chanmask;
 
 	return insn->n;
 }

commit 063b590413b5d132d542358e7975fe4955bfeb96
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:07 2013 -0700

    staging: comedi: pcmuio: remove subdevice private data
    
    The subdevice private data is only needed for each 'asic' not for each
    subdevice. Since the 'asic' can be calculated easily from the subdevice
    we can merge the subdevice private data members directly into the
    private data.
    
    This removes the need to kcalloc/free the subdevice private data and
    saves a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 57a52dafac47..fb0cbf047501 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -127,26 +127,17 @@ static const struct pcmuio_board pcmuio_boards[] = {
 	},
 };
 
-struct pcmuio_subdev_private {
-	/* The below is only used for intr subdevices */
-	struct {
-		/*
-		 * subdev-relative channel mask for channels
-		 * we are interested in
-		 */
-		int enabled_mask;
-		int active;
-		int stop_count;
-		int continuous;
-		spinlock_t spinlock;
-	} intr;
+struct pcmuio_asic {
+	spinlock_t pagelock;
+	spinlock_t spinlock;
+	int enabled_mask;
+	int active;
+	int stop_count;
+	int continuous;
 };
 
 struct pcmuio_private {
-	struct {
-		spinlock_t pagelock;
-	} asics[PCMUIO_MAX_ASICS];
-	struct pcmuio_subdev_private *sprivs;
+	struct pcmuio_asic asics[PCMUIO_MAX_ASICS];
 	unsigned int irq2;
 };
 
@@ -154,10 +145,11 @@ static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 			 int asic, int page, int port)
 {
 	struct pcmuio_private *devpriv = dev->private;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 	unsigned long flags;
 
-	spin_lock_irqsave(&devpriv->asics[asic].pagelock, flags);
+	spin_lock_irqsave(&chip->pagelock, flags);
 	if (page == 0) {
 		/* Port registers are valid for any page */
 		outb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));
@@ -169,18 +161,19 @@ static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 		outb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));
 		outb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));
 	}
-	spin_unlock_irqrestore(&devpriv->asics[asic].pagelock, flags);
+	spin_unlock_irqrestore(&chip->pagelock, flags);
 }
 
 static unsigned int pcmuio_read(struct comedi_device *dev,
 				int asic, int page, int port)
 {
 	struct pcmuio_private *devpriv = dev->private;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 	unsigned long flags;
 	unsigned int val;
 
-	spin_lock_irqsave(&devpriv->asics[asic].pagelock, flags);
+	spin_lock_irqsave(&chip->pagelock, flags);
 	if (page == 0) {
 		/* Port registers are valid for any page */
 		val = inb(iobase + PCMUIO_PORT_REG(port + 0));
@@ -192,7 +185,7 @@ static unsigned int pcmuio_read(struct comedi_device *dev,
 		val |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);
 		val |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);
 	}
-	spin_unlock_irqrestore(&devpriv->asics[asic].pagelock, flags);
+	spin_unlock_irqrestore(&chip->pagelock, flags);
 
 	return val;
 }
@@ -276,11 +269,12 @@ static void pcmuio_reset(struct comedi_device *dev)
 static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
 	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 
-	subpriv->intr.enabled_mask = 0;
-	subpriv->intr.active = 0;
+	chip->enabled_mask = 0;
+	chip->active = 0;
 	s->async->inttrig = NULL;
 
 	/* disable all intrs for this subdev.. */
@@ -291,7 +285,9 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      unsigned triggered)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
+	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned int len = s->async->cmd.chanlist_len;
 	unsigned oldevents = s->async->events;
 	unsigned int val = 0;
@@ -299,15 +295,15 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	unsigned mytrig;
 	unsigned int i;
 
-	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&chip->spinlock, flags);
 
-	if (!subpriv->intr.active)
+	if (!chip->active)
 		goto done;
 
 	mytrig = triggered;
 	mytrig &= ((0x1 << s->n_chan) - 1);
 
-	if (!(mytrig & subpriv->intr.enabled_mask))
+	if (!(mytrig & chip->enabled_mask))
 		goto done;
 
 	for (i = 0; i < len; i++) {
@@ -327,11 +323,11 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	}
 
 	/* Check for end of acquisition. */
-	if (!subpriv->intr.continuous) {
+	if (!chip->continuous) {
 		/* stop_src == TRIG_COUNT */
-		if (subpriv->intr.stop_count > 0) {
-			subpriv->intr.stop_count--;
-			if (subpriv->intr.stop_count == 0) {
+		if (chip->stop_count > 0) {
+			chip->stop_count--;
+			if (chip->stop_count == 0) {
 				s->async->events |= COMEDI_CB_EOA;
 				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 				pcmuio_stop_intr(dev, s);
@@ -340,7 +336,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	}
 
 done:
-	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&chip->spinlock, flags);
 
 	if (oldevents != s->async->events)
 		comedi_event(dev, s);
@@ -385,20 +381,21 @@ static irqreturn_t pcmuio_interrupt(int irq, void *d)
 static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
+	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 
-	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
+	if (!chip->continuous && chip->stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
-		subpriv->intr.active = 0;
+		chip->active = 0;
 		return 1;
 	} else {
 		struct comedi_cmd *cmd = &s->async->cmd;
-		int asic = s->index / 2;
 		unsigned bits = 0, pol_bits = 0, n;
 
-		subpriv->intr.enabled_mask = 0;
-		subpriv->intr.active = 1;
+		chip->enabled_mask = 0;
+		chip->active = 1;
 		if (cmd->chanlist) {
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
@@ -409,7 +406,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 			}
 		}
 		bits &= ((0x1 << s->n_chan) - 1);
-		subpriv->intr.enabled_mask = bits;
+		chip->enabled_mask = bits;
 
 		/* set pol and enab intrs for this subdev.. */
 		pcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);
@@ -420,13 +417,15 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
+	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 
-	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
-	if (subpriv->intr.active)
+	spin_lock_irqsave(&chip->spinlock, flags);
+	if (chip->active)
 		pcmuio_stop_intr(dev, s);
-	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&chip->spinlock, flags);
 
 	return 0;
 }
@@ -438,19 +437,21 @@ static int
 pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
+	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 	int event = 0;
 
 	if (trignum != 0)
 		return -EINVAL;
 
-	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&chip->spinlock, flags);
 	s->async->inttrig = NULL;
-	if (subpriv->intr.active)
+	if (chip->active)
 		event = pcmuio_start_intr(dev, s);
 
-	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&chip->spinlock, flags);
 
 	if (event)
 		comedi_event(dev, s);
@@ -463,24 +464,26 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	struct pcmuio_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	int asic = s->index / 2;
+	struct pcmuio_asic *chip = &devpriv->asics[asic];
 	unsigned long flags;
 	int event = 0;
 
-	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
-	subpriv->intr.active = 1;
+	spin_lock_irqsave(&chip->spinlock, flags);
+	chip->active = 1;
 
 	/* Set up end of acquisition. */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		subpriv->intr.continuous = 0;
-		subpriv->intr.stop_count = cmd->stop_arg;
+		chip->continuous = 0;
+		chip->stop_count = cmd->stop_arg;
 		break;
 	default:
 		/* TRIG_NONE */
-		subpriv->intr.continuous = 1;
-		subpriv->intr.stop_count = 0;
+		chip->continuous = 1;
+		chip->stop_count = 0;
 		break;
 	}
 
@@ -494,7 +497,7 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		event = pcmuio_start_intr(dev, s);
 		break;
 	}
-	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&chip->spinlock, flags);
 
 	if (event)
 		comedi_event(dev, s);
@@ -562,7 +565,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct pcmuio_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	struct pcmuio_private *devpriv;
-	struct pcmuio_subdev_private *subpriv;
 	int sdev_no, n_subdevs, asic;
 	int ret;
 
@@ -575,8 +577,12 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic)
-		spin_lock_init(&devpriv->asics[asic].pagelock);
+	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic) {
+		struct pcmuio_asic *chip = &devpriv->asics[asic];
+
+		spin_lock_init(&chip->pagelock);
+		spin_lock_init(&chip->spinlock);
+	}
 
 	pcmuio_reset(dev);
 
@@ -602,9 +608,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	n_subdevs = board->num_asics * 2;
-	devpriv->sprivs = kcalloc(n_subdevs, sizeof(*subpriv), GFP_KERNEL);
-	if (!devpriv->sprivs)
-		return -ENOMEM;
 
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret)
@@ -612,8 +615,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
 		s = &dev->subdevices[sdev_no];
-		subpriv = &devpriv->sprivs[sdev_no];
-		s->private = subpriv;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
@@ -635,7 +636,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		} else {
 			s->len_chanlist = 1;
 		}
-		spin_lock_init(&subpriv->intr.spinlock);
 	}
 
 	return 0;
@@ -651,8 +651,6 @@ static void pcmuio_detach(struct comedi_device *dev)
 		/* free the 2nd irq if used, the core will free the 1st one */
 		if (devpriv->irq2 && devpriv->irq2 != dev->irq)
 			free_irq(devpriv->irq2, dev);
-
-		kfree(devpriv->sprivs);
 	}
 	comedi_legacy_detach(dev);
 }

commit 0d1ead4809161867651b6f19e2cd793d2408abfd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:06 2013 -0700

    staging: comedi: pcmuio: remove 'asic' member from subdevice private data
    
    The 'asic' associated with a subdevice can be easily calculated. The
    functions that use this member in the subdevice private data can only
    be called by the subdevices that support interrupts. Just calculate
    the 'asic' when needed and remove the member variable and sanity checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8752d4d09f3f..57a52dafac47 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -130,8 +130,6 @@ static const struct pcmuio_board pcmuio_boards[] = {
 struct pcmuio_subdev_private {
 	/* The below is only used for intr subdevices */
 	struct {
-		/* if non-negative, this subdev has an interrupt asic */
-		int asic;
 		/*
 		 * subdev-relative channel mask for channels
 		 * we are interested in
@@ -279,11 +277,7 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmuio_subdev_private *subpriv = s->private;
-	int asic;
-
-	asic = subpriv->intr.asic;
-	if (asic < 0)
-		return;		/* not an interrupt subdev */
+	int asic = s->index / 2;
 
 	subpriv->intr.enabled_mask = 0;
 	subpriv->intr.active = 0;
@@ -399,14 +393,10 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 		subpriv->intr.active = 0;
 		return 1;
 	} else {
-		unsigned bits = 0, pol_bits = 0, n;
-		int asic;
 		struct comedi_cmd *cmd = &s->async->cmd;
+		int asic = s->index / 2;
+		unsigned bits = 0, pol_bits = 0, n;
 
-		asic = subpriv->intr.asic;
-		if (asic < 0)
-			return 1;	/* not an interrupt
-					   subdev */
 		subpriv->intr.enabled_mask = 0;
 		subpriv->intr.active = 1;
 		if (cmd->chanlist) {
@@ -636,7 +626,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if ((sdev_no == 0 && dev->irq) ||
 		    (sdev_no == 2 && devpriv->irq2)) {
 			/* setup the interrupt subdevice */
-			subpriv->intr.asic = sdev_no / 2;
 			dev->read_subdev = s;
 			s->subdev_flags |= SDF_CMD_READ;
 			s->cancel = pcmuio_cancel;
@@ -644,7 +633,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->do_cmdtest = pcmuio_cmdtest;
 			s->len_chanlist = s->n_chan;
 		} else {
-			subpriv->intr.asic = -1;
 			s->len_chanlist = 1;
 		}
 		spin_lock_init(&subpriv->intr.spinlock);

commit 741ba8cdf0e938d131b49fda37f80057286e459b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Dec 6 09:43:02 2013 -0700

    staging: comedi: pcmuio: tidy up pcmuio_handle_asic_interrupt()
    
    Unfortunatly, since there could be two asics, we can't use dev->read_subdev
    to get the subdevice. But, the comedi_subdevice associated with the 'asic'
    can easily be calculated. This allows removing the for () loop that searched
    for the correct subdevice.
    
    Tidy up the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index f7032fe251b1..8752d4d09f3f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -354,38 +354,24 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
-	struct pcmuio_subdev_private *subpriv;
+	/* there are could be two asics so we can't use dev->read_subdev */
+	struct comedi_subdevice *s = &dev->subdevices[asic * 2];
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
-	unsigned int triggered = 0;
-	int got1 = 0;
-	unsigned char int_pend;
-	int i;
-
-	int_pend = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;
-	if (int_pend) {
-		triggered = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);
-		pcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);
+	unsigned int val;
 
-		++got1;
-	}
+	/* are there any interrupts pending */
+	val = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;
+	if (!val)
+		return 0;
 
-	if (triggered) {
-		struct comedi_subdevice *s;
-		/* TODO here: dispatch io lines to subdevs with commands.. */
-		for (i = 0; i < dev->n_subdevices; i++) {
-			s = &dev->subdevices[i];
-			subpriv = s->private;
-			if (subpriv->intr.asic == asic) {
-				/*
-				 * This is an interrupt subdev, and it
-				 * matches this asic!
-				 */
-				pcmuio_handle_intr_subdev(dev, s,
-							  triggered);
-			}
-		}
-	}
-	return got1;
+	/* get, and clear, the pending interrupts */
+	val = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);
+	pcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);
+
+	/* handle the pending interrupts */
+	pcmuio_handle_intr_subdev(dev, s, val);
+
+	return 1;
 }
 
 static irqreturn_t pcmuio_interrupt(int irq, void *d)

commit 099ec87df0ff7c2c66173876a9b8910aafb7ca39
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:04 2013 -0700

    staging: comedi: pcmuio: spinlock protect pcmuio_{write, read}()
    
    Currently only the pcmuio_handle_asic_interrupt() function uses the
    spinlock in the private data to protect the read of the paged interrupt
    id registers. All accesses to the paged registers should be protected
    to ensure that the page is not changed until the access is complete.
    Move the lock/unlock into the pcmuio_{write,read}() functions to make
    sure the access completes correctly. Rename the spinlock to variable
    to clarify its use.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index dfa728052265..f7032fe251b1 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -146,7 +146,7 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		spinlock_t spinlock;
+		spinlock_t pagelock;
 	} asics[PCMUIO_MAX_ASICS];
 	struct pcmuio_subdev_private *sprivs;
 	unsigned int irq2;
@@ -155,8 +155,11 @@ struct pcmuio_private {
 static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 			 int asic, int page, int port)
 {
+	struct pcmuio_private *devpriv = dev->private;
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+	unsigned long flags;
 
+	spin_lock_irqsave(&devpriv->asics[asic].pagelock, flags);
 	if (page == 0) {
 		/* Port registers are valid for any page */
 		outb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));
@@ -168,14 +171,18 @@ static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 		outb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));
 		outb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));
 	}
+	spin_unlock_irqrestore(&devpriv->asics[asic].pagelock, flags);
 }
 
 static unsigned int pcmuio_read(struct comedi_device *dev,
 				int asic, int page, int port)
 {
+	struct pcmuio_private *devpriv = dev->private;
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
+	unsigned long flags;
 	unsigned int val;
 
+	spin_lock_irqsave(&devpriv->asics[asic].pagelock, flags);
 	if (page == 0) {
 		/* Port registers are valid for any page */
 		val = inb(iobase + PCMUIO_PORT_REG(port + 0));
@@ -187,6 +194,7 @@ static unsigned int pcmuio_read(struct comedi_device *dev,
 		val |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);
 		val |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);
 	}
+	spin_unlock_irqrestore(&devpriv->asics[asic].pagelock, flags);
 
 	return val;
 }
@@ -346,17 +354,13 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
-	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv;
 	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 	unsigned int triggered = 0;
 	int got1 = 0;
-	unsigned long flags;
 	unsigned char int_pend;
 	int i;
 
-	spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
-
 	int_pend = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;
 	if (int_pend) {
 		triggered = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);
@@ -365,8 +369,6 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 		++got1;
 	}
 
-	spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
-
 	if (triggered) {
 		struct comedi_subdevice *s;
 		/* TODO here: dispatch io lines to subdevs with commands.. */
@@ -598,7 +600,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic)
-		spin_lock_init(&devpriv->asics[asic].spinlock);
+		spin_lock_init(&devpriv->asics[asic].pagelock);
 
 	pcmuio_reset(dev);
 

commit 04426acfb86ad10968340771bb15f6074e12912f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 16:54:03 2013 -0700

    staging: comedi: pcmuio: fix interrupt requests
    
    Legacy (ISA) interrupts are not sharable so this driver should not
    be passing the IRQF_SHARED flag when requesting the interrupts.
    
    This driver supports two board types:
      PCM-UIO48 with one asic (one interrupt source)
      PCM-UIO96 with two asics (two interrupt sources)
    
    The PCM-UIO96 has a jumper that allows the two interrupt sources to
    share an interrupt. This is safe for legacy interrupts as long as
    the "shared" interrupt is handled by a single driver.
    
    Modify the request_irq() code in this driver to correctly request the
    interrupts. For the PCM-UI048 case (one asic) only one request_irq()
    is needed. For the PCM-UIO96 (two asics) there are three cases:
    
      1) irq is shared, one request_irq() call
      2) only one asic has an irq, one request_irq() call
      3) two irqs, two request_irq() calls
    
    The irq for the first asic (dev->irq) will be requested during the
    attach if required. The comedi core will handle the freeing of this
    irq during the detach.
    
    The irq for the second asic (devpriv->irq2) will also be requested
    during the attach if required. The freeing of this irq will be
    handled by the driver during the detach.
    
    Move the board reset and interrupt request code so it occurs early
    in the attach. We can then check dev->irq and devpriv->irq2 to see
    if the subdevice command support actually needs to be initialized.
    
    This also simplifies the interrupt handler. The irq can be simply
    checked against dev->irq and devpriv->irq2 to see which asic caused
    the interrupt.
    
    Add a call to pcmuio_reset() in the (*detach) to make sure the
    interrupts are disabled before freeing the irqs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 954fa96a50ac..dfa728052265 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -146,10 +146,10 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		unsigned int irq;
 		spinlock_t spinlock;
 	} asics[PCMUIO_MAX_ASICS];
 	struct pcmuio_subdev_private *sprivs;
+	unsigned int irq2;
 };
 
 static void pcmuio_write(struct comedi_device *dev, unsigned int val,
@@ -390,19 +390,14 @@ static irqreturn_t pcmuio_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcmuio_private *devpriv = dev->private;
-	int got1 = 0;
-	int asic;
+	int handled = 0;
 
-	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic) {
-		if (irq == devpriv->asics[asic].irq) {
-			/* it is an interrupt for ASIC #asic */
-			if (pcmuio_handle_asic_interrupt(dev, asic))
-				got1++;
-		}
-	}
-	if (!got1)
-		return IRQ_NONE;	/* interrupt from other source */
-	return IRQ_HANDLED;
+	if (irq == dev->irq)
+		handled += pcmuio_handle_asic_interrupt(dev, 0);
+	if (irq == devpriv->irq2)
+		handled += pcmuio_handle_asic_interrupt(dev, 1);
+
+	return handled ? IRQ_HANDLED : IRQ_NONE;
 }
 
 static int pcmuio_start_intr(struct comedi_device *dev,
@@ -591,12 +586,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pcmuio_private *devpriv;
 	struct pcmuio_subdev_private *subpriv;
 	int sdev_no, n_subdevs, asic;
-	unsigned int irq[PCMUIO_MAX_ASICS];
 	int ret;
 
-	irq[0] = it->options[1];
-	irq[1] = it->options[2];
-
 	ret = comedi_request_region(dev, it->options[0],
 				    board->num_asics * PCMUIO_ASIC_IOSIZE);
 	if (ret)
@@ -609,6 +600,29 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 
+	pcmuio_reset(dev);
+
+	if (it->options[1]) {
+		/* request the irq for the 1st asic */
+		ret = request_irq(it->options[1], pcmuio_interrupt, 0,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = it->options[1];
+	}
+
+	if (board->num_asics == 2) {
+		if (it->options[2] == dev->irq) {
+			/* the same irq (or none) is used by both asics */
+			devpriv->irq2 = it->options[2];
+		} else if (it->options[2]) {
+			/* request the irq for the 2nd asic */
+			ret = request_irq(it->options[2], pcmuio_interrupt, 0,
+					dev->board_name, dev);
+			if (ret == 0)
+				devpriv->irq2 = it->options[2];
+		}
+	}
+
 	n_subdevs = board->num_asics * 2;
 	devpriv->sprivs = kcalloc(n_subdevs, sizeof(*subpriv), GFP_KERNEL);
 	if (!devpriv->sprivs)
@@ -630,8 +644,9 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_config = pcmuio_dio_insn_config;
 		s->n_chan = 24;
 
-		/* subdevices 0 and 2 suppport interrupts */
-		if ((sdev_no % 2) == 0) {
+		/* subdevices 0 and 2 can suppport interrupts */
+		if ((sdev_no == 0 && dev->irq) ||
+		    (sdev_no == 2 && devpriv->irq2)) {
 			/* setup the interrupt subdevice */
 			subpriv->intr.asic = sdev_no / 2;
 			dev->read_subdev = s;
@@ -647,36 +662,20 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&subpriv->intr.spinlock);
 	}
 
-	pcmuio_reset(dev);
-
-	for (asic = 0; irq[0] && asic < PCMUIO_MAX_ASICS; ++asic) {
-		if (irq[asic]
-		    && request_irq(irq[asic], pcmuio_interrupt,
-				   IRQF_SHARED, board->name, dev)) {
-			int i;
-			/* unroll the allocated irqs.. */
-			for (i = asic - 1; i >= 0; --i) {
-				free_irq(irq[i], dev);
-				devpriv->asics[i].irq = irq[i] = 0;
-			}
-			irq[asic] = 0;
-		}
-		devpriv->asics[asic].irq = irq[asic];
-	}
-
 	return 0;
 }
 
 static void pcmuio_detach(struct comedi_device *dev)
 {
 	struct pcmuio_private *devpriv = dev->private;
-	int i;
 
 	if (devpriv) {
-		for (i = 0; i < PCMUIO_MAX_ASICS; ++i) {
-			if (devpriv->asics[i].irq)
-				free_irq(devpriv->asics[i].irq, dev);
-		}
+		pcmuio_reset(dev);
+
+		/* free the 2nd irq if used, the core will free the 1st one */
+		if (devpriv->irq2 && devpriv->irq2 != dev->irq)
+			free_irq(devpriv->irq2, dev);
+
 		kfree(devpriv->sprivs);
 	}
 	comedi_legacy_detach(dev);

commit 5c174c41d8a702ade02fbb125b15f58158e4d1da
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:33 2013 +0100

    staging: comedi: pcmuio: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change `pcmuio_handle_intr_subdev()` in the "pcmuio" module to use
    unsigned sample values for consistency.
    
    Also, make the order in which `pcmuio_handle_intr_subdev()` writes the
    two sample values (each actually containing up to 16 1-bit sample
    values) independent of the host byte ordering.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 67e2bb1d66f0..954fa96a50ac 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -315,8 +315,8 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	}
 
 	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s->async, ((short *)&val)[0]) &&
-	    comedi_buf_put(s->async, ((short *)&val)[1])) {
+	if (comedi_buf_put(s->async, val) &&
+	    comedi_buf_put(s->async, val >> 16)) {
 		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 	} else {
 		/* Overflow! Stop acquisition!! */

commit 2fd2bdfccae61efe18f6b92b6a45fbf936d75b48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 20 11:50:19 2013 +0100

    staging: comedi: pcmuio: fix possible NULL deref on detach
    
    pcmuio_detach() is called by the comedi core even if pcmuio_attach()
    returned an error, so `dev->private` might be `NULL`.  Check for that
    before dereferencing it.
    
    Also, as pointed out by Dan Carpenter, there is no need to check the
    pointer passed to `kfree()` is non-NULL, so remove that check.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index f9424554539d..67e2bb1d66f0 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -672,12 +672,13 @@ static void pcmuio_detach(struct comedi_device *dev)
 	struct pcmuio_private *devpriv = dev->private;
 	int i;
 
-	for (i = 0; i < PCMUIO_MAX_ASICS; ++i) {
-		if (devpriv->asics[i].irq)
-			free_irq(devpriv->asics[i].irq, dev);
-	}
-	if (devpriv && devpriv->sprivs)
+	if (devpriv) {
+		for (i = 0; i < PCMUIO_MAX_ASICS; ++i) {
+			if (devpriv->asics[i].irq)
+				free_irq(devpriv->asics[i].irq, dev);
+		}
 		kfree(devpriv->sprivs);
+	}
 	comedi_legacy_detach(dev);
 }
 

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 13f1943f5b8b..f9424554539d 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -233,27 +233,19 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
-	unsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);
 	int asic = s->index / 2;
 	int port = (s->index % 2) ? 3 : 0;
+	int ret;
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= chan_mask;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~chan_mask;
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
+
+	if (data[0] == INSN_CONFIG_DIO_INPUT)
 		pcmuio_write(dev, s->io_bits, asic, 0, port);
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & chan_mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
 
 	return insn->n;
 }

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 30f53fb5a0ac..13f1943f5b8b 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -73,6 +73,7 @@
  *             can be the same as first irq!)
  */
 
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c43b6334ceae..30f53fb5a0ac 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -609,10 +609,9 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic)
 		spin_lock_init(&devpriv->asics[asic].spinlock);

commit 5c1f62a75ca29d91606fd6e8bdeb2cff88086e0f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:27:19 2013 -0700

    staging: comedi: pcmuio: fix namespace for all private functions
    
    Rename a couple private functions so they have the same namespace
    as the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index bc969d24d1a3..c43b6334ceae 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -257,7 +257,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void init_asics(struct comedi_device *dev)
+static void pcmuio_reset(struct comedi_device *dev)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
 	int asic;
@@ -393,7 +393,7 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 	return got1;
 }
 
-static irqreturn_t interrupt_pcmuio(int irq, void *d)
+static irqreturn_t pcmuio_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pcmuio_private *devpriv = dev->private;
@@ -655,11 +655,11 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&subpriv->intr.spinlock);
 	}
 
-	init_asics(dev);	/* clear out all the registers, basically */
+	pcmuio_reset(dev);
 
 	for (asic = 0; irq[0] && asic < PCMUIO_MAX_ASICS; ++asic) {
 		if (irq[asic]
-		    && request_irq(irq[asic], interrupt_pcmuio,
+		    && request_irq(irq[asic], pcmuio_interrupt,
 				   IRQF_SHARED, board->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */

commit ee81b210fe9f761a3d34f6c061c67e6313df06bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:26:59 2013 -0700

    staging: comedi: pcmuio: return 0 for successful attach
    
    Returning 0 for success is more common.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 46def3b402da..bc969d24d1a3 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -672,7 +672,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].irq = irq[asic];
 	}
 
-	return 1;
+	return 0;
 }
 
 static void pcmuio_detach(struct comedi_device *dev)

commit b315773177ae6ed2b2e6721c3f1c44a576bda1af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:26:42 2013 -0700

    staging: comedi: pcmuio: remove dev_dbg() noise during attach
    
    This is just added noise. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 1c219018d2e5..46def3b402da 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -672,16 +672,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].irq = irq[asic];
 	}
 
-	if (irq[0]) {
-		dev_dbg(dev->class_dev, "irq: %u\n", irq[0]);
-		if (irq[1] && board->num_asics == 2)
-			dev_dbg(dev->class_dev, "second ASIC irq: %u\n",
-				irq[1]);
-	} else {
-		dev_dbg(dev->class_dev, "(IRQ mode disabled)\n");
-	}
-
-
 	return 1;
 }
 

commit e99f0f073d23795a3e58782a28431685c28ba6c4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:26:24 2013 -0700

    staging: comedi: pcmuio: use preferred form for passing the size of a struct
    
    As suggested by the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b88b24d290e8..1c219018d2e5 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -618,9 +618,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 
 	n_subdevs = board->num_asics * 2;
-	devpriv->sprivs = kcalloc(n_subdevs,
-				  sizeof(struct pcmuio_subdev_private),
-				  GFP_KERNEL);
+	devpriv->sprivs = kcalloc(n_subdevs, sizeof(*subpriv), GFP_KERNEL);
 	if (!devpriv->sprivs)
 		return -ENOMEM;
 

commit b07839c09b5235caae99ba2f8c24968a9115707c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:26:05 2013 -0700

    staging: comedi: pcmuio: cleanup remaining #define's
    
    Remove all the unused #define's and add namespace to the ones that
    are used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index d1f5fc024089..b88b24d290e8 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -108,21 +108,8 @@
 #define PCMUIO_PAGE_INT_ID		3
 #define PCMUIO_PAGE_REG(x)		(0x08 + (x))
 
-#define CHANS_PER_PORT		8
-#define PORTS_PER_ASIC		6
-/* number of channels per comedi subdevice */
-#define MAX_CHANS_PER_SUBDEV	24
-#define PORTS_PER_SUBDEV	(MAX_CHANS_PER_SUBDEV / CHANS_PER_PORT)
-#define CHANS_PER_ASIC		(CHANS_PER_PORT * PORTS_PER_ASIC)
-#define INTR_CHANS_PER_ASIC	24
-#define INTR_PORTS_PER_SUBDEV	(INTR_CHANS_PER_ASIC / CHANS_PER_PORT)
-#define MAX_DIO_CHANS		(PORTS_PER_ASIC * 2 * CHANS_PER_PORT)
-#define MAX_ASICS		(MAX_DIO_CHANS / CHANS_PER_ASIC)
-
-/* IO Memory sizes */
-#define ASIC_IOSIZE		0x10
-#define PCMUIO48_IOSIZE		ASIC_IOSIZE
-#define PCMUIO96_IOSIZE		(ASIC_IOSIZE * 2)
+#define PCMUIO_ASIC_IOSIZE		0x10
+#define PCMUIO_MAX_ASICS		2
 
 struct pcmuio_board {
 	const char *name;
@@ -160,14 +147,14 @@ struct pcmuio_private {
 	struct {
 		unsigned int irq;
 		spinlock_t spinlock;
-	} asics[MAX_ASICS];
+	} asics[PCMUIO_MAX_ASICS];
 	struct pcmuio_subdev_private *sprivs;
 };
 
 static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 			 int asic, int page, int port)
 {
-	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 
 	if (page == 0) {
 		/* Port registers are valid for any page */
@@ -185,7 +172,7 @@ static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 static unsigned int pcmuio_read(struct comedi_device *dev,
 				int asic, int page, int port)
 {
-	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 	unsigned int val;
 
 	if (page == 0) {
@@ -368,7 +355,7 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv;
-	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+	unsigned long iobase = dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);
 	unsigned int triggered = 0;
 	int got1 = 0;
 	unsigned long flags;
@@ -413,7 +400,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 	int got1 = 0;
 	int asic;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
+	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
 			/* it is an interrupt for ASIC #asic */
 			if (pcmuio_handle_asic_interrupt(dev, asic))
@@ -611,14 +598,14 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pcmuio_private *devpriv;
 	struct pcmuio_subdev_private *subpriv;
 	int sdev_no, n_subdevs, asic;
-	unsigned int irq[MAX_ASICS];
+	unsigned int irq[PCMUIO_MAX_ASICS];
 	int ret;
 
 	irq[0] = it->options[1];
 	irq[1] = it->options[2];
 
 	ret = comedi_request_region(dev, it->options[0],
-				    board->num_asics * ASIC_IOSIZE);
+				    board->num_asics * PCMUIO_ASIC_IOSIZE);
 	if (ret)
 		return ret;
 
@@ -627,7 +614,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic)
+	for (asic = 0; asic < PCMUIO_MAX_ASICS; ++asic)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 
 	n_subdevs = board->num_asics * 2;
@@ -672,7 +659,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	init_asics(dev);	/* clear out all the registers, basically */
 
-	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
+	for (asic = 0; irq[0] && asic < PCMUIO_MAX_ASICS; ++asic) {
 		if (irq[asic]
 		    && request_irq(irq[asic], interrupt_pcmuio,
 				   IRQF_SHARED, board->name, dev)) {
@@ -705,7 +692,7 @@ static void pcmuio_detach(struct comedi_device *dev)
 	struct pcmuio_private *devpriv = dev->private;
 	int i;
 
-	for (i = 0; i < MAX_ASICS; ++i) {
+	for (i = 0; i < PCMUIO_MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
 	}

commit 1fdd0fc5fe28cd11ecf64e77892a1d9a1fd89fbf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:25:47 2013 -0700

    staging: comedi: pcmuio: cleanup DIO subdevice (*insn_{bits,config})
    
    Use the pcmuio_{read,write}() helpers to read/write all 24 channels
    instead of handling the digital I/O as three separate ports. This
    simplifies both functions with minimal overhead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e52f6aeee453..d1f5fc024089 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -203,51 +203,42 @@ static unsigned int pcmuio_read(struct comedi_device *dev,
 	return val;
 }
 
+/*
+ * Each channel can be individually programmed for input or output.
+ * Writing a '0' to a channel causes the corresponding output pin
+ * to go to a high-z state (pulled high by an external 10K resistor).
+ * This allows it to be used as an input. When used in the input mode,
+ * a read reflects the inverted state of the I/O pin, such that a
+ * high on the pin will read as a '0' in the register. Writing a '1'
+ * to a bit position causes the pin to sink current (up to 12mA),
+ * effectively pulling it low.
+ */
 static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	unsigned int mask = data[0] & s->io_bits;	/* outputs only */
+	unsigned int bits = data[1];
 	int asic = s->index / 2;
 	int port = (s->index % 2) ? 3 : 0;
-	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
-	int byte_no;
-
-	/* NOTE:
-	   reading a 0 means this channel was high
-	   writine a 0 sets the channel high
-	   reading a 1 means this channel was low
-	   writing a 1 means set this channel low
-
-	   Therefore everything is always inverted. */
-
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
+	unsigned int val;
 
-	s->state = 0;
+	/* get inverted state of the channels from the port */
+	val = pcmuio_read(dev, asic, 0, port);
 
-	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
-		/* bit offset of port in 32-bit doubleword */
-		unsigned long offset = byte_no * 8;
-		/* this 8-bit port's data */
-		unsigned char byte = 0,
-		    /* The write mask for this port (if any) */
-		    write_mask_byte = (data[0] >> offset) & 0xff,
-		    /* The data byte for this port */
-		    data_byte = (data[1] >> offset) & 0xff;
+	/* get the true state of the channels */
+	s->state = val ^ ((0x1 << s->n_chan) - 1);
 
-		byte = inb(iobase + PCMUIO_PORT_REG(port + byte_no));
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (mask & bits);
 
-		if (write_mask_byte) {
-			byte &= ~write_mask_byte;
-			byte |= ~data_byte & write_mask_byte;
-			outb(byte, iobase + PCMUIO_PORT_REG(port + byte_no));
-		}
-		/* save the digital input lines for this byte.. */
-		s->state |= ((unsigned int)byte) << offset;
+		/* invert the state and update the channels */
+		val = s->state ^ ((0x1 << s->n_chan) - 1);
+		pcmuio_write(dev, val, asic, 0, port);
 	}
 
-	/* now return the DIO lines to data[1] - note they came inverted! */
-	data[1] = ~s->state;
+	data[1] = s->state;
 
 	return insn->n;
 }
@@ -256,58 +247,21 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	unsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);
 	int asic = s->index / 2;
 	int port = (s->index % 2) ? 3 : 0;
-	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int byte_no = chan / 8;
-	int bit_no = chan % 8;
-	unsigned char byte;
-
-	/* NOTE:
-	   writing a 0 an IO channel's bit sets the channel to INPUT
-	   and pulls the line high as well
-
-	   writing a 1 to an IO channel's  bit pulls the line low
-
-	   All channels are implicitly always in OUTPUT mode -- but when
-	   they are high they can be considered to be in INPUT mode..
-
-	   Thus, we only force channels low if the config request was INPUT,
-	   otherwise we do nothing to the hardware.    */
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		/* save to io_bits -- don't actually do anything since
-		   all input channels are also output channels... */
-		s->io_bits |= 1 << chan;
+		s->io_bits |= chan_mask;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		/* write a 0 to the actual register representing the channel
-		   to set it to 'input'.  0 means "float high". */
-		byte = inb(iobase + PCMUIO_PORT_REG(port + byte_no));
-		byte &= ~(1 << bit_no);
-				/**< set input channel to '0' */
-
-		/*
-		 * write out byte
-		 * This is the only time we actually affect the hardware
-		 * as all channels are implicitly output -- but input
-		 * channels are set to float-high.
-		 */
-		outb(byte, iobase + PCMUIO_PORT_REG(port + byte_no));
-
-		/* save to io_bits */
-		s->io_bits &= ~(1 << chan);
+		s->io_bits &= ~chan_mask;
+		pcmuio_write(dev, s->io_bits, asic, 0, port);
 		break;
-
 	case INSN_CONFIG_DIO_QUERY:
-		/* retrieve from shadow register */
-		data[1] =
-		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
+		data[1] = (s->io_bits & chan_mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		break;
-
 	default:
 		return -EINVAL;
 		break;

commit 89aaa92adffa5c57d9c2a545c7cb9809ddd3b615
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:25:15 2013 -0700

    staging: comedi: pcmuio: introduce pcmuio_read()
    
    Introduce a helper function to handle reading a 24-bit value from the
    three 8-bit registers associated with a "port" or "page".
    
    Simplify the for() loop in pcmuio_handle_asic_interrupt() that finds
    which channels have triggered the interrupt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8f745127ea6f..e52f6aeee453 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -110,7 +110,6 @@
 
 #define CHANS_PER_PORT		8
 #define PORTS_PER_ASIC		6
-#define INTR_PORTS_PER_ASIC	3
 /* number of channels per comedi subdevice */
 #define MAX_CHANS_PER_SUBDEV	24
 #define PORTS_PER_SUBDEV	(MAX_CHANS_PER_SUBDEV / CHANS_PER_PORT)
@@ -183,6 +182,27 @@ static void pcmuio_write(struct comedi_device *dev, unsigned int val,
 	}
 }
 
+static unsigned int pcmuio_read(struct comedi_device *dev,
+				int asic, int page, int port)
+{
+	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+	unsigned int val;
+
+	if (page == 0) {
+		/* Port registers are valid for any page */
+		val = inb(iobase + PCMUIO_PORT_REG(port + 0));
+		val |= (inb(iobase + PCMUIO_PORT_REG(port + 1)) << 8);
+		val |= (inb(iobase + PCMUIO_PORT_REG(port + 2)) << 16);
+	} else {
+		outb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);
+		val = inb(iobase + PCMUIO_PAGE_REG(0));
+		val |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);
+		val |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);
+	}
+
+	return val;
+}
+
 static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -296,12 +316,6 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void switch_page(struct comedi_device *dev, int asic, int page)
-{
-	outb(PCMUIO_PAGE(page),
-	     dev->iobase + ASIC_IOSIZE * asic + PCMUIO_PAGE_LOCK_REG);
-}
-
 static void init_asics(struct comedi_device *dev)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
@@ -401,7 +415,7 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv;
 	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
-	unsigned triggered = 0;
+	unsigned int triggered = 0;
 	int got1 = 0;
 	unsigned long flags;
 	unsigned char int_pend;
@@ -411,19 +425,8 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 
 	int_pend = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;
 	if (int_pend) {
-		for (i = 0; i < INTR_PORTS_PER_ASIC; ++i) {
-			if (int_pend & (0x1 << i)) {
-				unsigned char val;
-
-				switch_page(dev, asic, PCMUIO_PAGE_INT_ID);
-				val = inb(iobase + PCMUIO_PAGE_REG(i));
-				if (val)
-					/* clear pending interrupt */
-					outb(0, iobase + PCMUIO_PAGE_REG(i));
-
-					triggered |= (val << (i * 8));
-			}
-		}
+		triggered = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);
+		pcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);
 
 		++got1;
 	}

commit 1699d80aef8ba7992d5f4176aed3504db8cffaf9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:24:56 2013 -0700

    staging: comedi: pcmuio: simplify interrupt subdevice init
    
    Only subdevices 0 and 2 support interrupts. Simplify the attach
    a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b2860c0f8dae..8f745127ea6f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -653,7 +653,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	struct pcmuio_private *devpriv;
 	struct pcmuio_subdev_private *subpriv;
-	int sdev_no, n_subdevs, port, asic, thisasic_chanct = 0;
+	int sdev_no, n_subdevs, asic;
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
@@ -684,11 +684,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	port = 0;
-	asic = 0;
 	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
-		int byte_no;
-
 		s = &dev->subdevices[sdev_no];
 		subpriv = &devpriv->sprivs[sdev_no];
 		s->private = subpriv;
@@ -699,30 +695,20 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_bits = pcmuio_dio_insn_bits;
 		s->insn_config = pcmuio_dio_insn_config;
 		s->n_chan = 24;
-		subpriv->intr.asic = -1;
-		s->len_chanlist = 1;
-
-		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV;
-		     ++byte_no, ++port) {
-			if (port >= PORTS_PER_ASIC) {
-				port = 0;
-				++asic;
-				thisasic_chanct = 0;
-			}
 
-			if (thisasic_chanct <
-			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-			    && subpriv->intr.asic < 0) {
-				/* setup the interrupt subdevice */
-				subpriv->intr.asic = asic;
-				dev->read_subdev = s;
-				s->subdev_flags |= SDF_CMD_READ;
-				s->cancel = pcmuio_cancel;
-				s->do_cmd = pcmuio_cmd;
-				s->do_cmdtest = pcmuio_cmdtest;
-				s->len_chanlist = s->n_chan;
-			}
-			thisasic_chanct += CHANS_PER_PORT;
+		/* subdevices 0 and 2 suppport interrupts */
+		if ((sdev_no % 2) == 0) {
+			/* setup the interrupt subdevice */
+			subpriv->intr.asic = sdev_no / 2;
+			dev->read_subdev = s;
+			s->subdev_flags |= SDF_CMD_READ;
+			s->cancel = pcmuio_cancel;
+			s->do_cmd = pcmuio_cmd;
+			s->do_cmdtest = pcmuio_cmdtest;
+			s->len_chanlist = s->n_chan;
+		} else {
+			subpriv->intr.asic = -1;
+			s->len_chanlist = 1;
 		}
 		spin_lock_init(&subpriv->intr.spinlock);
 	}

commit c4ad65e6ce8a9cfe78d4c4b06b915c17a27ba011
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:24:36 2013 -0700

    staging: comedi: pcmuio: remove 'iobases' from subdevice private data
    
    The 'asic' and 'port' associated with a given subdevice can easily be
    found based on the subdevice 'index'. With that information we can
    then calculate the correct iobase and register offset needed to read/
    write the 8-bit ports.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b942b0a51bab..b2860c0f8dae 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -141,9 +141,6 @@ static const struct pcmuio_board pcmuio_boards[] = {
 };
 
 struct pcmuio_subdev_private {
-	/* mapping of halfwords (bytes) in port/chanarray to iobase */
-	unsigned long iobases[PORTS_PER_SUBDEV];
-
 	/* The below is only used for intr subdevices */
 	struct {
 		/* if non-negative, this subdev has an interrupt asic */
@@ -190,7 +187,9 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
+	int asic = s->index / 2;
+	int port = (s->index % 2) ? 3 : 0;
+	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
 	int byte_no;
 
 	/* NOTE:
@@ -207,10 +206,8 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 	s->state = 0;
 
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
-		/* address of 8-bit port */
-		unsigned long ioaddr = subpriv->iobases[byte_no],
-		    /* bit offset of port in 32-bit doubleword */
-		    offset = byte_no * 8;
+		/* bit offset of port in 32-bit doubleword */
+		unsigned long offset = byte_no * 8;
 		/* this 8-bit port's data */
 		unsigned char byte = 0,
 		    /* The write mask for this port (if any) */
@@ -218,12 +215,12 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 		    /* The data byte for this port */
 		    data_byte = (data[1] >> offset) & 0xff;
 
-		byte = inb(ioaddr);	/* read all 8-bits for this port */
+		byte = inb(iobase + PCMUIO_PORT_REG(port + byte_no));
 
 		if (write_mask_byte) {
 			byte &= ~write_mask_byte;
 			byte |= ~data_byte & write_mask_byte;
-			outb(byte, ioaddr);
+			outb(byte, iobase + PCMUIO_PORT_REG(port + byte_no));
 		}
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
@@ -239,15 +236,14 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
-	struct pcmuio_subdev_private *subpriv = s->private;
-	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-	    chan % 8;
-	unsigned long ioaddr;
+	int asic = s->index / 2;
+	int port = (s->index % 2) ? 3 : 0;
+	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int byte_no = chan / 8;
+	int bit_no = chan % 8;
 	unsigned char byte;
 
-	/* Compute ioaddr for this channel */
-	ioaddr = subpriv->iobases[byte_no];
-
 	/* NOTE:
 	   writing a 0 an IO channel's bit sets the channel to INPUT
 	   and pulls the line high as well
@@ -269,7 +265,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_DIO_INPUT:
 		/* write a 0 to the actual register representing the channel
 		   to set it to 'input'.  0 means "float high". */
-		byte = inb(ioaddr);
+		byte = inb(iobase + PCMUIO_PORT_REG(port + byte_no));
 		byte &= ~(1 << bit_no);
 				/**< set input channel to '0' */
 
@@ -279,7 +275,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 		 * as all channels are implicitly output -- but input
 		 * channels are set to float-high.
 		 */
-		outb(byte, ioaddr);
+		outb(byte, iobase + PCMUIO_PORT_REG(port + byte_no));
 
 		/* save to io_bits */
 		s->io_bits &= ~(1 << chan);
@@ -706,8 +702,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		subpriv->intr.asic = -1;
 		s->len_chanlist = 1;
 
-		/* save the ioport address for each 'port' of 8 channels in the
-		   subdevice */
 		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV;
 		     ++byte_no, ++port) {
 			if (port >= PORTS_PER_ASIC) {
@@ -715,8 +709,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				++asic;
 				thisasic_chanct = 0;
 			}
-			subpriv->iobases[byte_no] = dev->iobase +
-						    (asic * ASIC_IOSIZE) + port;
 
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC

commit 021314f82405594344b857e13e0493e11dad7298
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:24:05 2013 -0700

    staging: comedi: pcmuio: remove 'iobase' from private data
    
    It's simple enough to calculate the iobase when needed. Remove this
    member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e21594bde226..b942b0a51bab 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -162,7 +162,6 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		unsigned long iobase;
 		unsigned int irq;
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
@@ -405,7 +404,7 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv;
-	unsigned long iobase = devpriv->asics[asic].iobase;
+	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
 	unsigned triggered = 0;
 	int got1 = 0;
 	unsigned long flags;
@@ -675,10 +674,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
+	for (asic = 0; asic < MAX_ASICS; ++asic)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
-	}
 
 	n_subdevs = board->num_asics * 2;
 	devpriv->sprivs = kcalloc(n_subdevs,
@@ -718,8 +715,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				++asic;
 				thisasic_chanct = 0;
 			}
-			subpriv->iobases[byte_no] =
-			    devpriv->asics[asic].iobase + port;
+			subpriv->iobases[byte_no] = dev->iobase +
+						    (asic * ASIC_IOSIZE) + port;
 
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC

commit c87e1f26054388b661298a61e906a03fa2cd193e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:23:46 2013 -0700

    staging: comedi: pcmuio: simplify 'n_subdevs' and 's->n_chan'
    
    The number of subdevices needed by the driver is based on the
    'num_asics' reported by the boardinfo and each subdevice always
    has 24 channels. Simplify the attach a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 85a64807a073..e21594bde226 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -658,7 +658,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	struct pcmuio_private *devpriv;
 	struct pcmuio_subdev_private *subpriv;
-	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
+	int sdev_no, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
@@ -680,9 +680,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
-	chans_left = CHANS_PER_ASIC * board->num_asics;
-	n_subdevs = (chans_left / MAX_CHANS_PER_SUBDEV) +
-		    (!!(chans_left % MAX_CHANS_PER_SUBDEV));
+	n_subdevs = board->num_asics * 2;
 	devpriv->sprivs = kcalloc(n_subdevs,
 				  sizeof(struct pcmuio_subdev_private),
 				  GFP_KERNEL);
@@ -707,7 +705,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_DIO;
 		s->insn_bits = pcmuio_dio_insn_bits;
 		s->insn_config = pcmuio_dio_insn_config;
-		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
+		s->n_chan = 24;
 		subpriv->intr.asic = -1;
 		s->len_chanlist = 1;
 
@@ -738,15 +736,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			thisasic_chanct += CHANS_PER_PORT;
 		}
 		spin_lock_init(&subpriv->intr.spinlock);
-
-		chans_left -= s->n_chan;
-
-		if (!chans_left) {
-			/* reset to our first asic, to do intr subdevs */
-			asic = 0;
-			port = 0;
-		}
-
 	}
 
 	init_asics(dev);	/* clear out all the registers, basically */

commit d4fd9a5861b2349855e02d403b108dc98cdda022
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:23:21 2013 -0700

    staging: comedi: pcmuio: remove unused boardinfo
    
    These members of the boardinfo are not used by the driver. Remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 2e08e661d7ef..85a64807a073 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -128,19 +128,15 @@
 struct pcmuio_board {
 	const char *name;
 	const int num_asics;
-	const int num_channels_per_port;
-	const int num_ports;
 };
 
 static const struct pcmuio_board pcmuio_boards[] = {
 	{
 		.name		= "pcmuio48",
 		.num_asics	= 1,
-		.num_ports	= 6,
 	}, {
 		.name		= "pcmuio96",
 		.num_asics	= 2,
-		.num_ports	= 12,
 	},
 };
 

commit eddb297edcba5ae1ff128a76e1984d5e9681ecf6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:23:02 2013 -0700

    staging: comedi: pcmuio: kzalloc'ed data does not need cleared
    
    The 'subpriv' pointer is kzalloc'ed during the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b348e2c3d3e5..2e08e661d7ef 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -713,7 +713,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_config = pcmuio_dio_insn_config;
 		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->intr.asic = -1;
-		subpriv->intr.active = 0;
 		s->len_chanlist = 1;
 
 		/* save the ioport address for each 'port' of 8 channels in the
@@ -733,8 +732,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			    && subpriv->intr.asic < 0) {
 				/* setup the interrupt subdevice */
 				subpriv->intr.asic = asic;
-				subpriv->intr.active = 0;
-				subpriv->intr.stop_count = 0;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;

commit 43d70ce9ac772647baf8aadef1aa0f071bfe7f36
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:22:42 2013 -0700

    staging: comedi: pcmuio: remove 'asic_chan'
    
    This member of the subdevice private data is always initialize to
    '0' due to the 'thisasic_chanct' always being zero when it is set
    during the attach. Simplify the driver a bit by removing it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e5758814e161..b348e2c3d3e5 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -152,11 +152,6 @@ struct pcmuio_subdev_private {
 	struct {
 		/* if non-negative, this subdev has an interrupt asic */
 		int asic;
-		/*
-		 * if nonnegative, the first channel id with
-		 * respect to the asic that has interrupts
-		 */
-		int asic_chan;
 		/*
 		 * subdev-relative channel mask for channels
 		 * we are interested in
@@ -368,7 +363,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 	if (!subpriv->intr.active)
 		goto done;
 
-	mytrig = triggered >> subpriv->intr.asic_chan;
+	mytrig = triggered;
 	mytrig &= ((0x1 << s->n_chan) - 1);
 
 	if (!(mytrig & subpriv->intr.enabled_mask))
@@ -718,7 +713,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_config = pcmuio_dio_insn_config;
 		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->intr.asic = -1;
-		subpriv->intr.asic_chan = -1;
 		subpriv->intr.active = 0;
 		s->len_chanlist = 1;
 
@@ -741,7 +735,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				subpriv->intr.asic = asic;
 				subpriv->intr.active = 0;
 				subpriv->intr.stop_count = 0;
-				subpriv->intr.asic_chan = thisasic_chanct;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;

commit dbe9c7929c6c0021414d61f85fe4e2f20f069e1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:22:25 2013 -0700

    staging: comedi: pcmuio: remove 'num_asic_chans'
    
    This member of the subdevice private data is always initialize to
    s->n_chan if the subdevice supports interrupts and is only used
    in functions that can be called by the interrupt subdevice.
    
    Simplyfy the driver a bit  by removing it and just using s->n_chan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8771e4b5d4cb..e5758814e161 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -152,11 +152,6 @@ struct pcmuio_subdev_private {
 	struct {
 		/* if non-negative, this subdev has an interrupt asic */
 		int asic;
-		/*
-		 * the number of asic channels in this
-		 * subdev that have interrutps
-		 */
-		int num_asic_chans;
 		/*
 		 * if nonnegative, the first channel id with
 		 * respect to the asic that has interrupts
@@ -374,7 +369,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 		goto done;
 
 	mytrig = triggered >> subpriv->intr.asic_chan;
-	mytrig &= ((0x1 << subpriv->intr.num_asic_chans) - 1);
+	mytrig &= ((0x1 << s->n_chan) - 1);
 
 	if (!(mytrig & subpriv->intr.enabled_mask))
 		goto done;
@@ -517,7 +512,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
-		bits &= ((0x1 << subpriv->intr.num_asic_chans) - 1);
+		bits &= ((0x1 << s->n_chan) - 1);
 		subpriv->intr.enabled_mask = bits;
 
 		/* set pol and enab intrs for this subdev.. */
@@ -724,7 +719,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->intr.asic = -1;
 		subpriv->intr.asic_chan = -1;
-		subpriv->intr.num_asic_chans = -1;
 		subpriv->intr.active = 0;
 		s->len_chanlist = 1;
 
@@ -748,13 +742,12 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				subpriv->intr.active = 0;
 				subpriv->intr.stop_count = 0;
 				subpriv->intr.asic_chan = thisasic_chanct;
-				subpriv->intr.num_asic_chans = s->n_chan;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;
 				s->do_cmd = pcmuio_cmd;
 				s->do_cmdtest = pcmuio_cmdtest;
-				s->len_chanlist = subpriv->intr.num_asic_chans;
+				s->len_chanlist = s->n_chan;
 			}
 			thisasic_chanct += CHANS_PER_PORT;
 		}

commit d9990ceacc39b4320661adf7778538858a5c4bad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:22:07 2013 -0700

    staging: comedi: pcmuio: remove 'first_chan'
    
    This member of the subdevice private data is always initialize to
    '0' due to the 'byte_no' always being zero when it is set during
    the attach. Simplify the driver a bit by removing it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 0e71eacae14b..8771e4b5d4cb 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -152,8 +152,6 @@ struct pcmuio_subdev_private {
 	struct {
 		/* if non-negative, this subdev has an interrupt asic */
 		int asic;
-		/* if nonnegative, the first channel id for interrupts */
-		int first_chan;
 		/*
 		 * the number of asic channels in this
 		 * subdev that have interrutps
@@ -377,7 +375,6 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
 
 	mytrig = triggered >> subpriv->intr.asic_chan;
 	mytrig &= ((0x1 << subpriv->intr.num_asic_chans) - 1);
-	mytrig <<= subpriv->intr.first_chan;
 
 	if (!(mytrig & subpriv->intr.enabled_mask))
 		goto done;
@@ -520,8 +517,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
-		bits &= ((0x1 << subpriv->intr.num_asic_chans) -
-			 1) << subpriv->intr.first_chan;
+		bits &= ((0x1 << subpriv->intr.num_asic_chans) - 1);
 		subpriv->intr.enabled_mask = bits;
 
 		/* set pol and enab intrs for this subdev.. */
@@ -727,7 +723,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_config = pcmuio_dio_insn_config;
 		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->intr.asic = -1;
-		subpriv->intr.first_chan = -1;
 		subpriv->intr.asic_chan = -1;
 		subpriv->intr.num_asic_chans = -1;
 		subpriv->intr.active = 0;
@@ -752,10 +747,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				subpriv->intr.asic = asic;
 				subpriv->intr.active = 0;
 				subpriv->intr.stop_count = 0;
-				subpriv->intr.first_chan = byte_no * 8;
 				subpriv->intr.asic_chan = thisasic_chanct;
-				subpriv->intr.num_asic_chans =
-				    s->n_chan - subpriv->intr.first_chan;
+				subpriv->intr.num_asic_chans = s->n_chan;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;

commit 3de38f258f95b6dc9f614e1f64b8d596a75533e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:21:50 2013 -0700

    staging: comedi: pcmuio: remove unused private data variables
    
    These members of the private data are either not referenced or are set
    but never used by the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index d882bb3c124d..0e71eacae14b 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -125,8 +125,6 @@
 #define PCMUIO48_IOSIZE		ASIC_IOSIZE
 #define PCMUIO96_IOSIZE		(ASIC_IOSIZE * 2)
 
-#define NUM_PAGED_REGS		3
-
 struct pcmuio_board {
 	const char *name;
 	const int num_asics;
@@ -180,11 +178,6 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		/* shadow of POLx registers */
-		unsigned char pol[NUM_PAGED_REGS];
-		/* shadow of ENABx registers */
-		unsigned char enab[NUM_PAGED_REGS];
-		int num;
 		unsigned long iobase;
 		unsigned int irq;
 		spinlock_t spinlock;
@@ -701,7 +694,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->private = devpriv;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}

commit e4eae7c031e3eceed6dbc6358c15d55604fb31cd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:21:30 2013 -0700

    staging: comedi: pcmuio: introduce pcmuio_write()
    
    Introduce a helper function to handle writing a 24-bit value to the
    three 8-bit registers associated with a "port" or "page".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 3c98a00998b0..d882bb3c124d 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -126,8 +126,6 @@
 #define PCMUIO96_IOSIZE		(ASIC_IOSIZE * 2)
 
 #define NUM_PAGED_REGS		3
-#define NUM_PAGES		4
-#define FIRST_PAGED_REG		0x8
 
 struct pcmuio_board {
 	const char *name;
@@ -194,6 +192,24 @@ struct pcmuio_private {
 	struct pcmuio_subdev_private *sprivs;
 };
 
+static void pcmuio_write(struct comedi_device *dev, unsigned int val,
+			 int asic, int page, int port)
+{
+	unsigned long iobase = dev->iobase + (asic * ASIC_IOSIZE);
+
+	if (page == 0) {
+		/* Port registers are valid for any page */
+		outb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));
+		outb((val >> 8) & 0xff, iobase + PCMUIO_PORT_REG(port + 1));
+		outb((val >> 16) & 0xff, iobase + PCMUIO_PORT_REG(port + 2));
+	} else {
+		outb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);
+		outb(val & 0xff, iobase + PCMUIO_PAGE_REG(0));
+		outb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));
+		outb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));
+	}
+}
+
 static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -315,42 +331,27 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 }
 
 static void init_asics(struct comedi_device *dev)
-{				/* sets up an
-				   ASIC chip to defaults */
+{
 	const struct pcmuio_board *board = comedi_board(dev);
 	int asic;
 
 	for (asic = 0; asic < board->num_asics; ++asic) {
-		int port, page;
-		unsigned long baseaddr = dev->iobase + asic * ASIC_IOSIZE;
-
-		switch_page(dev, asic, 0);	/* switch back to page 0 */
-
 		/* first, clear all the DIO port bits */
-		for (port = 0; port < PORTS_PER_ASIC; ++port)
-			outb(0, baseaddr + PCMUIO_PORT_REG(port));
+		pcmuio_write(dev, 0, asic, 0, 0);
+		pcmuio_write(dev, 0, asic, 0, 3);
 
 		/* Next, clear all the paged registers for each page */
-		for (page = 1; page < NUM_PAGES; ++page) {
-			int reg;
-			/* now clear all the paged registers */
-			switch_page(dev, asic, page);
-			for (reg = FIRST_PAGED_REG;
-			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
-				outb(0, baseaddr + reg);
-		}
-
-		/* switch back to default page 0 */
-		switch_page(dev, asic, 0);
+		pcmuio_write(dev, 0, asic, PCMUIO_PAGE_POL, 0);
+		pcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);
+		pcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);
 	}
 }
 
 static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv = s->private;
-	int nports, firstport, asic, port;
+	int asic;
 
 	asic = subpriv->intr.asic;
 	if (asic < 0)
@@ -359,13 +360,9 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 	subpriv->intr.enabled_mask = 0;
 	subpriv->intr.active = 0;
 	s->async->inttrig = NULL;
-	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
-	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, asic, PCMUIO_PAGE_ENAB);
-	for (port = firstport; port < firstport + nports; ++port) {
-		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
-	}
+
+	/* disable all intrs for this subdev.. */
+	pcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);
 }
 
 static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
@@ -503,7 +500,6 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv = s->private;
 
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
@@ -513,7 +509,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 		return 1;
 	} else {
 		unsigned bits = 0, pol_bits = 0, n;
-		int nports, firstport, asic, port;
+		int asic;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
 		asic = subpriv->intr.asic;
@@ -522,8 +518,6 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 					   subdev */
 		subpriv->intr.enabled_mask = 0;
 		subpriv->intr.active = 1;
-		nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
-		firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
 		if (cmd->chanlist) {
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
@@ -537,21 +531,9 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 			 1) << subpriv->intr.first_chan;
 		subpriv->intr.enabled_mask = bits;
 
-		switch_page(dev, asic, PCMUIO_PAGE_ENAB);
-		for (port = firstport; port < firstport + nports; ++port) {
-			unsigned enab =
-			    bits >> (subpriv->intr.first_chan + (port -
-								 firstport) *
-				     8) & 0xff, pol =
-			    pol_bits >> (subpriv->intr.first_chan +
-					 (port - firstport) * 8) & 0xff;
-			/* set enab intrs for this subdev.. */
-			outb(enab,
-			     devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
-			switch_page(dev, asic, PCMUIO_PAGE_POL);
-			outb(pol,
-			     devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
-		}
+		/* set pol and enab intrs for this subdev.. */
+		pcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);
+		pcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);
 	}
 	return 0;
 }

commit 46317da71ee85dccc351735e8b463123f4d448a3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:21:13 2013 -0700

    staging: comedi: pcmuio: tidy up switch_page()
    
    All the I/O ports are left unlocked in the driver so the 'pagelock'
    in the private data is not necessary. The paranoia sanity checks
    are also unnecessary, Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 9fb75a47fb77..3c98a00998b0 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -182,8 +182,6 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		/* current page and lock */
-		unsigned char pagelock;
 		/* shadow of POLx registers */
 		unsigned char pol[NUM_PAGED_REGS];
 		/* shadow of ENABx registers */
@@ -312,19 +310,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
-	const struct pcmuio_board *board = comedi_board(dev);
-	struct pcmuio_private *devpriv = dev->private;
-
-	if (asic < 0 || asic >= board->num_asics)
-		return;		/* paranoia */
-	if (page < 0 || page >= NUM_PAGES)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock &= ~PCMUIO_PAGE_MASK;
-	devpriv->asics[asic].pagelock |= PCMUIO_PAGE(page);
-
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
+	outb(PCMUIO_PAGE(page),
 	     dev->iobase + ASIC_IOSIZE * asic + PCMUIO_PAGE_LOCK_REG);
 }
 

commit f45a1f26eae4cadbfeb65b4b36bfa3583f694066
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:20:51 2013 -0700

    staging: comedi: pcmuio: tidy up the register map defines
    
    Add namespace to the register map defines. Gather them together
    and tidy them up a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 5e7045b29bf1..9fb75a47fb77 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -80,6 +80,34 @@
 
 #include "comedi_fc.h"
 
+/*
+ * Register I/O map
+ *
+ * Offset    Page 0       Page 1       Page 2       Page 3
+ * ------  -----------  -----------  -----------  -----------
+ *  0x00   Port 0 I/O   Port 0 I/O   Port 0 I/O   Port 0 I/O
+ *  0x01   Port 1 I/O   Port 1 I/O   Port 1 I/O   Port 1 I/O
+ *  0x02   Port 2 I/O   Port 2 I/O   Port 2 I/O   Port 2 I/O
+ *  0x03   Port 3 I/O   Port 3 I/O   Port 3 I/O   Port 3 I/O
+ *  0x04   Port 4 I/O   Port 4 I/O   Port 4 I/O   Port 4 I/O
+ *  0x05   Port 5 I/O   Port 5 I/O   Port 5 I/O   Port 5 I/O
+ *  0x06   INT_PENDING  INT_PENDING  INT_PENDING  INT_PENDING
+ *  0x07    Page/Lock    Page/Lock    Page/Lock    Page/Lock
+ *  0x08       N/A         POL_0       ENAB_0       INT_ID0
+ *  0x09       N/A         POL_1       ENAB_1       INT_ID1
+ *  0x0a       N/A         POL_2       ENAB_2       INT_ID2
+ */
+#define PCMUIO_PORT_REG(x)		(0x00 + (x))
+#define PCMUIO_INT_PENDING_REG		0x06
+#define PCMUIO_PAGE_LOCK_REG		0x07
+#define PCMUIO_LOCK_PORT(x)		((1 << (x)) & 0x3f)
+#define PCMUIO_PAGE(x)			(((x) & 0x3) << 6)
+#define PCMUIO_PAGE_MASK		PCMUIO_PAGE(3)
+#define PCMUIO_PAGE_POL			1
+#define PCMUIO_PAGE_ENAB		2
+#define PCMUIO_PAGE_INT_ID		3
+#define PCMUIO_PAGE_REG(x)		(0x08 + (x))
+
 #define CHANS_PER_PORT		8
 #define PORTS_PER_ASIC		6
 #define INTR_PORTS_PER_ASIC	3
@@ -97,53 +125,9 @@
 #define PCMUIO48_IOSIZE		ASIC_IOSIZE
 #define PCMUIO96_IOSIZE		(ASIC_IOSIZE * 2)
 
-/*
- * Some offsets - these are all in the 16byte IO memory offset from
- * the base address.  Note that there is a paging scheme to swap out
- * offsets 0x8-0xA using the PAGELOCK register.  See the table below.
- *
- * Register(s)       Pages        R/W?        Description
- * --------------------------------------------------------------------------
- * REG_PORTx         All          R/W         Read/Write/Configure IO
- * REG_INT_PENDING   All          ReadOnly    Which INT_IDx has int.
- * REG_PAGELOCK      All          WriteOnly   Select a page
- * REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
- * REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect int.
- * REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
- */
-#define REG_PORT0		0x0
-#define REG_PORT1		0x1
-#define REG_PORT2		0x2
-#define REG_PORT3		0x3
-#define REG_PORT4		0x4
-#define REG_PORT5		0x5
-#define REG_INT_PENDING		0x6
-/*
- * page selector register
- * Upper 2 bits select a page and bits 0-5 are used to
- * 'lock down' a particular port above to make it readonly.
- */
-#define REG_PAGELOCK		0x7
-#define REG_POL0		0x8
-#define REG_POL1		0x9
-#define REG_POL2		0xa
-#define REG_ENAB0		0x8
-#define REG_ENAB1		0x9
-#define REG_ENAB2		0xa
-#define REG_INT_ID0		0x8
-#define REG_INT_ID1		0x9
-#define REG_INT_ID2		0xa
-
 #define NUM_PAGED_REGS		3
 #define NUM_PAGES		4
 #define FIRST_PAGED_REG		0x8
-#define REG_PAGE_BITOFFSET	6
-#define REG_LOCK_BITOFFSET	0
-#define REG_PAGE_MASK		(~((0x1 << REG_PAGE_BITOFFSET) - 1))
-#define REG_LOCK_MASK		~(REG_PAGE_MASK)
-#define PAGE_POL		1
-#define PAGE_ENAB		2
-#define PAGE_INT_ID		3
 
 struct pcmuio_board {
 	const char *name;
@@ -336,12 +320,12 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 	if (page < 0 || page >= NUM_PAGES)
 		return;		/* more paranoia */
 
-	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
-	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
+	devpriv->asics[asic].pagelock &= ~PCMUIO_PAGE_MASK;
+	devpriv->asics[asic].pagelock |= PCMUIO_PAGE(page);
 
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + PCMUIO_PAGE_LOCK_REG);
 }
 
 static void init_asics(struct comedi_device *dev)
@@ -358,7 +342,7 @@ static void init_asics(struct comedi_device *dev)
 
 		/* first, clear all the DIO port bits */
 		for (port = 0; port < PORTS_PER_ASIC; ++port)
-			outb(0, baseaddr + REG_PORT0 + port);
+			outb(0, baseaddr + PCMUIO_PORT_REG(port));
 
 		/* Next, clear all the paged registers for each page */
 		for (page = 1; page < NUM_PAGES; ++page) {
@@ -370,13 +354,6 @@ static void init_asics(struct comedi_device *dev)
 				outb(0, baseaddr + reg);
 		}
 
-		/* DEBUG  set rising edge interrupts on port0 of both asics */
-		/*switch_page(dev, asic, PAGE_POL);
-		   outb(0xff, baseaddr + REG_POL0);
-		   switch_page(dev, asic, PAGE_ENAB);
-		   outb(0xff, baseaddr + REG_ENAB0); */
-		/* END DEBUG */
-
 		/* switch back to default page 0 */
 		switch_page(dev, asic, 0);
 	}
@@ -398,10 +375,10 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
 	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, asic, PAGE_ENAB);
+	switch_page(dev, asic, PCMUIO_PAGE_ENAB);
 	for (port = firstport; port < firstport + nports; ++port) {
 		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+		outb(0, devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
 	}
 }
 
@@ -478,17 +455,17 @@ static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 
 	spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
 
-	int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
+	int_pend = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;
 	if (int_pend) {
 		for (i = 0; i < INTR_PORTS_PER_ASIC; ++i) {
 			if (int_pend & (0x1 << i)) {
 				unsigned char val;
 
-				switch_page(dev, asic, PAGE_INT_ID);
-				val = inb(iobase + REG_INT_ID0 + i);
+				switch_page(dev, asic, PCMUIO_PAGE_INT_ID);
+				val = inb(iobase + PCMUIO_PAGE_REG(i));
 				if (val)
 					/* clear pending interrupt */
-					outb(0, iobase + REG_INT_ID0 + i);
+					outb(0, iobase + PCMUIO_PAGE_REG(i));
 
 					triggered |= (val << (i * 8));
 			}
@@ -574,7 +551,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 			 1) << subpriv->intr.first_chan;
 		subpriv->intr.enabled_mask = bits;
 
-		switch_page(dev, asic, PAGE_ENAB);
+		switch_page(dev, asic, PCMUIO_PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
 			    bits >> (subpriv->intr.first_chan + (port -
@@ -584,10 +561,10 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab,
-			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
-			switch_page(dev, asic, PAGE_POL);
+			     devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
+			switch_page(dev, asic, PCMUIO_PAGE_POL);
 			outb(pol,
-			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + PCMUIO_PAGE_REG(port));
 		}
 	}
 	return 0;

commit 75ec11370ec4bbc144af9a412d7eeb578e7b3d59
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 18 13:20:29 2013 -0700

    staging: comedi: pcmuio: remove unused {lock,unlock}_port()
    
    These functions are #ifdef'ed out and not needed in the driver.
    Just remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 9a560a36f1f5..5e7045b29bf1 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -382,39 +382,6 @@ static void init_asics(struct comedi_device *dev)
 	}
 }
 
-#ifdef notused
-static void lock_port(struct comedi_device *dev, int asic, int port)
-{
-	const struct pcmuio_board *board = comedi_board(dev);
-	struct pcmuio_private *devpriv = dev->private;
-
-	if (asic < 0 || asic >= board->num_asics)
-		return;		/* paranoia */
-	if (port < 0 || port >= PORTS_PER_ASIC)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock |= 0x1 << port;
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
-}
-
-static void unlock_port(struct comedi_device *dev, int asic, int port)
-{
-	const struct pcmuio_board *board = comedi_board(dev);
-	struct pcmuio_private *devpriv = dev->private;
-
-	if (asic < 0 || asic >= board->num_asics)
-		return;		/* paranoia */
-	if (port < 0 || port >= PORTS_PER_ASIC)
-		return;		/* more paranoia */
-	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
-}
-#endif /* notused */
-
 static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {

commit 6d28bea92c27c383dd224ca6327d84d0dde2e770
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:04:33 2013 -0700

    staging: comedi: pcmuio: fix the last > 80 char line warning
    
    Fix the last checkpatch.pl warning in this file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index d73b491d3a3f..9a560a36f1f5 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -831,7 +831,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		/* save the ioport address for each 'port' of 8 channels in the
 		   subdevice */
-		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
+		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV;
+		     ++byte_no, ++port) {
 			if (port >= PORTS_PER_ASIC) {
 				port = 0;
 				++asic;

commit dff57e86d1f4ea82bafab7db0906cce092765c4b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:04:13 2013 -0700

    staging: comedi: pcmuio: remove the pcmuio_dio_insn_bits() debug noise
    
    These dev_dbg() and printk() messages are just development noise.
    Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8501fd272932..d73b491d3a3f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -230,12 +230,6 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 
-#ifdef DAMMIT_ITS_BROKEN
-	/* DEBUG */
-	dev_dbg(dev->class_dev, "write mask: %08x  data: %08x\n", data[0],
-		data[1]);
-#endif
-
 	s->state = 0;
 
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
@@ -252,23 +246,11 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
-#ifdef DAMMIT_ITS_BROKEN
-		/* DEBUG */
-		printk
-		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
-		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
-		     offset, ioaddr, (unsigned)byte);
-#endif
-
 		if (write_mask_byte) {
 			byte &= ~write_mask_byte;
 			byte |= ~data_byte & write_mask_byte;
 			outb(byte, ioaddr);
 		}
-#ifdef DAMMIT_ITS_BROKEN
-		/* DEBUG */
-		dev_dbg(dev->class_dev, "data_out_byte %02x\n", (unsigned)byte);
-#endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
 	}
@@ -276,12 +258,6 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 	/* now return the DIO lines to data[1] - note they came inverted! */
 	data[1] = ~s->state;
 
-#ifdef DAMMIT_ITS_BROKEN
-	/* DEBUG */
-	dev_dbg(dev->class_dev, "s->state %08x data_out %08x\n", s->state,
-		data[1]);
-#endif
-
 	return insn->n;
 }
 

commit 365c473e1da54e209aa8c01da2084c896f18fb20
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:03:50 2013 -0700

    staging: comedi: pcmuio: fix > 80 char line warnings
    
    Cleanup some comments to fix the checkpatch.pl warnings about lines
    over 80 characters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index ff07d7010977..8501fd272932 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -170,15 +170,25 @@ struct pcmuio_subdev_private {
 
 	/* The below is only used for intr subdevices */
 	struct {
-		int asic;	/* if non-negative, this subdev has an interrupt asic */
-		int first_chan;	/* if nonnegative, the first channel id for
-				   interrupts. */
-		int num_asic_chans;	/* the number of asic channels in this subdev
-					   that have interrutps */
-		int asic_chan;	/* if nonnegative, the first channel id with
-				   respect to the asic that has interrupts */
-		int enabled_mask;	/* subdev-relative channel mask for channels
-					   we are interested in */
+		/* if non-negative, this subdev has an interrupt asic */
+		int asic;
+		/* if nonnegative, the first channel id for interrupts */
+		int first_chan;
+		/*
+		 * the number of asic channels in this
+		 * subdev that have interrutps
+		 */
+		int num_asic_chans;
+		/*
+		 * if nonnegative, the first channel id with
+		 * respect to the asic that has interrupts
+		 */
+		int asic_chan;
+		/*
+		 * subdev-relative channel mask for channels
+		 * we are interested in
+		 */
+		int enabled_mask;
 		int active;
 		int stop_count;
 		int continuous;
@@ -188,9 +198,12 @@ struct pcmuio_subdev_private {
 
 struct pcmuio_private {
 	struct {
-		unsigned char pagelock;	/* current page and lock */
-		unsigned char pol[NUM_PAGED_REGS];	/* shadow of POLx registers */
-		unsigned char enab[NUM_PAGED_REGS];	/* shadow of ENABx registers */
+		/* current page and lock */
+		unsigned char pagelock;
+		/* shadow of POLx registers */
+		unsigned char pol[NUM_PAGED_REGS];
+		/* shadow of ENABx registers */
+		unsigned char enab[NUM_PAGED_REGS];
 		int num;
 		unsigned long iobase;
 		unsigned int irq;
@@ -248,10 +261,8 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 #endif
 
 		if (write_mask_byte) {
-			/* this byte has some write_bits -- so set the output lines */
-			byte &= ~write_mask_byte;	/* clear bits for write mask */
-			byte |= ~data_byte & write_mask_byte;	/* set to inverted data_byte */
-			/* Write out the new digital output state */
+			byte &= ~write_mask_byte;
+			byte |= ~data_byte & write_mask_byte;
 			outb(byte, ioaddr);
 		}
 #ifdef DAMMIT_ITS_BROKEN
@@ -312,9 +323,12 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 		byte &= ~(1 << bit_no);
 				/**< set input channel to '0' */
 
-		/* write out byte -- this is the only time we actually affect the
-		   hardware as all channels are implicitly output -- but input
-		   channels are set to float-high */
+		/*
+		 * write out byte
+		 * This is the only time we actually affect the hardware
+		 * as all channels are implicitly output -- but input
+		 * channels are set to float-high.
+		 */
 		outb(byte, ioaddr);
 
 		/* save to io_bits */
@@ -387,8 +401,8 @@ static void init_asics(struct comedi_device *dev)
 		   outb(0xff, baseaddr + REG_ENAB0); */
 		/* END DEBUG */
 
-		switch_page(dev, asic, 0);	/* switch back to default page 0 */
-
+		/* switch back to default page 0 */
+		switch_page(dev, asic, 0);
 	}
 }
 
@@ -801,9 +815,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;
 		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
-		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
-						   this function when we
-						   request_irqs */
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -856,7 +867,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (thisasic_chanct <
 			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
 			    && subpriv->intr.asic < 0) {
-				/* this is an interrupt subdevice, so setup the struct */
+				/* setup the interrupt subdevice */
 				subpriv->intr.asic = asic;
 				subpriv->intr.active = 0;
 				subpriv->intr.stop_count = 0;
@@ -878,7 +889,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		chans_left -= s->n_chan;
 
 		if (!chans_left) {
-			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
+			/* reset to our first asic, to do intr subdevs */
+			asic = 0;
 			port = 0;
 		}
 

commit 9145e217678c067f03fa713d4c2a6306a3b7461a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:03:31 2013 -0700

    staging: comedi: pcmuio: remove some boilerplate comments
    
    These comments are boilerplate from the 'skel' driver. Just remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 02ffc78e9900..ff07d7010977 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -164,7 +164,6 @@ static const struct pcmuio_board pcmuio_boards[] = {
 	},
 };
 
-/* this structure is for data unique to this subdevice.  */
 struct pcmuio_subdev_private {
 	/* mapping of halfwords (bytes) in port/chanarray to iobase */
 	unsigned long iobases[PORTS_PER_SUBDEV];
@@ -187,9 +186,6 @@ struct pcmuio_subdev_private {
 	} intr;
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pcmuio_private {
 	struct {
 		unsigned char pagelock;	/* current page and lock */
@@ -203,11 +199,6 @@ struct pcmuio_private {
 	struct pcmuio_subdev_private *sprivs;
 };
 
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The
- * comedi core can convert between insn_bits and insn_read/write */
 static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -283,10 +274,6 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* The input or output configuration of each digital line is
- * configured by a special insn_config instruction.  chanspec
- * contains the channel to be changed, and data[0] contains the
- * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)

commit fbe3bb17b9f9e18b771c30449916807c4c25e308
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:03:12 2013 -0700

    staging: comedi: pcmuio: tidy up the boardinfo
    
    Remove the boilerplate comment about the boardinfo struct.
    
    For aesthetic reasons, move the boardinfo declaration near the
    struct definition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 79a4d11a5c1c..02ffc78e9900 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -145,11 +145,6 @@
 #define PAGE_ENAB		2
 #define PAGE_INT_ID		3
 
-/*
- * Board descriptions for two imaginary boards.  Describing the
- * boards in this way is optional, and completely driver-dependent.
- * Some drivers use arrays such as this, other do not.
- */
 struct pcmuio_board {
 	const char *name;
 	const int num_asics;
@@ -157,6 +152,18 @@ struct pcmuio_board {
 	const int num_ports;
 };
 
+static const struct pcmuio_board pcmuio_boards[] = {
+	{
+		.name		= "pcmuio48",
+		.num_asics	= 1,
+		.num_ports	= 6,
+	}, {
+		.name		= "pcmuio96",
+		.num_asics	= 2,
+		.num_ports	= 12,
+	},
+};
+
 /* this structure is for data unique to this subdevice.  */
 struct pcmuio_subdev_private {
 	/* mapping of halfwords (bytes) in port/chanarray to iobase */
@@ -934,18 +941,6 @@ static void pcmuio_detach(struct comedi_device *dev)
 	comedi_legacy_detach(dev);
 }
 
-static const struct pcmuio_board pcmuio_boards[] = {
-	{
-		.name		= "pcmuio48",
-		.num_asics	= 1,
-		.num_ports	= 6,
-	}, {
-		.name		= "pcmuio96",
-		.num_asics	= 2,
-		.num_ports	= 12,
-	},
-};
-
 static struct comedi_driver pcmuio_driver = {
 	.driver_name	= "pcmuio",
 	.module		= THIS_MODULE,

commit 288201328ba804a5630c7a460534e668703f114f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:02:52 2013 -0700

    staging: comedi: pcmuio: tidy up driver #define's
    
    Add some whitespace to the #defines to make them more readable.
    Tidy up the comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8ce7e538d77e..79a4d11a5c1c 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -80,64 +80,70 @@
 
 #include "comedi_fc.h"
 
-#define CHANS_PER_PORT   8
-#define PORTS_PER_ASIC   6
-#define INTR_PORTS_PER_ASIC   3
-#define MAX_CHANS_PER_SUBDEV 24	/* number of channels per comedi subdevice */
-#define PORTS_PER_SUBDEV (MAX_CHANS_PER_SUBDEV/CHANS_PER_PORT)
-#define CHANS_PER_ASIC (CHANS_PER_PORT*PORTS_PER_ASIC)
-#define INTR_CHANS_PER_ASIC 24
-#define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
-#define MAX_DIO_CHANS   (PORTS_PER_ASIC*2*CHANS_PER_PORT)
-#define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
+#define CHANS_PER_PORT		8
+#define PORTS_PER_ASIC		6
+#define INTR_PORTS_PER_ASIC	3
+/* number of channels per comedi subdevice */
+#define MAX_CHANS_PER_SUBDEV	24
+#define PORTS_PER_SUBDEV	(MAX_CHANS_PER_SUBDEV / CHANS_PER_PORT)
+#define CHANS_PER_ASIC		(CHANS_PER_PORT * PORTS_PER_ASIC)
+#define INTR_CHANS_PER_ASIC	24
+#define INTR_PORTS_PER_SUBDEV	(INTR_CHANS_PER_ASIC / CHANS_PER_PORT)
+#define MAX_DIO_CHANS		(PORTS_PER_ASIC * 2 * CHANS_PER_PORT)
+#define MAX_ASICS		(MAX_DIO_CHANS / CHANS_PER_ASIC)
+
 /* IO Memory sizes */
-#define ASIC_IOSIZE (0x10)
-#define PCMUIO48_IOSIZE ASIC_IOSIZE
-#define PCMUIO96_IOSIZE (ASIC_IOSIZE*2)
-
-/* Some offsets - these are all in the 16byte IO memory offset from
-   the base address.  Note that there is a paging scheme to swap out
-   offsets 0x8-0xA using the PAGELOCK register.  See the table below.
-
-  Register(s)       Pages        R/W?        Description
-  --------------------------------------------------------------
-  REG_PORTx         All          R/W         Read/Write/Configure IO
-  REG_INT_PENDING   All          ReadOnly    Quickly see which INT_IDx has int.
-  REG_PAGELOCK      All          WriteOnly   Select a page
-  REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
-  REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect. int.
-  REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
+#define ASIC_IOSIZE		0x10
+#define PCMUIO48_IOSIZE		ASIC_IOSIZE
+#define PCMUIO96_IOSIZE		(ASIC_IOSIZE * 2)
+
+/*
+ * Some offsets - these are all in the 16byte IO memory offset from
+ * the base address.  Note that there is a paging scheme to swap out
+ * offsets 0x8-0xA using the PAGELOCK register.  See the table below.
+ *
+ * Register(s)       Pages        R/W?        Description
+ * --------------------------------------------------------------------------
+ * REG_PORTx         All          R/W         Read/Write/Configure IO
+ * REG_INT_PENDING   All          ReadOnly    Which INT_IDx has int.
+ * REG_PAGELOCK      All          WriteOnly   Select a page
+ * REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
+ * REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect int.
+ * REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
+ */
+#define REG_PORT0		0x0
+#define REG_PORT1		0x1
+#define REG_PORT2		0x2
+#define REG_PORT3		0x3
+#define REG_PORT4		0x4
+#define REG_PORT5		0x5
+#define REG_INT_PENDING		0x6
+/*
+ * page selector register
+ * Upper 2 bits select a page and bits 0-5 are used to
+ * 'lock down' a particular port above to make it readonly.
  */
-#define REG_PORT0 0x0
-#define REG_PORT1 0x1
-#define REG_PORT2 0x2
-#define REG_PORT3 0x3
-#define REG_PORT4 0x4
-#define REG_PORT5 0x5
-#define REG_INT_PENDING 0x6
-#define REG_PAGELOCK 0x7	/* page selector register, upper 2 bits select a page
-				   and bits 0-5 are used to 'lock down' a particular
-				   port above to make it readonly.  */
-#define REG_POL0 0x8
-#define REG_POL1 0x9
-#define REG_POL2 0xA
-#define REG_ENAB0 0x8
-#define REG_ENAB1 0x9
-#define REG_ENAB2 0xA
-#define REG_INT_ID0 0x8
-#define REG_INT_ID1 0x9
-#define REG_INT_ID2 0xA
-
-#define NUM_PAGED_REGS 3
-#define NUM_PAGES 4
-#define FIRST_PAGED_REG 0x8
-#define REG_PAGE_BITOFFSET 6
-#define REG_LOCK_BITOFFSET 0
-#define REG_PAGE_MASK (~((0x1<<REG_PAGE_BITOFFSET)-1))
-#define REG_LOCK_MASK ~(REG_PAGE_MASK)
-#define PAGE_POL 1
-#define PAGE_ENAB 2
-#define PAGE_INT_ID 3
+#define REG_PAGELOCK		0x7
+#define REG_POL0		0x8
+#define REG_POL1		0x9
+#define REG_POL2		0xa
+#define REG_ENAB0		0x8
+#define REG_ENAB1		0x9
+#define REG_ENAB2		0xa
+#define REG_INT_ID0		0x8
+#define REG_INT_ID1		0x9
+#define REG_INT_ID2		0xa
+
+#define NUM_PAGED_REGS		3
+#define NUM_PAGES		4
+#define FIRST_PAGED_REG		0x8
+#define REG_PAGE_BITOFFSET	6
+#define REG_LOCK_BITOFFSET	0
+#define REG_PAGE_MASK		(~((0x1 << REG_PAGE_BITOFFSET) - 1))
+#define REG_LOCK_MASK		~(REG_PAGE_MASK)
+#define PAGE_POL		1
+#define PAGE_ENAB		2
+#define PAGE_INT_ID		3
 
 /*
  * Board descriptions for two imaginary boards.  Describing the

commit 00b863964d3d24e7ae1dfb571e45707136c6cf42
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:02:34 2013 -0700

    staging: comedi: pcmuio: remove 'CALC_N_SUBDEVS' macro
    
    This macro is only used once in the driver, just remove it.
    
    This also fixes a > 80 char line checkpatch.pl warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 9d8b78015cbb..8ce7e538d77e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -90,7 +90,6 @@
 #define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
 #define MAX_DIO_CHANS   (PORTS_PER_ASIC*2*CHANS_PER_PORT)
 #define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
-#define CALC_N_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
 /* IO Memory sizes */
 #define ASIC_IOSIZE (0x10)
 #define PCMUIO48_IOSIZE ASIC_IOSIZE
@@ -809,7 +808,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	chans_left = CHANS_PER_ASIC * board->num_asics;
-	n_subdevs = CALC_N_SUBDEVS(chans_left);
+	n_subdevs = (chans_left / MAX_CHANS_PER_SUBDEV) +
+		    (!!(chans_left % MAX_CHANS_PER_SUBDEV));
 	devpriv->sprivs = kcalloc(n_subdevs,
 				  sizeof(struct pcmuio_subdev_private),
 				  GFP_KERNEL);

commit 9e1087b5ae4c31c812e3f8a35256d7922a1cdbd6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:02:07 2013 -0700

    staging: comedi: pcmuio: tidy up the multi-line comments
    
    Tidy up the multi-line comments at the beginning of the file to
    follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 15c8a9af5570..9d8b78015cbb 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -1,75 +1,77 @@
 /*
-    comedi/drivers/pcmuio.c
-    Driver for Winsystems PC-104 based 48-channel and 96-channel DIO boards.
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2006 Calin A. Culianu <calin@ajvar.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * pcmuio.c
+ * Comedi driver for Winsystems PC-104 based 48/96-channel DIO boards.
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2006 Calin A. Culianu <calin@ajvar.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
 /*
-Driver: pcmuio
-Description: A driver for the PCM-UIO48A and PCM-UIO96A boards from Winsystems.
-Devices: [Winsystems] PCM-UIO48A (pcmuio48), PCM-UIO96A (pcmuio96)
-Author: Calin Culianu <calin@ajvar.org>
-Updated: Fri, 13 Jan 2006 12:01:01 -0500
-Status: works
-
-A driver for the relatively straightforward-to-program PCM-UIO48A and
-PCM-UIO96A boards from Winsystems.  These boards use either one or two
-(in the 96-DIO version) WS16C48 ASIC HighDensity I/O Chips (HDIO).
-This chip is interesting in that each I/O line is individually
-programmable for INPUT or OUTPUT (thus comedi_dio_config can be done
-on a per-channel basis).  Also, each chip supports edge-triggered
-interrupts for the first 24 I/O lines.  Of course, since the
-96-channel version of the board has two ASICs, it can detect polarity
-changes on up to 48 I/O lines.  Since this is essentially an (non-PnP)
-ISA board, I/O Address and IRQ selection are done through jumpers on
-the board.  You need to pass that information to this driver as the
-first and second comedi_config option, respectively.  Note that the
-48-channel version uses 16 bytes of IO memory and the 96-channel
-version uses 32-bytes (in case you are worried about conflicts).  The
-48-channel board is split into two 24-channel comedi subdevices.
-The 96-channel board is split into 4 24-channel DIO subdevices.
-
-Note that IRQ support has been added, but it is untested.
-
-To use edge-detection IRQ support, pass the IRQs of both ASICS
-(for the 96 channel version) or just 1 ASIC (for 48-channel version).
-Then, use use comedi_commands with TRIG_NOW.
-Your callback will be called each time an edge is triggered, and the data
-values will be two sample_t's, which should be concatenated to form one
-32-bit unsigned int.  This value is the mask of channels that had
-edges detected from your channel list.  Note that the bits positions
-in the mask correspond to positions in your chanlist when you specified
-the command and *not* channel id's!
-
-To set the polarity of the edge-detection interrupts pass a nonzero value for
-either CR_RANGE or CR_AREF for edge-up polarity, or a zero value for both
-CR_RANGE and CR_AREF if you want edge-down polarity.
-
-In the 48-channel version:
-
-On subdev 0, the first 24 channels channels are edge-detect channels.
-
-In the 96-channel board you have the collowing channels that can do edge detection:
-
-subdev 0, channels 0-24  (first 24 channels of 1st ASIC)
-subdev 2, channels 0-24  (first 24 channels of 2nd ASIC)
-
-Configuration Options:
-  [0] - I/O port base address
-  [1] - IRQ (for first ASIC, or first 24 channels)
-  [2] - IRQ for second ASIC (pcmuio96 only - IRQ for chans 48-72 .. can be the same as first irq!)
-*/
+ * Driver: pcmuio
+ * Description: Winsystems PC-104 based 48/96-channel DIO boards.
+ * Devices: (Winsystems) PCM-UIO48A [pcmuio48]
+ *	    (Winsystems) PCM-UIO96A [pcmuio96]
+ * Author: Calin Culianu <calin@ajvar.org>
+ * Updated: Fri, 13 Jan 2006 12:01:01 -0500
+ * Status: works
+ *
+ * A driver for the relatively straightforward-to-program PCM-UIO48A and
+ * PCM-UIO96A boards from Winsystems. These boards use either one or two
+ * (in the 96-DIO version) WS16C48 ASIC HighDensity I/O Chips (HDIO). This
+ * chip is interesting in that each I/O line is individually programmable
+ * for INPUT or OUTPUT (thus comedi_dio_config can be done on a per-channel
+ * basis). Also, each chip supports edge-triggered interrupts for the first
+ * 24 I/O lines. Of course, since the 96-channel version of the board has
+ * two ASICs, it can detect polarity changes on up to 48 I/O lines. Since
+ * this is essentially an (non-PnP) ISA board, I/O Address and IRQ selection
+ * are done through jumpers on the board. You need to pass that information
+ * to this driver as the first and second comedi_config option, respectively.
+ * Note that the 48-channel version uses 16 bytes of IO memory and the 96-
+ * channel version uses 32-bytes (in case you are worried about conflicts).
+ * The 48-channel board is split into two 24-channel comedi subdevices. The
+ * 96-channel board is split into 4 24-channel DIO subdevices.
+ *
+ * Note that IRQ support has been added, but it is untested.
+ *
+ * To use edge-detection IRQ support, pass the IRQs of both ASICS (for the
+ * 96 channel version) or just 1 ASIC (for 48-channel version). Then, use
+ * comedi_commands with TRIG_NOW. Your callback will be called each time an
+ * edge is triggered, and the data values will be two sample_t's, which
+ * should be concatenated to form one 32-bit unsigned int.  This value is
+ * the mask of channels that had edges detected from your channel list. Note
+ * that the bits positions in the mask correspond to positions in your
+ * chanlist when you specified the command and *not* channel id's!
+ *
+ * To set the polarity of the edge-detection interrupts pass a nonzero value
+ * for either CR_RANGE or CR_AREF for edge-up polarity, or a zero value for
+ * both CR_RANGE and CR_AREF if you want edge-down polarity.
+ *
+ * In the 48-channel version:
+ *
+ * On subdev 0, the first 24 channels channels are edge-detect channels.
+ *
+ * In the 96-channel board you have the following channels that can do edge
+ * detection:
+ *
+ * subdev 0, channels 0-24  (first 24 channels of 1st ASIC)
+ * subdev 2, channels 0-24  (first 24 channels of 2nd ASIC)
+ *
+ * Configuration Options:
+ *  [0] - I/O port base address
+ *  [1] - IRQ (for first ASIC, or first 24 channels)
+ *  [2] - IRQ (for second ASIC, pcmuio96 only - IRQ for chans 48-72
+ *             can be the same as first irq!)
+ */
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>

commit 3b48c535802eb515069b4f2ff26f0601eabf51b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:01:37 2013 -0700

    staging: comedi: pcmuio: refactor interrupt_pcmuio()
    
    Refactor this function into two new functions in order to reduce the indent
    levels and clean up the ugly line breaks that, unsuccessfully, try to keep
    the lines < 80 chars.
    
    The first function handles the irq for a specific asic.
    
    The second function handles the irq for a specific subdevice that is
    associated with the asic.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index f7f27623ccae..15c8a9af5570 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -447,154 +447,131 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 	}
 }
 
-static irqreturn_t interrupt_pcmuio(int irq, void *d)
+static void pcmuio_handle_intr_subdev(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned triggered)
+{
+	struct pcmuio_subdev_private *subpriv = s->private;
+	unsigned int len = s->async->cmd.chanlist_len;
+	unsigned oldevents = s->async->events;
+	unsigned int val = 0;
+	unsigned long flags;
+	unsigned mytrig;
+	unsigned int i;
+
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+
+	if (!subpriv->intr.active)
+		goto done;
+
+	mytrig = triggered >> subpriv->intr.asic_chan;
+	mytrig &= ((0x1 << subpriv->intr.num_asic_chans) - 1);
+	mytrig <<= subpriv->intr.first_chan;
+
+	if (!(mytrig & subpriv->intr.enabled_mask))
+		goto done;
+
+	for (i = 0; i < len; i++) {
+		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]);
+		if (mytrig & (1U << chan))
+			val |= (1U << i);
+	}
+
+	/* Write the scan to the buffer. */
+	if (comedi_buf_put(s->async, ((short *)&val)[0]) &&
+	    comedi_buf_put(s->async, ((short *)&val)[1])) {
+		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	} else {
+		/* Overflow! Stop acquisition!! */
+		/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+		pcmuio_stop_intr(dev, s);
+	}
+
+	/* Check for end of acquisition. */
+	if (!subpriv->intr.continuous) {
+		/* stop_src == TRIG_COUNT */
+		if (subpriv->intr.stop_count > 0) {
+			subpriv->intr.stop_count--;
+			if (subpriv->intr.stop_count == 0) {
+				s->async->events |= COMEDI_CB_EOA;
+				/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+				pcmuio_stop_intr(dev, s);
+			}
+		}
+	}
+
+done:
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+
+	if (oldevents != s->async->events)
+		comedi_event(dev, s);
+}
+
+static int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)
 {
-	struct comedi_device *dev = (struct comedi_device *)d;
 	struct pcmuio_private *devpriv = dev->private;
 	struct pcmuio_subdev_private *subpriv;
-	int asic, got1 = 0;
+	unsigned long iobase = devpriv->asics[asic].iobase;
+	unsigned triggered = 0;
+	int got1 = 0;
+	unsigned long flags;
+	unsigned char int_pend;
 	int i;
 
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		if (irq == devpriv->asics[asic].irq) {
-			unsigned long flags;
-			unsigned triggered = 0;
-			unsigned long iobase = devpriv->asics[asic].iobase;
-			/* it is an interrupt for ASIC #asic */
-			unsigned char int_pend;
-
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-					  flags);
-
-			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
-
-			if (int_pend) {
-				int port;
-				for (port = 0; port < INTR_PORTS_PER_ASIC;
-				     ++port) {
-					if (int_pend & (0x1 << port)) {
-						unsigned char
-						    io_lines_with_edges = 0;
-						switch_page(dev, asic,
-							    PAGE_INT_ID);
-						io_lines_with_edges =
-						    inb(iobase +
-							REG_INT_ID0 + port);
-
-						if (io_lines_with_edges)
-							/* clear pending interrupt */
-							outb(0, iobase +
-							     REG_INT_ID0 +
-							     port);
-
-						triggered |=
-						    io_lines_with_edges <<
-						    port * 8;
-					}
-				}
-
-				++got1;
+	spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
+
+	int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
+	if (int_pend) {
+		for (i = 0; i < INTR_PORTS_PER_ASIC; ++i) {
+			if (int_pend & (0x1 << i)) {
+				unsigned char val;
+
+				switch_page(dev, asic, PAGE_INT_ID);
+				val = inb(iobase + REG_INT_ID0 + i);
+				if (val)
+					/* clear pending interrupt */
+					outb(0, iobase + REG_INT_ID0 + i);
+
+					triggered |= (val << (i * 8));
 			}
+		}
+
+		++got1;
+	}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
-					       flags);
-
-			if (triggered) {
-				struct comedi_subdevice *s;
-				/* TODO here: dispatch io lines to subdevs with commands.. */
-				printk
-				    ("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
-				     irq, asic, triggered);
-				for (i = 0; i < dev->n_subdevices; i++) {
-					s = &dev->subdevices[i];
-					subpriv = s->private;
-					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
-						unsigned long flags;
-						unsigned oldevents;
-
-						spin_lock_irqsave(&subpriv->
-								  intr.spinlock,
-								  flags);
-
-						oldevents = s->async->events;
-
-						if (subpriv->intr.active) {
-							unsigned mytrig =
-							    ((triggered >>
-							      subpriv->intr.asic_chan)
-							     &
-							     ((0x1 << subpriv->
-							       intr.
-							       num_asic_chans) -
-							      1)) << subpriv->
-							    intr.first_chan;
-							if (mytrig &
-							    subpriv->intr.enabled_mask)
-							{
-								unsigned int val
-								    = 0;
-								unsigned int n,
-								    ch, len;
-
-								len =
-								    s->
-								    async->cmd.chanlist_len;
-								for (n = 0;
-								     n < len;
-								     n++) {
-									ch = CR_CHAN(s->async->cmd.chanlist[n]);
-									if (mytrig & (1U << ch)) {
-										val |= (1U << n);
-									}
-								}
-								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *)&val)[0])
-								    &&
-								    comedi_buf_put
-								    (s->async,
-								     ((short *)
-								      &val)[1]))
-								{
-									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-								} else {
-									/* Overflow! Stop acquisition!! */
-									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-									pcmuio_stop_intr
-									    (dev,
-									     s);
-								}
-
-								/* Check for end of acquisition. */
-								if (!subpriv->intr.continuous) {
-									/* stop_src == TRIG_COUNT */
-									if (subpriv->intr.stop_count > 0) {
-										subpriv->intr.stop_count--;
-										if (subpriv->intr.stop_count == 0) {
-											s->async->events |= COMEDI_CB_EOA;
-											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
-											pcmuio_stop_intr
-											    (dev,
-											     s);
-										}
-									}
-								}
-							}
-						}
-
-						spin_unlock_irqrestore
-						    (&subpriv->intr.spinlock,
-						     flags);
-
-						if (oldevents !=
-						    s->async->events) {
-							comedi_event(dev, s);
-						}
-
-					}
-
-				}
+	spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
+
+	if (triggered) {
+		struct comedi_subdevice *s;
+		/* TODO here: dispatch io lines to subdevs with commands.. */
+		for (i = 0; i < dev->n_subdevices; i++) {
+			s = &dev->subdevices[i];
+			subpriv = s->private;
+			if (subpriv->intr.asic == asic) {
+				/*
+				 * This is an interrupt subdev, and it
+				 * matches this asic!
+				 */
+				pcmuio_handle_intr_subdev(dev, s,
+							  triggered);
 			}
+		}
+	}
+	return got1;
+}
 
+static irqreturn_t interrupt_pcmuio(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	struct pcmuio_private *devpriv = dev->private;
+	int got1 = 0;
+	int asic;
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		if (irq == devpriv->asics[asic].irq) {
+			/* it is an interrupt for ASIC #asic */
+			if (pcmuio_handle_asic_interrupt(dev, asic))
+				got1++;
 		}
 	}
 	if (!got1)

commit 8099a9841f1d9ff15de8f12cf1ba36b574d804c8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 3 18:01:17 2013 -0700

    staging: comedi: pcmuio: remove 'subpriv' macro
    
    The 'subpriv' macro relies on a local variable having a specific name.
    Replace the macro with a local variable where used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c53c101e033f..f7f27623ccae 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -189,8 +189,6 @@ struct pcmuio_private {
 	struct pcmuio_subdev_private *sprivs;
 };
 
-#define subpriv ((struct pcmuio_subdev_private *)s->private)
-
 /* DIO devices are slightly special.  Although it is possible to
  * implement the insn_read/insn_write interface, it is much more
  * useful to applications if you implement the insn_bits interface.
@@ -200,6 +198,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcmuio_subdev_private *subpriv = s->private;
 	int byte_no;
 
 	/* NOTE:
@@ -278,6 +277,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	struct pcmuio_subdev_private *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 	    chan % 8;
 	unsigned long ioaddr;
@@ -427,8 +427,9 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	int nports, firstport, asic, port;
 	struct pcmuio_private *devpriv = dev->private;
+	struct pcmuio_subdev_private *subpriv = s->private;
+	int nports, firstport, asic, port;
 
 	asic = subpriv->intr.asic;
 	if (asic < 0)
@@ -448,9 +449,10 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
-	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *)d;
 	struct pcmuio_private *devpriv = dev->private;
+	struct pcmuio_subdev_private *subpriv;
+	int asic, got1 = 0;
 	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
@@ -505,6 +507,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 				     irq, asic, triggered);
 				for (i = 0; i < dev->n_subdevices; i++) {
 					s = &dev->subdevices[i];
+					subpriv = s->private;
 					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
@@ -603,6 +606,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct pcmuio_private *devpriv = dev->private;
+	struct pcmuio_subdev_private *subpriv = s->private;
 
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -656,6 +660,7 @@ static int pcmuio_start_intr(struct comedi_device *dev,
 
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcmuio_subdev_private *subpriv = s->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
@@ -673,6 +678,7 @@ static int
 pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 			  unsigned int trignum)
 {
+	struct pcmuio_subdev_private *subpriv = s->private;
 	unsigned long flags;
 	int event = 0;
 
@@ -697,6 +703,7 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pcmuio_subdev_private *subpriv = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
@@ -793,8 +800,9 @@ static int pcmuio_cmdtest(struct comedi_device *dev,
 static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
-	struct pcmuio_private *devpriv;
 	struct comedi_subdevice *s;
+	struct pcmuio_private *devpriv;
+	struct pcmuio_subdev_private *subpriv;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned int irq[MAX_ASICS];
 	int ret;
@@ -839,7 +847,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		int byte_no;
 
 		s = &dev->subdevices[sdev_no];
-		s->private = &devpriv->sprivs[sdev_no];
+		subpriv = &devpriv->sprivs[sdev_no];
+		s->private = subpriv;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 0c98e26bbba1..c53c101e033f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -14,10 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 /*
 Driver: pcmuio

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7d5682fc58ff..0c98e26bbba1 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -917,9 +917,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].irq = irq[asic];
 	}
 
-	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
-				   irqs.. */
-
 	if (irq[0]) {
 		dev_dbg(dev->class_dev, "irq: %u\n", irq[0]);
 		if (irq[1] && board->num_asics == 2)

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index fc15d48bd30e..7d5682fc58ff 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -935,18 +935,16 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmuio_detach(struct comedi_device *dev)
 {
-	const struct pcmuio_board *board = comedi_board(dev);
 	struct pcmuio_private *devpriv = dev->private;
 	int i;
 
-	if (dev->iobase)
-		release_region(dev->iobase, ASIC_IOSIZE * board->num_asics);
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
 	}
 	if (devpriv && devpriv->sprivs)
 		kfree(devpriv->sprivs);
+	comedi_legacy_detach(dev);
 }
 
 static const struct pcmuio_board pcmuio_boards[] = {

commit 35626c2efecd6dad6ef67124ae2604385b717ed7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:28:06 2013 -0700

    staging: comedi: pcmuio: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 745f7b908767..fc15d48bd30e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -800,25 +800,16 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pcmuio_private *devpriv;
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
-	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
 	int ret;
 
-	iobase = it->options[0];
 	irq[0] = it->options[1];
 	irq[1] = it->options[2];
 
-	dev_dbg(dev->class_dev, "%s: io: %lx attach\n",
-		dev->driver->driver_name, iobase);
-
-	dev->iobase = iobase;
-
-	if (!iobase || !request_region(iobase,
-				       board->num_asics * ASIC_IOSIZE,
-				       dev->driver->driver_name)) {
-		dev_err(dev->class_dev, "I/O port conflict\n");
-		return -EIO;
-	}
+	ret = comedi_request_region(dev, it->options[0],
+				    board->num_asics * ASIC_IOSIZE);
+	if (ret)
+		return ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)

commit 34734c588dc41d4c2056381305f3dca1bfe86889
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:27:44 2013 -0700

    staging: comedi: pcmuio: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 433270ceda4f..745f7b908767 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -820,8 +820,6 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EIO;
 	}
 
-	dev->board_name = board->name;
-
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 71ef3f90bc98..433270ceda4f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -838,14 +838,11 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	chans_left = CHANS_PER_ASIC * board->num_asics;
 	n_subdevs = CALC_N_SUBDEVS(chans_left);
-	devpriv->sprivs =
-	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
-		    GFP_KERNEL);
-	if (!devpriv->sprivs) {
-		dev_warn(dev->class_dev,
-			 "cannot allocate subdevice private data structures\n");
+	devpriv->sprivs = kcalloc(n_subdevs,
+				  sizeof(struct pcmuio_subdev_private),
+				  GFP_KERNEL);
+	if (!devpriv->sprivs)
 		return -ENOMEM;
-	}
 
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret)

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b74431fba151..71ef3f90bc98 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -77,9 +77,9 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-#include <linux/pci.h>
 
 #include "../comedidev.h"
+
 #include "comedi_fc.h"
 
 #define CHANS_PER_PORT   8

commit 90a35c15c5d7d5c6254772d2752975dda185710c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Dec 19 17:27:02 2012 -0700

    staging: comedi: store the 'index' for each subdevice
    
    Store the 'index' for each comedi_subdevice when they are initially
    allocated by comedi_alloc_subdevice(). This allows removing the
    pointer math in comedi_fops.c which is used to figure out the
    index that user space uses to access the individual subdevices.
    
    Fix the ni_mio_common driver so it also uses the 'index' instead
    of doing the pointer math.
    
    Also, remove a couple unused macros in the pcmda12, pcmmio, and
    pcmuio drivers which also do the pointer math to figure out the
    index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c61cc64ffc2e..b74431fba151 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -92,7 +92,6 @@ Configuration Options:
 #define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
 #define MAX_DIO_CHANS   (PORTS_PER_ASIC*2*CHANS_PER_PORT)
 #define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
-#define SDEV_NO ((int)(s - dev->subdevices))
 #define CALC_N_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
 /* IO Memory sizes */
 #define ASIC_IOSIZE (0x10)

commit f95d45d114e1fd024bdee67beb80fce9b9c96126
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Dec 4 15:47:14 2012 -0700

    staging: comedi: pcm_common: remove module
    
    This module is built whenever CONFIG_COMEDI is enabled but it is
    only used by the pcmmio and pcmuio drivers. The pcm_common module
    consists of one exported function. Put a local copy of the function
    in the pcmmio and pcmuio drivers.
    
    This removes the need for the pcm_common module and the now unused
    pcm_common.[ch] files can be deleted and removed from the Makefile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 31ea20c2d39e..c61cc64ffc2e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -77,10 +77,10 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-#include "../comedidev.h"
-#include "pcm_common.h"
+#include <linux/pci.h>
 
-#include <linux/pci.h>		/* for PCI devices */
+#include "../comedidev.h"
+#include "comedi_fc.h"
 
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
@@ -740,11 +740,59 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int
-pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	       struct comedi_cmd *cmd)
+static int pcmuio_cmdtest(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_cmd *cmd)
 {
-	return comedi_pcm_cmdtest(dev, s, cmd);
+	int err = 0;
+
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+
+	if (err)
+		return 1;
+
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
 }
 
 static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 360180438b31..31ea20c2d39e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -775,10 +775,10 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->board_name = board->name;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 0e32119bc3f9..360180438b31 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -194,11 +194,6 @@ struct pcmuio_private {
 	struct pcmuio_subdev_private *sprivs;
 };
 
-/*
- * most drivers define the following macro to make it easy to
- * access the private structure.
- */
-#define devpriv ((struct pcmuio_private *)dev->private)
 #define subpriv ((struct pcmuio_subdev_private *)s->private)
 
 /* DIO devices are slightly special.  Although it is possible to
@@ -348,6 +343,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
+	struct pcmuio_private *devpriv = dev->private;
 
 	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
@@ -404,6 +400,7 @@ static void init_asics(struct comedi_device *dev)
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
+	struct pcmuio_private *devpriv = dev->private;
 
 	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
@@ -419,6 +416,7 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
+	struct pcmuio_private *devpriv = dev->private;
 
 	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
@@ -435,6 +433,7 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
+	struct pcmuio_private *devpriv = dev->private;
 
 	asic = subpriv->intr.asic;
 	if (asic < 0)
@@ -456,6 +455,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *)d;
+	struct pcmuio_private *devpriv = dev->private;
 	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
@@ -607,6 +607,8 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pcmuio_private *devpriv = dev->private;
+
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
@@ -748,6 +750,7 @@ pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
+	struct pcmuio_private *devpriv;
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned long iobase;
@@ -772,15 +775,10 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->board_name = board->name;
 
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
-		dev_warn(dev->class_dev,
-			 "cannot allocate private data structure\n");
-		return -ENOMEM;
-	}
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		devpriv->asics[asic].num = asic;
@@ -905,6 +903,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void pcmuio_detach(struct comedi_device *dev)
 {
 	const struct pcmuio_board *board = comedi_board(dev);
+	struct pcmuio_private *devpriv = dev->private;
 	int i;
 
 	if (dev->iobase)

commit 920e2ffbe243fb0555b2c238e26fe7dbc03db98c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 17 13:17:03 2012 -0700

    staging: comedi: pcmuio: pointers should be cleared with NULL
    
    Pointer variables should be cleared with NULL on 0. This quiets
    some sparse warnings about:
    
    warning: Using plain integer as NULL pointer
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index aba6b4516c5f..0e32119bc3f9 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -442,7 +442,7 @@ static void pcmuio_stop_intr(struct comedi_device *dev,
 
 	subpriv->intr.enabled_mask = 0;
 	subpriv->intr.active = 0;
-	s->async->inttrig = 0;
+	s->async->inttrig = NULL;
 	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
 	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
 	switch_page(dev, asic, PAGE_ENAB);
@@ -683,7 +683,7 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 		return -EINVAL;
 
 	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
-	s->async->inttrig = 0;
+	s->async->inttrig = NULL;
 	if (subpriv->intr.active)
 		event = pcmuio_start_intr(dev, s);
 

commit 68720ae68a94444387d56bc5a166396e33e420a5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:55:08 2012 -0700

    staging: comedi: pcmuio: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index feef3d02f35a..aba6b4516c5f 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -456,6 +456,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *)d;
+	int i;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -507,9 +508,8 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 				printk
 				    ("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
 				     irq, asic, triggered);
-				for (s = dev->subdevices;
-				     s < dev->subdevices + dev->n_subdevices;
-				     ++s) {
+				for (i = 0; i < dev->n_subdevices; i++) {
+					s = &dev->subdevices[i];
 					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
@@ -811,8 +811,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
 		int byte_no;
 
-		s = dev->subdevices + sdev_no;
-		s->private = devpriv->sprivs + sdev_no;
+		s = &dev->subdevices[sdev_no];
+		s->private = &devpriv->sprivs[sdev_no];
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 33f740ee3524..feef3d02f35a 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -277,7 +277,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 		data[1]);
 #endif
 
-	return 2;
+	return insn->n;
 }
 
 /* The input or output configuration of each digital line is

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 4426e1798ed5..33f740ee3524 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -211,8 +211,6 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
-	if (insn->n != 2)
-		return -EINVAL;
 
 	/* NOTE:
 	   reading a 0 means this channel was high

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 48565fe9efcc..4426e1798ed5 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -227,7 +227,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	dev_dbg(dev->hw_dev, "write mask: %08x  data: %08x\n", data[0],
+	dev_dbg(dev->class_dev, "write mask: %08x  data: %08x\n", data[0],
 		data[1]);
 #endif
 
@@ -264,7 +264,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 		}
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		dev_dbg(dev->hw_dev, "data_out_byte %02x\n", (unsigned)byte);
+		dev_dbg(dev->class_dev, "data_out_byte %02x\n", (unsigned)byte);
 #endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
@@ -275,7 +275,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	dev_dbg(dev->hw_dev, "s->state %08x data_out %08x\n", s->state,
+	dev_dbg(dev->class_dev, "s->state %08x data_out %08x\n", s->state,
 		data[1]);
 #endif
 
@@ -760,7 +760,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[0] = it->options[1];
 	irq[1] = it->options[2];
 
-	dev_dbg(dev->hw_dev, "comedi%d: %s: io: %lx attached\n", dev->minor,
+	dev_dbg(dev->class_dev, "%s: io: %lx attach\n",
 		dev->driver->driver_name, iobase);
 
 	dev->iobase = iobase;
@@ -768,7 +768,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!iobase || !request_region(iobase,
 				       board->num_asics * ASIC_IOSIZE,
 				       dev->driver->driver_name)) {
-		dev_err(dev->hw_dev, "I/O port conflict\n");
+		dev_err(dev->class_dev, "I/O port conflict\n");
 		return -EIO;
 	}
 
@@ -779,7 +779,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * convenient macro defined in comedidev.h.
  */
 	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
-		dev_warn(dev->hw_dev, "cannot allocate private data structure\n");
+		dev_warn(dev->class_dev,
+			 "cannot allocate private data structure\n");
 		return -ENOMEM;
 	}
 
@@ -798,7 +799,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
 		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
-		dev_warn(dev->hw_dev, "cannot allocate subdevice private data structures\n");
+		dev_warn(dev->class_dev,
+			 "cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
 	}
 
@@ -890,11 +892,12 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				   irqs.. */
 
 	if (irq[0]) {
-		dev_dbg(dev->hw_dev, "irq: %u\n", irq[0]);
+		dev_dbg(dev->class_dev, "irq: %u\n", irq[0]);
 		if (irq[1] && board->num_asics == 2)
-			dev_dbg(dev->hw_dev, "second ASIC irq: %u\n", irq[1]);
+			dev_dbg(dev->class_dev, "second ASIC irq: %u\n",
+				irq[1]);
 	} else {
-		dev_dbg(dev->hw_dev, "(IRQ mode disabled)\n");
+		dev_dbg(dev->class_dev, "(IRQ mode disabled)\n");
 	}
 
 

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 33ab4c63b3dc..48565fe9efcc 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -754,6 +754,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
+	int ret;
 
 	iobase = it->options[0];
 	irq[0] = it->options[1];
@@ -801,8 +802,9 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	}
 
-	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	if (ret)
+		return ret;
 
 	port = 0;
 	asic = 0;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e4153bd27172..33ab4c63b3dc 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -800,13 +800,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		dev_warn(dev->hw_dev, "cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
 	}
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 *
-	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
-	 * 96-channel version of the board.
-	 */
+
 	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
 		return -ENOMEM;
 

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index ce5068e3b46e..e4153bd27172 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -807,10 +807,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
 	 * 96-channel version of the board.
 	 */
-	if (comedi_alloc_subdevices(dev, n_subdevs) < 0) {
-		dev_dbg(dev->hw_dev, "cannot allocate subdevice data structures\n");
+	if (comedi_alloc_subdevices(dev, n_subdevs) < 0)
 		return -ENOMEM;
-	}
 
 	port = 0;
 	asic = 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b1a9bed38551..ce5068e3b46e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -807,7 +807,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
 	 * 96-channel version of the board.
 	 */
-	if (alloc_subdevices(dev, n_subdevs) < 0) {
+	if (comedi_alloc_subdevices(dev, n_subdevs) < 0) {
 		dev_dbg(dev->hw_dev, "cannot allocate subdevice data structures\n");
 		return -ENOMEM;
 	}

commit a28b59957d3ad01481c2ea87aca50cfdb85417f2
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 17:51:35 2012 -0700

    staging: comedi: remove this_board macro in the pcmuio driver
    
    The 'thisboard' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 623381d50dac..b1a9bed38551 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -155,11 +155,6 @@ struct pcmuio_board {
 	const int num_ports;
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct pcmuio_board *)dev->board_ptr)
-
 /* this structure is for data unique to this subdevice.  */
 struct pcmuio_subdev_private {
 	/* mapping of halfwords (bytes) in port/chanarray to iobase */
@@ -354,7 +349,9 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 
 static void switch_page(struct comedi_device *dev, int asic, int page)
 {
-	if (asic < 0 || asic >= thisboard->num_asics)
+	const struct pcmuio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
 	if (page < 0 || page >= NUM_PAGES)
 		return;		/* more paranoia */
@@ -370,9 +367,10 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
+	const struct pcmuio_board *board = comedi_board(dev);
 	int asic;
 
-	for (asic = 0; asic < thisboard->num_asics; ++asic) {
+	for (asic = 0; asic < board->num_asics; ++asic) {
 		int port, page;
 		unsigned long baseaddr = dev->iobase + asic * ASIC_IOSIZE;
 
@@ -407,7 +405,9 @@ static void init_asics(struct comedi_device *dev)
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
-	if (asic < 0 || asic >= thisboard->num_asics)
+	const struct pcmuio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -420,7 +420,9 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
-	if (asic < 0 || asic >= thisboard->num_asics)
+	const struct pcmuio_board *board = comedi_board(dev);
+
+	if (asic < 0 || asic >= board->num_asics)
 		return;		/* paranoia */
 	if (port < 0 || port >= PORTS_PER_ASIC)
 		return;		/* more paranoia */
@@ -747,6 +749,7 @@ pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct pcmuio_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned long iobase;
@@ -762,17 +765,13 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-				       thisboard->num_asics * ASIC_IOSIZE,
+				       board->num_asics * ASIC_IOSIZE,
 				       dev->driver->driver_name)) {
 		dev_err(dev->hw_dev, "I/O port conflict\n");
 		return -EIO;
 	}
 
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 /*
  * Allocate the private structure area.  alloc_private() is a
@@ -792,7 +791,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
-	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
+	chans_left = CHANS_PER_ASIC * board->num_asics;
 	n_subdevs = CALC_N_SUBDEVS(chans_left);
 	devpriv->sprivs =
 	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
@@ -881,7 +880,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
 		    && request_irq(irq[asic], interrupt_pcmuio,
-				   IRQF_SHARED, thisboard->name, dev)) {
+				   IRQF_SHARED, board->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -898,7 +897,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (irq[0]) {
 		dev_dbg(dev->hw_dev, "irq: %u\n", irq[0]);
-		if (irq[1] && thisboard->num_asics == 2)
+		if (irq[1] && board->num_asics == 2)
 			dev_dbg(dev->hw_dev, "second ASIC irq: %u\n", irq[1]);
 	} else {
 		dev_dbg(dev->hw_dev, "(IRQ mode disabled)\n");
@@ -910,10 +909,11 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void pcmuio_detach(struct comedi_device *dev)
 {
+	const struct pcmuio_board *board = comedi_board(dev);
 	int i;
 
 	if (dev->iobase)
-		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
+		release_region(dev->iobase, ASIC_IOSIZE * board->num_asics);
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b18912ac8e21..623381d50dac 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -908,24 +908,18 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-static int pcmuio_detach(struct comedi_device *dev)
+static void pcmuio_detach(struct comedi_device *dev)
 {
 	int i;
 
-	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
-		dev->driver->driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
-
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
 			free_irq(devpriv->asics[i].irq, dev);
 	}
-
 	if (devpriv && devpriv->sprivs)
 		kfree(devpriv->sprivs);
-
-	return 0;
 }
 
 static const struct pcmuio_board pcmuio_boards[] = {

commit 294f930d98be86fb4f34302c718a49719650857f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 3 15:09:40 2012 -0700

    staging: comedi: use module_comedi_driver
    
    Convert the refactored comedi drivers to use the module_comedi_driver()
    macro which makes the code smaller and a bit simpler.
    
    In the process, rename the driver variables from driver_* to *_driver,
    as is more typical with other subsystems, and make sure they are all
    static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 47a3ee6e405c..b18912ac8e21 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -940,7 +940,7 @@ static const struct pcmuio_board pcmuio_boards[] = {
 	},
 };
 
-static struct comedi_driver driver = {
+static struct comedi_driver pcmuio_driver = {
 	.driver_name	= "pcmuio",
 	.module		= THIS_MODULE,
 	.attach		= pcmuio_attach,
@@ -949,18 +949,7 @@ static struct comedi_driver driver = {
 	.offset		= sizeof(struct pcmuio_board),
 	.num_names	= ARRAY_SIZE(pcmuio_boards),
 };
-
-static int __init driver_init_module(void)
-{
-	return comedi_driver_register(&driver);
-}
-module_init(driver_init_module);
-
-static void __exit driver_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver);
-}
-module_exit(driver_cleanup_module);
+module_comedi_driver(pcmuio_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 2d2111ea2cf25cc60f7027130ceb34af2d03745d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 1 17:03:48 2012 -0700

    staging: comedi: fix build errors caused by module_init/module_exit refactor
    
    A couple build errors were introduced with the module_init/module_exit
    refactor.
    
    The struct comedi_driver variable was being accessed directly in the
    attach and detach routines. Instead of doing this, access the variable
    indirectly using the driver pointer in struct comedi_device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index de4f4865bef1..47a3ee6e405c 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -757,13 +757,13 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[1] = it->options[2];
 
 	dev_dbg(dev->hw_dev, "comedi%d: %s: io: %lx attached\n", dev->minor,
-		driver.driver_name, iobase);
+		dev->driver->driver_name, iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
 				       thisboard->num_asics * ASIC_IOSIZE,
-				       driver.driver_name)) {
+				       dev->driver->driver_name)) {
 		dev_err(dev->hw_dev, "I/O port conflict\n");
 		return -EIO;
 	}
@@ -913,7 +913,7 @@ static int pcmuio_detach(struct comedi_device *dev)
 	int i;
 
 	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
-		driver.driver_name);
+		dev->driver->driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
 

commit 6b19f9c6bee7afcd1e5dee9528333b2aa52de404
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 27 15:28:57 2012 -0700

    staging: comedi: refactor pcmuio driver to remove forward declarations
    
    Refactor the switch_page and pcmuio_stop_intr functions to avoid
    needing the forward declarations.
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 661ba2e03892..de4f4865bef1 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -155,19 +155,6 @@ struct pcmuio_board {
 	const int num_ports;
 };
 
-static const struct pcmuio_board pcmuio_boards[] = {
-	{
-	 .name = "pcmuio48",
-	 .num_asics = 1,
-	 .num_ports = 6,
-	 },
-	{
-	 .name = "pcmuio96",
-	 .num_asics = 2,
-	 .num_ports = 12,
-	 },
-};
-
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -218,262 +205,6 @@ struct pcmuio_private {
  */
 #define devpriv ((struct pcmuio_private *)dev->private)
 #define subpriv ((struct pcmuio_subdev_private *)s->private)
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int pcmuio_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pcmuio_detach(struct comedi_device *dev);
-
-static struct comedi_driver driver = {
-	.driver_name = "pcmuio",
-	.module = THIS_MODULE,
-	.attach = pcmuio_attach,
-	.detach = pcmuio_detach,
-/* It is not necessary to implement the following members if you are
- * writing a driver for a ISA PnP or PCI card */
-	/* Most drivers will support multiple types of boards by
-	 * having an array of board structures.  These were defined
-	 * in pcmuio_boards[] above.  Note that the element 'name'
-	 * was first in the structure -- Comedi uses this fact to
-	 * extract the name of the board without knowing any details
-	 * about the structure except for its length.
-	 * When a device is attached (by comedi_config), the name
-	 * of the device is given to Comedi, and Comedi tries to
-	 * match it by going through the list of board names.  If
-	 * there is a match, the address of the pointer is put
-	 * into dev->board_ptr and driver->attach() is called.
-	 *
-	 * Note that these are not necessary if you can determine
-	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
-	 * devices are such boards.
-	 */
-	.board_name = &pcmuio_boards[0].name,
-	.offset = sizeof(struct pcmuio_board),
-	.num_names = ARRAY_SIZE(pcmuio_boards),
-};
-
-static int pcmuio_dio_insn_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-static int pcmuio_dio_insn_config(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data);
-
-static irqreturn_t interrupt_pcmuio(int irq, void *d);
-static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
-static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_cmd *cmd);
-
-/* some helper functions to deal with specifics of this device's registers */
-static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
-static void switch_page(struct comedi_device *dev, int asic, int page);
-#ifdef notused
-static void lock_port(struct comedi_device *dev, int asic, int port);
-static void unlock_port(struct comedi_device *dev, int asic, int port);
-#endif
-
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	struct comedi_subdevice *s;
-	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
-	unsigned long iobase;
-	unsigned int irq[MAX_ASICS];
-
-	iobase = it->options[0];
-	irq[0] = it->options[1];
-	irq[1] = it->options[2];
-
-	dev_dbg(dev->hw_dev, "comedi%d: %s: io: %lx attached\n", dev->minor,
-		driver.driver_name, iobase);
-
-	dev->iobase = iobase;
-
-	if (!iobase || !request_region(iobase,
-				       thisboard->num_asics * ASIC_IOSIZE,
-				       driver.driver_name)) {
-		dev_err(dev->hw_dev, "I/O port conflict\n");
-		return -EIO;
-	}
-
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_name = thisboard->name;
-
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
-		dev_warn(dev->hw_dev, "cannot allocate private data structure\n");
-		return -ENOMEM;
-	}
-
-	for (asic = 0; asic < MAX_ASICS; ++asic) {
-		devpriv->asics[asic].num = asic;
-		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
-		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
-						   this function when we
-						   request_irqs */
-		spin_lock_init(&devpriv->asics[asic].spinlock);
-	}
-
-	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
-	n_subdevs = CALC_N_SUBDEVS(chans_left);
-	devpriv->sprivs =
-	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
-		    GFP_KERNEL);
-	if (!devpriv->sprivs) {
-		dev_warn(dev->hw_dev, "cannot allocate subdevice private data structures\n");
-		return -ENOMEM;
-	}
-	/*
-	 * Allocate the subdevice structures.  alloc_subdevice() is a
-	 * convenient macro defined in comedidev.h.
-	 *
-	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
-	 * 96-channel version of the board.
-	 */
-	if (alloc_subdevices(dev, n_subdevs) < 0) {
-		dev_dbg(dev->hw_dev, "cannot allocate subdevice data structures\n");
-		return -ENOMEM;
-	}
-
-	port = 0;
-	asic = 0;
-	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
-		int byte_no;
-
-		s = dev->subdevices + sdev_no;
-		s->private = devpriv->sprivs + sdev_no;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->type = COMEDI_SUBD_DIO;
-		s->insn_bits = pcmuio_dio_insn_bits;
-		s->insn_config = pcmuio_dio_insn_config;
-		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
-		subpriv->intr.asic = -1;
-		subpriv->intr.first_chan = -1;
-		subpriv->intr.asic_chan = -1;
-		subpriv->intr.num_asic_chans = -1;
-		subpriv->intr.active = 0;
-		s->len_chanlist = 1;
-
-		/* save the ioport address for each 'port' of 8 channels in the
-		   subdevice */
-		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
-			if (port >= PORTS_PER_ASIC) {
-				port = 0;
-				++asic;
-				thisasic_chanct = 0;
-			}
-			subpriv->iobases[byte_no] =
-			    devpriv->asics[asic].iobase + port;
-
-			if (thisasic_chanct <
-			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-			    && subpriv->intr.asic < 0) {
-				/* this is an interrupt subdevice, so setup the struct */
-				subpriv->intr.asic = asic;
-				subpriv->intr.active = 0;
-				subpriv->intr.stop_count = 0;
-				subpriv->intr.first_chan = byte_no * 8;
-				subpriv->intr.asic_chan = thisasic_chanct;
-				subpriv->intr.num_asic_chans =
-				    s->n_chan - subpriv->intr.first_chan;
-				dev->read_subdev = s;
-				s->subdev_flags |= SDF_CMD_READ;
-				s->cancel = pcmuio_cancel;
-				s->do_cmd = pcmuio_cmd;
-				s->do_cmdtest = pcmuio_cmdtest;
-				s->len_chanlist = subpriv->intr.num_asic_chans;
-			}
-			thisasic_chanct += CHANS_PER_PORT;
-		}
-		spin_lock_init(&subpriv->intr.spinlock);
-
-		chans_left -= s->n_chan;
-
-		if (!chans_left) {
-			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
-			port = 0;
-		}
-
-	}
-
-	init_asics(dev);	/* clear out all the registers, basically */
-
-	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
-		if (irq[asic]
-		    && request_irq(irq[asic], interrupt_pcmuio,
-				   IRQF_SHARED, thisboard->name, dev)) {
-			int i;
-			/* unroll the allocated irqs.. */
-			for (i = asic - 1; i >= 0; --i) {
-				free_irq(irq[i], dev);
-				devpriv->asics[i].irq = irq[i] = 0;
-			}
-			irq[asic] = 0;
-		}
-		devpriv->asics[asic].irq = irq[asic];
-	}
-
-	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
-				   irqs.. */
-
-	if (irq[0]) {
-		dev_dbg(dev->hw_dev, "irq: %u\n", irq[0]);
-		if (irq[1] && thisboard->num_asics == 2)
-			dev_dbg(dev->hw_dev, "second ASIC irq: %u\n", irq[1]);
-	} else {
-		dev_dbg(dev->hw_dev, "(IRQ mode disabled)\n");
-	}
-
-
-	return 1;
-}
-
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int pcmuio_detach(struct comedi_device *dev)
-{
-	int i;
-
-	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
-		driver.driver_name);
-	if (dev->iobase)
-		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
-
-	for (i = 0; i < MAX_ASICS; ++i) {
-		if (devpriv->asics[i].irq)
-			free_irq(devpriv->asics[i].irq, dev);
-	}
-
-	if (devpriv && devpriv->sprivs)
-		kfree(devpriv->sprivs);
-
-	return 0;
-}
 
 /* DIO devices are slightly special.  Although it is possible to
  * implement the insn_read/insn_write interface, it is much more
@@ -621,6 +352,21 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void switch_page(struct comedi_device *dev, int asic, int page)
+{
+	if (asic < 0 || asic >= thisboard->num_asics)
+		return;		/* paranoia */
+	if (page < 0 || page >= NUM_PAGES)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
+	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
+
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+}
+
 static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
@@ -658,21 +404,6 @@ static void init_asics(struct comedi_device *dev)
 	}
 }
 
-static void switch_page(struct comedi_device *dev, int asic, int page)
-{
-	if (asic < 0 || asic >= thisboard->num_asics)
-		return;		/* paranoia */
-	if (page < 0 || page >= NUM_PAGES)
-		return;		/* more paranoia */
-
-	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
-	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
-
-	/* now write out the shadow register */
-	outb(devpriv->asics[asic].pagelock,
-	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
-}
-
 #ifdef notused
 static void lock_port(struct comedi_device *dev, int asic, int port)
 {
@@ -700,6 +431,27 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 }
 #endif /* notused */
 
+static void pcmuio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
+{
+	int nports, firstport, asic, port;
+
+	asic = subpriv->intr.asic;
+	if (asic < 0)
+		return;		/* not an interrupt subdev */
+
+	subpriv->intr.enabled_mask = 0;
+	subpriv->intr.active = 0;
+	s->async->inttrig = 0;
+	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
+	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
+	switch_page(dev, asic, PAGE_ENAB);
+	for (port = firstport; port < firstport + nports; ++port) {
+		/* disable all intrs for this subdev.. */
+		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+	}
+}
+
 static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
@@ -852,27 +604,6 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	int nports, firstport, asic, port;
-
-	asic = subpriv->intr.asic;
-	if (asic < 0)
-		return;		/* not an interrupt subdev */
-
-	subpriv->intr.enabled_mask = 0;
-	subpriv->intr.active = 0;
-	s->async->inttrig = 0;
-	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
-	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
-	switch_page(dev, asic, PAGE_ENAB);
-	for (port = firstport; port < firstport + nports; ++port) {
-		/* disable all intrs for this subdev.. */
-		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
-	}
-}
-
 static int pcmuio_start_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -1014,21 +745,221 @@ pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	return comedi_pcm_cmdtest(dev, s, cmd);
 }
 
+static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct comedi_subdevice *s;
+	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
+	unsigned long iobase;
+	unsigned int irq[MAX_ASICS];
+
+	iobase = it->options[0];
+	irq[0] = it->options[1];
+	irq[1] = it->options[2];
+
+	dev_dbg(dev->hw_dev, "comedi%d: %s: io: %lx attached\n", dev->minor,
+		driver.driver_name, iobase);
+
+	dev->iobase = iobase;
+
+	if (!iobase || !request_region(iobase,
+				       thisboard->num_asics * ASIC_IOSIZE,
+				       driver.driver_name)) {
+		dev_err(dev->hw_dev, "I/O port conflict\n");
+		return -EIO;
+	}
+
 /*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
  */
+	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
+		dev_warn(dev->hw_dev, "cannot allocate private data structure\n");
+		return -ENOMEM;
+	}
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		devpriv->asics[asic].num = asic;
+		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
+		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
+						   this function when we
+						   request_irqs */
+		spin_lock_init(&devpriv->asics[asic].spinlock);
+	}
+
+	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
+	n_subdevs = CALC_N_SUBDEVS(chans_left);
+	devpriv->sprivs =
+	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
+		    GFP_KERNEL);
+	if (!devpriv->sprivs) {
+		dev_warn(dev->hw_dev, "cannot allocate subdevice private data structures\n");
+		return -ENOMEM;
+	}
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 *
+	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
+	 * 96-channel version of the board.
+	 */
+	if (alloc_subdevices(dev, n_subdevs) < 0) {
+		dev_dbg(dev->hw_dev, "cannot allocate subdevice data structures\n");
+		return -ENOMEM;
+	}
+
+	port = 0;
+	asic = 0;
+	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
+		int byte_no;
+
+		s = dev->subdevices + sdev_no;
+		s->private = devpriv->sprivs + sdev_no;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->type = COMEDI_SUBD_DIO;
+		s->insn_bits = pcmuio_dio_insn_bits;
+		s->insn_config = pcmuio_dio_insn_config;
+		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
+		subpriv->intr.asic = -1;
+		subpriv->intr.first_chan = -1;
+		subpriv->intr.asic_chan = -1;
+		subpriv->intr.num_asic_chans = -1;
+		subpriv->intr.active = 0;
+		s->len_chanlist = 1;
+
+		/* save the ioport address for each 'port' of 8 channels in the
+		   subdevice */
+		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
+			if (port >= PORTS_PER_ASIC) {
+				port = 0;
+				++asic;
+				thisasic_chanct = 0;
+			}
+			subpriv->iobases[byte_no] =
+			    devpriv->asics[asic].iobase + port;
+
+			if (thisasic_chanct <
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->intr.asic < 0) {
+				/* this is an interrupt subdevice, so setup the struct */
+				subpriv->intr.asic = asic;
+				subpriv->intr.active = 0;
+				subpriv->intr.stop_count = 0;
+				subpriv->intr.first_chan = byte_no * 8;
+				subpriv->intr.asic_chan = thisasic_chanct;
+				subpriv->intr.num_asic_chans =
+				    s->n_chan - subpriv->intr.first_chan;
+				dev->read_subdev = s;
+				s->subdev_flags |= SDF_CMD_READ;
+				s->cancel = pcmuio_cancel;
+				s->do_cmd = pcmuio_cmd;
+				s->do_cmdtest = pcmuio_cmdtest;
+				s->len_chanlist = subpriv->intr.num_asic_chans;
+			}
+			thisasic_chanct += CHANS_PER_PORT;
+		}
+		spin_lock_init(&subpriv->intr.spinlock);
+
+		chans_left -= s->n_chan;
+
+		if (!chans_left) {
+			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
+			port = 0;
+		}
+
+	}
+
+	init_asics(dev);	/* clear out all the registers, basically */
+
+	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
+		if (irq[asic]
+		    && request_irq(irq[asic], interrupt_pcmuio,
+				   IRQF_SHARED, thisboard->name, dev)) {
+			int i;
+			/* unroll the allocated irqs.. */
+			for (i = asic - 1; i >= 0; --i) {
+				free_irq(irq[i], dev);
+				devpriv->asics[i].irq = irq[i] = 0;
+			}
+			irq[asic] = 0;
+		}
+		devpriv->asics[asic].irq = irq[asic];
+	}
+
+	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
+				   irqs.. */
+
+	if (irq[0]) {
+		dev_dbg(dev->hw_dev, "irq: %u\n", irq[0]);
+		if (irq[1] && thisboard->num_asics == 2)
+			dev_dbg(dev->hw_dev, "second ASIC irq: %u\n", irq[1]);
+	} else {
+		dev_dbg(dev->hw_dev, "(IRQ mode disabled)\n");
+	}
+
+
+	return 1;
+}
+
+static int pcmuio_detach(struct comedi_device *dev)
+{
+	int i;
+
+	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
+		driver.driver_name);
+	if (dev->iobase)
+		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
+
+	for (i = 0; i < MAX_ASICS; ++i) {
+		if (devpriv->asics[i].irq)
+			free_irq(devpriv->asics[i].irq, dev);
+	}
+
+	if (devpriv && devpriv->sprivs)
+		kfree(devpriv->sprivs);
+
+	return 0;
+}
+
+static const struct pcmuio_board pcmuio_boards[] = {
+	{
+		.name		= "pcmuio48",
+		.num_asics	= 1,
+		.num_ports	= 6,
+	}, {
+		.name		= "pcmuio96",
+		.num_asics	= 2,
+		.num_ports	= 12,
+	},
+};
+
+static struct comedi_driver driver = {
+	.driver_name	= "pcmuio",
+	.module		= THIS_MODULE,
+	.attach		= pcmuio_attach,
+	.detach		= pcmuio_detach,
+	.board_name	= &pcmuio_boards[0].name,
+	.offset		= sizeof(struct pcmuio_board),
+	.num_names	= ARRAY_SIZE(pcmuio_boards),
+};
+
 static int __init driver_init_module(void)
 {
 	return comedi_driver_register(&driver);
 }
+module_init(driver_init_module);
 
 static void __exit driver_cleanup_module(void)
 {
 	comedi_driver_unregister(&driver);
 }
-
-module_init(driver_init_module);
 module_exit(driver_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit 976fe5ab27e682d3dbfec26517a8a248638af07d
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:20 2011 +0530

    Staging: comedi: fix printk issue in pcmuio.c
    
    This is a patch to the pcmuio.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    Converted printks to dev_dbg().
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 9a5dc91e6a8c..661ba2e03892 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -501,7 +501,8 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	printk("write mask: %08x  data: %08x\n", data[0], data[1]);
+	dev_dbg(dev->hw_dev, "write mask: %08x  data: %08x\n", data[0],
+		data[1]);
 #endif
 
 	s->state = 0;
@@ -537,7 +538,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 		}
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("data_out_byte %02x\n", (unsigned)byte);
+		dev_dbg(dev->hw_dev, "data_out_byte %02x\n", (unsigned)byte);
 #endif
 		/* save the digital input lines for this byte.. */
 		s->state |= ((unsigned int)byte) << offset;
@@ -548,7 +549,8 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev,
 
 #ifdef DAMMIT_ITS_BROKEN
 	/* DEBUG */
-	printk("s->state %08x data_out %08x\n", s->state, data[1]);
+	dev_dbg(dev->hw_dev, "s->state %08x data_out %08x\n", s->state,
+		data[1]);
 #endif
 
 	return 2;

commit deb04291a1eaa20c4565a64e894cdeb3e311d97b
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:19 2011 +0530

    Staging: comedi: fix printk issue in pcmuio.c
    
    This is a patch to the pcmuio.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    Converted printks to dev_functions.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 41f843b933c9..9a5dc91e6a8c 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -436,14 +436,13 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				   irqs.. */
 
 	if (irq[0]) {
-		printk("irq: %u ", irq[0]);
+		dev_dbg(dev->hw_dev, "irq: %u\n", irq[0]);
 		if (irq[1] && thisboard->num_asics == 2)
-			printk("second ASIC irq: %u ", irq[1]);
+			dev_dbg(dev->hw_dev, "second ASIC irq: %u\n", irq[1]);
 	} else {
-		printk("(IRQ mode disabled) ");
+		dev_dbg(dev->hw_dev, "(IRQ mode disabled)\n");
 	}
 
-	printk("attached\n");
 
 	return 1;
 }
@@ -460,7 +459,8 @@ static int pcmuio_detach(struct comedi_device *dev)
 {
 	int i;
 
-	printk("comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
+		driver.driver_name);
 	if (dev->iobase)
 		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
 

commit de1201ea91d0453800ec68f959297de2b37a042e
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:18 2011 +0530

    Staging: comedi: fix printk issue in pcmuio.c
    
    This is a patch to the pcmuio.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    Converted printks to dev_functions.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 0c5b06dcbe10..41f843b933c9 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -295,15 +295,15 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[0] = it->options[1];
 	irq[1] = it->options[2];
 
-	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-	       iobase);
+	dev_dbg(dev->hw_dev, "comedi%d: %s: io: %lx attached\n", dev->minor,
+		driver.driver_name, iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
 				       thisboard->num_asics * ASIC_IOSIZE,
 				       driver.driver_name)) {
-		printk("I/O port conflict\n");
+		dev_err(dev->hw_dev, "I/O port conflict\n");
 		return -EIO;
 	}
 
@@ -318,7 +318,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * convenient macro defined in comedidev.h.
  */
 	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
-		printk("cannot allocate private data structure\n");
+		dev_warn(dev->hw_dev, "cannot allocate private data structure\n");
 		return -ENOMEM;
 	}
 
@@ -337,7 +337,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
 		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
-		printk("cannot allocate subdevice private data structures\n");
+		dev_warn(dev->hw_dev, "cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
 	}
 	/*
@@ -348,7 +348,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	 * 96-channel version of the board.
 	 */
 	if (alloc_subdevices(dev, n_subdevs) < 0) {
-		printk("cannot allocate subdevice data structures\n");
+		dev_dbg(dev->hw_dev, "cannot allocate subdevice data structures\n");
 		return -ENOMEM;
 	}
 

commit 0389245f0c5692111c0dc8d997fc4af72d789472
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Nov 21 16:07:06 2011 +0530

    Staging: comedi: fix brace coding style issue in pcmuio.c
    
    This is a patch to the pcmuio.c file that fixes up a brace
    warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b2c2c8971a32..0c5b06dcbe10 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -951,14 +951,13 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	s->async->inttrig = 0;
-	if (subpriv->intr.active) {
+	if (subpriv->intr.active)
 		event = pcmuio_start_intr(dev, s);
-	}
+
 	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 1;
 }
@@ -1000,9 +999,8 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 0;
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7a9287433b2e..b2c2c8971a32 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -605,7 +605,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 		break;
 
 	case INSN_CONFIG_DIO_QUERY:
-		/* retreive from shadow register */
+		/* retrieve from shadow register */
 		data[1] =
 		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 785b3ec8fec8..7a9287433b2e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -1018,7 +1018,18 @@ pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver);
+static int __init driver_init_module(void)
+{
+	return comedi_driver_register(&driver);
+}
+
+static void __exit driver_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver);
+}
+
+module_init(driver_init_module);
+module_exit(driver_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 5af4c8448a3a..785b3ec8fec8 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -1019,3 +1019,7 @@ pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
  * as necessary.
  */
 COMEDI_INITCLEANUP(driver);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c1ae20ffb379..5af4c8448a3a 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -76,6 +76,7 @@ Configuration Options:
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include "../comedidev.h"
 #include "pcm_common.h"
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 81ee7cdc0caf..c1ae20ffb379 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -156,15 +156,15 @@ struct pcmuio_board {
 
 static const struct pcmuio_board pcmuio_boards[] = {
 	{
-	.name = "pcmuio48",
-	.num_asics = 1,
-	.num_ports = 6,
-		},
+	 .name = "pcmuio48",
+	 .num_asics = 1,
+	 .num_ports = 6,
+	 },
 	{
-	.name = "pcmuio96",
-	.num_asics = 2,
-	.num_ports = 12,
-		},
+	 .name = "pcmuio96",
+	 .num_asics = 2,
+	 .num_ports = 12,
+	 },
 };
 
 /*
@@ -223,7 +223,8 @@ struct pcmuio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmuio_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pcmuio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
@@ -254,17 +255,19 @@ static struct comedi_driver driver = {
 	.num_names = ARRAY_SIZE(pcmuio_boards),
 };
 
-static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int pcmuio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
+static int pcmuio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d);
 static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			  struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
@@ -292,13 +295,13 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	irq[1] = it->options[2];
 
 	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
-		iobase);
+	       iobase);
 
 	dev->iobase = iobase;
 
 	if (!iobase || !request_region(iobase,
-			thisboard->num_asics * ASIC_IOSIZE,
-			driver.driver_name)) {
+				       thisboard->num_asics * ASIC_IOSIZE,
+				       driver.driver_name)) {
 		printk("I/O port conflict\n");
 		return -EIO;
 	}
@@ -330,7 +333,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
 	n_subdevs = CALC_N_SUBDEVS(chans_left);
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private), GFP_KERNEL);
+	    kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),
+		    GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;
@@ -377,11 +381,11 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				thisasic_chanct = 0;
 			}
 			subpriv->iobases[byte_no] =
-				devpriv->asics[asic].iobase + port;
+			    devpriv->asics[asic].iobase + port;
 
 			if (thisasic_chanct <
-				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
-				&& subpriv->intr.asic < 0) {
+			    CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+			    && subpriv->intr.asic < 0) {
 				/* this is an interrupt subdevice, so setup the struct */
 				subpriv->intr.asic = asic;
 				subpriv->intr.active = 0;
@@ -389,7 +393,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				subpriv->intr.first_chan = byte_no * 8;
 				subpriv->intr.asic_chan = thisasic_chanct;
 				subpriv->intr.num_asic_chans =
-					s->n_chan - subpriv->intr.first_chan;
+				    s->n_chan - subpriv->intr.first_chan;
 				dev->read_subdev = s;
 				s->subdev_flags |= SDF_CMD_READ;
 				s->cancel = pcmuio_cancel;
@@ -414,8 +418,8 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& request_irq(irq[asic], interrupt_pcmuio,
-				IRQF_SHARED, thisboard->name, dev)) {
+		    && request_irq(irq[asic], interrupt_pcmuio,
+				   IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
@@ -475,8 +479,9 @@ static int pcmuio_detach(struct comedi_device *dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmuio_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -503,20 +508,23 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
 		/* address of 8-bit port */
 		unsigned long ioaddr = subpriv->iobases[byte_no],
-			/* bit offset of port in 32-bit doubleword */
-			offset = byte_no * 8;
+		    /* bit offset of port in 32-bit doubleword */
+		    offset = byte_no * 8;
 		/* this 8-bit port's data */
 		unsigned char byte = 0,
-			/* The write mask for this port (if any) */
-			write_mask_byte = (data[0] >> offset) & 0xff,
-			/* The data byte for this port */
-			data_byte = (data[1] >> offset) & 0xff;
+		    /* The write mask for this port (if any) */
+		    write_mask_byte = (data[0] >> offset) & 0xff,
+		    /* The data byte for this port */
+		    data_byte = (data[1] >> offset) & 0xff;
 
 		byte = inb(ioaddr);	/* read all 8-bits for this port */
 
 #ifdef DAMMIT_ITS_BROKEN
 		/* DEBUG */
-		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+		printk
+		    ("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",
+		     byte_no, (unsigned)write_mask_byte, (unsigned)data_byte,
+		     offset, ioaddr, (unsigned)byte);
 #endif
 
 		if (write_mask_byte) {
@@ -549,11 +557,12 @@ static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pcmuio_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
-		chan % 8;
+	    chan % 8;
 	unsigned long ioaddr;
 	unsigned char byte;
 
@@ -597,8 +606,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subde
 	case INSN_CONFIG_DIO_QUERY:
 		/* retreive from shadow register */
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 
@@ -631,7 +639,7 @@ static void init_asics(struct comedi_device *dev)
 			/* now clear all the paged registers */
 			switch_page(dev, asic, page);
 			for (reg = FIRST_PAGED_REG;
-				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+			     reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
 				outb(0, baseaddr + reg);
 		}
 
@@ -659,7 +667,7 @@ static void switch_page(struct comedi_device *dev, int asic, int page)
 
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
 #ifdef notused
@@ -673,7 +681,7 @@ static void lock_port(struct comedi_device *dev, int asic, int port)
 	devpriv->asics[asic].pagelock |= 0x1 << port;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
 static void unlock_port(struct comedi_device *dev, int asic, int port)
@@ -685,14 +693,14 @@ static void unlock_port(struct comedi_device *dev, int asic, int port)
 	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
 	/* now write out the shadow register */
 	outb(devpriv->asics[asic].pagelock,
-		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+	     dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 #endif /* notused */
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -702,121 +710,130 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+					  flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
 			if (int_pend) {
 				int port;
 				for (port = 0; port < INTR_PORTS_PER_ASIC;
-					++port) {
+				     ++port) {
 					if (int_pend & (0x1 << port)) {
 						unsigned char
-							io_lines_with_edges = 0;
+						    io_lines_with_edges = 0;
 						switch_page(dev, asic,
-							PAGE_INT_ID);
+							    PAGE_INT_ID);
 						io_lines_with_edges =
-							inb(iobase +
+						    inb(iobase +
 							REG_INT_ID0 + port);
 
 						if (io_lines_with_edges)
 							/* clear pending interrupt */
 							outb(0, iobase +
-								REG_INT_ID0 +
-								port);
+							     REG_INT_ID0 +
+							     port);
 
 						triggered |=
-							io_lines_with_edges <<
-							port * 8;
+						    io_lines_with_edges <<
+						    port * 8;
 					}
 				}
 
 				++got1;
 			}
 
-			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock,
+					       flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
-				printk("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				printk
+				    ("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",
+				     irq, asic, triggered);
 				for (s = dev->subdevices;
-					s < dev->subdevices + dev->n_subdevices;
-					++s) {
+				     s < dev->subdevices + dev->n_subdevices;
+				     ++s) {
 					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
 						unsigned long flags;
 						unsigned oldevents;
 
-						spin_lock_irqsave (&subpriv->intr.spinlock, flags);
+						spin_lock_irqsave(&subpriv->
+								  intr.spinlock,
+								  flags);
 
 						oldevents = s->async->events;
 
 						if (subpriv->intr.active) {
 							unsigned mytrig =
-								((triggered >>
-									subpriv->
-									intr.
-									asic_chan)
-								& ((0x1 << subpriv->intr.num_asic_chans) - 1)) << subpriv->intr.first_chan;
-							if (mytrig & subpriv->
-								intr.
-								enabled_mask) {
-								unsigned int val =
-									0;
+							    ((triggered >>
+							      subpriv->intr.asic_chan)
+							     &
+							     ((0x1 << subpriv->
+							       intr.
+							       num_asic_chans) -
+							      1)) << subpriv->
+							    intr.first_chan;
+							if (mytrig &
+							    subpriv->intr.enabled_mask)
+							{
+								unsigned int val
+								    = 0;
 								unsigned int n,
-									ch, len;
+								    ch, len;
 
-								len = s->async->
-									cmd.
-									chanlist_len;
+								len =
+								    s->
+								    async->cmd.chanlist_len;
 								for (n = 0;
-									n < len;
-									n++) {
+								     n < len;
+								     n++) {
 									ch = CR_CHAN(s->async->cmd.chanlist[n]);
 									if (mytrig & (1U << ch)) {
 										val |= (1U << n);
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) &val)[0])
-									&&
-									comedi_buf_put
-									(s->async, ((short *) &val)[1])) {
+								if (comedi_buf_put(s->async, ((short *)&val)[0])
+								    &&
+								    comedi_buf_put
+								    (s->async,
+								     ((short *)
+								      &val)[1]))
+								{
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */
 									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 									pcmuio_stop_intr
-										(dev,
-										s);
+									    (dev,
+									     s);
 								}
 
 								/* Check for end of acquisition. */
-								if (!subpriv->
-									intr.
-									continuous)
-								{
+								if (!subpriv->intr.continuous) {
 									/* stop_src == TRIG_COUNT */
 									if (subpriv->intr.stop_count > 0) {
-										subpriv->
-											intr.
-											stop_count--;
+										subpriv->intr.stop_count--;
 										if (subpriv->intr.stop_count == 0) {
 											s->async->events |= COMEDI_CB_EOA;
 											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
 											pcmuio_stop_intr
-												(dev,
-												s);
+											    (dev,
+											     s);
 										}
 									}
 								}
 							}
 						}
 
-						spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+						spin_unlock_irqrestore
+						    (&subpriv->intr.spinlock,
+						     flags);
 
 						if (oldevents !=
-							s->async->events) {
+						    s->async->events) {
 							comedi_event(dev, s);
 						}
 
@@ -832,7 +849,8 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pcmuio_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -852,7 +870,8 @@ static void pcmuio_stop_intr(struct comedi_device *dev, struct comedi_subdevice
 	}
 }
 
-static int pcmuio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pcmuio_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -876,27 +895,29 @@ static int pcmuio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 			for (n = 0; n < cmd->chanlist_len; n++) {
 				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
 				pol_bits |= (CR_AREF(cmd->chanlist[n])
-					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
-					<< CR_CHAN(cmd->chanlist[n]);
+					     || CR_RANGE(cmd->
+							 chanlist[n]) ? 1U : 0U)
+				    << CR_CHAN(cmd->chanlist[n]);
 			}
 		}
 		bits &= ((0x1 << subpriv->intr.num_asic_chans) -
-			1) << subpriv->intr.first_chan;
+			 1) << subpriv->intr.first_chan;
 		subpriv->intr.enabled_mask = bits;
 
 		switch_page(dev, asic, PAGE_ENAB);
 		for (port = firstport; port < firstport + nports; ++port) {
 			unsigned enab =
-				bits >> (subpriv->intr.first_chan + (port -
-					firstport) * 8) & 0xff, pol =
-				pol_bits >> (subpriv->intr.first_chan + (port -
-					firstport) * 8) & 0xff;
+			    bits >> (subpriv->intr.first_chan + (port -
+								 firstport) *
+				     8) & 0xff, pol =
+			    pol_bits >> (subpriv->intr.first_chan +
+					 (port - firstport) * 8) & 0xff;
 			/* set enab intrs for this subdev.. */
 			outb(enab,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 			switch_page(dev, asic, PAGE_POL);
 			outb(pol,
-				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			     devpriv->asics[asic].iobase + REG_ENAB0 + port);
 		}
 	}
 	return 0;
@@ -919,7 +940,7 @@ static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  */
 static int
 pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	unsigned long flags;
 	int event = 0;
@@ -986,7 +1007,8 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int
-pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	       struct comedi_cmd *cmd)
 {
 	return comedi_pcm_cmdtest(dev, s, cmd);
 }

commit 0b8f754a6220158f2348bc6eae2772bc64bc98a2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu May 14 15:24:29 2009 -0400

    staging: comedi: Move pcm do_cmdtest function into a single source file
    
    Many of the comedi source code has functions that were created with
    cut and paste, this moves the do_cmdtest function into a single file.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index ce0aa6b87fb0..81ee7cdc0caf 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -77,6 +77,7 @@ Configuration Options:
 
 #include <linux/interrupt.h>
 #include "../comedidev.h"
+#include "pcm_common.h"
 
 #include <linux/pci.h>		/* for PCI devices */
 
@@ -984,110 +985,10 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
- */
 static int
 pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0;
-	unsigned int tmp;
-
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= (TRIG_NOW | TRIG_INT);
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
-
-	if (err)
-		return 1;
-
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
-
-	if (err)
-		return 2;
-
-	/* step 3: make sure arguments are trivially compatible */
-
-	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_begin_src == TRIG_EXT */
-	if (cmd->scan_begin_arg != 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
-
-	/* cmd->convert_src == TRIG_NOW */
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_end_src == TRIG_COUNT */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	/* if (err) return 4; */
-
-	return 0;
+	return comedi_pcm_cmdtest(dev, s, cmd);
 }
 
 /*

commit 214e7b5c8281bf41238f575128e4fec5652ed797
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu May 14 15:24:28 2009 -0400

    staging: comedi: Remove MIN macro
    
    Remove the MIN() macro and instead use the min() provided by kernel.h
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8df67c37795b..ce0aa6b87fb0 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -80,7 +80,6 @@ Configuration Options:
 
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a, b) (((a) < (b)) ? (a) : (b))
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
 #define INTR_PORTS_PER_ASIC   3
@@ -360,7 +359,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_DIO;
 		s->insn_bits = pcmuio_dio_insn_bits;
 		s->insn_config = pcmuio_dio_insn_config;
-		s->n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		s->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv->intr.asic = -1;
 		subpriv->intr.first_chan = -1;
 		subpriv->intr.asic_chan = -1;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 291b6d963fd9..8df67c37795b 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -75,6 +75,7 @@ Configuration Options:
   [2] - IRQ for second ASIC (pcmuio96 only - IRQ for chans 48-72 .. can be the same as first irq!)
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 
 #include <linux/pci.h>		/* for PCI devices */

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index c28e6dfd0f9c..291b6d963fd9 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -322,7 +322,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
 		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
 						   this function when we
-						   comedi_request_irqs */
+						   request_irqs */
 		spin_lock_init(&devpriv->asics[asic].spinlock);
 	}
 
@@ -413,12 +413,12 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
 		if (irq[asic]
-			&& comedi_request_irq(irq[asic], interrupt_pcmuio,
+			&& request_irq(irq[asic], interrupt_pcmuio,
 				IRQF_SHARED, thisboard->name, dev)) {
 			int i;
 			/* unroll the allocated irqs.. */
 			for (i = asic - 1; i >= 0; --i) {
-				comedi_free_irq(irq[i], dev);
+				free_irq(irq[i], dev);
 				devpriv->asics[i].irq = irq[i] = 0;
 			}
 			irq[asic] = 0;
@@ -460,7 +460,7 @@ static int pcmuio_detach(struct comedi_device *dev)
 
 	for (i = 0; i < MAX_ASICS; ++i) {
 		if (devpriv->asics[i].irq)
-			comedi_free_irq(devpriv->asics[i].irq, dev);
+			free_irq(devpriv->asics[i].irq, dev);
 	}
 
 	if (devpriv && devpriv->sprivs)
@@ -701,8 +701,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 			/* it is an interrupt for ASIC #asic */
 			unsigned char int_pend;
 
-			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
-				flags);
+			spin_lock_irqsave(&devpriv->asics[asic].spinlock, flags);
 
 			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
 
@@ -734,8 +733,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 				++got1;
 			}
 
-			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
-				spinlock, flags);
+			spin_unlock_irqrestore(&devpriv->asics[asic].spinlock, flags);
 
 			if (triggered) {
 				struct comedi_subdevice *s;
@@ -748,9 +746,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 						unsigned long flags;
 						unsigned oldevents;
 
-						comedi_spin_lock_irqsave
-							(&subpriv->intr.
-							spinlock, flags);
+						spin_lock_irqsave (&subpriv->intr.spinlock, flags);
 
 						oldevents = s->async->events;
 
@@ -816,9 +812,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 							}
 						}
 
-						comedi_spin_unlock_irqrestore
-							(&subpriv->intr.
-							spinlock, flags);
+						spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 						if (oldevents !=
 							s->async->events) {
@@ -911,10 +905,10 @@ static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	if (subpriv->intr.active)
 		pcmuio_stop_intr(dev, s);
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	return 0;
 }
@@ -932,12 +926,12 @@ pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->intr.active) {
 		event = pcmuio_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -955,7 +949,7 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	spin_lock_irqsave(&subpriv->intr.spinlock, flags);
 	subpriv->intr.active = 1;
 
 	/* Set up end of acquisition. */
@@ -981,7 +975,7 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		event = pcmuio_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e515eadc0fb5..c28e6dfd0f9c 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -250,7 +250,7 @@ static struct comedi_driver driver = {
 	 */
 	.board_name = &pcmuio_boards[0].name,
 	.offset = sizeof(struct pcmuio_board),
-	.num_names = sizeof(pcmuio_boards) / sizeof(struct pcmuio_board),
+	.num_names = ARRAY_SIZE(pcmuio_boards),
 };
 
 static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index bf419e0445b4..e515eadc0fb5 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -253,24 +253,24 @@ static struct comedi_driver driver = {
 	.num_names = sizeof(pcmuio_boards) / sizeof(struct pcmuio_board),
 };
 
-static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d);
 static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
-static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
+static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
-static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
-static void switch_page(struct comedi_device * dev, int asic, int page);
+static void init_asics(struct comedi_device *dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(struct comedi_device *dev, int asic, int page);
 #ifdef notused
-static void lock_port(struct comedi_device * dev, int asic, int port);
-static void unlock_port(struct comedi_device * dev, int asic, int port);
+static void lock_port(struct comedi_device *dev, int asic, int port);
+static void unlock_port(struct comedi_device *dev, int asic, int port);
 #endif
 
 /*

commit 9b9bcba0cafa2578cebbe0eca01eaafd49f3e43b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:53 2009 -0400

    Staging: comedi: remove space after ampersand
    
    Change calses of & foo to &foo as suggested by checkpatch.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index e02017369f72..bf419e0445b4 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -781,10 +781,10 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((short *) & val)[0])
+								if (comedi_buf_put(s->async, ((short *) &val)[0])
 									&&
 									comedi_buf_put
-									(s->async, ((short *) & val)[1])) {
+									(s->async, ((short *) &val)[1])) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index cc62f518128e..e02017369f72 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -155,14 +155,14 @@ struct pcmuio_board {
 
 static const struct pcmuio_board pcmuio_boards[] = {
 	{
-	      name:	"pcmuio48",
-	      num_asics:1,
-	      num_ports:6,
+	.name = "pcmuio48",
+	.num_asics = 1,
+	.num_ports = 6,
 		},
 	{
-	      name:	"pcmuio96",
-	      num_asics:2,
-	      num_ports:12,
+	.name = "pcmuio96",
+	.num_asics = 2,
+	.num_ports = 12,
 		},
 };
 
@@ -226,10 +226,10 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static int pcmuio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
-      driver_name:"pcmuio",
-      module:THIS_MODULE,
-      attach:pcmuio_attach,
-      detach:pcmuio_detach,
+	.driver_name = "pcmuio",
+	.module = THIS_MODULE,
+	.attach = pcmuio_attach,
+	.detach = pcmuio_detach,
 /* It is not necessary to implement the following members if you are
  * writing a driver for a ISA PnP or PCI card */
 	/* Most drivers will support multiple types of boards by
@@ -248,9 +248,9 @@ static struct comedi_driver driver = {
 	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
 	 * devices are such boards.
 	 */
-      board_name:&pcmuio_boards[0].name,
-      offset:sizeof(struct pcmuio_board),
-      num_names:sizeof(pcmuio_boards) / sizeof(struct pcmuio_board),
+	.board_name = &pcmuio_boards[0].name,
+	.offset = sizeof(struct pcmuio_board),
+	.num_names = sizeof(pcmuio_boards) / sizeof(struct pcmuio_board),
 };
 
 static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7e442dbd2c19..cc62f518128e 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -841,7 +841,8 @@ static void pcmuio_stop_intr(struct comedi_device *dev, struct comedi_subdevice
 {
 	int nports, firstport, asic, port;
 
-	if ((asic = subpriv->intr.asic) < 0)
+	asic = subpriv->intr.asic;
+	if (asic < 0)
 		return;		/* not an interrupt subdev */
 
 	subpriv->intr.enabled_mask = 0;
@@ -868,7 +869,8 @@ static int pcmuio_start_intr(struct comedi_device *dev, struct comedi_subdevice
 		int nports, firstport, asic, port;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
-		if ((asic = subpriv->intr.asic) < 0)
+		asic = subpriv->intr.asic;
+		if (asic < 0)
 			return 1;	/* not an interrupt
 					   subdev */
 		subpriv->intr.enabled_mask = 0;

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 54971a1cb908..7e442dbd2c19 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -79,7 +79,7 @@ Configuration Options:
 
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
 #define INTR_PORTS_PER_ASIC   3

commit f7cbd7aad063b2a4b7aff6a743b2b00015ce3c3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:16 2009 -0400

    Staging: comedi: Add spaces after commas
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 04fff9dfe87d..54971a1cb908 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -79,7 +79,7 @@ Configuration Options:
 
 #include <linux/pci.h>		/* for PCI devices */
 
-#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
+#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
 #define INTR_PORTS_PER_ASIC   3

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index de9c13554ca1..04fff9dfe87d 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -222,8 +222,8 @@ struct pcmuio_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pcmuio_detach(struct comedi_device * dev);
+static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pcmuio_detach(struct comedi_device *dev);
 
 static struct comedi_driver driver = {
       driver_name:"pcmuio",
@@ -279,7 +279,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
@@ -450,7 +450,7 @@ static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pcmuio_detach(struct comedi_device * dev)
+static int pcmuio_detach(struct comedi_device *dev)
 {
 	int i;
 
@@ -474,8 +474,8 @@ static int pcmuio_detach(struct comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcmuio_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -548,8 +548,8 @@ static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pcmuio_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;
@@ -609,7 +609,7 @@ static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subd
 	return insn->n;
 }
 
-static void init_asics(struct comedi_device * dev)
+static void init_asics(struct comedi_device *dev)
 {				/* sets up an
 				   ASIC chip to defaults */
 	int asic;
@@ -646,7 +646,7 @@ static void init_asics(struct comedi_device * dev)
 	}
 }
 
-static void switch_page(struct comedi_device * dev, int asic, int page)
+static void switch_page(struct comedi_device *dev, int asic, int page)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -662,7 +662,7 @@ static void switch_page(struct comedi_device * dev, int asic, int page)
 }
 
 #ifdef notused
-static void lock_port(struct comedi_device * dev, int asic, int port)
+static void lock_port(struct comedi_device *dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -675,7 +675,7 @@ static void lock_port(struct comedi_device * dev, int asic, int port)
 		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
-static void unlock_port(struct comedi_device * dev, int asic, int port)
+static void unlock_port(struct comedi_device *dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -837,7 +837,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pcmuio_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int nports, firstport, asic, port;
 
@@ -856,7 +856,7 @@ static void pcmuio_stop_intr(struct comedi_device * dev, struct comedi_subdevice
 	}
 }
 
-static int pcmuio_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmuio_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -905,7 +905,7 @@ static int pcmuio_start_intr(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -921,7 +921,7 @@ static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
+pcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -947,7 +947,7 @@ pcmuio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -992,7 +992,7 @@ static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
+pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 4e7d8b6327fd..de9c13554ca1 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -258,7 +258,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
 static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data);
 
-static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
+static irqreturn_t interrupt_pcmuio(int irq, void *d);
 static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -688,7 +688,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port)
 }
 #endif /* notused */
 
-static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
+static irqreturn_t interrupt_pcmuio(int irq, void *d)
 {
 	int asic, got1 = 0;
 	struct comedi_device *dev = (struct comedi_device *) d;

commit 055f6636d9eb27bc13236e07739e019496c21221
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:20:36 2009 -0400

    Staging: comedi: Remove pcmuio_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 89cf5d417748..4e7d8b6327fd 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -197,7 +197,7 @@ struct pcmuio_subdev_private {
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct pcmuio_private {
 	struct {
 		unsigned char pagelock;	/* current page and lock */
 		unsigned char pol[NUM_PAGED_REGS];	/* shadow of POLx registers */
@@ -208,13 +208,13 @@ typedef struct {
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
 	struct pcmuio_subdev_private *sprivs;
-} pcmuio_private;
+};
 
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
-#define devpriv ((pcmuio_private *)dev->private)
+#define devpriv ((struct pcmuio_private *)dev->private)
 #define subpriv ((struct pcmuio_subdev_private *)s->private)
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -312,7 +312,7 @@ static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_private(dev, sizeof(pcmuio_private)) < 0) {
+	if (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {
 		printk("cannot allocate private data structure\n");
 		return -ENOMEM;
 	}

commit e15849e54405152087cd343437747db8d931fcd7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:42 2009 -0400

    Staging: comedi: Remove pcmuio_subdev_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index b995107779b4..89cf5d417748 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -172,7 +172,7 @@ static const struct pcmuio_board pcmuio_boards[] = {
 #define thisboard ((const struct pcmuio_board *)dev->board_ptr)
 
 /* this structure is for data unique to this subdevice.  */
-typedef struct {
+struct pcmuio_subdev_private {
 	/* mapping of halfwords (bytes) in port/chanarray to iobase */
 	unsigned long iobases[PORTS_PER_SUBDEV];
 
@@ -192,7 +192,7 @@ typedef struct {
 		int continuous;
 		spinlock_t spinlock;
 	} intr;
-} pcmuio_subdev_private;
+};
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -207,7 +207,7 @@ typedef struct {
 		unsigned int irq;
 		spinlock_t spinlock;
 	} asics[MAX_ASICS];
-	pcmuio_subdev_private *sprivs;
+	struct pcmuio_subdev_private *sprivs;
 } pcmuio_private;
 
 /*
@@ -215,7 +215,7 @@ typedef struct {
  * access the private structure.
  */
 #define devpriv ((pcmuio_private *)dev->private)
-#define subpriv ((pcmuio_subdev_private *)s->private)
+#define subpriv ((struct pcmuio_subdev_private *)s->private)
 /*
  * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
@@ -329,7 +329,7 @@ static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
 	n_subdevs = CALC_N_SUBDEVS(chans_left);
 	devpriv->sprivs =
-		kcalloc(n_subdevs, sizeof(pcmuio_subdev_private), GFP_KERNEL);
+		kcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private), GFP_KERNEL);
 	if (!devpriv->sprivs) {
 		printk("cannot allocate subdevice private data structures\n");
 		return -ENOMEM;

commit 70a6001aeffeaa12f2a1c21470e8f3bdfb6ef8e7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:10 2009 -0400

    Staging: comedi: Remove pcmuio_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 97ae34955d67..b995107779b4 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -146,14 +146,14 @@ Configuration Options:
  * boards in this way is optional, and completely driver-dependent.
  * Some drivers use arrays such as this, other do not.
  */
-typedef struct pcmuio_board_struct {
+struct pcmuio_board {
 	const char *name;
 	const int num_asics;
 	const int num_channels_per_port;
 	const int num_ports;
-} pcmuio_board;
+};
 
-static const pcmuio_board pcmuio_boards[] = {
+static const struct pcmuio_board pcmuio_boards[] = {
 	{
 	      name:	"pcmuio48",
 	      num_asics:1,
@@ -169,7 +169,7 @@ static const pcmuio_board pcmuio_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const pcmuio_board *)dev->board_ptr)
+#define thisboard ((const struct pcmuio_board *)dev->board_ptr)
 
 /* this structure is for data unique to this subdevice.  */
 typedef struct {
@@ -249,8 +249,8 @@ static struct comedi_driver driver = {
 	 * devices are such boards.
 	 */
       board_name:&pcmuio_boards[0].name,
-      offset:sizeof(pcmuio_board),
-      num_names:sizeof(pcmuio_boards) / sizeof(pcmuio_board),
+      offset:sizeof(struct pcmuio_board),
+      num_names:sizeof(pcmuio_boards) / sizeof(struct pcmuio_board),
 };
 
 static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index fca574b60436..97ae34955d67 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -222,7 +222,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pcmuio_detach(struct comedi_device * dev);
 
 static struct comedi_driver driver = {
@@ -279,7 +279,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pcmuio_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 2c460cf67c89..fca574b60436 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -254,9 +254,9 @@ static struct comedi_driver driver = {
 };
 
 static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
 static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
@@ -475,7 +475,7 @@ static int pcmuio_detach(struct comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -549,7 +549,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7204084073f0..2c460cf67c89 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -263,7 +263,7 @@ static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
 static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
 static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
@@ -866,7 +866,7 @@ static int pcmuio_start_intr(struct comedi_device * dev, struct comedi_subdevice
 	} else {
 		unsigned bits = 0, pol_bits = 0, n;
 		int nports, firstport, asic, port;
-		comedi_cmd *cmd = &s->async->cmd;
+		struct comedi_cmd *cmd = &s->async->cmd;
 
 		if ((asic = subpriv->intr.asic) < 0)
 			return 1;	/* not an interrupt
@@ -949,7 +949,7 @@ pcmuio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
  */
 static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int event = 0;
 
@@ -992,7 +992,7 @@ static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
+pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 6dc42eb047d3..7204084073f0 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -217,7 +217,7 @@ typedef struct {
 #define devpriv ((pcmuio_private *)dev->private)
 #define subpriv ((pcmuio_subdev_private *)s->private)
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
@@ -225,7 +225,7 @@ typedef struct {
 static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int pcmuio_detach(struct comedi_device * dev);
 
-static comedi_driver driver = {
+static struct comedi_driver driver = {
       driver_name:"pcmuio",
       module:THIS_MODULE,
       attach:pcmuio_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index d2af7082c1e8..6dc42eb047d3 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -253,16 +253,16 @@ static comedi_driver driver = {
       num_names:sizeof(pcmuio_boards) / sizeof(pcmuio_board),
 };
 
-static int pcmuio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pcmuio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
-static void pcmuio_stop_intr(struct comedi_device *, comedi_subdevice *);
-static int pcmuio_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static int pcmuio_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int pcmuio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static void pcmuio_stop_intr(struct comedi_device *, struct comedi_subdevice *);
+static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
@@ -281,7 +281,7 @@ static void unlock_port(struct comedi_device * dev, int asic, int port);
  */
 static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
 	unsigned long iobase;
 	unsigned int irq[MAX_ASICS];
@@ -474,7 +474,7 @@ static int pcmuio_detach(struct comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmuio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
@@ -548,7 +548,7 @@ static int pcmuio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmuio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
@@ -738,7 +738,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 				spinlock, flags);
 
 			if (triggered) {
-				comedi_subdevice *s;
+				struct comedi_subdevice *s;
 				/* TODO here: dispatch io lines to subdevs with commands.. */
 				printk("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
 				for (s = dev->subdevices;
@@ -837,7 +837,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
+static void pcmuio_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int nports, firstport, asic, port;
 
@@ -856,7 +856,7 @@ static void pcmuio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pcmuio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -905,7 +905,7 @@ static int pcmuio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcmuio_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -921,7 +921,7 @@ static int pcmuio_cancel(struct comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
+pcmuio_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -947,7 +947,7 @@ pcmuio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmuio_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -992,7 +992,7 @@ static int pcmuio_cmd(struct comedi_device * dev, comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pcmuio_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index f40f91987e30..d2af7082c1e8 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -196,7 +196,7 @@ typedef struct {
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 	struct {
 		unsigned char pagelock;	/* current page and lock */
@@ -222,8 +222,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pcmuio_attach(comedi_device * dev, comedi_devconfig * it);
-static int pcmuio_detach(comedi_device * dev);
+static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pcmuio_detach(struct comedi_device * dev);
 
 static comedi_driver driver = {
       driver_name:"pcmuio",
@@ -253,24 +253,24 @@ static comedi_driver driver = {
       num_names:sizeof(pcmuio_boards) / sizeof(pcmuio_board),
 };
 
-static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
-static void pcmuio_stop_intr(comedi_device *, comedi_subdevice *);
-static int pcmuio_cancel(comedi_device * dev, comedi_subdevice * s);
-static int pcmuio_cmd(comedi_device * dev, comedi_subdevice * s);
-static int pcmuio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static void pcmuio_stop_intr(struct comedi_device *, comedi_subdevice *);
+static int pcmuio_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int pcmuio_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int pcmuio_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 
 /* some helper functions to deal with specifics of this device's registers */
-static void init_asics(comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
-static void switch_page(comedi_device * dev, int asic, int page);
+static void init_asics(struct comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(struct comedi_device * dev, int asic, int page);
 #ifdef notused
-static void lock_port(comedi_device * dev, int asic, int port);
-static void unlock_port(comedi_device * dev, int asic, int port);
+static void lock_port(struct comedi_device * dev, int asic, int port);
+static void unlock_port(struct comedi_device * dev, int asic, int port);
 #endif
 
 /*
@@ -279,7 +279,7 @@ static void unlock_port(comedi_device * dev, int asic, int port);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pcmuio_attach(comedi_device * dev, comedi_devconfig * it)
+static int pcmuio_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
@@ -450,7 +450,7 @@ static int pcmuio_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pcmuio_detach(comedi_device * dev)
+static int pcmuio_detach(struct comedi_device * dev)
 {
 	int i;
 
@@ -474,7 +474,7 @@ static int pcmuio_detach(comedi_device * dev)
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
@@ -548,7 +548,7 @@ static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
  * configured by a special insn_config instruction.  chanspec
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
-static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int pcmuio_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
@@ -609,7 +609,7 @@ static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-static void init_asics(comedi_device * dev)
+static void init_asics(struct comedi_device * dev)
 {				/* sets up an
 				   ASIC chip to defaults */
 	int asic;
@@ -646,7 +646,7 @@ static void init_asics(comedi_device * dev)
 	}
 }
 
-static void switch_page(comedi_device * dev, int asic, int page)
+static void switch_page(struct comedi_device * dev, int asic, int page)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -662,7 +662,7 @@ static void switch_page(comedi_device * dev, int asic, int page)
 }
 
 #ifdef notused
-static void lock_port(comedi_device * dev, int asic, int port)
+static void lock_port(struct comedi_device * dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -675,7 +675,7 @@ static void lock_port(comedi_device * dev, int asic, int port)
 		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
 }
 
-static void unlock_port(comedi_device * dev, int asic, int port)
+static void unlock_port(struct comedi_device * dev, int asic, int port)
 {
 	if (asic < 0 || asic >= thisboard->num_asics)
 		return;		/* paranoia */
@@ -691,7 +691,7 @@ static void unlock_port(comedi_device * dev, int asic, int port)
 static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 {
 	int asic, got1 = 0;
-	comedi_device *dev = (comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *) d;
 
 	for (asic = 0; asic < MAX_ASICS; ++asic) {
 		if (irq == devpriv->asics[asic].irq) {
@@ -837,7 +837,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void pcmuio_stop_intr(comedi_device * dev, comedi_subdevice * s)
+static void pcmuio_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int nports, firstport, asic, port;
 
@@ -856,7 +856,7 @@ static void pcmuio_stop_intr(comedi_device * dev, comedi_subdevice * s)
 	}
 }
 
-static int pcmuio_start_intr(comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_start_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
 		/* An empty acquisition! */
@@ -905,7 +905,7 @@ static int pcmuio_start_intr(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int pcmuio_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -921,7 +921,7 @@ static int pcmuio_cancel(comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+pcmuio_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -947,7 +947,7 @@ pcmuio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int pcmuio_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pcmuio_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -992,7 +992,7 @@ static int pcmuio_cmd(comedi_device * dev, comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-pcmuio_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pcmuio_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8458b054331c..f40f91987e30 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -254,9 +254,9 @@ static comedi_driver driver = {
 };
 
 static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
 static void pcmuio_stop_intr(comedi_device *, comedi_subdevice *);
@@ -475,7 +475,7 @@ static int pcmuio_detach(comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int byte_no;
 	if (insn->n != 2)
@@ -549,7 +549,7 @@ static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
  * contains the channel to be changed, and data[0] contains the
  * value COMEDI_INPUT or COMEDI_OUTPUT. */
 static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
 		chan % 8;
@@ -764,7 +764,7 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 							if (mytrig & subpriv->
 								intr.
 								enabled_mask) {
-								lsampl_t val =
+								unsigned int val =
 									0;
 								unsigned int n,
 									ch, len;
@@ -781,10 +781,10 @@ static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
 									}
 								}
 								/* Write the scan to the buffer. */
-								if (comedi_buf_put(s->async, ((sampl_t *) & val)[0])
+								if (comedi_buf_put(s->async, ((short *) & val)[0])
 									&&
 									comedi_buf_put
-									(s->async, ((sampl_t *) & val)[1])) {
+									(s->async, ((short *) & val)[1])) {
 									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 								} else {
 									/* Overflow! Stop acquisition!! */

commit 6baef150380d561a4d695a6be4fc509821c23611
Author: Calin Culianu <calin@ajvar.org>
Date:   Thu Feb 19 09:13:10 2009 -0800

    Staging: comedi: add pcmmio and pcmuio drivers
    
    Drivers for Winsystems PC-104 based multifunction IO board and 48
    channel and 98 channel dio boards
    
    From: Calin Culianu <calin@ajvar.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
new file mode 100644
index 000000000000..8458b054331c
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -0,0 +1,1101 @@
+/*
+    comedi/drivers/pcmuio.c
+    Driver for Winsystems PC-104 based 48-channel and 96-channel DIO boards.
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2006 Calin A. Culianu <calin@ajvar.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+/*
+Driver: pcmuio
+Description: A driver for the PCM-UIO48A and PCM-UIO96A boards from Winsystems.
+Devices: [Winsystems] PCM-UIO48A (pcmuio48), PCM-UIO96A (pcmuio96)
+Author: Calin Culianu <calin@ajvar.org>
+Updated: Fri, 13 Jan 2006 12:01:01 -0500
+Status: works
+
+A driver for the relatively straightforward-to-program PCM-UIO48A and
+PCM-UIO96A boards from Winsystems.  These boards use either one or two
+(in the 96-DIO version) WS16C48 ASIC HighDensity I/O Chips (HDIO).
+This chip is interesting in that each I/O line is individually
+programmable for INPUT or OUTPUT (thus comedi_dio_config can be done
+on a per-channel basis).  Also, each chip supports edge-triggered
+interrupts for the first 24 I/O lines.  Of course, since the
+96-channel version of the board has two ASICs, it can detect polarity
+changes on up to 48 I/O lines.  Since this is essentially an (non-PnP)
+ISA board, I/O Address and IRQ selection are done through jumpers on
+the board.  You need to pass that information to this driver as the
+first and second comedi_config option, respectively.  Note that the
+48-channel version uses 16 bytes of IO memory and the 96-channel
+version uses 32-bytes (in case you are worried about conflicts).  The
+48-channel board is split into two 24-channel comedi subdevices.
+The 96-channel board is split into 4 24-channel DIO subdevices.
+
+Note that IRQ support has been added, but it is untested.
+
+To use edge-detection IRQ support, pass the IRQs of both ASICS
+(for the 96 channel version) or just 1 ASIC (for 48-channel version).
+Then, use use comedi_commands with TRIG_NOW.
+Your callback will be called each time an edge is triggered, and the data
+values will be two sample_t's, which should be concatenated to form one
+32-bit unsigned int.  This value is the mask of channels that had
+edges detected from your channel list.  Note that the bits positions
+in the mask correspond to positions in your chanlist when you specified
+the command and *not* channel id's!
+
+To set the polarity of the edge-detection interrupts pass a nonzero value for
+either CR_RANGE or CR_AREF for edge-up polarity, or a zero value for both
+CR_RANGE and CR_AREF if you want edge-down polarity.
+
+In the 48-channel version:
+
+On subdev 0, the first 24 channels channels are edge-detect channels.
+
+In the 96-channel board you have the collowing channels that can do edge detection:
+
+subdev 0, channels 0-24  (first 24 channels of 1st ASIC)
+subdev 2, channels 0-24  (first 24 channels of 2nd ASIC)
+
+Configuration Options:
+  [0] - I/O port base address
+  [1] - IRQ (for first ASIC, or first 24 channels)
+  [2] - IRQ for second ASIC (pcmuio96 only - IRQ for chans 48-72 .. can be the same as first irq!)
+*/
+
+#include "../comedidev.h"
+
+#include <linux/pci.h>		/* for PCI devices */
+
+#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
+#define CHANS_PER_PORT   8
+#define PORTS_PER_ASIC   6
+#define INTR_PORTS_PER_ASIC   3
+#define MAX_CHANS_PER_SUBDEV 24	/* number of channels per comedi subdevice */
+#define PORTS_PER_SUBDEV (MAX_CHANS_PER_SUBDEV/CHANS_PER_PORT)
+#define CHANS_PER_ASIC (CHANS_PER_PORT*PORTS_PER_ASIC)
+#define INTR_CHANS_PER_ASIC 24
+#define INTR_PORTS_PER_SUBDEV (INTR_CHANS_PER_ASIC/CHANS_PER_PORT)
+#define MAX_DIO_CHANS   (PORTS_PER_ASIC*2*CHANS_PER_PORT)
+#define MAX_ASICS       (MAX_DIO_CHANS/CHANS_PER_ASIC)
+#define SDEV_NO ((int)(s - dev->subdevices))
+#define CALC_N_SUBDEVS(nchans) ((nchans)/MAX_CHANS_PER_SUBDEV + (!!((nchans)%MAX_CHANS_PER_SUBDEV)) /*+ (nchans > INTR_CHANS_PER_ASIC ? 2 : 1)*/)
+/* IO Memory sizes */
+#define ASIC_IOSIZE (0x10)
+#define PCMUIO48_IOSIZE ASIC_IOSIZE
+#define PCMUIO96_IOSIZE (ASIC_IOSIZE*2)
+
+/* Some offsets - these are all in the 16byte IO memory offset from
+   the base address.  Note that there is a paging scheme to swap out
+   offsets 0x8-0xA using the PAGELOCK register.  See the table below.
+
+  Register(s)       Pages        R/W?        Description
+  --------------------------------------------------------------
+  REG_PORTx         All          R/W         Read/Write/Configure IO
+  REG_INT_PENDING   All          ReadOnly    Quickly see which INT_IDx has int.
+  REG_PAGELOCK      All          WriteOnly   Select a page
+  REG_POLx          Pg. 1 only   WriteOnly   Select edge-detection polarity
+  REG_ENABx         Pg. 2 only   WriteOnly   Enable/Disable edge-detect. int.
+  REG_INT_IDx       Pg. 3 only   R/W         See which ports/bits have ints.
+ */
+#define REG_PORT0 0x0
+#define REG_PORT1 0x1
+#define REG_PORT2 0x2
+#define REG_PORT3 0x3
+#define REG_PORT4 0x4
+#define REG_PORT5 0x5
+#define REG_INT_PENDING 0x6
+#define REG_PAGELOCK 0x7	/* page selector register, upper 2 bits select a page
+				   and bits 0-5 are used to 'lock down' a particular
+				   port above to make it readonly.  */
+#define REG_POL0 0x8
+#define REG_POL1 0x9
+#define REG_POL2 0xA
+#define REG_ENAB0 0x8
+#define REG_ENAB1 0x9
+#define REG_ENAB2 0xA
+#define REG_INT_ID0 0x8
+#define REG_INT_ID1 0x9
+#define REG_INT_ID2 0xA
+
+#define NUM_PAGED_REGS 3
+#define NUM_PAGES 4
+#define FIRST_PAGED_REG 0x8
+#define REG_PAGE_BITOFFSET 6
+#define REG_LOCK_BITOFFSET 0
+#define REG_PAGE_MASK (~((0x1<<REG_PAGE_BITOFFSET)-1))
+#define REG_LOCK_MASK ~(REG_PAGE_MASK)
+#define PAGE_POL 1
+#define PAGE_ENAB 2
+#define PAGE_INT_ID 3
+
+/*
+ * Board descriptions for two imaginary boards.  Describing the
+ * boards in this way is optional, and completely driver-dependent.
+ * Some drivers use arrays such as this, other do not.
+ */
+typedef struct pcmuio_board_struct {
+	const char *name;
+	const int num_asics;
+	const int num_channels_per_port;
+	const int num_ports;
+} pcmuio_board;
+
+static const pcmuio_board pcmuio_boards[] = {
+	{
+	      name:	"pcmuio48",
+	      num_asics:1,
+	      num_ports:6,
+		},
+	{
+	      name:	"pcmuio96",
+	      num_asics:2,
+	      num_ports:12,
+		},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const pcmuio_board *)dev->board_ptr)
+
+/* this structure is for data unique to this subdevice.  */
+typedef struct {
+	/* mapping of halfwords (bytes) in port/chanarray to iobase */
+	unsigned long iobases[PORTS_PER_SUBDEV];
+
+	/* The below is only used for intr subdevices */
+	struct {
+		int asic;	/* if non-negative, this subdev has an interrupt asic */
+		int first_chan;	/* if nonnegative, the first channel id for
+				   interrupts. */
+		int num_asic_chans;	/* the number of asic channels in this subdev
+					   that have interrutps */
+		int asic_chan;	/* if nonnegative, the first channel id with
+				   respect to the asic that has interrupts */
+		int enabled_mask;	/* subdev-relative channel mask for channels
+					   we are interested in */
+		int active;
+		int stop_count;
+		int continuous;
+		spinlock_t spinlock;
+	} intr;
+} pcmuio_subdev_private;
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+	struct {
+		unsigned char pagelock;	/* current page and lock */
+		unsigned char pol[NUM_PAGED_REGS];	/* shadow of POLx registers */
+		unsigned char enab[NUM_PAGED_REGS];	/* shadow of ENABx registers */
+		int num;
+		unsigned long iobase;
+		unsigned int irq;
+		spinlock_t spinlock;
+	} asics[MAX_ASICS];
+	pcmuio_subdev_private *sprivs;
+} pcmuio_private;
+
+/*
+ * most drivers define the following macro to make it easy to
+ * access the private structure.
+ */
+#define devpriv ((pcmuio_private *)dev->private)
+#define subpriv ((pcmuio_subdev_private *)s->private)
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int pcmuio_attach(comedi_device * dev, comedi_devconfig * it);
+static int pcmuio_detach(comedi_device * dev);
+
+static comedi_driver driver = {
+      driver_name:"pcmuio",
+      module:THIS_MODULE,
+      attach:pcmuio_attach,
+      detach:pcmuio_detach,
+/* It is not necessary to implement the following members if you are
+ * writing a driver for a ISA PnP or PCI card */
+	/* Most drivers will support multiple types of boards by
+	 * having an array of board structures.  These were defined
+	 * in pcmuio_boards[] above.  Note that the element 'name'
+	 * was first in the structure -- Comedi uses this fact to
+	 * extract the name of the board without knowing any details
+	 * about the structure except for its length.
+	 * When a device is attached (by comedi_config), the name
+	 * of the device is given to Comedi, and Comedi tries to
+	 * match it by going through the list of board names.  If
+	 * there is a match, the address of the pointer is put
+	 * into dev->board_ptr and driver->attach() is called.
+	 *
+	 * Note that these are not necessary if you can determine
+	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
+	 * devices are such boards.
+	 */
+      board_name:&pcmuio_boards[0].name,
+      offset:sizeof(pcmuio_board),
+      num_names:sizeof(pcmuio_boards) / sizeof(pcmuio_board),
+};
+
+static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG);
+static void pcmuio_stop_intr(comedi_device *, comedi_subdevice *);
+static int pcmuio_cancel(comedi_device * dev, comedi_subdevice * s);
+static int pcmuio_cmd(comedi_device * dev, comedi_subdevice * s);
+static int pcmuio_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+
+/* some helper functions to deal with specifics of this device's registers */
+static void init_asics(comedi_device * dev);	/* sets up/clears ASIC chips to defaults */
+static void switch_page(comedi_device * dev, int asic, int page);
+#ifdef notused
+static void lock_port(comedi_device * dev, int asic, int port);
+static void unlock_port(comedi_device * dev, int asic, int port);
+#endif
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int pcmuio_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	int sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;
+	unsigned long iobase;
+	unsigned int irq[MAX_ASICS];
+
+	iobase = it->options[0];
+	irq[0] = it->options[1];
+	irq[1] = it->options[2];
+
+	printk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,
+		iobase);
+
+	dev->iobase = iobase;
+
+	if (!iobase || !request_region(iobase,
+			thisboard->num_asics * ASIC_IOSIZE,
+			driver.driver_name)) {
+		printk("I/O port conflict\n");
+		return -EIO;
+	}
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(pcmuio_private)) < 0) {
+		printk("cannot allocate private data structure\n");
+		return -ENOMEM;
+	}
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		devpriv->asics[asic].num = asic;
+		devpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;
+		devpriv->asics[asic].irq = 0;	/* this gets actually set at the end of
+						   this function when we
+						   comedi_request_irqs */
+		spin_lock_init(&devpriv->asics[asic].spinlock);
+	}
+
+	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
+	n_subdevs = CALC_N_SUBDEVS(chans_left);
+	devpriv->sprivs =
+		kcalloc(n_subdevs, sizeof(pcmuio_subdev_private), GFP_KERNEL);
+	if (!devpriv->sprivs) {
+		printk("cannot allocate subdevice private data structures\n");
+		return -ENOMEM;
+	}
+	/*
+	 * Allocate the subdevice structures.  alloc_subdevice() is a
+	 * convenient macro defined in comedidev.h.
+	 *
+	 * Allocate 2 subdevs (32 + 16 DIO lines) or 3 32 DIO subdevs for the
+	 * 96-channel version of the board.
+	 */
+	if (alloc_subdevices(dev, n_subdevs) < 0) {
+		printk("cannot allocate subdevice data structures\n");
+		return -ENOMEM;
+	}
+
+	port = 0;
+	asic = 0;
+	for (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {
+		int byte_no;
+
+		s = dev->subdevices + sdev_no;
+		s->private = devpriv->sprivs + sdev_no;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->type = COMEDI_SUBD_DIO;
+		s->insn_bits = pcmuio_dio_insn_bits;
+		s->insn_config = pcmuio_dio_insn_config;
+		s->n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		subpriv->intr.asic = -1;
+		subpriv->intr.first_chan = -1;
+		subpriv->intr.asic_chan = -1;
+		subpriv->intr.num_asic_chans = -1;
+		subpriv->intr.active = 0;
+		s->len_chanlist = 1;
+
+		/* save the ioport address for each 'port' of 8 channels in the
+		   subdevice */
+		for (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {
+			if (port >= PORTS_PER_ASIC) {
+				port = 0;
+				++asic;
+				thisasic_chanct = 0;
+			}
+			subpriv->iobases[byte_no] =
+				devpriv->asics[asic].iobase + port;
+
+			if (thisasic_chanct <
+				CHANS_PER_PORT * INTR_PORTS_PER_ASIC
+				&& subpriv->intr.asic < 0) {
+				/* this is an interrupt subdevice, so setup the struct */
+				subpriv->intr.asic = asic;
+				subpriv->intr.active = 0;
+				subpriv->intr.stop_count = 0;
+				subpriv->intr.first_chan = byte_no * 8;
+				subpriv->intr.asic_chan = thisasic_chanct;
+				subpriv->intr.num_asic_chans =
+					s->n_chan - subpriv->intr.first_chan;
+				dev->read_subdev = s;
+				s->subdev_flags |= SDF_CMD_READ;
+				s->cancel = pcmuio_cancel;
+				s->do_cmd = pcmuio_cmd;
+				s->do_cmdtest = pcmuio_cmdtest;
+				s->len_chanlist = subpriv->intr.num_asic_chans;
+			}
+			thisasic_chanct += CHANS_PER_PORT;
+		}
+		spin_lock_init(&subpriv->intr.spinlock);
+
+		chans_left -= s->n_chan;
+
+		if (!chans_left) {
+			asic = 0;	/* reset the asic to our first asic, to do intr subdevs */
+			port = 0;
+		}
+
+	}
+
+	init_asics(dev);	/* clear out all the registers, basically */
+
+	for (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {
+		if (irq[asic]
+			&& comedi_request_irq(irq[asic], interrupt_pcmuio,
+				IRQF_SHARED, thisboard->name, dev)) {
+			int i;
+			/* unroll the allocated irqs.. */
+			for (i = asic - 1; i >= 0; --i) {
+				comedi_free_irq(irq[i], dev);
+				devpriv->asics[i].irq = irq[i] = 0;
+			}
+			irq[asic] = 0;
+		}
+		devpriv->asics[asic].irq = irq[asic];
+	}
+
+	dev->irq = irq[0];	/* grr.. wish comedi dev struct supported multiple
+				   irqs.. */
+
+	if (irq[0]) {
+		printk("irq: %u ", irq[0]);
+		if (irq[1] && thisboard->num_asics == 2)
+			printk("second ASIC irq: %u ", irq[1]);
+	} else {
+		printk("(IRQ mode disabled) ");
+	}
+
+	printk("attached\n");
+
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int pcmuio_detach(comedi_device * dev)
+{
+	int i;
+
+	printk("comedi%d: %s: remove\n", dev->minor, driver.driver_name);
+	if (dev->iobase)
+		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
+
+	for (i = 0; i < MAX_ASICS; ++i) {
+		if (devpriv->asics[i].irq)
+			comedi_free_irq(devpriv->asics[i].irq, dev);
+	}
+
+	if (devpriv && devpriv->sprivs)
+		kfree(devpriv->sprivs);
+
+	return 0;
+}
+
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The
+ * comedi core can convert between insn_bits and insn_read/write */
+static int pcmuio_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int byte_no;
+	if (insn->n != 2)
+		return -EINVAL;
+
+	/* NOTE:
+	   reading a 0 means this channel was high
+	   writine a 0 sets the channel high
+	   reading a 1 means this channel was low
+	   writing a 1 means set this channel low
+
+	   Therefore everything is always inverted. */
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+
+#ifdef DAMMIT_ITS_BROKEN
+	/* DEBUG */
+	printk("write mask: %08x  data: %08x\n", data[0], data[1]);
+#endif
+
+	s->state = 0;
+
+	for (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {
+		/* address of 8-bit port */
+		unsigned long ioaddr = subpriv->iobases[byte_no],
+			/* bit offset of port in 32-bit doubleword */
+			offset = byte_no * 8;
+		/* this 8-bit port's data */
+		unsigned char byte = 0,
+			/* The write mask for this port (if any) */
+			write_mask_byte = (data[0] >> offset) & 0xff,
+			/* The data byte for this port */
+			data_byte = (data[1] >> offset) & 0xff;
+
+		byte = inb(ioaddr);	/* read all 8-bits for this port */
+
+#ifdef DAMMIT_ITS_BROKEN
+		/* DEBUG */
+		printk("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ", byte_no, (unsigned)write_mask_byte, (unsigned)data_byte, offset, ioaddr, (unsigned)byte);
+#endif
+
+		if (write_mask_byte) {
+			/* this byte has some write_bits -- so set the output lines */
+			byte &= ~write_mask_byte;	/* clear bits for write mask */
+			byte |= ~data_byte & write_mask_byte;	/* set to inverted data_byte */
+			/* Write out the new digital output state */
+			outb(byte, ioaddr);
+		}
+#ifdef DAMMIT_ITS_BROKEN
+		/* DEBUG */
+		printk("data_out_byte %02x\n", (unsigned)byte);
+#endif
+		/* save the digital input lines for this byte.. */
+		s->state |= ((unsigned int)byte) << offset;
+	}
+
+	/* now return the DIO lines to data[1] - note they came inverted! */
+	data[1] = ~s->state;
+
+#ifdef DAMMIT_ITS_BROKEN
+	/* DEBUG */
+	printk("s->state %08x data_out %08x\n", s->state, data[1]);
+#endif
+
+	return 2;
+}
+
+/* The input or output configuration of each digital line is
+ * configured by a special insn_config instruction.  chanspec
+ * contains the channel to be changed, and data[0] contains the
+ * value COMEDI_INPUT or COMEDI_OUTPUT. */
+static int pcmuio_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =
+		chan % 8;
+	unsigned long ioaddr;
+	unsigned char byte;
+
+	/* Compute ioaddr for this channel */
+	ioaddr = subpriv->iobases[byte_no];
+
+	/* NOTE:
+	   writing a 0 an IO channel's bit sets the channel to INPUT
+	   and pulls the line high as well
+
+	   writing a 1 to an IO channel's  bit pulls the line low
+
+	   All channels are implicitly always in OUTPUT mode -- but when
+	   they are high they can be considered to be in INPUT mode..
+
+	   Thus, we only force channels low if the config request was INPUT,
+	   otherwise we do nothing to the hardware.    */
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		/* save to io_bits -- don't actually do anything since
+		   all input channels are also output channels... */
+		s->io_bits |= 1 << chan;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		/* write a 0 to the actual register representing the channel
+		   to set it to 'input'.  0 means "float high". */
+		byte = inb(ioaddr);
+		byte &= ~(1 << bit_no);
+				/**< set input channel to '0' */
+
+		/* write out byte -- this is the only time we actually affect the
+		   hardware as all channels are implicitly output -- but input
+		   channels are set to float-high */
+		outb(byte, ioaddr);
+
+		/* save to io_bits */
+		s->io_bits &= ~(1 << chan);
+		break;
+
+	case INSN_CONFIG_DIO_QUERY:
+		/* retreive from shadow register */
+		data[1] =
+			(s->
+			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+		break;
+
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	return insn->n;
+}
+
+static void init_asics(comedi_device * dev)
+{				/* sets up an
+				   ASIC chip to defaults */
+	int asic;
+
+	for (asic = 0; asic < thisboard->num_asics; ++asic) {
+		int port, page;
+		unsigned long baseaddr = dev->iobase + asic * ASIC_IOSIZE;
+
+		switch_page(dev, asic, 0);	/* switch back to page 0 */
+
+		/* first, clear all the DIO port bits */
+		for (port = 0; port < PORTS_PER_ASIC; ++port)
+			outb(0, baseaddr + REG_PORT0 + port);
+
+		/* Next, clear all the paged registers for each page */
+		for (page = 1; page < NUM_PAGES; ++page) {
+			int reg;
+			/* now clear all the paged registers */
+			switch_page(dev, asic, page);
+			for (reg = FIRST_PAGED_REG;
+				reg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)
+				outb(0, baseaddr + reg);
+		}
+
+		/* DEBUG  set rising edge interrupts on port0 of both asics */
+		/*switch_page(dev, asic, PAGE_POL);
+		   outb(0xff, baseaddr + REG_POL0);
+		   switch_page(dev, asic, PAGE_ENAB);
+		   outb(0xff, baseaddr + REG_ENAB0); */
+		/* END DEBUG */
+
+		switch_page(dev, asic, 0);	/* switch back to default page 0 */
+
+	}
+}
+
+static void switch_page(comedi_device * dev, int asic, int page)
+{
+	if (asic < 0 || asic >= thisboard->num_asics)
+		return;		/* paranoia */
+	if (page < 0 || page >= NUM_PAGES)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;
+	devpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;
+
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+}
+
+#ifdef notused
+static void lock_port(comedi_device * dev, int asic, int port)
+{
+	if (asic < 0 || asic >= thisboard->num_asics)
+		return;		/* paranoia */
+	if (port < 0 || port >= PORTS_PER_ASIC)
+		return;		/* more paranoia */
+
+	devpriv->asics[asic].pagelock |= 0x1 << port;
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+}
+
+static void unlock_port(comedi_device * dev, int asic, int port)
+{
+	if (asic < 0 || asic >= thisboard->num_asics)
+		return;		/* paranoia */
+	if (port < 0 || port >= PORTS_PER_ASIC)
+		return;		/* more paranoia */
+	devpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;
+	/* now write out the shadow register */
+	outb(devpriv->asics[asic].pagelock,
+		dev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);
+}
+#endif /* notused */
+
+static irqreturn_t interrupt_pcmuio(int irq, void *d PT_REGS_ARG)
+{
+	int asic, got1 = 0;
+	comedi_device *dev = (comedi_device *) d;
+
+	for (asic = 0; asic < MAX_ASICS; ++asic) {
+		if (irq == devpriv->asics[asic].irq) {
+			unsigned long flags;
+			unsigned triggered = 0;
+			unsigned long iobase = devpriv->asics[asic].iobase;
+			/* it is an interrupt for ASIC #asic */
+			unsigned char int_pend;
+
+			comedi_spin_lock_irqsave(&devpriv->asics[asic].spinlock,
+				flags);
+
+			int_pend = inb(iobase + REG_INT_PENDING) & 0x07;
+
+			if (int_pend) {
+				int port;
+				for (port = 0; port < INTR_PORTS_PER_ASIC;
+					++port) {
+					if (int_pend & (0x1 << port)) {
+						unsigned char
+							io_lines_with_edges = 0;
+						switch_page(dev, asic,
+							PAGE_INT_ID);
+						io_lines_with_edges =
+							inb(iobase +
+							REG_INT_ID0 + port);
+
+						if (io_lines_with_edges)
+							/* clear pending interrupt */
+							outb(0, iobase +
+								REG_INT_ID0 +
+								port);
+
+						triggered |=
+							io_lines_with_edges <<
+							port * 8;
+					}
+				}
+
+				++got1;
+			}
+
+			comedi_spin_unlock_irqrestore(&devpriv->asics[asic].
+				spinlock, flags);
+
+			if (triggered) {
+				comedi_subdevice *s;
+				/* TODO here: dispatch io lines to subdevs with commands.. */
+				printk("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n", irq, asic, triggered);
+				for (s = dev->subdevices;
+					s < dev->subdevices + dev->n_subdevices;
+					++s) {
+					if (subpriv->intr.asic == asic) {	/* this is an interrupt subdev, and it matches this asic! */
+						unsigned long flags;
+						unsigned oldevents;
+
+						comedi_spin_lock_irqsave
+							(&subpriv->intr.
+							spinlock, flags);
+
+						oldevents = s->async->events;
+
+						if (subpriv->intr.active) {
+							unsigned mytrig =
+								((triggered >>
+									subpriv->
+									intr.
+									asic_chan)
+								& ((0x1 << subpriv->intr.num_asic_chans) - 1)) << subpriv->intr.first_chan;
+							if (mytrig & subpriv->
+								intr.
+								enabled_mask) {
+								lsampl_t val =
+									0;
+								unsigned int n,
+									ch, len;
+
+								len = s->async->
+									cmd.
+									chanlist_len;
+								for (n = 0;
+									n < len;
+									n++) {
+									ch = CR_CHAN(s->async->cmd.chanlist[n]);
+									if (mytrig & (1U << ch)) {
+										val |= (1U << n);
+									}
+								}
+								/* Write the scan to the buffer. */
+								if (comedi_buf_put(s->async, ((sampl_t *) & val)[0])
+									&&
+									comedi_buf_put
+									(s->async, ((sampl_t *) & val)[1])) {
+									s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+								} else {
+									/* Overflow! Stop acquisition!! */
+									/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+									pcmuio_stop_intr
+										(dev,
+										s);
+								}
+
+								/* Check for end of acquisition. */
+								if (!subpriv->
+									intr.
+									continuous)
+								{
+									/* stop_src == TRIG_COUNT */
+									if (subpriv->intr.stop_count > 0) {
+										subpriv->
+											intr.
+											stop_count--;
+										if (subpriv->intr.stop_count == 0) {
+											s->async->events |= COMEDI_CB_EOA;
+											/* TODO: STOP_ACQUISITION_CALL_HERE!! */
+											pcmuio_stop_intr
+												(dev,
+												s);
+										}
+									}
+								}
+							}
+						}
+
+						comedi_spin_unlock_irqrestore
+							(&subpriv->intr.
+							spinlock, flags);
+
+						if (oldevents !=
+							s->async->events) {
+							comedi_event(dev, s);
+						}
+
+					}
+
+				}
+			}
+
+		}
+	}
+	if (!got1)
+		return IRQ_NONE;	/* interrupt from other source */
+	return IRQ_HANDLED;
+}
+
+static void pcmuio_stop_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	int nports, firstport, asic, port;
+
+	if ((asic = subpriv->intr.asic) < 0)
+		return;		/* not an interrupt subdev */
+
+	subpriv->intr.enabled_mask = 0;
+	subpriv->intr.active = 0;
+	s->async->inttrig = 0;
+	nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
+	firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
+	switch_page(dev, asic, PAGE_ENAB);
+	for (port = firstport; port < firstport + nports; ++port) {
+		/* disable all intrs for this subdev.. */
+		outb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);
+	}
+}
+
+static int pcmuio_start_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	if (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {
+		/* An empty acquisition! */
+		s->async->events |= COMEDI_CB_EOA;
+		subpriv->intr.active = 0;
+		return 1;
+	} else {
+		unsigned bits = 0, pol_bits = 0, n;
+		int nports, firstport, asic, port;
+		comedi_cmd *cmd = &s->async->cmd;
+
+		if ((asic = subpriv->intr.asic) < 0)
+			return 1;	/* not an interrupt
+					   subdev */
+		subpriv->intr.enabled_mask = 0;
+		subpriv->intr.active = 1;
+		nports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;
+		firstport = subpriv->intr.asic_chan / CHANS_PER_PORT;
+		if (cmd->chanlist) {
+			for (n = 0; n < cmd->chanlist_len; n++) {
+				bits |= (1U << CR_CHAN(cmd->chanlist[n]));
+				pol_bits |= (CR_AREF(cmd->chanlist[n])
+					|| CR_RANGE(cmd->chanlist[n]) ? 1U : 0U)
+					<< CR_CHAN(cmd->chanlist[n]);
+			}
+		}
+		bits &= ((0x1 << subpriv->intr.num_asic_chans) -
+			1) << subpriv->intr.first_chan;
+		subpriv->intr.enabled_mask = bits;
+
+		switch_page(dev, asic, PAGE_ENAB);
+		for (port = firstport; port < firstport + nports; ++port) {
+			unsigned enab =
+				bits >> (subpriv->intr.first_chan + (port -
+					firstport) * 8) & 0xff, pol =
+				pol_bits >> (subpriv->intr.first_chan + (port -
+					firstport) * 8) & 0xff;
+			/* set enab intrs for this subdev.. */
+			outb(enab,
+				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+			switch_page(dev, asic, PAGE_POL);
+			outb(pol,
+				devpriv->asics[asic].iobase + REG_ENAB0 + port);
+		}
+	}
+	return 0;
+}
+
+static int pcmuio_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	if (subpriv->intr.active)
+		pcmuio_stop_intr(dev, s);
+	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+
+	return 0;
+}
+
+/*
+ * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
+ */
+static int
+pcmuio_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	unsigned long flags;
+	int event = 0;
+
+	if (trignum != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	s->async->inttrig = 0;
+	if (subpriv->intr.active) {
+		event = pcmuio_start_intr(dev, s);
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 1;
+}
+
+/*
+ * 'do_cmd' function for an 'INTERRUPT' subdevice.
+ */
+static int pcmuio_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+	int event = 0;
+
+	comedi_spin_lock_irqsave(&subpriv->intr.spinlock, flags);
+	subpriv->intr.active = 1;
+
+	/* Set up end of acquisition. */
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		subpriv->intr.continuous = 0;
+		subpriv->intr.stop_count = cmd->stop_arg;
+		break;
+	default:
+		/* TRIG_NONE */
+		subpriv->intr.continuous = 1;
+		subpriv->intr.stop_count = 0;
+		break;
+	}
+
+	/* Set up start of acquisition. */
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		s->async->inttrig = pcmuio_inttrig_start_intr;
+		break;
+	default:
+		/* TRIG_NOW */
+		event = pcmuio_start_intr(dev, s);
+		break;
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->intr.spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 0;
+}
+
+/*
+ * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
+ */
+static int
+pcmuio_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= (TRIG_NOW | TRIG_INT);
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_begin_src == TRIG_EXT */
+	if (cmd->scan_begin_arg != 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+
+	/* cmd->convert_src == TRIG_NOW */
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_end_src == TRIG_COUNT */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver);
