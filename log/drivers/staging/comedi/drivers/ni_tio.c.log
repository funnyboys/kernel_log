commit 45621fc9ddc98a462f424d583c5f40251c950ab6
Author: Deepak R Varma <mh12gx2825@gmail.com>
Date:   Sun Mar 15 03:12:57 2020 +0530

    staging: comedi: ni_tio: Reformat function call arguments
    
    Reformat function call arguments so that the function call is clearly
    visible. Issue detected by checkpatch.
    
    Signed-off-by: Deepak R Varma <mh12gx2825@gmail.com>
    Link: https://lore.kernel.org/r/20200314214254.GA3941@deeUbuntu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index b264db32a411..f6154addaa95 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1342,8 +1342,8 @@ static int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 
 static inline unsigned int ni_tio_get_gate_mode(struct ni_gpct *counter)
 {
-	unsigned int mode = ni_tio_get_soft_copy(
-		counter, NITIO_MODE_REG(counter->counter_index));
+	unsigned int mode = ni_tio_get_soft_copy(counter,
+				NITIO_MODE_REG(counter->counter_index));
 	unsigned int ret = 0;
 
 	if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED)
@@ -1358,8 +1358,8 @@ static inline unsigned int ni_tio_get_gate_mode(struct ni_gpct *counter)
 
 static inline unsigned int ni_tio_get_gate2_mode(struct ni_gpct *counter)
 {
-	unsigned int mode = ni_tio_get_soft_copy(
-		counter, NITIO_GATE2_REG(counter->counter_index));
+	unsigned int mode = ni_tio_get_soft_copy(counter,
+				NITIO_GATE2_REG(counter->counter_index));
 	unsigned int ret = 0;
 
 	if (!(mode & GI_GATE2_MODE))

commit e0dccbdf5ac7ccb9da5612100dedba302f3ebcfe
Merge: cf482a49af56 e2a5be107f52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 13:31:29 2019 -0700

    Merge tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging / IIO driver updates from Greg KH:
     "Here is the big staging and iio driver update for 5.2-rc1.
    
      Lots of tiny fixes all over the staging and IIO driver trees here,
      along with some new IIO drivers.
    
      The "counter" subsystem was added in here as well, as it is needed by
      the IIO drivers and subsystem.
    
      Also we ended up deleting two drivers, making this pull request remove
      a few hundred thousand lines of code, always a nice thing to see. Both
      of the drivers removed have been replaced with "real" drivers in their
      various subsystem directories, and they will be coming to you from
      those locations during this merge window.
    
      There are some core vt/selection changes in here, that was due to some
      cleanups needed for the speakup fixes. Those have all been acked by
      the various subsystem maintainers (i.e. me), so those are ok.
    
      We also added a few new drivers, for some odd hardware, giving new
      developers plenty to work on with basic coding style cleanups to come
      in the near future.
    
      Other than that, nothing unusual here.
    
      All of these have been in linux-next for a while with no reported
      issues, other than an odd gcc warning for one of the new drivers that
      should be fixed up soon"
    
    [ I fixed up the warning myself  - Linus ]
    
    * tag 'staging-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (663 commits)
      staging: kpc2000: kpc_spi: Fix build error for {read,write}q
      Staging: rtl8192e: Remove extra space before break statement
      Staging: rtl8192u: ieee80211: Fix if-else indentation warning
      Staging: rtl8192u: ieee80211: Fix indentation errors by removing extra spaces
      staging: most: cdev: fix chrdev_region leak in mod_exit
      staging: wlan-ng: Fix improper SPDX comment style
      staging: rtl8192u: ieee80211: Resolve ERROR reported by checkpatch
      staging: vc04_services: bcm2835-camera: Compress two lines into one line
      staging: rtl8723bs: core: Use !x in place of NULL comparison.
      staging: rtl8723bs: core: Prefer using the BIT Macro.
      staging: fieldbus: anybus-s: fix wait_for_completion_timeout return handling
      staging: kpc2000: fix up build problems with readq()
      staging: rtlwifi: move remaining phydm .h files
      staging: rtlwifi: strip down phydm .h files
      staging: rtlwifi: delete the staging driver
      staging: fieldbus: anybus-s: rename bus id field to avoid confusion
      staging: fieldbus: anybus-s: keep device bus id in bus endianness
      Staging: sm750fb: Change *array into *const array
      staging: rtl8192u: ieee80211: Fix spelling mistake
      staging: rtl8192u: ieee80211: Replace bit shifting with BIT macro
      ...

commit fb24ea52f78e0d595852e09e3a55697c8f442189
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 17:14:59 2019 +0000

    drivers: Remove explicit invocations of mmiowb()
    
    mmiowb() is now implied by spin_unlock() on architectures that require
    it, so there is no reason to call it from driver code. This patch was
    generated using coccinelle:
    
            @mmiowb@
            @@
            - mmiowb();
    
    and invoked as:
    
    $ for d in drivers include/linux/qed sound; do \
    spatch --include-headers --sp-file mmiowb.cocci --dir $d --in-place; done
    
    NOTE: mmiowb() has only ever guaranteed ordering in conjunction with
    spin_unlock(). However, pairing each mmiowb() removal in this patch with
    the corresponding call to spin_unlock() is not at all trivial, so there
    is a small chance that this change may regress any drivers incorrectly
    relying on mmiowb() to order MMIO writes between CPUs using lock-free
    synchronisation. If you've ended up bisecting to this commit, you can
    reintroduce the mmiowb() calls using wmb() instead, which should restore
    the old behaviour on all architectures other than some esoteric ia64
    systems.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 048cb35723ad..c1131a1622c0 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -234,7 +234,6 @@ static void ni_tio_set_bits_transient(struct ni_gpct *counter,
 		regs[reg] &= ~mask;
 		regs[reg] |= (value & mask);
 		ni_tio_write(counter, regs[reg] | transient, reg);
-		mmiowb();
 		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 	}
 }

commit 5c724e197eb57336696a0a573b199a273db9466b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 27 15:15:15 2019 +0000

    staging: comedi: ni_tio: Use data[insn->n-1] in ni_tio_insn_write()
    
    The `insn_write` handler for the counter subdevices
    (`ni_tio_insn_write()`) writes a single data value `data[0]` to the
    channel.  Technically, `insn->n` specifies the number of successive
    values from `data[]` to write to the channel, but when there is little
    benefit in writing multiple data values, the usual Comedi convention is
    to just write the last data value `data[insn->n - 1]`.  Change the
    function to follow that convention and use `data[insn->n - 1]` instead
    of `data[0]`.  (In practice, `insn->n` would normally be 1 anyway.)
    
    Also follow the usual Comedi convention and return `insn->n` from the
    handler to indicate success instead of 0 (although any non-negative
    return value will do).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 048cb35723ad..943c5177cbea 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1682,9 +1682,11 @@ int ni_tio_insn_write(struct comedi_device *dev,
 	unsigned int cidx = counter->counter_index;
 	unsigned int chip = counter->chip_index;
 	unsigned int load_reg;
+	unsigned int load_val;
 
 	if (insn->n < 1)
 		return 0;
+	load_val = data[insn->n - 1];
 	switch (channel) {
 	case 0:
 		/*
@@ -1697,7 +1699,7 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		 * load register is already selected.
 		 */
 		load_reg = ni_tio_next_load_register(counter);
-		ni_tio_write(counter, data[0], load_reg);
+		ni_tio_write(counter, load_val, load_reg);
 		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 					  0, 0, GI_LOAD);
 		/* restore load reg */
@@ -1705,17 +1707,17 @@ int ni_tio_insn_write(struct comedi_device *dev,
 			     load_reg);
 		break;
 	case 1:
-		counter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = data[0];
-		ni_tio_write(counter, data[0], NITIO_LOADA_REG(cidx));
+		counter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = load_val;
+		ni_tio_write(counter, load_val, NITIO_LOADA_REG(cidx));
 		break;
 	case 2:
-		counter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = data[0];
-		ni_tio_write(counter, data[0], NITIO_LOADB_REG(cidx));
+		counter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = load_val;
+		ni_tio_write(counter, load_val, NITIO_LOADB_REG(cidx));
 		break;
 	default:
 		return -EINVAL;
 	}
-	return 0;
+	return insn->n;
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_write);
 

commit 97c64322b8dded294fe1f1021946dcad49c0fb4e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Feb 25 15:06:11 2019 +0000

    staging: comedi: ni_tio: Allocate shadow regs for each counter chip
    
    The "ni_tio" module contains code to allocate, destroy and operate on a
    `struct ni_gpct_device`, which represents a number of counters spread
    over one or more blocks (or "chips").  `struct ni_gpct_device` includes
    an array member `regs` holding shadow copies of register values.
    Unfortunately, this is currently shared by each block of counters so
    they interfere with each other.  This is a problem for the "ni_660x"
    module, which has 8 counters spread over 2 blocks.  The `regs` storage
    needs to be two-dimensional, indexed by block (chip) number and register
    number.  (It does not need to be three-dimensional because the registers
    for individual counters are intermingled within the block.)
    
    Change the `regs` member to an array pointer that can be indexed like a
    two-dimensional array to access the shadow storage for each register in
    each block.  Allocate the storage in `ni_gpct_device_construct()` and
    free it in `ni_gpct_device_destroy()`.  (`ni_gpct_device_construct()`
    can determine the number of blocks from the `num_counters` and
    `counters_per_chip` parameters.)
    
    Add new member `num_chips` to hold the number of chips.  Use that to
    check that `chip_index` value is in range in the same places that
    check the register offset is in range.
    
    Remove the `counters_per_chip` member of `struct ni_gpct_device` as it
    is not needed anywhere and could be easily derived from the
    `num_counters` and `num_chips` members if required.
    
    Thanks to GitHub user "raabej" (real name unknown) for an initial
    implementation of this in the out-of-tree fork of the Comedi drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 0eb388c0e1f0..048cb35723ad 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -224,13 +224,16 @@ static void ni_tio_set_bits_transient(struct ni_gpct *counter,
 				      unsigned int transient)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned int chip = counter->chip_index;
 	unsigned long flags;
 
-	if (reg < NITIO_NUM_REGS) {
+	if (reg < NITIO_NUM_REGS && chip < counter_dev->num_chips) {
+		unsigned int *regs = counter_dev->regs[chip];
+
 		spin_lock_irqsave(&counter_dev->regs_lock, flags);
-		counter_dev->regs[reg] &= ~mask;
-		counter_dev->regs[reg] |= (value & mask);
-		ni_tio_write(counter, counter_dev->regs[reg] | transient, reg);
+		regs[reg] &= ~mask;
+		regs[reg] |= (value & mask);
+		ni_tio_write(counter, regs[reg] | transient, reg);
 		mmiowb();
 		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 	}
@@ -267,12 +270,13 @@ unsigned int ni_tio_get_soft_copy(const struct ni_gpct *counter,
 				  enum ni_gpct_register reg)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned int chip = counter->chip_index;
 	unsigned int value = 0;
 	unsigned long flags;
 
-	if (reg < NITIO_NUM_REGS) {
+	if (reg < NITIO_NUM_REGS && chip < counter_dev->num_chips) {
 		spin_lock_irqsave(&counter_dev->regs_lock, flags);
-		value = counter_dev->regs[reg];
+		value = counter_dev->regs[chip][reg];
 		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 	}
 	return value;
@@ -302,6 +306,7 @@ static int ni_m_series_clock_src_select(const struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 	unsigned int second_gate_reg = NITIO_GATE2_REG(cidx);
 	unsigned int clock_source = 0;
 	unsigned int src;
@@ -318,7 +323,7 @@ static int ni_m_series_clock_src_select(const struct ni_gpct *counter,
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
 	case NI_M_TIMEBASE_3_CLK:
-		if (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)
+		if (counter_dev->regs[chip][second_gate_reg] & GI_SRC_SUBSEL)
 			clock_source =
 			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
 		else
@@ -328,7 +333,7 @@ static int ni_m_series_clock_src_select(const struct ni_gpct *counter,
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
 	case NI_M_NEXT_GATE_CLK:
-		if (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)
+		if (counter_dev->regs[chip][second_gate_reg] & GI_SRC_SUBSEL)
 			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
@@ -721,6 +726,7 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 	unsigned int second_gate_reg = NITIO_GATE2_REG(cidx);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
@@ -729,18 +735,18 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 		/* Gi_Source_Subselect is zero */
 	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
 	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
-		counter_dev->regs[second_gate_reg] &= ~GI_SRC_SUBSEL;
+		counter_dev->regs[chip][second_gate_reg] &= ~GI_SRC_SUBSEL;
 		break;
 		/* Gi_Source_Subselect is one */
 	case NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:
 	case NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:
-		counter_dev->regs[second_gate_reg] |= GI_SRC_SUBSEL;
+		counter_dev->regs[chip][second_gate_reg] |= GI_SRC_SUBSEL;
 		break;
 		/* Gi_Source_Subselect doesn't matter */
 	default:
 		return;
 	}
-	ni_tio_write(counter, counter_dev->regs[second_gate_reg],
+	ni_tio_write(counter, counter_dev->regs[chip][second_gate_reg],
 		     second_gate_reg);
 }
 
@@ -1116,6 +1122,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 	unsigned int abz_reg, shift, mask;
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
@@ -1141,9 +1148,9 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 	if (source > 0x1f)
 		source = 0x1f;	/* Disable gate */
 
-	counter_dev->regs[abz_reg] &= ~mask;
-	counter_dev->regs[abz_reg] |= (source << shift) & mask;
-	ni_tio_write(counter, counter_dev->regs[abz_reg], abz_reg);
+	counter_dev->regs[chip][abz_reg] &= ~mask;
+	counter_dev->regs[chip][abz_reg] |= (source << shift) & mask;
+	ni_tio_write(counter, counter_dev->regs[chip][abz_reg], abz_reg);
 	return 0;
 }
 
@@ -1632,6 +1639,7 @@ int ni_tio_insn_read(struct comedi_device *dev,
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int channel = CR_CHAN(insn->chanspec);
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
@@ -1640,10 +1648,12 @@ int ni_tio_insn_read(struct comedi_device *dev,
 			data[i] = ni_tio_read_sw_save_reg(dev, s);
 			break;
 		case 1:
-			data[i] = counter_dev->regs[NITIO_LOADA_REG(cidx)];
+			data[i] =
+			    counter_dev->regs[chip][NITIO_LOADA_REG(cidx)];
 			break;
 		case 2:
-			data[i] = counter_dev->regs[NITIO_LOADB_REG(cidx)];
+			data[i] =
+			    counter_dev->regs[chip][NITIO_LOADB_REG(cidx)];
 			break;
 		}
 	}
@@ -1670,6 +1680,7 @@ int ni_tio_insn_write(struct comedi_device *dev,
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int channel = CR_CHAN(insn->chanspec);
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 	unsigned int load_reg;
 
 	if (insn->n < 1)
@@ -1690,14 +1701,15 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 					  0, 0, GI_LOAD);
 		/* restore load reg */
-		ni_tio_write(counter, counter_dev->regs[load_reg], load_reg);
+		ni_tio_write(counter, counter_dev->regs[chip][load_reg],
+			     load_reg);
 		break;
 	case 1:
-		counter_dev->regs[NITIO_LOADA_REG(cidx)] = data[0];
+		counter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = data[0];
 		ni_tio_write(counter, data[0], NITIO_LOADA_REG(cidx));
 		break;
 	case 2:
-		counter_dev->regs[NITIO_LOADB_REG(cidx)] = data[0];
+		counter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = data[0];
 		ni_tio_write(counter, data[0], NITIO_LOADB_REG(cidx));
 		break;
 	default:
@@ -1711,11 +1723,12 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
+	unsigned int chip = counter->chip_index;
 
 	ni_tio_reset_count_and_disarm(counter);
 
 	/* initialize counter registers */
-	counter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;
+	counter_dev->regs[chip][NITIO_AUTO_INC_REG(cidx)] = 0x0;
 	ni_tio_write(counter, 0x0, NITIO_AUTO_INC_REG(cidx));
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
@@ -1723,10 +1736,10 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 
 	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
 
-	counter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;
+	counter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = 0x0;
 	ni_tio_write(counter, 0x0, NITIO_LOADA_REG(cidx));
 
-	counter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;
+	counter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = 0x0;
 	ni_tio_write(counter, 0x0, NITIO_LOADB_REG(cidx));
 
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);
@@ -1735,7 +1748,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);
 
 	if (ni_tio_has_gate2_registers(counter_dev)) {
-		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
+		counter_dev->regs[chip][NITIO_GATE2_REG(cidx)] = 0x0;
 		ni_tio_write(counter, 0x0, NITIO_GATE2_REG(cidx));
 	}
 
@@ -1776,9 +1789,16 @@ ni_gpct_device_construct(struct comedi_device *dev,
 
 	spin_lock_init(&counter_dev->regs_lock);
 
+	counter_dev->num_counters = num_counters;
+	counter_dev->num_chips = DIV_ROUND_UP(num_counters, counters_per_chip);
+
 	counter_dev->counters = kcalloc(num_counters, sizeof(*counter),
 					GFP_KERNEL);
-	if (!counter_dev->counters) {
+	counter_dev->regs = kcalloc(counter_dev->num_chips,
+				    sizeof(*counter_dev->regs), GFP_KERNEL);
+	if (!counter_dev->regs || !counter_dev->counters) {
+		kfree(counter_dev->regs);
+		kfree(counter_dev->counters);
 		kfree(counter_dev);
 		return NULL;
 	}
@@ -1790,8 +1810,6 @@ ni_gpct_device_construct(struct comedi_device *dev,
 		counter->counter_index = i % counters_per_chip;
 		spin_lock_init(&counter->lock);
 	}
-	counter_dev->num_counters = num_counters;
-	counter_dev->counters_per_chip = counters_per_chip;
 
 	return counter_dev;
 }
@@ -1801,6 +1819,7 @@ void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 {
 	if (!counter_dev)
 		return;
+	kfree(counter_dev->regs);
 	kfree(counter_dev->counters);
 	kfree(counter_dev);
 }

commit a7ed5b3e7dca197de4da6273940a7ca6d1d756a1
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Oct 11 21:05:20 2018 +0200

    staging: comedi: tio: fix multiple missing break in switch bugs
    
    Currently, there are multiple missing break statements in two switch code
    blocks. This makes the execution path to fall all the way down through
    to the default cases, which makes the function ni_tio_set_gate_src() to
    always return -EINVAL.
    
    Fix this by adding the missing break statements.
    
    Also, notice that due to the absence of the break statements,
    the following pieces of code are unreachable:
    
    1078    if (ret)
    1079            return ret;
    1080    /* 3.  reenable & set mode to starts things back up */
    1081    ni_tio_set_gate_mode(counter, src);
    
    1098    if (ret)
    1099            return ret;
    1100    /* 3.  reenable & set mode to starts things back up */
    1101    ni_tio_set_gate2_mode(counter, src);
    
    So, by adding the missing breaks, this patch also fixes the problem
    above.
    
    Addresses-Coverity-ID: 1474165 ("Missing break in switch")
    Addresses-Coverity-ID: 1474162 ("Structurally dead code")
    Fixes: 347e244884c3 ("staging: comedi: tio: implement global tio/ctr routing")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 838614ee64d6..0eb388c0e1f0 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1070,8 +1070,10 @@ int ni_tio_set_gate_src(struct ni_gpct *counter,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			ret = ni_m_set_gate(counter, chan);
+			break;
 		case ni_gpct_variant_660x:
 			ret = ni_660x_set_gate(counter, chan);
+			break;
 		default:
 			return -EINVAL;
 		}
@@ -1090,8 +1092,10 @@ int ni_tio_set_gate_src(struct ni_gpct *counter,
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
 			ret = ni_m_set_gate2(counter, chan);
+			break;
 		case ni_gpct_variant_660x:
 			ret = ni_660x_set_gate2(counter, chan);
+			break;
 		default:
 			return -EINVAL;
 		}

commit 347e244884c3be1f5bce1d93730f0c32efabba99
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:08 2018 -0600

    staging: comedi: tio: implement global tio/ctr routing
    
    Adds ability to use device-global names in command args, in particular
    cmd->start_arg (for NI_CtrArmStartTrigger), and cmd->scan_begin_arg or
    cmd->convert_arg (either is used to specify NI_CtrGate, with preference
    given to cmd->scan_begin_arg, if it is set).
    
    The actual arguments of cmd->start_arg are not fully checked against known
    register values for the particular devices because these are not documented
    or currently known.  This follows the precedence of prior versions of the
    tio driver.  Should these become known, they should be annotated in the
    route_values tables and the set of lines in ni_tio_cmdtest should be
    uncommented to allow the tests to be made.
    
    This patch also adds interface functions that allow routes for particular
    counter route destinations to be made/queried/unmade.  This allows overseer
    modules to implement test_route, connect_route, and disconnect_route.  As a
    part of these changes, various functions were cleaned up and clarified.
    
    These new interface functions allow direct writing/reading of register
    values.  This is an example of exactly what the new device-global access
    was intended to solve:  the old interface was not consistent with other
    portions of the ni_* drivers--it did not allow full register values to be
    given for various MUXes.  Instead, the old interface _did_ abstract away
    some of the actual hardware from the underlying devices, but it was not
    consistent with any other NI hardware.  Allowing the device-global
    identifiers to be used, the new patch provides for consistency across all
    ni_* drivers.  One final note:  these changes provide for backwards
    compatibility by allowing the older values to still be used in through the
    pre-existing kernel interfaces--though not in the new device-global
    test/dis/connect/route interfaces.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ef919b21b7d9..838614ee64d6 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -818,10 +818,79 @@ static int ni_tio_get_clock_src(struct ni_gpct *counter,
 	return 0;
 }
 
+static inline void ni_tio_set_gate_raw(struct ni_gpct *counter,
+				       unsigned int gate_source)
+{
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(counter->counter_index),
+			GI_GATE_SEL_MASK, GI_GATE_SEL(gate_source));
+}
+
+static inline void ni_tio_set_gate2_raw(struct ni_gpct *counter,
+					unsigned int gate_source)
+{
+	ni_tio_set_bits(counter, NITIO_GATE2_REG(counter->counter_index),
+			GI_GATE2_SEL_MASK, GI_GATE2_SEL(gate_source));
+}
+
+/* Set the mode bits for gate. */
+static inline void ni_tio_set_gate_mode(struct ni_gpct *counter,
+					unsigned int src)
+{
+	unsigned int mode_bits = 0;
+
+	if (CR_CHAN(src) & NI_GPCT_DISABLED_GATE_SELECT) {
+		/*
+		 * Allowing bitwise comparison here to allow non-zero raw
+		 * register value to be used for channel when disabling.
+		 */
+		mode_bits = GI_GATING_DISABLED;
+	} else {
+		if (src & CR_INVERT)
+			mode_bits |= GI_GATE_POL_INVERT;
+		if (src & CR_EDGE)
+			mode_bits |= GI_RISING_EDGE_GATING;
+		else
+			mode_bits |= GI_LEVEL_GATING;
+	}
+	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),
+			GI_GATE_POL_INVERT | GI_GATING_MODE_MASK,
+			mode_bits);
+}
+
+/*
+ * Set the mode bits for gate2.
+ *
+ * Previously, the code this function represents did not actually write anything
+ * to the register.  Rather, writing to this register was reserved for the code
+ * ni ni_tio_set_gate2_raw.
+ */
+static inline void ni_tio_set_gate2_mode(struct ni_gpct *counter,
+					 unsigned int src)
+{
+	/*
+	 * The GI_GATE2_MODE bit was previously set in the code that also sets
+	 * the gate2 source.
+	 * We'll set mode bits _after_ source bits now, and thus, this function
+	 * will effectively enable the second gate after all bits are set.
+	 */
+	unsigned int mode_bits = GI_GATE2_MODE;
+
+	if (CR_CHAN(src) & NI_GPCT_DISABLED_GATE_SELECT)
+		/*
+		 * Allowing bitwise comparison here to allow non-zero raw
+		 * register value to be used for channel when disabling.
+		 */
+		mode_bits = GI_GATING_DISABLED;
+	if (src & CR_INVERT)
+		mode_bits |= GI_GATE2_POL_INVERT;
+
+	ni_tio_set_bits(counter, NITIO_GATE2_REG(counter->counter_index),
+			GI_GATE2_POL_INVERT | GI_GATE2_MODE, mode_bits);
+}
+
 static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned int cidx = counter->counter_index;
 	unsigned int gate_sel;
 	unsigned int i;
 
@@ -854,15 +923,13 @@ static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 			break;
 		return -EINVAL;
 	}
-	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			GI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));
+	ni_tio_set_gate_raw(counter, gate_sel);
 	return 0;
 }
 
 static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned int cidx = counter->counter_index;
 	unsigned int gate_sel;
 	unsigned int i;
 
@@ -896,17 +963,13 @@ static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 			break;
 		return -EINVAL;
 	}
-	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			GI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));
+	ni_tio_set_gate_raw(counter, gate_sel);
 	return 0;
 }
 
 static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned int cidx = counter->counter_index;
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
 	unsigned int gate2_sel;
 	unsigned int i;
 
@@ -940,94 +1003,102 @@ static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 			break;
 		return -EINVAL;
 	}
-	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
-	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
-	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
-	ni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);
+	ni_tio_set_gate2_raw(counter, gate2_sel);
 	return 0;
 }
 
 static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned int cidx = counter->counter_index;
-	unsigned int chan = CR_CHAN(gate_source);
-	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned int gate2_sel;
-
 	/*
 	 * FIXME: We don't know what the m-series second gate codes are,
 	 * so we'll just pass the bits through for now.
 	 */
-	switch (chan) {
-	default:
-		gate2_sel = chan & 0x1f;
+	ni_tio_set_gate2_raw(counter, gate_source);
+	return 0;
+}
+
+int ni_tio_set_gate_src_raw(struct ni_gpct *counter,
+			    unsigned int gate, unsigned int src)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+
+	switch (gate) {
+	case 0:
+		/* 1.  start by disabling gate */
+		ni_tio_set_gate_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);
+		/* 2.  set the requested gate source */
+		ni_tio_set_gate_raw(counter, src);
+		/* 3.  reenable & set mode to starts things back up */
+		ni_tio_set_gate_mode(counter, src);
+		break;
+	case 1:
+		if (!ni_tio_has_gate2_registers(counter_dev))
+			return -EINVAL;
+
+		/* 1.  start by disabling gate */
+		ni_tio_set_gate2_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);
+		/* 2.  set the requested gate source */
+		ni_tio_set_gate2_raw(counter, src);
+		/* 3.  reenable & set mode to starts things back up */
+		ni_tio_set_gate2_mode(counter, src);
 		break;
+	default:
+		return -EINVAL;
 	}
-	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
-	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
-	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
-	ni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_set_gate_src_raw);
 
 int ni_tio_set_gate_src(struct ni_gpct *counter,
 			unsigned int gate, unsigned int src)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned int cidx = counter->counter_index;
-	unsigned int chan = CR_CHAN(src);
-	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned int mode = 0;
+	/*
+	 * mask off disable flag.  This high bit still passes CR_CHAN.
+	 * Doing this allows one to both set the gate as disabled, but also
+	 * change the route value of the gate.
+	 */
+	int chan = CR_CHAN(src) & (~NI_GPCT_DISABLED_GATE_SELECT);
+	int ret;
 
 	switch (gate) {
 	case 0:
-		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
-			ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
-					GI_GATING_MODE_MASK,
-					GI_GATING_DISABLED);
-			return 0;
-		}
-		if (src & CR_INVERT)
-			mode |= GI_GATE_POL_INVERT;
-		if (src & CR_EDGE)
-			mode |= GI_RISING_EDGE_GATING;
-		else
-			mode |= GI_LEVEL_GATING;
-		ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
-				GI_GATE_POL_INVERT | GI_GATING_MODE_MASK,
-				mode);
+		/* 1.  start by disabling gate */
+		ni_tio_set_gate_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);
+		/* 2.  set the requested gate source */
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
-		default:
-			return ni_m_set_gate(counter, src);
+			ret = ni_m_set_gate(counter, chan);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_gate(counter, src);
+			ret = ni_660x_set_gate(counter, chan);
+		default:
+			return -EINVAL;
 		}
+		if (ret)
+			return ret;
+		/* 3.  reenable & set mode to starts things back up */
+		ni_tio_set_gate_mode(counter, src);
 		break;
 	case 1:
 		if (!ni_tio_has_gate2_registers(counter_dev))
 			return -EINVAL;
 
-		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
-			counter_dev->regs[gate2_reg] &= ~GI_GATE2_MODE;
-			ni_tio_write(counter, counter_dev->regs[gate2_reg],
-				     gate2_reg);
-			return 0;
-		}
-		if (src & CR_INVERT)
-			counter_dev->regs[gate2_reg] |= GI_GATE2_POL_INVERT;
-		else
-			counter_dev->regs[gate2_reg] &= ~GI_GATE2_POL_INVERT;
+		/* 1.  start by disabling gate */
+		ni_tio_set_gate2_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);
+		/* 2.  set the requested gate source */
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
-			return ni_m_set_gate2(counter, src);
+			ret = ni_m_set_gate2(counter, chan);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_gate2(counter, src);
+			ret = ni_660x_set_gate2(counter, chan);
 		default:
 			return -EINVAL;
 		}
+		if (ret)
+			return ret;
+		/* 3.  reenable & set mode to starts things back up */
+		ni_tio_set_gate2_mode(counter, src);
 		break;
 	default:
 		return -EINVAL;
@@ -1047,19 +1118,21 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 		return -EINVAL;
 
 	abz_reg = NITIO_ABZ_REG(cidx);
-	switch (index) {
-	case NI_GPCT_SOURCE_ENCODER_A:
+
+	/* allow for new device-global names */
+	if (index == NI_GPCT_SOURCE_ENCODER_A ||
+	    (index >= NI_CtrA(0) && index <= NI_CtrA(-1))) {
 		shift = 10;
-		break;
-	case NI_GPCT_SOURCE_ENCODER_B:
+	} else if (index == NI_GPCT_SOURCE_ENCODER_B ||
+	    (index >= NI_CtrB(0) && index <= NI_CtrB(-1))) {
 		shift = 5;
-		break;
-	case NI_GPCT_SOURCE_ENCODER_Z:
+	} else if (index == NI_GPCT_SOURCE_ENCODER_Z ||
+	    (index >= NI_CtrZ(0) && index <= NI_CtrZ(-1))) {
 		shift = 0;
-		break;
-	default:
+	} else {
 		return -EINVAL;
 	}
+
 	mask = 0x1f << shift;
 	if (source > 0x1f)
 		source = 0x1f;	/* Disable gate */
@@ -1070,6 +1143,39 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 	return 0;
 }
 
+static int ni_tio_get_other_src(struct ni_gpct *counter, unsigned int index,
+				unsigned int *source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned int cidx = counter->counter_index;
+	unsigned int abz_reg, shift, mask;
+
+	if (counter_dev->variant != ni_gpct_variant_m_series)
+		/* A,B,Z only valid for m-series */
+		return -EINVAL;
+
+	abz_reg = NITIO_ABZ_REG(cidx);
+
+	/* allow for new device-global names */
+	if (index == NI_GPCT_SOURCE_ENCODER_A ||
+	    (index >= NI_CtrA(0) && index <= NI_CtrA(-1))) {
+		shift = 10;
+	} else if (index == NI_GPCT_SOURCE_ENCODER_B ||
+	    (index >= NI_CtrB(0) && index <= NI_CtrB(-1))) {
+		shift = 5;
+	} else if (index == NI_GPCT_SOURCE_ENCODER_Z ||
+	    (index >= NI_CtrZ(0) && index <= NI_CtrZ(-1))) {
+		shift = 0;
+	} else {
+		return -EINVAL;
+	}
+
+	mask = 0x1f;
+
+	*source = (ni_tio_get_soft_copy(counter, abz_reg) >> shift) & mask;
+	return 0;
+}
+
 static int ni_660x_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 {
 	unsigned int source;
@@ -1112,7 +1218,7 @@ static int ni_660x_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 	}
 	*src = source;
 	return 0;
-};
+}
 
 static int ni_m_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 {
@@ -1165,7 +1271,7 @@ static int ni_m_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 	}
 	*src = source;
 	return 0;
-};
+}
 
 static int ni_660x_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 {
@@ -1212,7 +1318,7 @@ static int ni_660x_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 	}
 	*src = source;
 	return 0;
-};
+}
 
 static int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 {
@@ -1222,32 +1328,60 @@ static int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 	 */
 	*src = gate;
 	return 0;
-};
+}
+
+static inline unsigned int ni_tio_get_gate_mode(struct ni_gpct *counter)
+{
+	unsigned int mode = ni_tio_get_soft_copy(
+		counter, NITIO_MODE_REG(counter->counter_index));
+	unsigned int ret = 0;
+
+	if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED)
+		ret |= NI_GPCT_DISABLED_GATE_SELECT;
+	if (mode & GI_GATE_POL_INVERT)
+		ret |= CR_INVERT;
+	if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
+		ret |= CR_EDGE;
+
+	return ret;
+}
+
+static inline unsigned int ni_tio_get_gate2_mode(struct ni_gpct *counter)
+{
+	unsigned int mode = ni_tio_get_soft_copy(
+		counter, NITIO_GATE2_REG(counter->counter_index));
+	unsigned int ret = 0;
+
+	if (!(mode & GI_GATE2_MODE))
+		ret |= NI_GPCT_DISABLED_GATE_SELECT;
+	if (mode & GI_GATE2_POL_INVERT)
+		ret |= CR_INVERT;
+
+	return ret;
+}
+
+static inline unsigned int ni_tio_get_gate_val(struct ni_gpct *counter)
+{
+	return GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter,
+		NITIO_INPUT_SEL_REG(counter->counter_index)));
+}
+
+static inline unsigned int ni_tio_get_gate2_val(struct ni_gpct *counter)
+{
+	return GI_BITS_TO_GATE2(ni_tio_get_soft_copy(counter,
+		NITIO_GATE2_REG(counter->counter_index)));
+}
 
 static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 			       unsigned int *gate_source)
 {
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned int cidx = counter->counter_index;
-	unsigned int mode;
-	unsigned int reg;
 	unsigned int gate;
 	int ret;
 
-	mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
-	if (((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) ||
-	    (gate_index == 1 &&
-	     !(counter_dev->regs[NITIO_GATE2_REG(cidx)] & GI_GATE2_MODE))) {
-		*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
-		return 0;
-	}
-
 	switch (gate_index) {
 	case 0:
-		reg = NITIO_INPUT_SEL_REG(cidx);
-		gate = GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter, reg));
-
-		switch (counter_dev->variant) {
+		gate = ni_tio_get_gate_val(counter);
+		switch (counter->counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
@@ -1259,16 +1393,11 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 		}
 		if (ret)
 			return ret;
-		if (mode & GI_GATE_POL_INVERT)
-			*gate_source |= CR_INVERT;
-		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
-			*gate_source |= CR_EDGE;
+		*gate_source |= ni_tio_get_gate_mode(counter);
 		break;
 	case 1:
-		reg = NITIO_GATE2_REG(cidx);
-		gate = GI_BITS_TO_GATE2(counter_dev->regs[reg]);
-
-		switch (counter_dev->variant) {
+		gate = ni_tio_get_gate2_val(counter);
+		switch (counter->counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
@@ -1280,11 +1409,26 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 		}
 		if (ret)
 			return ret;
-		if (counter_dev->regs[reg] & GI_GATE2_POL_INVERT)
-			*gate_source |= CR_INVERT;
-		/* second gate can't have edge/level mode set independently */
-		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
-			*gate_source |= CR_EDGE;
+		*gate_source |= ni_tio_get_gate2_mode(counter);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ni_tio_get_gate_src_raw(struct ni_gpct *counter,
+				   unsigned int gate_index,
+				   unsigned int *gate_source)
+{
+	switch (gate_index) {
+	case 0:
+		*gate_source = ni_tio_get_gate_mode(counter)
+			     | ni_tio_get_gate_val(counter);
+		break;
+	case 1:
+		*gate_source = ni_tio_get_gate2_mode(counter)
+			     | ni_tio_get_gate2_val(counter);
 		break;
 	default:
 		return -EINVAL;
@@ -1347,6 +1491,107 @@ int ni_tio_insn_config(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_config);
 
+/**
+ * Retrieves the register value of the current source of the output selector for
+ * the given destination.
+ *
+ * If the terminal for the destination is not already configured as an output,
+ * this function returns -EINVAL as error.
+ *
+ * Return: the register value of the destination output selector;
+ *         -EINVAL if terminal is not configured for output.
+ */
+int ni_tio_get_routing(struct ni_gpct_device *counter_dev, unsigned int dest)
+{
+	/* we need to know the actual counter below... */
+	int ctr_index = (dest - NI_COUNTER_NAMES_BASE) % NI_MAX_COUNTERS;
+	struct ni_gpct *counter = &counter_dev->counters[ctr_index];
+	int ret = 1;
+	unsigned int reg;
+
+	if (dest >= NI_CtrA(0) && dest <= NI_CtrZ(-1)) {
+		ret = ni_tio_get_other_src(counter, dest, &reg);
+	} else if (dest >= NI_CtrGate(0) && dest <= NI_CtrGate(-1)) {
+		ret = ni_tio_get_gate_src_raw(counter, 0, &reg);
+	} else if (dest >= NI_CtrAux(0) && dest <= NI_CtrAux(-1)) {
+		ret = ni_tio_get_gate_src_raw(counter, 1, &reg);
+	/*
+	 * This case is not possible through this interface.  A user must use
+	 * INSN_CONFIG_SET_CLOCK_SRC instead.
+	 * } else if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1)) {
+	 *	ret = ni_tio_set_clock_src(counter, &reg, &period_ns);
+	 */
+	}
+
+	if (ret)
+		return -EINVAL;
+
+	return reg;
+}
+EXPORT_SYMBOL_GPL(ni_tio_get_routing);
+
+/**
+ * Sets the register value of the selector MUX for the given destination.
+ * @counter_dev:Pointer to general counter device.
+ * @destination:Device-global identifier of route destination.
+ * @register_value:
+ *		The first several bits of this value should store the desired
+ *		value to write to the register.  All other bits are for
+ *		transmitting information that modify the mode of the particular
+ *		destination/gate.  These mode bits might include a bitwise or of
+ *		CR_INVERT and CR_EDGE.  Note that the calling function should
+ *		have already validated the correctness of this value.
+ */
+int ni_tio_set_routing(struct ni_gpct_device *counter_dev, unsigned int dest,
+		       unsigned int reg)
+{
+	/* we need to know the actual counter below... */
+	int ctr_index = (dest - NI_COUNTER_NAMES_BASE) % NI_MAX_COUNTERS;
+	struct ni_gpct *counter = &counter_dev->counters[ctr_index];
+	int ret;
+
+	if (dest >= NI_CtrA(0) && dest <= NI_CtrZ(-1)) {
+		ret = ni_tio_set_other_src(counter, dest, reg);
+	} else if (dest >= NI_CtrGate(0) && dest <= NI_CtrGate(-1)) {
+		ret = ni_tio_set_gate_src_raw(counter, 0, reg);
+	} else if (dest >= NI_CtrAux(0) && dest <= NI_CtrAux(-1)) {
+		ret = ni_tio_set_gate_src_raw(counter, 1, reg);
+	/*
+	 * This case is not possible through this interface.  A user must use
+	 * INSN_CONFIG_SET_CLOCK_SRC instead.
+	 * } else if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1)) {
+	 *	ret = ni_tio_set_clock_src(counter, reg, period_ns);
+	 */
+	} else {
+		return -EINVAL;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ni_tio_set_routing);
+
+/**
+ * Sets the given destination MUX to its default value or disable it.
+ *
+ * Return: 0 if successful; -EINVAL if terminal is unknown.
+ */
+int ni_tio_unset_routing(struct ni_gpct_device *counter_dev, unsigned int dest)
+{
+	if (dest >= NI_GATES_NAMES_BASE && dest <= NI_GATES_NAMES_MAX)
+		/* Disable gate (via mode bits) and set to default 0-value */
+		return ni_tio_set_routing(counter_dev, dest,
+					  NI_GPCT_DISABLED_GATE_SELECT);
+	/*
+	 * This case is not possible through this interface.  A user must use
+	 * INSN_CONFIG_SET_CLOCK_SRC instead.
+	 * if (dest >= NI_CtrSource(0) && dest <= NI_CtrSource(-1))
+	 *	return ni_tio_set_clock_src(counter, reg, period_ns);
+	 */
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(ni_tio_unset_routing);
+
 static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 					    struct comedi_subdevice *s)
 {
@@ -1504,13 +1749,15 @@ ni_gpct_device_construct(struct comedi_device *dev,
 			 unsigned int (*read)(struct ni_gpct *counter,
 					      enum ni_gpct_register reg),
 			 enum ni_gpct_variant variant,
-			 unsigned int num_counters)
+			 unsigned int num_counters,
+			 unsigned int counters_per_chip,
+			 const struct ni_route_tables *routing_tables)
 {
 	struct ni_gpct_device *counter_dev;
 	struct ni_gpct *counter;
 	unsigned int i;
 
-	if (num_counters == 0)
+	if (num_counters == 0 || counters_per_chip == 0)
 		return NULL;
 
 	counter_dev = kzalloc(sizeof(*counter_dev), GFP_KERNEL);
@@ -1521,6 +1768,7 @@ ni_gpct_device_construct(struct comedi_device *dev,
 	counter_dev->write = write;
 	counter_dev->read = read;
 	counter_dev->variant = variant;
+	counter_dev->routing_tables = routing_tables;
 
 	spin_lock_init(&counter_dev->regs_lock);
 
@@ -1534,9 +1782,12 @@ ni_gpct_device_construct(struct comedi_device *dev,
 	for (i = 0; i < num_counters; ++i) {
 		counter = &counter_dev->counters[i];
 		counter->counter_dev = counter_dev;
+		counter->chip_index = i / counters_per_chip;
+		counter->counter_index = i % counters_per_chip;
 		spin_lock_init(&counter->lock);
 	}
 	counter_dev->num_counters = num_counters;
+	counter_dev->counters_per_chip = counters_per_chip;
 
 	return counter_dev;
 }

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1a6334c81525..ef919b21b7d9 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -3,16 +3,6 @@
  * Support for NI general purpose counters
  *
  * Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 15cb4088467b..1a6334c81525 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Support for NI general purpose counters
  *

commit ce0347c2b089eb6ad6c14ab628a0ba5eb42f1492
Merge: abbdc56b17d6 a25f0944ba9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 14 08:53:56 2016 +0100

    Merge 4.9-rc5 into staging-next
    
    We want the staging/iio fixes in here as well to resolve issues and
    merge problems.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 55abe8165f31ffb83ce8b24da959b61362dca4c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Oct 27 20:28:36 2016 +0100

    staging: comedi: ni_tio: fix buggy ni_tio_clock_period_ps() return value
    
    `ni_tio_clock_period_ps()` used to return the clock period in
    picoseconds, and had a `BUG()` call for invalid cases.  It was changed
    to pass the clock period back via a pointer parameter and return an
    error for the invalid cases.  Unfortunately the code to handle
    user-specified clock sources with user-specified clock period is still
    returning the clock period the old way, which can lead to the caller not
    getting the clock period, or seeing an unexpected error.  Fix it by
    passing the clock period via the pointer parameter and returning `0`.
    
    Fixes: b42ca86ad605 ("staging: comedi: ni_tio: remove BUG() checks for ni_tio_get_clock_src()")
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 7043eb0543f6..5ab49a798164 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -207,7 +207,8 @@ static int ni_tio_clock_period_ps(const struct ni_gpct *counter,
 		 * clock period is specified by user with prescaling
 		 * already taken into account.
 		 */
-		return counter->clock_period_ps;
+		*period_ps = counter->clock_period_ps;
+		return 0;
 	}
 
 	switch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {

commit c9b32721225b103f3e3fc406600aaaaddc2e8053
Author: Ted Chen <tedc.37zngo@gmail.com>
Date:   Sun Oct 30 23:29:20 2016 +0800

    staging: comedi: ni_tio: fix warnings of uninitialized variables
    
    Fix the following warnings by initializing these variables
    to zero and add error check to return early when the check
    returns an error.
    
    drivers/staging/comedi/drivers/ni_tio.c: In function ni_tio_set_sync_mode:
    drivers/staging/comedi/drivers/ni_tio.c:492:28: warning: ps may be used uninitialized in this function [-Wuninitialized]
    drivers/staging/comedi/drivers/ni_tio.c: In function ni_tio_insn_config:
    drivers/staging/comedi/drivers/ni_tio.c:820:2: warning: temp64 may be used uninitialized in this function [-Wuninitialized]
    drivers/staging/comedi/drivers/ni_tio.c:811:6: note: temp64 was declared her
    
    Signed-off-by: Ted Chen <tedc.37zngo@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 7043eb0543f6..15ca0323ddd9 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -451,8 +451,9 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter)
 	unsigned int bits = 0;
 	unsigned int reg;
 	unsigned int mode;
-	unsigned int clk_src;
-	u64 ps;
+	unsigned int clk_src = 0;
+	u64 ps = 0;
+	int ret;
 	bool force_alt_sync;
 
 	/* only m series and 660x variants have counting mode registers */
@@ -482,9 +483,12 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter)
 		break;
 	}
 
-	ni_tio_generic_clock_src_select(counter, &clk_src);
-	ni_tio_clock_period_ps(counter, clk_src, &ps);
-
+	ret = ni_tio_generic_clock_src_select(counter, &clk_src);
+	if (ret)
+		return;
+	ret = ni_tio_clock_period_ps(counter, clk_src, &ps);
+	if (ret)
+		return;
 	/*
 	 * It's not clear what we should do if clock_period is unknown, so we
 	 * are not using the alt sync bit in that case.
@@ -808,7 +812,7 @@ static int ni_tio_get_clock_src(struct ni_gpct *counter,
 				unsigned int *clock_source,
 				unsigned int *period_ns)
 {
-	u64 temp64;
+	u64 temp64 = 0;
 	int ret;
 
 	ret = ni_tio_generic_clock_src_select(counter, clock_source);

commit b42ca86ad605eb3e3f26618eed35ac6ff7435964
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:37:04 2016 -0700

    staging: comedi: ni_tio: remove BUG() checks for ni_tio_get_clock_src()
    
    This function calls some helper functions to convert the counter variant
    specific clock select bits into the generic enum ni_gpct_clock_source_bits
    equivelent. These helper functions currently BUG() if the clock select
    bits are invalid.
    
    It then calls ni_tio_clock_period_ps() to figure out the clock period
    based on the generic clock source. This function could also BUG() if
    the prescale bits are invalid.
    
    In reality this should never happen but refactor the code to return
    -EINVAL instead and remove the BUG() checks.
    
    These functions are also called by ni_tio_set_sync_mode(). When this
    function is called by ni_tio_set_clock_src() the counter select bits
    have already been validated.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 9ce3a9a92a9a..7043eb0543f6 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -183,8 +183,9 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 	ni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
 }
 
-static u64 ni_tio_clock_period_ps(const struct ni_gpct *counter,
-				  unsigned int generic_clock_source)
+static int ni_tio_clock_period_ps(const struct ni_gpct *counter,
+				  unsigned int generic_clock_source,
+				  u64 *period_ps)
 {
 	u64 clock_period_ps;
 
@@ -219,10 +220,10 @@ static u64 ni_tio_clock_period_ps(const struct ni_gpct *counter,
 		clock_period_ps *= 8;
 		break;
 	default:
-		BUG();
-		break;
+		return -EINVAL;
 	}
-	return clock_period_ps;
+	*period_ps = clock_period_ps;
+	return 0;
 }
 
 static void ni_tio_set_bits_transient(struct ni_gpct *counter,
@@ -304,7 +305,8 @@ static unsigned int ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 	return bits;
 }
 
-static unsigned int ni_m_series_clock_src_select(const struct ni_gpct *counter)
+static int ni_m_series_clock_src_select(const struct ni_gpct *counter,
+					unsigned int *clk_src)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
@@ -362,14 +364,15 @@ static unsigned int ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		}
 		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
-		BUG();
-		break;
+		return -EINVAL;
 	}
 	clock_source |= ni_tio_clock_src_modifiers(counter);
-	return clock_source;
+	*clk_src = clock_source;
+	return 0;
 }
 
-static unsigned int ni_660x_clock_src_select(const struct ni_gpct *counter)
+static int ni_660x_clock_src_select(const struct ni_gpct *counter,
+				    unsigned int *clk_src)
 {
 	unsigned int clock_source = 0;
 	unsigned int cidx = counter->counter_index;
@@ -419,23 +422,23 @@ static unsigned int ni_660x_clock_src_select(const struct ni_gpct *counter)
 		}
 		if (i <= NI_660X_MAX_SRC_PIN)
 			break;
-		BUG();
-		break;
+		return -EINVAL;
 	}
 	clock_source |= ni_tio_clock_src_modifiers(counter);
-	return clock_source;
+	*clk_src = clock_source;
+	return 0;
 }
 
-static unsigned int
-ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
+static int ni_tio_generic_clock_src_select(const struct ni_gpct *counter,
+					   unsigned int *clk_src)
 {
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 	default:
-		return ni_m_series_clock_src_select(counter);
+		return ni_m_series_clock_src_select(counter, clk_src);
 	case ni_gpct_variant_660x:
-		return ni_660x_clock_src_select(counter);
+		return ni_660x_clock_src_select(counter, clk_src);
 	}
 }
 
@@ -448,6 +451,7 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter)
 	unsigned int bits = 0;
 	unsigned int reg;
 	unsigned int mode;
+	unsigned int clk_src;
 	u64 ps;
 	bool force_alt_sync;
 
@@ -478,8 +482,8 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter)
 		break;
 	}
 
-	ps = ni_tio_clock_period_ps(counter,
-				    ni_tio_generic_clock_src_select(counter));
+	ni_tio_generic_clock_src_select(counter, &clk_src);
+	ni_tio_clock_period_ps(counter, clk_src, &ps);
 
 	/*
 	 * It's not clear what we should do if clock_period is unknown, so we
@@ -800,16 +804,22 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	return 0;
 }
 
-static void ni_tio_get_clock_src(struct ni_gpct *counter,
-				 unsigned int *clock_source,
-				 unsigned int *period_ns)
+static int ni_tio_get_clock_src(struct ni_gpct *counter,
+				unsigned int *clock_source,
+				unsigned int *period_ns)
 {
 	u64 temp64;
+	int ret;
 
-	*clock_source = ni_tio_generic_clock_src_select(counter);
-	temp64 = ni_tio_clock_period_ps(counter, *clock_source);
+	ret = ni_tio_generic_clock_src_select(counter, clock_source);
+	if (ret)
+		return ret;
+	ret = ni_tio_clock_period_ps(counter, *clock_source, &temp64);
+	if (ret)
+		return ret;
 	do_div(temp64, 1000);	/* ps to ns */
 	*period_ns = temp64;
+	return 0;
 }
 
 static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
@@ -1320,7 +1330,7 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		ret = ni_tio_set_clock_src(counter, data[1], data[2]);
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
-		ni_tio_get_clock_src(counter, &data[1], &data[2]);
+		ret = ni_tio_get_clock_src(counter, &data[1], &data[2]);
 		break;
 	case INSN_CONFIG_SET_GATE_SRC:
 		ret = ni_tio_set_gate_src(counter, data[1], data[2]);

commit fa74d136fda8512a17918fc5f97a72acd05c22e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:37:03 2016 -0700

    staging: comedi: ni_tio: remove BUG() in ni_tio_set_gate_src()
    
    This BUG() can never happen. The previous ni_tio_has_gate2_registers()
    check will have already caused the function to return -EINVAL.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 10d4585ab25c..9ce3a9a92a9a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1020,8 +1020,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter,
 		case ni_gpct_variant_660x:
 			return ni_660x_set_gate2(counter, src);
 		default:
-			BUG();
-			break;
+			return -EINVAL;
 		}
 		break;
 	default:

commit 592ef9fb8d7e5deb359b02530c5bb0d0b717cfef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:37:02 2016 -0700

    staging: comedi: ni_tio: fix ni_tio_insn_config()
    
    The (*insn_config) functions are supposed to return an errno or the number
    of 'data' values used for the instruction (insn->n). Currently this function
    returns an errno or 0. Fix the function to work like the core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 51dd368f788d..10d4585ab25c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1295,15 +1295,18 @@ int ni_tio_insn_config(struct comedi_device *dev,
 	struct ni_gpct *counter = s->private;
 	unsigned int cidx = counter->counter_index;
 	unsigned int status;
+	int ret = 0;
 
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
-		return ni_tio_set_counter_mode(counter, data[1]);
+		ret = ni_tio_set_counter_mode(counter, data[1]);
+		break;
 	case INSN_CONFIG_ARM:
-		return ni_tio_arm(counter, true, data[1]);
+		ret = ni_tio_arm(counter, true, data[1]);
+		break;
 	case INSN_CONFIG_DISARM:
-		ni_tio_arm(counter, false, 0);
-		return 0;
+		ret = ni_tio_arm(counter, false, 0);
+		break;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = 0;
 		status = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));
@@ -1313,25 +1316,29 @@ int ni_tio_insn_config(struct comedi_device *dev,
 				data[1] |= COMEDI_COUNTER_COUNTING;
 		}
 		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
-		return 0;
+		break;
 	case INSN_CONFIG_SET_CLOCK_SRC:
-		return ni_tio_set_clock_src(counter, data[1], data[2]);
+		ret = ni_tio_set_clock_src(counter, data[1], data[2]);
+		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
 		ni_tio_get_clock_src(counter, &data[1], &data[2]);
-		return 0;
+		break;
 	case INSN_CONFIG_SET_GATE_SRC:
-		return ni_tio_set_gate_src(counter, data[1], data[2]);
+		ret = ni_tio_set_gate_src(counter, data[1], data[2]);
+		break;
 	case INSN_CONFIG_GET_GATE_SRC:
-		return ni_tio_get_gate_src(counter, data[1], &data[2]);
+		ret = ni_tio_get_gate_src(counter, data[1], &data[2]);
+		break;
 	case INSN_CONFIG_SET_OTHER_SRC:
-		return ni_tio_set_other_src(counter, data[1], data[2]);
+		ret = ni_tio_set_other_src(counter, data[1], data[2]);
+		break;
 	case INSN_CONFIG_RESET:
 		ni_tio_reset_count_and_disarm(counter);
-		return 0;
-	default:
 		break;
+	default:
+		return -EINVAL;
 	}
-	return -EINVAL;
+	return ret ? ret : insn->n;
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_config);
 

commit 475ea1ed14cce2608ed0f12474be2a3d75880eaf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:37:01 2016 -0700

    staging: comedi: ni_tio: remove BUG() checks for ni_tio_get_gate_src()
    
    This function calls some helper functions to convert the counter variant
    specific gate select bits into the generic enum ni_gpct_clock_source_bits
    equivelent. These helper functions currently BUG() if the gate select
    bits are invalid.
    
    This should never happen but refactor the code to return -EINVAL instead
    and remove the BUG() checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 564ec9bfd43d..51dd368f788d 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1065,114 +1065,157 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 	return 0;
 }
 
-static unsigned int ni_660x_gate_to_generic_gate(unsigned int gate)
+static int ni_660x_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 {
+	unsigned int source;
 	unsigned int i;
 
 	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE_SEL:
-		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		source = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		break;
 	case NI_660X_GATE_PIN_I_GATE_SEL:
-		return NI_GPCT_GATE_PIN_i_GATE_SELECT;
+		source = NI_GPCT_GATE_PIN_i_GATE_SELECT;
+		break;
 	case NI_660X_NEXT_SRC_GATE_SEL:
-		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		source = NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
 	case NI_660X_NEXT_OUT_GATE_SEL:
-		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		source = NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
 	case NI_660X_LOGIC_LOW_GATE_SEL:
-		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		source = NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (gate == NI_660X_RTSI_GATE_SEL(i))
-				return NI_GPCT_RTSI_GATE_SELECT(i);
+			if (gate == NI_660X_RTSI_GATE_SEL(i)) {
+				source = NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
 		}
+		if (i <= NI_660X_MAX_RTSI_CHAN)
+			break;
 		for (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {
-			if (gate == NI_660X_PIN_GATE_SEL(i))
-				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
+			if (gate == NI_660X_PIN_GATE_SEL(i)) {
+				source = NI_GPCT_GATE_PIN_GATE_SELECT(i);
+				break;
+			}
 		}
-		BUG();
-		break;
+		if (i <= NI_660X_MAX_GATE_PIN)
+			break;
+		return -EINVAL;
 	}
+	*src = source;
 	return 0;
 };
 
-static unsigned int ni_m_gate_to_generic_gate(unsigned int gate)
+static int ni_m_gate_to_generic_gate(unsigned int gate, unsigned int *src)
 {
+	unsigned int source;
 	unsigned int i;
 
 	switch (gate) {
 	case NI_M_TIMESTAMP_MUX_GATE_SEL:
-		return NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
+		source = NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
+		break;
 	case NI_M_AI_START2_GATE_SEL:
-		return NI_GPCT_AI_START2_GATE_SELECT;
+		source = NI_GPCT_AI_START2_GATE_SELECT;
+		break;
 	case NI_M_PXI_STAR_TRIGGER_GATE_SEL:
-		return NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;
+		source = NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;
+		break;
 	case NI_M_NEXT_OUT_GATE_SEL:
-		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		source = NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
 	case NI_M_AI_START1_GATE_SEL:
-		return NI_GPCT_AI_START1_GATE_SELECT;
+		source = NI_GPCT_AI_START1_GATE_SELECT;
+		break;
 	case NI_M_NEXT_SRC_GATE_SEL:
-		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		source = NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
 	case NI_M_ANALOG_TRIG_OUT_GATE_SEL:
-		return NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;
+		source = NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;
+		break;
 	case NI_M_LOGIC_LOW_GATE_SEL:
-		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		source = NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
-			if (gate == NI_M_RTSI_GATE_SEL(i))
-				return NI_GPCT_RTSI_GATE_SELECT(i);
+			if (gate == NI_M_RTSI_GATE_SEL(i)) {
+				source = NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
 		}
+		if (i <= NI_M_MAX_RTSI_CHAN)
+			break;
 		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
-			if (gate == NI_M_PFI_GATE_SEL(i))
-				return NI_GPCT_PFI_GATE_SELECT(i);
+			if (gate == NI_M_PFI_GATE_SEL(i)) {
+				source = NI_GPCT_PFI_GATE_SELECT(i);
+				break;
+			}
 		}
-		BUG();
-		break;
+		if (i <= NI_M_MAX_PFI_CHAN)
+			break;
+		return -EINVAL;
 	}
+	*src = source;
 	return 0;
 };
 
-static unsigned int ni_660x_gate2_to_generic_gate(unsigned int gate)
+static int ni_660x_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 {
+	unsigned int source;
 	unsigned int i;
 
 	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE2_SEL:
-		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		source = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		break;
 	case NI_660X_UD_PIN_I_GATE2_SEL:
-		return NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;
+		source = NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;
+		break;
 	case NI_660X_NEXT_SRC_GATE2_SEL:
-		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		source = NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
 	case NI_660X_NEXT_OUT_GATE2_SEL:
-		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		source = NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
 	case NI_660X_SELECTED_GATE2_SEL:
-		return NI_GPCT_SELECTED_GATE_GATE_SELECT;
+		source = NI_GPCT_SELECTED_GATE_GATE_SELECT;
+		break;
 	case NI_660X_LOGIC_LOW_GATE2_SEL:
-		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		source = NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (gate == NI_660X_RTSI_GATE2_SEL(i))
-				return NI_GPCT_RTSI_GATE_SELECT(i);
+			if (gate == NI_660X_RTSI_GATE2_SEL(i)) {
+				source = NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
 		}
+		if (i <= NI_660X_MAX_RTSI_CHAN)
+			break;
 		for (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {
-			if (gate == NI_660X_UD_PIN_GATE2_SEL(i))
-				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
+			if (gate == NI_660X_UD_PIN_GATE2_SEL(i)) {
+				source = NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
+				break;
+			}
 		}
-		BUG();
-		break;
+		if (i <= NI_660X_MAX_UP_DOWN_PIN)
+			break;
+		return -EINVAL;
 	}
+	*src = source;
 	return 0;
 };
 
-static unsigned int ni_m_gate2_to_generic_gate(unsigned int gate)
+static int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)
 {
 	/*
 	 * FIXME: the second gate sources for the m series are undocumented,
 	 * so we just return the raw bits for now.
 	 */
-	switch (gate) {
-	default:
-		return gate;
-	}
+	*src = gate;
 	return 0;
 };
 
@@ -1184,6 +1227,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 	unsigned int mode;
 	unsigned int reg;
 	unsigned int gate;
+	int ret;
 
 	mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
 	if (((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) ||
@@ -1202,12 +1246,14 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source = ni_m_gate_to_generic_gate(gate);
+			ret = ni_m_gate_to_generic_gate(gate, gate_source);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source = ni_660x_gate_to_generic_gate(gate);
+			ret = ni_660x_gate_to_generic_gate(gate, gate_source);
 			break;
 		}
+		if (ret)
+			return ret;
 		if (mode & GI_GATE_POL_INVERT)
 			*gate_source |= CR_INVERT;
 		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
@@ -1221,12 +1267,14 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source = ni_m_gate2_to_generic_gate(gate);
+			ret = ni_m_gate2_to_generic_gate(gate, gate_source);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source = ni_660x_gate2_to_generic_gate(gate);
+			ret = ni_660x_gate2_to_generic_gate(gate, gate_source);
 			break;
 		}
+		if (ret)
+			return ret;
 		if (counter_dev->regs[reg] & GI_GATE2_POL_INVERT)
 			*gate_source |= CR_INVERT;
 		/* second gate can't have edge/level mode set independently */

commit d87f5e90585a8b8646c3e9fe92d4c47716f5e19d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:37:00 2016 -0700

    staging: comedi: ni_tio: validate clock source
    
    Refactor the functions that determine the clock source bits so that they
    return -EINVAL if the clock source is invalid. Pass the errno back to
    ni_tio_insn_config().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e7209c1ca816..564ec9bfd43d 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -608,7 +608,7 @@ int ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)
 }
 EXPORT_SYMBOL_GPL(ni_tio_arm);
 
-static unsigned int ni_660x_clk_src(unsigned int clock_source)
+static int ni_660x_clk_src(unsigned int clock_source, unsigned int *bits)
 {
 	unsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned int ni_660x_clock;
@@ -653,14 +653,13 @@ static unsigned int ni_660x_clk_src(unsigned int clock_source)
 		}
 		if (i <= NI_660X_MAX_SRC_PIN)
 			break;
-		ni_660x_clock = 0;
-		BUG();
-		break;
+		return -EINVAL;
 	}
-	return GI_SRC_SEL(ni_660x_clock);
+	*bits = GI_SRC_SEL(ni_660x_clock);
+	return 0;
 }
 
-static unsigned int ni_m_clk_src(unsigned int clock_source)
+static int ni_m_clk_src(unsigned int clock_source, unsigned int *bits)
 {
 	unsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned int ni_m_series_clock;
@@ -711,13 +710,10 @@ static unsigned int ni_m_clk_src(unsigned int clock_source)
 		}
 		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
-		pr_err("invalid clock source 0x%lx\n",
-		       (unsigned long)clock_source);
-		BUG();
-		ni_m_series_clock = 0;
-		break;
+		return -EINVAL;
 	}
-	return GI_SRC_SEL(ni_m_series_clock);
+	*bits = GI_SRC_SEL(ni_m_series_clock);
+	return 0;
 };
 
 static void ni_tio_set_source_subselect(struct ni_gpct *counter,
@@ -755,18 +751,26 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
 	unsigned int bits = 0;
+	int ret;
 
-	/* FIXME: validate clock source */
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_660x:
-		bits |= ni_660x_clk_src(clock_source);
+		ret = ni_660x_clk_src(clock_source, &bits);
 		break;
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 	default:
-		bits |= ni_m_clk_src(clock_source);
+		ret = ni_m_clk_src(clock_source, &bits);
 		break;
 	}
+	if (ret) {
+		struct comedi_device *dev = counter_dev->dev;
+
+		dev_err(dev->class_dev, "invalid clock source 0x%x\n",
+			clock_source);
+		return ret;
+	}
+
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		bits |= GI_SRC_POL_INVERT;
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),

commit e3f7bb258b2f73c595ea8f2d26ad2cb137844b8a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:55 2016 -0700

    staging: comedi: ni_tio: tidy up ni_tio_arm()
    
    Make this function a bit more consise by absorbing the GI_HW_ARM_SEL_MASK()
    inline helper and combine the two switch (start_trigger) code paths.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 2c33b28bf114..e7209c1ca816 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -137,19 +137,6 @@ static inline unsigned int GI_PRESCALE_X8(enum ni_gpct_variant variant)
 	}
 }
 
-static inline unsigned int GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
-{
-	switch (variant) {
-	case ni_gpct_variant_e_series:
-	default:
-		return 0;
-	case ni_gpct_variant_m_series:
-		return GI_M_HW_ARM_SEL_MASK;
-	case ni_gpct_variant_660x:
-		return GI_660X_HW_ARM_SEL_MASK;
-	}
-}
-
 static bool ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
@@ -568,52 +555,55 @@ int ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
-	unsigned int command_transient_bits = 0;
+	unsigned int transient_bits = 0;
 
 	if (arm) {
+		unsigned int mask = 0;
+		unsigned int bits = 0;
+
+		/* only m series and 660x have counting mode registers */
+		switch (counter_dev->variant) {
+		case ni_gpct_variant_e_series:
+		default:
+			break;
+		case ni_gpct_variant_m_series:
+			mask = GI_M_HW_ARM_SEL_MASK;
+			break;
+		case ni_gpct_variant_660x:
+			mask = GI_660X_HW_ARM_SEL_MASK;
+			break;
+		}
+
 		switch (start_trigger) {
 		case NI_GPCT_ARM_IMMEDIATE:
-			command_transient_bits |= GI_ARM;
+			transient_bits |= GI_ARM;
 			break;
 		case NI_GPCT_ARM_PAIRED_IMMEDIATE:
-			command_transient_bits |= GI_ARM | GI_ARM_COPY;
+			transient_bits |= GI_ARM | GI_ARM_COPY;
 			break;
 		default:
+			/*
+			 * for m series and 660x, pass-through the least
+			 * significant bits so we can figure out what select
+			 * later
+			 */
+			if (mask && (start_trigger & NI_GPCT_ARM_UNKNOWN)) {
+				bits |= GI_HW_ARM_ENA |
+					(GI_HW_ARM_SEL(start_trigger) & mask);
+			} else {
+				return -EINVAL;
+			}
 			break;
 		}
-		if (ni_tio_counting_mode_registers_present(counter_dev)) {
-			unsigned int bits = 0;
-			unsigned int sel_mask;
 
-			sel_mask = GI_HW_ARM_SEL_MASK(counter_dev->variant);
-
-			switch (start_trigger) {
-			case NI_GPCT_ARM_IMMEDIATE:
-			case NI_GPCT_ARM_PAIRED_IMMEDIATE:
-				break;
-			default:
-				if (start_trigger & NI_GPCT_ARM_UNKNOWN) {
-					/*
-					 * pass-through the least significant
-					 * bits so we can figure out what
-					 * select later
-					 */
-					bits |= GI_HW_ARM_ENA |
-						(GI_HW_ARM_SEL(start_trigger) &
-						 sel_mask);
-				} else {
-					return -EINVAL;
-				}
-				break;
-			}
+		if (mask)
 			ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
-					GI_HW_ARM_ENA | sel_mask, bits);
-		}
+					GI_HW_ARM_ENA | mask, bits);
 	} else {
-		command_transient_bits |= GI_DISARM;
+		transient_bits |= GI_DISARM;
 	}
 	ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
-				  0, 0, command_transient_bits);
+				  0, 0, transient_bits);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_arm);

commit f51700a6428d7c8e94d48fd2fbb1062c604e8b2c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:54 2016 -0700

    staging: comedi: ni_tio: tidy up ni_tio_set_sync_mode()
    
    The 'force_alt_sync' paramater is always 0. Remove it.
    
    Absorb the GI_ALT_SYNC() inline helper and use some local variables
    to clarify this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ce64cc39e49c..2c33b28bf114 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -111,19 +111,6 @@
 #define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
 #define NI_660X_MAX_UP_DOWN_PIN		7
 
-static inline unsigned int GI_ALT_SYNC(enum ni_gpct_variant variant)
-{
-	switch (variant) {
-	case ni_gpct_variant_e_series:
-	default:
-		return 0;
-	case ni_gpct_variant_m_series:
-		return GI_M_ALT_SYNC;
-	case ni_gpct_variant_660x:
-		return GI_660X_ALT_SYNC;
-	}
-}
-
 static inline unsigned int GI_PRESCALE_X2(enum ni_gpct_variant variant)
 {
 	switch (variant) {
@@ -465,48 +452,56 @@ ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 	}
 }
 
-static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
+static void ni_tio_set_sync_mode(struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
-	unsigned int counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
 	static const u64 min_normal_sync_period_ps = 25000;
+	unsigned int mask = 0;
+	unsigned int bits = 0;
+	unsigned int reg;
 	unsigned int mode;
-	u64 clock_period_ps;
+	u64 ps;
+	bool force_alt_sync;
 
-	if (!ni_tio_counting_mode_registers_present(counter_dev))
+	/* only m series and 660x variants have counting mode registers */
+	switch (counter_dev->variant) {
+	case ni_gpct_variant_e_series:
+	default:
 		return;
+	case ni_gpct_variant_m_series:
+		mask = GI_M_ALT_SYNC;
+		break;
+	case ni_gpct_variant_660x:
+		mask = GI_660X_ALT_SYNC;
+		break;
+	}
 
-	mode = ni_tio_get_soft_copy(counter, counting_mode_reg);
+	reg = NITIO_CNT_MODE_REG(cidx);
+	mode = ni_tio_get_soft_copy(counter, reg);
 	switch (mode & GI_CNT_MODE_MASK) {
 	case GI_CNT_MODE_QUADX1:
 	case GI_CNT_MODE_QUADX2:
 	case GI_CNT_MODE_QUADX4:
 	case GI_CNT_MODE_SYNC_SRC:
-		force_alt_sync = 1;
+		force_alt_sync = true;
 		break;
 	default:
+		force_alt_sync = false;
 		break;
 	}
 
-	clock_period_ps = ni_tio_clock_period_ps(counter,
-				ni_tio_generic_clock_src_select(counter));
+	ps = ni_tio_clock_period_ps(counter,
+				    ni_tio_generic_clock_src_select(counter));
 
 	/*
 	 * It's not clear what we should do if clock_period is unknown, so we
-	 * are not using the alt sync bit in that case, but allow the caller
-	 * to decide by using the force_alt_sync parameter.
+	 * are not using the alt sync bit in that case.
 	 */
-	if (force_alt_sync ||
-	    (clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {
-		ni_tio_set_bits(counter, counting_mode_reg,
-				GI_ALT_SYNC(counter_dev->variant),
-				GI_ALT_SYNC(counter_dev->variant));
-	} else {
-		ni_tio_set_bits(counter, counting_mode_reg,
-				GI_ALT_SYNC(counter_dev->variant),
-				0x0);
-	}
+	if (force_alt_sync || (ps && ps < min_normal_sync_period_ps))
+		bits = mask;
+
+	ni_tio_set_bits(counter, reg, mask, bits);
 }
 
 static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned int mode)
@@ -552,7 +547,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned int mode)
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 				GI_CNT_MODE_MASK | GI_INDEX_PHASE_MASK |
 				GI_INDEX_MODE, bits);
-		ni_tio_set_sync_mode(counter, 0);
+		ni_tio_set_sync_mode(counter);
 	}
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_CNT_DIR_MASK,
@@ -807,7 +802,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 				GI_PRESCALE_X8(counter_dev->variant), bits);
 	}
 	counter->clock_period_ps = period_ns * 1000;
-	ni_tio_set_sync_mode(counter, 0);
+	ni_tio_set_sync_mode(counter);
 	return 0;
 }
 

commit a56b3f57c2f08a6f42c957c3731ca9f8158b6355
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:53 2016 -0700

    staging: comedi: ni_tio: tidy up ni_tio_get_gate_src()
    
    Clarify the code a bit by handling the NI_GPCT_DISABLED_GATE_SELECT source
    in the common code path.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e7af98d78607..ce64cc39e49c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1192,19 +1192,22 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
-	unsigned int mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
-	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned int mode;
+	unsigned int reg;
 	unsigned int gate;
 
+	mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
+	if (((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) ||
+	    (gate_index == 1 &&
+	     !(counter_dev->regs[NITIO_GATE2_REG(cidx)] & GI_GATE2_MODE))) {
+		*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
+		return 0;
+	}
+
 	switch (gate_index) {
 	case 0:
-		if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) {
-			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
-			return 0;
-		}
-
-		gate = GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter,
-						NITIO_INPUT_SEL_REG(cidx)));
+		reg = NITIO_INPUT_SEL_REG(cidx);
+		gate = GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter, reg));
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
@@ -1222,13 +1225,8 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 			*gate_source |= CR_EDGE;
 		break;
 	case 1:
-		if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED ||
-		    !(counter_dev->regs[gate2_reg] & GI_GATE2_MODE)) {
-			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
-			return 0;
-		}
-
-		gate = GI_BITS_TO_GATE2(counter_dev->regs[gate2_reg]);
+		reg = NITIO_GATE2_REG(cidx);
+		gate = GI_BITS_TO_GATE2(counter_dev->regs[reg]);
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
@@ -1240,7 +1238,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 			*gate_source = ni_660x_gate2_to_generic_gate(gate);
 			break;
 		}
-		if (counter_dev->regs[gate2_reg] & GI_GATE2_POL_INVERT)
+		if (counter_dev->regs[reg] & GI_GATE2_POL_INVERT)
 			*gate_source |= CR_INVERT;
 		/* second gate can't have edge/level mode set independently */
 		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)

commit 8e621cf0cb9761b7ef74a63d228ce62418dc5b8c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:52 2016 -0700

    staging: comedi: ni_tio: fix block comments
    
    Fix the checkpatch.pl issues:
    WARNING: Block comments use * on subsequent lines
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e4fd22123ef0..e7af98d78607 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1,19 +1,18 @@
 /*
-  comedi/drivers/ni_tio.c
-  Support for NI general purpose counters
-
-  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-*/
+ * Support for NI general purpose counters
+ *
+ * Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
  * Module: ni_tio
@@ -36,13 +35,10 @@
  * DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
  * DAQ 6601/6602 User Manual (NI 322137B-01)
  * 340934b.pdf  DAQ-STC reference manual
+ *
+ * TODO: Support use of both banks X and Y
  */
 
-/*
-TODO:
-	Support use of both banks X and Y
-*/
-
 #include <linux/module.h>
 #include <linux/slab.h>
 

commit 3676cdd9539a64d1b3e8cad8d8e5184bf860841a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:51 2016 -0700

    staging: comedi: ni_tio: Prefer kernel type 'u64' over 'uint64_t'
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ecf85270c264..e4fd22123ef0 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -213,10 +213,10 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 	ni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
 }
 
-static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-				       unsigned int generic_clock_source)
+static u64 ni_tio_clock_period_ps(const struct ni_gpct *counter,
+				  unsigned int generic_clock_source)
 {
-	uint64_t clock_period_ps;
+	u64 clock_period_ps;
 
 	switch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
@@ -474,9 +474,9 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int cidx = counter->counter_index;
 	unsigned int counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
-	static const uint64_t min_normal_sync_period_ps = 25000;
+	static const u64 min_normal_sync_period_ps = 25000;
 	unsigned int mode;
-	uint64_t clock_period_ps;
+	u64 clock_period_ps;
 
 	if (!ni_tio_counting_mode_registers_present(counter_dev))
 		return;
@@ -819,7 +819,7 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 				 unsigned int *clock_source,
 				 unsigned int *period_ns)
 {
-	uint64_t temp64;
+	u64 temp64;
 
 	*clock_source = ni_tio_generic_clock_src_select(counter);
 	temp64 = ni_tio_clock_period_ps(counter, *clock_source);

commit 74ea93be6ce16f01e9e73a4ad5abeb984b0b02fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:50 2016 -0700

    staging: comedi: ni_tio: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 28bec3cfeef5..ecf85270c264 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -115,7 +115,7 @@
 #define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
 #define NI_660X_MAX_UP_DOWN_PIN		7
 
-static inline unsigned GI_ALT_SYNC(enum ni_gpct_variant variant)
+static inline unsigned int GI_ALT_SYNC(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -128,7 +128,7 @@ static inline unsigned GI_ALT_SYNC(enum ni_gpct_variant variant)
 	}
 }
 
-static inline unsigned GI_PRESCALE_X2(enum ni_gpct_variant variant)
+static inline unsigned int GI_PRESCALE_X2(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -141,7 +141,7 @@ static inline unsigned GI_PRESCALE_X2(enum ni_gpct_variant variant)
 	}
 }
 
-static inline unsigned GI_PRESCALE_X8(enum ni_gpct_variant variant)
+static inline unsigned int GI_PRESCALE_X8(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -154,7 +154,7 @@ static inline unsigned GI_PRESCALE_X8(enum ni_gpct_variant variant)
 	}
 }
 
-static inline unsigned GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
+static inline unsigned int GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -208,13 +208,13 @@ EXPORT_SYMBOL_GPL(ni_tio_read);
 
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 
 	ni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-				       unsigned generic_clock_source)
+				       unsigned int generic_clock_source)
 {
 	uint64_t clock_period_ps;
 
@@ -316,13 +316,13 @@ unsigned int ni_tio_get_soft_copy(const struct ni_gpct *counter,
 }
 EXPORT_SYMBOL_GPL(ni_tio_get_soft_copy);
 
-static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
+static unsigned int ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned counting_mode_bits =
+	unsigned int cidx = counter->counter_index;
+	unsigned int counting_mode_bits =
 		ni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));
-	unsigned bits = 0;
+	unsigned int bits = 0;
 
 	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
 	    GI_SRC_POL_INVERT)
@@ -334,14 +334,14 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 	return bits;
 }
 
-static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
+static unsigned int ni_m_series_clock_src_select(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
-	unsigned clock_source = 0;
-	unsigned src;
-	unsigned i;
+	unsigned int cidx = counter->counter_index;
+	unsigned int second_gate_reg = NITIO_GATE2_REG(cidx);
+	unsigned int clock_source = 0;
+	unsigned int src;
+	unsigned int i;
 
 	src = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,
 						  NITIO_INPUT_SEL_REG(cidx)));
@@ -399,12 +399,12 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 	return clock_source;
 }
 
-static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
+static unsigned int ni_660x_clock_src_select(const struct ni_gpct *counter)
 {
-	unsigned clock_source = 0;
-	unsigned cidx = counter->counter_index;
-	unsigned src;
-	unsigned i;
+	unsigned int clock_source = 0;
+	unsigned int cidx = counter->counter_index;
+	unsigned int src;
+	unsigned int i;
 
 	src = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,
 						  NITIO_INPUT_SEL_REG(cidx)));
@@ -456,7 +456,8 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 	return clock_source;
 }
 
-static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
+static unsigned int
+ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 {
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -471,10 +472,10 @@ static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
+	unsigned int cidx = counter->counter_index;
+	unsigned int counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
 	static const uint64_t min_normal_sync_period_ps = 25000;
-	unsigned mode;
+	unsigned int mode;
 	uint64_t clock_period_ps;
 
 	if (!ni_tio_counting_mode_registers_present(counter_dev))
@@ -512,15 +513,15 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	}
 }
 
-static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
+static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned int mode)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned mode_reg_mask;
-	unsigned mode_reg_values;
-	unsigned input_select_bits = 0;
+	unsigned int cidx = counter->counter_index;
+	unsigned int mode_reg_mask;
+	unsigned int mode_reg_values;
+	unsigned int input_select_bits = 0;
 	/* these bits map directly on to the mode register */
-	static const unsigned mode_reg_direct_mask =
+	static const unsigned int mode_reg_direct_mask =
 	    NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
 	    NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
 	    NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
@@ -546,7 +547,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
-		unsigned bits = 0;
+		unsigned int bits = 0;
 
 		bits |= GI_CNT_MODE(mode >> NI_GPCT_COUNTING_MODE_SHIFT);
 		bits |= GI_INDEX_PHASE((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT));
@@ -626,11 +627,11 @@ int ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)
 }
 EXPORT_SYMBOL_GPL(ni_tio_arm);
 
-static unsigned ni_660x_clk_src(unsigned int clock_source)
+static unsigned int ni_660x_clk_src(unsigned int clock_source)
 {
-	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
-	unsigned ni_660x_clock;
-	unsigned i;
+	unsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	unsigned int ni_660x_clock;
+	unsigned int i;
 
 	switch (clk_src) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
@@ -678,11 +679,11 @@ static unsigned ni_660x_clk_src(unsigned int clock_source)
 	return GI_SRC_SEL(ni_660x_clock);
 }
 
-static unsigned ni_m_clk_src(unsigned int clock_source)
+static unsigned int ni_m_clk_src(unsigned int clock_source)
 {
-	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
-	unsigned ni_m_series_clock;
-	unsigned i;
+	unsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	unsigned int ni_m_series_clock;
+	unsigned int i;
 
 	switch (clk_src) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
@@ -742,8 +743,8 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 					unsigned int clock_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
+	unsigned int cidx = counter->counter_index;
+	unsigned int second_gate_reg = NITIO_GATE2_REG(cidx);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
 		return;
@@ -771,8 +772,8 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 				unsigned int period_ns)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned bits = 0;
+	unsigned int cidx = counter->counter_index;
+	unsigned int bits = 0;
 
 	/* FIXME: validate clock source */
 	switch (counter_dev->variant) {
@@ -829,9 +830,9 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned cidx = counter->counter_index;
-	unsigned gate_sel;
-	unsigned i;
+	unsigned int cidx = counter->counter_index;
+	unsigned int gate_sel;
+	unsigned int i;
 
 	switch (chan) {
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
@@ -870,9 +871,9 @@ static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned cidx = counter->counter_index;
-	unsigned gate_sel;
-	unsigned i;
+	unsigned int cidx = counter->counter_index;
+	unsigned int gate_sel;
+	unsigned int i;
 
 	switch (chan) {
 	case NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:
@@ -912,11 +913,11 @@ static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned gate2_sel;
-	unsigned i;
+	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned int gate2_sel;
+	unsigned int i;
 
 	switch (chan) {
 	case NI_GPCT_SOURCE_PIN_i_GATE_SELECT:
@@ -958,10 +959,10 @@ static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	unsigned int chan = CR_CHAN(gate_source);
-	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned gate2_sel;
+	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned int gate2_sel;
 
 	/*
 	 * FIXME: We don't know what the m-series second gate codes are,
@@ -1045,11 +1046,11 @@ int ni_tio_set_gate_src(struct ni_gpct *counter,
 }
 EXPORT_SYMBOL_GPL(ni_tio_set_gate_src);
 
-static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
+static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,
 				unsigned int source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	unsigned int abz_reg, shift, mask;
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
@@ -1079,9 +1080,9 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 	return 0;
 }
 
-static unsigned ni_660x_gate_to_generic_gate(unsigned gate)
+static unsigned int ni_660x_gate_to_generic_gate(unsigned int gate)
 {
-	unsigned i;
+	unsigned int i;
 
 	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE_SEL:
@@ -1109,9 +1110,9 @@ static unsigned ni_660x_gate_to_generic_gate(unsigned gate)
 	return 0;
 };
 
-static unsigned ni_m_gate_to_generic_gate(unsigned gate)
+static unsigned int ni_m_gate_to_generic_gate(unsigned int gate)
 {
-	unsigned i;
+	unsigned int i;
 
 	switch (gate) {
 	case NI_M_TIMESTAMP_MUX_GATE_SEL:
@@ -1145,9 +1146,9 @@ static unsigned ni_m_gate_to_generic_gate(unsigned gate)
 	return 0;
 };
 
-static unsigned ni_660x_gate2_to_generic_gate(unsigned gate)
+static unsigned int ni_660x_gate2_to_generic_gate(unsigned int gate)
 {
-	unsigned i;
+	unsigned int i;
 
 	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE2_SEL:
@@ -1177,7 +1178,7 @@ static unsigned ni_660x_gate2_to_generic_gate(unsigned gate)
 	return 0;
 };
 
-static unsigned ni_m_gate2_to_generic_gate(unsigned gate)
+static unsigned int ni_m_gate2_to_generic_gate(unsigned int gate)
 {
 	/*
 	 * FIXME: the second gate sources for the m series are undocumented,
@@ -1190,14 +1191,14 @@ static unsigned ni_m_gate2_to_generic_gate(unsigned gate)
 	return 0;
 };
 
-static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
+static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,
 			       unsigned int *gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
-	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned gate;
+	unsigned int cidx = counter->counter_index;
+	unsigned int mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
+	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned int gate;
 
 	switch (gate_index) {
 	case 0:
@@ -1261,8 +1262,8 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		       unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
-	unsigned cidx = counter->counter_index;
-	unsigned status;
+	unsigned int cidx = counter->counter_index;
+	unsigned int status;
 
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1307,7 +1308,7 @@ static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 					    struct comedi_subdevice *s)
 {
 	struct ni_gpct *counter = s->private;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	unsigned int val;
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
@@ -1338,7 +1339,7 @@ int ni_tio_insn_read(struct comedi_device *dev,
 	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned int channel = CR_CHAN(insn->chanspec);
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
@@ -1358,11 +1359,10 @@ int ni_tio_insn_read(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_read);
 
-static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
+static unsigned int ni_tio_next_load_register(struct ni_gpct *counter)
 {
-	unsigned cidx = counter->counter_index;
-	const unsigned bits =
-		ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));
+	unsigned int cidx = counter->counter_index;
+	unsigned int bits = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));
 
 	return (bits & GI_NEXT_LOAD_SRC(cidx))
 			? NITIO_LOADB_REG(cidx)
@@ -1376,9 +1376,9 @@ int ni_tio_insn_write(struct comedi_device *dev,
 {
 	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned channel = CR_CHAN(insn->chanspec);
-	unsigned cidx = counter->counter_index;
-	unsigned load_reg;
+	unsigned int channel = CR_CHAN(insn->chanspec);
+	unsigned int cidx = counter->counter_index;
+	unsigned int load_reg;
 
 	if (insn->n < 1)
 		return 0;
@@ -1418,7 +1418,7 @@ EXPORT_SYMBOL_GPL(ni_tio_insn_write);
 void ni_tio_init_counter(struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 
 	ni_tio_reset_count_and_disarm(counter);
 

commit 5994e51b20600accd55e9aaeeb0b78e5ca038e19
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:45 2016 -0700

    staging: comedi: ni_tio: tidy up struct ni_gpct_device (*{write, read}_register)
    
    For aesthetics, rename these callbacks to simply read/write. Change the
    'unsigned' parameters to 'unsigned int'.
    
    This fixes a number of checkpatch.pl issues:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a225279cb83f..28bec3cfeef5 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -189,7 +189,7 @@ void ni_tio_write(struct ni_gpct *counter, unsigned int value,
 		  enum ni_gpct_register reg)
 {
 	if (reg < NITIO_NUM_REGS)
-		counter->counter_dev->write_register(counter, value, reg);
+		counter->counter_dev->write(counter, value, reg);
 }
 EXPORT_SYMBOL_GPL(ni_tio_write);
 
@@ -201,7 +201,7 @@ EXPORT_SYMBOL_GPL(ni_tio_write);
 unsigned int ni_tio_read(struct ni_gpct *counter, enum ni_gpct_register reg)
 {
 	if (reg < NITIO_NUM_REGS)
-		return counter->counter_dev->read_register(counter, reg);
+		return counter->counter_dev->read(counter, reg);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_read);
@@ -1455,17 +1455,17 @@ EXPORT_SYMBOL_GPL(ni_tio_init_counter);
 
 struct ni_gpct_device *
 ni_gpct_device_construct(struct comedi_device *dev,
-			 void (*write_register)(struct ni_gpct *counter,
-						unsigned bits,
-						enum ni_gpct_register reg),
-			 unsigned (*read_register)(struct ni_gpct *counter,
-						   enum ni_gpct_register reg),
+			 void (*write)(struct ni_gpct *counter,
+				       unsigned int value,
+				       enum ni_gpct_register reg),
+			 unsigned int (*read)(struct ni_gpct *counter,
+					      enum ni_gpct_register reg),
 			 enum ni_gpct_variant variant,
-			 unsigned num_counters)
+			 unsigned int num_counters)
 {
 	struct ni_gpct_device *counter_dev;
 	struct ni_gpct *counter;
-	unsigned i;
+	unsigned int i;
 
 	if (num_counters == 0)
 		return NULL;
@@ -1475,8 +1475,8 @@ ni_gpct_device_construct(struct comedi_device *dev,
 		return NULL;
 
 	counter_dev->dev = dev;
-	counter_dev->write_register = write_register;
-	counter_dev->read_register = read_register;
+	counter_dev->write = write;
+	counter_dev->read = read;
 	counter_dev->variant = variant;
 
 	spin_lock_init(&counter_dev->regs_lock);

commit 51f2e4eb2882209c84c2546b5a9b5c638b850f95
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:44 2016 -0700

    staging: comedi: ni_tio_internal: export {read, write)_register()
    
    Move these inline functions out of the header and export them instead.
    These functions have pretty generic names, rename them.
    
    Fix the checkpatch.pl issues:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    CHECK: Avoid crashing the kernel - try using WARN_ON & recovery code
           rather than BUG() or BUG_ON()
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 44dea4c4da20..a225279cb83f 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -179,11 +179,38 @@ static bool ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
 	}
 }
 
+/**
+ * ni_tio_write() - Write a TIO register using the driver provided callback.
+ * @counter: struct ni_gpct counter.
+ * @value: the value to write
+ * @reg: the register to write.
+ */
+void ni_tio_write(struct ni_gpct *counter, unsigned int value,
+		  enum ni_gpct_register reg)
+{
+	if (reg < NITIO_NUM_REGS)
+		counter->counter_dev->write_register(counter, value, reg);
+}
+EXPORT_SYMBOL_GPL(ni_tio_write);
+
+/**
+ * ni_tio_read() - Read a TIO register using the driver provided callback.
+ * @counter: struct ni_gpct counter.
+ * @reg: the register to read.
+ */
+unsigned int ni_tio_read(struct ni_gpct *counter, enum ni_gpct_register reg)
+{
+	if (reg < NITIO_NUM_REGS)
+		return counter->counter_dev->read_register(counter, reg);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ni_tio_read);
+
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
 	unsigned cidx = counter->counter_index;
 
-	write_register(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
+	ni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
@@ -240,8 +267,7 @@ static void ni_tio_set_bits_transient(struct ni_gpct *counter,
 		spin_lock_irqsave(&counter_dev->regs_lock, flags);
 		counter_dev->regs[reg] &= ~mask;
 		counter_dev->regs[reg] |= (value & mask);
-		write_register(counter, counter_dev->regs[reg] | transient,
-			       reg);
+		ni_tio_write(counter, counter_dev->regs[reg] | transient, reg);
 		mmiowb();
 		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
 	}
@@ -736,8 +762,8 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 	default:
 		return;
 	}
-	write_register(counter, counter_dev->regs[second_gate_reg],
-		       second_gate_reg);
+	ni_tio_write(counter, counter_dev->regs[second_gate_reg],
+		     second_gate_reg);
 }
 
 static int ni_tio_set_clock_src(struct ni_gpct *counter,
@@ -925,7 +951,7 @@ static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
 	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
 	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
-	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
+	ni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
 
@@ -949,7 +975,7 @@ static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
 	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
 	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
-	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
+	ni_tio_write(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
 
@@ -994,8 +1020,8 @@ int ni_tio_set_gate_src(struct ni_gpct *counter,
 
 		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
 			counter_dev->regs[gate2_reg] &= ~GI_GATE2_MODE;
-			write_register(counter, counter_dev->regs[gate2_reg],
-				       gate2_reg);
+			ni_tio_write(counter, counter_dev->regs[gate2_reg],
+				     gate2_reg);
 			return 0;
 		}
 		if (src & CR_INVERT)
@@ -1049,7 +1075,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 
 	counter_dev->regs[abz_reg] &= ~mask;
 	counter_dev->regs[abz_reg] |= (source << shift) & mask;
-	write_register(counter, counter_dev->regs[abz_reg], abz_reg);
+	ni_tio_write(counter, counter_dev->regs[abz_reg], abz_reg);
 	return 0;
 }
 
@@ -1248,7 +1274,7 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		return 0;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = 0;
-		status = read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
+		status = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));
 		if (status & GI_ARMED(cidx)) {
 			data[1] |= COMEDI_COUNTER_ARMED;
 			if (status & GI_COUNTING(cidx))
@@ -1297,9 +1323,9 @@ static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 	 * will be correct since the count value will definitely have latched
 	 * by then.
 	 */
-	val = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-	if (val != read_register(counter, NITIO_SW_SAVE_REG(cidx)))
-		val = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+	val = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));
+	if (val != ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx)))
+		val = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));
 
 	return val;
 }
@@ -1336,7 +1362,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
 	unsigned cidx = counter->counter_index;
 	const unsigned bits =
-		read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
+		ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));
 
 	return (bits & GI_NEXT_LOAD_SRC(cidx))
 			? NITIO_LOADB_REG(cidx)
@@ -1368,19 +1394,19 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		 * load register is already selected.
 		 */
 		load_reg = ni_tio_next_load_register(counter);
-		write_register(counter, data[0], load_reg);
+		ni_tio_write(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 					  0, 0, GI_LOAD);
 		/* restore load reg */
-		write_register(counter, counter_dev->regs[load_reg], load_reg);
+		ni_tio_write(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:
 		counter_dev->regs[NITIO_LOADA_REG(cidx)] = data[0];
-		write_register(counter, data[0], NITIO_LOADA_REG(cidx));
+		ni_tio_write(counter, data[0], NITIO_LOADA_REG(cidx));
 		break;
 	case 2:
 		counter_dev->regs[NITIO_LOADB_REG(cidx)] = data[0];
-		write_register(counter, data[0], NITIO_LOADB_REG(cidx));
+		ni_tio_write(counter, data[0], NITIO_LOADB_REG(cidx));
 		break;
 	default:
 		return -EINVAL;
@@ -1398,7 +1424,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 
 	/* initialize counter registers */
 	counter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;
-	write_register(counter, 0x0, NITIO_AUTO_INC_REG(cidx));
+	ni_tio_write(counter, 0x0, NITIO_AUTO_INC_REG(cidx));
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
 			~0, GI_SYNC_GATE);
@@ -1406,10 +1432,10 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
 
 	counter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;
-	write_register(counter, 0x0, NITIO_LOADA_REG(cidx));
+	ni_tio_write(counter, 0x0, NITIO_LOADA_REG(cidx));
 
 	counter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;
-	write_register(counter, 0x0, NITIO_LOADB_REG(cidx));
+	ni_tio_write(counter, 0x0, NITIO_LOADB_REG(cidx));
 
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);
 
@@ -1418,7 +1444,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 
 	if (ni_tio_has_gate2_registers(counter_dev)) {
 		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
-		write_register(counter, 0x0, NITIO_GATE2_REG(cidx));
+		ni_tio_write(counter, 0x0, NITIO_GATE2_REG(cidx));
 	}
 
 	ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);

commit 73b2d13607f075ff27abbf75d57320a8b9f82461
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:43 2016 -0700

    staging: comedi: ni_tio_internal: simplify ni_tio_counting_mode_registers_present()
    
    Only the e series gpct variant does not have counting mode registers.
    Simplfy this function. For aesthetics, return bool instead of int.
    
    This fixes the checkpatch.pl issues:
    CHECK: spaces preferred around that '*' (ctx:ExV)
    CHECK: Avoid crashing the kernel - try using WARN_ON & recovery code
           rather than BUG() or BUG_ON()
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 5343fce88ebf..44dea4c4da20 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -451,7 +451,7 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	unsigned mode;
 	uint64_t clock_period_ps;
 
-	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
+	if (!ni_tio_counting_mode_registers_present(counter_dev))
 		return;
 
 	mode = ni_tio_get_soft_copy(counter, counting_mode_reg);

commit f4e0331f3050f051ad0e8818635fc157cf354713
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:42 2016 -0700

    staging: comedi: ni_tio: export and fix ni_tio_set_bits()
    
    Move the inline function from the header and export it instead.
    
    Fix the checkpatch.pl issue:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    The 'unsigned' vars can safely be changed to 'unsigned int'.
    
    This allows moving ni_tio_set_bits_transient() into the driver and
    making it static.
    
    Fix the checkpatch.pl issue:
    CHECK: Avoid crashing the kernel - try using WARN_ON & recovery code
           rather than BUG() or BUG_ON()
    
    The BUG_ON() is overkill. All the drivers that call this function pass
    'register_index' values that are valid. Just check the 'register_index'
    before updating the software copy and writing the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index abbdad59552a..5343fce88ebf 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -228,6 +228,43 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 	return clock_period_ps;
 }
 
+static void ni_tio_set_bits_transient(struct ni_gpct *counter,
+				      enum ni_gpct_register reg,
+				      unsigned int mask, unsigned int value,
+				      unsigned int transient)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned long flags;
+
+	if (reg < NITIO_NUM_REGS) {
+		spin_lock_irqsave(&counter_dev->regs_lock, flags);
+		counter_dev->regs[reg] &= ~mask;
+		counter_dev->regs[reg] |= (value & mask);
+		write_register(counter, counter_dev->regs[reg] | transient,
+			       reg);
+		mmiowb();
+		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
+	}
+}
+
+/**
+ * ni_tio_set_bits() - Safely write a counter register.
+ * @counter: struct ni_gpct counter.
+ * @reg: the register to write.
+ * @mask: the bits to change.
+ * @value: the new bits value.
+ *
+ * Used to write to, and update the software copy, a register whose bits may
+ * be twiddled in interrupt context, or whose software copy may be read in
+ * interrupt context.
+ */
+void ni_tio_set_bits(struct ni_gpct *counter, enum ni_gpct_register reg,
+		     unsigned int mask, unsigned int value)
+{
+	ni_tio_set_bits_transient(counter, reg, mask, value, 0x0);
+}
+EXPORT_SYMBOL_GPL(ni_tio_set_bits);
+
 /**
  * ni_tio_get_soft_copy() - Safely read the software copy of a counter register.
  * @counter: struct ni_gpct counter.

commit 85bfafa81f8e422503d31d48ae2658675aad1929
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:41 2016 -0700

    staging: comedi: ni_tio: export and fix ni_tio_get_soft_copy()
    
    Move the inline function from the header and export it instead.
    
    For the checkpatch.pl issues:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    CHECK: Avoid crashing the kernel - try using WARN_ON & recovery code
           rather than BUG() or BUG_ON()
    
    The 'unsigned' vars can safely be changed to 'unsigned int'.
    
    The BUG_ON() is overkill. All the drivers that call this function pass
    'register_index' values that are valid. Just check the 'register_index'
    and return 0 if it's not valid.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 35596b1a075c..abbdad59552a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -228,6 +228,31 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 	return clock_period_ps;
 }
 
+/**
+ * ni_tio_get_soft_copy() - Safely read the software copy of a counter register.
+ * @counter: struct ni_gpct counter.
+ * @reg: the register to read.
+ *
+ * Used to get the software copy of a register whose bits might be modified
+ * in interrupt context, or whose software copy might need to be read in
+ * interrupt context.
+ */
+unsigned int ni_tio_get_soft_copy(const struct ni_gpct *counter,
+				  enum ni_gpct_register reg)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned int value = 0;
+	unsigned long flags;
+
+	if (reg < NITIO_NUM_REGS) {
+		spin_lock_irqsave(&counter_dev->regs_lock, flags);
+		value = counter_dev->regs[reg];
+		spin_unlock_irqrestore(&counter_dev->regs_lock, flags);
+	}
+	return value;
+}
+EXPORT_SYMBOL_GPL(ni_tio_get_soft_copy);
+
 static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;

commit c9813d50a514b451c4ad3acf1f5a400fff005c70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:40 2016 -0700

    staging: comedi: ni_tio: fix ni_tio_arm() params/vars
    
    As suggested by checkpatch.pl:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    The 'arm' parameter is really a true/false flag. For aesthetics,
    change it to a bool.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index abbc8b7a7092..35596b1a075c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -484,11 +484,11 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	return 0;
 }
 
-int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
+int ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned command_transient_bits = 0;
+	unsigned int cidx = counter->counter_index;
+	unsigned int command_transient_bits = 0;
 
 	if (arm) {
 		switch (start_trigger) {
@@ -502,8 +502,8 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 			break;
 		}
 		if (ni_tio_counting_mode_registers_present(counter_dev)) {
-			unsigned bits = 0;
-			unsigned sel_mask;
+			unsigned int bits = 0;
+			unsigned int sel_mask;
 
 			sel_mask = GI_HW_ARM_SEL_MASK(counter_dev->variant);
 
@@ -1180,9 +1180,9 @@ int ni_tio_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_SET_COUNTER_MODE:
 		return ni_tio_set_counter_mode(counter, data[1]);
 	case INSN_CONFIG_ARM:
-		return ni_tio_arm(counter, 1, data[1]);
+		return ni_tio_arm(counter, true, data[1]);
 	case INSN_CONFIG_DISARM:
-		ni_tio_arm(counter, 0, 0);
+		ni_tio_arm(counter, false, 0);
 		return 0;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = 0;

commit a4915d543f5bbb775a5fa6d012d33606ba22389b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:39 2016 -0700

    staging: comedi: ni_tio: fix ni_tio_set_gate_src() params/vars
    
    As suggested by checkpatch.pl:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 623fc6c7bff0..abbc8b7a7092 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -891,16 +891,16 @@ static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 	return 0;
 }
 
-int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
-			unsigned int gate_source)
+int ni_tio_set_gate_src(struct ni_gpct *counter,
+			unsigned int gate, unsigned int src)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned int chan = CR_CHAN(gate_source);
-	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned mode = 0;
+	unsigned int cidx = counter->counter_index;
+	unsigned int chan = CR_CHAN(src);
+	unsigned int gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned int mode = 0;
 
-	switch (gate_index) {
+	switch (gate) {
 	case 0:
 		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
@@ -908,9 +908,9 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 					GI_GATING_DISABLED);
 			return 0;
 		}
-		if (gate_source & CR_INVERT)
+		if (src & CR_INVERT)
 			mode |= GI_GATE_POL_INVERT;
-		if (gate_source & CR_EDGE)
+		if (src & CR_EDGE)
 			mode |= GI_RISING_EDGE_GATING;
 		else
 			mode |= GI_LEVEL_GATING;
@@ -921,9 +921,9 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			return ni_m_set_gate(counter, gate_source);
+			return ni_m_set_gate(counter, src);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_gate(counter, gate_source);
+			return ni_660x_set_gate(counter, src);
 		}
 		break;
 	case 1:
@@ -936,15 +936,15 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 				       gate2_reg);
 			return 0;
 		}
-		if (gate_source & CR_INVERT)
+		if (src & CR_INVERT)
 			counter_dev->regs[gate2_reg] |= GI_GATE2_POL_INVERT;
 		else
 			counter_dev->regs[gate2_reg] &= ~GI_GATE2_POL_INVERT;
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
-			return ni_m_set_gate2(counter, gate_source);
+			return ni_m_set_gate2(counter, src);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_gate2(counter, gate_source);
+			return ni_660x_set_gate2(counter, src);
 		default:
 			BUG();
 			break;

commit bed05b6c3434e62310c2e37ef234f02ce57cf74d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 22 11:10:40 2016 -0700

    staging: comedi: ni_tio: make ni_gpct_device_destroy() NULL pointer safe
    
    Modify the pointer check to make this function NULL pointer safe.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index b74e44ec521a..623fc6c7bff0 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1413,7 +1413,7 @@ EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
 
 void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 {
-	if (!counter_dev->counters)
+	if (!counter_dev)
 		return;
 	kfree(counter_dev->counters);
 	kfree(counter_dev);

commit abfe2196e03d7026776a0bfb94f93ae1227b23d0
Author: Geliang Tang <geliangtang@163.com>
Date:   Sun Oct 18 22:35:30 2015 +0800

    staging: comedi: make ni_tio_has_gate2_registers return boolean
    
    This patch makes ni_tio_has_gate2_registers return boolean, since
    this function only uses either one or zero as its return value.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index c20c51bef3e7..b74e44ec521a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -167,15 +167,15 @@ static inline unsigned GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
 	}
 }
 
-static int ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
+static bool ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 	default:
-		return 0;
+		return false;
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
-		return 1;
+		return true;
 	}
 }
 

commit 9ade47ab81f53008af52d25569458e0d02336bb6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:57 2015 +0000

    staging: comedi: ni_tio: change comedi "driver" comment to "module"
    
    This module contains support code for some other comedi drivers, but
    isn't a comedi driver itself, so doesn't need a comedi "driver" comment.
    To preserve the details in the original comment, change it into a comedi
    "module" comment (which I've just invented) by changing the "Driver:"
    line into a "Module:" line and removing the "Devices:" line.
    
    Also reformat it to use the usual block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 0525292c1d8b..c20c51bef3e7 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -16,29 +16,28 @@
 */
 
 /*
-Driver: ni_tio
-Description: National Instruments general purpose counters
-Devices:
-Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
-	Herman.Bruyninckx@mech.kuleuven.ac.be,
-	Wim.Meeussen@mech.kuleuven.ac.be,
-	Klaas.Gadeyne@mech.kuleuven.ac.be,
-	Frank Mori Hess <fmhess@users.sourceforge.net>
-Updated: Thu Nov 16 09:50:32 EST 2006
-Status: works
-
-This module is not used directly by end-users.  Rather, it
-is used by other drivers (for example ni_660x and ni_pcimio)
-to provide support for NI's general purpose counters.  It was
-originally based on the counter code from ni_660x.c and
-ni_mio_common.c.
-
-References:
-DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
-DAQ 6601/6602 User Manual (NI 322137B-01)
-340934b.pdf  DAQ-STC reference manual
+ * Module: ni_tio
+ * Description: National Instruments general purpose counters
+ * Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
+ *         Herman.Bruyninckx@mech.kuleuven.ac.be,
+ *         Wim.Meeussen@mech.kuleuven.ac.be,
+ *         Klaas.Gadeyne@mech.kuleuven.ac.be,
+ *         Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Updated: Thu Nov 16 09:50:32 EST 2006
+ * Status: works
+ *
+ * This module is not used directly by end-users.  Rather, it
+ * is used by other drivers (for example ni_660x and ni_pcimio)
+ * to provide support for NI's general purpose counters.  It was
+ * originally based on the counter code from ni_660x.c and
+ * ni_mio_common.c.
+ *
+ * References:
+ * DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
+ * DAQ 6601/6602 User Manual (NI 322137B-01)
+ * 340934b.pdf  DAQ-STC reference manual
+ */
 
-*/
 /*
 TODO:
 	Support use of both banks X and Y

commit 578dc59f20199c854507dd5f04839ffcaf655ce3
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jul 31 12:29:18 2014 +0300

    staging: comedi: ni_tio: remove some dead code
    
    These conditions can never be true because "i" is always one more than
    NI_660X_MAX_RTSI_CHAN after the loop.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index fb7b271ac2a3..0525292c1d8b 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1012,14 +1012,10 @@ static unsigned ni_660x_gate_to_generic_gate(unsigned gate)
 			if (gate == NI_660X_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= NI_660X_MAX_RTSI_CHAN)
-			break;
 		for (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {
 			if (gate == NI_660X_PIN_GATE_SEL(i))
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 		}
-		if (i <= NI_660X_MAX_GATE_PIN)
-			break;
 		BUG();
 		break;
 	}
@@ -1052,14 +1048,10 @@ static unsigned ni_m_gate_to_generic_gate(unsigned gate)
 			if (gate == NI_M_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= NI_M_MAX_RTSI_CHAN)
-			break;
 		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
 			if (gate == NI_M_PFI_GATE_SEL(i))
 				return NI_GPCT_PFI_GATE_SELECT(i);
 		}
-		if (i <= NI_M_MAX_PFI_CHAN)
-			break;
 		BUG();
 		break;
 	}
@@ -1088,14 +1080,10 @@ static unsigned ni_660x_gate2_to_generic_gate(unsigned gate)
 			if (gate == NI_660X_RTSI_GATE2_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= NI_660X_MAX_RTSI_CHAN)
-			break;
 		for (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {
 			if (gate == NI_660X_UD_PIN_GATE2_SEL(i))
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
 		}
-		if (i <= NI_660X_MAX_UP_DOWN_PIN)
-			break;
 		BUG();
 		break;
 	}

commit dc613766b70db497dd3db22b1b23d19fc753497d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:54 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Reset_Bit
    
    Convert this inline CamelCase function into a define.
    
    For aesthetics, move the new define so it is associated with the
    register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ccdf96ed6539..fb7b271ac2a3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -184,7 +184,7 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
 	unsigned cidx = counter->counter_index;
 
-	write_register(counter, Gi_Reset_Bit(cidx), NITIO_RESET_REG(cidx));
+	write_register(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,

commit 24a675c5130198fcf354325f108b4a62aa7575a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:53 2014 -0700

    staging: comedi: ni_tio: tidy up Gxx_Status_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 15364128c91f..ccdf96ed6539 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1200,9 +1200,9 @@ int ni_tio_insn_config(struct comedi_device *dev,
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = 0;
 		status = read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
-		if (status & Gi_Armed_Bit(cidx)) {
+		if (status & GI_ARMED(cidx)) {
 			data[1] |= COMEDI_COUNTER_ARMED;
-			if (status & Gi_Counting_Bit(cidx))
+			if (status & GI_COUNTING(cidx))
 				data[1] |= COMEDI_COUNTER_COUNTING;
 		}
 		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
@@ -1289,7 +1289,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	const unsigned bits =
 		read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
 
-	return (bits & Gi_Next_Load_Source_Bit(cidx))
+	return (bits & GI_NEXT_LOAD_SRC(cidx))
 			? NITIO_LOADB_REG(cidx)
 			: NITIO_LOADA_REG(cidx);
 }

commit 4359dcf3564500e37e5da4eba7b4bd7f1847096b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:52 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Second_Gate_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 7a37d2b4fff3..15364128c91f 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -267,8 +267,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
 	case NI_M_TIMEBASE_3_CLK:
-		if (counter_dev->regs[second_gate_reg] &
-		    Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)
 			clock_source =
 			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
 		else
@@ -278,8 +277,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
 	case NI_M_NEXT_GATE_CLK:
-		if (counter_dev->regs[second_gate_reg] &
-		    Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] & GI_SRC_SUBSEL)
 			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
@@ -666,12 +664,12 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 		/* Gi_Source_Subselect is zero */
 	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
 	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
-		counter_dev->regs[second_gate_reg] &= ~Gi_Source_Subselect_Bit;
+		counter_dev->regs[second_gate_reg] &= ~GI_SRC_SUBSEL;
 		break;
 		/* Gi_Source_Subselect is one */
 	case NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:
 	case NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:
-		counter_dev->regs[second_gate_reg] |= Gi_Source_Subselect_Bit;
+		counter_dev->regs[second_gate_reg] |= GI_SRC_SUBSEL;
 		break;
 		/* Gi_Source_Subselect doesn't matter */
 	default:
@@ -863,9 +861,9 @@ static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 			break;
 		return -EINVAL;
 	}
-	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Mode_Bit;
-	counter_dev->regs[gate2_reg] &= ~Gi_Second_Gate_Select_Mask;
-	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Select_Bits(gate2_sel);
+	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
+	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
+	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
 	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
@@ -887,9 +885,9 @@ static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 		gate2_sel = chan & 0x1f;
 		break;
 	}
-	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Mode_Bit;
-	counter_dev->regs[gate2_reg] &= ~Gi_Second_Gate_Select_Mask;
-	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Select_Bits(gate2_sel);
+	counter_dev->regs[gate2_reg] |= GI_GATE2_MODE;
+	counter_dev->regs[gate2_reg] &= ~GI_GATE2_SEL_MASK;
+	counter_dev->regs[gate2_reg] |= GI_GATE2_SEL(gate2_sel);
 	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
@@ -934,19 +932,15 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			return -EINVAL;
 
 		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
-			counter_dev->regs[gate2_reg] &=
-						~Gi_Second_Gate_Mode_Bit;
+			counter_dev->regs[gate2_reg] &= ~GI_GATE2_MODE;
 			write_register(counter, counter_dev->regs[gate2_reg],
 				       gate2_reg);
 			return 0;
 		}
-		if (gate_source & CR_INVERT) {
-			counter_dev->regs[gate2_reg] |=
-						Gi_Second_Gate_Polarity_Bit;
-		} else {
-			counter_dev->regs[gate2_reg] &=
-						~Gi_Second_Gate_Polarity_Bit;
-		}
+		if (gate_source & CR_INVERT)
+			counter_dev->regs[gate2_reg] |= GI_GATE2_POL_INVERT;
+		else
+			counter_dev->regs[gate2_reg] &= ~GI_GATE2_POL_INVERT;
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
 			return ni_m_set_gate2(counter, gate_source);
@@ -1157,14 +1151,12 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		break;
 	case 1:
 		if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED ||
-		    !(counter_dev->regs[gate2_reg] & Gi_Second_Gate_Mode_Bit)) {
+		    !(counter_dev->regs[gate2_reg] & GI_GATE2_MODE)) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		}
 
-		gate = counter_dev->regs[gate2_reg];
-		gate &= Gi_Second_Gate_Select_Mask;
-		gate >>= Gi_Second_Gate_Select_Shift;
+		gate = GI_BITS_TO_GATE2(counter_dev->regs[gate2_reg]);
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
@@ -1176,7 +1168,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			*gate_source = ni_660x_gate2_to_generic_gate(gate);
 			break;
 		}
-		if (counter_dev->regs[gate2_reg] & Gi_Second_Gate_Polarity_Bit)
+		if (counter_dev->regs[gate2_reg] & GI_GATE2_POL_INVERT)
 			*gate_source |= CR_INVERT;
 		/* second gate can't have edge/level mode set independently */
 		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)

commit 36d80f4a5460cae2e33b15568e572426ff976c70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:51 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Mode_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index bd6a21ea2ae4..7a37d2b4fff3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -441,18 +441,18 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	    NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
 	    NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
 
-	mode_reg_mask = mode_reg_direct_mask | Gi_Reload_Source_Switching_Bit;
+	mode_reg_mask = mode_reg_direct_mask | GI_RELOAD_SRC_SWITCHING;
 	mode_reg_values = mode & mode_reg_direct_mask;
 	switch (mode & NI_GPCT_RELOAD_SOURCE_MASK) {
 	case NI_GPCT_RELOAD_SOURCE_FIXED_BITS:
 		break;
 	case NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS:
-		mode_reg_values |= Gi_Reload_Source_Switching_Bit;
+		mode_reg_values |= GI_RELOAD_SRC_SWITCHING;
 		break;
 	case NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:
 		input_select_bits |= GI_GATE_SEL_LOAD_SRC;
-		mode_reg_mask |= Gi_Gating_Mode_Mask;
-		mode_reg_values |= Gi_Level_Gating_Bits;
+		mode_reg_mask |= GI_GATING_MODE_MASK;
+		mode_reg_values |= GI_LEVEL_GATING;
 		break;
 	default:
 		break;
@@ -907,18 +907,18 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	case 0:
 		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
-					Gi_Gating_Mode_Mask,
-					Gi_Gating_Disabled_Bits);
+					GI_GATING_MODE_MASK,
+					GI_GATING_DISABLED);
 			return 0;
 		}
 		if (gate_source & CR_INVERT)
-			mode |= Gi_Gate_Polarity_Bit;
+			mode |= GI_GATE_POL_INVERT;
 		if (gate_source & CR_EDGE)
-			mode |= Gi_Rising_Edge_Gating_Bits;
+			mode |= GI_RISING_EDGE_GATING;
 		else
-			mode |= Gi_Level_Gating_Bits;
+			mode |= GI_LEVEL_GATING;
 		ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
-				Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask,
+				GI_GATE_POL_INVERT | GI_GATING_MODE_MASK,
 				mode);
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
@@ -1132,7 +1132,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 
 	switch (gate_index) {
 	case 0:
-		if ((mode & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits) {
+		if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		}
@@ -1150,13 +1150,13 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			*gate_source = ni_660x_gate_to_generic_gate(gate);
 			break;
 		}
-		if (mode & Gi_Gate_Polarity_Bit)
+		if (mode & GI_GATE_POL_INVERT)
 			*gate_source |= CR_INVERT;
-		if ((mode & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
+		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
 			*gate_source |= CR_EDGE;
 		break;
 	case 1:
-		if ((mode & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits ||
+		if ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED ||
 		    !(counter_dev->regs[gate2_reg] & Gi_Second_Gate_Mode_Bit)) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
@@ -1179,7 +1179,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		if (counter_dev->regs[gate2_reg] & Gi_Second_Gate_Polarity_Bit)
 			*gate_source |= CR_INVERT;
 		/* second gate can't have edge/level mode set independently */
-		if ((mode & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
+		if ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)
 			*gate_source |= CR_EDGE;
 		break;
 	default:

commit c2c6c288f9bfa898b86c9c107af4227e022e18f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:50 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Input_Select_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 8df8468b4673..bd6a21ea2ae4 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -51,7 +51,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 
 /*
  * clock sources for ni e and m series boards,
- * get bits with Gi_Source_Select_Bits()
+ * get bits with GI_SRC_SEL()
  */
 #define NI_M_TIMEBASE_1_CLK		0x0	/* 20MHz */
 #define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
@@ -69,7 +69,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 
 /*
  * clock sources for ni_660x boards,
- * get bits with Gi_Source_Select_Bits()
+ * get bits with GI_SRC_SEL()
  */
 #define NI_660X_TIMEBASE_1_CLK		0x0	/* 20MHz */
 #define NI_660X_SRC_PIN_I_CLK		0x1
@@ -168,16 +168,6 @@ static inline unsigned GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
 	}
 }
 
-static inline unsigned Gi_Source_Select_Bits(unsigned source)
-{
-	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
-}
-
-static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
-{
-	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
-}
-
 static int ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
@@ -248,7 +238,7 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 	unsigned bits = 0;
 
 	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-	    Gi_Source_Polarity_Bit)
+	    GI_SRC_POL_INVERT)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
 	if (counting_mode_bits & GI_PRESCALE_X2(counter_dev->variant))
 		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
@@ -263,12 +253,13 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 	unsigned cidx = counter->counter_index;
 	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 	unsigned clock_source = 0;
+	unsigned src;
 	unsigned i;
-	const unsigned input_select =
-		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
 
-	switch (input_select) {
+	src = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,
+						  NITIO_INPUT_SEL_REG(cidx)));
+
+	switch (src) {
 	case NI_M_TIMEBASE_1_CLK:
 		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
 		break;
@@ -301,7 +292,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		break;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
-			if (input_select == NI_M_RTSI_CLK(i)) {
+			if (src == NI_M_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}
@@ -309,7 +300,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
-			if (input_select == NI_M_PFI_CLK(i)) {
+			if (src == NI_M_PFI_CLK(i)) {
 				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
 				break;
 			}
@@ -327,12 +318,13 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 {
 	unsigned clock_source = 0;
 	unsigned cidx = counter->counter_index;
-	const unsigned input_select =
-		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
+	unsigned src;
 	unsigned i;
 
-	switch (input_select) {
+	src = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,
+						  NITIO_INPUT_SEL_REG(cidx)));
+
+	switch (src) {
 	case NI_660X_TIMEBASE_1_CLK:
 		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
 		break;
@@ -356,7 +348,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (input_select == NI_660X_RTSI_CLK(i)) {
+			if (src == NI_660X_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}
@@ -364,7 +356,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
-			if (input_select == NI_660X_SRC_PIN_CLK(i)) {
+			if (src == NI_660X_SRC_PIN_CLK(i)) {
 				clock_source =
 				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
 				break;
@@ -458,7 +450,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		mode_reg_values |= Gi_Reload_Source_Switching_Bit;
 		break;
 	case NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:
-		input_select_bits |= Gi_Gate_Select_Load_Source_Bit;
+		input_select_bits |= GI_GATE_SEL_LOAD_SRC;
 		mode_reg_mask |= Gi_Gating_Mode_Mask;
 		mode_reg_values |= Gi_Level_Gating_Bits;
 		break;
@@ -485,12 +477,12 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 			GI_CNT_DIR(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT));
 
 	if (mode & NI_GPCT_OR_GATE_BIT)
-		input_select_bits |= Gi_Or_Gate_Bit;
+		input_select_bits |= GI_OR_GATE;
 	if (mode & NI_GPCT_INVERT_OUTPUT_BIT)
-		input_select_bits |= Gi_Output_Polarity_Bit;
+		input_select_bits |= GI_OUTPUT_POL_INVERT;
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
-			Gi_Output_Polarity_Bit, input_select_bits);
+			GI_GATE_SEL_LOAD_SRC | GI_OR_GATE |
+			GI_OUTPUT_POL_INVERT, input_select_bits);
 
 	return 0;
 }
@@ -598,7 +590,7 @@ static unsigned ni_660x_clk_src(unsigned int clock_source)
 		BUG();
 		break;
 	}
-	return Gi_Source_Select_Bits(ni_660x_clock);
+	return GI_SRC_SEL(ni_660x_clock);
 }
 
 static unsigned ni_m_clk_src(unsigned int clock_source)
@@ -658,7 +650,7 @@ static unsigned ni_m_clk_src(unsigned int clock_source)
 		ni_m_series_clock = 0;
 		break;
 	}
-	return Gi_Source_Select_Bits(ni_m_series_clock);
+	return GI_SRC_SEL(ni_m_series_clock);
 };
 
 static void ni_tio_set_source_subselect(struct ni_gpct *counter,
@@ -709,9 +701,9 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 		break;
 	}
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
-		bits |= Gi_Source_Polarity_Bit;
+		bits |= GI_SRC_POL_INVERT;
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit, bits);
+			GI_SRC_SEL_MASK | GI_SRC_POL_INVERT, bits);
 	ni_tio_set_source_subselect(counter, clock_source);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
@@ -786,7 +778,7 @@ static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 		return -EINVAL;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(gate_sel));
+			GI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));
 	return 0;
 }
 
@@ -828,7 +820,7 @@ static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 		return -EINVAL;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(gate_sel));
+			GI_GATE_SEL_MASK, GI_GATE_SEL(gate_sel));
 	return 0;
 }
 
@@ -1136,7 +1128,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	unsigned cidx = counter->counter_index;
 	unsigned mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
 	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
-	unsigned gate_sel;
+	unsigned gate;
 
 	switch (gate_index) {
 	case 0:
@@ -1145,19 +1137,17 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			return 0;
 		}
 
-		gate_sel = ni_tio_get_soft_copy(counter,
-						NITIO_INPUT_SEL_REG(cidx));
-		gate_sel &= Gi_Gate_Select_Mask;
-		gate_sel >>= Gi_Gate_Select_Shift;
+		gate = GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter,
+						NITIO_INPUT_SEL_REG(cidx)));
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source = ni_m_gate_to_generic_gate(gate_sel);
+			*gate_source = ni_m_gate_to_generic_gate(gate);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source = ni_660x_gate_to_generic_gate(gate_sel);
+			*gate_source = ni_660x_gate_to_generic_gate(gate);
 			break;
 		}
 		if (mode & Gi_Gate_Polarity_Bit)
@@ -1172,18 +1162,18 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			return 0;
 		}
 
-		gate_sel = counter_dev->regs[gate2_reg];
-		gate_sel &= Gi_Second_Gate_Select_Mask;
-		gate_sel >>= Gi_Second_Gate_Select_Shift;
+		gate = counter_dev->regs[gate2_reg];
+		gate &= Gi_Second_Gate_Select_Mask;
+		gate >>= Gi_Second_Gate_Select_Shift;
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source = ni_m_gate2_to_generic_gate(gate_sel);
+			*gate_source = ni_m_gate2_to_generic_gate(gate);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source = ni_660x_gate2_to_generic_gate(gate_sel);
+			*gate_source = ni_660x_gate2_to_generic_gate(gate);
 			break;
 		}
 		if (counter_dev->regs[gate2_reg] & Gi_Second_Gate_Polarity_Bit)

commit b9a09764eeb75c3b38f99d5d4154fcb68155e65a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:48 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Command_Reg_Bits
    
    Convert this enum into defines and rename all the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with the
    register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1baad07fa44b..8df8468b4673 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -481,10 +481,8 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
-	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-			Gi_Up_Down_Mask,
-			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
-			Gi_Up_Down_Shift);
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_CNT_DIR_MASK,
+			GI_CNT_DIR(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT));
 
 	if (mode & NI_GPCT_OR_GATE_BIT)
 		input_select_bits |= Gi_Or_Gate_Bit;
@@ -506,10 +504,10 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 	if (arm) {
 		switch (start_trigger) {
 		case NI_GPCT_ARM_IMMEDIATE:
-			command_transient_bits |= Gi_Arm_Bit;
+			command_transient_bits |= GI_ARM;
 			break;
 		case NI_GPCT_ARM_PAIRED_IMMEDIATE:
-			command_transient_bits |= Gi_Arm_Bit | Gi_Arm_Copy_Bit;
+			command_transient_bits |= GI_ARM | GI_ARM_COPY;
 			break;
 		default:
 			break;
@@ -543,7 +541,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 					GI_HW_ARM_ENA | sel_mask, bits);
 		}
 	} else {
-		command_transient_bits |= Gi_Disarm_Bit;
+		command_transient_bits |= GI_DISARM;
 	}
 	ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 				  0, 0, command_transient_bits);
@@ -1255,9 +1253,9 @@ static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 	unsigned cidx = counter->counter_index;
 	unsigned int val;
 
-	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), Gi_Save_Trace_Bit, 0);
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-			Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
+			GI_SAVE_TRACE, GI_SAVE_TRACE);
 
 	/*
 	 * The count doesn't get latched until the next clock edge, so it is
@@ -1341,7 +1339,7 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
-					  0, 0, Gi_Load_Bit);
+					  0, 0, GI_LOAD);
 		/* restore load reg */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
@@ -1372,7 +1370,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 	write_register(counter, 0x0, NITIO_AUTO_INC_REG(cidx));
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-			~0, Gi_Synchronize_Gate_Bit);
+			~0, GI_SYNC_GATE);
 
 	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
 

commit ed40487163dd7cf0e2e9982e8cbb5427be1e1779
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:47 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Counting_Mode_Reg_Bits
    
    Convert this enum into defines and rename all the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with the
    register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6ed14dfa142a..1baad07fa44b 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -116,59 +116,55 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 #define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
 #define NI_660X_MAX_UP_DOWN_PIN		7
 
-static inline enum Gi_Counting_Mode_Reg_Bits
-Gi_Alternate_Sync_Bit(enum ni_gpct_variant variant)
+static inline unsigned GI_ALT_SYNC(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 	default:
 		return 0;
 	case ni_gpct_variant_m_series:
-		return Gi_M_Series_Alternate_Sync_Bit;
+		return GI_M_ALT_SYNC;
 	case ni_gpct_variant_660x:
-		return Gi_660x_Alternate_Sync_Bit;
+		return GI_660X_ALT_SYNC;
 	}
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits
-Gi_Prescale_X2_Bit(enum ni_gpct_variant variant)
+static inline unsigned GI_PRESCALE_X2(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 	default:
 		return 0;
 	case ni_gpct_variant_m_series:
-		return Gi_M_Series_Prescale_X2_Bit;
+		return GI_M_PRESCALE_X2;
 	case ni_gpct_variant_660x:
-		return Gi_660x_Prescale_X2_Bit;
+		return GI_660X_PRESCALE_X2;
 	}
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits
-Gi_Prescale_X8_Bit(enum ni_gpct_variant variant)
+static inline unsigned GI_PRESCALE_X8(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 	default:
 		return 0;
 	case ni_gpct_variant_m_series:
-		return Gi_M_Series_Prescale_X8_Bit;
+		return GI_M_PRESCALE_X8;
 	case ni_gpct_variant_660x:
-		return Gi_660x_Prescale_X8_Bit;
+		return GI_660X_PRESCALE_X8;
 	}
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits
-Gi_HW_Arm_Select_Mask(enum ni_gpct_variant variant)
+static inline unsigned GI_HW_ARM_SEL_MASK(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 	default:
 		return 0;
 	case ni_gpct_variant_m_series:
-		return Gi_M_Series_HW_Arm_Select_Mask;
+		return GI_M_HW_ARM_SEL_MASK;
 	case ni_gpct_variant_660x:
-		return Gi_660x_HW_Arm_Select_Mask;
+		return GI_660X_HW_ARM_SEL_MASK;
 	}
 }
 
@@ -254,9 +250,9 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
 	    Gi_Source_Polarity_Bit)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
-	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
+	if (counting_mode_bits & GI_PRESCALE_X2(counter_dev->variant))
 		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
-	if (counting_mode_bits & Gi_Prescale_X8_Bit(counter_dev->variant))
+	if (counting_mode_bits & GI_PRESCALE_X8(counter_dev->variant))
 		bits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;
 	return bits;
 }
@@ -401,17 +397,18 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	unsigned cidx = counter->counter_index;
 	const unsigned counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
 	static const uint64_t min_normal_sync_period_ps = 25000;
+	unsigned mode;
 	uint64_t clock_period_ps;
 
 	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
 		return;
 
-	switch (ni_tio_get_soft_copy(counter, counting_mode_reg) &
-		Gi_Counting_Mode_Mask) {
-	case Gi_Counting_Mode_QuadratureX1_Bits:
-	case Gi_Counting_Mode_QuadratureX2_Bits:
-	case Gi_Counting_Mode_QuadratureX4_Bits:
-	case Gi_Counting_Mode_Sync_Source_Bits:
+	mode = ni_tio_get_soft_copy(counter, counting_mode_reg);
+	switch (mode & GI_CNT_MODE_MASK) {
+	case GI_CNT_MODE_QUADX1:
+	case GI_CNT_MODE_QUADX2:
+	case GI_CNT_MODE_QUADX4:
+	case GI_CNT_MODE_SYNC_SRC:
 		force_alt_sync = 1;
 		break;
 	default:
@@ -429,11 +426,11 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	if (force_alt_sync ||
 	    (clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {
 		ni_tio_set_bits(counter, counting_mode_reg,
-				Gi_Alternate_Sync_Bit(counter_dev->variant),
-				Gi_Alternate_Sync_Bit(counter_dev->variant));
+				GI_ALT_SYNC(counter_dev->variant),
+				GI_ALT_SYNC(counter_dev->variant));
 	} else {
 		ni_tio_set_bits(counter, counting_mode_reg,
-				Gi_Alternate_Sync_Bit(counter_dev->variant),
+				GI_ALT_SYNC(counter_dev->variant),
 				0x0);
 	}
 }
@@ -472,19 +469,15 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
-		unsigned counting_mode_bits = 0;
-
-		counting_mode_bits |=
-		    (mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
-		    Gi_Counting_Mode_Mask;
-		counting_mode_bits |=
-		    ((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
-		     Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
+		unsigned bits = 0;
+
+		bits |= GI_CNT_MODE(mode >> NI_GPCT_COUNTING_MODE_SHIFT);
+		bits |= GI_INDEX_PHASE((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT));
 		if (mode & NI_GPCT_INDEX_ENABLE_BIT)
-			counting_mode_bits |= Gi_Index_Mode_Bit;
+			bits |= GI_INDEX_MODE;
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
-				Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
-				Gi_Index_Mode_Bit, counting_mode_bits);
+				GI_CNT_MODE_MASK | GI_INDEX_PHASE_MASK |
+				GI_INDEX_MODE, bits);
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
@@ -522,7 +515,10 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 			break;
 		}
 		if (ni_tio_counting_mode_registers_present(counter_dev)) {
-			unsigned counting_mode_bits = 0;
+			unsigned bits = 0;
+			unsigned sel_mask;
+
+			sel_mask = GI_HW_ARM_SEL_MASK(counter_dev->variant);
 
 			switch (start_trigger) {
 			case NI_GPCT_ARM_IMMEDIATE:
@@ -535,25 +531,16 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 					 * bits so we can figure out what
 					 * select later
 					 */
-					unsigned hw_arm_select_bits =
-					    (start_trigger <<
-					     Gi_HW_Arm_Select_Shift) &
-					    Gi_HW_Arm_Select_Mask
-					    (counter_dev->variant);
-
-					counting_mode_bits |=
-					    Gi_HW_Arm_Enable_Bit |
-					    hw_arm_select_bits;
+					bits |= GI_HW_ARM_ENA |
+						(GI_HW_ARM_SEL(start_trigger) &
+						 sel_mask);
 				} else {
 					return -EINVAL;
 				}
 				break;
 			}
 			ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
-					Gi_HW_Arm_Select_Mask
-					(counter_dev->variant) |
-					Gi_HW_Arm_Enable_Bit,
-					counting_mode_bits);
+					GI_HW_ARM_ENA | sel_mask, bits);
 		}
 	} else {
 		command_transient_bits |= Gi_Disarm_Bit;
@@ -735,17 +722,17 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 		case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
 			break;
 		case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
-			bits |= Gi_Prescale_X2_Bit(counter_dev->variant);
+			bits |= GI_PRESCALE_X2(counter_dev->variant);
 			break;
 		case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
-			bits |= Gi_Prescale_X8_Bit(counter_dev->variant);
+			bits |= GI_PRESCALE_X8(counter_dev->variant);
 			break;
 		default:
 			return -EINVAL;
 		}
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
-				Gi_Prescale_X2_Bit(counter_dev->variant) |
-				Gi_Prescale_X8_Bit(counter_dev->variant), bits);
+				GI_PRESCALE_X2(counter_dev->variant) |
+				GI_PRESCALE_X8(counter_dev->variant), bits);
 	}
 	counter->clock_period_ps = period_ns * 1000;
 	ni_tio_set_sync_mode(counter, 0);

commit 56bd1ac7089872e9f282a83ed73d8e8dba48f0b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:46 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_read_sw_save_reg()
    
    Remove the need for some of the local variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f9f632014511..6ed14dfa142a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1266,9 +1266,7 @@ static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 {
 	struct ni_gpct *counter = s->private;
 	unsigned cidx = counter->counter_index;
-	unsigned int first_read;
-	unsigned int second_read;
-	unsigned int correct_read;
+	unsigned int val;
 
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), Gi_Save_Trace_Bit, 0);
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
@@ -1283,14 +1281,11 @@ static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
 	 * will be correct since the count value will definitely have latched
 	 * by then.
 	 */
-	first_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-	second_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-	if (first_read != second_read)
-		correct_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-	else
-		correct_read = first_read;
-
-	return correct_read;
+	val = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+	if (val != read_register(counter, NITIO_SW_SAVE_REG(cidx)))
+		val = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+
+	return val;
 }
 
 int ni_tio_insn_read(struct comedi_device *dev,

commit 0748e36265f7a8908c91740a2f538e8dffee3bbc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:05 2014 -0700

    staging: comedi: ni_tio: convert printk to pr_err
    
    Convert the printk(KERN_ERR ...) in ni_m_clk_src() to a pr_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 036748299bf6..f9f632014511 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -667,7 +667,7 @@ static unsigned ni_m_clk_src(unsigned int clock_source)
 		}
 		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
-		printk(KERN_ERR "invalid clock source 0x%lx\n",
+		pr_err("invalid clock source 0x%lx\n",
 		       (unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;

commit 099286dc307e6395990d40bf7a87838274c3ea84
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:04 2014 -0700

    staging: comedi: ni_tio: remove forward declarations
    
    Move some of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ebfc7240604b..036748299bf6 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -116,10 +116,6 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 #define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
 #define NI_660X_MAX_UP_DOWN_PIN		7
 
-static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-				       unsigned generic_clock_source);
-static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
-
 static inline enum Gi_Counting_Mode_Reg_Bits
 Gi_Alternate_Sync_Bit(enum ni_gpct_variant variant)
 {
@@ -205,6 +201,200 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 	write_register(counter, Gi_Reset_Bit(cidx), NITIO_RESET_REG(cidx));
 }
 
+static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
+				       unsigned generic_clock_source)
+{
+	uint64_t clock_period_ps;
+
+	switch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {
+	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
+		clock_period_ps = 50000;
+		break;
+	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
+		clock_period_ps = 10000000;
+		break;
+	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
+		clock_period_ps = 12500;
+		break;
+	case NI_GPCT_PXI10_CLOCK_SRC_BITS:
+		clock_period_ps = 100000;
+		break;
+	default:
+		/*
+		 * clock period is specified by user with prescaling
+		 * already taken into account.
+		 */
+		return counter->clock_period_ps;
+	}
+
+	switch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {
+	case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
+		break;
+	case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
+		clock_period_ps *= 2;
+		break;
+	case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
+		clock_period_ps *= 8;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return clock_period_ps;
+}
+
+static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
+	const unsigned counting_mode_bits =
+		ni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));
+	unsigned bits = 0;
+
+	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+	    Gi_Source_Polarity_Bit)
+		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
+	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
+		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
+	if (counting_mode_bits & Gi_Prescale_X8_Bit(counter_dev->variant))
+		bits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;
+	return bits;
+}
+
+static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
+	unsigned clock_source = 0;
+	unsigned i;
+	const unsigned input_select =
+		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
+
+	switch (input_select) {
+	case NI_M_TIMEBASE_1_CLK:
+		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
+		break;
+	case NI_M_TIMEBASE_2_CLK:
+		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
+		break;
+	case NI_M_TIMEBASE_3_CLK:
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
+			clock_source =
+			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
+		else
+			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
+		break;
+	case NI_M_LOGIC_LOW_CLK:
+		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
+		break;
+	case NI_M_NEXT_GATE_CLK:
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
+			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
+		else
+			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
+		break;
+	case NI_M_PXI10_CLK:
+		clock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;
+		break;
+	case NI_M_NEXT_TC_CLK:
+		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
+		break;
+	default:
+		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
+			if (input_select == NI_M_RTSI_CLK(i)) {
+				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= NI_M_MAX_RTSI_CHAN)
+			break;
+		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
+			if (input_select == NI_M_PFI_CLK(i)) {
+				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= NI_M_MAX_PFI_CHAN)
+			break;
+		BUG();
+		break;
+	}
+	clock_source |= ni_tio_clock_src_modifiers(counter);
+	return clock_source;
+}
+
+static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
+{
+	unsigned clock_source = 0;
+	unsigned cidx = counter->counter_index;
+	const unsigned input_select =
+		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
+	unsigned i;
+
+	switch (input_select) {
+	case NI_660X_TIMEBASE_1_CLK:
+		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_TIMEBASE_2_CLK:
+		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_TIMEBASE_3_CLK:
+		clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_LOGIC_LOW_CLK:
+		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_SRC_PIN_I_CLK:
+		clock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_NEXT_GATE_CLK:
+		clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
+		break;
+	case NI_660X_NEXT_TC_CLK:
+		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
+		break;
+	default:
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
+			if (input_select == NI_660X_RTSI_CLK(i)) {
+				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= NI_660X_MAX_RTSI_CHAN)
+			break;
+		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
+			if (input_select == NI_660X_SRC_PIN_CLK(i)) {
+				clock_source =
+				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= NI_660X_MAX_SRC_PIN)
+			break;
+		BUG();
+		break;
+	}
+	clock_source |= ni_tio_clock_src_modifiers(counter);
+	return clock_source;
+}
+
+static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
+{
+	switch (counter->counter_dev->variant) {
+	case ni_gpct_variant_e_series:
+	case ni_gpct_variant_m_series:
+	default:
+		return ni_m_series_clock_src_select(counter);
+	case ni_gpct_variant_660x:
+		return ni_660x_clock_src_select(counter);
+	}
+}
+
 static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
@@ -562,200 +752,6 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	return 0;
 }
 
-static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
-{
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned counting_mode_bits =
-		ni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));
-	unsigned bits = 0;
-
-	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-	    Gi_Source_Polarity_Bit)
-		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
-	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
-		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
-	if (counting_mode_bits & Gi_Prescale_X8_Bit(counter_dev->variant))
-		bits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;
-	return bits;
-}
-
-static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
-{
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
-	unsigned clock_source = 0;
-	unsigned i;
-	const unsigned input_select =
-		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
-
-	switch (input_select) {
-	case NI_M_TIMEBASE_1_CLK:
-		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
-		break;
-	case NI_M_TIMEBASE_2_CLK:
-		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
-		break;
-	case NI_M_TIMEBASE_3_CLK:
-		if (counter_dev->regs[second_gate_reg] &
-		    Gi_Source_Subselect_Bit)
-			clock_source =
-			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
-		else
-			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
-		break;
-	case NI_M_LOGIC_LOW_CLK:
-		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
-		break;
-	case NI_M_NEXT_GATE_CLK:
-		if (counter_dev->regs[second_gate_reg] &
-		    Gi_Source_Subselect_Bit)
-			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
-		else
-			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
-		break;
-	case NI_M_PXI10_CLK:
-		clock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;
-		break;
-	case NI_M_NEXT_TC_CLK:
-		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
-		break;
-	default:
-		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
-			if (input_select == NI_M_RTSI_CLK(i)) {
-				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
-				break;
-			}
-		}
-		if (i <= NI_M_MAX_RTSI_CHAN)
-			break;
-		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
-			if (input_select == NI_M_PFI_CLK(i)) {
-				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
-				break;
-			}
-		}
-		if (i <= NI_M_MAX_PFI_CHAN)
-			break;
-		BUG();
-		break;
-	}
-	clock_source |= ni_tio_clock_src_modifiers(counter);
-	return clock_source;
-}
-
-static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
-{
-	unsigned clock_source = 0;
-	unsigned cidx = counter->counter_index;
-	const unsigned input_select =
-		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
-	unsigned i;
-
-	switch (input_select) {
-	case NI_660X_TIMEBASE_1_CLK:
-		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_TIMEBASE_2_CLK:
-		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_TIMEBASE_3_CLK:
-		clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_LOGIC_LOW_CLK:
-		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_SRC_PIN_I_CLK:
-		clock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_NEXT_GATE_CLK:
-		clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
-		break;
-	case NI_660X_NEXT_TC_CLK:
-		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
-		break;
-	default:
-		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (input_select == NI_660X_RTSI_CLK(i)) {
-				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
-				break;
-			}
-		}
-		if (i <= NI_660X_MAX_RTSI_CHAN)
-			break;
-		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
-			if (input_select == NI_660X_SRC_PIN_CLK(i)) {
-				clock_source =
-				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
-				break;
-			}
-		}
-		if (i <= NI_660X_MAX_SRC_PIN)
-			break;
-		BUG();
-		break;
-	}
-	clock_source |= ni_tio_clock_src_modifiers(counter);
-	return clock_source;
-}
-
-static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
-{
-	switch (counter->counter_dev->variant) {
-	case ni_gpct_variant_e_series:
-	case ni_gpct_variant_m_series:
-	default:
-		return ni_m_series_clock_src_select(counter);
-	case ni_gpct_variant_660x:
-		return ni_660x_clock_src_select(counter);
-	}
-}
-
-static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-				       unsigned generic_clock_source)
-{
-	uint64_t clock_period_ps;
-
-	switch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {
-	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
-		clock_period_ps = 50000;
-		break;
-	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
-		clock_period_ps = 10000000;
-		break;
-	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
-		clock_period_ps = 12500;
-		break;
-	case NI_GPCT_PXI10_CLOCK_SRC_BITS:
-		clock_period_ps = 100000;
-		break;
-	default:
-		/*
-		 * clock period is specified by user with prescaling
-		 * already taken into account.
-		 */
-		return counter->clock_period_ps;
-	}
-
-	switch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {
-	case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
-		break;
-	case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
-		clock_period_ps *= 2;
-		break;
-	case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
-		clock_period_ps *= 8;
-		break;
-	default:
-		BUG();
-		break;
-	}
-	return clock_period_ps;
-}
-
 static void ni_tio_get_clock_src(struct ni_gpct *counter,
 				 unsigned int *clock_source,
 				 unsigned int *period_ns)

commit 3e90b1c7ebe9abbc7f49abff0bfbb6513f30c00b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:03 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_set_clock_src() and helpers
    
    Do some renaming of local vars, etc. to tidy up the ugly line breaks
    to improve the readability of the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 2f7e8410226c..ebfc7240604b 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -374,7 +374,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 }
 EXPORT_SYMBOL_GPL(ni_tio_arm);
 
-static unsigned ni_660x_source_select_bits(unsigned int clock_source)
+static unsigned ni_660x_clk_src(unsigned int clock_source)
 {
 	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned ni_660x_clock;
@@ -426,7 +426,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 	return Gi_Source_Select_Bits(ni_660x_clock);
 }
 
-static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
+static unsigned ni_m_clk_src(unsigned int clock_source)
 {
 	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned ni_m_series_clock;
@@ -520,52 +520,44 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	unsigned input_select_bits = 0;
-	static const uint64_t pico_per_nano = 1000;
+	unsigned bits = 0;
 
-/*FIXME: validate clock source */
+	/* FIXME: validate clock source */
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_660x:
-		input_select_bits |= ni_660x_source_select_bits(clock_source);
+		bits |= ni_660x_clk_src(clock_source);
 		break;
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 	default:
-		input_select_bits |=
-		    ni_m_series_source_select_bits(clock_source);
+		bits |= ni_m_clk_src(clock_source);
 		break;
 	}
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
-		input_select_bits |= Gi_Source_Polarity_Bit;
+		bits |= Gi_Source_Polarity_Bit;
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
-			input_select_bits);
+			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit, bits);
 	ni_tio_set_source_subselect(counter, clock_source);
-	if (ni_tio_counting_mode_registers_present(counter_dev)) {
-		const unsigned prescaling_mode =
-		    clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
-		unsigned counting_mode_bits = 0;
 
-		switch (prescaling_mode) {
+	if (ni_tio_counting_mode_registers_present(counter_dev)) {
+		bits = 0;
+		switch (clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {
 		case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
 			break;
 		case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
-			counting_mode_bits |=
-			    Gi_Prescale_X2_Bit(counter_dev->variant);
+			bits |= Gi_Prescale_X2_Bit(counter_dev->variant);
 			break;
 		case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
-			counting_mode_bits |=
-			    Gi_Prescale_X8_Bit(counter_dev->variant);
+			bits |= Gi_Prescale_X8_Bit(counter_dev->variant);
 			break;
 		default:
 			return -EINVAL;
 		}
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 				Gi_Prescale_X2_Bit(counter_dev->variant) |
-				Gi_Prescale_X8_Bit(counter_dev->variant),
-				counting_mode_bits);
+				Gi_Prescale_X8_Bit(counter_dev->variant), bits);
 	}
-	counter->clock_period_ps = pico_per_nano * period_ns;
+	counter->clock_period_ps = period_ns * 1000;
 	ni_tio_set_sync_mode(counter, 0);
 	return 0;
 }

commit f68d10c428b99b747fed440ac73602bbdafc89a4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:02 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_get_clock_src()
    
    Remove the static const local variable and add a blank line after
    the declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 33ffd17cd097..2f7e8410226c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -768,11 +768,11 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 				 unsigned int *clock_source,
 				 unsigned int *period_ns)
 {
-	static const unsigned pico_per_nano = 1000;
 	uint64_t temp64;
+
 	*clock_source = ni_tio_generic_clock_src_select(counter);
 	temp64 = ni_tio_clock_period_ps(counter, *clock_source);
-	do_div(temp64, pico_per_nano);
+	do_div(temp64, 1000);	/* ps to ns */
 	*period_ns = temp64;
 }
 

commit 7d9e68d3f4e597c8d8b0cb698d7753720f414820
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:01 2014 -0700

    staging: comedi: ni_tio: absorb ni_tio_set_first_gate_modifiers()
    
    This function is only called by ni_tio_set_gate_src(). For aesthetics,
    absorb the code into that function..
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index eb5458240639..33ffd17cd097 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -776,23 +776,6 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 	*period_ns = temp64;
 }
 
-static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
-					    unsigned int gate_source)
-{
-	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
-	unsigned cidx = counter->counter_index;
-	unsigned mode_values = 0;
-
-	if (gate_source & CR_INVERT)
-		mode_values |= Gi_Gate_Polarity_Bit;
-	if (gate_source & CR_EDGE)
-		mode_values |= Gi_Rising_Edge_Gating_Bits;
-	else
-		mode_values |= Gi_Level_Gating_Bits;
-	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
-			mode_mask, mode_values);
-}
-
 static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
@@ -953,6 +936,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	unsigned cidx = counter->counter_index;
 	unsigned int chan = CR_CHAN(gate_source);
 	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned mode = 0;
 
 	switch (gate_index) {
 	case 0:
@@ -962,7 +946,15 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 					Gi_Gating_Disabled_Bits);
 			return 0;
 		}
-		ni_tio_set_first_gate_modifiers(counter, gate_source);
+		if (gate_source & CR_INVERT)
+			mode |= Gi_Gate_Polarity_Bit;
+		if (gate_source & CR_EDGE)
+			mode |= Gi_Rising_Edge_Gating_Bits;
+		else
+			mode |= Gi_Level_Gating_Bits;
+		ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
+				Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask,
+				mode);
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:

commit d54bb5a7f766bbcee530cd9e241890711eba6c07
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:15:00 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_set_gate_src() and helpers
    
    Do some renaming of local vars, parameters, etc. to tidy up the ugly
    line breaks to improve the readability of the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1982a259a872..eb5458240639 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -793,8 +793,7 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 			mode_mask, mode_values);
 }
 
-static int ni_660x_set_first_gate(struct ni_gpct *counter,
-				  unsigned int gate_source)
+static int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
 	unsigned cidx = counter->counter_index;
@@ -835,8 +834,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 	return 0;
 }
 
-static int ni_m_series_set_first_gate(struct ni_gpct *counter,
-				      unsigned int gate_source)
+static int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	unsigned int chan = CR_CHAN(gate_source);
 	unsigned cidx = counter->counter_index;
@@ -878,8 +876,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 	return 0;
 }
 
-static int ni_660x_set_second_gate(struct ni_gpct *counter,
-				   unsigned int gate_source)
+static int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
@@ -925,33 +922,27 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 	return 0;
 }
 
-static int ni_m_series_set_second_gate(struct ni_gpct *counter,
-				       unsigned int gate_source)
+static int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
-	const unsigned selected_second_gate = CR_CHAN(gate_source);
-	/* bits of second_gate that may be meaningful to second gate register */
-	static const unsigned selected_second_gate_mask = 0x1f;
-	unsigned ni_m_series_second_gate_select;
+	unsigned int chan = CR_CHAN(gate_source);
+	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned gate2_sel;
 
 	/*
 	 * FIXME: We don't know what the m-series second gate codes are,
 	 * so we'll just pass the bits through for now.
 	 */
-	switch (selected_second_gate) {
+	switch (chan) {
 	default:
-		ni_m_series_second_gate_select =
-		    selected_second_gate & selected_second_gate_mask;
+		gate2_sel = chan & 0x1f;
 		break;
 	}
-	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
-	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
-	counter_dev->regs[second_gate_reg] |=
-	    Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
-	write_register(counter, counter_dev->regs[second_gate_reg],
-		       second_gate_reg);
+	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Mode_Bit;
+	counter_dev->regs[gate2_reg] &= ~Gi_Second_Gate_Select_Mask;
+	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Select_Bits(gate2_sel);
+	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
 
@@ -960,11 +951,12 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
+	unsigned int chan = CR_CHAN(gate_source);
+	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
 
 	switch (gate_index) {
 	case 0:
-		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
+		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
 					Gi_Gating_Mode_Mask,
 					Gi_Gating_Disabled_Bits);
@@ -975,36 +967,34 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			return ni_m_series_set_first_gate(counter, gate_source);
+			return ni_m_set_gate(counter, gate_source);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_first_gate(counter, gate_source);
+			return ni_660x_set_gate(counter, gate_source);
 		}
 		break;
 	case 1:
 		if (!ni_tio_has_gate2_registers(counter_dev))
 			return -EINVAL;
 
-		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
-			counter_dev->regs[second_gate_reg] &=
-			    ~Gi_Second_Gate_Mode_Bit;
-			write_register(counter,
-				       counter_dev->regs[second_gate_reg],
-				       second_gate_reg);
+		if (chan == NI_GPCT_DISABLED_GATE_SELECT) {
+			counter_dev->regs[gate2_reg] &=
+						~Gi_Second_Gate_Mode_Bit;
+			write_register(counter, counter_dev->regs[gate2_reg],
+				       gate2_reg);
 			return 0;
 		}
 		if (gate_source & CR_INVERT) {
-			counter_dev->regs[second_gate_reg] |=
-			    Gi_Second_Gate_Polarity_Bit;
+			counter_dev->regs[gate2_reg] |=
+						Gi_Second_Gate_Polarity_Bit;
 		} else {
-			counter_dev->regs[second_gate_reg] &=
-			    ~Gi_Second_Gate_Polarity_Bit;
+			counter_dev->regs[gate2_reg] &=
+						~Gi_Second_Gate_Polarity_Bit;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
-			return ni_m_series_set_second_gate(counter,
-							   gate_source);
+			return ni_m_set_gate2(counter, gate_source);
 		case ni_gpct_variant_660x:
-			return ni_660x_set_second_gate(counter, gate_source);
+			return ni_660x_set_gate2(counter, gate_source);
 		default:
 			BUG();
 			break;

commit bf4ec095b38b108b97ff5e1a37416a5575378e5d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:59 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_set_other_src()
    
    Invert the counter_dev->variant test to reduce the indent level of
    this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a149a73513eb..1982a259a872 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1022,35 +1022,33 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
+	unsigned int abz_reg, shift, mask;
 
-	if (counter_dev->variant == ni_gpct_variant_m_series) {
-		unsigned int abz_reg, shift, mask;
+	if (counter_dev->variant != ni_gpct_variant_m_series)
+		return -EINVAL;
 
-		abz_reg = NITIO_ABZ_REG(cidx);
-		switch (index) {
-		case NI_GPCT_SOURCE_ENCODER_A:
-			shift = 10;
-			break;
-		case NI_GPCT_SOURCE_ENCODER_B:
-			shift = 5;
-			break;
-		case NI_GPCT_SOURCE_ENCODER_Z:
-			shift = 0;
-			break;
-		default:
-			return -EINVAL;
-		}
-		mask = 0x1f << shift;
-		if (source > 0x1f) {
-			/* Disable gate */
-			source = 0x1f;
-		}
-		counter_dev->regs[abz_reg] &= ~mask;
-		counter_dev->regs[abz_reg] |= (source << shift) & mask;
-		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-		return 0;
+	abz_reg = NITIO_ABZ_REG(cidx);
+	switch (index) {
+	case NI_GPCT_SOURCE_ENCODER_A:
+		shift = 10;
+		break;
+	case NI_GPCT_SOURCE_ENCODER_B:
+		shift = 5;
+		break;
+	case NI_GPCT_SOURCE_ENCODER_Z:
+		shift = 0;
+		break;
+	default:
+		return -EINVAL;
 	}
-	return -EINVAL;
+	mask = 0x1f << shift;
+	if (source > 0x1f)
+		source = 0x1f;	/* Disable gate */
+
+	counter_dev->regs[abz_reg] &= ~mask;
+	counter_dev->regs[abz_reg] |= (source << shift) & mask;
+	write_register(counter, counter_dev->regs[abz_reg], abz_reg);
+	return 0;
 }
 
 static unsigned ni_660x_gate_to_generic_gate(unsigned gate)

commit d00193be1febb2a1fe83cd4115c74cab6a6d14ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:58 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_get_gate_src() and helpers
    
    Do some renaming of local vars, parameters, etc. to tidy up the ugly
    line breaks to improve the readability of the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f0578484fba4..a149a73513eb 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1053,12 +1053,11 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 	return -EINVAL;
 }
 
-static unsigned
-ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
+static unsigned ni_660x_gate_to_generic_gate(unsigned gate)
 {
 	unsigned i;
 
-	switch (ni_660x_gate_select) {
+	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE_SEL:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
 	case NI_660X_GATE_PIN_I_GATE_SEL:
@@ -1071,13 +1070,13 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (ni_660x_gate_select == NI_660X_RTSI_GATE_SEL(i))
+			if (gate == NI_660X_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
 		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {
-			if (ni_660x_gate_select == NI_660X_PIN_GATE_SEL(i))
+			if (gate == NI_660X_PIN_GATE_SEL(i))
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 		}
 		if (i <= NI_660X_MAX_GATE_PIN)
@@ -1088,12 +1087,11 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	return 0;
 };
 
-static unsigned
-ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
+static unsigned ni_m_gate_to_generic_gate(unsigned gate)
 {
 	unsigned i;
 
-	switch (ni_m_series_gate_select) {
+	switch (gate) {
 	case NI_M_TIMESTAMP_MUX_GATE_SEL:
 		return NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
 	case NI_M_AI_START2_GATE_SEL:
@@ -1112,13 +1110,13 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
-			if (ni_m_series_gate_select == NI_M_RTSI_GATE_SEL(i))
+			if (gate == NI_M_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
 		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
-			if (ni_m_series_gate_select == NI_M_PFI_GATE_SEL(i))
+			if (gate == NI_M_PFI_GATE_SEL(i))
 				return NI_GPCT_PFI_GATE_SELECT(i);
 		}
 		if (i <= NI_M_MAX_PFI_CHAN)
@@ -1129,12 +1127,11 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 	return 0;
 };
 
-static unsigned
-ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
+static unsigned ni_660x_gate2_to_generic_gate(unsigned gate)
 {
 	unsigned i;
 
-	switch (ni_660x_gate_select) {
+	switch (gate) {
 	case NI_660X_SRC_PIN_I_GATE2_SEL:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
 	case NI_660X_UD_PIN_I_GATE2_SEL:
@@ -1149,13 +1146,13 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (ni_660x_gate_select == NI_660X_RTSI_GATE2_SEL(i))
+			if (gate == NI_660X_RTSI_GATE2_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
 		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {
-			if (ni_660x_gate_select == NI_660X_UD_PIN_GATE2_SEL(i))
+			if (gate == NI_660X_UD_PIN_GATE2_SEL(i))
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
 		}
 		if (i <= NI_660X_MAX_UP_DOWN_PIN)
@@ -1166,16 +1163,15 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	return 0;
 };
 
-static unsigned
-ni_m_series_second_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
+static unsigned ni_m_gate2_to_generic_gate(unsigned gate)
 {
 	/*
 	 * FIXME: the second gate sources for the m series are undocumented,
 	 * so we just return the raw bits for now.
 	 */
-	switch (ni_m_series_gate_select) {
+	switch (gate) {
 	default:
-		return ni_m_series_gate_select;
+		return gate;
 	}
 	return 0;
 };
@@ -1185,74 +1181,62 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	const unsigned mode_bits =
-		ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
-	unsigned gate_select_bits;
+	unsigned mode = ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
+	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned gate_sel;
 
 	switch (gate_index) {
 	case 0:
-		if ((mode_bits & Gi_Gating_Mode_Mask) ==
-		    Gi_Gating_Disabled_Bits) {
+		if ((mode & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		}
 
-		gate_select_bits =
-		    (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
-			Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
+		gate_sel = ni_tio_get_soft_copy(counter,
+						NITIO_INPUT_SEL_REG(cidx));
+		gate_sel &= Gi_Gate_Select_Mask;
+		gate_sel >>= Gi_Gate_Select_Shift;
 
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source =
-			    ni_m_series_first_gate_to_generic_gate_source
-			    (gate_select_bits);
+			*gate_source = ni_m_gate_to_generic_gate(gate_sel);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source =
-			    ni_660x_first_gate_to_generic_gate_source
-			    (gate_select_bits);
+			*gate_source = ni_660x_gate_to_generic_gate(gate_sel);
 			break;
 		}
-		if (mode_bits & Gi_Gate_Polarity_Bit)
+		if (mode & Gi_Gate_Polarity_Bit)
 			*gate_source |= CR_INVERT;
-		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
+		if ((mode & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
 			*gate_source |= CR_EDGE;
 		break;
 	case 1:
-		if ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits
-		    || (counter_dev->regs[second_gate_reg] &
-			Gi_Second_Gate_Mode_Bit)
-		    == 0) {
+		if ((mode & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits ||
+		    !(counter_dev->regs[gate2_reg] & Gi_Second_Gate_Mode_Bit)) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		}
 
-		gate_select_bits = (counter_dev->regs[second_gate_reg] &
-				Gi_Second_Gate_Select_Mask) >>
-				Gi_Second_Gate_Select_Shift;
+		gate_sel = counter_dev->regs[gate2_reg];
+		gate_sel &= Gi_Second_Gate_Select_Mask;
+		gate_sel >>= Gi_Second_Gate_Select_Shift;
+
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 		default:
-			*gate_source =
-			    ni_m_series_second_gate_to_generic_gate_source
-			    (gate_select_bits);
+			*gate_source = ni_m_gate2_to_generic_gate(gate_sel);
 			break;
 		case ni_gpct_variant_660x:
-			*gate_source =
-			    ni_660x_second_gate_to_generic_gate_source
-			    (gate_select_bits);
+			*gate_source = ni_660x_gate2_to_generic_gate(gate_sel);
 			break;
 		}
-		if (counter_dev->regs[second_gate_reg] &
-		    Gi_Second_Gate_Polarity_Bit) {
+		if (counter_dev->regs[gate2_reg] & Gi_Second_Gate_Polarity_Bit)
 			*gate_source |= CR_INVERT;
-		}
 		/* second gate can't have edge/level mode set independently */
-		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
+		if ((mode & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
 			*gate_source |= CR_EDGE;
 		break;
 	default:

commit 704c6dbaa914c3f1e4493fe6d40e6a30e89a223b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:57 2014 -0700

    staging: comedi: ni_tio: absorb ni_tio_counter_status()
    
    This function is only called to handle the INSN_CONFIG_GET_COUNTER_STATUS
    instruction. For aesthetics, absorb the code into ni_tio_insn_config().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index d099f542b796..f0578484fba4 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -205,21 +205,6 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 	write_register(counter, Gi_Reset_Bit(cidx), NITIO_RESET_REG(cidx));
 }
 
-static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
-{
-	unsigned cidx = counter->counter_index;
-	const unsigned bits = read_register(counter,
-					    NITIO_SHARED_STATUS_REG(cidx));
-	unsigned int status = 0;
-
-	if (bits & Gi_Armed_Bit(cidx)) {
-		status |= COMEDI_COUNTER_ARMED;
-		if (bits & Gi_Counting_Bit(cidx))
-			status |= COMEDI_COUNTER_COUNTING;
-	}
-	return status;
-}
-
 static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
@@ -1282,6 +1267,8 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		       unsigned int *data)
 {
 	struct ni_gpct *counter = s->private;
+	unsigned cidx = counter->counter_index;
+	unsigned status;
 
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1292,7 +1279,13 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		ni_tio_arm(counter, 0, 0);
 		return 0;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
-		data[1] = ni_tio_counter_status(counter);
+		data[1] = 0;
+		status = read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
+		if (status & Gi_Armed_Bit(cidx)) {
+			data[1] |= COMEDI_COUNTER_ARMED;
+			if (status & Gi_Counting_Bit(cidx))
+				data[1] |= COMEDI_COUNTER_COUNTING;
+		}
 		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 		return 0;
 	case INSN_CONFIG_SET_CLOCK_SRC:

commit f6e2278326fd0b845d892614ec5f30ef49ecea85
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:56 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_set_sync_mode()
    
    Fix the > 80 char line issues in this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 55485c27198e..d099f542b796 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -226,14 +226,13 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	unsigned cidx = counter->counter_index;
 	const unsigned counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
 	static const uint64_t min_normal_sync_period_ps = 25000;
-	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
-								ni_tio_generic_clock_src_select
-								(counter));
+	uint64_t clock_period_ps;
 
 	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
 		return;
 
-	switch (ni_tio_get_soft_copy(counter, counting_mode_reg) & Gi_Counting_Mode_Mask) {
+	switch (ni_tio_get_soft_copy(counter, counting_mode_reg) &
+		Gi_Counting_Mode_Mask) {
 	case Gi_Counting_Mode_QuadratureX1_Bits:
 	case Gi_Counting_Mode_QuadratureX2_Bits:
 	case Gi_Counting_Mode_QuadratureX4_Bits:
@@ -243,6 +242,10 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	default:
 		break;
 	}
+
+	clock_period_ps = ni_tio_clock_period_ps(counter,
+				ni_tio_generic_clock_src_select(counter));
+
 	/*
 	 * It's not clear what we should do if clock_period is unknown, so we
 	 * are not using the alt sync bit in that case, but allow the caller

commit 463daa7f187d68de5600a406069ddd4dca72c7b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:55 2014 -0700

    staging: comedi: ni_tio: tidy up ni_660x_source_select_bits()
    
    Rename a local variable to fix the > 80 char line issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 404a14f380e3..55485c27198e 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -388,12 +388,11 @@ EXPORT_SYMBOL_GPL(ni_tio_arm);
 
 static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 {
+	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned ni_660x_clock;
 	unsigned i;
-	const unsigned clock_select_bits =
-	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 
-	switch (clock_select_bits) {
+	switch (clk_src) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
 		ni_660x_clock = NI_660X_TIMEBASE_1_CLK;
 		break;
@@ -417,7 +416,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
-			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
+			if (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660X_RTSI_CLK(i);
 				break;
 			}
@@ -425,8 +424,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
-			if (clock_select_bits ==
-			    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
+			if (clk_src == NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660X_SRC_PIN_CLK(i);
 				break;
 			}

commit 99065954d1be462644f9b14badd1ead8deffa0b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:54 2014 -0700

    staging: comedi: ni_tio: tidy up ni_m_series_source_select_bits()
    
    Rename a local variable to fix the > 80 char line issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index b2ed3d8d60ee..404a14f380e3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -442,11 +442,11 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 
 static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 {
+	unsigned clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	unsigned ni_m_series_clock;
 	unsigned i;
-	const unsigned clock_select_bits =
-	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
-	switch (clock_select_bits) {
+
+	switch (clk_src) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
 		ni_m_series_clock = NI_M_TIMEBASE_1_CLK;
 		break;
@@ -476,7 +476,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		break;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
-			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
+			if (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
 				ni_m_series_clock = NI_M_RTSI_CLK(i);
 				break;
 			}
@@ -484,7 +484,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
 		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
-			if (clock_select_bits == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {
+			if (clk_src == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {
 				ni_m_series_clock = NI_M_PFI_CLK(i);
 				break;
 			}

commit dba0f57f88581687b3790d810ab9d737afe724ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:53 2014 -0700

    staging: comedi: ni_tio: rename ni_tio_second_gate_registers_present()
    
    For aesthetics, rename this function to shorten some of the long lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 0cecc604f480..b2ed3d8d60ee 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -186,8 +186,7 @@ static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
 }
 
-static int
-ni_tio_second_gate_registers_present(const struct ni_gpct_device *counter_dev)
+static int ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -996,8 +995,9 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		}
 		break;
 	case 1:
-		if (ni_tio_second_gate_registers_present(counter_dev) == 0)
+		if (!ni_tio_has_gate2_registers(counter_dev))
 			return -EINVAL;
+
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			counter_dev->regs[second_gate_reg] &=
 			    ~Gi_Second_Gate_Mode_Bit;
@@ -1459,7 +1459,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 	if (ni_tio_counting_mode_registers_present(counter_dev))
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);
 
-	if (ni_tio_second_gate_registers_present(counter_dev)) {
+	if (ni_tio_has_gate2_registers(counter_dev)) {
 		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
 		write_register(counter, 0x0, NITIO_GATE2_REG(cidx));
 	}

commit 25e529b0f45ce88a6d8f82c6bf43503040617c57
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:52 2014 -0700

    staging: comedi: ni_tio: tidy up ni_tio_init_counter()
    
    This function is called to initialize/reset a gpct counter during a
    comedi drivers (*attach).
    
    For aesthetics, move this exported function toward the end of the file.
    
    Tidy up the functions a bit by just open coding the '0x0' values used
    to initialize some of the registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a65b55db9819..0cecc604f480 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -206,49 +206,6 @@ static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 	write_register(counter, Gi_Reset_Bit(cidx), NITIO_RESET_REG(cidx));
 }
 
-void ni_tio_init_counter(struct ni_gpct *counter)
-{
-	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-
-	ni_tio_reset_count_and_disarm(counter);
-
-	/* initialize counter registers */
-	counter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;
-	write_register(counter, counter_dev->regs[NITIO_AUTO_INC_REG(cidx)],
-		       NITIO_AUTO_INC_REG(cidx));
-
-	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-			~0, Gi_Synchronize_Gate_Bit);
-
-	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
-
-	counter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;
-	write_register(counter, counter_dev->regs[NITIO_LOADA_REG(cidx)],
-		       NITIO_LOADA_REG(cidx));
-
-	counter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;
-	write_register(counter, counter_dev->regs[NITIO_LOADB_REG(cidx)],
-		       NITIO_LOADB_REG(cidx));
-
-	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);
-
-	if (ni_tio_counting_mode_registers_present(counter_dev))
-		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);
-
-	if (ni_tio_second_gate_registers_present(counter_dev)) {
-		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
-		write_register(counter,
-			       counter_dev->regs[NITIO_GATE2_REG(cidx)],
-			       NITIO_GATE2_REG(cidx));
-	}
-
-	ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);
-
-	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx), ~0, 0x0);
-}
-EXPORT_SYMBOL_GPL(ni_tio_init_counter);
-
 static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
 	unsigned cidx = counter->counter_index;
@@ -1475,6 +1432,44 @@ int ni_tio_insn_write(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_write);
 
+void ni_tio_init_counter(struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
+
+	ni_tio_reset_count_and_disarm(counter);
+
+	/* initialize counter registers */
+	counter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;
+	write_register(counter, 0x0, NITIO_AUTO_INC_REG(cidx));
+
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
+			~0, Gi_Synchronize_Gate_Bit);
+
+	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
+
+	counter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;
+	write_register(counter, 0x0, NITIO_LOADA_REG(cidx));
+
+	counter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;
+	write_register(counter, 0x0, NITIO_LOADB_REG(cidx));
+
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);
+
+	if (ni_tio_counting_mode_registers_present(counter_dev))
+		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);
+
+	if (ni_tio_second_gate_registers_present(counter_dev)) {
+		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
+		write_register(counter, 0x0, NITIO_GATE2_REG(cidx));
+	}
+
+	ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);
+
+	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx), ~0, 0x0);
+}
+EXPORT_SYMBOL_GPL(ni_tio_init_counter);
+
 struct ni_gpct_device *
 ni_gpct_device_construct(struct comedi_device *dev,
 			 void (*write_register)(struct ni_gpct *counter,

commit 8477c5d4ba0d7ff04d346c5cb104d06a62adddae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:51 2014 -0700

    staging: comedi: ni_tio: tidy up ni_gpct_device_{construct,destroy)()
    
    For aesthetics, move these exported functions to the end of the file.
    
    Tidy up the functions a bit and remove the BUG_ON when (num_counters == 0).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e49c71c0ba2b..a65b55db9819 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -186,52 +186,6 @@ static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
 }
 
-struct ni_gpct_device *
-ni_gpct_device_construct(struct comedi_device *dev,
-			 void (*write_register)(struct ni_gpct *counter,
-						unsigned bits,
-						enum ni_gpct_register reg),
-			 unsigned (*read_register)(struct ni_gpct *counter,
-						   enum ni_gpct_register reg),
-			 enum ni_gpct_variant variant,
-			 unsigned num_counters)
-{
-	unsigned i;
-
-	struct ni_gpct_device *counter_dev =
-	    kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
-	if (counter_dev == NULL)
-		return NULL;
-	counter_dev->dev = dev;
-	counter_dev->write_register = write_register;
-	counter_dev->read_register = read_register;
-	counter_dev->variant = variant;
-	spin_lock_init(&counter_dev->regs_lock);
-	BUG_ON(num_counters == 0);
-	counter_dev->counters =
-	    kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
-	if (counter_dev->counters == NULL) {
-		kfree(counter_dev);
-		return NULL;
-	}
-	for (i = 0; i < num_counters; ++i) {
-		counter_dev->counters[i].counter_dev = counter_dev;
-		spin_lock_init(&counter_dev->counters[i].lock);
-	}
-	counter_dev->num_counters = num_counters;
-	return counter_dev;
-}
-EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
-
-void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
-{
-	if (counter_dev->counters == NULL)
-		return;
-	kfree(counter_dev->counters);
-	kfree(counter_dev);
-}
-EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);
-
 static int
 ni_tio_second_gate_registers_present(const struct ni_gpct_device *counter_dev)
 {
@@ -1521,6 +1475,61 @@ int ni_tio_insn_write(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_write);
 
+struct ni_gpct_device *
+ni_gpct_device_construct(struct comedi_device *dev,
+			 void (*write_register)(struct ni_gpct *counter,
+						unsigned bits,
+						enum ni_gpct_register reg),
+			 unsigned (*read_register)(struct ni_gpct *counter,
+						   enum ni_gpct_register reg),
+			 enum ni_gpct_variant variant,
+			 unsigned num_counters)
+{
+	struct ni_gpct_device *counter_dev;
+	struct ni_gpct *counter;
+	unsigned i;
+
+	if (num_counters == 0)
+		return NULL;
+
+	counter_dev = kzalloc(sizeof(*counter_dev), GFP_KERNEL);
+	if (!counter_dev)
+		return NULL;
+
+	counter_dev->dev = dev;
+	counter_dev->write_register = write_register;
+	counter_dev->read_register = read_register;
+	counter_dev->variant = variant;
+
+	spin_lock_init(&counter_dev->regs_lock);
+
+	counter_dev->counters = kcalloc(num_counters, sizeof(*counter),
+					GFP_KERNEL);
+	if (!counter_dev->counters) {
+		kfree(counter_dev);
+		return NULL;
+	}
+
+	for (i = 0; i < num_counters; ++i) {
+		counter = &counter_dev->counters[i];
+		counter->counter_dev = counter_dev;
+		spin_lock_init(&counter->lock);
+	}
+	counter_dev->num_counters = num_counters;
+
+	return counter_dev;
+}
+EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
+
+void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
+{
+	if (!counter_dev->counters)
+		return;
+	kfree(counter_dev->counters);
+	kfree(counter_dev);
+}
+EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);
+
 static int __init ni_tio_init_module(void)
 {
 	return 0;

commit 9ff506ec11eae62bd0290e903a431552a05e5ac8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:50 2014 -0700

    staging: comedi: ni_tio: move defines to head of file
    
    For aesthetics, move all the defines to the head of the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index c187456596fb..e49c71c0ba2b 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -49,6 +49,73 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 
 #include "ni_tio_internal.h"
 
+/*
+ * clock sources for ni e and m series boards,
+ * get bits with Gi_Source_Select_Bits()
+ */
+#define NI_M_TIMEBASE_1_CLK		0x0	/* 20MHz */
+#define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
+#define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
+#define NI_M_TIMEBASE_2_CLK		0x12	/* 100KHz */
+#define NI_M_NEXT_TC_CLK		0x13
+#define NI_M_NEXT_GATE_CLK		0x14	/* Gi_Src_SubSelect=0 */
+#define NI_M_PXI_STAR_TRIGGER_CLK	0x14	/* Gi_Src_SubSelect=1 */
+#define NI_M_PXI10_CLK			0x1d
+#define NI_M_TIMEBASE_3_CLK		0x1e	/* 80MHz, Gi_Src_SubSelect=0 */
+#define NI_M_ANALOG_TRIGGER_OUT_CLK	0x1e	/* Gi_Src_SubSelect=1 */
+#define NI_M_LOGIC_LOW_CLK		0x1f
+#define NI_M_MAX_PFI_CHAN		15
+#define NI_M_MAX_RTSI_CHAN		7
+
+/*
+ * clock sources for ni_660x boards,
+ * get bits with Gi_Source_Select_Bits()
+ */
+#define NI_660X_TIMEBASE_1_CLK		0x0	/* 20MHz */
+#define NI_660X_SRC_PIN_I_CLK		0x1
+#define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
+#define NI_660X_NEXT_GATE_CLK		0xa
+#define NI_660X_RTSI_CLK(x)		(0xb + (x))
+#define NI_660X_TIMEBASE_2_CLK		0x12	/* 100KHz */
+#define NI_660X_NEXT_TC_CLK		0x13
+#define NI_660X_TIMEBASE_3_CLK		0x1e	/* 80MHz */
+#define NI_660X_LOGIC_LOW_CLK		0x1f
+#define NI_660X_MAX_SRC_PIN		7
+#define NI_660X_MAX_RTSI_CHAN		6
+
+/* ni m series gate_select */
+#define NI_M_TIMESTAMP_MUX_GATE_SEL	0x0
+#define NI_M_PFI_GATE_SEL(x)		(((x) < 10) ? (1 + (x)) : (0xb + (x)))
+#define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
+#define NI_M_AI_START2_GATE_SEL		0x12
+#define NI_M_PXI_STAR_TRIGGER_GATE_SEL	0x13
+#define NI_M_NEXT_OUT_GATE_SEL		0x14
+#define NI_M_AI_START1_GATE_SEL		0x1c
+#define NI_M_NEXT_SRC_GATE_SEL		0x1d
+#define NI_M_ANALOG_TRIG_OUT_GATE_SEL	0x1e
+#define NI_M_LOGIC_LOW_GATE_SEL		0x1f
+
+/* ni_660x gate select */
+#define NI_660X_SRC_PIN_I_GATE_SEL	0x0
+#define NI_660X_GATE_PIN_I_GATE_SEL	0x1
+#define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
+#define NI_660X_NEXT_SRC_GATE_SEL	0xa
+#define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
+#define NI_660X_NEXT_OUT_GATE_SEL	0x14
+#define NI_660X_LOGIC_LOW_GATE_SEL	0x1f
+#define NI_660X_MAX_GATE_PIN		7
+
+/* ni_660x second gate select */
+#define NI_660X_SRC_PIN_I_GATE2_SEL	0x0
+#define NI_660X_UD_PIN_I_GATE2_SEL	0x1
+#define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
+#define NI_660X_NEXT_SRC_GATE2_SEL	0xa
+#define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
+#define NI_660X_NEXT_OUT_GATE2_SEL	0x14
+#define NI_660X_SELECTED_GATE2_SEL	0x1e
+#define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
+#define NI_660X_MAX_UP_DOWN_PIN		7
+
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 				       unsigned generic_clock_source);
 static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
@@ -109,59 +176,6 @@ Gi_HW_Arm_Select_Mask(enum ni_gpct_variant variant)
 	}
 }
 
-/* clock sources for ni_660x boards, get bits with Gi_Source_Select_Bits() */
-#define NI_660X_TIMEBASE_1_CLK		0x0	/* 20MHz */
-#define NI_660X_SRC_PIN_I_CLK		0x1
-#define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
-#define NI_660X_NEXT_GATE_CLK		0xa
-#define NI_660X_RTSI_CLK(x)		(0xb + (x))
-#define NI_660X_TIMEBASE_2_CLK		0x12	/* 100KHz */
-#define NI_660X_NEXT_TC_CLK		0x13
-#define NI_660X_TIMEBASE_3_CLK		0x1e	/* 80MHz */
-#define NI_660X_LOGIC_LOW_CLK		0x1f
-#define NI_660X_MAX_SRC_PIN		7
-#define NI_660X_MAX_RTSI_CHAN		6
-
-/*
- * clock sources for ni e and m series boards,
- * get bits with Gi_Source_Select_Bits()
- */
-#define NI_M_TIMEBASE_1_CLK		0x0	/* 20MHz */
-#define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
-#define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
-#define NI_M_TIMEBASE_2_CLK		0x12	/* 100KHz */
-#define NI_M_NEXT_TC_CLK		0x13
-#define NI_M_NEXT_GATE_CLK		0x14	/* Gi_Src_SubSelect=0 */
-#define NI_M_PXI_STAR_TRIGGER_CLK	0x14	/* Gi_Src_SubSelect=1 */
-#define NI_M_PXI10_CLK			0x1d
-#define NI_M_TIMEBASE_3_CLK		0x1e	/* 80MHz, Gi_Src_SubSelect=0 */
-#define NI_M_ANALOG_TRIGGER_OUT_CLK	0x1e	/* Gi_Src_SubSelect=1 */
-#define NI_M_LOGIC_LOW_CLK		0x1f
-#define NI_M_MAX_PFI_CHAN		15
-#define NI_M_MAX_RTSI_CHAN		7
-
-/* NI660X gate select */
-#define NI_660X_SRC_PIN_I_GATE_SEL	0x0
-#define NI_660X_GATE_PIN_I_GATE_SEL	0x1
-#define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
-#define NI_660X_NEXT_SRC_GATE_SEL	0xa
-#define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
-#define NI_660X_NEXT_OUT_GATE_SEL	0x14
-#define NI_660X_LOGIC_LOW_GATE_SEL	0x1f
-#define NI_660X_MAX_GATE_PIN		7
-
-/* NI M SERIES gate_select */
-#define NI_M_TIMESTAMP_MUX_GATE_SEL	0x0
-#define NI_M_PFI_GATE_SEL(x)		(((x) < 10) ? (1 + (x)) : (0xb + (x)))
-#define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
-#define NI_M_AI_START2_GATE_SEL		0x12
-#define NI_M_PXI_STAR_TRIGGER_GATE_SEL	0x13
-#define NI_M_NEXT_OUT_GATE_SEL		0x14
-#define NI_M_AI_START1_GATE_SEL		0x1c
-#define NI_M_NEXT_SRC_GATE_SEL		0x1d
-#define NI_M_ANALOG_TRIG_OUT_GATE_SEL	0x1e
-#define NI_M_LOGIC_LOW_GATE_SEL		0x1f
-
 static inline unsigned Gi_Source_Select_Bits(unsigned source)
 {
 	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
@@ -172,17 +186,6 @@ static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
 }
 
-/* NI660X second gate select */
-#define NI_660X_SRC_PIN_I_GATE2_SEL	0x0
-#define NI_660X_UD_PIN_I_GATE2_SEL	0x1
-#define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
-#define NI_660X_NEXT_SRC_GATE2_SEL	0xa
-#define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
-#define NI_660X_NEXT_OUT_GATE2_SEL	0x14
-#define NI_660X_SELECTED_GATE2_SEL	0x1e
-#define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
-#define NI_660X_MAX_UP_DOWN_PIN		7
-
 struct ni_gpct_device *
 ni_gpct_device_construct(struct comedi_device *dev,
 			 void (*write_register)(struct ni_gpct *counter,

commit b8e58af6da5a85d8656b31dcecac2bee1919f602
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:49 2014 -0700

    staging: comedi: ni_tio: tidy up enum ni_660x_clock_source
    
    These values are not used as an enum. For aesthetics, rename the
    CamelCase values and convert them into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 757a7a58626c..c187456596fb 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -110,20 +110,17 @@ Gi_HW_Arm_Select_Mask(enum ni_gpct_variant variant)
 }
 
 /* clock sources for ni_660x boards, get bits with Gi_Source_Select_Bits() */
-enum ni_660x_clock_source {
-	NI_660x_Timebase_1_Clock = 0x0,	/* 20MHz */
-	NI_660x_Source_Pin_i_Clock = 0x1,
-	NI_660x_Next_Gate_Clock = 0xa,
-	NI_660x_Timebase_2_Clock = 0x12,	/* 100KHz */
-	NI_660x_Next_TC_Clock = 0x13,
-	NI_660x_Timebase_3_Clock = 0x1e,	/* 80MHz */
-	NI_660x_Logic_Low_Clock = 0x1f,
-};
-#define NI_660X_MAX_RTSI_CHAN		6
+#define NI_660X_TIMEBASE_1_CLK		0x0	/* 20MHz */
+#define NI_660X_SRC_PIN_I_CLK		0x1
+#define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
+#define NI_660X_NEXT_GATE_CLK		0xa
 #define NI_660X_RTSI_CLK(x)		(0xb + (x))
-
+#define NI_660X_TIMEBASE_2_CLK		0x12	/* 100KHz */
+#define NI_660X_NEXT_TC_CLK		0x13
+#define NI_660X_TIMEBASE_3_CLK		0x1e	/* 80MHz */
+#define NI_660X_LOGIC_LOW_CLK		0x1f
 #define NI_660X_MAX_SRC_PIN		7
-#define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
+#define NI_660X_MAX_RTSI_CHAN		6
 
 /*
  * clock sources for ni e and m series boards,
@@ -485,25 +482,25 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Timebase_1_Clock;
+		ni_660x_clock = NI_660X_TIMEBASE_1_CLK;
 		break;
 	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Timebase_2_Clock;
+		ni_660x_clock = NI_660X_TIMEBASE_2_CLK;
 		break;
 	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Timebase_3_Clock;
+		ni_660x_clock = NI_660X_TIMEBASE_3_CLK;
 		break;
 	case NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Logic_Low_Clock;
+		ni_660x_clock = NI_660X_LOGIC_LOW_CLK;
 		break;
 	case NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Source_Pin_i_Clock;
+		ni_660x_clock = NI_660X_SRC_PIN_I_CLK;
 		break;
 	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Next_Gate_Clock;
+		ni_660x_clock = NI_660X_NEXT_GATE_CLK;
 		break;
 	case NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:
-		ni_660x_clock = NI_660x_Next_TC_Clock;
+		ni_660x_clock = NI_660X_NEXT_TC_CLK;
 		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
@@ -768,25 +765,25 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 	unsigned i;
 
 	switch (input_select) {
-	case NI_660x_Timebase_1_Clock:
+	case NI_660X_TIMEBASE_1_CLK:
 		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Timebase_2_Clock:
+	case NI_660X_TIMEBASE_2_CLK:
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Timebase_3_Clock:
+	case NI_660X_TIMEBASE_3_CLK:
 		clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Logic_Low_Clock:
+	case NI_660X_LOGIC_LOW_CLK:
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Source_Pin_i_Clock:
+	case NI_660X_SRC_PIN_I_CLK:
 		clock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Next_Gate_Clock:
+	case NI_660X_NEXT_GATE_CLK:
 		clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
 		break;
-	case NI_660x_Next_TC_Clock:
+	case NI_660X_NEXT_TC_CLK:
 		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
 		break;
 	default:

commit c93a74068657ef8489765a900d872be1451d5f85
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:48 2014 -0700

    staging: comedi: ni_tio: tidy up enum ni_m_series_clock_source
    
    These values are not used as an enum. For aesthetics, rename the
    CamelCase values and convert them into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 39c7f50a49a9..757a7a58626c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -125,23 +125,23 @@ enum ni_660x_clock_source {
 #define NI_660X_MAX_SRC_PIN		7
 #define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
 
-/* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */
-enum ni_m_series_clock_source {
-	NI_M_Series_Timebase_1_Clock = 0x0,	/* 20MHz */
-	NI_M_Series_Timebase_2_Clock = 0x12,	/* 100KHz */
-	NI_M_Series_Next_TC_Clock = 0x13,
-	NI_M_Series_Next_Gate_Clock = 0x14,	/* when Gi_Src_SubSelect = 0 */
-	NI_M_Series_PXI_Star_Trigger_Clock = 0x14,	/* when Gi_Src_SubSelect = 1 */
-	NI_M_Series_PXI10_Clock = 0x1d,
-	NI_M_Series_Timebase_3_Clock = 0x1e,	/* 80MHz, when Gi_Src_SubSelect = 0 */
-	NI_M_Series_Analog_Trigger_Out_Clock = 0x1e,	/* when Gi_Src_SubSelect = 1 */
-	NI_M_Series_Logic_Low_Clock = 0x1f,
-};
-#define NI_M_MAX_PFI_CHAN		15
+/*
+ * clock sources for ni e and m series boards,
+ * get bits with Gi_Source_Select_Bits()
+ */
+#define NI_M_TIMEBASE_1_CLK		0x0	/* 20MHz */
 #define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
-
-#define NI_M_MAX_RTSI_CHAN		7
 #define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
+#define NI_M_TIMEBASE_2_CLK		0x12	/* 100KHz */
+#define NI_M_NEXT_TC_CLK		0x13
+#define NI_M_NEXT_GATE_CLK		0x14	/* Gi_Src_SubSelect=0 */
+#define NI_M_PXI_STAR_TRIGGER_CLK	0x14	/* Gi_Src_SubSelect=1 */
+#define NI_M_PXI10_CLK			0x1d
+#define NI_M_TIMEBASE_3_CLK		0x1e	/* 80MHz, Gi_Src_SubSelect=0 */
+#define NI_M_ANALOG_TRIGGER_OUT_CLK	0x1e	/* Gi_Src_SubSelect=1 */
+#define NI_M_LOGIC_LOW_CLK		0x1f
+#define NI_M_MAX_PFI_CHAN		15
+#define NI_M_MAX_RTSI_CHAN		7
 
 /* NI660X gate select */
 #define NI_660X_SRC_PIN_I_GATE_SEL	0x0
@@ -538,31 +538,31 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Timebase_1_Clock;
+		ni_m_series_clock = NI_M_TIMEBASE_1_CLK;
 		break;
 	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Timebase_2_Clock;
+		ni_m_series_clock = NI_M_TIMEBASE_2_CLK;
 		break;
 	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Timebase_3_Clock;
+		ni_m_series_clock = NI_M_TIMEBASE_3_CLK;
 		break;
 	case NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Logic_Low_Clock;
+		ni_m_series_clock = NI_M_LOGIC_LOW_CLK;
 		break;
 	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Next_Gate_Clock;
+		ni_m_series_clock = NI_M_NEXT_GATE_CLK;
 		break;
 	case NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Next_TC_Clock;
+		ni_m_series_clock = NI_M_NEXT_TC_CLK;
 		break;
 	case NI_GPCT_PXI10_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_PXI10_Clock;
+		ni_m_series_clock = NI_M_PXI10_CLK;
 		break;
 	case NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_PXI_Star_Trigger_Clock;
+		ni_m_series_clock = NI_M_PXI_STAR_TRIGGER_CLK;
 		break;
 	case NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:
-		ni_m_series_clock = NI_M_Series_Analog_Trigger_Out_Clock;
+		ni_m_series_clock = NI_M_ANALOG_TRIGGER_OUT_CLK;
 		break;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
@@ -704,13 +704,13 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
 
 	switch (input_select) {
-	case NI_M_Series_Timebase_1_Clock:
+	case NI_M_TIMEBASE_1_CLK:
 		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_Timebase_2_Clock:
+	case NI_M_TIMEBASE_2_CLK:
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_Timebase_3_Clock:
+	case NI_M_TIMEBASE_3_CLK:
 		if (counter_dev->regs[second_gate_reg] &
 		    Gi_Source_Subselect_Bit)
 			clock_source =
@@ -718,20 +718,20 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		else
 			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_Logic_Low_Clock:
+	case NI_M_LOGIC_LOW_CLK:
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_Next_Gate_Clock:
+	case NI_M_NEXT_GATE_CLK:
 		if (counter_dev->regs[second_gate_reg] &
 		    Gi_Source_Subselect_Bit)
 			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_PXI10_Clock:
+	case NI_M_PXI10_CLK:
 		clock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;
 		break;
-	case NI_M_Series_Next_TC_Clock:
+	case NI_M_NEXT_TC_CLK:
 		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
 		break;
 	default:

commit 5a3d1ed8574a505d80d94796e4d2f2efaf9bfed0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:47 2014 -0700

    staging: comedi: ni_tio: tidy up enum ni_660x_gate_select
    
    These values are not used as an enum. For aesthetics, rename the
    CamelCase values and convert them into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 62a5cab53970..39c7f50a49a9 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -143,16 +143,15 @@ enum ni_m_series_clock_source {
 #define NI_M_MAX_RTSI_CHAN		7
 #define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
 
-enum ni_660x_gate_select {
-	NI_660x_Source_Pin_i_Gate_Select = 0x0,
-	NI_660x_Gate_Pin_i_Gate_Select = 0x1,
-	NI_660x_Next_SRC_Gate_Select = 0xa,
-	NI_660x_Next_Out_Gate_Select = 0x14,
-	NI_660x_Logic_Low_Gate_Select = 0x1f,
-};
-#define NI_660X_MAX_GATE_PIN		7
+/* NI660X gate select */
+#define NI_660X_SRC_PIN_I_GATE_SEL	0x0
+#define NI_660X_GATE_PIN_I_GATE_SEL	0x1
 #define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
+#define NI_660X_NEXT_SRC_GATE_SEL	0xa
 #define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
+#define NI_660X_NEXT_OUT_GATE_SEL	0x14
+#define NI_660X_LOGIC_LOW_GATE_SEL	0x1f
+#define NI_660X_MAX_GATE_PIN		7
 
 /* NI M SERIES gate_select */
 #define NI_M_TIMESTAMP_MUX_GATE_SEL	0x0
@@ -908,7 +907,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 
 	switch (chan) {
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
-		gate_sel = NI_660x_Next_SRC_Gate_Select;
+		gate_sel = NI_660X_NEXT_SRC_GATE_SEL;
 		break;
 	case NI_GPCT_NEXT_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
@@ -1163,15 +1162,15 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	unsigned i;
 
 	switch (ni_660x_gate_select) {
-	case NI_660x_Source_Pin_i_Gate_Select:
+	case NI_660X_SRC_PIN_I_GATE_SEL:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
-	case NI_660x_Gate_Pin_i_Gate_Select:
+	case NI_660X_GATE_PIN_I_GATE_SEL:
 		return NI_GPCT_GATE_PIN_i_GATE_SELECT;
-	case NI_660x_Next_SRC_Gate_Select:
+	case NI_660X_NEXT_SRC_GATE_SEL:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-	case NI_660x_Next_Out_Gate_Select:
+	case NI_660X_NEXT_OUT_GATE_SEL:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-	case NI_660x_Logic_Low_Gate_Select:
+	case NI_660X_LOGIC_LOW_GATE_SEL:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {

commit 390db7a30e4105db0a87a91918e08e060f1398a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:46 2014 -0700

    staging: comedi: ni_tio: tidy up enum ni_m_series_gate_select
    
    These values are not used as an enum. For aesthetics, rename the
    CamelCase values and convert them into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6ef64a6efea7..62a5cab53970 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -154,18 +154,17 @@ enum ni_660x_gate_select {
 #define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
 #define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
 
-enum ni_m_series_gate_select {
-	NI_M_Series_Timestamp_Mux_Gate_Select = 0x0,
-	NI_M_Series_AI_START2_Gate_Select = 0x12,
-	NI_M_Series_PXI_Star_Trigger_Gate_Select = 0x13,
-	NI_M_Series_Next_Out_Gate_Select = 0x14,
-	NI_M_Series_AI_START1_Gate_Select = 0x1c,
-	NI_M_Series_Next_SRC_Gate_Select = 0x1d,
-	NI_M_Series_Analog_Trigger_Out_Gate_Select = 0x1e,
-	NI_M_Series_Logic_Low_Gate_Select = 0x1f,
-};
-#define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
+/* NI M SERIES gate_select */
+#define NI_M_TIMESTAMP_MUX_GATE_SEL	0x0
 #define NI_M_PFI_GATE_SEL(x)		(((x) < 10) ? (1 + (x)) : (0xb + (x)))
+#define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
+#define NI_M_AI_START2_GATE_SEL		0x12
+#define NI_M_PXI_STAR_TRIGGER_GATE_SEL	0x13
+#define NI_M_NEXT_OUT_GATE_SEL		0x14
+#define NI_M_AI_START1_GATE_SEL		0x1c
+#define NI_M_NEXT_SRC_GATE_SEL		0x1d
+#define NI_M_ANALOG_TRIG_OUT_GATE_SEL	0x1e
+#define NI_M_LOGIC_LOW_GATE_SEL		0x1f
 
 static inline unsigned Gi_Source_Select_Bits(unsigned source)
 {
@@ -1199,21 +1198,21 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 	unsigned i;
 
 	switch (ni_m_series_gate_select) {
-	case NI_M_Series_Timestamp_Mux_Gate_Select:
+	case NI_M_TIMESTAMP_MUX_GATE_SEL:
 		return NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
-	case NI_M_Series_AI_START2_Gate_Select:
+	case NI_M_AI_START2_GATE_SEL:
 		return NI_GPCT_AI_START2_GATE_SELECT;
-	case NI_M_Series_PXI_Star_Trigger_Gate_Select:
+	case NI_M_PXI_STAR_TRIGGER_GATE_SEL:
 		return NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;
-	case NI_M_Series_Next_Out_Gate_Select:
+	case NI_M_NEXT_OUT_GATE_SEL:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-	case NI_M_Series_AI_START1_Gate_Select:
+	case NI_M_AI_START1_GATE_SEL:
 		return NI_GPCT_AI_START1_GATE_SELECT;
-	case NI_M_Series_Next_SRC_Gate_Select:
+	case NI_M_NEXT_SRC_GATE_SEL:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-	case NI_M_Series_Analog_Trigger_Out_Gate_Select:
+	case NI_M_ANALOG_TRIG_OUT_GATE_SEL:
 		return NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;
-	case NI_M_Series_Logic_Low_Gate_Select:
+	case NI_M_LOGIC_LOW_GATE_SEL:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {

commit 7e3e7591631290617ca0a5bc9bd05aabf547d87d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:45 2014 -0700

    staging: comedi: ni_tio: tidy up enum ni_660x_second_gate_select
    
    These values are not used as an enum. For aesthetics, rename the
    CamelCase values and convert them into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6da4ab588385..6ef64a6efea7 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -177,17 +177,16 @@ static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
 }
 
-enum ni_660x_second_gate_select {
-	NI_660x_Source_Pin_i_Second_Gate_Select = 0x0,
-	NI_660x_Up_Down_Pin_i_Second_Gate_Select = 0x1,
-	NI_660x_Next_SRC_Second_Gate_Select = 0xa,
-	NI_660x_Next_Out_Second_Gate_Select = 0x14,
-	NI_660x_Selected_Gate_Second_Gate_Select = 0x1e,
-	NI_660x_Logic_Low_Second_Gate_Select = 0x1f,
-};
-#define NI_660X_MAX_UP_DOWN_PIN		7
+/* NI660X second gate select */
+#define NI_660X_SRC_PIN_I_GATE2_SEL	0x0
+#define NI_660X_UD_PIN_I_GATE2_SEL	0x1
 #define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
+#define NI_660X_NEXT_SRC_GATE2_SEL	0xa
 #define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
+#define NI_660X_NEXT_OUT_GATE2_SEL	0x14
+#define NI_660X_SELECTED_GATE2_SEL	0x1e
+#define NI_660X_LOGIC_LOW_GATE2_SEL	0x1f
+#define NI_660X_MAX_UP_DOWN_PIN		7
 
 struct ni_gpct_device *
 ni_gpct_device_construct(struct comedi_device *dev,
@@ -1004,7 +1003,7 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 		gate2_sel = chan & 0x1f;
 		break;
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
-		gate2_sel = NI_660x_Next_SRC_Second_Gate_Select;
+		gate2_sel = NI_660X_NEXT_SRC_GATE2_SEL;
 		break;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
@@ -1241,17 +1240,17 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	unsigned i;
 
 	switch (ni_660x_gate_select) {
-	case NI_660x_Source_Pin_i_Second_Gate_Select:
+	case NI_660X_SRC_PIN_I_GATE2_SEL:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
-	case NI_660x_Up_Down_Pin_i_Second_Gate_Select:
+	case NI_660X_UD_PIN_I_GATE2_SEL:
 		return NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;
-	case NI_660x_Next_SRC_Second_Gate_Select:
+	case NI_660X_NEXT_SRC_GATE2_SEL:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-	case NI_660x_Next_Out_Second_Gate_Select:
+	case NI_660X_NEXT_OUT_GATE2_SEL:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-	case NI_660x_Selected_Gate_Second_Gate_Select:
+	case NI_660X_SELECTED_GATE2_SEL:
 		return NI_GPCT_SELECTED_GATE_GATE_SELECT;
-	case NI_660x_Logic_Low_Second_Gate_Select:
+	case NI_660X_LOGIC_LOW_GATE2_SEL:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {

commit 01ca8f978b2e6633fb0dbabf8b18355a460712df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:44 2014 -0700

    staging: comedi: ni_tio: remove counter_status_mask
    
    For aesthetics, remove this global static const varaible.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 9b5ab0bf5bfe..6da4ab588385 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -189,9 +189,6 @@ enum ni_660x_second_gate_select {
 #define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
 #define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
 
-static const unsigned int counter_status_mask =
-	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
-
 struct ni_gpct_device *
 ni_gpct_device_construct(struct comedi_device *dev,
 			 void (*write_register)(struct ni_gpct *counter,
@@ -1387,7 +1384,7 @@ int ni_tio_insn_config(struct comedi_device *dev,
 		return 0;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = ni_tio_counter_status(counter);
-		data[2] = counter_status_mask;
+		data[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 		return 0;
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		return ni_tio_set_clock_src(counter, data[1], data[2]);

commit eca7d87201eea47ec2b1d5705533c8cdef312e54
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:43 2014 -0700

    staging: comedi: ni_tio: convert global static const variables to defines
    
    For aesthetics, convert the global static const varaibles into defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 247e3daadadb..9b5ab0bf5bfe 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -119,10 +119,10 @@ enum ni_660x_clock_source {
 	NI_660x_Timebase_3_Clock = 0x1e,	/* 80MHz */
 	NI_660x_Logic_Low_Clock = 0x1f,
 };
-static const unsigned ni_660x_max_rtsi_channel = 6;
+#define NI_660X_MAX_RTSI_CHAN		6
 #define NI_660X_RTSI_CLK(x)		(0xb + (x))
 
-static const unsigned ni_660x_max_source_pin = 7;
+#define NI_660X_MAX_SRC_PIN		7
 #define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
 
 /* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */
@@ -137,10 +137,10 @@ enum ni_m_series_clock_source {
 	NI_M_Series_Analog_Trigger_Out_Clock = 0x1e,	/* when Gi_Src_SubSelect = 1 */
 	NI_M_Series_Logic_Low_Clock = 0x1f,
 };
-static const unsigned ni_m_series_max_pfi_channel = 15;
+#define NI_M_MAX_PFI_CHAN		15
 #define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
 
-static const unsigned ni_m_series_max_rtsi_channel = 7;
+#define NI_M_MAX_RTSI_CHAN		7
 #define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
 
 enum ni_660x_gate_select {
@@ -150,7 +150,7 @@ enum ni_660x_gate_select {
 	NI_660x_Next_Out_Gate_Select = 0x14,
 	NI_660x_Logic_Low_Gate_Select = 0x1f,
 };
-static const unsigned ni_660x_max_gate_pin = 7;
+#define NI_660X_MAX_GATE_PIN		7
 #define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
 #define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
 
@@ -185,7 +185,7 @@ enum ni_660x_second_gate_select {
 	NI_660x_Selected_Gate_Second_Gate_Select = 0x1e,
 	NI_660x_Logic_Low_Second_Gate_Select = 0x1f,
 };
-static const unsigned ni_660x_max_up_down_pin = 7;
+#define NI_660X_MAX_UP_DOWN_PIN		7
 #define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
 #define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
 
@@ -512,22 +512,22 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 		ni_660x_clock = NI_660x_Next_TC_Clock;
 		break;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660X_RTSI_CLK(i);
 				break;
 			}
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
 			if (clock_select_bits ==
 			    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660X_SRC_PIN_CLK(i);
 				break;
 			}
 		}
-		if (i <= ni_660x_max_source_pin)
+		if (i <= NI_660X_MAX_SRC_PIN)
 			break;
 		ni_660x_clock = 0;
 		BUG();
@@ -571,21 +571,21 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		ni_m_series_clock = NI_M_Series_Analog_Trigger_Out_Clock;
 		break;
 	default:
-		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
 			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
 				ni_m_series_clock = NI_M_RTSI_CLK(i);
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_rtsi_channel)
+		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
 			if (clock_select_bits == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {
 				ni_m_series_clock = NI_M_PFI_CLK(i);
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_pfi_channel)
+		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
 		printk(KERN_ERR "invalid clock source 0x%lx\n",
 		       (unsigned long)clock_source);
@@ -741,21 +741,21 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
 		break;
 	default:
-		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
 			if (input_select == NI_M_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_rtsi_channel)
+		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
 			if (input_select == NI_M_PFI_CLK(i)) {
 				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_pfi_channel)
+		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
 		BUG();
 		break;
@@ -796,22 +796,22 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
 		break;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (input_select == NI_660X_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {
 			if (input_select == NI_660X_SRC_PIN_CLK(i)) {
 				clock_source =
 				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
-		if (i <= ni_660x_max_source_pin)
+		if (i <= NI_660X_MAX_SRC_PIN)
 			break;
 		BUG();
 		break;
@@ -922,21 +922,21 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 		gate_sel = chan & 0x1f;
 		break;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {
 			if (chan == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
 				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_660x_max_gate_pin)
+		if (i <= NI_660X_MAX_GATE_PIN)
 			break;
 		return -EINVAL;
 	}
@@ -965,21 +965,21 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		gate_sel = chan & 0x1f;
 		break;
 	default:
-		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
 			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_rtsi_channel)
+		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
 			if (chan == NI_GPCT_PFI_GATE_SELECT(i)) {
 				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_m_series_max_pfi_channel)
+		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
 		return -EINVAL;
 	}
@@ -1010,21 +1010,21 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 		gate2_sel = NI_660x_Next_SRC_Second_Gate_Select;
 		break;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				gate2_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {
 			if (chan == NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
 				gate2_sel = chan & 0x1f;
 				break;
 			}
 		}
-		if (i <= ni_660x_max_up_down_pin)
+		if (i <= NI_660X_MAX_UP_DOWN_PIN)
 			break;
 		return -EINVAL;
 	}
@@ -1179,17 +1179,17 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	case NI_660x_Logic_Low_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (ni_660x_gate_select == NI_660X_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {
 			if (ni_660x_gate_select == NI_660X_PIN_GATE_SEL(i))
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 		}
-		if (i <= ni_660x_max_gate_pin)
+		if (i <= NI_660X_MAX_GATE_PIN)
 			break;
 		BUG();
 		break;
@@ -1220,17 +1220,17 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 	case NI_M_Series_Logic_Low_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
-		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {
 			if (ni_m_series_gate_select == NI_M_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= ni_m_series_max_rtsi_channel)
+		if (i <= NI_M_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+		for (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {
 			if (ni_m_series_gate_select == NI_M_PFI_GATE_SEL(i))
 				return NI_GPCT_PFI_GATE_SELECT(i);
 		}
-		if (i <= ni_m_series_max_pfi_channel)
+		if (i <= NI_M_MAX_PFI_CHAN)
 			break;
 		BUG();
 		break;
@@ -1257,17 +1257,17 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 	case NI_660x_Logic_Low_Second_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
-		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+		for (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {
 			if (ni_660x_gate_select == NI_660X_RTSI_GATE2_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
-		if (i <= ni_660x_max_rtsi_channel)
+		if (i <= NI_660X_MAX_RTSI_CHAN)
 			break;
-		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
+		for (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {
 			if (ni_660x_gate_select == NI_660X_UD_PIN_GATE2_SEL(i))
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
 		}
-		if (i <= ni_660x_max_up_down_pin)
+		if (i <= NI_660X_MAX_UP_DOWN_PIN)
 			break;
 		BUG();
 		break;

commit e04460a650e10afb891b941c0a58545b1f2f5963
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:42 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_Up_Down_Pin_Second_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 234761225081..247e3daadadb 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -186,12 +186,7 @@ enum ni_660x_second_gate_select {
 	NI_660x_Logic_Low_Second_Gate_Select = 0x1f,
 };
 static const unsigned ni_660x_max_up_down_pin = 7;
-static inline unsigned NI_660x_Up_Down_Pin_Second_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_up_down_pin);
-	return 0x2 + n;
-}
-
+#define NI_660X_UD_PIN_GATE2_SEL(x)	(0x2 + (x))
 #define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
 
 static const unsigned int counter_status_mask =
@@ -1269,10 +1264,8 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
-			if (ni_660x_gate_select ==
-			    NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
+			if (ni_660x_gate_select == NI_660X_UD_PIN_GATE2_SEL(i))
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_660x_max_up_down_pin)
 			break;

commit ff9a9861154e5f8cebeb981b86ee194cfef00ede
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:41 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_RTSI_Second_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 422052ffda7d..234761225081 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -192,11 +192,7 @@ static inline unsigned NI_660x_Up_Down_Pin_Second_Gate_Select(unsigned n)
 	return 0x2 + n;
 }
 
-static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_rtsi_channel);
-	return 0xb + n;
-}
+#define NI_660X_RTSI_GATE2_SEL(x)	(0xb + (x))
 
 static const unsigned int counter_status_mask =
 	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
@@ -1267,10 +1263,8 @@ ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (ni_660x_gate_select ==
-			    NI_660x_RTSI_Second_Gate_Select(i)) {
+			if (ni_660x_gate_select == NI_660X_RTSI_GATE2_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
 			break;

commit 288cb1a87c63ab4df05936c8842474c9b5530af4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:40 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_RTSI_Clock() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a7cd59b7e8de..422052ffda7d 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -120,11 +120,7 @@ enum ni_660x_clock_source {
 	NI_660x_Logic_Low_Clock = 0x1f,
 };
 static const unsigned ni_660x_max_rtsi_channel = 6;
-static inline unsigned NI_660x_RTSI_Clock(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_rtsi_channel);
-	return 0xb + n;
-}
+#define NI_660X_RTSI_CLK(x)		(0xb + (x))
 
 static const unsigned ni_660x_max_source_pin = 7;
 #define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
@@ -527,7 +523,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
-				ni_660x_clock = NI_660x_RTSI_Clock(i);
+				ni_660x_clock = NI_660X_RTSI_CLK(i);
 				break;
 			}
 		}
@@ -810,7 +806,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (input_select == NI_660x_RTSI_Clock(i)) {
+			if (input_select == NI_660X_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}

commit cdf4fce4211be5af3915a10f2ea9a28d2696c2cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:39 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_Source_Pin_Clock() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ee9c8534fe79..a7cd59b7e8de 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -127,11 +127,7 @@ static inline unsigned NI_660x_RTSI_Clock(unsigned n)
 }
 
 static const unsigned ni_660x_max_source_pin = 7;
-static inline unsigned NI_660x_Source_Pin_Clock(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_source_pin);
-	return 0x2 + n;
-}
+#define NI_660X_SRC_PIN_CLK(x)		(0x2 + (x))
 
 /* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */
 enum ni_m_series_clock_source {
@@ -540,7 +536,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
 			if (clock_select_bits ==
 			    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
-				ni_660x_clock = NI_660x_Source_Pin_Clock(i);
+				ni_660x_clock = NI_660X_SRC_PIN_CLK(i);
 				break;
 			}
 		}
@@ -822,7 +818,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
-			if (input_select == NI_660x_Source_Pin_Clock(i)) {
+			if (input_select == NI_660X_SRC_PIN_CLK(i)) {
 				clock_source =
 				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
 				break;

commit 03c7867123e012d99ffedef885db41579eab1c48
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:38 2014 -0700

    staging: comedi: ni_tio: convert NI_M_Series_PFI_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 60ec33fe100a..ee9c8534fe79 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -173,14 +173,7 @@ enum ni_m_series_gate_select {
 	NI_M_Series_Logic_Low_Gate_Select = 0x1f,
 };
 #define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
-
-static inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_m_series_max_pfi_channel);
-	if (n < 10)
-		return 1 + n;
-	return 0xb + n;
-}
+#define NI_M_PFI_GATE_SEL(x)		(((x) < 10) ? (1 + (x)) : (0xb + (x)))
 
 static inline unsigned Gi_Source_Select_Bits(unsigned source)
 {
@@ -1251,10 +1244,8 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 		if (i <= ni_m_series_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
-			if (ni_m_series_gate_select ==
-			    NI_M_Series_PFI_Gate_Select(i)) {
+			if (ni_m_series_gate_select == NI_M_PFI_GATE_SEL(i))
 				return NI_GPCT_PFI_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_m_series_max_pfi_channel)
 			break;

commit cfd5fed2004c4c48247ae7766f8705ec2438a2ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:37 2014 -0700

    staging: comedi: ni_tio: convert NI_M_Series_RTSI_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1fb9a5c26a32..60ec33fe100a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -172,13 +172,7 @@ enum ni_m_series_gate_select {
 	NI_M_Series_Analog_Trigger_Out_Gate_Select = 0x1e,
 	NI_M_Series_Logic_Low_Gate_Select = 0x1f,
 };
-static inline unsigned NI_M_Series_RTSI_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_m_series_max_rtsi_channel);
-	if (n == 7)
-		return 0x1b;
-	return 0xb + n;
-}
+#define NI_M_RTSI_GATE_SEL(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
 
 static inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)
 {
@@ -1251,10 +1245,8 @@ ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
-			if (ni_m_series_gate_select ==
-			    NI_M_Series_RTSI_Gate_Select(i)) {
+			if (ni_m_series_gate_select == NI_M_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_m_series_max_rtsi_channel)
 			break;

commit 5f8c74429a5f328ab541ddce31d578807e5bcf9c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:36 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_RTSI_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 818519a72f76..1fb9a5c26a32 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -160,12 +160,7 @@ enum ni_660x_gate_select {
 };
 static const unsigned ni_660x_max_gate_pin = 7;
 #define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
-
-static inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_rtsi_channel);
-	return 0xb + n;
-}
+#define NI_660X_RTSI_GATE_SEL(x)	(0xb + (x))
 
 enum ni_m_series_gate_select {
 	NI_M_Series_Timestamp_Mux_Gate_Select = 0x0,
@@ -1215,7 +1210,7 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i))
+			if (ni_660x_gate_select == NI_660X_RTSI_GATE_SEL(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 		}
 		if (i <= ni_660x_max_rtsi_channel)

commit 72f4202f1ff20edfcc34368488d5bd760fac57b6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:35 2014 -0700

    staging: comedi: ni_tio: convert NI_660x_Gate_Pin_Gate_Select() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e6b813489116..818519a72f76 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -159,11 +159,7 @@ enum ni_660x_gate_select {
 	NI_660x_Logic_Low_Gate_Select = 0x1f,
 };
 static const unsigned ni_660x_max_gate_pin = 7;
-static inline unsigned NI_660x_Gate_Pin_Gate_Select(unsigned n)
-{
-	BUG_ON(n > ni_660x_max_gate_pin);
-	return 0x2 + n;
-}
+#define NI_660X_PIN_GATE_SEL(x)		(0x2 + (x))
 
 static inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)
 {
@@ -1225,8 +1221,7 @@ ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
-			if (ni_660x_gate_select ==
-			    NI_660x_Gate_Pin_Gate_Select(i))
+			if (ni_660x_gate_select == NI_660X_PIN_GATE_SEL(i))
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 		}
 		if (i <= ni_660x_max_gate_pin)

commit 1649d56d92ff85b56c7af9b385fa729487277e94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:34 2014 -0700

    staging: comedi: ni_tio: convert NI_M_Series_PFI_Clock() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e1d7d4edb976..e6b813489116 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -146,12 +146,7 @@ enum ni_m_series_clock_source {
 	NI_M_Series_Logic_Low_Clock = 0x1f,
 };
 static const unsigned ni_m_series_max_pfi_channel = 15;
-static inline unsigned NI_M_Series_PFI_Clock(unsigned n)
-{
-	BUG_ON(n > ni_m_series_max_pfi_channel);
-
-	return (n < 10) ? (1 + n) : (0xb + n);
-}
+#define NI_M_PFI_CLK(x)			(((x) < 10) ? (1 + (x)) : (0xb + (x)))
 
 static const unsigned ni_m_series_max_rtsi_channel = 7;
 #define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
@@ -625,7 +620,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
 			if (clock_select_bits == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {
-				ni_m_series_clock = NI_M_Series_PFI_Clock(i);
+				ni_m_series_clock = NI_M_PFI_CLK(i);
 				break;
 			}
 		}
@@ -794,7 +789,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		if (i <= ni_m_series_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
-			if (input_select == NI_M_Series_PFI_Clock(i)) {
+			if (input_select == NI_M_PFI_CLK(i)) {
 				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
 				break;
 			}

commit 9f9d6446b3e962ba65243a869eb2d60baa464344
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:33 2014 -0700

    staging: comedi: ni_tio: convert NI_M_Series_RTSI_Clock() to a macro
    
    The BUG_ON() in this function can never happen.
    
    For aesthetics, rename this CamelCase inline function and convert it into
    a simple macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e613353c6f53..e1d7d4edb976 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -154,12 +154,7 @@ static inline unsigned NI_M_Series_PFI_Clock(unsigned n)
 }
 
 static const unsigned ni_m_series_max_rtsi_channel = 7;
-static inline unsigned NI_M_Series_RTSI_Clock(unsigned n)
-{
-	BUG_ON(n > ni_m_series_max_rtsi_channel);
-
-	return (n == 7) ? 0x1b : (0xb + n);
-}
+#define NI_M_RTSI_CLK(x)		(((x) == 7) ? 0x1b : (0xb + (x)))
 
 enum ni_660x_gate_select {
 	NI_660x_Source_Pin_i_Gate_Select = 0x0,
@@ -622,7 +617,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
-				ni_m_series_clock = NI_M_Series_RTSI_Clock(i);
+				ni_m_series_clock = NI_M_RTSI_CLK(i);
 				break;
 			}
 		}
@@ -791,7 +786,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		break;
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
-			if (input_select == NI_M_Series_RTSI_Clock(i)) {
+			if (input_select == NI_M_RTSI_CLK(i)) {
 				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
 				break;
 			}

commit e09dd2c3c5c9454c0fe93a0165421d2d2027c3dc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:32 2014 -0700

    staging: comedi: ni_tio: tidy up ni_660x_set_first_gate()
    
    Rename some of the local vars and tidy up this function to fix to
    fix a couple > 80 char line issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index fa1ca451d28b..e613353c6f53 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -955,37 +955,33 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 static int ni_660x_set_first_gate(struct ni_gpct *counter,
 				  unsigned int gate_source)
 {
-	const unsigned selected_gate = CR_CHAN(gate_source);
+	unsigned int chan = CR_CHAN(gate_source);
 	unsigned cidx = counter->counter_index;
-	/* bits of selected_gate that may be meaningful to input select register */
-	const unsigned selected_gate_mask = 0x1f;
-	unsigned ni_660x_gate_select;
+	unsigned gate_sel;
 	unsigned i;
 
-	switch (selected_gate) {
+	switch (chan) {
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
-		ni_660x_gate_select = NI_660x_Next_SRC_Gate_Select;
+		gate_sel = NI_660x_Next_SRC_Gate_Select;
 		break;
 	case NI_GPCT_NEXT_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
 	case NI_GPCT_SOURCE_PIN_i_GATE_SELECT:
 	case NI_GPCT_GATE_PIN_i_GATE_SELECT:
-		ni_660x_gate_select = selected_gate & selected_gate_mask;
+		gate_sel = chan & 0x1f;
 		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
-				ni_660x_gate_select =
-				    selected_gate & selected_gate_mask;
+			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
-			if (selected_gate == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
-				ni_660x_gate_select =
-				    selected_gate & selected_gate_mask;
+			if (chan == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
+				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
@@ -994,8 +990,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 		return -EINVAL;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Gate_Select_Mask,
-			Gi_Gate_Select_Bits(ni_660x_gate_select));
+			Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(gate_sel));
 	return 0;
 }
 

commit 7d2a6e548e7137d456d742d3a0df0228861818ec
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:31 2014 -0700

    staging: comedi: ni_tio: tidy up ni_m_series_set_first_gate()
    
    Rename some of the local vars and tidy up this function to fix to
    fix a couple > 80 char line issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index d610902e1e1c..fa1ca451d28b 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1002,14 +1002,12 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 				      unsigned int gate_source)
 {
-	const unsigned selected_gate = CR_CHAN(gate_source);
+	unsigned int chan = CR_CHAN(gate_source);
 	unsigned cidx = counter->counter_index;
-	/* bits of selected_gate that may be meaningful to input select register */
-	const unsigned selected_gate_mask = 0x1f;
-	unsigned ni_m_series_gate_select;
+	unsigned gate_sel;
 	unsigned i;
 
-	switch (selected_gate) {
+	switch (chan) {
 	case NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:
 	case NI_GPCT_AI_START2_GATE_SELECT:
 	case NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT:
@@ -1018,22 +1016,20 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
 	case NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
-		ni_m_series_gate_select = selected_gate & selected_gate_mask;
+		gate_sel = chan & 0x1f;
 		break;
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
-			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
-				ni_m_series_gate_select =
-				    selected_gate & selected_gate_mask;
+			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
 		if (i <= ni_m_series_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
-			if (selected_gate == NI_GPCT_PFI_GATE_SELECT(i)) {
-				ni_m_series_gate_select =
-				    selected_gate & selected_gate_mask;
+			if (chan == NI_GPCT_PFI_GATE_SELECT(i)) {
+				gate_sel = chan & 0x1f;
 				break;
 			}
 		}
@@ -1042,8 +1038,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		return -EINVAL;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Gate_Select_Mask,
-			Gi_Gate_Select_Bits(ni_m_series_gate_select));
+			Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(gate_sel));
 	return 0;
 }
 

commit 552050532721c17d729abc4a9a655e9ac37b9338
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:30 2014 -0700

    staging: comedi: ni_tio: tidy up ni_660x_set_second_gate()
    
    Rename some of the local vars and tidy up this function to fix to
    fix a couple > 80 char line issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index c876273a80f4..d610902e1e1c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1052,43 +1052,34 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
-	const unsigned selected_second_gate = CR_CHAN(gate_source);
-	/* bits of second_gate that may be meaningful to second gate register */
-	static const unsigned selected_second_gate_mask = 0x1f;
-	unsigned ni_660x_second_gate_select;
+	unsigned int chan = CR_CHAN(gate_source);
+	unsigned gate2_reg = NITIO_GATE2_REG(cidx);
+	unsigned gate2_sel;
 	unsigned i;
 
-	switch (selected_second_gate) {
+	switch (chan) {
 	case NI_GPCT_SOURCE_PIN_i_GATE_SELECT:
 	case NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT:
 	case NI_GPCT_SELECTED_GATE_GATE_SELECT:
 	case NI_GPCT_NEXT_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
-		ni_660x_second_gate_select =
-		    selected_second_gate & selected_second_gate_mask;
+		gate2_sel = chan & 0x1f;
 		break;
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
-		ni_660x_second_gate_select =
-		    NI_660x_Next_SRC_Second_Gate_Select;
+		gate2_sel = NI_660x_Next_SRC_Second_Gate_Select;
 		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (selected_second_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
-				ni_660x_second_gate_select =
-				    selected_second_gate &
-				    selected_second_gate_mask;
+			if (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				gate2_sel = chan & 0x1f;
 				break;
 			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
-			if (selected_second_gate ==
-			    NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
-				ni_660x_second_gate_select =
-				    selected_second_gate &
-				    selected_second_gate_mask;
+			if (chan == NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
+				gate2_sel = chan & 0x1f;
 				break;
 			}
 		}
@@ -1096,12 +1087,10 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 			break;
 		return -EINVAL;
 	}
-	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
-	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
-	counter_dev->regs[second_gate_reg] |=
-	    Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
-	write_register(counter, counter_dev->regs[second_gate_reg],
-		       second_gate_reg);
+	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Mode_Bit;
+	counter_dev->regs[gate2_reg] &= ~Gi_Second_Gate_Select_Mask;
+	counter_dev->regs[gate2_reg] |= Gi_Second_Gate_Select_Bits(gate2_sel);
+	write_register(counter, counter_dev->regs[gate2_reg], gate2_reg);
 	return 0;
 }
 

commit 856031614ef3e848f5c60b5c098d365e200d0d20
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:29 2014 -0700

    staging: comedi: ni_tio: remove unnecessary ni_gpct_variant BUG() cases
    
    The enum ni_gpct_variant is used to handle hardware variations in the
    gpct timers handled by this driver. This enum is defined as:
    
    enum ni_gpct_variant {
            ni_gpct_variant_e_series,
            ni_gpct_variant_m_series,
            ni_gpct_variant_660x
    };
    
    For all the switch statements where all three enum values are handled,
    remove the unreachable BUG(). Move the default case so it is handled
    the same as ni_gpct_variant_e_series.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 49ffb508de00..c876273a80f4 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -58,16 +58,13 @@ Gi_Alternate_Sync_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
+	default:
 		return 0;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Alternate_Sync_Bit;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Alternate_Sync_Bit;
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 static inline enum Gi_Counting_Mode_Reg_Bits
@@ -75,16 +72,13 @@ Gi_Prescale_X2_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
+	default:
 		return 0;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Prescale_X2_Bit;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Prescale_X2_Bit;
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 static inline enum Gi_Counting_Mode_Reg_Bits
@@ -92,16 +86,13 @@ Gi_Prescale_X8_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
+	default:
 		return 0;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Prescale_X8_Bit;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Prescale_X8_Bit;
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 static inline enum Gi_Counting_Mode_Reg_Bits
@@ -109,16 +100,13 @@ Gi_HW_Arm_Select_Mask(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
+	default:
 		return 0;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_HW_Arm_Select_Mask;
 	case ni_gpct_variant_660x:
 		return Gi_660x_HW_Arm_Select_Mask;
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 /* clock sources for ni_660x boards, get bits with Gi_Source_Select_Bits() */
@@ -304,15 +292,12 @@ ni_tio_second_gate_registers_present(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
+	default:
 		return 0;
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		return 1;
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
@@ -704,12 +689,10 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 		break;
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
+	default:
 		input_select_bits |=
 		    ni_m_series_source_select_bits(clock_source);
 		break;
-	default:
-		BUG();
-		break;
 	}
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		input_select_bits |= Gi_Source_Polarity_Bit;
@@ -891,14 +874,11 @@ static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
+	default:
 		return ni_m_series_clock_src_select(counter);
 	case ni_gpct_variant_660x:
 		return ni_660x_clock_src_select(counter);
-	default:
-		BUG();
-		break;
 	}
-	return 0;
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
@@ -1174,12 +1154,10 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
+		default:
 			return ni_m_series_set_first_gate(counter, gate_source);
 		case ni_gpct_variant_660x:
 			return ni_660x_set_first_gate(counter, gate_source);
-		default:
-			BUG();
-			break;
 		}
 		break;
 	case 1:
@@ -1415,6 +1393,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
+		default:
 			*gate_source =
 			    ni_m_series_first_gate_to_generic_gate_source
 			    (gate_select_bits);
@@ -1424,9 +1403,6 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			    ni_660x_first_gate_to_generic_gate_source
 			    (gate_select_bits);
 			break;
-		default:
-			BUG();
-			break;
 		}
 		if (mode_bits & Gi_Gate_Polarity_Bit)
 			*gate_source |= CR_INVERT;
@@ -1448,6 +1424,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
+		default:
 			*gate_source =
 			    ni_m_series_second_gate_to_generic_gate_source
 			    (gate_select_bits);
@@ -1457,9 +1434,6 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			    ni_660x_second_gate_to_generic_gate_source
 			    (gate_select_bits);
 			break;
-		default:
-			BUG();
-			break;
 		}
 		if (counter_dev->regs[second_gate_reg] &
 		    Gi_Second_Gate_Polarity_Bit) {

commit 347208efa7928cafc8ff54be3d25f0dc695ed91d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:28 2014 -0700

    staging: comedi: ni_tio: tidy up some function declarations
    
    Fix the whitespace in some of the function declarations to avoid
    the ugly line breaks and fix a couple checkpatch.pl issues:
    
    WARNING: line over 80 characters
    WARNING: Unnecessary space before function pointer arguments
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 8b56397173a3..49ffb508de00 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -53,9 +53,8 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 				       unsigned generic_clock_source);
 static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
 
-static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
-								   ni_gpct_variant
-								   variant)
+static inline enum Gi_Counting_Mode_Reg_Bits
+Gi_Alternate_Sync_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -71,9 +70,8 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
 	return 0;
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
-								ni_gpct_variant
-								variant)
+static inline enum Gi_Counting_Mode_Reg_Bits
+Gi_Prescale_X2_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -89,9 +87,8 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
 	return 0;
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
-								ni_gpct_variant
-								variant)
+static inline enum Gi_Counting_Mode_Reg_Bits
+Gi_Prescale_X8_Bit(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -107,9 +104,8 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
 	return 0;
 }
 
-static inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum
-								   ni_gpct_variant
-								   variant)
+static inline enum Gi_Counting_Mode_Reg_Bits
+Gi_HW_Arm_Select_Mask(enum ni_gpct_variant variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -257,21 +253,15 @@ static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 static const unsigned int counter_status_mask =
 	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
-struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
-						void (*write_register) (struct
-									ni_gpct
-									*
-									counter,
-									unsigned
-									bits,
-									enum
-									ni_gpct_register
-									reg),
-						unsigned (*read_register)
-						(struct ni_gpct *counter,
-						 enum ni_gpct_register reg),
-						enum ni_gpct_variant variant,
-						unsigned num_counters)
+struct ni_gpct_device *
+ni_gpct_device_construct(struct comedi_device *dev,
+			 void (*write_register)(struct ni_gpct *counter,
+						unsigned bits,
+						enum ni_gpct_register reg),
+			 unsigned (*read_register)(struct ni_gpct *counter,
+						   enum ni_gpct_register reg),
+			 enum ni_gpct_variant variant,
+			 unsigned num_counters)
 {
 	unsigned i;
 
@@ -309,8 +299,8 @@ void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 }
 EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);
 
-static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
-						*counter_dev)
+static int
+ni_tio_second_gate_registers_present(const struct ni_gpct_device *counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -1264,8 +1254,8 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 	return -EINVAL;
 }
 
-static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
-							  ni_660x_gate_select)
+static unsigned
+ni_660x_first_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1300,8 +1290,8 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 	return 0;
 };
 
-static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
-							      ni_m_series_gate_select)
+static unsigned
+ni_m_series_first_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 {
 	unsigned i;
 
@@ -1345,8 +1335,8 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 	return 0;
 };
 
-static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
-							   ni_660x_gate_select)
+static unsigned
+ni_660x_second_gate_to_generic_gate_source(unsigned ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1386,8 +1376,8 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 	return 0;
 };
 
-static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
-							       ni_m_series_gate_select)
+static unsigned
+ni_m_series_second_gate_to_generic_gate_source(unsigned ni_m_series_gate_select)
 {
 	/*
 	 * FIXME: the second gate sources for the m series are undocumented,

commit 14f194a9359acd606f43c861559b71ea91cf3224
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:27 2014 -0700

    staging: comedi: ni_tio: fix > 80 char comments
    
    Tidy up some of the comments to fix some fo the the checkpatch.pl
    warnings:
    
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index da6602392fb3..8b56397173a3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -413,9 +413,11 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	default:
 		break;
 	}
-	/* It's not clear what we should do if clock_period is unknown, so we are not
-	   using the alt sync bit in that case, but allow the caller to decide by using the
-	   force_alt_sync parameter. */
+	/*
+	 * It's not clear what we should do if clock_period is unknown, so we
+	 * are not using the alt sync bit in that case, but allow the caller
+	 * to decide by using the force_alt_sync parameter.
+	 */
 	if (force_alt_sync ||
 	    (clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {
 		ni_tio_set_bits(counter, counting_mode_reg,
@@ -520,7 +522,11 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 				break;
 			default:
 				if (start_trigger & NI_GPCT_ARM_UNKNOWN) {
-					/* pass-through the least significant bits so we can figure out what select later */
+					/*
+					 * pass-through the least significant
+					 * bits so we can figure out what
+					 * select later
+					 */
 					unsigned hw_arm_select_bits =
 					    (start_trigger <<
 					     Gi_HW_Arm_Select_Shift) &
@@ -924,7 +930,10 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 		clock_period_ps = 100000;
 		break;
 	default:
-		/* clock period is specified by user with prescaling already taken into account. */
+		/*
+		 * clock period is specified by user with prescaling
+		 * already taken into account.
+		 */
 		return counter->clock_period_ps;
 	}
 
@@ -1137,8 +1146,10 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 	static const unsigned selected_second_gate_mask = 0x1f;
 	unsigned ni_m_series_second_gate_select;
 
-	/* FIXME: We don't know what the m-series second gate codes are, so we'll just pass
-	   the bits through for now. */
+	/*
+	 * FIXME: We don't know what the m-series second gate codes are,
+	 * so we'll just pass the bits through for now.
+	 */
 	switch (selected_second_gate) {
 	default:
 		ni_m_series_second_gate_select =
@@ -1378,8 +1389,10 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
 							       ni_m_series_gate_select)
 {
-	/*FIXME: the second gate sources for the m series are undocumented, so we just return
-	 * the raw bits for now. */
+	/*
+	 * FIXME: the second gate sources for the m series are undocumented,
+	 * so we just return the raw bits for now.
+	 */
 	switch (ni_m_series_gate_select) {
 	default:
 		return ni_m_series_gate_select;
@@ -1598,13 +1611,20 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		return 0;
 	switch (channel) {
 	case 0:
-		/* Unsafe if counter is armed.  Should probably check status and return -EBUSY if armed. */
-		/* Don't disturb load source select, just use whichever load register is already selected. */
+		/*
+		 * Unsafe if counter is armed.
+		 * Should probably check status and return -EBUSY if armed.
+		 */
+
+		/*
+		 * Don't disturb load source select, just use whichever
+		 * load register is already selected.
+		 */
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 					  0, 0, Gi_Load_Bit);
-		/* restore state of load reg to whatever the user set last set it to */
+		/* restore load reg */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:

commit 27c4d23cb070fd83f5705aabfad8d277fed9e022
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 24 10:14:26 2014 -0700

    staging: comedi: ni_tio: fix ni_tio_insn_read()
    
    The comedi core expects the (*insn_read) operations to read insn->n
    values and return the number of values read.
    
    Fix this function to work line the core expects.
    
    For aesthetics, factor out the code that reads the SM_Save_Reg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 694bd5142cc5..da6602392fb3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1512,6 +1512,38 @@ int ni_tio_insn_config(struct comedi_device *dev,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_config);
 
+static unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,
+					    struct comedi_subdevice *s)
+{
+	struct ni_gpct *counter = s->private;
+	unsigned cidx = counter->counter_index;
+	unsigned int first_read;
+	unsigned int second_read;
+	unsigned int correct_read;
+
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), Gi_Save_Trace_Bit, 0);
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
+			Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
+
+	/*
+	 * The count doesn't get latched until the next clock edge, so it is
+	 * possible the count may change (once) while we are reading. Since
+	 * the read of the SW_Save_Reg isn't atomic (apparently even when it's
+	 * a 32 bit register according to 660x docs), we need to read twice
+	 * and make sure the reading hasn't changed. If it has, a third read
+	 * will be correct since the count value will definitely have latched
+	 * by then.
+	 */
+	first_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+	second_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+	if (first_read != second_read)
+		correct_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+	else
+		correct_read = first_read;
+
+	return correct_read;
+}
+
 int ni_tio_insn_read(struct comedi_device *dev,
 		     struct comedi_subdevice *s,
 		     struct comedi_insn *insn,
@@ -1519,42 +1551,24 @@ int ni_tio_insn_read(struct comedi_device *dev,
 {
 	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned channel = CR_CHAN(insn->chanspec);
+	unsigned int channel = CR_CHAN(insn->chanspec);
 	unsigned cidx = counter->counter_index;
-	unsigned first_read;
-	unsigned second_read;
-	unsigned correct_read;
+	int i;
 
-	if (insn->n < 1)
-		return 0;
-	switch (channel) {
-	case 0:
-		ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-				Gi_Save_Trace_Bit, 0);
-		ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
-				Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
-		/* The count doesn't get latched until the next clock edge, so it is possible the count
-		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
-		   atomic (apparently even when it's a 32 bit register according to 660x docs),
-		   we need to read twice and make sure the reading hasn't changed.  If it has,
-		   a third read will be correct since the count value will definitely have latched by then. */
-		first_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-		second_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
-		if (first_read != second_read)
-			correct_read =
-			    read_register(counter, NITIO_SW_SAVE_REG(cidx));
-		else
-			correct_read = first_read;
-		data[0] = correct_read;
-		return 0;
-	case 1:
-		data[0] = counter_dev->regs[NITIO_LOADA_REG(cidx)];
-		break;
-	case 2:
-		data[0] = counter_dev->regs[NITIO_LOADB_REG(cidx)];
-		break;
+	for (i = 0; i < insn->n; i++) {
+		switch (channel) {
+		case 0:
+			data[i] = ni_tio_read_sw_save_reg(dev, s);
+			break;
+		case 1:
+			data[i] = counter_dev->regs[NITIO_LOADA_REG(cidx)];
+			break;
+		case 2:
+			data[i] = counter_dev->regs[NITIO_LOADB_REG(cidx)];
+			break;
+		}
 	}
-	return 0;
+	return insn->n;
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_read);
 

commit 2b28a540dec5cb39499f79b93787c1655cc650e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:22:57 2014 -0700

    staging: comedi: ni_tio: checkpatch.pl cleanup (braces not necessary)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: braces {} are not necessary for single statement blocks
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 0ac9fbf170f5..694bd5142cc5 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1271,17 +1271,15 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
-			if (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i)) {
+			if (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i))
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
 			break;
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
 			if (ni_660x_gate_select ==
-			    NI_660x_Gate_Pin_Gate_Select(i)) {
+			    NI_660x_Gate_Pin_Gate_Select(i))
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
-			}
 		}
 		if (i <= ni_660x_max_gate_pin)
 			break;

commit 4318d1d3cd285a4eefeb65a29b62c0d715d5f114
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:02:10 2014 -0700

    staging: comedi: ni_tio: checkpatch.pl cleanup (missing blank line)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1a5bb2353de3..0ac9fbf170f5 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -463,6 +463,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		unsigned counting_mode_bits = 0;
+
 		counting_mode_bits |=
 		    (mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
 		    Gi_Counting_Mode_Mask;

commit 89660697cbbb976e471f71232b6ebcec79d95f06
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:38 2014 -0700

    staging: comedi: ni_tio: checkpatch.pl cleanup (else is not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a25e2f5d83ab..1a5bb2353de3 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -165,20 +165,16 @@ static const unsigned ni_m_series_max_pfi_channel = 15;
 static inline unsigned NI_M_Series_PFI_Clock(unsigned n)
 {
 	BUG_ON(n > ni_m_series_max_pfi_channel);
-	if (n < 10)
-		return 1 + n;
-	else
-		return 0xb + n;
+
+	return (n < 10) ? (1 + n) : (0xb + n);
 }
 
 static const unsigned ni_m_series_max_rtsi_channel = 7;
 static inline unsigned NI_M_Series_RTSI_Clock(unsigned n)
 {
 	BUG_ON(n > ni_m_series_max_rtsi_channel);
-	if (n == 7)
-		return 0x1b;
-	else
-		return 0xb + n;
+
+	return (n == 7) ? 0x1b : (0xb + n);
 }
 
 enum ni_660x_gate_select {
@@ -1408,12 +1404,12 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		    Gi_Gating_Disabled_Bits) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
-		} else {
-			gate_select_bits =
-			    (ni_tio_get_soft_copy(counter,
-						  NITIO_INPUT_SEL_REG(cidx)) &
-			     Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
 		}
+
+		gate_select_bits =
+		    (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+			Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
+
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
@@ -1442,12 +1438,11 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		    == 0) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
-		} else {
-			gate_select_bits =
-			    (counter_dev->regs[second_gate_reg] &
-			     Gi_Second_Gate_Select_Mask) >>
-			    Gi_Second_Gate_Select_Shift;
 		}
+
+		gate_select_bits = (counter_dev->regs[second_gate_reg] &
+				Gi_Second_Gate_Select_Mask) >>
+				Gi_Second_Gate_Select_Shift;
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
@@ -1570,10 +1565,9 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	const unsigned bits =
 		read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
 
-	if (bits & Gi_Next_Load_Source_Bit(cidx))
-		return NITIO_LOADB_REG(cidx);
-	else
-		return NITIO_LOADA_REG(cidx);
+	return (bits & Gi_Next_Load_Source_Bit(cidx))
+			? NITIO_LOADB_REG(cidx)
+			: NITIO_LOADA_REG(cidx);
 }
 
 int ni_tio_insn_write(struct comedi_device *dev,

commit 9bad91337cacc7dcc857a9604e498025d4cc19e9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:37 2014 -0700

    staging: comedi: ni_tio: checkpatch.pl cleanup (break is not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 92691b491c24..a25e2f5d83ab 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -60,13 +60,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 		return 0;
-		break;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Alternate_Sync_Bit;
-		break;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Alternate_Sync_Bit;
-		break;
 	default:
 		BUG();
 		break;
@@ -81,13 +78,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 		return 0;
-		break;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Prescale_X2_Bit;
-		break;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Prescale_X2_Bit;
-		break;
 	default:
 		BUG();
 		break;
@@ -102,13 +96,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 		return 0;
-		break;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_Prescale_X8_Bit;
-		break;
 	case ni_gpct_variant_660x:
 		return Gi_660x_Prescale_X8_Bit;
-		break;
 	default:
 		BUG();
 		break;
@@ -123,13 +114,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum
 	switch (variant) {
 	case ni_gpct_variant_e_series:
 		return 0;
-		break;
 	case ni_gpct_variant_m_series:
 		return Gi_M_Series_HW_Arm_Select_Mask;
-		break;
 	case ni_gpct_variant_660x:
 		return Gi_660x_HW_Arm_Select_Mask;
-		break;
 	default:
 		BUG();
 		break;
@@ -331,11 +319,9 @@ static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 		return 0;
-		break;
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		return 1;
-		break;
 	default:
 		BUG();
 		break;
@@ -704,7 +690,6 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 		/* Gi_Source_Subselect doesn't matter */
 	default:
 		return;
-		break;
 	}
 	write_register(counter, counter_dev->regs[second_gate_reg],
 		       second_gate_reg);
@@ -757,7 +742,6 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 				Gi_Prescale_X2_Bit(counter_dev->variant) |
@@ -915,10 +899,8 @@ static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 		return ni_m_series_clock_src_select(counter);
-		break;
 	case ni_gpct_variant_660x:
 		return ni_660x_clock_src_select(counter);
-		break;
 	default:
 		BUG();
 		break;
@@ -947,7 +929,6 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 	default:
 		/* clock period is specified by user with prescaling already taken into account. */
 		return counter->clock_period_ps;
-		break;
 	}
 
 	switch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {
@@ -1035,7 +1016,6 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 		if (i <= ni_660x_max_gate_pin)
 			break;
 		return -EINVAL;
-		break;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Gate_Select_Mask,
@@ -1084,7 +1064,6 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
 		return -EINVAL;
-		break;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Gate_Select_Mask,
@@ -1140,7 +1119,6 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 		if (i <= ni_660x_max_up_down_pin)
 			break;
 		return -EINVAL;
-		break;
 	}
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
@@ -1199,10 +1177,8 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			return ni_m_series_set_first_gate(counter, gate_source);
-			break;
 		case ni_gpct_variant_660x:
 			return ni_660x_set_first_gate(counter, gate_source);
-			break;
 		default:
 			BUG();
 			break;
@@ -1230,10 +1206,8 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		case ni_gpct_variant_m_series:
 			return ni_m_series_set_second_gate(counter,
 							   gate_source);
-			break;
 		case ni_gpct_variant_660x:
 			return ni_660x_set_second_gate(counter, gate_source);
-			break;
 		default:
 			BUG();
 			break;
@@ -1241,7 +1215,6 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 0;
 }
@@ -1269,7 +1242,6 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 			break;
 		default:
 			return -EINVAL;
-			break;
 		}
 		mask = 0x1f << shift;
 		if (source > 0x1f) {
@@ -1292,24 +1264,18 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 	switch (ni_660x_gate_select) {
 	case NI_660x_Source_Pin_i_Gate_Select:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
-		break;
 	case NI_660x_Gate_Pin_i_Gate_Select:
 		return NI_GPCT_GATE_PIN_i_GATE_SELECT;
-		break;
 	case NI_660x_Next_SRC_Gate_Select:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-		break;
 	case NI_660x_Next_Out_Gate_Select:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-		break;
 	case NI_660x_Logic_Low_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
-		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
@@ -1318,7 +1284,6 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 			if (ni_660x_gate_select ==
 			    NI_660x_Gate_Pin_Gate_Select(i)) {
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_660x_max_gate_pin)
@@ -1337,34 +1302,25 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 	switch (ni_m_series_gate_select) {
 	case NI_M_Series_Timestamp_Mux_Gate_Select:
 		return NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
-		break;
 	case NI_M_Series_AI_START2_Gate_Select:
 		return NI_GPCT_AI_START2_GATE_SELECT;
-		break;
 	case NI_M_Series_PXI_Star_Trigger_Gate_Select:
 		return NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;
-		break;
 	case NI_M_Series_Next_Out_Gate_Select:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-		break;
 	case NI_M_Series_AI_START1_Gate_Select:
 		return NI_GPCT_AI_START1_GATE_SELECT;
-		break;
 	case NI_M_Series_Next_SRC_Gate_Select:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-		break;
 	case NI_M_Series_Analog_Trigger_Out_Gate_Select:
 		return NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;
-		break;
 	case NI_M_Series_Logic_Low_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
-		break;
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (ni_m_series_gate_select ==
 			    NI_M_Series_RTSI_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_m_series_max_rtsi_channel)
@@ -1373,7 +1329,6 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 			if (ni_m_series_gate_select ==
 			    NI_M_Series_PFI_Gate_Select(i)) {
 				return NI_GPCT_PFI_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_m_series_max_pfi_channel)
@@ -1392,28 +1347,21 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 	switch (ni_660x_gate_select) {
 	case NI_660x_Source_Pin_i_Second_Gate_Select:
 		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
-		break;
 	case NI_660x_Up_Down_Pin_i_Second_Gate_Select:
 		return NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;
-		break;
 	case NI_660x_Next_SRC_Second_Gate_Select:
 		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
-		break;
 	case NI_660x_Next_Out_Second_Gate_Select:
 		return NI_GPCT_NEXT_OUT_GATE_SELECT;
-		break;
 	case NI_660x_Selected_Gate_Second_Gate_Select:
 		return NI_GPCT_SELECTED_GATE_GATE_SELECT;
-		break;
 	case NI_660x_Logic_Low_Second_Gate_Select:
 		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
-		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (ni_660x_gate_select ==
 			    NI_660x_RTSI_Second_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_660x_max_rtsi_channel)
@@ -1422,7 +1370,6 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 			if (ni_660x_gate_select ==
 			    NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
-				break;
 			}
 		}
 		if (i <= ni_660x_max_up_down_pin)
@@ -1441,7 +1388,6 @@ static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
 	switch (ni_m_series_gate_select) {
 	default:
 		return ni_m_series_gate_select;
-		break;
 	}
 	return 0;
 };
@@ -1528,7 +1474,6 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 0;
 }
@@ -1543,39 +1488,29 @@ int ni_tio_insn_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
 		return ni_tio_set_counter_mode(counter, data[1]);
-		break;
 	case INSN_CONFIG_ARM:
 		return ni_tio_arm(counter, 1, data[1]);
-		break;
 	case INSN_CONFIG_DISARM:
 		ni_tio_arm(counter, 0, 0);
 		return 0;
-		break;
 	case INSN_CONFIG_GET_COUNTER_STATUS:
 		data[1] = ni_tio_counter_status(counter);
 		data[2] = counter_status_mask;
 		return 0;
-		break;
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		return ni_tio_set_clock_src(counter, data[1], data[2]);
-		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
 		ni_tio_get_clock_src(counter, &data[1], &data[2]);
 		return 0;
-		break;
 	case INSN_CONFIG_SET_GATE_SRC:
 		return ni_tio_set_gate_src(counter, data[1], data[2]);
-		break;
 	case INSN_CONFIG_GET_GATE_SRC:
 		return ni_tio_get_gate_src(counter, data[1], &data[2]);
-		break;
 	case INSN_CONFIG_SET_OTHER_SRC:
 		return ni_tio_set_other_src(counter, data[1], data[2]);
-		break;
 	case INSN_CONFIG_RESET:
 		ni_tio_reset_count_and_disarm(counter);
 		return 0;
-		break;
 	default:
 		break;
 	}
@@ -1618,7 +1553,6 @@ int ni_tio_insn_read(struct comedi_device *dev,
 			correct_read = first_read;
 		data[0] = correct_read;
 		return 0;
-		break;
 	case 1:
 		data[0] = counter_dev->regs[NITIO_LOADA_REG(cidx)];
 		break;
@@ -1676,7 +1610,6 @@ int ni_tio_insn_write(struct comedi_device *dev,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return 0;
 }

commit cac04c0f68a2d1c4ebf505f9b7626e194d40c0c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:02 2013 -0700

    staging: comedi: ni_tio: make ni_tio_insn_config() a proper comedi (*insn_config)
    
    Change the parameters to ni_tio_insn_config() to make it a proper comedi
    (*insn_config) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 1f78c1d5e2e6..92691b491c24 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1533,9 +1533,13 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	return 0;
 }
 
-int ni_tio_insn_config(struct ni_gpct *counter,
-		       struct comedi_insn *insn, unsigned int *data)
+int ni_tio_insn_config(struct comedi_device *dev,
+		       struct comedi_subdevice *s,
+		       struct comedi_insn *insn,
+		       unsigned int *data)
 {
+	struct ni_gpct *counter = s->private;
+
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
 		return ni_tio_set_counter_mode(counter, data[1]);

commit 10f74377eec3318a63a3693e6e6d13af55c25624
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:01 2013 -0700

    staging: comedi: ni_tio: make ni_tio_winsn() a proper comedi (*insn_write)
    
    Change the parameters to ni_tio_winsn() to make it a proper comedi
    (*insn_write) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    For aesthetics, rename the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 9d0031dcad28..1f78c1d5e2e6 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1638,9 +1638,12 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 		return NITIO_LOADA_REG(cidx);
 }
 
-int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
-		 unsigned int *data)
+int ni_tio_insn_write(struct comedi_device *dev,
+		      struct comedi_subdevice *s,
+		      struct comedi_insn *insn,
+		      unsigned int *data)
 {
+	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
 	unsigned cidx = counter->counter_index;
@@ -1673,7 +1676,7 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(ni_tio_winsn);
+EXPORT_SYMBOL_GPL(ni_tio_insn_write);
 
 static int __init ni_tio_init_module(void)
 {

commit 9014d816e549d562a3566f8eed6e537500f2cfd1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:00 2013 -0700

    staging: comedi: ni_tio: make ni_tio_rinsn() a proper comedi (*insn_read)
    
    Change the parameters to ni_tio_rinsn() to make is a proper comedi
    (*insn_read) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    For aesthetics, rename the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index e00bdda8e698..9d0031dcad28 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1579,9 +1579,12 @@ int ni_tio_insn_config(struct ni_gpct *counter,
 }
 EXPORT_SYMBOL_GPL(ni_tio_insn_config);
 
-int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
-		 unsigned int *data)
+int ni_tio_insn_read(struct comedi_device *dev,
+		     struct comedi_subdevice *s,
+		     struct comedi_insn *insn,
+		     unsigned int *data)
 {
+	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
 	unsigned cidx = counter->counter_index;
@@ -1621,7 +1624,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(ni_tio_rinsn);
+EXPORT_SYMBOL_GPL(ni_tio_insn_read);
 
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {

commit f688d4a763852ae076bbdb0e064acee9dae7e593
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:57 2013 -0700

    staging: comedi: ni_tio: move the MODULE_* stuff to the end of file
    
    For aesthetics, move all the MODULE_* information to the end of the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index b310a1e40c50..e00bdda8e698 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -53,10 +53,6 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 				       unsigned generic_clock_source);
 static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
 
-MODULE_AUTHOR("Comedi <comedi@comedi.org>");
-MODULE_DESCRIPTION("Comedi support for NI general-purpose counters");
-MODULE_LICENSE("GPL");
-
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
 								   ni_gpct_variant
 								   variant)
@@ -277,19 +273,6 @@ static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 static const unsigned int counter_status_mask =
 	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
-static int __init ni_tio_init_module(void)
-{
-	return 0;
-}
-
-module_init(ni_tio_init_module);
-
-static void __exit ni_tio_cleanup_module(void)
-{
-}
-
-module_exit(ni_tio_cleanup_module);
-
 struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
 						void (*write_register) (struct
 									ni_gpct
@@ -1688,3 +1671,18 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_winsn);
+
+static int __init ni_tio_init_module(void)
+{
+	return 0;
+}
+module_init(ni_tio_init_module);
+
+static void __exit ni_tio_cleanup_module(void)
+{
+}
+module_exit(ni_tio_cleanup_module);
+
+MODULE_AUTHOR("Comedi <comedi@comedi.org>");
+MODULE_DESCRIPTION("Comedi support for NI general-purpose counters");
+MODULE_LICENSE("GPL");

commit fca7c1d753504a0679e4a9033382caa25259c9ed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:55 2013 -0700

    staging: comedi: ni_tio: use a local var for the 'counter_index'
    
    Use a local variable for the 'counter->counter_index' to help shorten the
    long lines and ugly line breaks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index ed55885b5918..b310a1e40c50 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -362,74 +362,64 @@ static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
 
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
-	write_register(counter, Gi_Reset_Bit(counter->counter_index),
-		       NITIO_RESET_REG(counter->counter_index));
+	unsigned cidx = counter->counter_index;
+
+	write_register(counter, Gi_Reset_Bit(cidx), NITIO_RESET_REG(cidx));
 }
 
 void ni_tio_init_counter(struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 
 	ni_tio_reset_count_and_disarm(counter);
+
 	/* initialize counter registers */
-	counter_dev->regs[NITIO_AUTO_INC_REG(counter->counter_index)] =
-	    0x0;
-	write_register(counter,
-		       counter_dev->
-		       regs[NITIO_AUTO_INC_REG(counter->counter_index)],
-		       NITIO_AUTO_INC_REG(counter->counter_index));
-	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
+	counter_dev->regs[NITIO_AUTO_INC_REG(cidx)] = 0x0;
+	write_register(counter, counter_dev->regs[NITIO_AUTO_INC_REG(cidx)],
+		       NITIO_AUTO_INC_REG(cidx));
+
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
 			~0, Gi_Synchronize_Gate_Bit);
-	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index), ~0,
-			0);
-	counter_dev->regs[NITIO_LOADA_REG(counter->counter_index)] = 0x0;
-	write_register(counter,
-		       counter_dev->
-		       regs[NITIO_LOADA_REG(counter->counter_index)],
-		       NITIO_LOADA_REG(counter->counter_index));
-	counter_dev->regs[NITIO_LOADB_REG(counter->counter_index)] = 0x0;
-	write_register(counter,
-		       counter_dev->
-		       regs[NITIO_LOADB_REG(counter->counter_index)],
-		       NITIO_LOADB_REG(counter->counter_index));
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index), ~0,
-			0);
-	if (ni_tio_counting_mode_registers_present(counter_dev)) {
-		ni_tio_set_bits(counter,
-				NITIO_CNT_MODE_REG(counter->
-							   counter_index), ~0,
-				0);
-	}
+
+	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);
+
+	counter_dev->regs[NITIO_LOADA_REG(cidx)] = 0x0;
+	write_register(counter, counter_dev->regs[NITIO_LOADA_REG(cidx)],
+		       NITIO_LOADA_REG(cidx));
+
+	counter_dev->regs[NITIO_LOADB_REG(cidx)] = 0x0;
+	write_register(counter, counter_dev->regs[NITIO_LOADB_REG(cidx)],
+		       NITIO_LOADB_REG(cidx));
+
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);
+
+	if (ni_tio_counting_mode_registers_present(counter_dev))
+		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);
+
 	if (ni_tio_second_gate_registers_present(counter_dev)) {
-		counter_dev->
-		    regs[NITIO_GATE2_REG(counter->counter_index)] =
-		    0x0;
+		counter_dev->regs[NITIO_GATE2_REG(cidx)] = 0x0;
 		write_register(counter,
-			       counter_dev->
-			       regs[NITIO_GATE2_REG
-				    (counter->counter_index)],
-			       NITIO_GATE2_REG(counter->
-							counter_index));
+			       counter_dev->regs[NITIO_GATE2_REG(cidx)],
+			       NITIO_GATE2_REG(cidx));
 	}
-	ni_tio_set_bits(counter,
-			NITIO_DMA_CFG_REG(counter->counter_index), ~0,
-			0x0);
-	ni_tio_set_bits(counter,
-			NITIO_INT_ENA_REG(counter->counter_index),
-			~0, 0x0);
+
+	ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);
+
+	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx), ~0, 0x0);
 }
 EXPORT_SYMBOL_GPL(ni_tio_init_counter);
 
 static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
-	unsigned int status = 0;
+	unsigned cidx = counter->counter_index;
 	const unsigned bits = read_register(counter,
-					    NITIO_SHARED_STATUS_REG(counter->
-								 counter_index));
-	if (bits & Gi_Armed_Bit(counter->counter_index)) {
+					    NITIO_SHARED_STATUS_REG(cidx));
+	unsigned int status = 0;
+
+	if (bits & Gi_Armed_Bit(cidx)) {
 		status |= COMEDI_COUNTER_ARMED;
-		if (bits & Gi_Counting_Bit(counter->counter_index))
+		if (bits & Gi_Counting_Bit(cidx))
 			status |= COMEDI_COUNTER_COUNTING;
 	}
 	return status;
@@ -438,8 +428,8 @@ static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned counting_mode_reg =
-	    NITIO_CNT_MODE_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned counting_mode_reg = NITIO_CNT_MODE_REG(cidx);
 	static const uint64_t min_normal_sync_period_ps = 25000;
 	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
 								ni_tio_generic_clock_src_select
@@ -476,6 +466,7 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 	unsigned mode_reg_mask;
 	unsigned mode_reg_values;
 	unsigned input_select_bits = 0;
@@ -502,7 +493,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	default:
 		break;
 	}
-	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
 			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
@@ -515,15 +506,13 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		     Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
 		if (mode & NI_GPCT_INDEX_ENABLE_BIT)
 			counting_mode_bits |= Gi_Index_Mode_Bit;
-		ni_tio_set_bits(counter,
-				NITIO_CNT_MODE_REG(counter->
-							   counter_index),
+		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 				Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
 				Gi_Index_Mode_Bit, counting_mode_bits);
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
-	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
 			Gi_Up_Down_Mask,
 			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
 			Gi_Up_Down_Shift);
@@ -532,8 +521,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		input_select_bits |= Gi_Or_Gate_Bit;
 	if (mode & NI_GPCT_INVERT_OUTPUT_BIT)
 		input_select_bits |= Gi_Output_Polarity_Bit;
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
 			Gi_Output_Polarity_Bit, input_select_bits);
 
@@ -543,7 +531,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-
+	unsigned cidx = counter->counter_index;
 	unsigned command_transient_bits = 0;
 
 	if (arm) {
@@ -581,9 +569,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 				}
 				break;
 			}
-			ni_tio_set_bits(counter,
-					NITIO_CNT_MODE_REG
-					(counter->counter_index),
+			ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 					Gi_HW_Arm_Select_Mask
 					(counter_dev->variant) |
 					Gi_HW_Arm_Enable_Bit,
@@ -592,8 +578,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 	} else {
 		command_transient_bits |= Gi_Disarm_Bit;
 	}
-	ni_tio_set_bits_transient(counter,
-				  NITIO_CMD_REG(counter->counter_index),
+	ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 				  0, 0, command_transient_bits);
 	return 0;
 }
@@ -717,8 +702,8 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 					unsigned int clock_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
 		return;
@@ -747,6 +732,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 				unsigned int period_ns)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 	unsigned input_select_bits = 0;
 	static const uint64_t pico_per_nano = 1000;
 
@@ -766,8 +752,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	}
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		input_select_bits |= Gi_Source_Polarity_Bit;
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
 			input_select_bits);
 	ni_tio_set_source_subselect(counter, clock_source);
@@ -791,9 +776,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 			return -EINVAL;
 			break;
 		}
-		ni_tio_set_bits(counter,
-				NITIO_CNT_MODE_REG(counter->
-							   counter_index),
+		ni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),
 				Gi_Prescale_X2_Bit(counter_dev->variant) |
 				Gi_Prescale_X8_Bit(counter_dev->variant),
 				counting_mode_bits);
@@ -806,15 +789,12 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,
-								 NITIO_CNT_MODE_REG
-								 (counter->
-								  counter_index));
+	unsigned cidx = counter->counter_index;
+	const unsigned counting_mode_bits =
+		ni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));
 	unsigned bits = 0;
 
-	if (ni_tio_get_soft_copy(counter,
-				 NITIO_INPUT_SEL_REG
-				 (counter->counter_index)) &
+	if (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
 	    Gi_Source_Polarity_Bit)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
 	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
@@ -827,15 +807,13 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 	unsigned clock_source = 0;
 	unsigned i;
-	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-							    NITIO_INPUT_SEL_REG
-							    (counter->counter_index))
-				       & Gi_Source_Select_Mask) >>
-	    Gi_Source_Select_Shift;
+	const unsigned input_select =
+		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_M_Series_Timebase_1_Clock:
@@ -895,12 +873,11 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 {
 	unsigned clock_source = 0;
+	unsigned cidx = counter->counter_index;
+	const unsigned input_select =
+		(ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &
+			Gi_Source_Select_Mask) >> Gi_Source_Select_Shift;
 	unsigned i;
-	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-							    NITIO_INPUT_SEL_REG
-							    (counter->counter_index))
-				       & Gi_Source_Select_Mask) >>
-	    Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_660x_Timebase_1_Clock:
@@ -1022,6 +999,7 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 					    unsigned int gate_source)
 {
 	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
+	unsigned cidx = counter->counter_index;
 	unsigned mode_values = 0;
 
 	if (gate_source & CR_INVERT)
@@ -1030,7 +1008,7 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 		mode_values |= Gi_Rising_Edge_Gating_Bits;
 	else
 		mode_values |= Gi_Level_Gating_Bits;
-	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
 			mode_mask, mode_values);
 }
 
@@ -1038,6 +1016,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 				  unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
+	unsigned cidx = counter->counter_index;
 	/* bits of selected_gate that may be meaningful to input select register */
 	const unsigned selected_gate_mask = 0x1f;
 	unsigned ni_660x_gate_select;
@@ -1075,8 +1054,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 		return -EINVAL;
 		break;
 	}
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Gate_Select_Mask,
 			Gi_Gate_Select_Bits(ni_660x_gate_select));
 	return 0;
@@ -1086,6 +1064,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 				      unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
+	unsigned cidx = counter->counter_index;
 	/* bits of selected_gate that may be meaningful to input select register */
 	const unsigned selected_gate_mask = 0x1f;
 	unsigned ni_m_series_gate_select;
@@ -1124,8 +1103,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		return -EINVAL;
 		break;
 	}
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Gate_Select_Mask,
 			Gi_Gate_Select_Bits(ni_m_series_gate_select));
 	return 0;
@@ -1135,8 +1113,8 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 				   unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1194,8 +1172,8 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 				       unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1222,15 +1200,13 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 
 	switch (gate_index) {
 	case 0:
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
-			ni_tio_set_bits(counter,
-					NITIO_MODE_REG(counter->
-							  counter_index),
+			ni_tio_set_bits(counter, NITIO_MODE_REG(cidx),
 					Gi_Gating_Mode_Mask,
 					Gi_Gating_Disabled_Bits);
 			return 0;
@@ -1292,11 +1268,12 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 				unsigned int source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 
 	if (counter_dev->variant == ni_gpct_variant_m_series) {
 		unsigned int abz_reg, shift, mask;
 
-		abz_reg = NITIO_ABZ_REG(counter->counter_index);
+		abz_reg = NITIO_ABZ_REG(cidx);
 		switch (index) {
 		case NI_GPCT_SOURCE_ENCODER_A:
 			shift = 10;
@@ -1490,12 +1467,10 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			       unsigned int *gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
-							NITIO_MODE_REG
-							(counter->
-							 counter_index));
-	const unsigned second_gate_reg =
-	    NITIO_GATE2_REG(counter->counter_index);
+	unsigned cidx = counter->counter_index;
+	const unsigned mode_bits =
+		ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx));
+	const unsigned second_gate_reg = NITIO_GATE2_REG(cidx);
 	unsigned gate_select_bits;
 
 	switch (gate_index) {
@@ -1507,8 +1482,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		} else {
 			gate_select_bits =
 			    (ni_tio_get_soft_copy(counter,
-						  NITIO_INPUT_SEL_REG
-						  (counter->counter_index)) &
+						  NITIO_INPUT_SEL_REG(cidx)) &
 			     Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
 		}
 		switch (counter_dev->variant) {
@@ -1627,6 +1601,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
+	unsigned cidx = counter->counter_index;
 	unsigned first_read;
 	unsigned second_read;
 	unsigned correct_read;
@@ -1635,41 +1610,30 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		return 0;
 	switch (channel) {
 	case 0:
-		ni_tio_set_bits(counter,
-				NITIO_CMD_REG(counter->counter_index),
+		ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
 				Gi_Save_Trace_Bit, 0);
-		ni_tio_set_bits(counter,
-				NITIO_CMD_REG(counter->counter_index),
+		ni_tio_set_bits(counter, NITIO_CMD_REG(cidx),
 				Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
 		/* The count doesn't get latched until the next clock edge, so it is possible the count
 		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
 		   atomic (apparently even when it's a 32 bit register according to 660x docs),
 		   we need to read twice and make sure the reading hasn't changed.  If it has,
 		   a third read will be correct since the count value will definitely have latched by then. */
-		first_read =
-		    read_register(counter,
-				  NITIO_SW_SAVE_REG(counter->counter_index));
-		second_read =
-		    read_register(counter,
-				  NITIO_SW_SAVE_REG(counter->counter_index));
+		first_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
+		second_read = read_register(counter, NITIO_SW_SAVE_REG(cidx));
 		if (first_read != second_read)
 			correct_read =
-			    read_register(counter,
-				  NITIO_SW_SAVE_REG(counter->counter_index));
+			    read_register(counter, NITIO_SW_SAVE_REG(cidx));
 		else
 			correct_read = first_read;
 		data[0] = correct_read;
 		return 0;
 		break;
 	case 1:
-		data[0] =
-		    counter_dev->
-		    regs[NITIO_LOADA_REG(counter->counter_index)];
+		data[0] = counter_dev->regs[NITIO_LOADA_REG(cidx)];
 		break;
 	case 2:
-		data[0] =
-		    counter_dev->
-		    regs[NITIO_LOADB_REG(counter->counter_index)];
+		data[0] = counter_dev->regs[NITIO_LOADB_REG(cidx)];
 		break;
 	}
 	return 0;
@@ -1678,14 +1642,14 @@ EXPORT_SYMBOL_GPL(ni_tio_rinsn);
 
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
-	const unsigned bits = read_register(counter,
-					    NITIO_SHARED_STATUS_REG(counter->
-								 counter_index));
+	unsigned cidx = counter->counter_index;
+	const unsigned bits =
+		read_register(counter, NITIO_SHARED_STATUS_REG(cidx));
 
-	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))
-		return NITIO_LOADB_REG(counter->counter_index);
+	if (bits & Gi_Next_Load_Source_Bit(cidx))
+		return NITIO_LOADB_REG(cidx);
 	else
-		return NITIO_LOADA_REG(counter->counter_index);
+		return NITIO_LOADA_REG(cidx);
 }
 
 int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
@@ -1693,6 +1657,7 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
+	unsigned cidx = counter->counter_index;
 	unsigned load_reg;
 
 	if (insn->n < 1)
@@ -1703,23 +1668,18 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		/* Don't disturb load source select, just use whichever load register is already selected. */
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
-		ni_tio_set_bits_transient(counter,
-					  NITIO_CMD_REG(counter->counter_index),
+		ni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),
 					  0, 0, Gi_Load_Bit);
 		/* restore state of load reg to whatever the user set last set it to */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:
-		counter_dev->regs[NITIO_LOADA_REG(counter->counter_index)] =
-		    data[0];
-		write_register(counter, data[0],
-			       NITIO_LOADA_REG(counter->counter_index));
+		counter_dev->regs[NITIO_LOADA_REG(cidx)] = data[0];
+		write_register(counter, data[0], NITIO_LOADA_REG(cidx));
 		break;
 	case 2:
-		counter_dev->regs[NITIO_LOADB_REG(counter->counter_index)] =
-		    data[0];
-		write_register(counter, data[0],
-			       NITIO_LOADB_REG(counter->counter_index));
+		counter_dev->regs[NITIO_LOADB_REG(cidx)] = data[0];
+		write_register(counter, data[0], NITIO_LOADB_REG(cidx));
 		break;
 	default:
 		return -EINVAL;

commit 94baf025ba41136eb4e9e858ebdbad33a6b3c539
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:52 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Interrupt_Enable_Reg()
    
    The "Interrupt Enable" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 633c20af484a..ed55885b5918 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -416,7 +416,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 			NITIO_DMA_CFG_REG(counter->counter_index), ~0,
 			0x0);
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			NITIO_INT_ENA_REG(counter->counter_index),
 			~0, 0x0);
 }
 EXPORT_SYMBOL_GPL(ni_tio_init_counter);

commit c9d766d04ab032943c0fa68ddc6434ca1fe2c9f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:51 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Status_Reg()
    
    The "Status" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Rename the define for the shared status register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 8762dc628c27..633c20af484a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -425,7 +425,7 @@ static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
 	unsigned int status = 0;
 	const unsigned bits = read_register(counter,
-					    NITIO_STATUS_REG(counter->
+					    NITIO_SHARED_STATUS_REG(counter->
 								 counter_index));
 	if (bits & Gi_Armed_Bit(counter->counter_index)) {
 		status |= COMEDI_COUNTER_ARMED;
@@ -1679,7 +1679,7 @@ EXPORT_SYMBOL_GPL(ni_tio_rinsn);
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
 	const unsigned bits = read_register(counter,
-					    NITIO_STATUS_REG(counter->
+					    NITIO_SHARED_STATUS_REG(counter->
 								 counter_index));
 
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))

commit ff157abe21e76c0d51065bd93e91051547f5d608
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:49 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_ABZ_Reg()
    
    The "ABZ" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f3f1fca765a7..8762dc628c27 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1296,7 +1296,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 	if (counter_dev->variant == ni_gpct_variant_m_series) {
 		unsigned int abz_reg, shift, mask;
 
-		abz_reg = NITIO_Gi_ABZ_Reg(counter->counter_index);
+		abz_reg = NITIO_ABZ_REG(counter->counter_index);
 		switch (index) {
 		case NI_GPCT_SOURCE_ENCODER_A:
 			shift = 10;

commit 1dd26c2152502b4521d4c7d3aad07ed4eda5705f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:47 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_DMA_Config_Reg()
    
    The "DMA Config" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6fcaebd27de9..f3f1fca765a7 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -413,7 +413,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 							counter_index));
 	}
 	ni_tio_set_bits(counter,
-			NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0,
+			NITIO_DMA_CFG_REG(counter->counter_index), ~0,
 			0x0);
 	ni_tio_set_bits(counter,
 			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),

commit fc31c52f4cfb9465ff69df881807ef1cc0730501
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:44 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gxx_Joint_Reset_Reg()
    
    The shared "Reset" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 7da8228f554c..6fcaebd27de9 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -363,7 +363,7 @@ static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
 	write_register(counter, Gi_Reset_Bit(counter->counter_index),
-		       NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
+		       NITIO_RESET_REG(counter->counter_index));
 }
 
 void ni_tio_init_counter(struct ni_gpct *counter)

commit 96b6175aa32385db609c706f2c78b14ac515e926
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:43 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gxx_Status_Reg()
    
    The shared "Status" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 5203103084fc..7da8228f554c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -425,7 +425,7 @@ static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
 	unsigned int status = 0;
 	const unsigned bits = read_register(counter,
-					    NITIO_Gxx_Status_Reg(counter->
+					    NITIO_STATUS_REG(counter->
 								 counter_index));
 	if (bits & Gi_Armed_Bit(counter->counter_index)) {
 		status |= COMEDI_COUNTER_ARMED;
@@ -1679,7 +1679,7 @@ EXPORT_SYMBOL_GPL(ni_tio_rinsn);
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
 	const unsigned bits = read_register(counter,
-					    NITIO_Gxx_Status_Reg(counter->
+					    NITIO_STATUS_REG(counter->
 								 counter_index));
 
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))

commit 7a0894e0d465a6bcf6fc3f67c75f808f0d90fa3e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:42 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Second_Gate_Reg()
    
    The "Second Gate" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f79140563901..5203103084fc 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -403,13 +403,13 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 	}
 	if (ni_tio_second_gate_registers_present(counter_dev)) {
 		counter_dev->
-		    regs[NITIO_Gi_Second_Gate_Reg(counter->counter_index)] =
+		    regs[NITIO_GATE2_REG(counter->counter_index)] =
 		    0x0;
 		write_register(counter,
 			       counter_dev->
-			       regs[NITIO_Gi_Second_Gate_Reg
+			       regs[NITIO_GATE2_REG
 				    (counter->counter_index)],
-			       NITIO_Gi_Second_Gate_Reg(counter->
+			       NITIO_GATE2_REG(counter->
 							counter_index));
 	}
 	ni_tio_set_bits(counter,
@@ -718,7 +718,7 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
 		return;
@@ -828,7 +828,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
@@ -1136,7 +1136,7 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1195,7 +1195,7 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1223,7 +1223,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 
 	switch (gate_index) {
 	case 0:
@@ -1495,7 +1495,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 							(counter->
 							 counter_index));
 	const unsigned second_gate_reg =
-	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_GATE2_REG(counter->counter_index);
 	unsigned gate_select_bits;
 
 	switch (gate_index) {

commit 0412ea4696decc35ec5f394ab7832619504c96a7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:41 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Counting_Mode_Reg()
    
    The "Counting Mode" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 21456d653a0a..f79140563901 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -397,7 +397,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 			0);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Counting_Mode_Reg(counter->
+				NITIO_CNT_MODE_REG(counter->
 							   counter_index), ~0,
 				0);
 	}
@@ -439,7 +439,7 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_reg =
-	    NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
+	    NITIO_CNT_MODE_REG(counter->counter_index);
 	static const uint64_t min_normal_sync_period_ps = 25000;
 	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
 								ni_tio_generic_clock_src_select
@@ -516,7 +516,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		if (mode & NI_GPCT_INDEX_ENABLE_BIT)
 			counting_mode_bits |= Gi_Index_Mode_Bit;
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Counting_Mode_Reg(counter->
+				NITIO_CNT_MODE_REG(counter->
 							   counter_index),
 				Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
 				Gi_Index_Mode_Bit, counting_mode_bits);
@@ -582,7 +582,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 				break;
 			}
 			ni_tio_set_bits(counter,
-					NITIO_Gi_Counting_Mode_Reg
+					NITIO_CNT_MODE_REG
 					(counter->counter_index),
 					Gi_HW_Arm_Select_Mask
 					(counter_dev->variant) |
@@ -792,7 +792,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 			break;
 		}
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Counting_Mode_Reg(counter->
+				NITIO_CNT_MODE_REG(counter->
 							   counter_index),
 				Gi_Prescale_X2_Bit(counter_dev->variant) |
 				Gi_Prescale_X8_Bit(counter_dev->variant),
@@ -807,7 +807,7 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,
-								 NITIO_Gi_Counting_Mode_Reg
+								 NITIO_CNT_MODE_REG
 								 (counter->
 								  counter_index));
 	unsigned bits = 0;

commit 3da68f50f2a1eaa8d9e5bf1e354eb14c0da1375d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:40 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Input_Select_Reg()
    
    The "Input Select" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 2d20e8d2cbe7..21456d653a0a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -393,7 +393,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		       regs[NITIO_LOADB_REG(counter->counter_index)],
 		       NITIO_LOADB_REG(counter->counter_index));
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0,
+			NITIO_INPUT_SEL_REG(counter->counter_index), ~0,
 			0);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		ni_tio_set_bits(counter,
@@ -533,7 +533,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	if (mode & NI_GPCT_INVERT_OUTPUT_BIT)
 		input_select_bits |= Gi_Output_Polarity_Bit;
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			NITIO_INPUT_SEL_REG(counter->counter_index),
 			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
 			Gi_Output_Polarity_Bit, input_select_bits);
 
@@ -767,7 +767,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		input_select_bits |= Gi_Source_Polarity_Bit;
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			NITIO_INPUT_SEL_REG(counter->counter_index),
 			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
 			input_select_bits);
 	ni_tio_set_source_subselect(counter, clock_source);
@@ -813,7 +813,7 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 	unsigned bits = 0;
 
 	if (ni_tio_get_soft_copy(counter,
-				 NITIO_Gi_Input_Select_Reg
+				 NITIO_INPUT_SEL_REG
 				 (counter->counter_index)) &
 	    Gi_Source_Polarity_Bit)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
@@ -832,7 +832,7 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-							    NITIO_Gi_Input_Select_Reg
+							    NITIO_INPUT_SEL_REG
 							    (counter->counter_index))
 				       & Gi_Source_Select_Mask) >>
 	    Gi_Source_Select_Shift;
@@ -897,7 +897,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-							    NITIO_Gi_Input_Select_Reg
+							    NITIO_INPUT_SEL_REG
 							    (counter->counter_index))
 				       & Gi_Source_Select_Mask) >>
 	    Gi_Source_Select_Shift;
@@ -1076,7 +1076,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter,
 		break;
 	}
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			NITIO_INPUT_SEL_REG(counter->counter_index),
 			Gi_Gate_Select_Mask,
 			Gi_Gate_Select_Bits(ni_660x_gate_select));
 	return 0;
@@ -1125,7 +1125,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		break;
 	}
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			NITIO_INPUT_SEL_REG(counter->counter_index),
 			Gi_Gate_Select_Mask,
 			Gi_Gate_Select_Bits(ni_m_series_gate_select));
 	return 0;
@@ -1507,7 +1507,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		} else {
 			gate_select_bits =
 			    (ni_tio_get_soft_copy(counter,
-						  NITIO_Gi_Input_Select_Reg
+						  NITIO_INPUT_SEL_REG
 						  (counter->counter_index)) &
 			     Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
 		}

commit cc7a164b1686e233fa9d8f796e1b657379cd9278
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:39 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_LoadB_Reg()
    
    The "LoadB" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f203a6c07f86..2d20e8d2cbe7 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -387,11 +387,11 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		       counter_dev->
 		       regs[NITIO_LOADA_REG(counter->counter_index)],
 		       NITIO_LOADA_REG(counter->counter_index));
-	counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;
+	counter_dev->regs[NITIO_LOADB_REG(counter->counter_index)] = 0x0;
 	write_register(counter,
 		       counter_dev->
-		       regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
-		       NITIO_Gi_LoadB_Reg(counter->counter_index));
+		       regs[NITIO_LOADB_REG(counter->counter_index)],
+		       NITIO_LOADB_REG(counter->counter_index));
 	ni_tio_set_bits(counter,
 			NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0,
 			0);
@@ -1669,7 +1669,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	case 2:
 		data[0] =
 		    counter_dev->
-		    regs[NITIO_Gi_LoadB_Reg(counter->counter_index)];
+		    regs[NITIO_LOADB_REG(counter->counter_index)];
 		break;
 	}
 	return 0;
@@ -1683,7 +1683,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 								 counter_index));
 
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))
-		return NITIO_Gi_LoadB_Reg(counter->counter_index);
+		return NITIO_LOADB_REG(counter->counter_index);
 	else
 		return NITIO_LOADA_REG(counter->counter_index);
 }
@@ -1716,10 +1716,10 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 			       NITIO_LOADA_REG(counter->counter_index));
 		break;
 	case 2:
-		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =
+		counter_dev->regs[NITIO_LOADB_REG(counter->counter_index)] =
 		    data[0];
 		write_register(counter, data[0],
-			       NITIO_Gi_LoadB_Reg(counter->counter_index));
+			       NITIO_LOADB_REG(counter->counter_index));
 		break;
 	default:
 		return -EINVAL;

commit 720712f439b3f02bcf473efe83ece259d97ce455
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:38 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_LoadA_Reg()
    
    The "LoadA" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 5b46324e77de..f203a6c07f86 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -382,11 +382,11 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 			~0, Gi_Synchronize_Gate_Bit);
 	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index), ~0,
 			0);
-	counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;
+	counter_dev->regs[NITIO_LOADA_REG(counter->counter_index)] = 0x0;
 	write_register(counter,
 		       counter_dev->
-		       regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
-		       NITIO_Gi_LoadA_Reg(counter->counter_index));
+		       regs[NITIO_LOADA_REG(counter->counter_index)],
+		       NITIO_LOADA_REG(counter->counter_index));
 	counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
 		       counter_dev->
@@ -1664,7 +1664,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	case 1:
 		data[0] =
 		    counter_dev->
-		    regs[NITIO_Gi_LoadA_Reg(counter->counter_index)];
+		    regs[NITIO_LOADA_REG(counter->counter_index)];
 		break;
 	case 2:
 		data[0] =
@@ -1685,7 +1685,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))
 		return NITIO_Gi_LoadB_Reg(counter->counter_index);
 	else
-		return NITIO_Gi_LoadA_Reg(counter->counter_index);
+		return NITIO_LOADA_REG(counter->counter_index);
 }
 
 int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
@@ -1710,10 +1710,10 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:
-		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] =
+		counter_dev->regs[NITIO_LOADA_REG(counter->counter_index)] =
 		    data[0];
 		write_register(counter, data[0],
-			       NITIO_Gi_LoadA_Reg(counter->counter_index));
+			       NITIO_LOADA_REG(counter->counter_index));
 		break;
 	case 2:
 		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =

commit 0101791e83cbd9076c34bf138d1407442dfdf95f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:37 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Mode_Reg()
    
    The "Mode" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 38ad82333cdf..5b46324e77de 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -380,7 +380,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		       NITIO_AUTO_INC_REG(counter->counter_index));
 	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
 			~0, Gi_Synchronize_Gate_Bit);
-	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,
+	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index), ~0,
 			0);
 	counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
@@ -502,7 +502,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	default:
 		break;
 	}
-	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),
 			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
@@ -1030,7 +1030,7 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 		mode_values |= Gi_Rising_Edge_Gating_Bits;
 	else
 		mode_values |= Gi_Level_Gating_Bits;
-	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),
 			mode_mask, mode_values);
 }
 
@@ -1229,7 +1229,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	case 0:
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter,
-					NITIO_Gi_Mode_Reg(counter->
+					NITIO_MODE_REG(counter->
 							  counter_index),
 					Gi_Gating_Mode_Mask,
 					Gi_Gating_Disabled_Bits);
@@ -1491,7 +1491,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
-							NITIO_Gi_Mode_Reg
+							NITIO_MODE_REG
 							(counter->
 							 counter_index));
 	const unsigned second_gate_reg =

commit 67c68de0f13d17433b40d12ba1a8a36e4e2a0270
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:36 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_SW_Save_Reg()
    
    The "SW Save" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index d535bbbb15f5..38ad82333cdf 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1648,15 +1648,14 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		   a third read will be correct since the count value will definitely have latched by then. */
 		first_read =
 		    read_register(counter,
-				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
+				  NITIO_SW_SAVE_REG(counter->counter_index));
 		second_read =
 		    read_register(counter,
-				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
+				  NITIO_SW_SAVE_REG(counter->counter_index));
 		if (first_read != second_read)
 			correct_read =
 			    read_register(counter,
-					  NITIO_Gi_SW_Save_Reg(counter->
-							       counter_index));
+				  NITIO_SW_SAVE_REG(counter->counter_index));
 		else
 			correct_read = first_read;
 		data[0] = correct_read;

commit e25ef744460ca114c9f4cd5178932135c760f456
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:35 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Command_Reg()
    
    The "Command" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6fa72f00360a..d535bbbb15f5 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -378,7 +378,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		       counter_dev->
 		       regs[NITIO_AUTO_INC_REG(counter->counter_index)],
 		       NITIO_AUTO_INC_REG(counter->counter_index));
-	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
 			~0, Gi_Synchronize_Gate_Bit);
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,
 			0);
@@ -523,7 +523,7 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
-	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
 			Gi_Up_Down_Mask,
 			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
 			Gi_Up_Down_Shift);
@@ -593,7 +593,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 		command_transient_bits |= Gi_Disarm_Bit;
 	}
 	ni_tio_set_bits_transient(counter,
-				  NITIO_Gi_Command_Reg(counter->counter_index),
+				  NITIO_CMD_REG(counter->counter_index),
 				  0, 0, command_transient_bits);
 	return 0;
 }
@@ -1636,10 +1636,10 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	switch (channel) {
 	case 0:
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Command_Reg(counter->counter_index),
+				NITIO_CMD_REG(counter->counter_index),
 				Gi_Save_Trace_Bit, 0);
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Command_Reg(counter->counter_index),
+				NITIO_CMD_REG(counter->counter_index),
 				Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
 		/* The count doesn't get latched until the next clock edge, so it is possible the count
 		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
@@ -1705,8 +1705,7 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter,
-					  NITIO_Gi_Command_Reg(counter->
-							       counter_index),
+					  NITIO_CMD_REG(counter->counter_index),
 					  0, 0, Gi_Load_Bit);
 		/* restore state of load reg to whatever the user set last set it to */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);

commit e062f51b79062b691e81b1851b4b2871093410c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:34 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Autoincrement_Reg()
    
    The "AutoIncrement" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index cf8892bcf01e..6fa72f00360a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -372,12 +372,12 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 
 	ni_tio_reset_count_and_disarm(counter);
 	/* initialize counter registers */
-	counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)] =
+	counter_dev->regs[NITIO_AUTO_INC_REG(counter->counter_index)] =
 	    0x0;
 	write_register(counter,
 		       counter_dev->
-		       regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)],
-		       NITIO_Gi_Autoincrement_Reg(counter->counter_index));
+		       regs[NITIO_AUTO_INC_REG(counter->counter_index)],
+		       NITIO_AUTO_INC_REG(counter->counter_index));
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
 			~0, Gi_Synchronize_Gate_Bit);
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,

commit 9cc2bafb61bf8bc614a4570f7f78e09eb60e1dff
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:27 2013 -0700

    staging: comedi: ni_tio: remove commented out printk message
    
    This printk message is just added noise. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 9b120c77d83a..cf8892bcf01e 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1319,7 +1319,6 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-/* printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 5b6fde08e582..9b120c77d83a 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -44,6 +44,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 	Support use of both banks X and Y
 */
 
+#include <linux/module.h>
 #include <linux/slab.h>
 
 #include "ni_tio_internal.h"

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f2cf76d15d78..5b6fde08e582 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -44,6 +44,8 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 	Support use of both banks X and Y
 */
 
+#include <linux/slab.h>
+
 #include "ni_tio_internal.h"
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 225287769dc1..f2cf76d15d78 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -13,10 +13,6 @@
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*

commit d1e1501e3129f215ec182bb0c69305655d429f80
Author: Jake Champlin <jake.champlin.27@gmail.com>
Date:   Thu Jan 17 08:55:30 2013 -0500

    Staging: Comedi: ni_tio: Fixed spacing issue
    
    Fixed coding style issue from spaces to tabs.
    
    Signed-off-by: Jake Champlin <jake.champlin.27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 98f87897e2a8..225287769dc1 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -276,7 +276,7 @@ static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 }
 
 static const unsigned int counter_status_mask =
-    COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
+	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
 static int __init ni_tio_init_module(void)
 {

commit 95cd17c9f3734091a5811fabbd778e3f7b1f0789
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:35 2011 -0700

    staging: Remove unnecessary semicolons when switch (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_switch.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(switch\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index a9bb6b13dfc4..98f87897e2a8 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1181,7 +1181,7 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 			break;
 		return -EINVAL;
 		break;
-	};
+	}
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
@@ -1209,7 +1209,7 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 		ni_m_series_second_gate_select =
 		    selected_second_gate & selected_second_gate_mask;
 		break;
-	};
+	}
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
@@ -1674,7 +1674,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		    counter_dev->
 		    regs[NITIO_Gi_LoadB_Reg(counter->counter_index)];
 		break;
-	};
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_rinsn);

commit 3d34023a99d35440d6a22fb0b4547fc9817b7b40
Author: Cody Harmon <harmonco@flip.engr.oregonstate.edu>
Date:   Tue May 18 23:03:40 2010 -0700

    Staging: comedi: ni_tio: fixed brace coding style issues and a few errors
    
    Fixed code style and placed KERN_ERR in printk statement.
    
    Signed-off-by: Cody Harmon <harmonco@engr.orst.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 6621e940c308..a9bb6b13dfc4 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -302,7 +302,7 @@ struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
 									ni_gpct_register
 									reg),
 						unsigned (*read_register)
-						(struct ni_gpct * counter,
+						(struct ni_gpct *counter,
 						 enum ni_gpct_register reg),
 						enum ni_gpct_variant variant,
 						unsigned num_counters)
@@ -332,6 +332,7 @@ struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
 	counter_dev->num_counters = num_counters;
 	return counter_dev;
 }
+EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
 
 void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 {
@@ -340,6 +341,7 @@ void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 	kfree(counter_dev->counters);
 	kfree(counter_dev);
 }
+EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);
 
 static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
 						*counter_dev)
@@ -418,6 +420,7 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
 			~0, 0x0);
 }
+EXPORT_SYMBOL_GPL(ni_tio_init_counter);
 
 static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
@@ -446,9 +449,7 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
 		return;
 
-	switch (ni_tio_get_soft_copy(counter,
-				     counting_mode_reg) & Gi_Counting_Mode_Mask)
-	{
+	switch (ni_tio_get_soft_copy(counter, counting_mode_reg) & Gi_Counting_Mode_Mask) {
 	case Gi_Counting_Mode_QuadratureX1_Bits:
 	case Gi_Counting_Mode_QuadratureX2_Bits:
 	case Gi_Counting_Mode_QuadratureX4_Bits:
@@ -513,9 +514,8 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		counting_mode_bits |=
 		    ((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
 		     Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
-		if (mode & NI_GPCT_INDEX_ENABLE_BIT) {
+		if (mode & NI_GPCT_INDEX_ENABLE_BIT)
 			counting_mode_bits |= Gi_Index_Mode_Bit;
-		}
 		ni_tio_set_bits(counter,
 				NITIO_Gi_Counting_Mode_Reg(counter->
 							   counter_index),
@@ -529,12 +529,10 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
 			Gi_Up_Down_Shift);
 
-	if (mode & NI_GPCT_OR_GATE_BIT) {
+	if (mode & NI_GPCT_OR_GATE_BIT)
 		input_select_bits |= Gi_Or_Gate_Bit;
-	}
-	if (mode & NI_GPCT_INVERT_OUTPUT_BIT) {
+	if (mode & NI_GPCT_INVERT_OUTPUT_BIT)
 		input_select_bits |= Gi_Output_Polarity_Bit;
-	}
 	ni_tio_set_bits(counter,
 			NITIO_Gi_Input_Select_Reg(counter->counter_index),
 			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
@@ -600,6 +598,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 				  0, 0, command_transient_bits);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_arm);
 
 static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 {
@@ -706,7 +705,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		}
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
-		printk("invalid clock source 0x%lx\n",
+		printk(KERN_ERR "invalid clock source 0x%lx\n",
 		       (unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;
@@ -1026,14 +1025,12 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
 	unsigned mode_values = 0;
 
-	if (gate_source & CR_INVERT) {
+	if (gate_source & CR_INVERT)
 		mode_values |= Gi_Gate_Polarity_Bit;
-	}
-	if (gate_source & CR_EDGE) {
+	if (gate_source & CR_EDGE)
 		mode_values |= Gi_Rising_Edge_Gating_Bits;
-	} else {
+	else
 		mode_values |= Gi_Level_Gating_Bits;
-	}
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
 			mode_mask, mode_values);
 }
@@ -1290,6 +1287,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 	}
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_set_gate_src);
 
 static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 				unsigned int source)
@@ -1531,12 +1529,10 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			BUG();
 			break;
 		}
-		if (mode_bits & Gi_Gate_Polarity_Bit) {
+		if (mode_bits & Gi_Gate_Polarity_Bit)
 			*gate_source |= CR_INVERT;
-		}
-		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits) {
+		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
 			*gate_source |= CR_EDGE;
-		}
 		break;
 	case 1:
 		if ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits
@@ -1572,9 +1568,8 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			*gate_source |= CR_INVERT;
 		}
 		/* second gate can't have edge/level mode set independently */
-		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits) {
+		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)
 			*gate_source |= CR_EDGE;
-		}
 		break;
 	default:
 		return -EINVAL;
@@ -1627,6 +1622,7 @@ int ni_tio_insn_config(struct ni_gpct *counter,
 	}
 	return -EINVAL;
 }
+EXPORT_SYMBOL_GPL(ni_tio_insn_config);
 
 int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 		 unsigned int *data)
@@ -1681,6 +1677,7 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	};
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_rinsn);
 
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
@@ -1734,12 +1731,4 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
 	}
 	return 0;
 }
-
-EXPORT_SYMBOL_GPL(ni_tio_rinsn);
 EXPORT_SYMBOL_GPL(ni_tio_winsn);
-EXPORT_SYMBOL_GPL(ni_tio_insn_config);
-EXPORT_SYMBOL_GPL(ni_tio_init_counter);
-EXPORT_SYMBOL_GPL(ni_tio_arm);
-EXPORT_SYMBOL_GPL(ni_tio_set_gate_src);
-EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
-EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);

commit 091b4242ebb789e826cbde573a0fee9f60fe998b
Author: Samuel Richardson <sam.j.richardson@gmail.com>
Date:   Mon May 17 19:08:18 2010 +0100

    Staging: comedi: fixed brace coding style issue in ni_tio.c
    
    This is a patch to the ni_tio.c file that fixes a brace warning found by
    the checkpatch.pl tool
    
    Signed-off-by: Samuel Richardson <sam.j.richardson@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 13e5b264ff0d..6621e940c308 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1688,11 +1688,10 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 					    NITIO_Gxx_Status_Reg(counter->
 								 counter_index));
 
-	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index)) {
+	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index))
 		return NITIO_Gi_LoadB_Reg(counter->counter_index);
-	} else {
+	else
 		return NITIO_Gi_LoadA_Reg(counter->counter_index);
-	}
 }
 
 int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 785553d0cc9d..13e5b264ff0d 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -51,7 +51,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 #include "ni_tio_internal.h"
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-	unsigned generic_clock_source);
+				       unsigned generic_clock_source);
 static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
 
 MODULE_AUTHOR("Comedi <comedi@comedi.org>");
@@ -59,7 +59,8 @@ MODULE_DESCRIPTION("Comedi support for NI general-purpose counters");
 MODULE_LICENSE("GPL");
 
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
-	ni_gpct_variant variant)
+								   ni_gpct_variant
+								   variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -77,8 +78,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
-	ni_gpct_variant variant)
+								ni_gpct_variant
+								variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -96,8 +99,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
-	ni_gpct_variant variant)
+								ni_gpct_variant
+								variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -115,8 +120,10 @@ static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
 	}
 	return 0;
 }
+
 static inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum
-	ni_gpct_variant variant)
+								   ni_gpct_variant
+								   variant)
 {
 	switch (variant) {
 	case ni_gpct_variant_e_series:
@@ -151,6 +158,7 @@ static inline unsigned NI_660x_RTSI_Clock(unsigned n)
 	BUG_ON(n > ni_660x_max_rtsi_channel);
 	return 0xb + n;
 }
+
 static const unsigned ni_660x_max_source_pin = 7;
 static inline unsigned NI_660x_Source_Pin_Clock(unsigned n)
 {
@@ -179,6 +187,7 @@ static inline unsigned NI_M_Series_PFI_Clock(unsigned n)
 	else
 		return 0xb + n;
 }
+
 static const unsigned ni_m_series_max_rtsi_channel = 7;
 static inline unsigned NI_M_Series_RTSI_Clock(unsigned n)
 {
@@ -202,6 +211,7 @@ static inline unsigned NI_660x_Gate_Pin_Gate_Select(unsigned n)
 	BUG_ON(n > ni_660x_max_gate_pin);
 	return 0x2 + n;
 }
+
 static inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_rtsi_channel);
@@ -225,6 +235,7 @@ static inline unsigned NI_M_Series_RTSI_Gate_Select(unsigned n)
 		return 0x1b;
 	return 0xb + n;
 }
+
 static inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_m_series_max_pfi_channel);
@@ -237,6 +248,7 @@ static inline unsigned Gi_Source_Select_Bits(unsigned source)
 {
 	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
 }
+
 static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
 {
 	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
@@ -256,6 +268,7 @@ static inline unsigned NI_660x_Up_Down_Pin_Second_Gate_Select(unsigned n)
 	BUG_ON(n > ni_660x_max_up_down_pin);
 	return 0x2 + n;
 }
+
 static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_rtsi_channel);
@@ -263,7 +276,7 @@ static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 }
 
 static const unsigned int counter_status_mask =
-	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
+    COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
 static int __init ni_tio_init_module(void)
 {
@@ -278,17 +291,26 @@ static void __exit ni_tio_cleanup_module(void)
 
 module_exit(ni_tio_cleanup_module);
 
-struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
-	void (*write_register) (struct ni_gpct *counter, unsigned bits,
-		enum ni_gpct_register reg),
-	unsigned (*read_register) (struct ni_gpct *counter,
-		enum ni_gpct_register reg), enum ni_gpct_variant variant,
-	unsigned num_counters)
+struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,
+						void (*write_register) (struct
+									ni_gpct
+									*
+									counter,
+									unsigned
+									bits,
+									enum
+									ni_gpct_register
+									reg),
+						unsigned (*read_register)
+						(struct ni_gpct * counter,
+						 enum ni_gpct_register reg),
+						enum ni_gpct_variant variant,
+						unsigned num_counters)
 {
 	unsigned i;
 
 	struct ni_gpct_device *counter_dev =
-		kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
+	    kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
 	if (counter_dev == NULL)
 		return NULL;
 	counter_dev->dev = dev;
@@ -298,7 +320,7 @@ struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
 	spin_lock_init(&counter_dev->regs_lock);
 	BUG_ON(num_counters == 0);
 	counter_dev->counters =
-		kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
+	    kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
 	if (counter_dev->counters == NULL) {
 		kfree(counter_dev);
 		return NULL;
@@ -320,7 +342,7 @@ void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
 }
 
 static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
-	*counter_dev)
+						*counter_dev)
 {
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
@@ -340,7 +362,7 @@ static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
 static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
 {
 	write_register(counter, Gi_Reset_Bit(counter->counter_index),
-		NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
+		       NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
 }
 
 void ni_tio_init_counter(struct ni_gpct *counter)
@@ -350,49 +372,59 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 	ni_tio_reset_count_and_disarm(counter);
 	/* initialize counter registers */
 	counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)] =
-		0x0;
+	    0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->
-				counter_index)],
-		NITIO_Gi_Autoincrement_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)],
+		       NITIO_Gi_Autoincrement_Reg(counter->counter_index));
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		~0, Gi_Synchronize_Gate_Bit);
+			~0, Gi_Synchronize_Gate_Bit);
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,
-		0);
+			0);
 	counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
-		NITIO_Gi_LoadA_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
+		       NITIO_Gi_LoadA_Reg(counter->counter_index));
 	counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;
 	write_register(counter,
-		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
-		NITIO_Gi_LoadB_Reg(counter->counter_index));
+		       counter_dev->
+		       regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
+		       NITIO_Gi_LoadB_Reg(counter->counter_index));
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0, 0);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0,
+			0);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index), ~0,
-			0);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index), ~0,
+				0);
 	}
 	if (ni_tio_second_gate_registers_present(counter_dev)) {
-		counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
-				counter_index)] = 0x0;
+		counter_dev->
+		    regs[NITIO_Gi_Second_Gate_Reg(counter->counter_index)] =
+		    0x0;
 		write_register(counter,
-			counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
-					counter_index)],
-			NITIO_Gi_Second_Gate_Reg(counter->counter_index));
+			       counter_dev->
+			       regs[NITIO_Gi_Second_Gate_Reg
+				    (counter->counter_index)],
+			       NITIO_Gi_Second_Gate_Reg(counter->
+							counter_index));
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0, 0x0);
+			NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0,
+			0x0);
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index), ~0, 0x0);
+			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			~0, 0x0);
 }
 
 static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
 	unsigned int status = 0;
 	const unsigned bits = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+					    NITIO_Gxx_Status_Reg(counter->
+								 counter_index));
 	if (bits & Gi_Armed_Bit(counter->counter_index)) {
 		status |= COMEDI_COUNTER_ARMED;
 		if (bits & Gi_Counting_Bit(counter->counter_index))
@@ -405,16 +437,18 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_reg =
-		NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
+	    NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
 	static const uint64_t min_normal_sync_period_ps = 25000;
 	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
-		ni_tio_generic_clock_src_select(counter));
+								ni_tio_generic_clock_src_select
+								(counter));
 
 	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
 		return;
 
 	switch (ni_tio_get_soft_copy(counter,
-			counting_mode_reg) & Gi_Counting_Mode_Mask) {
+				     counting_mode_reg) & Gi_Counting_Mode_Mask)
+	{
 	case Gi_Counting_Mode_QuadratureX1_Bits:
 	case Gi_Counting_Mode_QuadratureX2_Bits:
 	case Gi_Counting_Mode_QuadratureX4_Bits:
@@ -428,14 +462,14 @@ static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
 	   using the alt sync bit in that case, but allow the caller to decide by using the
 	   force_alt_sync parameter. */
 	if (force_alt_sync ||
-		(clock_period_ps
-			&& clock_period_ps < min_normal_sync_period_ps)) {
+	    (clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {
 		ni_tio_set_bits(counter, counting_mode_reg,
-			Gi_Alternate_Sync_Bit(counter_dev->variant),
-			Gi_Alternate_Sync_Bit(counter_dev->variant));
+				Gi_Alternate_Sync_Bit(counter_dev->variant),
+				Gi_Alternate_Sync_Bit(counter_dev->variant));
 	} else {
 		ni_tio_set_bits(counter, counting_mode_reg,
-			Gi_Alternate_Sync_Bit(counter_dev->variant), 0x0);
+				Gi_Alternate_Sync_Bit(counter_dev->variant),
+				0x0);
 	}
 }
 
@@ -447,10 +481,10 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 	unsigned input_select_bits = 0;
 	/* these bits map directly on to the mode register */
 	static const unsigned mode_reg_direct_mask =
-		NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
-		NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
-		NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
-		NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
+	    NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
+	    NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
+	    NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
+	    NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
 
 	mode_reg_mask = mode_reg_direct_mask | Gi_Reload_Source_Switching_Bit;
 	mode_reg_values = mode & mode_reg_direct_mask;
@@ -469,29 +503,31 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		break;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
-		mode_reg_mask, mode_reg_values);
+			mode_reg_mask, mode_reg_values);
 
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		unsigned counting_mode_bits = 0;
 		counting_mode_bits |=
-			(mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
-			Gi_Counting_Mode_Mask;
+		    (mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
+		    Gi_Counting_Mode_Mask;
 		counting_mode_bits |=
-			((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
-			Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
+		    ((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
+		     Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
 		if (mode & NI_GPCT_INDEX_ENABLE_BIT) {
 			counting_mode_bits |= Gi_Index_Mode_Bit;
 		}
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
-			Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
-			Gi_Index_Mode_Bit, counting_mode_bits);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index),
+				Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
+				Gi_Index_Mode_Bit, counting_mode_bits);
 		ni_tio_set_sync_mode(counter, 0);
 	}
 
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		Gi_Up_Down_Mask,
-		(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) << Gi_Up_Down_Shift);
+			Gi_Up_Down_Mask,
+			(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<
+			Gi_Up_Down_Shift);
 
 	if (mode & NI_GPCT_OR_GATE_BIT) {
 		input_select_bits |= Gi_Or_Gate_Bit;
@@ -500,9 +536,9 @@ static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
 		input_select_bits |= Gi_Output_Polarity_Bit;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
-		Gi_Output_Polarity_Bit, input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
+			Gi_Output_Polarity_Bit, input_select_bits);
 
 	return 0;
 }
@@ -535,32 +571,33 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 				if (start_trigger & NI_GPCT_ARM_UNKNOWN) {
 					/* pass-through the least significant bits so we can figure out what select later */
 					unsigned hw_arm_select_bits =
-						(start_trigger <<
-						Gi_HW_Arm_Select_Shift) &
-						Gi_HW_Arm_Select_Mask
-						(counter_dev->variant);
+					    (start_trigger <<
+					     Gi_HW_Arm_Select_Shift) &
+					    Gi_HW_Arm_Select_Mask
+					    (counter_dev->variant);
 
 					counting_mode_bits |=
-						Gi_HW_Arm_Enable_Bit |
-						hw_arm_select_bits;
+					    Gi_HW_Arm_Enable_Bit |
+					    hw_arm_select_bits;
 				} else {
 					return -EINVAL;
 				}
 				break;
 			}
 			ni_tio_set_bits(counter,
-				NITIO_Gi_Counting_Mode_Reg(counter->
-					counter_index),
-				Gi_HW_Arm_Select_Mask(counter_dev->
-					variant) | Gi_HW_Arm_Enable_Bit,
-				counting_mode_bits);
+					NITIO_Gi_Counting_Mode_Reg
+					(counter->counter_index),
+					Gi_HW_Arm_Select_Mask
+					(counter_dev->variant) |
+					Gi_HW_Arm_Enable_Bit,
+					counting_mode_bits);
 		}
 	} else {
 		command_transient_bits |= Gi_Disarm_Bit;
 	}
 	ni_tio_set_bits_transient(counter,
-		NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
-		command_transient_bits);
+				  NITIO_Gi_Command_Reg(counter->counter_index),
+				  0, 0, command_transient_bits);
 	return 0;
 }
 
@@ -569,7 +606,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 	unsigned ni_660x_clock;
 	unsigned i;
 	const unsigned clock_select_bits =
-		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
@@ -604,7 +641,7 @@ static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 			break;
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
 			if (clock_select_bits ==
-				NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
+			    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
 				ni_660x_clock = NI_660x_Source_Pin_Clock(i);
 				break;
 			}
@@ -623,7 +660,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 	unsigned ni_m_series_clock;
 	unsigned i;
 	const unsigned clock_select_bits =
-		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	    clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
 	switch (clock_select_bits) {
 	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
 		ni_m_series_clock = NI_M_Series_Timebase_1_Clock;
@@ -670,7 +707,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
 		printk("invalid clock source 0x%lx\n",
-			(unsigned long)clock_source);
+		       (unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;
 		break;
@@ -679,11 +716,11 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 };
 
 static void ni_tio_set_source_subselect(struct ni_gpct *counter,
-	unsigned int clock_source)
+					unsigned int clock_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 
 	if (counter_dev->variant != ni_gpct_variant_m_series)
 		return;
@@ -704,11 +741,12 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 		break;
 	}
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 }
 
 static int ni_tio_set_clock_src(struct ni_gpct *counter,
-	unsigned int clock_source, unsigned int period_ns)
+				unsigned int clock_source,
+				unsigned int period_ns)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned input_select_bits = 0;
@@ -722,7 +760,7 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	case ni_gpct_variant_e_series:
 	case ni_gpct_variant_m_series:
 		input_select_bits |=
-			ni_m_series_source_select_bits(clock_source);
+		    ni_m_series_source_select_bits(clock_source);
 		break;
 	default:
 		BUG();
@@ -731,13 +769,13 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
 		input_select_bits |= Gi_Source_Polarity_Bit;
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
-		input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
+			input_select_bits);
 	ni_tio_set_source_subselect(counter, clock_source);
 	if (ni_tio_counting_mode_registers_present(counter_dev)) {
 		const unsigned prescaling_mode =
-			clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
+		    clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
 		unsigned counting_mode_bits = 0;
 
 		switch (prescaling_mode) {
@@ -745,21 +783,22 @@ static int ni_tio_set_clock_src(struct ni_gpct *counter,
 			break;
 		case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
 			counting_mode_bits |=
-				Gi_Prescale_X2_Bit(counter_dev->variant);
+			    Gi_Prescale_X2_Bit(counter_dev->variant);
 			break;
 		case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
 			counting_mode_bits |=
-				Gi_Prescale_X8_Bit(counter_dev->variant);
+			    Gi_Prescale_X8_Bit(counter_dev->variant);
 			break;
 		default:
 			return -EINVAL;
 			break;
 		}
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
-			Gi_Prescale_X2_Bit(counter_dev->
-				variant) | Gi_Prescale_X8_Bit(counter_dev->
-				variant), counting_mode_bits);
+				NITIO_Gi_Counting_Mode_Reg(counter->
+							   counter_index),
+				Gi_Prescale_X2_Bit(counter_dev->variant) |
+				Gi_Prescale_X8_Bit(counter_dev->variant),
+				counting_mode_bits);
 	}
 	counter->clock_period_ps = pico_per_nano * period_ns;
 	ni_tio_set_sync_mode(counter, 0);
@@ -770,12 +809,15 @@ static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,
-		NITIO_Gi_Counting_Mode_Reg(counter->counter_index));
+								 NITIO_Gi_Counting_Mode_Reg
+								 (counter->
+								  counter_index));
 	unsigned bits = 0;
 
 	if (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Polarity_Bit)
+				 NITIO_Gi_Input_Select_Reg
+				 (counter->counter_index)) &
+	    Gi_Source_Polarity_Bit)
 		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
 	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
 		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
@@ -788,13 +830,14 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Select_Mask) >>
-		Gi_Source_Select_Shift;
+							    NITIO_Gi_Input_Select_Reg
+							    (counter->counter_index))
+				       & Gi_Source_Select_Mask) >>
+	    Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_M_Series_Timebase_1_Clock:
@@ -804,10 +847,10 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
 		break;
 	case NI_M_Series_Timebase_3_Clock:
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
 			clock_source =
-				NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
+			    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
 		break;
@@ -815,8 +858,8 @@ static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
 		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
 		break;
 	case NI_M_Series_Next_Gate_Clock:
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Source_Subselect_Bit)
 			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
 		else
 			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
@@ -856,9 +899,10 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 	unsigned clock_source = 0;
 	unsigned i;
 	const unsigned input_select = (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Input_Select_Reg(counter->
-				counter_index)) & Gi_Source_Select_Mask) >>
-		Gi_Source_Select_Shift;
+							    NITIO_Gi_Input_Select_Reg
+							    (counter->counter_index))
+				       & Gi_Source_Select_Mask) >>
+	    Gi_Source_Select_Shift;
 
 	switch (input_select) {
 	case NI_660x_Timebase_1_Clock:
@@ -894,7 +938,7 @@ static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
 		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
 			if (input_select == NI_660x_Source_Pin_Clock(i)) {
 				clock_source =
-					NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
+				    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
 				break;
 			}
 		}
@@ -925,7 +969,7 @@ static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
 }
 
 static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
-	unsigned generic_clock_source)
+				       unsigned generic_clock_source)
 {
 	uint64_t clock_period_ps;
 
@@ -965,7 +1009,8 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 }
 
 static void ni_tio_get_clock_src(struct ni_gpct *counter,
-	unsigned int *clock_source, unsigned int *period_ns)
+				 unsigned int *clock_source,
+				 unsigned int *period_ns)
 {
 	static const unsigned pico_per_nano = 1000;
 	uint64_t temp64;
@@ -976,7 +1021,7 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 }
 
 static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
-	unsigned int gate_source)
+					    unsigned int gate_source)
 {
 	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
 	unsigned mode_values = 0;
@@ -990,10 +1035,11 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 		mode_values |= Gi_Level_Gating_Bits;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
-		mode_mask, mode_values);
+			mode_mask, mode_values);
 }
 
-static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_source)
+static int ni_660x_set_first_gate(struct ni_gpct *counter,
+				  unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1015,7 +1061,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_sou
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_660x_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1024,7 +1070,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_sou
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
 			if (selected_gate == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
 				ni_660x_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1034,13 +1080,14 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_sou
 		break;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(ni_660x_gate_select));
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Mask,
+			Gi_Gate_Select_Bits(ni_660x_gate_select));
 	return 0;
 }
 
 static int ni_m_series_set_first_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				      unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1063,7 +1110,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_m_series_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1072,7 +1119,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
 			if (selected_gate == NI_GPCT_PFI_GATE_SELECT(i)) {
 				ni_m_series_gate_select =
-					selected_gate & selected_gate_mask;
+				    selected_gate & selected_gate_mask;
 				break;
 			}
 		}
@@ -1082,18 +1129,18 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 		break;
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Gate_Select_Mask,
-		Gi_Gate_Select_Bits(ni_m_series_gate_select));
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Gate_Select_Mask,
+			Gi_Gate_Select_Bits(ni_m_series_gate_select));
 	return 0;
 }
 
 static int ni_660x_set_second_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				   unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1107,18 +1154,18 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 	case NI_GPCT_NEXT_OUT_GATE_SELECT:
 	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
 		ni_660x_second_gate_select =
-			selected_second_gate & selected_second_gate_mask;
+		    selected_second_gate & selected_second_gate_mask;
 		break;
 	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
 		ni_660x_second_gate_select =
-			NI_660x_Next_SRC_Second_Gate_Select;
+		    NI_660x_Next_SRC_Second_Gate_Select;
 		break;
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (selected_second_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
 				ni_660x_second_gate_select =
-					selected_second_gate &
-					selected_second_gate_mask;
+				    selected_second_gate &
+				    selected_second_gate_mask;
 				break;
 			}
 		}
@@ -1126,10 +1173,10 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
 			if (selected_second_gate ==
-				NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
+			    NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
 				ni_660x_second_gate_select =
-					selected_second_gate &
-					selected_second_gate_mask;
+				    selected_second_gate &
+				    selected_second_gate_mask;
 				break;
 			}
 		}
@@ -1141,18 +1188,18 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
-		Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
+	    Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 	return 0;
 }
 
 static int ni_m_series_set_second_gate(struct ni_gpct *counter,
-	unsigned int gate_source)
+				       unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	const unsigned selected_second_gate = CR_CHAN(gate_source);
 	/* bits of second_gate that may be meaningful to second gate register */
 	static const unsigned selected_second_gate_mask = 0x1f;
@@ -1163,31 +1210,33 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 	switch (selected_second_gate) {
 	default:
 		ni_m_series_second_gate_select =
-			selected_second_gate & selected_second_gate_mask;
+		    selected_second_gate & selected_second_gate_mask;
 		break;
 	};
 	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
 	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
 	counter_dev->regs[second_gate_reg] |=
-		Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
+	    Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
 	write_register(counter, counter_dev->regs[second_gate_reg],
-		second_gate_reg);
+		       second_gate_reg);
 	return 0;
 }
 
 int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int gate_source)
+			unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 
 	switch (gate_index) {
 	case 0:
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			ni_tio_set_bits(counter,
-				NITIO_Gi_Mode_Reg(counter->counter_index),
-				Gi_Gating_Mode_Mask, Gi_Gating_Disabled_Bits);
+					NITIO_Gi_Mode_Reg(counter->
+							  counter_index),
+					Gi_Gating_Mode_Mask,
+					Gi_Gating_Disabled_Bits);
 			return 0;
 		}
 		ni_tio_set_first_gate_modifiers(counter, gate_source);
@@ -1209,23 +1258,23 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 			return -EINVAL;
 		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
 			counter_dev->regs[second_gate_reg] &=
-				~Gi_Second_Gate_Mode_Bit;
+			    ~Gi_Second_Gate_Mode_Bit;
 			write_register(counter,
-				counter_dev->regs[second_gate_reg],
-				second_gate_reg);
+				       counter_dev->regs[second_gate_reg],
+				       second_gate_reg);
 			return 0;
 		}
 		if (gate_source & CR_INVERT) {
 			counter_dev->regs[second_gate_reg] |=
-				Gi_Second_Gate_Polarity_Bit;
+			    Gi_Second_Gate_Polarity_Bit;
 		} else {
 			counter_dev->regs[second_gate_reg] &=
-				~Gi_Second_Gate_Polarity_Bit;
+			    ~Gi_Second_Gate_Polarity_Bit;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_m_series:
 			return ni_m_series_set_second_gate(counter,
-				gate_source);
+							   gate_source);
 			break;
 		case ni_gpct_variant_660x:
 			return ni_660x_set_second_gate(counter, gate_source);
@@ -1243,7 +1292,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
-	unsigned int source)
+				unsigned int source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 
@@ -1280,7 +1329,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 }
 
 static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
-	ni_660x_gate_select)
+							  ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1311,7 +1360,7 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 			break;
 		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_Gate_Pin_Gate_Select(i)) {
+			    NI_660x_Gate_Pin_Gate_Select(i)) {
 				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
 				break;
 			}
@@ -1325,7 +1374,7 @@ static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
 };
 
 static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
-	ni_m_series_gate_select)
+							      ni_m_series_gate_select)
 {
 	unsigned i;
 
@@ -1357,7 +1406,7 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 	default:
 		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
 			if (ni_m_series_gate_select ==
-				NI_M_Series_RTSI_Gate_Select(i)) {
+			    NI_M_Series_RTSI_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 				break;
 			}
@@ -1366,7 +1415,7 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 			break;
 		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
 			if (ni_m_series_gate_select ==
-				NI_M_Series_PFI_Gate_Select(i)) {
+			    NI_M_Series_PFI_Gate_Select(i)) {
 				return NI_GPCT_PFI_GATE_SELECT(i);
 				break;
 			}
@@ -1380,7 +1429,7 @@ static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
 };
 
 static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
-	ni_660x_gate_select)
+							   ni_660x_gate_select)
 {
 	unsigned i;
 
@@ -1406,7 +1455,7 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 	default:
 		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_RTSI_Second_Gate_Select(i)) {
+			    NI_660x_RTSI_Second_Gate_Select(i)) {
 				return NI_GPCT_RTSI_GATE_SELECT(i);
 				break;
 			}
@@ -1415,7 +1464,7 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 			break;
 		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
 			if (ni_660x_gate_select ==
-				NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
+			    NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
 				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
 				break;
 			}
@@ -1429,7 +1478,7 @@ static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
 };
 
 static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
-	ni_m_series_gate_select)
+							       ni_m_series_gate_select)
 {
 	/*FIXME: the second gate sources for the m series are undocumented, so we just return
 	 * the raw bits for now. */
@@ -1442,39 +1491,41 @@ static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
 };
 
 static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int *gate_source)
+			       unsigned int *gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
-		NITIO_Gi_Mode_Reg(counter->counter_index));
+							NITIO_Gi_Mode_Reg
+							(counter->
+							 counter_index));
 	const unsigned second_gate_reg =
-		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	    NITIO_Gi_Second_Gate_Reg(counter->counter_index);
 	unsigned gate_select_bits;
 
 	switch (gate_index) {
 	case 0:
 		if ((mode_bits & Gi_Gating_Mode_Mask) ==
-			Gi_Gating_Disabled_Bits) {
+		    Gi_Gating_Disabled_Bits) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		} else {
 			gate_select_bits =
-				(ni_tio_get_soft_copy(counter,
-					NITIO_Gi_Input_Select_Reg(counter->
-						counter_index)) &
-				Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
+			    (ni_tio_get_soft_copy(counter,
+						  NITIO_Gi_Input_Select_Reg
+						  (counter->counter_index)) &
+			     Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			*gate_source =
-				ni_m_series_first_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_m_series_first_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		case ni_gpct_variant_660x:
 			*gate_source =
-				ni_660x_first_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_660x_first_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		default:
 			BUG();
@@ -1489,36 +1540,35 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 		break;
 	case 1:
 		if ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits
-			|| (counter_dev->
-				regs[second_gate_reg] & Gi_Second_Gate_Mode_Bit)
-			== 0) {
+		    || (counter_dev->regs[second_gate_reg] &
+			Gi_Second_Gate_Mode_Bit)
+		    == 0) {
 			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
 			return 0;
 		} else {
 			gate_select_bits =
-				(counter_dev->
-				regs[second_gate_reg] &
-				Gi_Second_Gate_Select_Mask) >>
-				Gi_Second_Gate_Select_Shift;
+			    (counter_dev->regs[second_gate_reg] &
+			     Gi_Second_Gate_Select_Mask) >>
+			    Gi_Second_Gate_Select_Shift;
 		}
 		switch (counter_dev->variant) {
 		case ni_gpct_variant_e_series:
 		case ni_gpct_variant_m_series:
 			*gate_source =
-				ni_m_series_second_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_m_series_second_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		case ni_gpct_variant_660x:
 			*gate_source =
-				ni_660x_second_gate_to_generic_gate_source
-				(gate_select_bits);
+			    ni_660x_second_gate_to_generic_gate_source
+			    (gate_select_bits);
 			break;
 		default:
 			BUG();
 			break;
 		}
-		if (counter_dev->
-			regs[second_gate_reg] & Gi_Second_Gate_Polarity_Bit) {
+		if (counter_dev->regs[second_gate_reg] &
+		    Gi_Second_Gate_Polarity_Bit) {
 			*gate_source |= CR_INVERT;
 		}
 		/* second gate can't have edge/level mode set independently */
@@ -1534,7 +1584,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 int ni_tio_insn_config(struct ni_gpct *counter,
-	struct comedi_insn *insn, unsigned int *data)
+		       struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1578,7 +1628,8 @@ int ni_tio_insn_config(struct ni_gpct *counter,
 	return -EINVAL;
 }
 
-int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
+int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,
+		 unsigned int *data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1591,26 +1642,27 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned in
 	switch (channel) {
 	case 0:
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index),
-			Gi_Save_Trace_Bit, 0);
+				NITIO_Gi_Command_Reg(counter->counter_index),
+				Gi_Save_Trace_Bit, 0);
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index),
-			Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
+				NITIO_Gi_Command_Reg(counter->counter_index),
+				Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
 		/* The count doesn't get latched until the next clock edge, so it is possible the count
 		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
 		   atomic (apparently even when it's a 32 bit register according to 660x docs),
 		   we need to read twice and make sure the reading hasn't changed.  If it has,
 		   a third read will be correct since the count value will definitely have latched by then. */
 		first_read =
-			read_register(counter,
-			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		    read_register(counter,
+				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
 		second_read =
-			read_register(counter,
-			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		    read_register(counter,
+				  NITIO_Gi_SW_Save_Reg(counter->counter_index));
 		if (first_read != second_read)
 			correct_read =
-				read_register(counter,
-				NITIO_Gi_SW_Save_Reg(counter->counter_index));
+			    read_register(counter,
+					  NITIO_Gi_SW_Save_Reg(counter->
+							       counter_index));
 		else
 			correct_read = first_read;
 		data[0] = correct_read;
@@ -1618,13 +1670,13 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned in
 		break;
 	case 1:
 		data[0] =
-			counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->
-				counter_index)];
+		    counter_dev->
+		    regs[NITIO_Gi_LoadA_Reg(counter->counter_index)];
 		break;
 	case 2:
 		data[0] =
-			counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->
-				counter_index)];
+		    counter_dev->
+		    regs[NITIO_Gi_LoadB_Reg(counter->counter_index)];
 		break;
 	};
 	return 0;
@@ -1633,7 +1685,8 @@ int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned in
 static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 {
 	const unsigned bits = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+					    NITIO_Gxx_Status_Reg(counter->
+								 counter_index));
 
 	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index)) {
 		return NITIO_Gi_LoadB_Reg(counter->counter_index);
@@ -1642,7 +1695,8 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	}
 }
 
-int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
+int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,
+		 unsigned int *data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1657,22 +1711,23 @@ int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned in
 		load_reg = ni_tio_next_load_register(counter);
 		write_register(counter, data[0], load_reg);
 		ni_tio_set_bits_transient(counter,
-			NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
-			Gi_Load_Bit);
+					  NITIO_Gi_Command_Reg(counter->
+							       counter_index),
+					  0, 0, Gi_Load_Bit);
 		/* restore state of load reg to whatever the user set last set it to */
 		write_register(counter, counter_dev->regs[load_reg], load_reg);
 		break;
 	case 1:
 		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] =
-			data[0];
+		    data[0];
 		write_register(counter, data[0],
-			NITIO_Gi_LoadA_Reg(counter->counter_index));
+			       NITIO_Gi_LoadA_Reg(counter->counter_index));
 		break;
 	case 2:
 		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =
-			data[0];
+		    data[0];
 		write_register(counter, data[0],
-			NITIO_Gi_LoadB_Reg(counter->counter_index));
+			       NITIO_Gi_LoadB_Reg(counter->counter_index));
 		break;
 	default:
 		return -EINVAL;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 2b0441e646dd..785553d0cc9d 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -669,7 +669,7 @@ static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 		}
 		if (i <= ni_m_series_max_pfi_channel)
 			break;
-		rt_printk("invalid clock source 0x%lx\n",
+		printk("invalid clock source 0x%lx\n",
 			(unsigned long)clock_source);
 		BUG();
 		ni_m_series_clock = 0;
@@ -1273,7 +1273,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-/* rt_printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
+/* printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;

commit dae0dc30be7fa21b15a9d9534589286c6c3e68a3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:48 2009 -0400

    Staging: comedi: Remove parens around return values
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index bdb232635abd..2b0441e646dd 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -149,13 +149,13 @@ static const unsigned ni_660x_max_rtsi_channel = 6;
 static inline unsigned NI_660x_RTSI_Clock(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_rtsi_channel);
-	return (0xb + n);
+	return 0xb + n;
 }
 static const unsigned ni_660x_max_source_pin = 7;
 static inline unsigned NI_660x_Source_Pin_Clock(unsigned n)
 {
 	BUG_ON(n > ni_660x_max_source_pin);
-	return (0x2 + n);
+	return 0x2 + n;
 }
 
 /* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 7457b4ffbe8c..bdb232635abd 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -279,9 +279,9 @@ static void __exit ni_tio_cleanup_module(void)
 module_exit(ni_tio_cleanup_module);
 
 struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
-	void (*write_register) (struct ni_gpct * counter, unsigned bits,
+	void (*write_register) (struct ni_gpct *counter, unsigned bits,
 		enum ni_gpct_register reg),
-	unsigned (*read_register) (struct ni_gpct * counter,
+	unsigned (*read_register) (struct ni_gpct *counter,
 		enum ni_gpct_register reg), enum ni_gpct_variant variant,
 	unsigned num_counters)
 {
@@ -965,7 +965,7 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 }
 
 static void ni_tio_get_clock_src(struct ni_gpct *counter,
-	unsigned int * clock_source, unsigned int * period_ns)
+	unsigned int *clock_source, unsigned int *period_ns)
 {
 	static const unsigned pico_per_nano = 1000;
 	uint64_t temp64;
@@ -1442,7 +1442,7 @@ static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
 };
 
 static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	unsigned int * gate_source)
+	unsigned int *gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
@@ -1534,7 +1534,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 int ni_tio_insn_config(struct ni_gpct *counter,
-	struct comedi_insn * insn, unsigned int * data)
+	struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:

commit ddcb01d458e8cbe33c76e4af11636257e8a14cb0
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Tue Mar 24 19:30:57 2009 +0100

    Staging: comedi: replace __FUNCTION__ usages
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 53966e9816c1..7457b4ffbe8c 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1273,7 +1273,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-/* rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source); */
+/* rt_printk("%s %x %d %d\n", __func__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index 05a957540398..53966e9816c1 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1273,7 +1273,7 @@ static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
 		counter_dev->regs[abz_reg] &= ~mask;
 		counter_dev->regs[abz_reg] |= (source << shift) & mask;
 		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
-//              rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source);
+/* rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source); */
 		return 0;
 	}
 	return -EINVAL;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f5385b903d41..05a957540398 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -1534,7 +1534,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 int ni_tio_insn_config(struct ni_gpct *counter,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1578,7 +1578,7 @@ int ni_tio_insn_config(struct ni_gpct *counter,
 	return -EINVAL;
 }
 
-int ni_tio_rinsn(struct ni_gpct *counter, comedi_insn * insn, unsigned int * data)
+int ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1642,7 +1642,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	}
 }
 
-int ni_tio_winsn(struct ni_gpct *counter, comedi_insn * insn, unsigned int * data)
+int ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index efa9cf5546f5..f5385b903d41 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -278,7 +278,7 @@ static void __exit ni_tio_cleanup_module(void)
 
 module_exit(ni_tio_cleanup_module);
 
-struct ni_gpct_device *ni_gpct_device_construct(comedi_device * dev,
+struct ni_gpct_device *ni_gpct_device_construct(struct comedi_device * dev,
 	void (*write_register) (struct ni_gpct * counter, unsigned bits,
 		enum ni_gpct_register reg),
 	unsigned (*read_register) (struct ni_gpct * counter,

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
index f2fd095c4576..efa9cf5546f5 100644
--- a/drivers/staging/comedi/drivers/ni_tio.c
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -262,7 +262,7 @@ static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
 	return 0xb + n;
 }
 
-static const lsampl_t counter_status_mask =
+static const unsigned int counter_status_mask =
 	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
 
 static int __init ni_tio_init_module(void)
@@ -388,9 +388,9 @@ void ni_tio_init_counter(struct ni_gpct *counter)
 		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index), ~0, 0x0);
 }
 
-static lsampl_t ni_tio_counter_status(struct ni_gpct *counter)
+static unsigned int ni_tio_counter_status(struct ni_gpct *counter)
 {
-	lsampl_t status = 0;
+	unsigned int status = 0;
 	const unsigned bits = read_register(counter,
 		NITIO_Gxx_Status_Reg(counter->counter_index));
 	if (bits & Gi_Armed_Bit(counter->counter_index)) {
@@ -564,7 +564,7 @@ int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
 	return 0;
 }
 
-static unsigned ni_660x_source_select_bits(lsampl_t clock_source)
+static unsigned ni_660x_source_select_bits(unsigned int clock_source)
 {
 	unsigned ni_660x_clock;
 	unsigned i;
@@ -618,7 +618,7 @@ static unsigned ni_660x_source_select_bits(lsampl_t clock_source)
 	return Gi_Source_Select_Bits(ni_660x_clock);
 }
 
-static unsigned ni_m_series_source_select_bits(lsampl_t clock_source)
+static unsigned ni_m_series_source_select_bits(unsigned int clock_source)
 {
 	unsigned ni_m_series_clock;
 	unsigned i;
@@ -679,7 +679,7 @@ static unsigned ni_m_series_source_select_bits(lsampl_t clock_source)
 };
 
 static void ni_tio_set_source_subselect(struct ni_gpct *counter,
-	lsampl_t clock_source)
+	unsigned int clock_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
@@ -708,7 +708,7 @@ static void ni_tio_set_source_subselect(struct ni_gpct *counter,
 }
 
 static int ni_tio_set_clock_src(struct ni_gpct *counter,
-	lsampl_t clock_source, lsampl_t period_ns)
+	unsigned int clock_source, unsigned int period_ns)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned input_select_bits = 0;
@@ -965,7 +965,7 @@ static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
 }
 
 static void ni_tio_get_clock_src(struct ni_gpct *counter,
-	lsampl_t * clock_source, lsampl_t * period_ns)
+	unsigned int * clock_source, unsigned int * period_ns)
 {
 	static const unsigned pico_per_nano = 1000;
 	uint64_t temp64;
@@ -976,7 +976,7 @@ static void ni_tio_get_clock_src(struct ni_gpct *counter,
 }
 
 static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
-	lsampl_t gate_source)
+	unsigned int gate_source)
 {
 	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
 	unsigned mode_values = 0;
@@ -993,7 +993,7 @@ static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
 		mode_mask, mode_values);
 }
 
-static int ni_660x_set_first_gate(struct ni_gpct *counter, lsampl_t gate_source)
+static int ni_660x_set_first_gate(struct ni_gpct *counter, unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1040,7 +1040,7 @@ static int ni_660x_set_first_gate(struct ni_gpct *counter, lsampl_t gate_source)
 }
 
 static int ni_m_series_set_first_gate(struct ni_gpct *counter,
-	lsampl_t gate_source)
+	unsigned int gate_source)
 {
 	const unsigned selected_gate = CR_CHAN(gate_source);
 	/* bits of selected_gate that may be meaningful to input select register */
@@ -1089,7 +1089,7 @@ static int ni_m_series_set_first_gate(struct ni_gpct *counter,
 }
 
 static int ni_660x_set_second_gate(struct ni_gpct *counter,
-	lsampl_t gate_source)
+	unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
@@ -1148,7 +1148,7 @@ static int ni_660x_set_second_gate(struct ni_gpct *counter,
 }
 
 static int ni_m_series_set_second_gate(struct ni_gpct *counter,
-	lsampl_t gate_source)
+	unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
@@ -1176,7 +1176,7 @@ static int ni_m_series_set_second_gate(struct ni_gpct *counter,
 }
 
 int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	lsampl_t gate_source)
+	unsigned int gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned second_gate_reg =
@@ -1243,7 +1243,7 @@ int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
-	lsampl_t source)
+	unsigned int source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 
@@ -1442,7 +1442,7 @@ static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
 };
 
 static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
-	lsampl_t * gate_source)
+	unsigned int * gate_source)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
@@ -1534,7 +1534,7 @@ static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
 }
 
 int ni_tio_insn_config(struct ni_gpct *counter,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
@@ -1578,7 +1578,7 @@ int ni_tio_insn_config(struct ni_gpct *counter,
 	return -EINVAL;
 }
 
-int ni_tio_rinsn(struct ni_gpct *counter, comedi_insn * insn, lsampl_t * data)
+int ni_tio_rinsn(struct ni_gpct *counter, comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);
@@ -1642,7 +1642,7 @@ static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
 	}
 }
 
-int ni_tio_winsn(struct ni_gpct *counter, comedi_insn * insn, lsampl_t * data)
+int ni_tio_winsn(struct ni_gpct *counter, comedi_insn * insn, unsigned int * data)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	const unsigned channel = CR_CHAN(insn->chanspec);

commit cb7859a90af1c6dedcc244f4b680ee68ed607add
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 12 15:39:24 2009 -0800

    Staging: comedi: add National Instruments infrastructure
    
    These drivers are used to support National Instruments general purpose
    counters and commands.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: J.P. Mellor <jpmellor@rose-hulman.edu>
    Cc: Herman Bruyninckx <Herman.Bruyninckx@mech.kuleuven.ac.be>
    Cc: Wim Meeussen <Wim.Meeussen@mech.kuleuven.ac.be>
    Cc: Klass Gadeyne <Klaas.Gadeyne@mech.kuleuven.ac.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tio.c b/drivers/staging/comedi/drivers/ni_tio.c
new file mode 100644
index 000000000000..f2fd095c4576
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_tio.c
@@ -0,0 +1,1691 @@
+/*
+  comedi/drivers/ni_tio.c
+  Support for NI general purpose counters
+
+  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+Driver: ni_tio
+Description: National Instruments general purpose counters
+Devices:
+Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
+	Herman.Bruyninckx@mech.kuleuven.ac.be,
+	Wim.Meeussen@mech.kuleuven.ac.be,
+	Klaas.Gadeyne@mech.kuleuven.ac.be,
+	Frank Mori Hess <fmhess@users.sourceforge.net>
+Updated: Thu Nov 16 09:50:32 EST 2006
+Status: works
+
+This module is not used directly by end-users.  Rather, it
+is used by other drivers (for example ni_660x and ni_pcimio)
+to provide support for NI's general purpose counters.  It was
+originally based on the counter code from ni_660x.c and
+ni_mio_common.c.
+
+References:
+DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
+DAQ 6601/6602 User Manual (NI 322137B-01)
+340934b.pdf  DAQ-STC reference manual
+
+*/
+/*
+TODO:
+	Support use of both banks X and Y
+*/
+
+#include "ni_tio_internal.h"
+
+static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
+	unsigned generic_clock_source);
+static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter);
+
+MODULE_AUTHOR("Comedi <comedi@comedi.org>");
+MODULE_DESCRIPTION("Comedi support for NI general-purpose counters");
+MODULE_LICENSE("GPL");
+
+static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum
+	ni_gpct_variant variant)
+{
+	switch (variant) {
+	case ni_gpct_variant_e_series:
+		return 0;
+		break;
+	case ni_gpct_variant_m_series:
+		return Gi_M_Series_Alternate_Sync_Bit;
+		break;
+	case ni_gpct_variant_660x:
+		return Gi_660x_Alternate_Sync_Bit;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum
+	ni_gpct_variant variant)
+{
+	switch (variant) {
+	case ni_gpct_variant_e_series:
+		return 0;
+		break;
+	case ni_gpct_variant_m_series:
+		return Gi_M_Series_Prescale_X2_Bit;
+		break;
+	case ni_gpct_variant_660x:
+		return Gi_660x_Prescale_X2_Bit;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+static inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum
+	ni_gpct_variant variant)
+{
+	switch (variant) {
+	case ni_gpct_variant_e_series:
+		return 0;
+		break;
+	case ni_gpct_variant_m_series:
+		return Gi_M_Series_Prescale_X8_Bit;
+		break;
+	case ni_gpct_variant_660x:
+		return Gi_660x_Prescale_X8_Bit;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+static inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum
+	ni_gpct_variant variant)
+{
+	switch (variant) {
+	case ni_gpct_variant_e_series:
+		return 0;
+		break;
+	case ni_gpct_variant_m_series:
+		return Gi_M_Series_HW_Arm_Select_Mask;
+		break;
+	case ni_gpct_variant_660x:
+		return Gi_660x_HW_Arm_Select_Mask;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+
+/* clock sources for ni_660x boards, get bits with Gi_Source_Select_Bits() */
+enum ni_660x_clock_source {
+	NI_660x_Timebase_1_Clock = 0x0,	/* 20MHz */
+	NI_660x_Source_Pin_i_Clock = 0x1,
+	NI_660x_Next_Gate_Clock = 0xa,
+	NI_660x_Timebase_2_Clock = 0x12,	/* 100KHz */
+	NI_660x_Next_TC_Clock = 0x13,
+	NI_660x_Timebase_3_Clock = 0x1e,	/* 80MHz */
+	NI_660x_Logic_Low_Clock = 0x1f,
+};
+static const unsigned ni_660x_max_rtsi_channel = 6;
+static inline unsigned NI_660x_RTSI_Clock(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_rtsi_channel);
+	return (0xb + n);
+}
+static const unsigned ni_660x_max_source_pin = 7;
+static inline unsigned NI_660x_Source_Pin_Clock(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_source_pin);
+	return (0x2 + n);
+}
+
+/* clock sources for ni e and m series boards, get bits with Gi_Source_Select_Bits() */
+enum ni_m_series_clock_source {
+	NI_M_Series_Timebase_1_Clock = 0x0,	/* 20MHz */
+	NI_M_Series_Timebase_2_Clock = 0x12,	/* 100KHz */
+	NI_M_Series_Next_TC_Clock = 0x13,
+	NI_M_Series_Next_Gate_Clock = 0x14,	/* when Gi_Src_SubSelect = 0 */
+	NI_M_Series_PXI_Star_Trigger_Clock = 0x14,	/* when Gi_Src_SubSelect = 1 */
+	NI_M_Series_PXI10_Clock = 0x1d,
+	NI_M_Series_Timebase_3_Clock = 0x1e,	/* 80MHz, when Gi_Src_SubSelect = 0 */
+	NI_M_Series_Analog_Trigger_Out_Clock = 0x1e,	/* when Gi_Src_SubSelect = 1 */
+	NI_M_Series_Logic_Low_Clock = 0x1f,
+};
+static const unsigned ni_m_series_max_pfi_channel = 15;
+static inline unsigned NI_M_Series_PFI_Clock(unsigned n)
+{
+	BUG_ON(n > ni_m_series_max_pfi_channel);
+	if (n < 10)
+		return 1 + n;
+	else
+		return 0xb + n;
+}
+static const unsigned ni_m_series_max_rtsi_channel = 7;
+static inline unsigned NI_M_Series_RTSI_Clock(unsigned n)
+{
+	BUG_ON(n > ni_m_series_max_rtsi_channel);
+	if (n == 7)
+		return 0x1b;
+	else
+		return 0xb + n;
+}
+
+enum ni_660x_gate_select {
+	NI_660x_Source_Pin_i_Gate_Select = 0x0,
+	NI_660x_Gate_Pin_i_Gate_Select = 0x1,
+	NI_660x_Next_SRC_Gate_Select = 0xa,
+	NI_660x_Next_Out_Gate_Select = 0x14,
+	NI_660x_Logic_Low_Gate_Select = 0x1f,
+};
+static const unsigned ni_660x_max_gate_pin = 7;
+static inline unsigned NI_660x_Gate_Pin_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_gate_pin);
+	return 0x2 + n;
+}
+static inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_rtsi_channel);
+	return 0xb + n;
+}
+
+enum ni_m_series_gate_select {
+	NI_M_Series_Timestamp_Mux_Gate_Select = 0x0,
+	NI_M_Series_AI_START2_Gate_Select = 0x12,
+	NI_M_Series_PXI_Star_Trigger_Gate_Select = 0x13,
+	NI_M_Series_Next_Out_Gate_Select = 0x14,
+	NI_M_Series_AI_START1_Gate_Select = 0x1c,
+	NI_M_Series_Next_SRC_Gate_Select = 0x1d,
+	NI_M_Series_Analog_Trigger_Out_Gate_Select = 0x1e,
+	NI_M_Series_Logic_Low_Gate_Select = 0x1f,
+};
+static inline unsigned NI_M_Series_RTSI_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_m_series_max_rtsi_channel);
+	if (n == 7)
+		return 0x1b;
+	return 0xb + n;
+}
+static inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_m_series_max_pfi_channel);
+	if (n < 10)
+		return 1 + n;
+	return 0xb + n;
+}
+
+static inline unsigned Gi_Source_Select_Bits(unsigned source)
+{
+	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
+}
+static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
+{
+	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
+}
+
+enum ni_660x_second_gate_select {
+	NI_660x_Source_Pin_i_Second_Gate_Select = 0x0,
+	NI_660x_Up_Down_Pin_i_Second_Gate_Select = 0x1,
+	NI_660x_Next_SRC_Second_Gate_Select = 0xa,
+	NI_660x_Next_Out_Second_Gate_Select = 0x14,
+	NI_660x_Selected_Gate_Second_Gate_Select = 0x1e,
+	NI_660x_Logic_Low_Second_Gate_Select = 0x1f,
+};
+static const unsigned ni_660x_max_up_down_pin = 7;
+static inline unsigned NI_660x_Up_Down_Pin_Second_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_up_down_pin);
+	return 0x2 + n;
+}
+static inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)
+{
+	BUG_ON(n > ni_660x_max_rtsi_channel);
+	return 0xb + n;
+}
+
+static const lsampl_t counter_status_mask =
+	COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;
+
+static int __init ni_tio_init_module(void)
+{
+	return 0;
+}
+
+module_init(ni_tio_init_module);
+
+static void __exit ni_tio_cleanup_module(void)
+{
+}
+
+module_exit(ni_tio_cleanup_module);
+
+struct ni_gpct_device *ni_gpct_device_construct(comedi_device * dev,
+	void (*write_register) (struct ni_gpct * counter, unsigned bits,
+		enum ni_gpct_register reg),
+	unsigned (*read_register) (struct ni_gpct * counter,
+		enum ni_gpct_register reg), enum ni_gpct_variant variant,
+	unsigned num_counters)
+{
+	unsigned i;
+
+	struct ni_gpct_device *counter_dev =
+		kzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);
+	if (counter_dev == NULL)
+		return NULL;
+	counter_dev->dev = dev;
+	counter_dev->write_register = write_register;
+	counter_dev->read_register = read_register;
+	counter_dev->variant = variant;
+	spin_lock_init(&counter_dev->regs_lock);
+	BUG_ON(num_counters == 0);
+	counter_dev->counters =
+		kzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);
+	if (counter_dev->counters == NULL) {
+		kfree(counter_dev);
+		return NULL;
+	}
+	for (i = 0; i < num_counters; ++i) {
+		counter_dev->counters[i].counter_dev = counter_dev;
+		spin_lock_init(&counter_dev->counters[i].lock);
+	}
+	counter_dev->num_counters = num_counters;
+	return counter_dev;
+}
+
+void ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)
+{
+	if (counter_dev->counters == NULL)
+		return;
+	kfree(counter_dev->counters);
+	kfree(counter_dev);
+}
+
+static int ni_tio_second_gate_registers_present(const struct ni_gpct_device
+	*counter_dev)
+{
+	switch (counter_dev->variant) {
+	case ni_gpct_variant_e_series:
+		return 0;
+		break;
+	case ni_gpct_variant_m_series:
+	case ni_gpct_variant_660x:
+		return 1;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+
+static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
+{
+	write_register(counter, Gi_Reset_Bit(counter->counter_index),
+		NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
+}
+
+void ni_tio_init_counter(struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+
+	ni_tio_reset_count_and_disarm(counter);
+	/* initialize counter registers */
+	counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)] =
+		0x0;
+	write_register(counter,
+		counter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->
+				counter_index)],
+		NITIO_Gi_Autoincrement_Reg(counter->counter_index));
+	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+		~0, Gi_Synchronize_Gate_Bit);
+	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,
+		0);
+	counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;
+	write_register(counter,
+		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)],
+		NITIO_Gi_LoadA_Reg(counter->counter_index));
+	counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;
+	write_register(counter,
+		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)],
+		NITIO_Gi_LoadB_Reg(counter->counter_index));
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index), ~0, 0);
+	if (ni_tio_counting_mode_registers_present(counter_dev)) {
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Counting_Mode_Reg(counter->counter_index), ~0,
+			0);
+	}
+	if (ni_tio_second_gate_registers_present(counter_dev)) {
+		counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
+				counter_index)] = 0x0;
+		write_register(counter,
+			counter_dev->regs[NITIO_Gi_Second_Gate_Reg(counter->
+					counter_index)],
+			NITIO_Gi_Second_Gate_Reg(counter->counter_index));
+	}
+	ni_tio_set_bits(counter,
+		NITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0, 0x0);
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index), ~0, 0x0);
+}
+
+static lsampl_t ni_tio_counter_status(struct ni_gpct *counter)
+{
+	lsampl_t status = 0;
+	const unsigned bits = read_register(counter,
+		NITIO_Gxx_Status_Reg(counter->counter_index));
+	if (bits & Gi_Armed_Bit(counter->counter_index)) {
+		status |= COMEDI_COUNTER_ARMED;
+		if (bits & Gi_Counting_Bit(counter->counter_index))
+			status |= COMEDI_COUNTER_COUNTING;
+	}
+	return status;
+}
+
+static void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned counting_mode_reg =
+		NITIO_Gi_Counting_Mode_Reg(counter->counter_index);
+	static const uint64_t min_normal_sync_period_ps = 25000;
+	const uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,
+		ni_tio_generic_clock_src_select(counter));
+
+	if (ni_tio_counting_mode_registers_present(counter_dev) == 0)
+		return;
+
+	switch (ni_tio_get_soft_copy(counter,
+			counting_mode_reg) & Gi_Counting_Mode_Mask) {
+	case Gi_Counting_Mode_QuadratureX1_Bits:
+	case Gi_Counting_Mode_QuadratureX2_Bits:
+	case Gi_Counting_Mode_QuadratureX4_Bits:
+	case Gi_Counting_Mode_Sync_Source_Bits:
+		force_alt_sync = 1;
+		break;
+	default:
+		break;
+	}
+	/* It's not clear what we should do if clock_period is unknown, so we are not
+	   using the alt sync bit in that case, but allow the caller to decide by using the
+	   force_alt_sync parameter. */
+	if (force_alt_sync ||
+		(clock_period_ps
+			&& clock_period_ps < min_normal_sync_period_ps)) {
+		ni_tio_set_bits(counter, counting_mode_reg,
+			Gi_Alternate_Sync_Bit(counter_dev->variant),
+			Gi_Alternate_Sync_Bit(counter_dev->variant));
+	} else {
+		ni_tio_set_bits(counter, counting_mode_reg,
+			Gi_Alternate_Sync_Bit(counter_dev->variant), 0x0);
+	}
+}
+
+static int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned mode_reg_mask;
+	unsigned mode_reg_values;
+	unsigned input_select_bits = 0;
+	/* these bits map directly on to the mode register */
+	static const unsigned mode_reg_direct_mask =
+		NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |
+		NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |
+		NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |
+		NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;
+
+	mode_reg_mask = mode_reg_direct_mask | Gi_Reload_Source_Switching_Bit;
+	mode_reg_values = mode & mode_reg_direct_mask;
+	switch (mode & NI_GPCT_RELOAD_SOURCE_MASK) {
+	case NI_GPCT_RELOAD_SOURCE_FIXED_BITS:
+		break;
+	case NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS:
+		mode_reg_values |= Gi_Reload_Source_Switching_Bit;
+		break;
+	case NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:
+		input_select_bits |= Gi_Gate_Select_Load_Source_Bit;
+		mode_reg_mask |= Gi_Gating_Mode_Mask;
+		mode_reg_values |= Gi_Level_Gating_Bits;
+		break;
+	default:
+		break;
+	}
+	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
+		mode_reg_mask, mode_reg_values);
+
+	if (ni_tio_counting_mode_registers_present(counter_dev)) {
+		unsigned counting_mode_bits = 0;
+		counting_mode_bits |=
+			(mode >> NI_GPCT_COUNTING_MODE_SHIFT) &
+			Gi_Counting_Mode_Mask;
+		counting_mode_bits |=
+			((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<
+			Gi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;
+		if (mode & NI_GPCT_INDEX_ENABLE_BIT) {
+			counting_mode_bits |= Gi_Index_Mode_Bit;
+		}
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
+			Gi_Counting_Mode_Mask | Gi_Index_Phase_Mask |
+			Gi_Index_Mode_Bit, counting_mode_bits);
+		ni_tio_set_sync_mode(counter, 0);
+	}
+
+	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+		Gi_Up_Down_Mask,
+		(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) << Gi_Up_Down_Shift);
+
+	if (mode & NI_GPCT_OR_GATE_BIT) {
+		input_select_bits |= Gi_Or_Gate_Bit;
+	}
+	if (mode & NI_GPCT_INVERT_OUTPUT_BIT) {
+		input_select_bits |= Gi_Output_Polarity_Bit;
+	}
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index),
+		Gi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |
+		Gi_Output_Polarity_Bit, input_select_bits);
+
+	return 0;
+}
+
+int ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+
+	unsigned command_transient_bits = 0;
+
+	if (arm) {
+		switch (start_trigger) {
+		case NI_GPCT_ARM_IMMEDIATE:
+			command_transient_bits |= Gi_Arm_Bit;
+			break;
+		case NI_GPCT_ARM_PAIRED_IMMEDIATE:
+			command_transient_bits |= Gi_Arm_Bit | Gi_Arm_Copy_Bit;
+			break;
+		default:
+			break;
+		}
+		if (ni_tio_counting_mode_registers_present(counter_dev)) {
+			unsigned counting_mode_bits = 0;
+
+			switch (start_trigger) {
+			case NI_GPCT_ARM_IMMEDIATE:
+			case NI_GPCT_ARM_PAIRED_IMMEDIATE:
+				break;
+			default:
+				if (start_trigger & NI_GPCT_ARM_UNKNOWN) {
+					/* pass-through the least significant bits so we can figure out what select later */
+					unsigned hw_arm_select_bits =
+						(start_trigger <<
+						Gi_HW_Arm_Select_Shift) &
+						Gi_HW_Arm_Select_Mask
+						(counter_dev->variant);
+
+					counting_mode_bits |=
+						Gi_HW_Arm_Enable_Bit |
+						hw_arm_select_bits;
+				} else {
+					return -EINVAL;
+				}
+				break;
+			}
+			ni_tio_set_bits(counter,
+				NITIO_Gi_Counting_Mode_Reg(counter->
+					counter_index),
+				Gi_HW_Arm_Select_Mask(counter_dev->
+					variant) | Gi_HW_Arm_Enable_Bit,
+				counting_mode_bits);
+		}
+	} else {
+		command_transient_bits |= Gi_Disarm_Bit;
+	}
+	ni_tio_set_bits_transient(counter,
+		NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
+		command_transient_bits);
+	return 0;
+}
+
+static unsigned ni_660x_source_select_bits(lsampl_t clock_source)
+{
+	unsigned ni_660x_clock;
+	unsigned i;
+	const unsigned clock_select_bits =
+		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+
+	switch (clock_select_bits) {
+	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Timebase_1_Clock;
+		break;
+	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Timebase_2_Clock;
+		break;
+	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Timebase_3_Clock;
+		break;
+	case NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Logic_Low_Clock;
+		break;
+	case NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Source_Pin_i_Clock;
+		break;
+	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Next_Gate_Clock;
+		break;
+	case NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:
+		ni_660x_clock = NI_660x_Next_TC_Clock;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
+				ni_660x_clock = NI_660x_RTSI_Clock(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
+			if (clock_select_bits ==
+				NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {
+				ni_660x_clock = NI_660x_Source_Pin_Clock(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_source_pin)
+			break;
+		ni_660x_clock = 0;
+		BUG();
+		break;
+	}
+	return Gi_Source_Select_Bits(ni_660x_clock);
+}
+
+static unsigned ni_m_series_source_select_bits(lsampl_t clock_source)
+{
+	unsigned ni_m_series_clock;
+	unsigned i;
+	const unsigned clock_select_bits =
+		clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;
+	switch (clock_select_bits) {
+	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Timebase_1_Clock;
+		break;
+	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Timebase_2_Clock;
+		break;
+	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Timebase_3_Clock;
+		break;
+	case NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Logic_Low_Clock;
+		break;
+	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Next_Gate_Clock;
+		break;
+	case NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Next_TC_Clock;
+		break;
+	case NI_GPCT_PXI10_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_PXI10_Clock;
+		break;
+	case NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_PXI_Star_Trigger_Clock;
+		break;
+	case NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:
+		ni_m_series_clock = NI_M_Series_Analog_Trigger_Out_Clock;
+		break;
+	default:
+		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+			if (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {
+				ni_m_series_clock = NI_M_Series_RTSI_Clock(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+			if (clock_select_bits == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {
+				ni_m_series_clock = NI_M_Series_PFI_Clock(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_pfi_channel)
+			break;
+		rt_printk("invalid clock source 0x%lx\n",
+			(unsigned long)clock_source);
+		BUG();
+		ni_m_series_clock = 0;
+		break;
+	}
+	return Gi_Source_Select_Bits(ni_m_series_clock);
+};
+
+static void ni_tio_set_source_subselect(struct ni_gpct *counter,
+	lsampl_t clock_source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+
+	if (counter_dev->variant != ni_gpct_variant_m_series)
+		return;
+	switch (clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {
+		/* Gi_Source_Subselect is zero */
+	case NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:
+	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
+		counter_dev->regs[second_gate_reg] &= ~Gi_Source_Subselect_Bit;
+		break;
+		/* Gi_Source_Subselect is one */
+	case NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:
+	case NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:
+		counter_dev->regs[second_gate_reg] |= Gi_Source_Subselect_Bit;
+		break;
+		/* Gi_Source_Subselect doesn't matter */
+	default:
+		return;
+		break;
+	}
+	write_register(counter, counter_dev->regs[second_gate_reg],
+		second_gate_reg);
+}
+
+static int ni_tio_set_clock_src(struct ni_gpct *counter,
+	lsampl_t clock_source, lsampl_t period_ns)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned input_select_bits = 0;
+	static const uint64_t pico_per_nano = 1000;
+
+/*FIXME: validate clock source */
+	switch (counter_dev->variant) {
+	case ni_gpct_variant_660x:
+		input_select_bits |= ni_660x_source_select_bits(clock_source);
+		break;
+	case ni_gpct_variant_e_series:
+	case ni_gpct_variant_m_series:
+		input_select_bits |=
+			ni_m_series_source_select_bits(clock_source);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	if (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)
+		input_select_bits |= Gi_Source_Polarity_Bit;
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index),
+		Gi_Source_Select_Mask | Gi_Source_Polarity_Bit,
+		input_select_bits);
+	ni_tio_set_source_subselect(counter, clock_source);
+	if (ni_tio_counting_mode_registers_present(counter_dev)) {
+		const unsigned prescaling_mode =
+			clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;
+		unsigned counting_mode_bits = 0;
+
+		switch (prescaling_mode) {
+		case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
+			break;
+		case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
+			counting_mode_bits |=
+				Gi_Prescale_X2_Bit(counter_dev->variant);
+			break;
+		case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
+			counting_mode_bits |=
+				Gi_Prescale_X8_Bit(counter_dev->variant);
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Counting_Mode_Reg(counter->counter_index),
+			Gi_Prescale_X2_Bit(counter_dev->
+				variant) | Gi_Prescale_X8_Bit(counter_dev->
+				variant), counting_mode_bits);
+	}
+	counter->clock_period_ps = pico_per_nano * period_ns;
+	ni_tio_set_sync_mode(counter, 0);
+	return 0;
+}
+
+static unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,
+		NITIO_Gi_Counting_Mode_Reg(counter->counter_index));
+	unsigned bits = 0;
+
+	if (ni_tio_get_soft_copy(counter,
+			NITIO_Gi_Input_Select_Reg(counter->
+				counter_index)) & Gi_Source_Polarity_Bit)
+		bits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;
+	if (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))
+		bits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;
+	if (counting_mode_bits & Gi_Prescale_X8_Bit(counter_dev->variant))
+		bits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;
+	return bits;
+}
+
+static unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	unsigned clock_source = 0;
+	unsigned i;
+	const unsigned input_select = (ni_tio_get_soft_copy(counter,
+			NITIO_Gi_Input_Select_Reg(counter->
+				counter_index)) & Gi_Source_Select_Mask) >>
+		Gi_Source_Select_Shift;
+
+	switch (input_select) {
+	case NI_M_Series_Timebase_1_Clock:
+		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_Timebase_2_Clock:
+		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_Timebase_3_Clock:
+		if (counter_dev->
+			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+			clock_source =
+				NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;
+		else
+			clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_Logic_Low_Clock:
+		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_Next_Gate_Clock:
+		if (counter_dev->
+			regs[second_gate_reg] & Gi_Source_Subselect_Bit)
+			clock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;
+		else
+			clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_PXI10_Clock:
+		clock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;
+		break;
+	case NI_M_Series_Next_TC_Clock:
+		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
+		break;
+	default:
+		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+			if (input_select == NI_M_Series_RTSI_Clock(i)) {
+				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+			if (input_select == NI_M_Series_PFI_Clock(i)) {
+				clock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_pfi_channel)
+			break;
+		BUG();
+		break;
+	}
+	clock_source |= ni_tio_clock_src_modifiers(counter);
+	return clock_source;
+}
+
+static unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)
+{
+	unsigned clock_source = 0;
+	unsigned i;
+	const unsigned input_select = (ni_tio_get_soft_copy(counter,
+			NITIO_Gi_Input_Select_Reg(counter->
+				counter_index)) & Gi_Source_Select_Mask) >>
+		Gi_Source_Select_Shift;
+
+	switch (input_select) {
+	case NI_660x_Timebase_1_Clock:
+		clock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Timebase_2_Clock:
+		clock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Timebase_3_Clock:
+		clock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Logic_Low_Clock:
+		clock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Source_Pin_i_Clock:
+		clock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Next_Gate_Clock:
+		clock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;
+		break;
+	case NI_660x_Next_TC_Clock:
+		clock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (input_select == NI_660x_RTSI_Clock(i)) {
+				clock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_source_pin; ++i) {
+			if (input_select == NI_660x_Source_Pin_Clock(i)) {
+				clock_source =
+					NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_source_pin)
+			break;
+		BUG();
+		break;
+	}
+	clock_source |= ni_tio_clock_src_modifiers(counter);
+	return clock_source;
+}
+
+static unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)
+{
+	switch (counter->counter_dev->variant) {
+	case ni_gpct_variant_e_series:
+	case ni_gpct_variant_m_series:
+		return ni_m_series_clock_src_select(counter);
+		break;
+	case ni_gpct_variant_660x:
+		return ni_660x_clock_src_select(counter);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return 0;
+}
+
+static uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,
+	unsigned generic_clock_source)
+{
+	uint64_t clock_period_ps;
+
+	switch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {
+	case NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:
+		clock_period_ps = 50000;
+		break;
+	case NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:
+		clock_period_ps = 10000000;
+		break;
+	case NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:
+		clock_period_ps = 12500;
+		break;
+	case NI_GPCT_PXI10_CLOCK_SRC_BITS:
+		clock_period_ps = 100000;
+		break;
+	default:
+		/* clock period is specified by user with prescaling already taken into account. */
+		return counter->clock_period_ps;
+		break;
+	}
+
+	switch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {
+	case NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:
+		break;
+	case NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:
+		clock_period_ps *= 2;
+		break;
+	case NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:
+		clock_period_ps *= 8;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return clock_period_ps;
+}
+
+static void ni_tio_get_clock_src(struct ni_gpct *counter,
+	lsampl_t * clock_source, lsampl_t * period_ns)
+{
+	static const unsigned pico_per_nano = 1000;
+	uint64_t temp64;
+	*clock_source = ni_tio_generic_clock_src_select(counter);
+	temp64 = ni_tio_clock_period_ps(counter, *clock_source);
+	do_div(temp64, pico_per_nano);
+	*period_ns = temp64;
+}
+
+static void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,
+	lsampl_t gate_source)
+{
+	const unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;
+	unsigned mode_values = 0;
+
+	if (gate_source & CR_INVERT) {
+		mode_values |= Gi_Gate_Polarity_Bit;
+	}
+	if (gate_source & CR_EDGE) {
+		mode_values |= Gi_Rising_Edge_Gating_Bits;
+	} else {
+		mode_values |= Gi_Level_Gating_Bits;
+	}
+	ni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),
+		mode_mask, mode_values);
+}
+
+static int ni_660x_set_first_gate(struct ni_gpct *counter, lsampl_t gate_source)
+{
+	const unsigned selected_gate = CR_CHAN(gate_source);
+	/* bits of selected_gate that may be meaningful to input select register */
+	const unsigned selected_gate_mask = 0x1f;
+	unsigned ni_660x_gate_select;
+	unsigned i;
+
+	switch (selected_gate) {
+	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
+		ni_660x_gate_select = NI_660x_Next_SRC_Gate_Select;
+		break;
+	case NI_GPCT_NEXT_OUT_GATE_SELECT:
+	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
+	case NI_GPCT_SOURCE_PIN_i_GATE_SELECT:
+	case NI_GPCT_GATE_PIN_i_GATE_SELECT:
+		ni_660x_gate_select = selected_gate & selected_gate_mask;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				ni_660x_gate_select =
+					selected_gate & selected_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
+			if (selected_gate == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {
+				ni_660x_gate_select =
+					selected_gate & selected_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_660x_max_gate_pin)
+			break;
+		return -EINVAL;
+		break;
+	}
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index),
+		Gi_Gate_Select_Mask, Gi_Gate_Select_Bits(ni_660x_gate_select));
+	return 0;
+}
+
+static int ni_m_series_set_first_gate(struct ni_gpct *counter,
+	lsampl_t gate_source)
+{
+	const unsigned selected_gate = CR_CHAN(gate_source);
+	/* bits of selected_gate that may be meaningful to input select register */
+	const unsigned selected_gate_mask = 0x1f;
+	unsigned ni_m_series_gate_select;
+	unsigned i;
+
+	switch (selected_gate) {
+	case NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:
+	case NI_GPCT_AI_START2_GATE_SELECT:
+	case NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT:
+	case NI_GPCT_NEXT_OUT_GATE_SELECT:
+	case NI_GPCT_AI_START1_GATE_SELECT:
+	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
+	case NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT:
+	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
+		ni_m_series_gate_select = selected_gate & selected_gate_mask;
+		break;
+	default:
+		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+			if (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				ni_m_series_gate_select =
+					selected_gate & selected_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+			if (selected_gate == NI_GPCT_PFI_GATE_SELECT(i)) {
+				ni_m_series_gate_select =
+					selected_gate & selected_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_pfi_channel)
+			break;
+		return -EINVAL;
+		break;
+	}
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index),
+		Gi_Gate_Select_Mask,
+		Gi_Gate_Select_Bits(ni_m_series_gate_select));
+	return 0;
+}
+
+static int ni_660x_set_second_gate(struct ni_gpct *counter,
+	lsampl_t gate_source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	const unsigned selected_second_gate = CR_CHAN(gate_source);
+	/* bits of second_gate that may be meaningful to second gate register */
+	static const unsigned selected_second_gate_mask = 0x1f;
+	unsigned ni_660x_second_gate_select;
+	unsigned i;
+
+	switch (selected_second_gate) {
+	case NI_GPCT_SOURCE_PIN_i_GATE_SELECT:
+	case NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT:
+	case NI_GPCT_SELECTED_GATE_GATE_SELECT:
+	case NI_GPCT_NEXT_OUT_GATE_SELECT:
+	case NI_GPCT_LOGIC_LOW_GATE_SELECT:
+		ni_660x_second_gate_select =
+			selected_second_gate & selected_second_gate_mask;
+		break;
+	case NI_GPCT_NEXT_SOURCE_GATE_SELECT:
+		ni_660x_second_gate_select =
+			NI_660x_Next_SRC_Second_Gate_Select;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (selected_second_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {
+				ni_660x_second_gate_select =
+					selected_second_gate &
+					selected_second_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
+			if (selected_second_gate ==
+				NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {
+				ni_660x_second_gate_select =
+					selected_second_gate &
+					selected_second_gate_mask;
+				break;
+			}
+		}
+		if (i <= ni_660x_max_up_down_pin)
+			break;
+		return -EINVAL;
+		break;
+	};
+	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
+	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
+	counter_dev->regs[second_gate_reg] |=
+		Gi_Second_Gate_Select_Bits(ni_660x_second_gate_select);
+	write_register(counter, counter_dev->regs[second_gate_reg],
+		second_gate_reg);
+	return 0;
+}
+
+static int ni_m_series_set_second_gate(struct ni_gpct *counter,
+	lsampl_t gate_source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	const unsigned selected_second_gate = CR_CHAN(gate_source);
+	/* bits of second_gate that may be meaningful to second gate register */
+	static const unsigned selected_second_gate_mask = 0x1f;
+	unsigned ni_m_series_second_gate_select;
+
+	/* FIXME: We don't know what the m-series second gate codes are, so we'll just pass
+	   the bits through for now. */
+	switch (selected_second_gate) {
+	default:
+		ni_m_series_second_gate_select =
+			selected_second_gate & selected_second_gate_mask;
+		break;
+	};
+	counter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;
+	counter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;
+	counter_dev->regs[second_gate_reg] |=
+		Gi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);
+	write_register(counter, counter_dev->regs[second_gate_reg],
+		second_gate_reg);
+	return 0;
+}
+
+int ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,
+	lsampl_t gate_source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+
+	switch (gate_index) {
+	case 0:
+		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
+			ni_tio_set_bits(counter,
+				NITIO_Gi_Mode_Reg(counter->counter_index),
+				Gi_Gating_Mode_Mask, Gi_Gating_Disabled_Bits);
+			return 0;
+		}
+		ni_tio_set_first_gate_modifiers(counter, gate_source);
+		switch (counter_dev->variant) {
+		case ni_gpct_variant_e_series:
+		case ni_gpct_variant_m_series:
+			return ni_m_series_set_first_gate(counter, gate_source);
+			break;
+		case ni_gpct_variant_660x:
+			return ni_660x_set_first_gate(counter, gate_source);
+			break;
+		default:
+			BUG();
+			break;
+		}
+		break;
+	case 1:
+		if (ni_tio_second_gate_registers_present(counter_dev) == 0)
+			return -EINVAL;
+		if (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {
+			counter_dev->regs[second_gate_reg] &=
+				~Gi_Second_Gate_Mode_Bit;
+			write_register(counter,
+				counter_dev->regs[second_gate_reg],
+				second_gate_reg);
+			return 0;
+		}
+		if (gate_source & CR_INVERT) {
+			counter_dev->regs[second_gate_reg] |=
+				Gi_Second_Gate_Polarity_Bit;
+		} else {
+			counter_dev->regs[second_gate_reg] &=
+				~Gi_Second_Gate_Polarity_Bit;
+		}
+		switch (counter_dev->variant) {
+		case ni_gpct_variant_m_series:
+			return ni_m_series_set_second_gate(counter,
+				gate_source);
+			break;
+		case ni_gpct_variant_660x:
+			return ni_660x_set_second_gate(counter, gate_source);
+			break;
+		default:
+			BUG();
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+static int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,
+	lsampl_t source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+
+	if (counter_dev->variant == ni_gpct_variant_m_series) {
+		unsigned int abz_reg, shift, mask;
+
+		abz_reg = NITIO_Gi_ABZ_Reg(counter->counter_index);
+		switch (index) {
+		case NI_GPCT_SOURCE_ENCODER_A:
+			shift = 10;
+			break;
+		case NI_GPCT_SOURCE_ENCODER_B:
+			shift = 5;
+			break;
+		case NI_GPCT_SOURCE_ENCODER_Z:
+			shift = 0;
+			break;
+		default:
+			return -EINVAL;
+			break;
+		}
+		mask = 0x1f << shift;
+		if (source > 0x1f) {
+			/* Disable gate */
+			source = 0x1f;
+		}
+		counter_dev->regs[abz_reg] &= ~mask;
+		counter_dev->regs[abz_reg] |= (source << shift) & mask;
+		write_register(counter, counter_dev->regs[abz_reg], abz_reg);
+//              rt_printk("%s %x %d %d\n", __FUNCTION__, counter_dev->regs[abz_reg], index, source);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static unsigned ni_660x_first_gate_to_generic_gate_source(unsigned
+	ni_660x_gate_select)
+{
+	unsigned i;
+
+	switch (ni_660x_gate_select) {
+	case NI_660x_Source_Pin_i_Gate_Select:
+		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		break;
+	case NI_660x_Gate_Pin_i_Gate_Select:
+		return NI_GPCT_GATE_PIN_i_GATE_SELECT;
+		break;
+	case NI_660x_Next_SRC_Gate_Select:
+		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
+	case NI_660x_Next_Out_Gate_Select:
+		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
+	case NI_660x_Logic_Low_Gate_Select:
+		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i)) {
+				return NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_gate_pin; ++i) {
+			if (ni_660x_gate_select ==
+				NI_660x_Gate_Pin_Gate_Select(i)) {
+				return NI_GPCT_GATE_PIN_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_gate_pin)
+			break;
+		BUG();
+		break;
+	}
+	return 0;
+};
+
+static unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned
+	ni_m_series_gate_select)
+{
+	unsigned i;
+
+	switch (ni_m_series_gate_select) {
+	case NI_M_Series_Timestamp_Mux_Gate_Select:
+		return NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;
+		break;
+	case NI_M_Series_AI_START2_Gate_Select:
+		return NI_GPCT_AI_START2_GATE_SELECT;
+		break;
+	case NI_M_Series_PXI_Star_Trigger_Gate_Select:
+		return NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;
+		break;
+	case NI_M_Series_Next_Out_Gate_Select:
+		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
+	case NI_M_Series_AI_START1_Gate_Select:
+		return NI_GPCT_AI_START1_GATE_SELECT;
+		break;
+	case NI_M_Series_Next_SRC_Gate_Select:
+		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
+	case NI_M_Series_Analog_Trigger_Out_Gate_Select:
+		return NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;
+		break;
+	case NI_M_Series_Logic_Low_Gate_Select:
+		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
+	default:
+		for (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {
+			if (ni_m_series_gate_select ==
+				NI_M_Series_RTSI_Gate_Select(i)) {
+				return NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {
+			if (ni_m_series_gate_select ==
+				NI_M_Series_PFI_Gate_Select(i)) {
+				return NI_GPCT_PFI_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_m_series_max_pfi_channel)
+			break;
+		BUG();
+		break;
+	}
+	return 0;
+};
+
+static unsigned ni_660x_second_gate_to_generic_gate_source(unsigned
+	ni_660x_gate_select)
+{
+	unsigned i;
+
+	switch (ni_660x_gate_select) {
+	case NI_660x_Source_Pin_i_Second_Gate_Select:
+		return NI_GPCT_SOURCE_PIN_i_GATE_SELECT;
+		break;
+	case NI_660x_Up_Down_Pin_i_Second_Gate_Select:
+		return NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;
+		break;
+	case NI_660x_Next_SRC_Second_Gate_Select:
+		return NI_GPCT_NEXT_SOURCE_GATE_SELECT;
+		break;
+	case NI_660x_Next_Out_Second_Gate_Select:
+		return NI_GPCT_NEXT_OUT_GATE_SELECT;
+		break;
+	case NI_660x_Selected_Gate_Second_Gate_Select:
+		return NI_GPCT_SELECTED_GATE_GATE_SELECT;
+		break;
+	case NI_660x_Logic_Low_Second_Gate_Select:
+		return NI_GPCT_LOGIC_LOW_GATE_SELECT;
+		break;
+	default:
+		for (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {
+			if (ni_660x_gate_select ==
+				NI_660x_RTSI_Second_Gate_Select(i)) {
+				return NI_GPCT_RTSI_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_rtsi_channel)
+			break;
+		for (i = 0; i <= ni_660x_max_up_down_pin; ++i) {
+			if (ni_660x_gate_select ==
+				NI_660x_Up_Down_Pin_Second_Gate_Select(i)) {
+				return NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);
+				break;
+			}
+		}
+		if (i <= ni_660x_max_up_down_pin)
+			break;
+		BUG();
+		break;
+	}
+	return 0;
+};
+
+static unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned
+	ni_m_series_gate_select)
+{
+	/*FIXME: the second gate sources for the m series are undocumented, so we just return
+	 * the raw bits for now. */
+	switch (ni_m_series_gate_select) {
+	default:
+		return ni_m_series_gate_select;
+		break;
+	}
+	return 0;
+};
+
+static int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,
+	lsampl_t * gate_source)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned mode_bits = ni_tio_get_soft_copy(counter,
+		NITIO_Gi_Mode_Reg(counter->counter_index));
+	const unsigned second_gate_reg =
+		NITIO_Gi_Second_Gate_Reg(counter->counter_index);
+	unsigned gate_select_bits;
+
+	switch (gate_index) {
+	case 0:
+		if ((mode_bits & Gi_Gating_Mode_Mask) ==
+			Gi_Gating_Disabled_Bits) {
+			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
+			return 0;
+		} else {
+			gate_select_bits =
+				(ni_tio_get_soft_copy(counter,
+					NITIO_Gi_Input_Select_Reg(counter->
+						counter_index)) &
+				Gi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;
+		}
+		switch (counter_dev->variant) {
+		case ni_gpct_variant_e_series:
+		case ni_gpct_variant_m_series:
+			*gate_source =
+				ni_m_series_first_gate_to_generic_gate_source
+				(gate_select_bits);
+			break;
+		case ni_gpct_variant_660x:
+			*gate_source =
+				ni_660x_first_gate_to_generic_gate_source
+				(gate_select_bits);
+			break;
+		default:
+			BUG();
+			break;
+		}
+		if (mode_bits & Gi_Gate_Polarity_Bit) {
+			*gate_source |= CR_INVERT;
+		}
+		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits) {
+			*gate_source |= CR_EDGE;
+		}
+		break;
+	case 1:
+		if ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits
+			|| (counter_dev->
+				regs[second_gate_reg] & Gi_Second_Gate_Mode_Bit)
+			== 0) {
+			*gate_source = NI_GPCT_DISABLED_GATE_SELECT;
+			return 0;
+		} else {
+			gate_select_bits =
+				(counter_dev->
+				regs[second_gate_reg] &
+				Gi_Second_Gate_Select_Mask) >>
+				Gi_Second_Gate_Select_Shift;
+		}
+		switch (counter_dev->variant) {
+		case ni_gpct_variant_e_series:
+		case ni_gpct_variant_m_series:
+			*gate_source =
+				ni_m_series_second_gate_to_generic_gate_source
+				(gate_select_bits);
+			break;
+		case ni_gpct_variant_660x:
+			*gate_source =
+				ni_660x_second_gate_to_generic_gate_source
+				(gate_select_bits);
+			break;
+		default:
+			BUG();
+			break;
+		}
+		if (counter_dev->
+			regs[second_gate_reg] & Gi_Second_Gate_Polarity_Bit) {
+			*gate_source |= CR_INVERT;
+		}
+		/* second gate can't have edge/level mode set independently */
+		if ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits) {
+			*gate_source |= CR_EDGE;
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+int ni_tio_insn_config(struct ni_gpct *counter,
+	comedi_insn * insn, lsampl_t * data)
+{
+	switch (data[0]) {
+	case INSN_CONFIG_SET_COUNTER_MODE:
+		return ni_tio_set_counter_mode(counter, data[1]);
+		break;
+	case INSN_CONFIG_ARM:
+		return ni_tio_arm(counter, 1, data[1]);
+		break;
+	case INSN_CONFIG_DISARM:
+		ni_tio_arm(counter, 0, 0);
+		return 0;
+		break;
+	case INSN_CONFIG_GET_COUNTER_STATUS:
+		data[1] = ni_tio_counter_status(counter);
+		data[2] = counter_status_mask;
+		return 0;
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		return ni_tio_set_clock_src(counter, data[1], data[2]);
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		ni_tio_get_clock_src(counter, &data[1], &data[2]);
+		return 0;
+		break;
+	case INSN_CONFIG_SET_GATE_SRC:
+		return ni_tio_set_gate_src(counter, data[1], data[2]);
+		break;
+	case INSN_CONFIG_GET_GATE_SRC:
+		return ni_tio_get_gate_src(counter, data[1], &data[2]);
+		break;
+	case INSN_CONFIG_SET_OTHER_SRC:
+		return ni_tio_set_other_src(counter, data[1], data[2]);
+		break;
+	case INSN_CONFIG_RESET:
+		ni_tio_reset_count_and_disarm(counter);
+		return 0;
+		break;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+int ni_tio_rinsn(struct ni_gpct *counter, comedi_insn * insn, lsampl_t * data)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned channel = CR_CHAN(insn->chanspec);
+	unsigned first_read;
+	unsigned second_read;
+	unsigned correct_read;
+
+	if (insn->n < 1)
+		return 0;
+	switch (channel) {
+	case 0:
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Command_Reg(counter->counter_index),
+			Gi_Save_Trace_Bit, 0);
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Command_Reg(counter->counter_index),
+			Gi_Save_Trace_Bit, Gi_Save_Trace_Bit);
+		/* The count doesn't get latched until the next clock edge, so it is possible the count
+		   may change (once) while we are reading.  Since the read of the SW_Save_Reg isn't
+		   atomic (apparently even when it's a 32 bit register according to 660x docs),
+		   we need to read twice and make sure the reading hasn't changed.  If it has,
+		   a third read will be correct since the count value will definitely have latched by then. */
+		first_read =
+			read_register(counter,
+			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		second_read =
+			read_register(counter,
+			NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		if (first_read != second_read)
+			correct_read =
+				read_register(counter,
+				NITIO_Gi_SW_Save_Reg(counter->counter_index));
+		else
+			correct_read = first_read;
+		data[0] = correct_read;
+		return 0;
+		break;
+	case 1:
+		data[0] =
+			counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->
+				counter_index)];
+		break;
+	case 2:
+		data[0] =
+			counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->
+				counter_index)];
+		break;
+	};
+	return 0;
+}
+
+static unsigned ni_tio_next_load_register(struct ni_gpct *counter)
+{
+	const unsigned bits = read_register(counter,
+		NITIO_Gxx_Status_Reg(counter->counter_index));
+
+	if (bits & Gi_Next_Load_Source_Bit(counter->counter_index)) {
+		return NITIO_Gi_LoadB_Reg(counter->counter_index);
+	} else {
+		return NITIO_Gi_LoadA_Reg(counter->counter_index);
+	}
+}
+
+int ni_tio_winsn(struct ni_gpct *counter, comedi_insn * insn, lsampl_t * data)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const unsigned channel = CR_CHAN(insn->chanspec);
+	unsigned load_reg;
+
+	if (insn->n < 1)
+		return 0;
+	switch (channel) {
+	case 0:
+		/* Unsafe if counter is armed.  Should probably check status and return -EBUSY if armed. */
+		/* Don't disturb load source select, just use whichever load register is already selected. */
+		load_reg = ni_tio_next_load_register(counter);
+		write_register(counter, data[0], load_reg);
+		ni_tio_set_bits_transient(counter,
+			NITIO_Gi_Command_Reg(counter->counter_index), 0, 0,
+			Gi_Load_Bit);
+		/* restore state of load reg to whatever the user set last set it to */
+		write_register(counter, counter_dev->regs[load_reg], load_reg);
+		break;
+	case 1:
+		counter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] =
+			data[0];
+		write_register(counter, data[0],
+			NITIO_Gi_LoadA_Reg(counter->counter_index));
+		break;
+	case 2:
+		counter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =
+			data[0];
+		write_register(counter, data[0],
+			NITIO_Gi_LoadB_Reg(counter->counter_index));
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ni_tio_rinsn);
+EXPORT_SYMBOL_GPL(ni_tio_winsn);
+EXPORT_SYMBOL_GPL(ni_tio_insn_config);
+EXPORT_SYMBOL_GPL(ni_tio_init_counter);
+EXPORT_SYMBOL_GPL(ni_tio_arm);
+EXPORT_SYMBOL_GPL(ni_tio_set_gate_src);
+EXPORT_SYMBOL_GPL(ni_gpct_device_construct);
+EXPORT_SYMBOL_GPL(ni_gpct_device_destroy);
