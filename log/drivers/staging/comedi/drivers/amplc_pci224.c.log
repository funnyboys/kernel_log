commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 5c9c67ca0131..657b736ef46d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -7,16 +7,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4e554944bc71..5c9c67ca0131 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/amplc_pci224.c
  * Driver for Amplicon PCI224 and PCI234 AO boards.

commit 2bbd5023ee09c8df507f7a6ed5ab45fc619a7ff6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 4 11:32:27 2017 +0100

    staging: comedi: amplc_pci224: convert CLK_CONFIG() macro to function
    
    Convert the `CLK_CLKFIG(chan, src)` macro to a static function
    `pci224_clk_config(chan, src)`.  This is consistent with an earlier
    change to convert `GAT_CONFIG(chan, src)` to a static function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 7de2cd5f0f7e..4e554944bc71 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -206,8 +206,11 @@
 #define CLK_1KHZ	5	/* internal 1 kHz clock */
 #define CLK_OUTNM1	6	/* output of channel-1 modulo total */
 #define CLK_EXT		7	/* external clock */
-/* Macro to construct clock input configuration register value. */
-#define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+static unsigned int pci224_clk_config(unsigned int chan, unsigned int src)
+{
+	return ((chan & 3) << 3) | (src & 7);
+}
 
 /*
  * Counter/timer gate input configuration sources.
@@ -825,9 +828,11 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 	/* Make sure Z2-2 is gated on.  */
 	outb(pci224_gat_config(2, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
 	/* Z2-2 needs 10 MHz clock. */
-	outb(CLK_CONFIG(2, CLK_10MHZ), devpriv->iobase1 + PCI224_ZCLK_SCE);
+	outb(pci224_clk_config(2, CLK_10MHZ),
+	     devpriv->iobase1 + PCI224_ZCLK_SCE);
 	/* Z2-0 is clocked from Z2-2's output. */
-	outb(CLK_CONFIG(0, CLK_OUTNM1), devpriv->iobase1 + PCI224_ZCLK_SCE);
+	outb(pci224_clk_config(0, CLK_OUTNM1),
+	     devpriv->iobase1 + PCI224_ZCLK_SCE);
 
 	comedi_8254_pacer_enable(dev->pacer, 2, 0, false);
 }

commit a19aa38022a37bee17e0aebf1053b1cf0496812d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Apr 4 11:32:26 2017 +0100

    staging: comedi: amplc_pci224: remove 'inline' from pci224_gat_config()
    
    Let the compiler figure out whether `pci224_gat_confip()` should be
    inlined by itself.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 07555cffc414..7de2cd5f0f7e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -217,8 +217,7 @@
 #define GAT_EXT		2	/* reserved (external gate input) */
 #define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
 
-static inline unsigned int pci224_gat_config(unsigned int chan,
-					     unsigned int src)
+static unsigned int pci224_gat_config(unsigned int chan, unsigned int src)
 {
 	return ((chan & 3) << 3) | (src & 7);
 }

commit cb52fce16027d79a97d0870a1110d4a4493fa0a8
Author: simran singhal <singhalsimran0@gmail.com>
Date:   Sun Mar 12 22:25:42 2017 +0530

    staging: comedi: amplc_pci224: Convert macro GAT_CONFIG to static inline function
    
    Convert macro GAT_CONFIG to static inline function as static inline
    functions are preferred over macros. This change is possible since the
    arguments at all call sites have the same type.
    
    The uses were updated with Coccinelle:
    
    @r1@
    expression dev,reg,chan,src;
    @@
    -GAT_CONFIG(chan, src)
    +pci224_gat_config(chan, src)
    
    Also, the comment describing the macro has been removed.
    
    Signed-off-by: simran singhal <singhalsimran0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 2e6decf1b69d..07555cffc414 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -216,8 +216,12 @@
 #define GAT_GND		1	/* GND (i.e. disabled) */
 #define GAT_EXT		2	/* reserved (external gate input) */
 #define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
-/* Macro to construct gate input configuration register value. */
-#define GAT_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+static inline unsigned int pci224_gat_config(unsigned int chan,
+					     unsigned int src)
+{
+	return ((chan & 3) << 3) | (src & 7);
+}
 
 /*
  * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI224 and PCI234:
@@ -817,10 +821,10 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 	 * source.
 	 */
 	/* Make sure Z2-0 is gated on.  */
-	outb(GAT_CONFIG(0, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
+	outb(pci224_gat_config(0, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
 	/* Cascading with Z2-2. */
 	/* Make sure Z2-2 is gated on.  */
-	outb(GAT_CONFIG(2, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
+	outb(pci224_gat_config(2, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
 	/* Z2-2 needs 10 MHz clock. */
 	outb(CLK_CONFIG(2, CLK_10MHZ), devpriv->iobase1 + PCI224_ZCLK_SCE);
 	/* Z2-0 is clocked from Z2-2's output. */

commit e078cb2a64fd588557ef2dec573622699a05d642
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 30 12:00:29 2016 -0700

    staging: comedi: amplc_pci224: Prefer using the BIT macro
    
    Fix the checkpatch.pl issues by using the BIT macro and defining some
    macros for the multi-bit fields.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index cac011fdd375..2e6decf1b69d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -132,48 +132,53 @@
  * DACCON values.
  */
 /* (r/w) Scan trigger. */
-#define PCI224_DACCON_TRIG_MASK		(7 << 0)
-#define PCI224_DACCON_TRIG_NONE		(0 << 0)	/* none */
-#define PCI224_DACCON_TRIG_SW		(1 << 0)	/* software trig */
-#define PCI224_DACCON_TRIG_EXTP		(2 << 0)	/* ext +ve edge */
-#define PCI224_DACCON_TRIG_EXTN		(3 << 0)	/* ext -ve edge */
-#define PCI224_DACCON_TRIG_Z2CT0	(4 << 0)	/* Z2 CT0 out */
-#define PCI224_DACCON_TRIG_Z2CT1	(5 << 0)	/* Z2 CT1 out */
-#define PCI224_DACCON_TRIG_Z2CT2	(6 << 0)	/* Z2 CT2 out */
+#define PCI224_DACCON_TRIG(x)		(((x) & 0x7) << 0)
+#define PCI224_DACCON_TRIG_MASK		PCI224_DACCON_TRIG(7)
+#define PCI224_DACCON_TRIG_NONE		PCI224_DACCON_TRIG(0)	/* none */
+#define PCI224_DACCON_TRIG_SW		PCI224_DACCON_TRIG(1)	/* soft trig */
+#define PCI224_DACCON_TRIG_EXTP		PCI224_DACCON_TRIG(2)	/* ext + edge */
+#define PCI224_DACCON_TRIG_EXTN		PCI224_DACCON_TRIG(3)	/* ext - edge */
+#define PCI224_DACCON_TRIG_Z2CT0	PCI224_DACCON_TRIG(4)	/* Z2 CT0 out */
+#define PCI224_DACCON_TRIG_Z2CT1	PCI224_DACCON_TRIG(5)	/* Z2 CT1 out */
+#define PCI224_DACCON_TRIG_Z2CT2	PCI224_DACCON_TRIG(6)	/* Z2 CT2 out */
 /* (r/w) Polarity (PCI224 only, PCI234 always bipolar!). */
-#define PCI224_DACCON_POLAR_MASK	(1 << 3)
-#define PCI224_DACCON_POLAR_UNI		(0 << 3)	/* range [0,Vref] */
-#define PCI224_DACCON_POLAR_BI		(1 << 3)	/* range [-Vref,Vref] */
+#define PCI224_DACCON_POLAR(x)		(((x) & 0x1) << 3)
+#define PCI224_DACCON_POLAR_MASK	PCI224_DACCON_POLAR(1)
+#define PCI224_DACCON_POLAR_UNI		PCI224_DACCON_POLAR(0)	/* [0,+V] */
+#define PCI224_DACCON_POLAR_BI		PCI224_DACCON_POLAR(1)	/* [-V,+V] */
 /* (r/w) Internal Vref (PCI224 only, when LK1 in position 1-2). */
-#define PCI224_DACCON_VREF_MASK		(3 << 4)
-#define PCI224_DACCON_VREF_1_25		(0 << 4)	/* Vref = 1.25V */
-#define PCI224_DACCON_VREF_2_5		(1 << 4)	/* Vref = 2.5V */
-#define PCI224_DACCON_VREF_5		(2 << 4)	/* Vref = 5V */
-#define PCI224_DACCON_VREF_10		(3 << 4)	/* Vref = 10V */
+#define PCI224_DACCON_VREF(x)		(((x) & 0x3) << 4)
+#define PCI224_DACCON_VREF_MASK		PCI224_DACCON_VREF(3)
+#define PCI224_DACCON_VREF_1_25		PCI224_DACCON_VREF(0)	/* 1.25V */
+#define PCI224_DACCON_VREF_2_5		PCI224_DACCON_VREF(1)	/* 2.5V */
+#define PCI224_DACCON_VREF_5		PCI224_DACCON_VREF(2)	/* 5V */
+#define PCI224_DACCON_VREF_10		PCI224_DACCON_VREF(3)	/* 10V */
 /* (r/w) Wraparound mode enable (to play back stored waveform). */
-#define PCI224_DACCON_FIFOWRAP		(1 << 7)
+#define PCI224_DACCON_FIFOWRAP		BIT(7)
 /* (r/w) FIFO enable.  It MUST be set! */
-#define PCI224_DACCON_FIFOENAB		(1 << 8)
+#define PCI224_DACCON_FIFOENAB		BIT(8)
 /* (r/w) FIFO interrupt trigger level (most values are not very useful). */
-#define PCI224_DACCON_FIFOINTR_MASK	(7 << 9)
-#define PCI224_DACCON_FIFOINTR_EMPTY	(0 << 9)	/* when empty */
-#define PCI224_DACCON_FIFOINTR_NEMPTY	(1 << 9)	/* when not empty */
-#define PCI224_DACCON_FIFOINTR_NHALF	(2 << 9)	/* when not half full */
-#define PCI224_DACCON_FIFOINTR_HALF	(3 << 9)	/* when half full */
-#define PCI224_DACCON_FIFOINTR_NFULL	(4 << 9)	/* when not full */
-#define PCI224_DACCON_FIFOINTR_FULL	(5 << 9)	/* when full */
+#define PCI224_DACCON_FIFOINTR(x)	(((x) & 0x7) << 9)
+#define PCI224_DACCON_FIFOINTR_MASK	PCI224_DACCON_FIFOINTR(7)
+#define PCI224_DACCON_FIFOINTR_EMPTY	PCI224_DACCON_FIFOINTR(0) /* empty */
+#define PCI224_DACCON_FIFOINTR_NEMPTY	PCI224_DACCON_FIFOINTR(1) /* !empty */
+#define PCI224_DACCON_FIFOINTR_NHALF	PCI224_DACCON_FIFOINTR(2) /* !half */
+#define PCI224_DACCON_FIFOINTR_HALF	PCI224_DACCON_FIFOINTR(3) /* half */
+#define PCI224_DACCON_FIFOINTR_NFULL	PCI224_DACCON_FIFOINTR(4) /* !full */
+#define PCI224_DACCON_FIFOINTR_FULL	PCI224_DACCON_FIFOINTR(5) /* full */
 /* (r-o) FIFO fill level. */
-#define PCI224_DACCON_FIFOFL_MASK	(7 << 12)
-#define PCI224_DACCON_FIFOFL_EMPTY	(1 << 12)	/* 0 */
-#define PCI224_DACCON_FIFOFL_ONETOHALF	(0 << 12)	/* [1,2048] */
-#define PCI224_DACCON_FIFOFL_HALFTOFULL	(4 << 12)	/* [2049,4095] */
-#define PCI224_DACCON_FIFOFL_FULL	(6 << 12)	/* 4096 */
+#define PCI224_DACCON_FIFOFL(x)		(((x) & 0x7) << 12)
+#define PCI224_DACCON_FIFOFL_MASK	PCI224_DACCON_FIFOFL(7)
+#define PCI224_DACCON_FIFOFL_EMPTY	PCI224_DACCON_FIFOFL(1)	/* 0 */
+#define PCI224_DACCON_FIFOFL_ONETOHALF	PCI224_DACCON_FIFOFL(0)	/* 1-2048 */
+#define PCI224_DACCON_FIFOFL_HALFTOFULL	PCI224_DACCON_FIFOFL(4)	/* 2049-4095 */
+#define PCI224_DACCON_FIFOFL_FULL	PCI224_DACCON_FIFOFL(6)	/* 4096 */
 /* (r-o) DAC busy flag. */
-#define PCI224_DACCON_BUSY		(1 << 15)
+#define PCI224_DACCON_BUSY		BIT(15)
 /* (w-o) FIFO reset. */
-#define PCI224_DACCON_FIFORESET		(1 << 12)
+#define PCI224_DACCON_FIFORESET		BIT(12)
 /* (w-o) Global reset (not sure what it does). */
-#define PCI224_DACCON_GLOBALRESET	(1 << 13)
+#define PCI224_DACCON_GLOBALRESET	BIT(13)
 
 /*
  * DAC FIFO size.

commit 04226e40592c4b27cc2250105b4505901d467102
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Nov 10 22:41:34 2015 +0800

    staging: comedi: use kmalloc_array instead of kmalloc
    
    Use kmalloc_array instead of kmalloc to allocate memory for an array.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b2f7679a0116..cac011fdd375 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1022,14 +1022,17 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	irq = pci_dev->irq;
 
 	/* Allocate buffer to hold values for AO channel scan. */
-	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
-					board->ao_chans, GFP_KERNEL);
+	devpriv->ao_scan_vals = kmalloc_array(board->ao_chans,
+					      sizeof(devpriv->ao_scan_vals[0]),
+					      GFP_KERNEL);
 	if (!devpriv->ao_scan_vals)
 		return -ENOMEM;
 
 	/* Allocate buffer to hold AO channel scan order. */
-	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
-					 board->ao_chans, GFP_KERNEL);
+	devpriv->ao_scan_order =
+				kmalloc_array(board->ao_chans,
+					      sizeof(devpriv->ao_scan_order[0]),
+					      GFP_KERNEL);
 	if (!devpriv->ao_scan_order)
 		return -ENOMEM;
 

commit c7f53ea17d3a0b2624821ece33a0234069bcd77d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:39 2015 -0700

    staging: comedi: amplc_pci224: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 08a91854837a..b2f7679a0116 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -385,14 +385,14 @@ static void
 pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 		   unsigned int data)
 {
-	const struct pci224_board *thisboard = dev->board_ptr;
+	const struct pci224_board *board = dev->board_ptr;
 	struct pci224_private *devpriv = dev->private;
 	unsigned short mangled;
 
 	/* Enable the channel. */
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
-	devpriv->daccon = COMBINE(devpriv->daccon, thisboard->ao_hwrange[range],
+	devpriv->daccon = COMBINE(devpriv->daccon, board->ao_hwrange[range],
 				  PCI224_DACCON_POLAR_MASK |
 				  PCI224_DACCON_VREF_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
@@ -402,7 +402,7 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 	 * - bipolar: 16-bit 2's complement
 	 * - unipolar: 16-bit unsigned
 	 */
-	mangled = (unsigned short)data << (16 - thisboard->ao_bits);
+	mangled = (unsigned short)data << (16 - board->ao_bits);
 	if ((devpriv->daccon & PCI224_DACCON_POLAR_MASK) ==
 	    PCI224_DACCON_POLAR_BI) {
 		mangled ^= 0x8000;
@@ -620,12 +620,12 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_cmd *cmd)
 {
-	const struct pci224_board *thisboard = dev->board_ptr;
+	const struct pci224_board *board = dev->board_ptr;
 	unsigned int range_check_0;
 	unsigned int chan_mask = 0;
 	int i;
 
-	range_check_0 = thisboard->ao_range_check[CR_RANGE(cmd->chanlist[0])];
+	range_check_0 = board->ao_range_check[CR_RANGE(cmd->chanlist[0])];
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 
@@ -637,7 +637,7 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 		}
 		chan_mask |= 1 << chan;
 
-		if (thisboard->ao_range_check[CR_RANGE(cmd->chanlist[i])] !=
+		if (board->ao_range_check[CR_RANGE(cmd->chanlist[i])] !=
 		    range_check_0) {
 			dev_dbg(dev->class_dev,
 				"%s: entries in chanlist have incompatible ranges\n",
@@ -826,7 +826,7 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct pci224_board *thisboard = dev->board_ptr;
+	const struct pci224_board *board = dev->board_ptr;
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -869,7 +869,7 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	devpriv->daccon =
 	    COMBINE(devpriv->daccon,
-		    thisboard->ao_hwrange[range] | PCI224_DACCON_TRIG_NONE |
+		    board->ao_hwrange[range] | PCI224_DACCON_TRIG_NONE |
 		    PCI224_DACCON_FIFOINTR_NHALF,
 		    PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
 		    PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
@@ -911,7 +911,7 @@ static void
 pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
-	const struct pci224_board *thisboard = dev->board_ptr;
+	const struct pci224_board *board = dev->board_ptr;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
@@ -920,9 +920,9 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int i;
 
 	/* The hardware expects 16-bit numbers. */
-	shift = 16 - thisboard->ao_bits;
+	shift = 16 - board->ao_bits;
 	/* Channels will be all bipolar or all unipolar. */
-	if ((thisboard->ao_hwrange[CR_RANGE(cmd->chanlist[0])] &
+	if ((board->ao_hwrange[CR_RANGE(cmd->chanlist[0])] &
 	     PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
 		/* Unipolar */
 		offset = 0;
@@ -988,21 +988,21 @@ static int
 pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	const struct pci224_board *thisboard = NULL;
+	const struct pci224_board *board = NULL;
 	struct pci224_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq;
 	int ret;
 
 	if (context_model < ARRAY_SIZE(pci224_boards))
-		thisboard = &pci224_boards[context_model];
-	if (!thisboard || !thisboard->name) {
+		board = &pci224_boards[context_model];
+	if (!board || !board->name) {
 		dev_err(dev->class_dev,
 			"amplc_pci224: BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	dev_info(dev->class_dev, "amplc_pci224: attach pci %s - %s\n",
 		 pci_name(pci_dev), dev->board_name);
@@ -1023,13 +1023,13 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 
 	/* Allocate buffer to hold values for AO channel scan. */
 	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
-					thisboard->ao_chans, GFP_KERNEL);
+					board->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_vals)
 		return -ENOMEM;
 
 	/* Allocate buffer to hold AO channel scan order. */
 	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
-					 thisboard->ao_chans, GFP_KERNEL);
+					 board->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_order)
 		return -ENOMEM;
 
@@ -1059,9 +1059,9 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	/* Analog output subdevice. */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan = thisboard->ao_chans;
-	s->maxdata = (1 << thisboard->ao_bits) - 1;
-	s->range_table = thisboard->ao_range;
+	s->n_chan = board->ao_chans;
+	s->maxdata = (1 << board->ao_bits) - 1;
+	s->range_table = board->ao_range;
 	s->insn_write = pci224_ao_insn_write;
 	s->len_chanlist = s->n_chan;
 	dev->write_subdev = s;

commit e0703e09e719819da1cc5e380c70a56f9c248663
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:02 2015 +0000

    staging: comedi: amplc_pci224: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 6c9fa4ab4fcd..08a91854837a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -108,7 +108,6 @@
 
 #include "../comedi_pci.h"
 
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 /*
@@ -666,22 +665,22 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-				     TRIG_EXT | TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src,
-				     TRIG_COUNT | TRIG_EXT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_EXT | TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -706,7 +705,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
@@ -726,13 +725,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 MAX_SCAN_PERIOD);
+		err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,
+						    MAX_SCAN_PERIOD);
 
 		arg = cmd->chanlist_len * CONVERT_PERIOD;
 		if (arg < MIN_SCAN_PERIOD)
 			arg = MIN_SCAN_PERIOD;
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
@@ -752,12 +751,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		break;
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
@@ -773,7 +773,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		break;
 	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	}
 
@@ -786,7 +786,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		arg = cmd->scan_begin_arg;
 		/* Use two timers. */
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit b3c8b18850617b29f564c16f1cfad72c5bd1ad6b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:43 2015 +0000

    staging: comedi: amplc_pci224: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index cf5f646e514e..6c9fa4ab4fcd 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -103,11 +103,10 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "comedi_fc.h"
 #include "comedi_8254.h"

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8ac35f9fc69f..cf5f646e514e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -446,7 +446,6 @@ static void pci224_ao_stop(struct comedi_device *dev,
 	if (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state))
 		return;
 
-
 	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	/* Kill the interrupts. */
 	devpriv->intsce = 0;
@@ -1029,14 +1028,12 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	if (!devpriv->ao_scan_vals)
 		return -ENOMEM;
 
-
 	/* Allocate buffer to hold AO channel scan order. */
 	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
 					 thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_order)
 		return -ENOMEM;
 
-
 	/* Disable interrupt sources. */
 	devpriv->intsce = 0;
 	outb(0, devpriv->iobase1 + PCI224_INT_SCE);

commit 0048b9923daced04ffcb3b9974019b488ce19e8f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:30 2015 -0700

    staging: comedi: amplc_pci224: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 88b8c0101c25..8ac35f9fc69f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -838,7 +838,7 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	/* Cannot handle null/empty chanlist. */
-	if (cmd->chanlist == NULL || cmd->chanlist_len == 0)
+	if (!cmd->chanlist || cmd->chanlist_len == 0)
 		return -EINVAL;
 
 	/* Determine which channels are enabled and their load order.  */

commit 6aa37d79169b10816edeaa2d4a690f35665f3091
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:35 2015 -0700

    staging: comedi: amplc_pci224: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    output data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 924c8298c7a0..88b8c0101c25 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -110,15 +110,12 @@
 #include "../comedidev.h"
 
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 
 /*
  * PCI224/234 i/o space 1 (PCIBAR2) registers.
  */
-#define PCI224_Z2_CT0	0x14	/* 82C54 counter/timer 0 */
-#define PCI224_Z2_CT1	0x15	/* 82C54 counter/timer 1 */
-#define PCI224_Z2_CT2	0x16	/* 82C54 counter/timer 2 */
-#define PCI224_Z2_CTC	0x17	/* 82C54 counter/timer control word */
+#define PCI224_Z2_BASE	0x14	/* 82C54 counter/timer */
 #define PCI224_ZCLK_SCE	0x1A	/* Group Z Clock Configuration Register */
 #define PCI224_ZGAT_SCE	0x1D	/* Group Z Gate Configuration Register */
 #define PCI224_INT_SCE	0x1E	/* ISR Interrupt source mask register */
@@ -379,8 +376,6 @@ struct pci224_private {
 	int intr_cpuid;
 	short intr_running;
 	unsigned short daccon;
-	unsigned int cached_div1;
-	unsigned int cached_div2;
 	unsigned short ao_enab;	/* max 16 channels so 'short' will do */
 	unsigned char intsce;
 };
@@ -668,7 +663,6 @@ static int
 pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		  struct comedi_cmd *cmd)
 {
-	struct pci224_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -793,10 +787,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		/* Use two timers. */
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->cached_div1,
-					  &devpriv->cached_div2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
@@ -817,7 +808,6 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
 	struct pci224_private *devpriv = dev->private;
-	unsigned long timer_base = devpriv->iobase1 + PCI224_Z2_CT0;
 
 	/*
 	 * The output of timer Z2-0 will be used as the scan trigger
@@ -830,14 +820,10 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 	outb(GAT_CONFIG(2, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
 	/* Z2-2 needs 10 MHz clock. */
 	outb(CLK_CONFIG(2, CLK_10MHZ), devpriv->iobase1 + PCI224_ZCLK_SCE);
-	/* Load Z2-2 mode (2) and counter (div1). */
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-	i8254_write(timer_base, 0, 2, devpriv->cached_div1);
 	/* Z2-0 is clocked from Z2-2's output. */
 	outb(CLK_CONFIG(0, CLK_OUTNM1), devpriv->iobase1 + PCI224_ZCLK_SCE);
-	/* Load Z2-0 mode (2) and counter (div2). */
-	i8254_set_mode(timer_base, 0, 0, I8254_MODE2 | I8254_BINARY);
-	i8254_write(timer_base, 0, 0, devpriv->cached_div2);
+
+	comedi_8254_pacer_enable(dev->pacer, 2, 0, false);
 }
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -855,7 +841,6 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->chanlist == NULL || cmd->chanlist_len == 0)
 		return -EINVAL;
 
-
 	/* Determine which channels are enabled and their load order.  */
 	devpriv->ao_enab = 0;
 
@@ -893,8 +878,10 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		comedi_8254_update_divisors(dev->pacer);
 		pci224_ao_start_pacer(dev, s);
+	}
 
 	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	if (cmd->start_src == TRIG_INT) {
@@ -1063,6 +1050,11 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 
+	dev->pacer = comedi_8254_init(devpriv->iobase1 + PCI224_Z2_BASE,
+				      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)
 		return ret;

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a896f0192fbd..924c8298c7a0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1075,7 +1075,6 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	s->maxdata = (1 << thisboard->ao_bits) - 1;
 	s->range_table = thisboard->ao_range;
 	s->insn_write = pci224_ao_insn_write;
-	s->insn_read = comedi_readback_insn_read;
 	s->len_chanlist = s->n_chan;
 	dev->write_subdev = s;
 	s->do_cmd = pci224_ao_cmd;

commit d682141e59676c2c31c2c8a939348369429b1042
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:30 2014 -0700

    staging: comedi: amplc_pci224: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'ao_stop_count' and use the comedi_async
    'scans_done' member to detect the end-of-acquisition.
    
    Use the helper function comedi_nscans_left() to determine the number of scans
    available in the async buffer or left in the command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 342779f1f84a..a896f0192fbd 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -381,7 +381,6 @@ struct pci224_private {
 	unsigned short daccon;
 	unsigned int cached_div1;
 	unsigned int cached_div2;
-	unsigned int ao_stop_count;
 	unsigned short ao_enab;	/* max 16 channels so 'short' will do */
 	unsigned char intsce;
 };
@@ -514,26 +513,18 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 {
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int num_scans;
+	unsigned int num_scans = comedi_nscans_left(s, 0);
 	unsigned int room;
 	unsigned short dacstat;
 	unsigned int i, n;
 
-	/* Determine number of scans available in buffer. */
-	num_scans = comedi_buf_read_n_available(s) / comedi_bytes_per_scan(s);
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* Fixed number of scans. */
-		if (num_scans > devpriv->ao_stop_count)
-			num_scans = devpriv->ao_stop_count;
-	}
-
 	/* Determine how much room is in the FIFO (in samples). */
 	dacstat = inw(dev->iobase + PCI224_DACCON);
 	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
 	case PCI224_DACCON_FIFOFL_EMPTY:
 		room = PCI224_FIFO_ROOM_EMPTY;
 		if (cmd->stop_src == TRIG_COUNT &&
-		    devpriv->ao_stop_count == 0) {
+		    s->async->scans_done >= cmd->stop_arg) {
 			/* FIFO empty at end of counted acquisition. */
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_handle_events(dev, s);
@@ -574,18 +565,16 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 			     dev->iobase + PCI224_DACDATA);
 		}
 	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->ao_stop_count -= num_scans;
-		if (devpriv->ao_stop_count == 0) {
-			/*
-			 * Change FIFO interrupt trigger level to wait
-			 * until FIFO is empty.
-			 */
-			devpriv->daccon = COMBINE(devpriv->daccon,
-						  PCI224_DACCON_FIFOINTR_EMPTY,
-						  PCI224_DACCON_FIFOINTR_MASK);
-			outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
-		}
+	if (cmd->stop_src == TRIG_COUNT &&
+	    s->async->scans_done >= cmd->stop_arg) {
+		/*
+		 * Change FIFO interrupt trigger level to wait
+		 * until FIFO is empty.
+		 */
+		devpriv->daccon = COMBINE(devpriv->daccon,
+					  PCI224_DACCON_FIFOINTR_EMPTY,
+					  PCI224_DACCON_FIFOINTR_MASK);
+		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
 	if ((devpriv->daccon & PCI224_DACCON_TRIG_MASK) ==
 	    PCI224_DACCON_TRIG_NONE) {
@@ -907,14 +896,6 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->scan_begin_src == TRIG_TIMER)
 		pci224_ao_start_pacer(dev, s);
 
-	/*
-	 * Sort out end of acquisition.
-	 */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_stop_count = cmd->stop_arg;
-	else	/* TRIG_EXT | TRIG_NONE */
-		devpriv->ao_stop_count = 0;
-
 	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	if (cmd->start_src == TRIG_INT) {
 		s->async->inttrig = pci224_ao_inttrig_start;

commit bcdbe8848e8dbcd0bee3fcfa86c08f16c9730a15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:35 2014 -0700

    staging: comedi: amplc_pci224: use comedi_buf_read_samples()
    
    Use the new generic method to read the analog output samples from the async
    buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 9fcf6f77c96e..342779f1f84a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -514,14 +514,13 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 {
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int bytes_per_scan = comedi_bytes_per_scan(s);
 	unsigned int num_scans;
 	unsigned int room;
 	unsigned short dacstat;
 	unsigned int i, n;
 
 	/* Determine number of scans available in buffer. */
-	num_scans = comedi_buf_read_n_available(s) / bytes_per_scan;
+	num_scans = comedi_buf_read_n_available(s) / comedi_bytes_per_scan(s);
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_stop_count)
@@ -568,8 +567,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 
 	/* Process scans. */
 	for (n = 0; n < num_scans; n++) {
-		cfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],
-					   bytes_per_scan);
+		comedi_buf_read_samples(s, &devpriv->ao_scan_vals[0],
+					cmd->chanlist_len);
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			outw(devpriv->ao_scan_vals[devpriv->ao_scan_order[i]],
 			     dev->iobase + PCI224_DACDATA);

commit 46a5c3913bd2b0fa102f3d4ce9f7e9bdf9942772
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:41:13 2014 -0700

    staging: comedi: amplc_pci224: use comedi_bytes_per_scan()
    
    This inline function is just a wrapper around comedi_bytes_per_scan().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 7ca6a6179cf2..9fcf6f77c96e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -514,7 +514,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 {
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int bytes_per_scan = cfc_bytes_per_scan(s);
+	unsigned int bytes_per_scan = comedi_bytes_per_scan(s);
 	unsigned int num_scans;
 	unsigned int room;
 	unsigned short dacstat;

commit 781f1f189e9726da6134cc8483b39fb7d56b073d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:17 2014 -0700

    staging: comedi: amplc_pci224: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 3bbbb57f19d6..7ca6a6179cf2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -537,7 +537,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		    devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
 			s->async->events |= COMEDI_CB_EOA;
-			cfc_handle_events(dev, s);
+			comedi_handle_events(dev, s);
 			return;
 		}
 		break;
@@ -618,7 +618,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static int pci224_ao_inttrig_start(struct comedi_device *dev,

commit aaf6598f086396e51caafceee89f7ceecd7defd0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:38 2014 -0700

    staging: comedi: amplc_pci224: remove "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediately generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index fa179d9d8a2e..3bbbb57f19d6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -494,21 +494,16 @@ static void pci224_ao_start(struct comedi_device *dev,
 	unsigned long flags;
 
 	set_bit(AO_CMD_STARTED, &devpriv->state);
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_stop_count == 0) {
-		/* An empty acquisition! */
-		s->async->events |= COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-	} else {
-		/* Enable interrupts. */
-		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
-		if (cmd->stop_src == TRIG_EXT)
-			devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
-		else
-			devpriv->intsce = PCI224_INTR_DAC;
 
-		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-	}
+	/* Enable interrupts. */
+	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	if (cmd->stop_src == TRIG_EXT)
+		devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
+	else
+		devpriv->intsce = PCI224_INTR_DAC;
+
+	outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
+	spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 }
 
 /*
@@ -782,7 +777,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		/* Any count allowed. */
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */

commit 6b417436aaa2f6d64d39f2be8338bb7a096f24bc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:21 2014 +0100

    staging: comedi: amplc_pci224: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b65cd484d61e..fa179d9d8a2e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -393,7 +393,7 @@ static void
 pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 		   unsigned int data)
 {
-	const struct pci224_board *thisboard = comedi_board(dev);
+	const struct pci224_board *thisboard = dev->board_ptr;
 	struct pci224_private *devpriv = dev->private;
 	unsigned short mangled;
 
@@ -645,7 +645,7 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_cmd *cmd)
 {
-	const struct pci224_board *thisboard = comedi_board(dev);
+	const struct pci224_board *thisboard = dev->board_ptr;
 	unsigned int range_check_0;
 	unsigned int chan_mask = 0;
 	int i;
@@ -859,7 +859,7 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct pci224_board *thisboard = comedi_board(dev);
+	const struct pci224_board *thisboard = dev->board_ptr;
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -951,7 +951,7 @@ static void
 pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
-	const struct pci224_board *thisboard = comedi_board(dev);
+	const struct pci224_board *thisboard = dev->board_ptr;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index ba247741adaf..b65cd484d61e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1130,13 +1130,11 @@ static void pci224_detach(struct comedi_device *dev)
 {
 	struct pci224_private *devpriv = dev->private;
 
-	if (dev->irq)
-		free_irq(dev->irq, dev);
+	comedi_pci_detach(dev);
 	if (devpriv) {
 		kfree(devpriv->ao_scan_vals);
 		kfree(devpriv->ao_scan_order);
 	}
-	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver amplc_pci224_driver = {

commit 23b858dcb6bdd6ec7bbe41de179076486ebc7f18
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:23 2014 -0700

    staging: comedi: amplc_pci224: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    For aesthetics, rename the (*insn_write) function and tidy it up.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0b056cfd0136..ba247741adaf 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -374,7 +374,6 @@ struct pci224_private {
 	unsigned long iobase1;
 	unsigned long state;
 	spinlock_t ao_spinlock;	/* spinlock for AO command handling */
-	unsigned int *ao_readback;
 	unsigned short *ao_scan_vals;
 	unsigned char *ao_scan_order;
 	int intr_cpuid;
@@ -398,8 +397,6 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 	struct pci224_private *devpriv = dev->private;
 	unsigned short mangled;
 
-	/* Store unmangled data for readback. */
-	devpriv->ao_readback[chan] = data;
 	/* Enable the channel. */
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
@@ -424,53 +421,23 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 	inw(dev->iobase + PCI224_SOFTTRIG);
 }
 
-/*
- * 'insn_write' function for AO subdevice.
- */
-static int
-pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-		     struct comedi_insn *insn, unsigned int *data)
-{
-	int i;
-	int chan, range;
-
-	/* Unpack channel and range. */
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
-
-	/*
-	 * Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined.
-	 */
-	for (i = 0; i < insn->n; i++)
-		pci224_ao_set_data(dev, chan, range, data[i]);
-
-	return i;
-}
-
-/*
- * 'insn_read' function for AO subdevice.
- *
- * N.B. The value read will not be valid if the DAC channel has
- * never been written successfully since the device was attached
- * or since the channel has been used by an AO streaming write
- * command.
- */
-static int
-pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-		    struct comedi_insn *insn, unsigned int *data)
+static int pci224_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	struct pci224_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = s->readback[chan];
 	int i;
-	int chan;
-
-	chan = CR_CHAN(insn->chanspec);
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
 
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		pci224_ao_set_data(dev, chan, range, val);
+	}
+	s->readback[chan] = val;
 
-	return i;
+	return insn->n;
 }
 
 /*
@@ -1094,13 +1061,6 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	dev->iobase = pci_resource_start(pci_dev, 3);
 	irq = pci_dev->irq;
 
-	/* Allocate readback buffer for AO channels. */
-	devpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *
-				       thisboard->ao_chans, GFP_KERNEL);
-	if (!devpriv->ao_readback)
-		return -ENOMEM;
-
-
 	/* Allocate buffer to hold values for AO channel scan. */
 	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
 					thisboard->ao_chans, GFP_KERNEL);
@@ -1140,7 +1100,7 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	s->maxdata = (1 << thisboard->ao_bits) - 1;
 	s->range_table = thisboard->ao_range;
 	s->insn_write = pci224_ao_insn_write;
-	s->insn_read = pci224_ao_insn_read;
+	s->insn_read = comedi_readback_insn_read;
 	s->len_chanlist = s->n_chan;
 	dev->write_subdev = s;
 	s->do_cmd = pci224_ao_cmd;
@@ -1148,6 +1108,10 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	s->cancel = pci224_ao_cancel;
 	s->munge = pci224_ao_munge;
 
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
 	if (irq) {
 		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
@@ -1169,7 +1133,6 @@ static void pci224_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
-		kfree(devpriv->ao_readback);
 		kfree(devpriv->ao_scan_vals);
 		kfree(devpriv->ao_scan_order);
 	}

commit fe10bdbda634597b4853cd45bc655e1bc8f3d89e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:55 2014 +0100

    staging: comedi: amplc_pci224: no need to comedi_set_hw_dev() here
    
    The comedi core module calls `comedi_set_hw_dev()` to associate the
    hardware `struct device` with the `struct comedi_device` before it calls
    the comedi driver's "auto_attach" hook `pci224_auto_attach()`.  There is
    no need for `pci224_auto_attach()` to call `comedi_set_hw_dev()` itself,
    so remove the call.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a01504ac0443..0b056cfd0136 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1084,8 +1084,6 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 	if (!devpriv)
 		return -ENOMEM;
 
-	comedi_set_hw_dev(dev, &pci_dev->dev);
-
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;

commit fd2bb912e17aee18713504d157bceff7f41fad1e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:54 2014 +0100

    staging: comedi: amplc_pci224: absorb pci224_attach_common()
    
    `pci224_attach_common()` is now only called from `pci225_auto_attach()`,
    so absorb it into that function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index caca0c92b613..a01504ac0443 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1057,18 +1057,33 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 	return IRQ_RETVAL(retval);
 }
 
-/*
- * Common part of attach and auto_attach.
- */
-static int pci224_attach_common(struct comedi_device *dev,
-				struct pci_dev *pci_dev)
+static int
+pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 {
-	const struct pci224_board *thisboard = comedi_board(dev);
-	struct pci224_private *devpriv = dev->private;
+	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
+	const struct pci224_board *thisboard = NULL;
+	struct pci224_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq;
 	int ret;
 
+	if (context_model < ARRAY_SIZE(pci224_boards))
+		thisboard = &pci224_boards[context_model];
+	if (!thisboard || !thisboard->name) {
+		dev_err(dev->class_dev,
+			"amplc_pci224: BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+	dev->board_ptr = thisboard;
+	dev->board_name = thisboard->name;
+
+	dev_info(dev->class_dev, "amplc_pci224: attach pci %s - %s\n",
+		 pci_name(pci_dev), dev->board_name);
+
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
 	comedi_set_hw_dev(dev, &pci_dev->dev);
 
 	ret = comedi_pci_enable(dev);
@@ -1149,33 +1164,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int
-pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
-{
-	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	const struct pci224_board *thisboard = NULL;
-	struct pci224_private *devpriv;
-
-	if (context_model < ARRAY_SIZE(pci224_boards))
-		thisboard = &pci224_boards[context_model];
-	if (!thisboard || !thisboard->name) {
-		dev_err(dev->class_dev,
-			"amplc_pci224: BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
-
-	dev_info(dev->class_dev, "amplc_pci224: attach pci %s - %s\n",
-		 pci_name(pci_dev), dev->board_name);
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
-	return pci224_attach_common(dev, pci_dev);
-}
-
 static void pci224_detach(struct comedi_device *dev)
 {
 	struct pci224_private *devpriv = dev->private;

commit dce75412aa80d0e569d09cc5ef296b52d4c71126
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:53 2014 +0100

    staging: comedi: amplc_pci224: remove PCI_DEVICE_ID_... macros
    
    The macros `PCI_DEVICE_ID_AMPLICON_PCI224` and
    `PCI_DEVICE_ID_AMPLICON_PCI234` are only used in the PCI module device
    table `amplc_pci224_pci_table[]`.  Just expand the macros where they are
    used and remove them.  The macro `PCI_DEVICE_ID_INVALID` is no longer
    used either, so remove it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 675bbe896b18..caca0c92b613 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -112,13 +112,6 @@
 #include "comedi_fc.h"
 #include "8253.h"
 
-/*
- * PCI IDs.
- */
-#define PCI_DEVICE_ID_AMPLICON_PCI224 0x0007
-#define PCI_DEVICE_ID_AMPLICON_PCI234 0x0008
-#define PCI_DEVICE_ID_INVALID 0xffff
-
 /*
  * PCI224/234 i/o space 1 (PCIBAR2) registers.
  */
@@ -1215,8 +1208,8 @@ static int amplc_pci224_pci_probe(struct pci_dev *dev,
 }
 
 static const struct pci_device_id amplc_pci224_pci_table[] = {
-	{ PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224), pci224_model },
-	{ PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234), pci234_model },
+	{ PCI_VDEVICE(AMPLICON, 0x0007), pci224_model },
+	{ PCI_VDEVICE(AMPLICON, 0x0008), pci234_model },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, amplc_pci224_pci_table);

commit 930771fb905be0e1c09a2fe84c17b578d7a0fdd6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Aug 4 12:14:28 2014 +0100

    staging: comedi: amplc_pci224: put board indices in PCI driver_data
    
    The `driver_data` member value from the matched entry of the PCI module
    device table `amplc_pci224_pci_table[]` is passed through to our comedi
    "auto_attach" handler, `pci224_auto_attach()`.  Use that to index
    directly into our static board data array `pci224_boards[]` instead of
    calling `pci224_find_pci_board()` to search for the entry matching the
    PCI device ID.  That function can be removed.  The `devid` and `model`
    members of `struct pci224_board` are no longer needed either and can be
    removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index bcef9e607c2e..675bbe896b18 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -351,8 +351,6 @@ enum pci224_model { pci224_model, pci234_model };
 
 struct pci224_board {
 	const char *name;
-	unsigned short devid;
-	enum pci224_model model;
 	unsigned int ao_chans;
 	unsigned int ao_bits;
 	const struct comedi_lrange *ao_range;
@@ -361,20 +359,16 @@ struct pci224_board {
 };
 
 static const struct pci224_board pci224_boards[] = {
-	{
+	[pci224_model] = {
 		.name		= "pci224",
-		.devid		= PCI_DEVICE_ID_AMPLICON_PCI224,
-		.model		= pci224_model,
 		.ao_chans	= 16,
 		.ao_bits	= 12,
 		.ao_range	= &range_pci224,
 		.ao_hwrange	= &hwrange_pci224[0],
 		.ao_range_check	= &range_check_pci224[0],
 	},
-	{
+	[pci234_model] = {
 		.name		= "pci234",
-		.devid		= PCI_DEVICE_ID_AMPLICON_PCI234,
-		.model		= pci234_model,
 		.ao_chans	= 4,
 		.ao_bits	= 16,
 		.ao_range	= &range_pci234,
@@ -1070,20 +1064,6 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 	return IRQ_RETVAL(retval);
 }
 
-/*
- * This function looks for a board matching the supplied PCI device.
- */
-static const struct pci224_board
-*pci224_find_pci_board(struct pci_dev *pci_dev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(pci224_boards); i++)
-		if (pci_dev->device == pci224_boards[i].devid)
-			return &pci224_boards[i];
-	return NULL;
-}
-
 /*
  * Common part of attach and auto_attach.
  */
@@ -1162,8 +1142,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	s->cancel = pci224_ao_cancel;
 	s->munge = pci224_ao_munge;
 
-	dev->board_name = thisboard->name;
-
 	if (irq) {
 		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
@@ -1179,23 +1157,29 @@ static int pci224_attach_common(struct comedi_device *dev,
 }
 
 static int
-pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
+pci224_auto_attach(struct comedi_device *dev, unsigned long context_model)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
+	const struct pci224_board *thisboard = NULL;
 	struct pci224_private *devpriv;
 
-	dev_info(dev->class_dev, "attach pci %s\n", pci_name(pci_dev));
+	if (context_model < ARRAY_SIZE(pci224_boards))
+		thisboard = &pci224_boards[context_model];
+	if (!thisboard || !thisboard->name) {
+		dev_err(dev->class_dev,
+			"amplc_pci224: BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+	dev->board_ptr = thisboard;
+	dev->board_name = thisboard->name;
+
+	dev_info(dev->class_dev, "amplc_pci224: attach pci %s - %s\n",
+		 pci_name(pci_dev), dev->board_name);
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
 
-	dev->board_ptr = pci224_find_pci_board(pci_dev);
-	if (dev->board_ptr == NULL) {
-		dev_err(dev->class_dev,
-			"BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
 	return pci224_attach_common(dev, pci_dev);
 }
 
@@ -1231,8 +1215,8 @@ static int amplc_pci224_pci_probe(struct pci_dev *dev,
 }
 
 static const struct pci_device_id amplc_pci224_pci_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
+	{ PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224), pci224_model },
+	{ PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234), pci234_model },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, amplc_pci224_pci_table);

commit 176835357e7d468987d6ce3663241fac7677b83e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:51 2014 +0100

    staging: comedi: amplc_pci224: no need to manipulate PCI ref count
    
    This driver no longer supports a "legacy" attach mechanism that searches
    for a suitable PCI device and increments it's reference count, but since
    the common "detach" handler `pci224_detach()` still has a left-over
    `pci_dev_put()`, a matching `pci_dev_get()` is needed in the
    "auto_attach" handler `pci224_auto_attach()`.  There is no longer any
    reason to "get" and "put" the PCI device, so those calls can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0bf5e68410f4..bcef9e607c2e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1196,20 +1196,12 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 			"BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	/*
-	 * Need to 'get' the PCI device to match the 'put' in pci224_detach().
-	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
-	 * support for manual attachment of PCI devices via pci224_attach()
-	 * has been removed.
-	 */
-	pci_dev_get(pci_dev);
 	return pci224_attach_common(dev, pci_dev);
 }
 
 static void pci224_detach(struct comedi_device *dev)
 {
 	struct pci224_private *devpriv = dev->private;
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
@@ -1219,8 +1211,6 @@ static void pci224_detach(struct comedi_device *dev)
 		kfree(devpriv->ao_scan_order);
 	}
 	comedi_pci_disable(dev);
-	if (pcidev)
-		pci_dev_put(pcidev);
 }
 
 static struct comedi_driver amplc_pci224_driver = {

commit 7b2809efb16e4a975666b9b14f3e37edd4b39ad2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:50 2014 +0100

    staging: comedi: amplc_pci224: remove "legacy" attach mechanism
    
    Since the driver no longer supports options in its "legacy" attach
    mechanism to describe the jumper settings (or any options beyond
    restricting a PCI search to a particular bus and/or slot), there is no
    need to retain this mechanism in the driver.  Remove the comedi driver
    "attach" handler `pci224_attach()`, and the now unused
    `pci224_find_pci_dev()`.  Also, remove the "wildcard" entry from the
    board table `pci224_boards[]` as it is no longer needed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index fba0198ad7b3..0bf5e68410f4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -22,9 +22,8 @@
  * Driver: amplc_pci224
  * Description: Amplicon PCI224, PCI234
  * Author: Ian Abbott <abbotti@mev.co.uk>
- * Devices: [Amplicon] PCI224 (amplc_pci224 or pci224),
- *   PCI234 (amplc_pci224 or pci234)
- * Updated: Wed, 30 Jul 2014 18:08:43 +0000
+ * Devices: [Amplicon] PCI224 (amplc_pci224), PCI234
+ * Updated: Thu, 31 Jul 2014 11:08:03 +0000
  * Status: works, but see caveats
  *
  * Supports:
@@ -46,12 +45,10 @@
  *     scan_begin_src or stop_src may use TRIG_EXT.
  *
  * Configuration options:
- *   [0] - PCI bus of device (optional).
- *   [1] - PCI slot of device (optional).
- *           If bus/slot is not specified, the first available PCI device
- *           will be used.
+ *   none
  *
- * Passing a zero for an option is the same as leaving it unspecified.
+ * Manual configuration of PCI cards is not supported; they are configured
+ * automatically.
  *
  * Output range selection - PCI224:
  *
@@ -350,7 +347,7 @@ static const unsigned char range_check_pci234[4] = {
  * Board descriptions.
  */
 
-enum pci224_model { any_model, pci224_model, pci234_model };
+enum pci224_model { pci224_model, pci234_model };
 
 struct pci224_board {
 	const char *name;
@@ -384,11 +381,6 @@ static const struct pci224_board pci224_boards[] = {
 		.ao_hwrange	= &hwrange_pci234[0],
 		.ao_range_check	= &range_check_pci234[0],
 	},
-	{
-		.name		= "amplc_pci224",
-		.devid		= PCI_DEVICE_ID_INVALID,
-		.model		= any_model,	/* wildcard */
-	},
 };
 
 struct pci224_private {
@@ -1092,49 +1084,6 @@ static const struct pci224_board
 	return NULL;
 }
 
-/*
- * This function looks for a PCI device matching the requested board name,
- * bus and slot.
- */
-static struct pci_dev *pci224_find_pci_dev(struct comedi_device *dev,
-					   struct comedi_devconfig *it)
-{
-	const struct pci224_board *thisboard = comedi_board(dev);
-	struct pci_dev *pci_dev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
-
-	for_each_pci_dev(pci_dev) {
-		if (bus || slot) {
-			if (bus != pci_dev->bus->number ||
-			    slot != PCI_SLOT(pci_dev->devfn))
-				continue;
-		}
-		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
-			continue;
-
-		if (thisboard->model == any_model) {
-			/* Match any supported model. */
-			const struct pci224_board *board_ptr;
-
-			board_ptr = pci224_find_pci_board(pci_dev);
-			if (board_ptr == NULL)
-				continue;
-			/* Change board_ptr to matched board. */
-			dev->board_ptr = board_ptr;
-		} else {
-			/* Match specific model name. */
-			if (thisboard->devid != pci_dev->device)
-				continue;
-		}
-		return pci_dev;
-	}
-	dev_err(dev->class_dev,
-		"No supported board found! (req. bus %d, slot %d)\n",
-		bus, slot);
-	return NULL;
-}
-
 /*
  * Common part of attach and auto_attach.
  */
@@ -1229,24 +1178,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	struct pci224_private *devpriv;
-	struct pci_dev *pci_dev;
-
-	dev_info(dev->class_dev, "attach\n");
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
-	pci_dev = pci224_find_pci_dev(dev, it);
-	if (!pci_dev)
-		return -EIO;
-
-	return pci224_attach_common(dev, pci_dev);
-}
-
 static int
 pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 {
@@ -1295,7 +1226,6 @@ static void pci224_detach(struct comedi_device *dev)
 static struct comedi_driver amplc_pci224_driver = {
 	.driver_name	= "amplc_pci224",
 	.module		= THIS_MODULE,
-	.attach		= pci224_attach,
 	.detach		= pci224_detach,
 	.auto_attach	= pci224_auto_attach,
 	.board_name	= &pci224_boards[0].name,

commit c7929e7133daead1b055b4dfceeed5f63ead28ae
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:49 2014 +0100

    staging: comedi: amplc_pci224: remove options to select output ranges
    
    When attaching a PCI224 or PCI234 manually via the `COMEDI_DEVCONFIG`
    ioctl, there are several options the user can supply that describe the
    state of the hardware jumpers (LK1 for PCI224, LK1 thru LK5 for PCI234).
    These options control how the driver sets up the AO range tables for the
    device.  Those options are useless when the board is attached
    automatically via the PCI driver probe function
    `amplc_pci225_pci_probe()`, `comedi_pci_auto_config()`, and the
    comedi driver "auto_attach" handler `pci224_auto_attach()`.
    
    Rip out the range table selection options and use a single, static range
    table per board type, containing all the software- and
    hardware-selectable ranges for that board.  The PCI234 used to have a
    per-channel `range_table_list` rather than an all-channel `range_table`,
    as the jumpers selected different ranges for all channels.  Now that the
    channels are using a unified range table, use an all-channel
    `range_table` instead.
    
    When checking the channel list for an asynchronous command in
    `pci224_ao_check_chanlist()` make sure the ranges specified in the list
    have compatible jumper settings.  We don't know how the jumpers are
    actually set, but we can at least avoid conflicting settings.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b8b86abf52a2..fba0198ad7b3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -24,7 +24,7 @@
  * Author: Ian Abbott <abbotti@mev.co.uk>
  * Devices: [Amplicon] PCI224 (amplc_pci224 or pci224),
  *   PCI234 (amplc_pci224 or pci234)
- * Updated: Wed, 22 Oct 2008 12:25:08 +0100
+ * Updated: Wed, 30 Jul 2014 18:08:43 +0000
  * Status: works, but see caveats
  *
  * Supports:
@@ -45,42 +45,48 @@
  *     There is only one external trigger source so only one of start_src,
  *     scan_begin_src or stop_src may use TRIG_EXT.
  *
- * Configuration options - PCI224:
+ * Configuration options:
  *   [0] - PCI bus of device (optional).
  *   [1] - PCI slot of device (optional).
  *           If bus/slot is not specified, the first available PCI device
  *           will be used.
- *   [2] - Select available ranges according to jumper LK1.  All channels
- *         are set to the same range:
- *         0=Jumper position 1-2 (factory default), 4 software-selectable
- *           internal voltage references, giving 4 bipolar and 4 unipolar
- *           ranges:
- *             [-10V,+10V], [-5V,+5V], [-2.5V,+2.5V], [-1.25V,+1.25V],
- *             [0,+10V], [0,+5V], [0,+2.5V], [0,1.25V].
- *         1=Jumper position 2-3, 1 external voltage reference, giving
- *           1 bipolar and 1 unipolar range:
- *             [-Vext,+Vext], [0,+Vext].
- *
- * Configuration options - PCI234:
- *   [0] - PCI bus of device (optional).
- *   [1] - PCI slot of device (optional).
- *           If bus/slot is not specified, the first available PCI device
- *           will be used.
- *   [2] - Select internal or external voltage reference according to
- *         jumper LK1.  This affects all channels:
- *         0=Jumper position 1-2 (factory default), Vref=5V internal.
- *         1=Jumper position 2-3, Vref=Vext external.
- *   [3] - Select channel 0 range according to jumper LK2:
- *         0=Jumper position 2-3 (factory default), range [-2*Vref,+2*Vref]
- *           (10V bipolar when options[2]=0).
- *         1=Jumper position 1-2, range [-Vref,+Vref]
- *           (5V bipolar when options[2]=0).
- *   [4] - Select channel 1 range according to jumper LK3: cf. options[3].
- *   [5] - Select channel 2 range according to jumper LK4: cf. options[3].
- *   [6] - Select channel 3 range according to jumper LK5: cf. options[3].
  *
  * Passing a zero for an option is the same as leaving it unspecified.
  *
+ * Output range selection - PCI224:
+ *
+ *   Output ranges on PCI224 are partly software-selectable and partly
+ *   hardware-selectable according to jumper LK1.  All channels are set
+ *   to the same range:
+ *
+ *   - LK1 position 1-2 (factory default) corresponds to the following
+ *     comedi ranges:
+ *
+ *       0: [-10V,+10V]; 1: [-5V,+5V]; 2: [-2.5V,+2.5V], 3: [-1.25V,+1.25V],
+ *       4: [0,+10V],    5: [0,+5V],   6: [0,+2.5V],     7: [0,+1.25V]
+ *
+ *   - LK1 position 2-3 corresponds to the following Comedi ranges, using
+ *     an external voltage reference:
+ *
+ *       0: [-Vext,+Vext],
+ *       1: [0,+Vext]
+ *
+ * Output range selection - PCI234:
+ *
+ *   Output ranges on PCI234 are hardware-selectable according to jumper
+ *   LK1 which affects all channels, and jumpers LK2, LK3, LK4 and LK5
+ *   which affect channels 0, 1, 2 and 3 individually.  LK1 chooses between
+ *   an internal 5V reference and an external voltage reference (Vext).
+ *   LK2/3/4/5 choose (per channel) to double the reference or not according
+ *   to the following table:
+ *
+ *     LK1 position   LK2/3/4/5 pos  Comedi range
+ *     -------------  -------------  --------------
+ *     2-3 (factory)  1-2 (factory)  0: [-10V,+10V]
+ *     2-3 (factory)  2-3            1: [-5V,+5V]
+ *     1-2            1-2 (factory)  2: [-2*Vext,+2*Vext]
+ *     1-2            2-3            3: [-Vext,+Vext]
+ *
  * Caveats:
  *
  *   1) All channels on the PCI224 share the same range.  Any change to the
@@ -262,9 +268,17 @@
  * Range tables.
  */
 
-/* The software selectable internal ranges for PCI224 (option[2] == 0). */
-static const struct comedi_lrange range_pci224_internal = {
-	8, {
+/*
+ * The ranges for PCI224.
+ *
+ * These are partly hardware-selectable by jumper LK1 and partly
+ * software-selectable.
+ *
+ * All channels share the same hardware range.
+ */
+static const struct comedi_lrange range_pci224 = {
+	10, {
+		/* jumper LK1 in position 1-2 (factory default) */
 		BIP_RANGE(10),
 		BIP_RANGE(5),
 		BIP_RANGE(2.5),
@@ -272,11 +286,15 @@ static const struct comedi_lrange range_pci224_internal = {
 		UNI_RANGE(10),
 		UNI_RANGE(5),
 		UNI_RANGE(2.5),
-		UNI_RANGE(1.25)
+		UNI_RANGE(1.25),
+		/* jumper LK1 in position 2-3 */
+		RANGE_ext(-1, 1),	/* bipolar [-Vext,+Vext] */
+		RANGE_ext(0, 1),	/* unipolar [0,+Vext] */
 	}
 };
 
-static const unsigned short hwrange_pci224_internal[8] = {
+static const unsigned short hwrange_pci224[10] = {
+	/* jumper LK1 in position 1-2 (factory default) */
 	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_10,
 	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_5,
 	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_2_5,
@@ -285,44 +303,47 @@ static const unsigned short hwrange_pci224_internal[8] = {
 	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_5,
 	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_2_5,
 	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_1_25,
-};
-
-/* The software selectable external ranges for PCI224 (option[2] == 1). */
-static const struct comedi_lrange range_pci224_external = {
-	2, {
-		RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
-		RANGE_ext(0, 1)		/* unipolar [0,+Vref] */
-	}
-};
-
-static const unsigned short hwrange_pci224_external[2] = {
+	/* jumper LK1 in position 2-3 */
 	PCI224_DACCON_POLAR_BI,
 	PCI224_DACCON_POLAR_UNI,
 };
 
-/*
- * The hardware selectable Vref*2 external range for PCI234
- * (option[2] == 1, option[3+n] == 0).
- */
-static const struct comedi_lrange range_pci234_ext2 = {
-	1, {
-		RANGE_ext(-2, 2)
-	}
+/* Used to check all channels set to the same range on PCI224. */
+static const unsigned char range_check_pci224[10] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
 };
 
 /*
- * The hardware selectable Vref external range for PCI234
- * (option[2] == 1, option[3+n] == 1).
+ * The ranges for PCI234.
+ *
+ * These are all hardware-selectable by jumper LK1 affecting all channels,
+ * and jumpers LK2, LK3, LK4 and LK5 affecting channels 0, 1, 2 and 3
+ * individually.
  */
-static const struct comedi_lrange range_pci234_ext = {
-	1, {
-		RANGE_ext(-1, 1)
+static const struct comedi_lrange range_pci234 = {
+	4, {
+		/* LK1: 1-2 (fact def), LK2/3/4/5: 2-3 (fac def) */
+		BIP_RANGE(10),
+		/* LK1: 1-2 (fact def), LK2/3/4/5: 1-2 */
+		BIP_RANGE(5),
+		/* LK1: 2-3, LK2/3/4/5: 2-3 (fac def) */
+		RANGE_ext(-2, 2),	/* bipolar [-2*Vext,+2*Vext] */
+		/* LK1: 2-3, LK2/3/4/5: 1-2 */
+		RANGE_ext(-1, 1),	/* bipolar [-Vext,+Vext] */
 	}
 };
 
-/* This serves for all the PCI234 ranges. */
-static const unsigned short hwrange_pci234[1] = {
-	PCI224_DACCON_POLAR_BI,	/* bipolar - hardware ignores it! */
+/* N.B. PCI234 ignores the polarity bit, but software uses it. */
+static const unsigned short hwrange_pci234[4] = {
+	PCI224_DACCON_POLAR_BI,
+	PCI224_DACCON_POLAR_BI,
+	PCI224_DACCON_POLAR_BI,
+	PCI224_DACCON_POLAR_BI,
+};
+
+/* Used to check all channels use same LK1 setting on PCI234. */
+static const unsigned char range_check_pci234[4] = {
+	0, 0, 1, 1,
 };
 
 /*
@@ -337,6 +358,9 @@ struct pci224_board {
 	enum pci224_model model;
 	unsigned int ao_chans;
 	unsigned int ao_bits;
+	const struct comedi_lrange *ao_range;
+	const unsigned short *ao_hwrange;
+	const unsigned char *ao_range_check;
 };
 
 static const struct pci224_board pci224_boards[] = {
@@ -346,6 +370,9 @@ static const struct pci224_board pci224_boards[] = {
 		.model		= pci224_model,
 		.ao_chans	= 16,
 		.ao_bits	= 12,
+		.ao_range	= &range_pci224,
+		.ao_hwrange	= &hwrange_pci224[0],
+		.ao_range_check	= &range_check_pci224[0],
 	},
 	{
 		.name		= "pci234",
@@ -353,6 +380,9 @@ static const struct pci224_board pci224_boards[] = {
 		.model		= pci234_model,
 		.ao_chans	= 4,
 		.ao_bits	= 16,
+		.ao_range	= &range_pci234,
+		.ao_hwrange	= &hwrange_pci234[0],
+		.ao_range_check	= &range_check_pci234[0],
 	},
 	{
 		.name		= "amplc_pci224",
@@ -362,7 +392,6 @@ static const struct pci224_board pci224_boards[] = {
 };
 
 struct pci224_private {
-	const unsigned short *hwrange;
 	unsigned long iobase1;
 	unsigned long state;
 	spinlock_t ao_spinlock;	/* spinlock for AO command handling */
@@ -395,7 +424,7 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 	/* Enable the channel. */
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
-	devpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],
+	devpriv->daccon = COMBINE(devpriv->daccon, thisboard->ao_hwrange[range],
 				  PCI224_DACCON_POLAR_MASK |
 				  PCI224_DACCON_VREF_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
@@ -670,13 +699,14 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_cmd *cmd)
 {
-	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	const struct pci224_board *thisboard = comedi_board(dev);
+	unsigned int range_check_0;
 	unsigned int chan_mask = 0;
 	int i;
 
+	range_check_0 = thisboard->ao_range_check[CR_RANGE(cmd->chanlist[0])];
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
-		unsigned int range = CR_RANGE(cmd->chanlist[i]);
 
 		if (chan_mask & (1 << chan)) {
 			dev_dbg(dev->class_dev,
@@ -686,9 +716,10 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 		}
 		chan_mask |= 1 << chan;
 
-		if (range != range0) {
+		if (thisboard->ao_range_check[CR_RANGE(cmd->chanlist[i])] !=
+		    range_check_0) {
 			dev_dbg(dev->class_dev,
-				"%s: entries in chanlist must all have the same range index\n",
+				"%s: entries in chanlist have incompatible ranges\n",
 				__func__);
 			return -EINVAL;
 		}
@@ -882,6 +913,7 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -925,7 +957,7 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	devpriv->daccon =
 	    COMBINE(devpriv->daccon,
-		    devpriv->hwrange[range] | PCI224_DACCON_TRIG_NONE |
+		    thisboard->ao_hwrange[range] | PCI224_DACCON_TRIG_NONE |
 		    PCI224_DACCON_FIFOINTR_NHALF,
 		    PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
 		    PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
@@ -974,7 +1006,6 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	const struct pci224_board *thisboard = comedi_board(dev);
-	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
@@ -985,7 +1016,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* The hardware expects 16-bit numbers. */
 	shift = 16 - thisboard->ao_bits;
 	/* Channels will be all bipolar or all unipolar. */
-	if ((devpriv->hwrange[CR_RANGE(cmd->chanlist[0])] &
+	if ((thisboard->ao_hwrange[CR_RANGE(cmd->chanlist[0])] &
 	     PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
 		/* Unipolar */
 		offset = 0;
@@ -1108,13 +1139,12 @@ static struct pci_dev *pci224_find_pci_dev(struct comedi_device *dev,
  * Common part of attach and auto_attach.
  */
 static int pci224_attach_common(struct comedi_device *dev,
-				struct pci_dev *pci_dev, int *options)
+				struct pci_dev *pci_dev)
 {
 	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	unsigned int irq;
-	unsigned n;
 	int ret;
 
 	comedi_set_hw_dev(dev, &pci_dev->dev);
@@ -1173,6 +1203,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
 	s->n_chan = thisboard->ao_chans;
 	s->maxdata = (1 << thisboard->ao_bits) - 1;
+	s->range_table = thisboard->ao_range;
 	s->insn_write = pci224_ao_insn_write;
 	s->insn_read = pci224_ao_insn_read;
 	s->len_chanlist = s->n_chan;
@@ -1182,61 +1213,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	s->cancel = pci224_ao_cancel;
 	s->munge = pci224_ao_munge;
 
-	/* Sort out channel range options. */
-	if (thisboard->model == pci234_model) {
-		/* PCI234 range options. */
-		const struct comedi_lrange **range_table_list;
-
-		range_table_list =
-		    kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
-			    GFP_KERNEL);
-		if (!range_table_list)
-			return -ENOMEM;
-		s->range_table_list = range_table_list;
-
-		if (options) {
-			for (n = 2; n < 3 + s->n_chan; n++) {
-				if (options[n] < 0 || options[n] > 1) {
-					dev_warn(dev->class_dev,
-						 "warning! bad options[%u]=%d\n",
-						 n, options[n]);
-				}
-			}
-		}
-		for (n = 0; n < s->n_chan; n++) {
-			if (n < COMEDI_NDEVCONFOPTS - 3 && options &&
-			    options[3 + n] == 1) {
-				if (options[2] == 1)
-					range_table_list[n] = &range_pci234_ext;
-				else
-					range_table_list[n] = &range_bipolar5;
-
-			} else {
-				if (options && options[2] == 1) {
-					range_table_list[n] =
-					    &range_pci234_ext2;
-				} else {
-					range_table_list[n] = &range_bipolar10;
-				}
-			}
-		}
-		devpriv->hwrange = hwrange_pci234;
-	} else {
-		/* PCI224 range options. */
-		if (options && options[2] == 1) {
-			s->range_table = &range_pci224_external;
-			devpriv->hwrange = hwrange_pci224_external;
-		} else {
-			if (options && options[2] != 0) {
-				dev_warn(dev->class_dev,
-					 "warning! bad options[2]=%d\n",
-					 options[2]);
-			}
-			s->range_table = &range_pci224_internal;
-			devpriv->hwrange = hwrange_pci224_internal;
-		}
-	}
-
 	dev->board_name = thisboard->name;
 
 	if (irq) {
@@ -1268,7 +1244,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!pci_dev)
 		return -EIO;
 
-	return pci224_attach_common(dev, pci_dev, it->options);
+	return pci224_attach_common(dev, pci_dev);
 }
 
 static int
@@ -1296,7 +1272,7 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 	 * has been removed.
 	 */
 	pci_dev_get(pci_dev);
-	return pci224_attach_common(dev, pci_dev, NULL);
+	return pci224_attach_common(dev, pci_dev);
 }
 
 static void pci224_detach(struct comedi_device *dev)
@@ -1306,13 +1282,6 @@ static void pci224_detach(struct comedi_device *dev)
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->subdevices) {
-		struct comedi_subdevice *s;
-
-		s = &dev->subdevices[0];
-		/* AO subdevice */
-		kfree(s->range_table_list);
-	}
 	if (devpriv) {
 		kfree(devpriv->ao_readback);
 		kfree(devpriv->ao_scan_vals);

commit 74f6084336fa651e6e063f50c2cbaa62c3e831be
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:48 2014 +0100

    staging: comedi: amplc_pci224: no need for '&function'
    
    Remove the "address-of" operator when the operand is a function.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 68fc407b1559..b8b86abf52a2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1173,15 +1173,14 @@ static int pci224_attach_common(struct comedi_device *dev,
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
 	s->n_chan = thisboard->ao_chans;
 	s->maxdata = (1 << thisboard->ao_bits) - 1;
-	s->insn_write = &pci224_ao_insn_write;
-	s->insn_read = &pci224_ao_insn_read;
+	s->insn_write = pci224_ao_insn_write;
+	s->insn_read = pci224_ao_insn_read;
 	s->len_chanlist = s->n_chan;
-
 	dev->write_subdev = s;
-	s->do_cmd = &pci224_ao_cmd;
-	s->do_cmdtest = &pci224_ao_cmdtest;
-	s->cancel = &pci224_ao_cancel;
-	s->munge = &pci224_ao_munge;
+	s->do_cmd = pci224_ao_cmd;
+	s->do_cmdtest = pci224_ao_cmdtest;
+	s->cancel = pci224_ao_cancel;
+	s->munge = pci224_ao_munge;
 
 	/* Sort out channel range options. */
 	if (thisboard->model == pci234_model) {

commit 56eb5cbc5894b206ef9d4b5d3bcc2e1b232e8c22
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:47 2014 +0100

    staging: comedi: amplc_pci224: reduce leading whitespace in a few places
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a7f34547e781..68fc407b1559 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -500,11 +500,10 @@ static void pci224_ao_stop(struct comedi_device *dev,
 	spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	/* Reconfigure DAC for insn_write usage. */
 	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
-	devpriv->daccon = COMBINE(devpriv->daccon,
-				  PCI224_DACCON_TRIG_SW |
-				  PCI224_DACCON_FIFOINTR_EMPTY,
-				  PCI224_DACCON_TRIG_MASK |
-				  PCI224_DACCON_FIFOINTR_MASK);
+	devpriv->daccon =
+	     COMBINE(devpriv->daccon,
+		     PCI224_DACCON_TRIG_SW | PCI224_DACCON_FIFOINTR_EMPTY,
+		     PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 }
@@ -644,8 +643,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 			else
 				trig = PCI224_DACCON_TRIG_EXTP;
 		}
-		devpriv->daccon = COMBINE(devpriv->daccon, trig,
-					  PCI224_DACCON_TRIG_MASK);
+		devpriv->daccon =
+		    COMBINE(devpriv->daccon, trig, PCI224_DACCON_TRIG_MASK);
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
 
@@ -717,11 +716,11 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_EXT | TRIG_TIMER);
+				     TRIG_EXT | TRIG_TIMER);
 	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src,
-					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
+				     TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
@@ -760,8 +759,8 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
 		if (cmd->start_arg & ~CR_FLAGS_MASK) {
-			cmd->start_arg = COMBINE(cmd->start_arg, 0,
-						 ~CR_FLAGS_MASK);
+			cmd->start_arg =
+			    COMBINE(cmd->start_arg, 0, ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
@@ -786,16 +785,16 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
 		if (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {
-			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-						      ~CR_FLAGS_MASK);
+			cmd->scan_begin_arg =
+			    COMBINE(cmd->scan_begin_arg, 0, ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
 		if (cmd->scan_begin_arg & CR_FLAGS_MASK &
 		    ~(CR_EDGE | CR_INVERT)) {
-			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-						      CR_FLAGS_MASK &
-						      ~(CR_EDGE | CR_INVERT));
+			cmd->scan_begin_arg =
+			    COMBINE(cmd->scan_begin_arg, 0,
+				    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
 			err |= -EINVAL;
 		}
 		break;
@@ -811,14 +810,14 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
 		if (cmd->stop_arg & ~CR_FLAGS_MASK) {
-			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-						~CR_FLAGS_MASK);
+			cmd->stop_arg =
+			    COMBINE(cmd->stop_arg, 0, ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if (cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) {
-			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-						CR_FLAGS_MASK & ~CR_EDGE);
+			cmd->stop_arg =
+			    COMBINE(cmd->stop_arg, 0, CR_FLAGS_MASK & ~CR_EDGE);
 		}
 		break;
 	case TRIG_NONE:
@@ -924,14 +923,12 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 *
 	 * N.B. DAC FIFO interrupts are currently disabled.
 	 */
-	devpriv->daccon = COMBINE(devpriv->daccon,
-				  devpriv->hwrange[range] |
-				  PCI224_DACCON_TRIG_NONE |
-				  PCI224_DACCON_FIFOINTR_NHALF,
-				  PCI224_DACCON_POLAR_MASK |
-				  PCI224_DACCON_VREF_MASK |
-				  PCI224_DACCON_TRIG_MASK |
-				  PCI224_DACCON_FIFOINTR_MASK);
+	devpriv->daccon =
+	    COMBINE(devpriv->daccon,
+		    devpriv->hwrange[range] | PCI224_DACCON_TRIG_NONE |
+		    PCI224_DACCON_FIFOINTR_NHALF,
+		    PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
+		    PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 

commit e038756110401b6bca6b1091cbcb668fe2741756
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:46 2014 +0100

    staging: comedi: amplc_pci224: remove some unnecessary parentheses
    
    Remove some pairs of parentheses that don't really improve readability.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0ac05fb5ac5d..a7f34547e781 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -396,8 +396,8 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
 	devpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],
-				  (PCI224_DACCON_POLAR_MASK |
-				   PCI224_DACCON_VREF_MASK));
+				  PCI224_DACCON_POLAR_MASK |
+				  PCI224_DACCON_VREF_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 	/*
@@ -685,7 +685,7 @@ static int pci224_ao_check_chanlist(struct comedi_device *dev,
 				__func__);
 			return -EINVAL;
 		}
-		chan_mask |= (1 << chan);
+		chan_mask |= 1 << chan;
 
 		if (range != range0) {
 			dev_dbg(dev->class_dev,
@@ -925,13 +925,13 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * N.B. DAC FIFO interrupts are currently disabled.
 	 */
 	devpriv->daccon = COMBINE(devpriv->daccon,
-				  (devpriv->
-				   hwrange[range] | PCI224_DACCON_TRIG_NONE |
-				   PCI224_DACCON_FIFOINTR_NHALF),
-				  (PCI224_DACCON_POLAR_MASK |
-				   PCI224_DACCON_VREF_MASK |
-				   PCI224_DACCON_TRIG_MASK |
-				   PCI224_DACCON_FIFOINTR_MASK));
+				  devpriv->hwrange[range] |
+				  PCI224_DACCON_TRIG_NONE |
+				  PCI224_DACCON_FIFOINTR_NHALF,
+				  PCI224_DACCON_POLAR_MASK |
+				  PCI224_DACCON_VREF_MASK |
+				  PCI224_DACCON_TRIG_MASK |
+				  PCI224_DACCON_FIFOINTR_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 
@@ -1161,9 +1161,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 	outw(PCI224_DACCON_GLOBALRESET, dev->iobase + PCI224_DACCON);
 	outw(0, dev->iobase + PCI224_DACCEN);
 	outw(0, dev->iobase + PCI224_FIFOSIZ);
-	devpriv->daccon = (PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |
-			   PCI224_DACCON_FIFOENAB |
-			   PCI224_DACCON_FIFOINTR_EMPTY);
+	devpriv->daccon = PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |
+			  PCI224_DACCON_FIFOENAB | PCI224_DACCON_FIFOINTR_EMPTY;
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 

commit fe3cda6d39bba3368ed9823f78bbd145e3a1416e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:45 2014 +0100

    staging: comedi: amplc_pci224: omit '!= 0' from logical expressions
    
    Since anything non-zero is logically "true", don't bother doing
    "not-equal" comparisons with zero, except when testing for an explicit
    number 0 (not as a result of bit tests for example).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index f7862375bbbc..0ac05fb5ac5d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -759,13 +759,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
-		if ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {
+		if (cmd->start_arg & ~CR_FLAGS_MASK) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
 						 ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
-		if ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+		if (cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
 						 CR_FLAGS_MASK & ~CR_EDGE);
 			err |= -EINVAL;
@@ -785,14 +785,14 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
-		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+		if (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
-		if ((cmd->scan_begin_arg & CR_FLAGS_MASK &
-		     ~(CR_EDGE | CR_INVERT)) != 0) {
+		if (cmd->scan_begin_arg & CR_FLAGS_MASK &
+		    ~(CR_EDGE | CR_INVERT)) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      CR_FLAGS_MASK &
 						      ~(CR_EDGE | CR_INVERT));
@@ -810,13 +810,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
-		if ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {
+		if (cmd->stop_arg & ~CR_FLAGS_MASK) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
 						~CR_FLAGS_MASK);
 			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
-		if ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+		if (cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
 						CR_FLAGS_MASK & ~CR_EDGE);
 		}
@@ -1026,7 +1026,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 		devpriv->intr_running = 1;
 		devpriv->intr_cpuid = THISCPU;
 		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-		if (valid_intstat != 0) {
+		if (valid_intstat) {
 			cmd = &s->async->cmd;
 			if (valid_intstat & PCI224_INTR_EXT) {
 				devpriv->intsce &= ~PCI224_INTR_EXT;

commit bf6002d898630cc3042f5f727f2ebf0ec4ebabb0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:44 2014 +0100

    staging: comedi: amplc_pci224: set a more descriptive MODULE_DESCRIPTION()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8ce0f4fa09c3..f7862375bbbc 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1362,5 +1362,5 @@ static struct pci_driver amplc_pci224_pci_driver = {
 module_comedi_pci_driver(amplc_pci224_driver, amplc_pci224_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for Amplicon PCI224 and PCI234 AO boards");
 MODULE_LICENSE("GPL");

commit 5b18dc660a4e8b3a60d3f2696625b87af40b4d81
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:43 2014 +0100

    staging: comedi: amplc_pci224: add whitespace to pci224_boards[]
    
    Add a bit of whitespace to the initializer of `pci224_boards[]` for
    aesthetic reasons.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index dfeb70cc9775..8ce0f4fa09c3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -341,24 +341,24 @@ struct pci224_board {
 
 static const struct pci224_board pci224_boards[] = {
 	{
-	 .name = "pci224",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCI224,
-	 .model = pci224_model,
-	 .ao_chans = 16,
-	 .ao_bits = 12,
-	 },
+		.name		= "pci224",
+		.devid		= PCI_DEVICE_ID_AMPLICON_PCI224,
+		.model		= pci224_model,
+		.ao_chans	= 16,
+		.ao_bits	= 12,
+	},
 	{
-	 .name = "pci234",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCI234,
-	 .model = pci234_model,
-	 .ao_chans = 4,
-	 .ao_bits = 16,
-	 },
+		.name		= "pci234",
+		.devid		= PCI_DEVICE_ID_AMPLICON_PCI234,
+		.model		= pci234_model,
+		.ao_chans	= 4,
+		.ao_bits	= 16,
+	},
 	{
-	 .name = "amplc_pci224",
-	 .devid = PCI_DEVICE_ID_INVALID,
-	 .model = any_model,	/* wildcard */
-	 },
+		.name		= "amplc_pci224",
+		.devid		= PCI_DEVICE_ID_INVALID,
+		.model		= any_model,	/* wildcard */
+	},
 };
 
 struct pci224_private {

commit 71e70e9f6daea58bb5ef03d17ba26c630fcac1d2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:42 2014 +0100

    staging: comedi: amplc_pci224: fix spinlock_t definition without comment
    
    Fix checkpatch issue: "CHECK: spinlock_t definition without comment".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8e5d94abacd4..dfeb70cc9775 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -365,7 +365,7 @@ struct pci224_private {
 	const unsigned short *hwrange;
 	unsigned long iobase1;
 	unsigned long state;
-	spinlock_t ao_spinlock;
+	spinlock_t ao_spinlock;	/* spinlock for AO command handling */
 	unsigned int *ao_readback;
 	unsigned short *ao_scan_vals;
 	unsigned char *ao_scan_order;

commit ab2064a5cbd732f5228c718cb7f1afd72ea180da
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:41 2014 +0100

    staging: comedi: amplc_pci224: multiple assignments should be avoided
    
    Fix checkpatch issue: "CHECK: multiple assignments should be avoided".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index e34bc5e76aff..8e5d94abacd4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1192,11 +1192,12 @@ static int pci224_attach_common(struct comedi_device *dev,
 		/* PCI234 range options. */
 		const struct comedi_lrange **range_table_list;
 
-		s->range_table_list = range_table_list =
+		range_table_list =
 		    kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
 			    GFP_KERNEL);
-		if (!s->range_table_list)
+		if (!range_table_list)
 			return -ENOMEM;
+		s->range_table_list = range_table_list;
 
 		if (options) {
 			for (n = 2; n < 3 + s->n_chan; n++) {

commit d0f2c953b692a81acafcb71f35b7cff578099de0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:40 2014 +0100

    staging: comedi: amplc_pci224: blank lines aren't necessary before a close brace '}'
    
    Fix checkpatch issues: "CHECK: Blank lines aren't necessary before a
    close brace '}'".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 6a570ef1f5ab..e34bc5e76aff 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -557,7 +557,6 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_stop_count)
 			num_scans = devpriv->ao_stop_count;
-
 	}
 
 	/* Determine how much room is in the FIFO (in samples). */
@@ -644,7 +643,6 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 				trig = PCI224_DACCON_TRIG_EXTN;
 			else
 				trig = PCI224_DACCON_TRIG_EXTP;
-
 		}
 		devpriv->daccon = COMBINE(devpriv->daccon, trig,
 					  PCI224_DACCON_TRIG_MASK);
@@ -908,7 +906,6 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		for (j = 0; j < cmd->chanlist_len; j++) {
 			if (CR_CHAN(cmd->chanlist[j]) < ch)
 				rank++;
-
 		}
 		devpriv->ao_scan_order[rank] = i;
 	}
@@ -1002,7 +999,6 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* Munge the data. */
 	for (i = 0; i < length; i++)
 		array[i] = (array[i] << shift) - offset;
-
 }
 
 /*
@@ -1038,11 +1034,9 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 					pci224_ao_start(dev, s);
 				else if (cmd->stop_src == TRIG_EXT)
 					pci224_ao_stop(dev, s);
-
 			}
 			if (valid_intstat & PCI224_INTR_DAC)
 				pci224_ao_handle_fifo(dev, s);
-
 		}
 		/* Reenable interrupt sources. */
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);

commit 7c40bd48dbae93e7bd8369d8326f8850eff98f73
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:39 2014 +0100

    staging: comedi: amplc_pci224: fix checkpatch line over 80 characters
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 72506bf6aa1e..6a570ef1f5ab 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -565,7 +565,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
 	case PCI224_DACCON_FIFOFL_EMPTY:
 		room = PCI224_FIFO_ROOM_EMPTY;
-		if (cmd->stop_src == TRIG_COUNT && devpriv->ao_stop_count == 0) {
+		if (cmd->stop_src == TRIG_COUNT &&
+		    devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
 			s->async->events |= COMEDI_CB_EOA;
 			cfc_handle_events(dev, s);

commit 53bd9a204816a3513c5fa3c6170fe33100bb3f4d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 31 14:47:38 2014 +0100

    staging: comedi: amplc_pci224: reformat some comments
    
    Reformat comments to fit in with the preferred coding style, including
    the copyright and comedi driver description comments at the start of the
    file.  Also, remove a boiler-plate comment for the comedi device private
    data structure.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 45aba1f950fc..72506bf6aa1e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1,102 +1,103 @@
 /*
-    comedi/drivers/amplc_pci224.c
-    Driver for Amplicon PCI224 and PCI234 AO boards.
-
-    Copyright (C) 2005 MEV Ltd. <http://www.mev.co.uk/>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+ * comedi/drivers/amplc_pci224.c
+ * Driver for Amplicon PCI224 and PCI234 AO boards.
+ *
+ * Copyright (C) 2005 MEV Ltd. <http://www.mev.co.uk/>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
 /*
-Driver: amplc_pci224
-Description: Amplicon PCI224, PCI234
-Author: Ian Abbott <abbotti@mev.co.uk>
-Devices: [Amplicon] PCI224 (amplc_pci224 or pci224),
-  PCI234 (amplc_pci224 or pci234)
-Updated: Wed, 22 Oct 2008 12:25:08 +0100
-Status: works, but see caveats
-
-Supports:
-
-  - ao_insn read/write
-  - ao_do_cmd mode with the following sources:
-
-    - start_src         TRIG_INT        TRIG_EXT
-    - scan_begin_src    TRIG_TIMER      TRIG_EXT
-    - convert_src       TRIG_NOW
-    - scan_end_src      TRIG_COUNT
-    - stop_src          TRIG_COUNT      TRIG_EXT        TRIG_NONE
-
-    The channel list must contain at least one channel with no repeated
-    channels.  The scan end count must equal the number of channels in
-    the channel list.
-
-    There is only one external trigger source so only one of start_src,
-    scan_begin_src or stop_src may use TRIG_EXT.
-
-Configuration options - PCI224:
-  [0] - PCI bus of device (optional).
-  [1] - PCI slot of device (optional).
-          If bus/slot is not specified, the first available PCI device
-          will be used.
-  [2] - Select available ranges according to jumper LK1.  All channels
-        are set to the same range:
-        0=Jumper position 1-2 (factory default), 4 software-selectable
-          internal voltage references, giving 4 bipolar and 4 unipolar
-          ranges:
-            [-10V,+10V], [-5V,+5V], [-2.5V,+2.5V], [-1.25V,+1.25V],
-            [0,+10V], [0,+5V], [0,+2.5V], [0,1.25V].
-        1=Jumper position 2-3, 1 external voltage reference, giving
-          1 bipolar and 1 unipolar range:
-            [-Vext,+Vext], [0,+Vext].
-
-Configuration options - PCI234:
-  [0] - PCI bus of device (optional).
-  [1] - PCI slot of device (optional).
-          If bus/slot is not specified, the first available PCI device
-          will be used.
-  [2] - Select internal or external voltage reference according to
-        jumper LK1.  This affects all channels:
-        0=Jumper position 1-2 (factory default), Vref=5V internal.
-        1=Jumper position 2-3, Vref=Vext external.
-  [3] - Select channel 0 range according to jumper LK2:
-        0=Jumper position 2-3 (factory default), range [-2*Vref,+2*Vref]
-          (10V bipolar when options[2]=0).
-        1=Jumper position 1-2, range [-Vref,+Vref]
-          (5V bipolar when options[2]=0).
-  [4] - Select channel 1 range according to jumper LK3: cf. options[3].
-  [5] - Select channel 2 range according to jumper LK4: cf. options[3].
-  [6] - Select channel 3 range according to jumper LK5: cf. options[3].
-
-Passing a zero for an option is the same as leaving it unspecified.
-
-Caveats:
-
-  1) All channels on the PCI224 share the same range.  Any change to the
-     range as a result of insn_write or a streaming command will affect
-     the output voltages of all channels, including those not specified
-     by the instruction or command.
-
-  2) For the analog output command,  the first scan may be triggered
-     falsely at the start of acquisition.  This occurs when the DAC scan
-     trigger source is switched from 'none' to 'timer' (scan_begin_src =
-     TRIG_TIMER) or 'external' (scan_begin_src == TRIG_EXT) at the start
-     of acquisition and the trigger source is at logic level 1 at the
-     time of the switch.  This is very likely for TRIG_TIMER.  For
-     TRIG_EXT, it depends on the state of the external line and whether
-     the CR_INVERT flag has been set.  The remaining scans are triggered
-     correctly.
-*/
+ * Driver: amplc_pci224
+ * Description: Amplicon PCI224, PCI234
+ * Author: Ian Abbott <abbotti@mev.co.uk>
+ * Devices: [Amplicon] PCI224 (amplc_pci224 or pci224),
+ *   PCI234 (amplc_pci224 or pci234)
+ * Updated: Wed, 22 Oct 2008 12:25:08 +0100
+ * Status: works, but see caveats
+ *
+ * Supports:
+ *
+ *   - ao_insn read/write
+ *   - ao_do_cmd mode with the following sources:
+ *
+ *     - start_src         TRIG_INT        TRIG_EXT
+ *     - scan_begin_src    TRIG_TIMER      TRIG_EXT
+ *     - convert_src       TRIG_NOW
+ *     - scan_end_src      TRIG_COUNT
+ *     - stop_src          TRIG_COUNT      TRIG_EXT        TRIG_NONE
+ *
+ *     The channel list must contain at least one channel with no repeated
+ *     channels.  The scan end count must equal the number of channels in
+ *     the channel list.
+ *
+ *     There is only one external trigger source so only one of start_src,
+ *     scan_begin_src or stop_src may use TRIG_EXT.
+ *
+ * Configuration options - PCI224:
+ *   [0] - PCI bus of device (optional).
+ *   [1] - PCI slot of device (optional).
+ *           If bus/slot is not specified, the first available PCI device
+ *           will be used.
+ *   [2] - Select available ranges according to jumper LK1.  All channels
+ *         are set to the same range:
+ *         0=Jumper position 1-2 (factory default), 4 software-selectable
+ *           internal voltage references, giving 4 bipolar and 4 unipolar
+ *           ranges:
+ *             [-10V,+10V], [-5V,+5V], [-2.5V,+2.5V], [-1.25V,+1.25V],
+ *             [0,+10V], [0,+5V], [0,+2.5V], [0,1.25V].
+ *         1=Jumper position 2-3, 1 external voltage reference, giving
+ *           1 bipolar and 1 unipolar range:
+ *             [-Vext,+Vext], [0,+Vext].
+ *
+ * Configuration options - PCI234:
+ *   [0] - PCI bus of device (optional).
+ *   [1] - PCI slot of device (optional).
+ *           If bus/slot is not specified, the first available PCI device
+ *           will be used.
+ *   [2] - Select internal or external voltage reference according to
+ *         jumper LK1.  This affects all channels:
+ *         0=Jumper position 1-2 (factory default), Vref=5V internal.
+ *         1=Jumper position 2-3, Vref=Vext external.
+ *   [3] - Select channel 0 range according to jumper LK2:
+ *         0=Jumper position 2-3 (factory default), range [-2*Vref,+2*Vref]
+ *           (10V bipolar when options[2]=0).
+ *         1=Jumper position 1-2, range [-Vref,+Vref]
+ *           (5V bipolar when options[2]=0).
+ *   [4] - Select channel 1 range according to jumper LK3: cf. options[3].
+ *   [5] - Select channel 2 range according to jumper LK4: cf. options[3].
+ *   [6] - Select channel 3 range according to jumper LK5: cf. options[3].
+ *
+ * Passing a zero for an option is the same as leaving it unspecified.
+ *
+ * Caveats:
+ *
+ *   1) All channels on the PCI224 share the same range.  Any change to the
+ *      range as a result of insn_write or a streaming command will affect
+ *      the output voltages of all channels, including those not specified
+ *      by the instruction or command.
+ *
+ *   2) For the analog output command,  the first scan may be triggered
+ *      falsely at the start of acquisition.  This occurs when the DAC scan
+ *      trigger source is switched from 'none' to 'timer' (scan_begin_src =
+ *      TRIG_TIMER) or 'external' (scan_begin_src == TRIG_EXT) at the start
+ *      of acquisition and the trigger source is at logic level 1 at the
+ *      time of the switch.  This is very likely for TRIG_TIMER.  For
+ *      TRIG_EXT, it depends on the state of the external line and whether
+ *      the CR_INVERT flag has been set.  The remaining scans are triggered
+ *      correctly.
+ */
 
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -299,16 +300,20 @@ static const unsigned short hwrange_pci224_external[2] = {
 	PCI224_DACCON_POLAR_UNI,
 };
 
-/* The hardware selectable Vref*2 external range for PCI234
- * (option[2] == 1, option[3+n] == 0). */
+/*
+ * The hardware selectable Vref*2 external range for PCI234
+ * (option[2] == 1, option[3+n] == 0).
+ */
 static const struct comedi_lrange range_pci234_ext2 = {
 	1, {
 		RANGE_ext(-2, 2)
 	}
 };
 
-/* The hardware selectable Vref external range for PCI234
- * (option[2] == 1, option[3+n] == 1). */
+/*
+ * The hardware selectable Vref external range for PCI234
+ * (option[2] == 1, option[3+n] == 1).
+ */
 static const struct comedi_lrange range_pci234_ext = {
 	1, {
 		RANGE_ext(-1, 1)
@@ -356,9 +361,6 @@ static const struct pci224_board pci224_boards[] = {
 	 },
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pci224_private {
 	const unsigned short *hwrange;
 	unsigned long iobase1;
@@ -428,8 +430,10 @@ pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
 
-	/* Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined. */
+	/*
+	 * Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined.
+	 */
 	for (i = 0; i < insn->n; i++)
 		pci224_ao_set_data(dev, chan, range, data[i]);
 

commit 3d03cfcaf6cde186f439ca1a318423007570760a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:23 2014 -0700

    staging: comedi: drivers: remove unnecessary DRIVER_NAME defines
    
    These defines are usually only used to initialize the driver_name
    member of the comedi_driver struct. Some of the drivers also use
    the define as part of dev_{level}() messages and/or when doing a
    request_irq().
    
    The addition of the DRIVER_NAME to the messages is just added noise
    and the dev->board_name is typically used in the request_irq().
    
    Just remove all the DRIVER_NAME defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 64a961a5643a..45aba1f950fc 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -108,8 +108,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 #include "comedi_fc.h"
 #include "8253.h"
 
-#define DRIVER_NAME	"amplc_pci224"
-
 /*
  * PCI IDs.
  */
@@ -352,7 +350,7 @@ static const struct pci224_board pci224_boards[] = {
 	 .ao_bits = 16,
 	 },
 	{
-	 .name = DRIVER_NAME,
+	 .name = "amplc_pci224",
 	 .devid = PCI_DEVICE_ID_INVALID,
 	 .model = any_model,	/* wildcard */
 	 },
@@ -1204,8 +1202,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 		if (options) {
 			for (n = 2; n < 3 + s->n_chan; n++) {
 				if (options[n] < 0 || options[n] > 1) {
-					dev_warn(dev->class_dev, DRIVER_NAME
-						 ": warning! bad options[%u]=%d\n",
+					dev_warn(dev->class_dev,
+						 "warning! bad options[%u]=%d\n",
 						 n, options[n]);
 				}
 			}
@@ -1235,8 +1233,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 			devpriv->hwrange = hwrange_pci224_external;
 		} else {
 			if (options && options[2] != 0) {
-				dev_warn(dev->class_dev, DRIVER_NAME
-					 ": warning! bad options[2]=%d\n",
+				dev_warn(dev->class_dev,
+					 "warning! bad options[2]=%d\n",
 					 options[2]);
 			}
 			s->range_table = &range_pci224_internal;
@@ -1248,7 +1246,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 
 	if (irq) {
 		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
-				  DRIVER_NAME, dev);
+				  dev->board_name, dev);
 		if (ret < 0) {
 			dev_err(dev->class_dev,
 				"error! unable to allocate irq %u\n", irq);
@@ -1265,7 +1263,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct pci224_private *devpriv;
 	struct pci_dev *pci_dev;
 
-	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
+	dev_info(dev->class_dev, "attach\n");
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1284,8 +1282,7 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
 	struct pci224_private *devpriv;
 
-	dev_info(dev->class_dev, DRIVER_NAME ": attach pci %s\n",
-		 pci_name(pci_dev));
+	dev_info(dev->class_dev, "attach pci %s\n", pci_name(pci_dev));
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1294,7 +1291,7 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 	dev->board_ptr = pci224_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {
 		dev_err(dev->class_dev,
-			DRIVER_NAME ": BUG! cannot determine board type!\n");
+			"BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
 	/*

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 55f69c5981c4..64a961a5643a 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -120,7 +120,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 /*
  * PCI224/234 i/o space 1 (PCIBAR2) registers.
  */
-#define PCI224_IO1_SIZE	0x20	/* Size of i/o space 1 (8-bit registers) */
 #define PCI224_Z2_CT0	0x14	/* 82C54 counter/timer 0 */
 #define PCI224_Z2_CT1	0x15	/* 82C54 counter/timer 1 */
 #define PCI224_Z2_CT2	0x16	/* 82C54 counter/timer 2 */
@@ -133,7 +132,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 /*
  * PCI224/234 i/o space 2 (PCIBAR3) 16-bit registers.
  */
-#define PCI224_IO2_SIZE	0x10	/* Size of i/o space 2 (16-bit registers). */
 #define PCI224_DACDATA	0x00	/* (w-o) DAC FIFO data. */
 #define PCI224_SOFTTRIG	0x00	/* (r-o) DAC software scan trigger. */
 #define PCI224_DACCON	0x02	/* (r/w) DAC status/configuration. */

commit 34880ec79918879bd6d81f2301b14bf7243f39cf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:20 2014 -0700

    staging: comedi: amplc_pci224: checkpatch.pl cleanup (else after return)
    
    Fix this checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 339c47c1eb97..55f69c5981c4 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1255,9 +1255,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 			dev_err(dev->class_dev,
 				"error! unable to allocate irq %u\n", irq);
 			return ret;
-		} else {
-			dev->irq = irq;
 		}
+		dev->irq = irq;
 	}
 
 	return 0;

commit 35a51030995157dc03142ae6f9e17741b0224beb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:06 2014 -0700

    staging: comedi: amplc_pci224: use cfc_bytes_per_scan()
    
    The cmd->chanlist_len will always be >= 1 in this function. Remove the
    unnecessary checks.
    
    Use the comedi_fc helper function to get the 'bytes_per_scan'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 44904fd87b27..339c47c1eb97 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -545,18 +545,12 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 {
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int bytes_per_scan = cfc_bytes_per_scan(s);
 	unsigned int num_scans;
 	unsigned int room;
 	unsigned short dacstat;
 	unsigned int i, n;
-	unsigned int bytes_per_scan;
 
-	if (cmd->chanlist_len) {
-		bytes_per_scan = cmd->chanlist_len * sizeof(short);
-	} else {
-		/* Shouldn't get here! */
-		bytes_per_scan = sizeof(short);
-	}
 	/* Determine number of scans available in buffer. */
 	num_scans = comedi_buf_read_n_available(s) / bytes_per_scan;
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -597,8 +591,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
-	if (cmd->chanlist_len)
-		room /= cmd->chanlist_len;
+	room /= cmd->chanlist_len;
 
 	/* Determine how many scans to process. */
 	if (num_scans > room)

commit 9af39b31b57965f2b1f8b2bfdd8f313b485a87ff
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:48 2014 -0700

    staging: comedi: amplc_pci224: use comedi_cmd pointer
    
    Use the local variable to access the comedi_cmd as a pointer in
    pci224_ao_munge() instead of getting to it from the comedi_async
    pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index e8beeab7a78b..44904fd87b27 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -987,7 +987,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci224_private *devpriv = dev->private;
-	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
 	unsigned int offset;
@@ -997,7 +997,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* The hardware expects 16-bit numbers. */
 	shift = 16 - thisboard->ao_bits;
 	/* Channels will be all bipolar or all unipolar. */
-	if ((devpriv->hwrange[CR_RANGE(async->cmd.chanlist[0])] &
+	if ((devpriv->hwrange[CR_RANGE(cmd->chanlist[0])] &
 	     PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
 		/* Unipolar */
 		offset = 0;

commit e9edef3a5454a19fd0d0c342cc88b6310b871a48
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:09 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_read_n_available()
    
    Change the parameters of `comedi_buf_read_n_available()` to pass a
    pointer to the comedi subdevice instead of a pointer to the "async"
    structure belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index da4634e8cfeb..e8beeab7a78b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -558,7 +558,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		bytes_per_scan = sizeof(short);
 	}
 	/* Determine number of scans available in buffer. */
-	num_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;
+	num_scans = comedi_buf_read_n_available(s) / bytes_per_scan;
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_stop_count)

commit af50b31b21126daea60e63a42ed241b807fb8c99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 6 12:26:04 2014 -0700

    staging: comedi: amplc_pci224: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    scan_begin_arg when the scan_begin_src is TRIG_TIMER.
    
    For aesthetics reasons, rename the local variable 'tmp' to 'arg'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index c2b352c3c6a6..da4634e8cfeb 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -719,7 +719,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct pci224_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -746,14 +746,14 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	 * There's only one external trigger signal (which makes these
 	 * tests easier).  Only one thing can use it.
 	 */
-	tmp = 0;
+	arg = 0;
 	if (cmd->start_src & TRIG_EXT)
-		tmp++;
+		arg++;
 	if (cmd->scan_begin_src & TRIG_EXT)
-		tmp++;
+		arg++;
 	if (cmd->stop_src & TRIG_EXT)
-		tmp++;
-	if (tmp > 1)
+		arg++;
+	if (arg > 1)
 		err |= -EINVAL;
 
 	if (err)
@@ -786,10 +786,10 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
 						 MAX_SCAN_PERIOD);
 
-		tmp = cmd->chanlist_len * CONVERT_PERIOD;
-		if (tmp < MIN_SCAN_PERIOD)
-			tmp = MIN_SCAN_PERIOD;
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, tmp);
+		arg = cmd->chanlist_len * CONVERT_PERIOD;
+		if (arg < MIN_SCAN_PERIOD)
+			arg = MIN_SCAN_PERIOD;
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
@@ -840,15 +840,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* Step 4: fix up any arguments. */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
+		arg = cmd->scan_begin_arg;
 		/* Use two timers. */
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &devpriv->cached_div1,
 					  &devpriv->cached_div2,
-					  &cmd->scan_begin_arg,
-					  cmd->flags);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit 90c32ce300fb79f45d55803bc021c4e49ed9b85f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:54 2014 -0700

    staging: comedi: amplc_pci244: clarify 8254 timer programming
    
    Refactor the 8254 timer programming to use the i8254_set_mode()
    and i8254_write() helpers instead of i8254_load(). This allows
    us to use the I8254_MODE* defines to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 3002156e7e79..c2b352c3c6a6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -868,6 +868,7 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
 	struct pci224_private *devpriv = dev->private;
+	unsigned long timer_base = devpriv->iobase1 + PCI224_Z2_CT0;
 
 	/*
 	 * The output of timer Z2-0 will be used as the scan trigger
@@ -881,13 +882,13 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 	/* Z2-2 needs 10 MHz clock. */
 	outb(CLK_CONFIG(2, CLK_10MHZ), devpriv->iobase1 + PCI224_ZCLK_SCE);
 	/* Load Z2-2 mode (2) and counter (div1). */
-	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-			2, devpriv->cached_div1, 2);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+	i8254_write(timer_base, 0, 2, devpriv->cached_div1);
 	/* Z2-0 is clocked from Z2-2's output. */
 	outb(CLK_CONFIG(0, CLK_OUTNM1), devpriv->iobase1 + PCI224_ZCLK_SCE);
 	/* Load Z2-0 mode (2) and counter (div2). */
-	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-		   0, devpriv->cached_div2, 2);
+	i8254_set_mode(timer_base, 0, 0, I8254_MODE2 | I8254_BINARY);
+	i8254_write(timer_base, 0, 0, devpriv->cached_div2);
 }
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)

commit 96410e7a3316a61ec509865ec76e7d033f8096eb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:37 2014 -0700

    staging: comedi: amplc_pci224: remove 'ai_stop_continuous' from private data
    
    This member of the private data can be determined by checking the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index f0b04cac4a6e..3002156e7e79 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -377,7 +377,6 @@ struct pci224_private {
 	unsigned int cached_div1;
 	unsigned int cached_div2;
 	unsigned int ao_stop_count;
-	short ao_stop_continuous;
 	unsigned short ao_enab;	/* max 16 channels so 'short' will do */
 	unsigned char intsce;
 };
@@ -521,7 +520,7 @@ static void pci224_ao_start(struct comedi_device *dev,
 	unsigned long flags;
 
 	set_bit(AO_CMD_STARTED, &devpriv->state);
-	if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_stop_count == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
@@ -560,7 +559,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 	}
 	/* Determine number of scans available in buffer. */
 	num_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;
-	if (!devpriv->ao_stop_continuous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		/* Fixed number of scans. */
 		if (num_scans > devpriv->ao_stop_count)
 			num_scans = devpriv->ao_stop_count;
@@ -572,7 +571,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
 	case PCI224_DACCON_FIFOFL_EMPTY:
 		room = PCI224_FIFO_ROOM_EMPTY;
-		if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
+		if (cmd->stop_src == TRIG_COUNT && devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
 			s->async->events |= COMEDI_CB_EOA;
 			cfc_handle_events(dev, s);
@@ -614,7 +613,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 			     dev->iobase + PCI224_DACDATA);
 		}
 	}
-	if (!devpriv->ao_stop_continuous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_stop_count -= num_scans;
 		if (devpriv->ao_stop_count == 0) {
 			/*
@@ -952,18 +951,10 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*
 	 * Sort out end of acquisition.
 	 */
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* Fixed number of scans.  */
-		devpriv->ao_stop_continuous = 0;
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_stop_count = cmd->stop_arg;
-		break;
-	default:
-		/* Continuous scans. */
-		devpriv->ao_stop_continuous = 1;
+	else	/* TRIG_EXT | TRIG_NONE */
 		devpriv->ao_stop_count = 0;
-		break;
-	}
 
 	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	if (cmd->start_src == TRIG_INT) {

commit 43268701b50e7dbbad767e118e0023c703c7e3da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 23 15:57:19 2014 -0700

    staging: comedi: amplc_pci224: only calc the pacer divisors once
    
    When the cmd->scan_begin_src == TRIG_TIMER the divisors needed to
    generate the pacer time are calculated in the (*do_cmdtest) to
    validate the cmd->scan_begin_arg. The core always does the
    (*do_cmdtest) before the (*do_cmd) so there is no reason to recalc
    the divisors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 37a81b72633f..f0b04cac4a6e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -869,14 +869,6 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
 	struct pci224_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-
-	/* Use two timers. */
-	i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-				  &devpriv->cached_div1,
-				  &devpriv->cached_div2,
-				  &cmd->scan_begin_arg,
-				  cmd->flags);
 
 	/*
 	 * The output of timer Z2-0 will be used as the scan trigger

commit afb2bf149ac80b6d59e4139c936352ec90f45559
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 23 15:57:18 2014 -0700

    staging: comedi: amplc_pci224: always cascade the 8254 timers
    
    The 8254 timers are only used in this driver to generate the analog
    output pacer. To simplify the driver, always cascade the timers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 727fc225ad46..37a81b72633f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -841,51 +841,15 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* Step 4: fix up any arguments. */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		unsigned int div1, div2, round;
-		int round_mode = cmd->flags & TRIG_ROUND_MASK;
-
 		tmp = cmd->scan_begin_arg;
-		/* Check whether to use a single timer. */
-		switch (round_mode) {
-		case TRIG_ROUND_NEAREST:
-		default:
-			round = I8254_OSC_BASE_10MHZ / 2;
-			break;
-		case TRIG_ROUND_DOWN:
-			round = 0;
-			break;
-		case TRIG_ROUND_UP:
-			round = I8254_OSC_BASE_10MHZ - 1;
-			break;
-		}
-		/* Be careful to avoid overflow! */
-		div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
-		div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
-			I8254_OSC_BASE_10MHZ;
-		if (div2 <= 0x10000) {
-			/* A single timer will suffice. */
-			if (div2 < 2)
-				div2 = 2;
-			cmd->scan_begin_arg = div2 * I8254_OSC_BASE_10MHZ;
-			if (cmd->scan_begin_arg < div2 ||
-			    cmd->scan_begin_arg < I8254_OSC_BASE_10MHZ) {
-				/* Overflow! */
-				cmd->scan_begin_arg = MAX_SCAN_PERIOD;
-			}
-		} else {
-			/* Use two timers. */
-			div1 = devpriv->cached_div1;
-			div2 = devpriv->cached_div2;
-			i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-						  &div1, &div2,
-						  &cmd->scan_begin_arg,
-						  round_mode);
-			devpriv->cached_div1 = div1;
-			devpriv->cached_div2 = div2;
-		}
+		/* Use two timers. */
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					  &devpriv->cached_div1,
+					  &devpriv->cached_div2,
+					  &cmd->scan_begin_arg,
+					  cmd->flags);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
-
 	}
 
 	if (err)
@@ -906,70 +870,33 @@ static void pci224_ao_start_pacer(struct comedi_device *dev,
 {
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int div1, div2, round;
-	unsigned int ns = cmd->scan_begin_arg;
-	int round_mode = cmd->flags & TRIG_ROUND_MASK;
 
-	/* Check whether to use a single timer. */
-	switch (round_mode) {
-	case TRIG_ROUND_NEAREST:
-	default:
-		round = I8254_OSC_BASE_10MHZ / 2;
-		break;
-	case TRIG_ROUND_DOWN:
-		round = 0;
-		break;
-	case TRIG_ROUND_UP:
-		round = I8254_OSC_BASE_10MHZ - 1;
-		break;
-	}
-	/* Be careful to avoid overflow! */
-	div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
-	div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
-		I8254_OSC_BASE_10MHZ;
-	if (div2 <= 0x10000) {
-		/* A single timer will suffice. */
-		if (div2 < 2)
-			div2 = 2;
-		div2 &= 0xffff;
-		div1 = 1;	/* Flag that single timer to be used. */
-	} else {
-		/* Use two timers. */
-		div1 = devpriv->cached_div1;
-		div2 = devpriv->cached_div2;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					 &div1, &div2,
-					 &ns, round_mode);
-	}
+	/* Use two timers. */
+	i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+				  &devpriv->cached_div1,
+				  &devpriv->cached_div2,
+				  &cmd->scan_begin_arg,
+				  cmd->flags);
 
 	/*
 	 * The output of timer Z2-0 will be used as the scan trigger
 	 * source.
 	 */
 	/* Make sure Z2-0 is gated on.  */
-	outb(GAT_CONFIG(0, GAT_VCC),
-		devpriv->iobase1 + PCI224_ZGAT_SCE);
-	if (div1 == 1) {
-		/* Not cascading.  Z2-0 needs 10 MHz clock. */
-		outb(CLK_CONFIG(0, CLK_10MHZ),
-			devpriv->iobase1 + PCI224_ZCLK_SCE);
-	} else {
-		/* Cascading with Z2-2. */
-		/* Make sure Z2-2 is gated on.  */
-		outb(GAT_CONFIG(2, GAT_VCC),
-			devpriv->iobase1 + PCI224_ZGAT_SCE);
-		/* Z2-2 needs 10 MHz clock. */
-		outb(CLK_CONFIG(2, CLK_10MHZ),
-			devpriv->iobase1 + PCI224_ZCLK_SCE);
-		/* Load Z2-2 mode (2) and counter (div1). */
-		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-				2, div1, 2);
-		/* Z2-0 is clocked from Z2-2's output. */
-		outb(CLK_CONFIG(0, CLK_OUTNM1),
-			devpriv->iobase1 + PCI224_ZCLK_SCE);
-	}
+	outb(GAT_CONFIG(0, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
+	/* Cascading with Z2-2. */
+	/* Make sure Z2-2 is gated on.  */
+	outb(GAT_CONFIG(2, GAT_VCC), devpriv->iobase1 + PCI224_ZGAT_SCE);
+	/* Z2-2 needs 10 MHz clock. */
+	outb(CLK_CONFIG(2, CLK_10MHZ), devpriv->iobase1 + PCI224_ZCLK_SCE);
+	/* Load Z2-2 mode (2) and counter (div1). */
+	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
+			2, devpriv->cached_div1, 2);
+	/* Z2-0 is clocked from Z2-2's output. */
+	outb(CLK_CONFIG(0, CLK_OUTNM1), devpriv->iobase1 + PCI224_ZCLK_SCE);
 	/* Load Z2-0 mode (2) and counter (div2). */
-	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
+	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
+		   0, devpriv->cached_div2, 2);
 }
 
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)

commit 40d948be0ae3e40ddc0aba7b1f34f9bfd1a8bb90
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 23 15:57:17 2014 -0700

    staging: comedi: amplc_pci224: factor out the 'start pacer' code
    
    To clarify the analog output (*do_cmd) function, factor out the
    code that starts the pacer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a34bd9db10c0..727fc225ad46 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -901,9 +901,77 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
-/*
- * 'do_cmd' function for AO subdevice.
- */
+static void pci224_ao_start_pacer(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
+{
+	struct pci224_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int div1, div2, round;
+	unsigned int ns = cmd->scan_begin_arg;
+	int round_mode = cmd->flags & TRIG_ROUND_MASK;
+
+	/* Check whether to use a single timer. */
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		round = I8254_OSC_BASE_10MHZ / 2;
+		break;
+	case TRIG_ROUND_DOWN:
+		round = 0;
+		break;
+	case TRIG_ROUND_UP:
+		round = I8254_OSC_BASE_10MHZ - 1;
+		break;
+	}
+	/* Be careful to avoid overflow! */
+	div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
+	div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
+		I8254_OSC_BASE_10MHZ;
+	if (div2 <= 0x10000) {
+		/* A single timer will suffice. */
+		if (div2 < 2)
+			div2 = 2;
+		div2 &= 0xffff;
+		div1 = 1;	/* Flag that single timer to be used. */
+	} else {
+		/* Use two timers. */
+		div1 = devpriv->cached_div1;
+		div2 = devpriv->cached_div2;
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					 &div1, &div2,
+					 &ns, round_mode);
+	}
+
+	/*
+	 * The output of timer Z2-0 will be used as the scan trigger
+	 * source.
+	 */
+	/* Make sure Z2-0 is gated on.  */
+	outb(GAT_CONFIG(0, GAT_VCC),
+		devpriv->iobase1 + PCI224_ZGAT_SCE);
+	if (div1 == 1) {
+		/* Not cascading.  Z2-0 needs 10 MHz clock. */
+		outb(CLK_CONFIG(0, CLK_10MHZ),
+			devpriv->iobase1 + PCI224_ZCLK_SCE);
+	} else {
+		/* Cascading with Z2-2. */
+		/* Make sure Z2-2 is gated on.  */
+		outb(GAT_CONFIG(2, GAT_VCC),
+			devpriv->iobase1 + PCI224_ZGAT_SCE);
+		/* Z2-2 needs 10 MHz clock. */
+		outb(CLK_CONFIG(2, CLK_10MHZ),
+			devpriv->iobase1 + PCI224_ZCLK_SCE);
+		/* Load Z2-2 mode (2) and counter (div1). */
+		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
+				2, div1, 2);
+		/* Z2-0 is clocked from Z2-2's output. */
+		outb(CLK_CONFIG(0, CLK_OUTNM1),
+			devpriv->iobase1 + PCI224_ZCLK_SCE);
+	}
+	/* Load Z2-0 mode (2) and counter (div2). */
+	i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
+}
+
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pci224_private *devpriv = dev->private;
@@ -959,72 +1027,8 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		unsigned int div1, div2, round;
-		unsigned int ns = cmd->scan_begin_arg;
-		int round_mode = cmd->flags & TRIG_ROUND_MASK;
-
-		/* Check whether to use a single timer. */
-		switch (round_mode) {
-		case TRIG_ROUND_NEAREST:
-		default:
-			round = I8254_OSC_BASE_10MHZ / 2;
-			break;
-		case TRIG_ROUND_DOWN:
-			round = 0;
-			break;
-		case TRIG_ROUND_UP:
-			round = I8254_OSC_BASE_10MHZ - 1;
-			break;
-		}
-		/* Be careful to avoid overflow! */
-		div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
-		div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
-			I8254_OSC_BASE_10MHZ;
-		if (div2 <= 0x10000) {
-			/* A single timer will suffice. */
-			if (div2 < 2)
-				div2 = 2;
-			div2 &= 0xffff;
-			div1 = 1;	/* Flag that single timer to be used. */
-		} else {
-			/* Use two timers. */
-			div1 = devpriv->cached_div1;
-			div2 = devpriv->cached_div2;
-			i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-						  &div1, &div2,
-						  &ns, round_mode);
-		}
-
-		/*
-		 * The output of timer Z2-0 will be used as the scan trigger
-		 * source.
-		 */
-		/* Make sure Z2-0 is gated on.  */
-		outb(GAT_CONFIG(0, GAT_VCC),
-		     devpriv->iobase1 + PCI224_ZGAT_SCE);
-		if (div1 == 1) {
-			/* Not cascading.  Z2-0 needs 10 MHz clock. */
-			outb(CLK_CONFIG(0, CLK_10MHZ),
-			     devpriv->iobase1 + PCI224_ZCLK_SCE);
-		} else {
-			/* Cascading with Z2-2. */
-			/* Make sure Z2-2 is gated on.  */
-			outb(GAT_CONFIG(2, GAT_VCC),
-			     devpriv->iobase1 + PCI224_ZGAT_SCE);
-			/* Z2-2 needs 10 MHz clock. */
-			outb(CLK_CONFIG(2, CLK_10MHZ),
-			     devpriv->iobase1 + PCI224_ZCLK_SCE);
-			/* Load Z2-2 mode (2) and counter (div1). */
-			i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-				   2, div1, 2);
-			/* Z2-0 is clocked from Z2-2's output. */
-			outb(CLK_CONFIG(0, CLK_OUTNM1),
-			     devpriv->iobase1 + PCI224_ZCLK_SCE);
-		}
-		/* Load Z2-0 mode (2) and counter (div2). */
-		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
-	}
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		pci224_ao_start_pacer(dev, s);
 
 	/*
 	 * Sort out end of acquisition.

commit 5aae190100727086d7a752cd9d2f3889ff7359fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 23 15:57:16 2014 -0700

    staging: comedi: amplc_pci224: remove pci224_cascade_ns_to_timer()
    
    This function is just a wrapper around i8253_cascade_ns_to_timer().
    Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 3b9a8b9ae39c..a34bd9db10c0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -466,16 +466,6 @@ pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	return i;
 }
 
-/*
- * Just a wrapper for the inline function 'i8253_cascade_ns_to_timer'.
- */
-static void
-pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
-			   unsigned int *nanosec, int round_mode)
-{
-	i8253_cascade_ns_to_timer(osc_base, d1, d2, nanosec, round_mode);
-}
-
 /*
  * Kills a command running on the AO subdevice.
  */
@@ -886,10 +876,10 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			/* Use two timers. */
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
-			pci224_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-						   &div1, &div2,
-						   &cmd->scan_begin_arg,
-						   round_mode);
+			i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+						  &div1, &div2,
+						  &cmd->scan_begin_arg,
+						  round_mode);
 			devpriv->cached_div1 = div1;
 			devpriv->cached_div2 = div2;
 		}
@@ -1001,9 +991,9 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/* Use two timers. */
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
-			pci224_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-						   &div1, &div2,
-						   &ns, round_mode);
+			i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+						  &div1, &div2,
+						  &ns, round_mode);
 		}
 
 		/*

commit 9fba5ead79b996f97e80a670eabab75538a7422a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:54 2014 -0700

    staging: comedi: amplc_pci224: fix the ao cmd->start_arg use
    
    This driver supports two cmd->start_src values, TRIG_INT and TRIG_EXT. For
    TRIG_INT sources, the cmd->start_arg is actually the valid trig_num that is
    passed to the async (*inttrig) callback. This driver trivially validates the
    arg for this source to be 0.
    
    Refactor the (*inttrig) so that the cmd->start_arg is used to check the trig_num
    instead of the open coded value.
    
    For aesthetics, refactor the (*do_cmd) to use if/else instead of the switch when
    handling the cmd->start_src. All code paths do the spin lock/unlock so move those
    out of the if/else.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index e99829e58635..3b9a8b9ae39c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -671,14 +671,13 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 	cfc_handle_events(dev, s);
 }
 
-/*
- * Internal trigger function to start acquisition on AO subdevice.
- */
-static int
-pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned int trignum)
+static int pci224_ao_inttrig_start(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int trig_num)
 {
-	if (trignum != 0)
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	s->async->inttrig = NULL;
@@ -1053,23 +1052,15 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		break;
 	}
 
-	/*
-	 * Sort out start of acquisition.
-	 */
-	switch (cmd->start_src) {
-	case TRIG_INT:
-		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
-		s->async->inttrig = &pci224_ao_inttrig_start;
-		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-		break;
-	case TRIG_EXT:
+	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	if (cmd->start_src == TRIG_INT) {
+		s->async->inttrig = pci224_ao_inttrig_start;
+	} else {	/* TRIG_EXT */
 		/* Enable external interrupt trigger to start acquisition. */
-		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		devpriv->intsce |= PCI224_INTR_EXT;
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-		break;
 	}
+	spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 
 	return 0;
 }

commit febb63b6a43008621fa3465bee2a715ac6dd2b09
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:08 2014 -0700

    staging: comedi: amplc_pci224: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor the step 5 code for the analog output async command
    support. Tidy up the factored out code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 29e01e280039..e99829e58635 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -687,6 +687,37 @@ pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 1;
 }
 
+static int pci224_ao_check_chanlist(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_cmd *cmd)
+{
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	unsigned int chan_mask = 0;
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan_mask & (1 << chan)) {
+			dev_dbg(dev->class_dev,
+				"%s: entries in chanlist must contain no duplicate channels\n",
+				__func__);
+			return -EINVAL;
+		}
+		chan_mask |= (1 << chan);
+
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"%s: entries in chanlist must all have the same range index\n",
+				__func__);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 #define MAX_SCAN_PERIOD		0xFFFFFFFFU
 #define MIN_SCAN_PERIOD		2500
 #define CONVERT_PERIOD		625
@@ -871,48 +902,9 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	/* Step 5: check channel list. */
-
-	if (cmd->chanlist && (cmd->chanlist_len > 0)) {
-		unsigned int range;
-		enum { range_err = 1, dupchan_err = 2, };
-		unsigned errors;
-		unsigned int n;
-		unsigned int ch;
-
-		/*
-		 * Check all channels have the same range index.  Don't care
-		 * about analogue reference, as we can't configure it.
-		 *
-		 * Check the list has no duplicate channels.
-		 */
-		range = CR_RANGE(cmd->chanlist[0]);
-		errors = 0;
-		tmp = 0;
-		for (n = 0; n < cmd->chanlist_len; n++) {
-			ch = CR_CHAN(cmd->chanlist[n]);
-			if (tmp & (1U << ch))
-				errors |= dupchan_err;
-
-			tmp |= (1U << ch);
-			if (CR_RANGE(cmd->chanlist[n]) != range)
-				errors |= range_err;
-
-		}
-		if (errors) {
-			if (errors & dupchan_err) {
-				dev_dbg(dev->class_dev,
-					"%s: entries in chanlist must contain no duplicate channels\n",
-					__func__);
-			}
-			if (errors & range_err) {
-				dev_dbg(dev->class_dev,
-					"%s: entries in chanlist must all have the same range index\n",
-					__func__);
-			}
-			err++;
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= pci224_ao_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 94c0377d569c46be0731a5a603c8f970b8cba681
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:36 2014 -0700

    staging: comedi: amplc_pci224: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    In the Kconfig, COMEDI_AMPLC_PCI224 already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8be36b8afbdf..29e01e280039 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -533,9 +533,8 @@ static void pci224_ao_start(struct comedi_device *dev,
 	set_bit(AO_CMD_STARTED, &devpriv->state);
 	if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
 		/* An empty acquisition! */
-		pci224_ao_stop(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 	} else {
 		/* Enable interrupts. */
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
@@ -585,9 +584,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		room = PCI224_FIFO_ROOM_EMPTY;
 		if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
-			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
+			cfc_handle_events(dev, s);
 			return;
 		}
 		break;
@@ -605,9 +603,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		/* FIFO is less than half-full. */
 		if (num_scans == 0) {
 			/* Nothing left to put in the FIFO. */
-			pci224_ao_stop(dev, s);
-			s->async->events |= COMEDI_CB_OVERFLOW;
 			dev_err(dev->class_dev, "AO buffer underrun\n");
+			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
@@ -670,9 +667,8 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 					  PCI224_DACCON_TRIG_MASK);
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
-	if (s->async->events)
-		comedi_event(dev, s);
 
+	cfc_handle_events(dev, s);
 }
 
 /*

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index ae4048a624fa..8be36b8afbdf 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1237,20 +1237,6 @@ static struct pci_dev *pci224_find_pci_dev(struct comedi_device *dev,
 	return NULL;
 }
 
-static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	char tmpbuf[30];
-
-	if (irq)
-		snprintf(tmpbuf, sizeof(tmpbuf), "irq %u%s", irq,
-			 (dev->irq ? "" : " UNAVAILABLE"));
-	else
-		snprintf(tmpbuf, sizeof(tmpbuf), "no irq");
-	dev_info(dev->class_dev, "%s (pci %s) (%s) attached\n",
-		 dev->board_name, pci_name(pcidev), tmpbuf);
-}
-
 /*
  * Common part of attach and auto_attach.
  */
@@ -1399,8 +1385,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 		}
 	}
 
-	pci224_report_attach(dev, irq);
-	return 1;
+	return 0;
 }
 
 static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit 2cdbefe62789c01e0d2ee4a9360ddfa52a23a33c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:11 2013 -0700

    staging: comedi: amplc_pci224: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index f16b4724632c..ae4048a624fa 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -267,17 +267,16 @@ Passing a zero for an option is the same as leaving it unspecified.
 
 /* The software selectable internal ranges for PCI224 (option[2] == 0). */
 static const struct comedi_lrange range_pci224_internal = {
-	8,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1.25),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2.5),
-	 UNI_RANGE(1.25),
-	 }
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 static const unsigned short hwrange_pci224_internal[8] = {
@@ -293,11 +292,10 @@ static const unsigned short hwrange_pci224_internal[8] = {
 
 /* The software selectable external ranges for PCI224 (option[2] == 1). */
 static const struct comedi_lrange range_pci224_external = {
-	2,
-	{
-	 RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
-	 RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
-	 }
+	2, {
+		RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
+		RANGE_ext(0, 1)		/* unipolar [0,+Vref] */
+	}
 };
 
 static const unsigned short hwrange_pci224_external[2] = {
@@ -308,19 +306,17 @@ static const unsigned short hwrange_pci224_external[2] = {
 /* The hardware selectable Vref*2 external range for PCI234
  * (option[2] == 1, option[3+n] == 0). */
 static const struct comedi_lrange range_pci234_ext2 = {
-	1,
-	{
-	 RANGE_ext(-2, 2),
-	 }
+	1, {
+		RANGE_ext(-2, 2)
+	}
 };
 
 /* The hardware selectable Vref external range for PCI234
  * (option[2] == 1, option[3+n] == 1). */
 static const struct comedi_lrange range_pci234_ext = {
-	1,
-	{
-	 RANGE_ext(-1, 1),
-	 }
+	1, {
+		RANGE_ext(-1, 1)
+	}
 };
 
 /* This serves for all the PCI234 ranges. */

commit f127c47d23613a7f61c6c4783932ece566873888
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:44 2013 -0700

    staging: comedi: amplc_pci224: use dev->write_subdev
    
    Use the dev->write_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 230a0103497b..f16b4724632c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1140,7 +1140,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct pci224_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_cmd *cmd;
 	unsigned char intstat, valid_intstat;
 	unsigned char curenab;

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index dcccdce53c18..230a0103497b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1496,7 +1496,7 @@ static int amplc_pci224_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(amplc_pci224_pci_table) = {
+static const struct pci_device_id amplc_pci224_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
 	{ 0 }

commit 0a783410a1051fdd9238247ed6518eb5ea001f5e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:46:42 2013 -0700

    staging: comedi: amplc_pci224: remove use of DPRINTK
    
    Use dev_dbg() instead of the DPRINTK macro to output the comedi
    debugging information.
    
    The dev_dbg() will prefix the messages appropriately so remove the
    "comedi%d: " DRIVER_NAME portion and use __func__ to show the actual
    function name for debugging.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 810e397d8fd7..dcccdce53c18 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -909,16 +909,14 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		if (errors) {
 			if (errors & dupchan_err) {
-				DPRINTK("comedi%d: " DRIVER_NAME
-					": ao_cmdtest: "
-					"entries in chanlist must contain no "
-					"duplicate channels\n", dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: entries in chanlist must contain no duplicate channels\n",
+					__func__);
 			}
 			if (errors & range_err) {
-				DPRINTK("comedi%d: " DRIVER_NAME
-					": ao_cmdtest: "
-					"entries in chanlist must all have "
-					"the same range index\n", dev->minor);
+				dev_dbg(dev->class_dev,
+					"%s: entries in chanlist must all have the same range index\n",
+					__func__);
 			}
 			err++;
 		}

commit b6b40b67a9f9a94967580707c9889a0cb9600620
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:12 2013 +0100

    staging: comedi: amplc_pci224: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the type of the `ao_scan_vals` member of `struct pci224_private`
    from `short *` to `unsigned short *` for consistency.  Also change the
    type of the `array` variable in `pci224_ao_munge()` from `short *` to
    `unsigned short *`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index cf385b8e32bf..810e397d8fd7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -373,7 +373,7 @@ struct pci224_private {
 	unsigned long state;
 	spinlock_t ao_spinlock;
 	unsigned int *ao_readback;
-	short *ao_scan_vals;
+	unsigned short *ao_scan_vals;
 	unsigned char *ao_scan_order;
 	int intr_cpuid;
 	short intr_running;
@@ -1112,7 +1112,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci224_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
-	short *array = data;
+	unsigned short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
 	unsigned int offset;
 	unsigned int shift;

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 179de53a86f0..cf385b8e32bf 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -215,12 +215,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 #define CLK_EXT		7	/* external clock */
 /* Macro to construct clock input configuration register value. */
 #define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
-/* Timebases in ns. */
-#define TIMEBASE_10MHZ		100
-#define TIMEBASE_1MHZ		1000
-#define TIMEBASE_100KHZ		10000
-#define TIMEBASE_10KHZ		100000
-#define TIMEBASE_1KHZ		1000000
 
 /*
  * Counter/timer gate input configuration sources.
@@ -843,26 +837,26 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		switch (round_mode) {
 		case TRIG_ROUND_NEAREST:
 		default:
-			round = TIMEBASE_10MHZ / 2;
+			round = I8254_OSC_BASE_10MHZ / 2;
 			break;
 		case TRIG_ROUND_DOWN:
 			round = 0;
 			break;
 		case TRIG_ROUND_UP:
-			round = TIMEBASE_10MHZ - 1;
+			round = I8254_OSC_BASE_10MHZ - 1;
 			break;
 		}
 		/* Be careful to avoid overflow! */
-		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
-		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-		    TIMEBASE_10MHZ;
+		div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
+		div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
+			I8254_OSC_BASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
 				div2 = 2;
-			cmd->scan_begin_arg = div2 * TIMEBASE_10MHZ;
+			cmd->scan_begin_arg = div2 * I8254_OSC_BASE_10MHZ;
 			if (cmd->scan_begin_arg < div2 ||
-			    cmd->scan_begin_arg < TIMEBASE_10MHZ) {
+			    cmd->scan_begin_arg < I8254_OSC_BASE_10MHZ) {
 				/* Overflow! */
 				cmd->scan_begin_arg = MAX_SCAN_PERIOD;
 			}
@@ -870,7 +864,8 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			/* Use two timers. */
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
-			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
+			pci224_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+						   &div1, &div2,
 						   &cmd->scan_begin_arg,
 						   round_mode);
 			devpriv->cached_div1 = div1;
@@ -1002,19 +997,19 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		switch (round_mode) {
 		case TRIG_ROUND_NEAREST:
 		default:
-			round = TIMEBASE_10MHZ / 2;
+			round = I8254_OSC_BASE_10MHZ / 2;
 			break;
 		case TRIG_ROUND_DOWN:
 			round = 0;
 			break;
 		case TRIG_ROUND_UP:
-			round = TIMEBASE_10MHZ - 1;
+			round = I8254_OSC_BASE_10MHZ - 1;
 			break;
 		}
 		/* Be careful to avoid overflow! */
-		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
-		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-		    TIMEBASE_10MHZ;
+		div2 = cmd->scan_begin_arg / I8254_OSC_BASE_10MHZ;
+		div2 += (round + cmd->scan_begin_arg % I8254_OSC_BASE_10MHZ) /
+			I8254_OSC_BASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
@@ -1025,7 +1020,8 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/* Use two timers. */
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
-			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
+			pci224_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+						   &div1, &div2,
 						   &ns, round_mode);
 		}
 

commit bcc27c82bac2622e352c732a0bda49651e1799b3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Jul 25 22:02:48 2013 +0200

    staging: comedi: Add missing #include <linux/slab.h>
    
    sparc64 allmodconfig:
    
    drivers/staging/comedi/drivers/addi_apci_2032.c: In function 'apci2032_auto_attach':
    drivers/staging/comedi/drivers/addi_apci_2032.c:328:3: error: implicit declaration of function 'kzalloc' [-Werror=implicit-function-declaration]
    drivers/staging/comedi/drivers/addi_apci_2032.c:328:11: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/addi_apci_2032.c: In function 'apci2032_detach':
    drivers/staging/comedi/drivers/addi_apci_2032.c:350:3: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
    
    drivers/staging/comedi/drivers/amplc_pci224.c: In function 'pci224_attach_common':
    drivers/staging/comedi/drivers/amplc_pci224.c:1289:2: error: implicit declaration of function 'kmalloc' [-Werror=implicit-function-declaration]
    drivers/staging/comedi/drivers/amplc_pci224.c:1289:23: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1296:24: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1303:25: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1348:42: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c: In function 'pci224_detach':
    drivers/staging/comedi/drivers/amplc_pci224.c:1474:3: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
    
    Introduced by commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a ("staging:
    comedi: use comedi_alloc_devpriv()"), which removed some inclusions of
    <linux/slab.h>.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 2fc56c40f5b1..179de53a86f0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -101,6 +101,7 @@ Passing a zero for an option is the same as leaving it unspecified.
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 
 #include "../comedidev.h"
 

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 043120448cf9..2fc56c40f5b1 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -98,6 +98,7 @@ Passing a zero for an option is the same as leaving it unspecified.
      correctly.
 */
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index f1e36f08b103..043120448cf9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -100,7 +100,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 
 #include <linux/pci.h>
 #include <linux/interrupt.h>
-#include <linux/slab.h>
 
 #include "../comedidev.h"
 
@@ -1419,10 +1418,9 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	pci_dev = pci224_find_pci_dev(dev, it);
 	if (!pci_dev)
@@ -1440,10 +1438,9 @@ pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 	dev_info(dev->class_dev, DRIVER_NAME ": attach pci %s\n",
 		 pci_name(pci_dev));
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	dev->board_ptr = pci224_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4d7eab9b5565..f1e36f08b103 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -16,11 +16,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 /*
 Driver: amplc_pci224

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 3d5c1332eb34..4d7eab9b5565 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1280,13 +1280,10 @@ static int pci224_attach_common(struct comedi_device *dev,
 
 	comedi_set_hw_dev(dev, &pci_dev->dev);
 
-	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
-	if (ret < 0) {
-		dev_err(dev->class_dev,
-			"error! cannot enable PCI device and request regions!\n"
-			);
+	ret = comedi_pci_enable(dev);
+	if (ret)
 		return ret;
-	}
+
 	spin_lock_init(&devpriv->ao_spinlock);
 
 	devpriv->iobase1 = pci_resource_start(pci_dev, 2);

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4a56468cb7ba..3d5c1332eb34 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1488,11 +1488,9 @@ static void pci224_detach(struct comedi_device *dev)
 		kfree(devpriv->ao_scan_vals);
 		kfree(devpriv->ao_scan_order);
 	}
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
+	comedi_pci_disable(dev);
+	if (pcidev)
 		pci_dev_put(pcidev);
-	}
 }
 
 static struct comedi_driver amplc_pci224_driver = {

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index c9da4cd74baa..4a56468cb7ba 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1507,10 +1507,10 @@ static struct comedi_driver amplc_pci224_driver = {
 };
 
 static int amplc_pci224_pci_probe(struct pci_dev *dev,
-						   const struct pci_device_id
-						   *ent)
+				  const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &amplc_pci224_driver);
+	return comedi_pci_auto_config(dev, &amplc_pci224_driver,
+				      id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(amplc_pci224_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 24794f4c565f..c9da4cd74baa 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -103,6 +103,7 @@ Passing a zero for an option is the same as leaving it unspecified.
      correctly.
 */
 
+#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 6e2566a2dd57..24794f4c565f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1512,11 +1512,6 @@ static int amplc_pci224_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_pci224_driver);
 }
 
-static void amplc_pci224_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(amplc_pci224_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
@@ -1528,7 +1523,7 @@ static struct pci_driver amplc_pci224_pci_driver = {
 	.name		= "amplc_pci224",
 	.id_table	= amplc_pci224_pci_table,
 	.probe		= amplc_pci224_pci_probe,
-	.remove		= amplc_pci224_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(amplc_pci224_driver, amplc_pci224_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b1b56bab8285..6e2566a2dd57 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1512,7 +1512,7 @@ static int amplc_pci224_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_pci224_driver);
 }
 
-static void __devexit amplc_pci224_pci_remove(struct pci_dev *dev)
+static void amplc_pci224_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 1713a6660757..b1b56bab8285 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1438,7 +1438,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return pci224_attach_common(dev, pci_dev, it->options);
 }
 
-static int __devinit
+static int
 pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
@@ -1505,7 +1505,7 @@ static struct comedi_driver amplc_pci224_driver = {
 	.num_names	= ARRAY_SIZE(pci224_boards),
 };
 
-static int __devinit amplc_pci224_pci_probe(struct pci_dev *dev,
+static int amplc_pci224_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0b901d5d2694..1713a6660757 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1528,7 +1528,7 @@ static struct pci_driver amplc_pci224_pci_driver = {
 	.name		= "amplc_pci224",
 	.id_table	= amplc_pci224_pci_table,
 	.probe		= amplc_pci224_pci_probe,
-	.remove		= __devexit_p(amplc_pci224_pci_remove),
+	.remove		= amplc_pci224_pci_remove,
 };
 module_comedi_pci_driver(amplc_pci224_driver, amplc_pci224_pci_driver);
 

commit 0427c4847ef2d9f6babbc9167687a606e7533c19
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:52:40 2012 -0700

    staging: comedi: amplc_pci224: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of pci224_ao_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index e997f6e446d7..0b901d5d2694 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -757,76 +757,58 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* Step 3: make sure arguments are trivially compatible. */
+	/* Step 3: check if arguments are trivially valid */
 
 	switch (cmd->start_src) {
 	case TRIG_INT:
-		if (cmd->start_arg != 0) {
-			cmd->start_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
 		if ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
 						 ~CR_FLAGS_MASK);
-			err++;
+			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
 						 CR_FLAGS_MASK & ~CR_EDGE);
-			err++;
+			err |= -EINVAL;
 		}
 		break;
 	}
 
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		if (cmd->scan_begin_arg > MAX_SCAN_PERIOD) {
-			cmd->scan_begin_arg = MAX_SCAN_PERIOD;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 MAX_SCAN_PERIOD);
+
 		tmp = cmd->chanlist_len * CONVERT_PERIOD;
 		if (tmp < MIN_SCAN_PERIOD)
 			tmp = MIN_SCAN_PERIOD;
-
-		if (cmd->scan_begin_arg < tmp) {
-			cmd->scan_begin_arg = tmp;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, tmp);
 		break;
 	case TRIG_EXT:
 		/* Force to external trigger 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
 						      ~CR_FLAGS_MASK);
-			err++;
+			err |= -EINVAL;
 		}
 		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK &
 		     ~(CR_EDGE | CR_INVERT)) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-						      CR_FLAGS_MASK & ~(CR_EDGE
-									|
-									CR_INVERT));
-			err++;
+						      CR_FLAGS_MASK &
+						      ~(CR_EDGE | CR_INVERT));
+			err |= -EINVAL;
 		}
 		break;
 	}
 
-	/* cmd->convert_src == TRIG_NOW */
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_end_arg == TRIG_COUNT */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
@@ -837,7 +819,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		if ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
 						~CR_FLAGS_MASK);
-			err++;
+			err |= -EINVAL;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
@@ -846,10 +828,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	}
 

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 610f2ce8fa12..e997f6e446d7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1286,7 +1286,7 @@ static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
 }
 
 /*
- * Common part of attach and attach_pci.
+ * Common part of attach and auto_attach.
  */
 static int pci224_attach_common(struct comedi_device *dev,
 				struct pci_dev *pci_dev, int *options)
@@ -1460,11 +1460,12 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 }
 
 static int __devinit
-pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
+pci224_auto_attach(struct comedi_device *dev, unsigned long context_unused)
 {
+	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
 	struct pci224_private *devpriv;
 
-	dev_info(dev->class_dev, DRIVER_NAME ": attach_pci %s\n",
+	dev_info(dev->class_dev, DRIVER_NAME ": attach pci %s\n",
 		 pci_name(pci_dev));
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
@@ -1519,7 +1520,7 @@ static struct comedi_driver amplc_pci224_driver = {
 	.module		= THIS_MODULE,
 	.attach		= pci224_attach,
 	.detach		= pci224_detach,
-	.attach_pci	= pci224_attach_pci,
+	.auto_attach	= pci224_auto_attach,
 	.board_name	= &pci224_boards[0].name,
 	.offset		= sizeof(struct pci224_board),
 	.num_names	= ARRAY_SIZE(pci224_boards),

commit 2847ff5d1b63496c2e3eedb8efad2752cc2e195d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 18:14:40 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_AMPLICON
    
    Add a define for the Amplicon Liveline Limited PCI vendor id.
    Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 6a9ec11c4f07..610f2ce8fa12 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -116,7 +116,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 /*
  * PCI IDs.
  */
-#define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI224 0x0007
 #define PCI_DEVICE_ID_AMPLICON_PCI234 0x0008
 #define PCI_DEVICE_ID_INVALID 0xffff

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 5d73082adfc5..6a9ec11c4f07 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1445,14 +1445,13 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pci224_private *devpriv;
 	struct pci_dev *pci_dev;
-	int ret;
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	pci_dev = pci224_find_pci_dev(dev, it);
 	if (!pci_dev)
@@ -1465,15 +1464,14 @@ static int __devinit
 pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 {
 	struct pci224_private *devpriv;
-	int ret;
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach_pci %s\n",
 		 pci_name(pci_dev));
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	dev->board_ptr = pci224_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 1f65ec4d261e..5d73082adfc5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1443,16 +1443,16 @@ static int pci224_attach_common(struct comedi_device *dev,
 
 static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct pci224_private *devpriv;
 	struct pci_dev *pci_dev;
 	int ret;
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
 
-	ret = alloc_private(dev, sizeof(struct pci224_private));
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
-	}
+	devpriv = dev->private;
 
 	pci_dev = pci224_find_pci_dev(dev, it);
 	if (!pci_dev)
@@ -1464,16 +1464,16 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static int __devinit
 pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 {
+	struct pci224_private *devpriv;
 	int ret;
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach_pci %s\n",
 		 pci_name(pci_dev));
 
-	ret = alloc_private(dev, sizeof(struct pci224_private));
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
-	}
+	devpriv = dev->private;
 
 	dev->board_ptr = pci224_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 365f911b9b0e..1f65ec4d261e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -720,53 +720,31 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	int err = 0;
 	unsigned int tmp;
 
-	/* Step 1: make sure trigger sources are trivially valid. */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT | TRIG_TIMER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_EXT | TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* Step 2: make sure trigger sources are unique and mutually
-	 * compatible. */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
-	/* There's only one external trigger signal (which makes these
-	 * tests easier).  Only one thing can use it. */
+	/* Step 2b : and mutually compatible */
+
+	/*
+	 * There's only one external trigger signal (which makes these
+	 * tests easier).  Only one thing can use it.
+	 */
 	tmp = 0;
 	if (cmd->start_src & TRIG_EXT)
 		tmp++;
@@ -775,7 +753,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->stop_src & TRIG_EXT)
 		tmp++;
 	if (tmp > 1)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit e11c07fe386c4aff703ac87c9ec990acdfe12e39
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:30:28 2012 -0700

    staging: comedi: amplc_pci224: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8bf109e7bb05..365f911b9b0e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1375,7 +1375,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* Analog output subdevice. */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
@@ -1523,7 +1523,7 @@ static void pci224_detach(struct comedi_device *dev)
 	if (dev->subdevices) {
 		struct comedi_subdevice *s;
 
-		s = dev->subdevices + 0;
+		s = &dev->subdevices[0];
 		/* AO subdevice */
 		kfree(s->range_table_list);
 	}

commit cadf84bfeb80e216fde328d357fe856160157d2c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 3 16:39:38 2012 +0100

    staging: comedi: amplc_pci224: Fix PCI ref count
    
    When attaching a PCI device manually via the comedi driver `attach` hook
    (`pci224_attach()`) (called by the comedi core for the
    `COMEDI_DEVCONFIG` ioctl), its reference count is incremented in the
    `for_each_pci_dev` loop (in `pci224_find_pci_dev()`).  It is decremented
    when the `detach` hook (`pci224_detach()`) is called to detach the
    device.  However, when the PCI device is attached automatically via the
    `attach_pci` hook (`pci224_attach_pci()`, called at probe time via
    `comedi_pci_auto_config()`) it's reference count is not incremented so
    there will be an unmatched decrement when detaching the device.
    
    Increment the PCI device reference count in `pci224_attach_pci()` to
    correct the mismatch.
    
    Once support for manual configuration has been removed from this driver,
    the calls to `pci_dev_get()` and `pci_dev_put()` can be removed.
    
    Cc: stable <stable@vger.kernel.org> # 3.5.x
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4e17f13e57f6..8bf109e7bb05 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1503,6 +1503,13 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 			DRIVER_NAME ": BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
+	/*
+	 * Need to 'get' the PCI device to match the 'put' in pci224_detach().
+	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
+	 * support for manual attachment of PCI devices via pci224_attach()
+	 * has been removed.
+	 */
+	pci_dev_get(pci_dev);
 	return pci224_attach_common(dev, pci_dev, NULL);
 }
 

commit 415417040fbe26160c381b7e147408aacc814a96
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:41:09 2012 -0700

    staging: comedi: amplc_pci224: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index d48936708634..4e17f13e57f6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -378,7 +378,6 @@ static const struct pci224_board pci224_boards[] = {
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct pci224_private {
-	struct pci_dev *pci_dev;	/* PCI device */
 	const unsigned short *hwrange;
 	unsigned long iobase1;
 	unsigned long state;
@@ -1297,7 +1296,7 @@ static struct pci_dev *pci224_find_pci_dev(struct comedi_device *dev,
 
 static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
 {
-	struct pci224_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	char tmpbuf[30];
 
 	if (irq)
@@ -1306,7 +1305,7 @@ static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
 	else
 		snprintf(tmpbuf, sizeof(tmpbuf), "no irq");
 	dev_info(dev->class_dev, "%s (pci %s) (%s) attached\n",
-		 dev->board_name, pci_name(devpriv->pci_dev), tmpbuf);
+		 dev->board_name, pci_name(pcidev), tmpbuf);
 }
 
 /*
@@ -1322,7 +1321,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 	unsigned n;
 	int ret;
 
-	devpriv->pci_dev = pci_dev;
+	comedi_set_hw_dev(dev, &pci_dev->dev);
+
 	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
@@ -1509,6 +1509,7 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 static void pci224_detach(struct comedi_device *dev)
 {
 	struct pci224_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
@@ -1523,11 +1524,11 @@ static void pci224_detach(struct comedi_device *dev)
 		kfree(devpriv->ao_readback);
 		kfree(devpriv->ao_scan_vals);
 		kfree(devpriv->ao_scan_order);
-		if (devpriv->pci_dev) {
-			if (dev->iobase)
-				comedi_pci_disable(devpriv->pci_dev);
-			pci_dev_put(devpriv->pci_dev);
-		}
+	}
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+		pci_dev_put(pcidev);
 	}
 }
 

commit 89ed0731bcf4be9f4f4bef9d564dc329c5511639
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:40:38 2012 -0700

    staging: comedi: amplc_pci224: cleanup "find pci device" code
    
    For aesthetic reasons, rename the function and pass the
    comedi_devconfig struct instead of pre-parsing out the bus/slot
    information.
    
    Use for_each_pci_dev() instead of open-coding the loop using
    pci_get_device().
    
    Consolidate the dev_err messages when a pci device is not found.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b87e10ddf239..d48936708634 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1256,50 +1256,42 @@ static const struct pci224_board
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-static struct pci_dev *
-pci224_find_pci(struct comedi_device *dev, int bus, int slot)
+static struct pci_dev *pci224_find_pci_dev(struct comedi_device *dev,
+					   struct comedi_devconfig *it)
 {
 	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci_dev *pci_dev = NULL;
+	int bus = it->options[0];
+	int slot = it->options[1];
 
-	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-	     pci_dev != NULL;
-	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
-				      pci_dev)) {
-		/* If bus/slot specified, check them. */
+	for_each_pci_dev(pci_dev) {
 		if (bus || slot) {
-			if (bus != pci_dev->bus->number
-			    || slot != PCI_SLOT(pci_dev->devfn))
+			if (bus != pci_dev->bus->number ||
+			    slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
+		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
+			continue;
+
 		if (thisboard->model == any_model) {
 			/* Match any supported model. */
 			const struct pci224_board *board_ptr;
+
 			board_ptr = pci224_find_pci_board(pci_dev);
 			if (board_ptr == NULL)
 				continue;
 			/* Change board_ptr to matched board. */
 			dev->board_ptr = board_ptr;
-			thisboard = comedi_board(dev);
 		} else {
 			/* Match specific model name. */
 			if (thisboard->devid != pci_dev->device)
 				continue;
 		}
-
-		/* Found a match. */
 		return pci_dev;
 	}
-	/* No match found. */
-	if (bus || slot) {
-		dev_err(dev->class_dev,
-			"error! no %s found at pci %02x:%02x!\n",
-			thisboard->name, bus, slot);
-	} else {
-		dev_err(dev->class_dev, "error! no %s found!\n",
-			thisboard->name);
-	}
+	dev_err(dev->class_dev,
+		"No supported board found! (req. bus %d, slot %d)\n",
+		bus, slot);
 	return NULL;
 }
 
@@ -1474,21 +1466,18 @@ static int pci224_attach_common(struct comedi_device *dev,
 static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pci_dev *pci_dev;
-	int bus, slot;
 	int ret;
 
 	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
 
-	bus = it->options[0];
-	slot = it->options[1];
 	ret = alloc_private(dev, sizeof(struct pci224_private));
 	if (ret < 0) {
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
-	pci_dev = pci224_find_pci(dev, bus, slot);
-	if (pci_dev == NULL)
+	pci_dev = pci224_find_pci_dev(dev, it);
+	if (!pci_dev)
 		return -EIO;
 
 	return pci224_attach_common(dev, pci_dev, it->options);

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 1392406d99f0..b87e10ddf239 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1380,7 +1380,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 	     dev->iobase + PCI224_DACCON);
 
 	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index c64e32821c4d..1392406d99f0 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1379,7 +1379,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
 	     dev->iobase + PCI224_DACCON);
 
-	/* Allocate subdevices.  There is only one!  */
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0)
 		return ret;

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8d33aeab53b1..c64e32821c4d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1381,10 +1381,8 @@ static int pci224_attach_common(struct comedi_device *dev,
 
 	/* Allocate subdevices.  There is only one!  */
 	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	if (ret < 0)
 		return ret;
-	}
 
 	s = dev->subdevices + 0;
 	/* Analog output subdevice. */

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a1e23bafabea..8d33aeab53b1 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1380,7 +1380,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 	     dev->iobase + PCI224_DACCON);
 
 	/* Allocate subdevices.  There is only one!  */
-	ret = alloc_subdevices(dev, 1);
+	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;

commit cbdfaffc461fd3df12f494655aca5cae68d6c7aa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jun 8 10:39:42 2012 +0100

    staging: comedi: amplc_pci224: Replace NULLFUNC
    
    The source code defines a macro NULLFUNC
    
      #define NULLFUNC 0
    
    and uses it as a generic null function pointer constant.  This is
    superfluous.  Just use NULL instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 43f07f8f365e..a1e23bafabea 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -265,9 +265,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 /* Combine old and new bits. */
 #define COMBINE(old, new, mask)	(((old) & ~(mask)) | ((new) & (mask)))
 
-/* A generic null function pointer value.  */
-#define NULLFUNC	0
-
 /* Current CPU.  XXX should this be hard_smp_processor_id()? */
 #define THISCPU		smp_processor_id()
 
@@ -703,7 +700,7 @@ pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (trignum != 0)
 		return -EINVAL;
 
-	s->async->inttrig = NULLFUNC;
+	s->async->inttrig = NULL;
 	pci224_ao_start(dev, s);
 
 	return 1;

commit 9dc5a822ea8eaa2397f95aace504fcc657a6cd8b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 16:02:05 2012 +0100

    staging: comedi: amplc_pci224: Remove thisboard and devpriv macros
    
    The 'thisboard' and 'devpriv' macros rely on a local variable having a
    specific name and yield pointers derived from that local variable.
    Replace the macros with local variables wherever they occur.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4c41c289696c..43f07f8f365e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -377,11 +377,6 @@ static const struct pci224_board pci224_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((struct pci224_board *)dev->board_ptr)
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
@@ -405,8 +400,6 @@ struct pci224_private {
 	unsigned char intsce;
 };
 
-#define devpriv ((struct pci224_private *)dev->private)
-
 /*
  * Called from the 'insn_write' function to perform a single write.
  */
@@ -414,6 +407,8 @@ static void
 pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
 		   unsigned int data)
 {
+	const struct pci224_board *thisboard = comedi_board(dev);
+	struct pci224_private *devpriv = dev->private;
 	unsigned short mangled;
 
 	/* Store unmangled data for readback. */
@@ -476,6 +471,7 @@ static int
 pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 		    struct comedi_insn *insn, unsigned int *data)
 {
+	struct pci224_private *devpriv = dev->private;
 	int i;
 	int chan;
 
@@ -504,6 +500,7 @@ pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
 static void pci224_ao_stop(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
+	struct pci224_private *devpriv = dev->private;
 	unsigned long flags;
 
 	if (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state))
@@ -547,6 +544,7 @@ static void pci224_ao_stop(struct comedi_device *dev,
 static void pci224_ao_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 
@@ -575,6 +573,7 @@ static void pci224_ao_start(struct comedi_device *dev,
 static void pci224_ao_handle_fifo(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
 	unsigned int room;
@@ -721,6 +720,7 @@ static int
 pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		  struct comedi_cmd *cmd)
 {
+	struct pci224_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp;
 
@@ -991,6 +991,7 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
 	unsigned int i, j;
@@ -1163,6 +1164,8 @@ static void
 pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
+	const struct pci224_board *thisboard = comedi_board(dev);
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
@@ -1193,6 +1196,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 static irqreturn_t pci224_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	struct comedi_cmd *cmd;
 	unsigned char intstat, valid_intstat;
@@ -1258,6 +1262,7 @@ static const struct pci224_board
 static struct pci_dev *
 pci224_find_pci(struct comedi_device *dev, int bus, int slot)
 {
+	const struct pci224_board *thisboard = comedi_board(dev);
 	struct pci_dev *pci_dev = NULL;
 
 	/* Look for matching PCI device. */
@@ -1279,6 +1284,7 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot)
 				continue;
 			/* Change board_ptr to matched board. */
 			dev->board_ptr = board_ptr;
+			thisboard = comedi_board(dev);
 		} else {
 			/* Match specific model name. */
 			if (thisboard->devid != pci_dev->device)
@@ -1302,6 +1308,7 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot)
 
 static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
 {
+	struct pci224_private *devpriv = dev->private;
 	char tmpbuf[30];
 
 	if (irq)
@@ -1319,6 +1326,8 @@ static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
 static int pci224_attach_common(struct comedi_device *dev,
 				struct pci_dev *pci_dev, int *options)
 {
+	const struct pci224_board *thisboard = comedi_board(dev);
+	struct pci224_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	unsigned int irq;
 	unsigned n;
@@ -1516,6 +1525,8 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 
 static void pci224_detach(struct comedi_device *dev)
 {
+	struct pci224_private *devpriv = dev->private;
+
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices) {

commit 01ea83bce2d5219a71a044a084e3cecd6f0ad28e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 16:02:04 2012 +0100

    staging: comedi: amplc_pci224: Change return type of pci224_find_pci()
    
    pci224_find_pci() finds a supported PCI device, returning 0 on success
    or -EIO on failure and returning the pointer to the PCI device via a
    struct pci_dev ** parameter.  Change it to return the struct pci_dev *
    on success or NULL on failure.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a07546e0622e..4c41c289696c 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1255,14 +1255,11 @@ static const struct pci224_board
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-static int
-pci224_find_pci(struct comedi_device *dev, int bus, int slot,
-		struct pci_dev **pci_dev_p)
+static struct pci_dev *
+pci224_find_pci(struct comedi_device *dev, int bus, int slot)
 {
 	struct pci_dev *pci_dev = NULL;
 
-	*pci_dev_p = NULL;
-
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
@@ -1289,8 +1286,7 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 		}
 
 		/* Found a match. */
-		*pci_dev_p = pci_dev;
-		return 0;
+		return pci_dev;
 	}
 	/* No match found. */
 	if (bus || slot) {
@@ -1301,7 +1297,7 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 		dev_err(dev->class_dev, "error! no %s found!\n",
 			thisboard->name);
 	}
-	return -EIO;
+	return NULL;
 }
 
 static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
@@ -1488,9 +1484,9 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 	}
 
-	ret = pci224_find_pci(dev, bus, slot, &pci_dev);
-	if (ret < 0)
-		return ret;
+	pci_dev = pci224_find_pci(dev, bus, slot);
+	if (pci_dev == NULL)
+		return -EIO;
 
 	return pci224_attach_common(dev, pci_dev, it->options);
 }

commit eedc1b7be2ea7c8350f359ff9afa568cb89a70d7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 16:02:03 2012 +0100

    staging: comedi: amplc_pci224: Replace printk calls
    
    Replace the printk calls with dev_info, dev_err, etc.  There were some
    consecutive printk calls without newlines which now scnprintf into a
    temporary buffer and this bit of code has been factored out into new
    function pci224_report_attach().
    
    A couple of DPRINTK() macro calls which may result in printk() calls
    have been left alone to be tackled en masse at a later date.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 96a9d341fa15..a07546e0622e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -626,8 +626,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 			/* Nothing left to put in the FIFO. */
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
-			printk(KERN_ERR "comedi%d: "
-			       "AO buffer underrun\n", dev->minor);
+			dev_err(dev->class_dev, "AO buffer underrun\n");
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
@@ -1295,16 +1294,29 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 	}
 	/* No match found. */
 	if (bus || slot) {
-		printk(KERN_ERR "comedi%d: error! "
-		       "no %s found at pci %02x:%02x!\n",
-		       dev->minor, thisboard->name, bus, slot);
+		dev_err(dev->class_dev,
+			"error! no %s found at pci %02x:%02x!\n",
+			thisboard->name, bus, slot);
 	} else {
-		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-		       dev->minor, thisboard->name);
+		dev_err(dev->class_dev, "error! no %s found!\n",
+			thisboard->name);
 	}
 	return -EIO;
 }
 
+static void pci224_report_attach(struct comedi_device *dev, unsigned int irq)
+{
+	char tmpbuf[30];
+
+	if (irq)
+		snprintf(tmpbuf, sizeof(tmpbuf), "irq %u%s", irq,
+			 (dev->irq ? "" : " UNAVAILABLE"));
+	else
+		snprintf(tmpbuf, sizeof(tmpbuf), "no irq");
+	dev_info(dev->class_dev, "%s (pci %s) (%s) attached\n",
+		 dev->board_name, pci_name(devpriv->pci_dev), tmpbuf);
+}
+
 /*
  * Common part of attach and attach_pci.
  */
@@ -1319,9 +1331,9 @@ static int pci224_attach_common(struct comedi_device *dev,
 	devpriv->pci_dev = pci_dev;
 	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
 	if (ret < 0) {
-		printk(KERN_ERR
-		       "comedi%d: error! cannot enable PCI device "
-		       "and request regions!\n", dev->minor);
+		dev_err(dev->class_dev,
+			"error! cannot enable PCI device and request regions!\n"
+			);
 		return ret;
 	}
 	spin_lock_init(&devpriv->ao_spinlock);
@@ -1368,8 +1380,7 @@ static int pci224_attach_common(struct comedi_device *dev,
 	/* Allocate subdevices.  There is only one!  */
 	ret = alloc_subdevices(dev, 1);
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
@@ -1403,10 +1414,9 @@ static int pci224_attach_common(struct comedi_device *dev,
 		if (options) {
 			for (n = 2; n < 3 + s->n_chan; n++) {
 				if (options[n] < 0 || options[n] > 1) {
-					printk(KERN_WARNING
-					       "comedi%d: %s: warning! bad options[%u]=%d\n",
-					       dev->minor, DRIVER_NAME, n,
-					       options[n]);
+					dev_warn(dev->class_dev, DRIVER_NAME
+						 ": warning! bad options[%u]=%d\n",
+						 n, options[n]);
 				}
 			}
 		}
@@ -1435,9 +1445,9 @@ static int pci224_attach_common(struct comedi_device *dev,
 			devpriv->hwrange = hwrange_pci224_external;
 		} else {
 			if (options && options[2] != 0) {
-				printk(KERN_WARNING "comedi%d: %s: warning! "
-				       "bad options[2]=%d\n",
-				       dev->minor, DRIVER_NAME, options[2]);
+				dev_warn(dev->class_dev, DRIVER_NAME
+					 ": warning! bad options[2]=%d\n",
+					 options[2]);
 			}
 			s->range_table = &range_pci224_internal;
 			devpriv->hwrange = hwrange_pci224_internal;
@@ -1450,24 +1460,15 @@ static int pci224_attach_common(struct comedi_device *dev,
 		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
 				  DRIVER_NAME, dev);
 		if (ret < 0) {
-			printk(KERN_ERR "comedi%d: error! "
-			       "unable to allocate irq %u\n", dev->minor, irq);
+			dev_err(dev->class_dev,
+				"error! unable to allocate irq %u\n", irq);
 			return ret;
 		} else {
 			dev->irq = irq;
 		}
 	}
 
-	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
-	printk("(pci %s) ", pci_name(pci_dev));
-	if (irq)
-		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
-	else
-		printk("(no irq) ");
-
-
-	printk("attached\n");
-
+	pci224_report_attach(dev, irq);
 	return 1;
 }
 
@@ -1477,14 +1478,13 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int bus, slot;
 	int ret;
 
-	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor, DRIVER_NAME);
+	dev_info(dev->class_dev, DRIVER_NAME ": attach\n");
 
 	bus = it->options[0];
 	slot = it->options[1];
 	ret = alloc_private(dev, sizeof(struct pci224_private));
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
@@ -1500,21 +1500,19 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 {
 	int ret;
 
-	printk(KERN_DEBUG "comedi%d: %s: attach_pci %s\n", dev->minor,
-	       DRIVER_NAME, pci_name(pci_dev));
+	dev_info(dev->class_dev, DRIVER_NAME ": attach_pci %s\n",
+		 pci_name(pci_dev));
 
 	ret = alloc_private(dev, sizeof(struct pci224_private));
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
 	dev->board_ptr = pci224_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {
-		printk(KERN_ERR
-		       "comedi%d: %s: BUG! cannot determine board type!\n",
-		       dev->minor, DRIVER_NAME);
+		dev_err(dev->class_dev,
+			DRIVER_NAME ": BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
 	return pci224_attach_common(dev, pci_dev, NULL);

commit 52954abcee66f9a3c5c2416a89c8b2affd2f5a2b
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 16:02:02 2012 +0100

    staging: comedi: amplc_pci224: __devinit pci224_attach_pci()
    
    pci224_attach_pci() is only called during PCI probe, indirectly via
    comedi_pci_auto_config(), so it can be marked __devinit.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0d1f9cc50ef3..96a9d341fa15 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1495,7 +1495,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return pci224_attach_common(dev, pci_dev, it->options);
 }
 
-static int
+static int __devinit
 pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 {
 	int ret;

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index fbf19cae8747..0d1f9cc50ef3 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -108,8 +108,6 @@ Passing a zero for an option is the same as leaving it unspecified.
 
 #include "../comedidev.h"
 
-#include "comedi_pci.h"
-
 #include "comedi_fc.h"
 #include "8253.h"
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8b515f31cc9b..fbf19cae8747 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1522,13 +1522,10 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 	return pci224_attach_common(dev, pci_dev, NULL);
 }
 
-static int pci224_detach(struct comedi_device *dev)
+static void pci224_detach(struct comedi_device *dev)
 {
-	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-
 	if (dev->subdevices) {
 		struct comedi_subdevice *s;
 
@@ -1543,16 +1540,9 @@ static int pci224_detach(struct comedi_device *dev)
 		if (devpriv->pci_dev) {
 			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
-
 			pci_dev_put(devpriv->pci_dev);
 		}
 	}
-	if (dev->board_name) {
-		printk(KERN_INFO "comedi%d: %s removed\n",
-		       dev->minor, dev->board_name);
-	}
-
-	return 0;
 }
 
 static struct comedi_driver amplc_pci224_driver = {

commit 0d09df00279fde45535819e1cace3e9d330137e3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 13:50:01 2012 -0700

    staging: comedi: refactor amplc_pci224 driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index fe65338dd323..8b515f31cc9b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -379,18 +379,6 @@ static const struct pci224_board pci224_boards[] = {
 	 },
 };
 
-/*
- * PCI driver table.
- */
-
-static DEFINE_PCI_DEVICE_TABLE(pci224_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, pci224_pci_table);
-
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -421,68 +409,6 @@ struct pci224_private {
 
 #define devpriv ((struct pci224_private *)dev->private)
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int pci224_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int pci224_detach(struct comedi_device *dev);
-static int pci224_attach_pci(struct comedi_device *dev,
-			     struct pci_dev *pci_dev);
-static struct comedi_driver driver_amplc_pci224 = {
-	.driver_name = DRIVER_NAME,
-	.module = THIS_MODULE,
-	.attach = pci224_attach,
-	.detach = pci224_detach,
-	.attach_pci = pci224_attach_pci,
-	.board_name = &pci224_boards[0].name,
-	.offset = sizeof(struct pci224_board),
-	.num_names = ARRAY_SIZE(pci224_boards),
-};
-
-static int __devinit driver_amplc_pci224_pci_probe(struct pci_dev *dev,
-						   const struct pci_device_id
-						   *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_amplc_pci224);
-}
-
-static void __devexit driver_amplc_pci224_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_amplc_pci224_pci_driver = {
-	.id_table = pci224_pci_table,
-	.probe = &driver_amplc_pci224_pci_probe,
-	.remove = __devexit_p(&driver_amplc_pci224_pci_remove)
-};
-
-static int __init driver_amplc_pci224_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_amplc_pci224);
-	if (retval < 0)
-		return retval;
-
-	driver_amplc_pci224_pci_driver.name =
-	    (char *)driver_amplc_pci224.driver_name;
-	return pci_register_driver(&driver_amplc_pci224_pci_driver);
-}
-
-static void __exit driver_amplc_pci224_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_amplc_pci224_pci_driver);
-	comedi_driver_unregister(&driver_amplc_pci224);
-}
-
-module_init(driver_amplc_pci224_init_module);
-module_exit(driver_amplc_pci224_cleanup_module);
-
 /*
  * Called from the 'insn_write' function to perform a single write.
  */
@@ -1547,12 +1473,6 @@ static int pci224_attach_common(struct comedi_device *dev,
 	return 1;
 }
 
-/*
- * _attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
 static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pci_dev *pci_dev;
@@ -1577,11 +1497,6 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return pci224_attach_common(dev, pci_dev, it->options);
 }
 
-/*
- * _attach_pci is called by comedi_pci_auto_config() in the Comedi core
- * to configure a comedi device for a probed PCI device.
- * dev->board_ptr is NULL on entry.
- */
 static int
 pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 {
@@ -1607,14 +1522,6 @@ pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
 	return pci224_attach_common(dev, pci_dev, NULL);
 }
 
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
 static int pci224_detach(struct comedi_device *dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
@@ -1648,6 +1555,44 @@ static int pci224_detach(struct comedi_device *dev)
 	return 0;
 }
 
+static struct comedi_driver amplc_pci224_driver = {
+	.driver_name	= "amplc_pci224",
+	.module		= THIS_MODULE,
+	.attach		= pci224_attach,
+	.detach		= pci224_detach,
+	.attach_pci	= pci224_attach_pci,
+	.board_name	= &pci224_boards[0].name,
+	.offset		= sizeof(struct pci224_board),
+	.num_names	= ARRAY_SIZE(pci224_boards),
+};
+
+static int __devinit amplc_pci224_pci_probe(struct pci_dev *dev,
+						   const struct pci_device_id
+						   *ent)
+{
+	return comedi_pci_auto_config(dev, &amplc_pci224_driver);
+}
+
+static void __devexit amplc_pci224_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(amplc_pci224_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, amplc_pci224_pci_table);
+
+static struct pci_driver amplc_pci224_pci_driver = {
+	.name		= "amplc_pci224",
+	.id_table	= amplc_pci224_pci_table,
+	.probe		= amplc_pci224_pci_probe,
+	.remove		= __devexit_p(amplc_pci224_pci_remove),
+};
+module_comedi_pci_driver(amplc_pci224_driver, amplc_pci224_pci_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 5e9d922f788a0be512b7cb1eaa90c3692d42c8c7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:04 2012 +0100

    staging: comedi: amplc_pci224: use attach_pci() hook
    
    Change the amplc_pci224 driver to use the new attach_pci() hook in
    struct comedi_driver to auto-configure probed PCI devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 0f2cac2feab7..fe65338dd323 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -430,11 +430,14 @@ struct pci224_private {
 static int pci224_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
 static int pci224_detach(struct comedi_device *dev);
+static int pci224_attach_pci(struct comedi_device *dev,
+			     struct pci_dev *pci_dev);
 static struct comedi_driver driver_amplc_pci224 = {
 	.driver_name = DRIVER_NAME,
 	.module = THIS_MODULE,
 	.attach = pci224_attach,
 	.detach = pci224_detach,
+	.attach_pci = pci224_attach_pci,
 	.board_name = &pci224_boards[0].name,
 	.offset = sizeof(struct pci224_board),
 	.num_names = ARRAY_SIZE(pci224_boards),
@@ -1311,6 +1314,20 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 	return IRQ_RETVAL(retval);
 }
 
+/*
+ * This function looks for a board matching the supplied PCI device.
+ */
+static const struct pci224_board
+*pci224_find_pci_board(struct pci_dev *pci_dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pci224_boards); i++)
+		if (pci_dev->device == pci224_boards[i].devid)
+			return &pci224_boards[i];
+	return NULL;
+}
+
 /*
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
@@ -1336,17 +1353,12 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 		}
 		if (thisboard->model == any_model) {
 			/* Match any supported model. */
-			int i;
-
-			for (i = 0; i < ARRAY_SIZE(pci224_boards); i++) {
-				if (pci_dev->device == pci224_boards[i].devid) {
-					/* Change board_ptr to matched board. */
-					dev->board_ptr = &pci224_boards[i];
-					break;
-				}
-			}
-			if (i == ARRAY_SIZE(pci224_boards))
+			const struct pci224_board *board_ptr;
+			board_ptr = pci224_find_pci_board(pci_dev);
+			if (board_ptr == NULL)
 				continue;
+			/* Change board_ptr to matched board. */
+			dev->board_ptr = board_ptr;
 		} else {
 			/* Match specific model name. */
 			if (thisboard->devid != pci_dev->device)
@@ -1370,35 +1382,16 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 }
 
 /*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
+ * Common part of attach and attach_pci.
  */
-static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci224_attach_common(struct comedi_device *dev,
+				struct pci_dev *pci_dev, int *options)
 {
 	struct comedi_subdevice *s;
-	struct pci_dev *pci_dev;
 	unsigned int irq;
-	int bus = 0, slot = 0;
 	unsigned n;
 	int ret;
 
-	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor, DRIVER_NAME);
-
-	bus = it->options[0];
-	slot = it->options[1];
-	ret = alloc_private(dev, sizeof(struct pci224_private));
-	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
-		return ret;
-	}
-
-	ret = pci224_find_pci(dev, bus, slot, &pci_dev);
-	if (ret < 0)
-		return ret;
-
 	devpriv->pci_dev = pci_dev;
 	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
 	if (ret < 0) {
@@ -1483,24 +1476,26 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (!s->range_table_list)
 			return -ENOMEM;
 
-		for (n = 2; n < 3 + s->n_chan; n++) {
-			if (it->options[n] < 0 || it->options[n] > 1) {
-				printk(KERN_WARNING "comedi%d: %s: warning! "
-				       "bad options[%u]=%d\n",
-				       dev->minor, DRIVER_NAME, n,
-				       it->options[n]);
+		if (options) {
+			for (n = 2; n < 3 + s->n_chan; n++) {
+				if (options[n] < 0 || options[n] > 1) {
+					printk(KERN_WARNING
+					       "comedi%d: %s: warning! bad options[%u]=%d\n",
+					       dev->minor, DRIVER_NAME, n,
+					       options[n]);
+				}
 			}
 		}
 		for (n = 0; n < s->n_chan; n++) {
-			if (n < COMEDI_NDEVCONFOPTS - 3 &&
-			    it->options[3 + n] == 1) {
-				if (it->options[2] == 1)
+			if (n < COMEDI_NDEVCONFOPTS - 3 && options &&
+			    options[3 + n] == 1) {
+				if (options[2] == 1)
 					range_table_list[n] = &range_pci234_ext;
 				else
 					range_table_list[n] = &range_bipolar5;
 
 			} else {
-				if (it->options[2] == 1) {
+				if (options && options[2] == 1) {
 					range_table_list[n] =
 					    &range_pci234_ext2;
 				} else {
@@ -1511,14 +1506,14 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->hwrange = hwrange_pci234;
 	} else {
 		/* PCI224 range options. */
-		if (it->options[2] == 1) {
+		if (options && options[2] == 1) {
 			s->range_table = &range_pci224_external;
 			devpriv->hwrange = hwrange_pci224_external;
 		} else {
-			if (it->options[2] != 0) {
+			if (options && options[2] != 0) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
 				       "bad options[2]=%d\n",
-				       dev->minor, DRIVER_NAME, it->options[2]);
+				       dev->minor, DRIVER_NAME, options[2]);
 			}
 			s->range_table = &range_pci224_internal;
 			devpriv->hwrange = hwrange_pci224_internal;
@@ -1552,6 +1547,66 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
+/*
+ * _attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct pci_dev *pci_dev;
+	int bus, slot;
+	int ret;
+
+	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor, DRIVER_NAME);
+
+	bus = it->options[0];
+	slot = it->options[1];
+	ret = alloc_private(dev, sizeof(struct pci224_private));
+	if (ret < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+		       dev->minor);
+		return ret;
+	}
+
+	ret = pci224_find_pci(dev, bus, slot, &pci_dev);
+	if (ret < 0)
+		return ret;
+
+	return pci224_attach_common(dev, pci_dev, it->options);
+}
+
+/*
+ * _attach_pci is called by comedi_pci_auto_config() in the Comedi core
+ * to configure a comedi device for a probed PCI device.
+ * dev->board_ptr is NULL on entry.
+ */
+static int
+pci224_attach_pci(struct comedi_device *dev, struct pci_dev *pci_dev)
+{
+	int ret;
+
+	printk(KERN_DEBUG "comedi%d: %s: attach_pci %s\n", dev->minor,
+	       DRIVER_NAME, pci_name(pci_dev));
+
+	ret = alloc_private(dev, sizeof(struct pci224_private));
+	if (ret < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+		       dev->minor);
+		return ret;
+	}
+
+	dev->board_ptr = pci224_find_pci_board(pci_dev);
+	if (dev->board_ptr == NULL) {
+		printk(KERN_ERR
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, DRIVER_NAME);
+		return -EINVAL;
+	}
+	return pci224_attach_common(dev, pci_dev, NULL);
+}
+
 /*
  * _detach is called to deconfigure a device.  It should deallocate
  * resources.

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b278917cec25..0f2cac2feab7 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -444,7 +444,7 @@ static int __devinit driver_amplc_pci224_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {
-	return comedi_pci_auto_config(dev, driver_amplc_pci224.driver_name);
+	return comedi_pci_auto_config(dev, &driver_amplc_pci224);
 }
 
 static void __devexit driver_amplc_pci224_pci_remove(struct pci_dev *dev)

commit 7b0be12b26d86ea2bd5079f0d723289e2f5a43a9
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Nov 7 00:54:02 2011 +0100

    staging/comedi/amplc: Convert pci_table entries to PCI_DEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries to use the PCI_DEVICE macro,
    if .subvendor and .subdevice are set to PCI_ANY_ID,
    and thus improves readablity.
    
    Since the driver_data field isn't used anywhere we can also drop the
    assignments for class, class_mask and driver_data.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 1b5ba1c27259..b278917cec25 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -384,12 +384,9 @@ static const struct pci224_board pci224_boards[] = {
  */
 
 static DEFINE_PCI_DEVICE_TABLE(pci224_pci_table) = {
-	{
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
-		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
-		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234) },
+	{0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci224_pci_table);

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index a27e27f5b7b8..1b5ba1c27259 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -443,7 +443,45 @@ static struct comedi_driver driver_amplc_pci224 = {
 	.num_names = ARRAY_SIZE(pci224_boards),
 };
 
-COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
+static int __devinit driver_amplc_pci224_pci_probe(struct pci_dev *dev,
+						   const struct pci_device_id
+						   *ent)
+{
+	return comedi_pci_auto_config(dev, driver_amplc_pci224.driver_name);
+}
+
+static void __devexit driver_amplc_pci224_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_amplc_pci224_pci_driver = {
+	.id_table = pci224_pci_table,
+	.probe = &driver_amplc_pci224_pci_probe,
+	.remove = __devexit_p(&driver_amplc_pci224_pci_remove)
+};
+
+static int __init driver_amplc_pci224_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_amplc_pci224);
+	if (retval < 0)
+		return retval;
+
+	driver_amplc_pci224_pci_driver.name =
+	    (char *)driver_amplc_pci224.driver_name;
+	return pci_register_driver(&driver_amplc_pci224_pci_driver);
+}
+
+static void __exit driver_amplc_pci224_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_amplc_pci224_pci_driver);
+	comedi_driver_unregister(&driver_amplc_pci224);
+}
+
+module_init(driver_amplc_pci224_init_module);
+module_exit(driver_amplc_pci224_cleanup_module);
 
 /*
  * Called from the 'insn_write' function to perform a single write.

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index c486a878e180..a27e27f5b7b8 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1557,3 +1557,7 @@ static int pci224_detach(struct comedi_device *dev)
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 6608224c9e5c8aacf88914697be2d5f1fc7a0be6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 17:36:52 2010 -0700

    Staging: comedi: remove another vendor id
    
    This id was already in the drivers, so just use it there
    instead of in a common header file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 8af156dca17e..c486a878e180 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -118,7 +118,7 @@ Passing a zero for an option is the same as leaving it unspecified.
 /*
  * PCI IDs.
  */
-/* #define PCI_VENDOR_ID_AMPLICON 0x14dc */
+#define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI224 0x0007
 #define PCI_DEVICE_ID_AMPLICON_PCI234 0x0008
 #define PCI_DEVICE_ID_INVALID 0xffff

commit 767700c454301058188fe6561c3d0213f6991e81
Author: Jason Wong <tsanghan@gmail.com>
Date:   Wed Mar 10 16:58:55 2010 +0800

    Staging: comedi: amplc_pci224: fixed multiple brace coding style issue
    
    Fixed multiple coding style issue.
    
    Signed-off-by: Jason Wong <tsanghan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index c54cca8b2565..8af156dca17e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -496,9 +496,9 @@ pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Writing a list of values to an AO channel is probably not
 	 * very useful, but that's how the interface is defined. */
-	for (i = 0; i < insn->n; i++) {
+	for (i = 0; i < insn->n; i++)
 		pci224_ao_set_data(dev, chan, range, data[i]);
-	}
+
 	return i;
 }
 
@@ -519,9 +519,9 @@ pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	chan = CR_CHAN(insn->chanspec);
 
-	for (i = 0; i < insn->n; i++) {
+	for (i = 0; i < insn->n; i++)
 		data[i] = devpriv->ao_readback[chan];
-	}
+
 
 	return i;
 }
@@ -544,9 +544,9 @@ static void pci224_ao_stop(struct comedi_device *dev,
 {
 	unsigned long flags;
 
-	if (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state)) {
+	if (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state))
 		return;
-	}
+
 
 	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	/* Kill the interrupts. */
@@ -597,11 +597,11 @@ static void pci224_ao_start(struct comedi_device *dev,
 	} else {
 		/* Enable interrupts. */
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
-		if (cmd->stop_src == TRIG_EXT) {
+		if (cmd->stop_src == TRIG_EXT)
 			devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
-		} else {
+		else
 			devpriv->intsce = PCI224_INTR_DAC;
-		}
+
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
 		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	}
@@ -630,9 +630,9 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 	num_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;
 	if (!devpriv->ao_stop_continuous) {
 		/* Fixed number of scans. */
-		if (num_scans > devpriv->ao_stop_count) {
+		if (num_scans > devpriv->ao_stop_count)
 			num_scans = devpriv->ao_stop_count;
-		}
+
 	}
 
 	/* Determine how much room is in the FIFO (in samples). */
@@ -669,13 +669,13 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
-	if (cmd->chanlist_len) {
+	if (cmd->chanlist_len)
 		room /= cmd->chanlist_len;
-	}
+
 	/* Determine how many scans to process. */
-	if (num_scans > room) {
+	if (num_scans > room)
 		num_scans = room;
-	}
+
 	/* Process scans. */
 	for (n = 0; n < num_scans; n++) {
 		cfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],
@@ -718,19 +718,19 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev,
 			trig = PCI224_DACCON_TRIG_Z2CT0;
 		} else {
 			/* cmd->scan_begin_src == TRIG_EXT */
-			if (cmd->scan_begin_arg & CR_INVERT) {
+			if (cmd->scan_begin_arg & CR_INVERT)
 				trig = PCI224_DACCON_TRIG_EXTN;
-			} else {
+			else
 				trig = PCI224_DACCON_TRIG_EXTP;
-			}
+
 		}
 		devpriv->daccon = COMBINE(devpriv->daccon, trig,
 					  PCI224_DACCON_TRIG_MASK);
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
-	if (s->async->events) {
+	if (s->async->events)
 		comedi_event(dev, s);
-	}
+
 }
 
 /*
@@ -855,9 +855,9 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			err++;
 		}
 		tmp = cmd->chanlist_len * CONVERT_PERIOD;
-		if (tmp < MIN_SCAN_PERIOD) {
+		if (tmp < MIN_SCAN_PERIOD)
 			tmp = MIN_SCAN_PERIOD;
-		}
+
 		if (cmd->scan_begin_arg < tmp) {
 			cmd->scan_begin_arg = tmp;
 			err++;
@@ -966,9 +966,9 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			devpriv->cached_div1 = div1;
 			devpriv->cached_div2 = div2;
 		}
-		if (tmp != cmd->scan_begin_arg) {
+		if (tmp != cmd->scan_begin_arg)
 			err++;
-		}
+
 	}
 
 	if (err)
@@ -994,13 +994,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 		tmp = 0;
 		for (n = 0; n < cmd->chanlist_len; n++) {
 			ch = CR_CHAN(cmd->chanlist[n]);
-			if (tmp & (1U << ch)) {
+			if (tmp & (1U << ch))
 				errors |= dupchan_err;
-			}
+
 			tmp |= (1U << ch);
-			if (CR_RANGE(cmd->chanlist[n]) != range) {
+			if (CR_RANGE(cmd->chanlist[n]) != range)
 				errors |= range_err;
-			}
+
 		}
 		if (errors) {
 			if (errors & dupchan_err) {
@@ -1038,9 +1038,9 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	/* Cannot handle null/empty chanlist. */
-	if (cmd->chanlist == NULL || cmd->chanlist_len == 0) {
+	if (cmd->chanlist == NULL || cmd->chanlist_len == 0)
 		return -EINVAL;
-	}
+
 
 	/* Determine which channels are enabled and their load order.  */
 	devpriv->ao_enab = 0;
@@ -1050,9 +1050,9 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ao_enab |= 1U << ch;
 		rank = 0;
 		for (j = 0; j < cmd->chanlist_len; j++) {
-			if (CR_CHAN(cmd->chanlist[j]) < ch) {
+			if (CR_CHAN(cmd->chanlist[j]) < ch)
 				rank++;
-			}
+
 		}
 		devpriv->ao_scan_order[rank] = i;
 	}
@@ -1221,9 +1221,9 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 		offset = 32768;
 	}
 	/* Munge the data. */
-	for (i = 0; i < length; i++) {
+	for (i = 0; i < length; i++)
 		array[i] = (array[i] << shift) - offset;
-	}
+
 }
 
 /*
@@ -1254,15 +1254,15 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 			cmd = &s->async->cmd;
 			if (valid_intstat & PCI224_INTR_EXT) {
 				devpriv->intsce &= ~PCI224_INTR_EXT;
-				if (cmd->start_src == TRIG_EXT) {
+				if (cmd->start_src == TRIG_EXT)
 					pci224_ao_start(dev, s);
-				} else if (cmd->stop_src == TRIG_EXT) {
+				else if (cmd->stop_src == TRIG_EXT)
 					pci224_ao_stop(dev, s);
-				}
+
 			}
-			if (valid_intstat & PCI224_INTR_DAC) {
+			if (valid_intstat & PCI224_INTR_DAC)
 				pci224_ao_handle_fifo(dev, s);
-			}
+
 		}
 		/* Reenable interrupt sources. */
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
@@ -1381,23 +1381,23 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Allocate readback buffer for AO channels. */
 	devpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *
 				       thisboard->ao_chans, GFP_KERNEL);
-	if (!devpriv->ao_readback) {
+	if (!devpriv->ao_readback)
 		return -ENOMEM;
-	}
+
 
 	/* Allocate buffer to hold values for AO channel scan. */
 	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
 					thisboard->ao_chans, GFP_KERNEL);
-	if (!devpriv->ao_scan_vals) {
+	if (!devpriv->ao_scan_vals)
 		return -ENOMEM;
-	}
+
 
 	/* Allocate buffer to hold AO channel scan order. */
 	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
 					 thisboard->ao_chans, GFP_KERNEL);
-	if (!devpriv->ao_scan_order) {
+	if (!devpriv->ao_scan_order)
 		return -ENOMEM;
-	}
+
 
 	/* Disable interrupt sources. */
 	devpriv->intsce = 0;
@@ -1445,9 +1445,9 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->range_table_list = range_table_list =
 		    kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
 			    GFP_KERNEL);
-		if (!s->range_table_list) {
+		if (!s->range_table_list)
 			return -ENOMEM;
-		}
+
 		for (n = 2; n < 3 + s->n_chan; n++) {
 			if (it->options[n] < 0 || it->options[n] > 1) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
@@ -1459,11 +1459,11 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		for (n = 0; n < s->n_chan; n++) {
 			if (n < COMEDI_NDEVCONFOPTS - 3 &&
 			    it->options[3 + n] == 1) {
-				if (it->options[2] == 1) {
+				if (it->options[2] == 1)
 					range_table_list[n] = &range_pci234_ext;
-				} else {
+				else
 					range_table_list[n] = &range_bipolar5;
-				}
+
 			} else {
 				if (it->options[2] == 1) {
 					range_table_list[n] =
@@ -1506,11 +1506,11 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
 	printk("(pci %s) ", pci_name(pci_dev));
-	if (irq) {
+	if (irq)
 		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
-	} else {
+	else
 		printk("(no irq) ");
-	}
+
 
 	printk("attached\n");
 
@@ -1529,9 +1529,9 @@ static int pci224_detach(struct comedi_device *dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
 
-	if (dev->irq) {
+	if (dev->irq)
 		free_irq(dev->irq, dev);
-	}
+
 	if (dev->subdevices) {
 		struct comedi_subdevice *s;
 
@@ -1544,9 +1544,9 @@ static int pci224_detach(struct comedi_device *dev)
 		kfree(devpriv->ao_scan_vals);
 		kfree(devpriv->ao_scan_order);
 		if (devpriv->pci_dev) {
-			if (dev->iobase) {
+			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
-			}
+
 			pci_dev_put(devpriv->pci_dev);
 		}
 	}

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b41e5e5963aa..c54cca8b2565 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -104,6 +104,7 @@ Passing a zero for an option is the same as leaving it unspecified.
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 
 #include "../comedidev.h"
 

commit 48d07f2bf3fd6d0bbe7577f1844f7edfaf7399f6
Author: d binderman <dcb314@hotmail.com>
Date:   Sun Feb 21 10:02:59 2010 +0000

    Staging: comedi: amplc_pci224.c: coding style cleanups
    
    Signed-off-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index d9836879355e..b41e5e5963aa 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1536,20 +1536,12 @@ static int pci224_detach(struct comedi_device *dev)
 
 		s = dev->subdevices + 0;
 		/* AO subdevice */
-		if (s->range_table_list) {
-			kfree(s->range_table_list);
-		}
+		kfree(s->range_table_list);
 	}
 	if (devpriv) {
-		if (devpriv->ao_readback) {
-			kfree(devpriv->ao_readback);
-		}
-		if (devpriv->ao_scan_vals) {
-			kfree(devpriv->ao_scan_vals);
-		}
-		if (devpriv->ao_scan_order) {
-			kfree(devpriv->ao_scan_order);
-		}
+		kfree(devpriv->ao_readback);
+		kfree(devpriv->ao_scan_vals);
+		kfree(devpriv->ao_scan_order);
 		if (devpriv->pci_dev) {
 			if (dev->iobase) {
 				comedi_pci_disable(devpriv->pci_dev);

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index d1a64e80cddb..d9836879355e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -283,15 +283,15 @@ Passing a zero for an option is the same as leaving it unspecified.
 static const struct comedi_lrange range_pci224_internal = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25),
+	 }
 };
 
 static const unsigned short hwrange_pci224_internal[8] = {
@@ -309,9 +309,9 @@ static const unsigned short hwrange_pci224_internal[8] = {
 static const struct comedi_lrange range_pci224_external = {
 	2,
 	{
-			RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
-			RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
-		}
+	 RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
+	 RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
+	 }
 };
 
 static const unsigned short hwrange_pci224_external[2] = {
@@ -324,8 +324,8 @@ static const unsigned short hwrange_pci224_external[2] = {
 static const struct comedi_lrange range_pci234_ext2 = {
 	1,
 	{
-			RANGE_ext(-2, 2),
-		}
+	 RANGE_ext(-2, 2),
+	 }
 };
 
 /* The hardware selectable Vref external range for PCI234
@@ -333,8 +333,8 @@ static const struct comedi_lrange range_pci234_ext2 = {
 static const struct comedi_lrange range_pci234_ext = {
 	1,
 	{
-			RANGE_ext(-1, 1),
-		}
+	 RANGE_ext(-1, 1),
+	 }
 };
 
 /* This serves for all the PCI234 ranges. */
@@ -358,24 +358,24 @@ struct pci224_board {
 
 static const struct pci224_board pci224_boards[] = {
 	{
-	.name = "pci224",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI224,
-	.model = pci224_model,
-	.ao_chans = 16,
-	.ao_bits = 12,
-		},
+	 .name = "pci224",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI224,
+	 .model = pci224_model,
+	 .ao_chans = 16,
+	 .ao_bits = 12,
+	 },
 	{
-	.name = "pci234",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI234,
-	.model = pci234_model,
-	.ao_chans = 4,
-	.ao_bits = 16,
-		},
+	 .name = "pci234",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI234,
+	 .model = pci234_model,
+	 .ao_chans = 4,
+	 .ao_bits = 16,
+	 },
 	{
-	.name = DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.model = any_model,	/* wildcard */
-		},
+	 .name = DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .model = any_model,	/* wildcard */
+	 },
 };
 
 /*
@@ -383,11 +383,12 @@ static const struct pci224_board pci224_boards[] = {
  */
 
 static DEFINE_PCI_DEVICE_TABLE(pci224_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci224_pci_table);
@@ -428,7 +429,8 @@ struct pci224_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci224_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int pci224_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci224 = {
 	.driver_name = DRIVER_NAME,
@@ -446,7 +448,8 @@ COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
  * Called from the 'insn_write' function to perform a single write.
  */
 static void
-pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int data)
+pci224_ao_set_data(struct comedi_device *dev, int chan, int range,
+		   unsigned int data)
 {
 	unsigned short mangled;
 
@@ -456,9 +459,10 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int
 	outw(1 << chan, dev->iobase + PCI224_DACCEN);
 	/* Set range and reset FIFO. */
 	devpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],
-		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK));
+				  (PCI224_DACCON_POLAR_MASK |
+				   PCI224_DACCON_VREF_MASK));
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 	/*
 	 * Mangle the data.  The hardware expects:
 	 * - bipolar: 16-bit 2's complement
@@ -466,7 +470,7 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int
 	 */
 	mangled = (unsigned short)data << (16 - thisboard->ao_bits);
 	if ((devpriv->daccon & PCI224_DACCON_POLAR_MASK) ==
-		PCI224_DACCON_POLAR_BI) {
+	    PCI224_DACCON_POLAR_BI) {
 		mangled ^= 0x8000;
 	}
 	/* Write mangled data to the FIFO. */
@@ -480,7 +484,7 @@ pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int
  */
 static int
 pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		     struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -507,7 +511,7 @@ pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int
 pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+		    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -526,7 +530,7 @@ pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static void
 pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
-	unsigned int *nanosec, int round_mode)
+			   unsigned int *nanosec, int round_mode)
 {
 	i8253_cascade_ns_to_timer(osc_base, d1, d2, nanosec, round_mode);
 }
@@ -534,7 +538,8 @@ pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
 /*
  * Kills a command running on the AO subdevice.
  */
-static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_stop(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -565,16 +570,19 @@ static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	/* Reconfigure DAC for insn_write usage. */
 	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
 	devpriv->daccon = COMBINE(devpriv->daccon,
-		PCI224_DACCON_TRIG_SW | PCI224_DACCON_FIFOINTR_EMPTY,
-		PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
+				  PCI224_DACCON_TRIG_SW |
+				  PCI224_DACCON_FIFOINTR_EMPTY,
+				  PCI224_DACCON_TRIG_MASK |
+				  PCI224_DACCON_FIFOINTR_MASK);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 }
 
 /*
  * Handles start of acquisition for the AO subdevice.
  */
-static void pci224_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -601,7 +609,8 @@ static void pci224_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 /*
  * Handles interrupts from the DAC FIFO.
  */
-static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
+static void pci224_ao_handle_fifo(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
@@ -630,8 +639,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
 	case PCI224_DACCON_FIFOFL_EMPTY:
 		room = PCI224_FIFO_ROOM_EMPTY;
-		if (!devpriv->ao_stop_continuous
-			&& devpriv->ao_stop_count == 0) {
+		if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
 			/* FIFO empty at end of counted acquisition. */
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
@@ -656,7 +664,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 			printk(KERN_ERR "comedi%d: "
-				"AO buffer underrun\n", dev->minor);
+			       "AO buffer underrun\n", dev->minor);
 		}
 	}
 	/* Determine how many new scans can be put in the FIFO. */
@@ -670,11 +678,10 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 	/* Process scans. */
 	for (n = 0; n < num_scans; n++) {
 		cfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],
-			bytes_per_scan);
+					   bytes_per_scan);
 		for (i = 0; i < cmd->chanlist_len; i++) {
-			outw(devpriv->ao_scan_vals[devpriv->
-					ao_scan_order[i]],
-				dev->iobase + PCI224_DACDATA);
+			outw(devpriv->ao_scan_vals[devpriv->ao_scan_order[i]],
+			     dev->iobase + PCI224_DACDATA);
 		}
 	}
 	if (!devpriv->ao_stop_continuous) {
@@ -685,14 +692,13 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 			 * until FIFO is empty.
 			 */
 			devpriv->daccon = COMBINE(devpriv->daccon,
-				PCI224_DACCON_FIFOINTR_EMPTY,
-				PCI224_DACCON_FIFOINTR_MASK);
-			outw(devpriv->daccon,
-				dev->iobase + PCI224_DACCON);
+						  PCI224_DACCON_FIFOINTR_EMPTY,
+						  PCI224_DACCON_FIFOINTR_MASK);
+			outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 		}
 	}
 	if ((devpriv->daccon & PCI224_DACCON_TRIG_MASK) ==
-		PCI224_DACCON_TRIG_NONE) {
+	    PCI224_DACCON_TRIG_NONE) {
 		unsigned short trig;
 
 		/*
@@ -718,7 +724,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 			}
 		}
 		devpriv->daccon = COMBINE(devpriv->daccon, trig,
-			PCI224_DACCON_TRIG_MASK);
+					  PCI224_DACCON_TRIG_MASK);
 		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
 	}
 	if (s->async->events) {
@@ -731,7 +737,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
  */
 static int
 pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			unsigned int trignum)
 {
 	if (trignum != 0)
 		return -EINVAL;
@@ -750,7 +756,8 @@ pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
+pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+		  struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -828,13 +835,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct
 		/* Force to external trigger 0. */
 		if ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
-				~CR_FLAGS_MASK);
+						 ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->start_arg = COMBINE(cmd->start_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						 CR_FLAGS_MASK & ~CR_EDGE);
 			err++;
 		}
 		break;
@@ -859,14 +866,16 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct
 		/* Force to external trigger 0. */
 		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				~CR_FLAGS_MASK);
+						      ~CR_FLAGS_MASK);
 			err++;
 		}
 		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
 		if ((cmd->scan_begin_arg & CR_FLAGS_MASK &
-				~(CR_EDGE | CR_INVERT)) != 0) {
+		     ~(CR_EDGE | CR_INVERT)) != 0) {
 			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
-				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+						      CR_FLAGS_MASK & ~(CR_EDGE
+									|
+									CR_INVERT));
 			err++;
 		}
 		break;
@@ -892,13 +901,13 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct
 		/* Force to external trigger 0. */
 		if ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-				~CR_FLAGS_MASK);
+						~CR_FLAGS_MASK);
 			err++;
 		}
 		/* The only flag allowed is CR_EDGE, which is ignored. */
 		if ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
 			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
-				CR_FLAGS_MASK & ~CR_EDGE);
+						CR_FLAGS_MASK & ~CR_EDGE);
 		}
 		break;
 	case TRIG_NONE:
@@ -935,14 +944,14 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct
 		/* Be careful to avoid overflow! */
 		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
 		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-			TIMEBASE_10MHZ;
+		    TIMEBASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
 				div2 = 2;
 			cmd->scan_begin_arg = div2 * TIMEBASE_10MHZ;
 			if (cmd->scan_begin_arg < div2 ||
-				cmd->scan_begin_arg < TIMEBASE_10MHZ) {
+			    cmd->scan_begin_arg < TIMEBASE_10MHZ) {
 				/* Overflow! */
 				cmd->scan_begin_arg = MAX_SCAN_PERIOD;
 			}
@@ -951,7 +960,8 @@ pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
 			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
-				&cmd->scan_begin_arg, round_mode);
+						   &cmd->scan_begin_arg,
+						   round_mode);
 			devpriv->cached_div1 = div1;
 			devpriv->cached_div2 = div2;
 		}
@@ -1061,12 +1071,15 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * N.B. DAC FIFO interrupts are currently disabled.
 	 */
 	devpriv->daccon = COMBINE(devpriv->daccon,
-		(devpriv->hwrange[range] | PCI224_DACCON_TRIG_NONE |
-			PCI224_DACCON_FIFOINTR_NHALF),
-		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
-			PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK));
+				  (devpriv->
+				   hwrange[range] | PCI224_DACCON_TRIG_NONE |
+				   PCI224_DACCON_FIFOINTR_NHALF),
+				  (PCI224_DACCON_POLAR_MASK |
+				   PCI224_DACCON_VREF_MASK |
+				   PCI224_DACCON_TRIG_MASK |
+				   PCI224_DACCON_FIFOINTR_MASK));
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int div1, div2, round;
@@ -1089,7 +1102,7 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* Be careful to avoid overflow! */
 		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
 		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
-			TIMEBASE_10MHZ;
+		    TIMEBASE_10MHZ;
 		if (div2 <= 0x10000) {
 			/* A single timer will suffice. */
 			if (div2 < 2)
@@ -1101,7 +1114,7 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			div1 = devpriv->cached_div1;
 			div2 = devpriv->cached_div2;
 			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
-				&ns, round_mode);
+						   &ns, round_mode);
 		}
 
 		/*
@@ -1110,25 +1123,25 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		 */
 		/* Make sure Z2-0 is gated on.  */
 		outb(GAT_CONFIG(0, GAT_VCC),
-			devpriv->iobase1 + PCI224_ZGAT_SCE);
+		     devpriv->iobase1 + PCI224_ZGAT_SCE);
 		if (div1 == 1) {
 			/* Not cascading.  Z2-0 needs 10 MHz clock. */
 			outb(CLK_CONFIG(0, CLK_10MHZ),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 		} else {
 			/* Cascading with Z2-2. */
 			/* Make sure Z2-2 is gated on.  */
 			outb(GAT_CONFIG(2, GAT_VCC),
-				devpriv->iobase1 + PCI224_ZGAT_SCE);
+			     devpriv->iobase1 + PCI224_ZGAT_SCE);
 			/* Z2-2 needs 10 MHz clock. */
 			outb(CLK_CONFIG(2, CLK_10MHZ),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 			/* Load Z2-2 mode (2) and counter (div1). */
 			i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
-				2, div1, 2);
+				   2, div1, 2);
 			/* Z2-0 is clocked from Z2-2's output. */
 			outb(CLK_CONFIG(0, CLK_OUTNM1),
-				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			     devpriv->iobase1 + PCI224_ZCLK_SCE);
 		}
 		/* Load Z2-0 mode (2) and counter (div2). */
 		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
@@ -1174,7 +1187,8 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 /*
  * 'cancel' function for AO subdevice.
  */
-static int pci224_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci224_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	pci224_ao_stop(dev, s);
 	return 0;
@@ -1184,8 +1198,8 @@ static int pci224_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *
  * 'munge' data for AO command.
  */
 static void
-pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s, void *data,
-	unsigned int num_bytes, unsigned int chan_index)
+pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,
+		void *data, unsigned int num_bytes, unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
 	short *array = data;
@@ -1198,7 +1212,7 @@ pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s, void *dat
 	shift = 16 - thisboard->ao_bits;
 	/* Channels will be all bipolar or all unipolar. */
 	if ((devpriv->hwrange[CR_RANGE(async->cmd.chanlist[0])] &
-			PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
+	     PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
 		/* Unipolar */
 		offset = 0;
 	} else {
@@ -1253,7 +1267,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (curenab != devpriv->intsce) {
 			outb(devpriv->intsce,
-				devpriv->iobase1 + PCI224_INT_SCE);
+			     devpriv->iobase1 + PCI224_INT_SCE);
 		}
 		devpriv->intr_running = 0;
 		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
@@ -1267,7 +1281,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
  */
 static int
 pci224_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+		struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -1275,13 +1289,13 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
-			pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
+				      pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == any_model) {
@@ -1310,11 +1324,11 @@ pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR "comedi%d: error! "
-			"no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -1341,7 +1355,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	ret = alloc_private(dev, sizeof(struct pci224_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1353,8 +1367,8 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
 	if (ret < 0) {
 		printk(KERN_ERR
-			"comedi%d: error! cannot enable PCI device "
-			"and request regions!\n", dev->minor);
+		       "comedi%d: error! cannot enable PCI device "
+		       "and request regions!\n", dev->minor);
 		return ret;
 	}
 	spin_lock_init(&devpriv->ao_spinlock);
@@ -1365,21 +1379,21 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* Allocate readback buffer for AO channels. */
 	devpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+				       thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_readback) {
 		return -ENOMEM;
 	}
 
 	/* Allocate buffer to hold values for AO channel scan. */
 	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+					thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_vals) {
 		return -ENOMEM;
 	}
 
 	/* Allocate buffer to hold AO channel scan order. */
 	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
-		thisboard->ao_chans, GFP_KERNEL);
+					 thisboard->ao_chans, GFP_KERNEL);
 	if (!devpriv->ao_scan_order) {
 		return -ENOMEM;
 	}
@@ -1393,15 +1407,16 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outw(0, dev->iobase + PCI224_DACCEN);
 	outw(0, dev->iobase + PCI224_FIFOSIZ);
 	devpriv->daccon = (PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |
-		PCI224_DACCON_FIFOENAB | PCI224_DACCON_FIFOINTR_EMPTY);
+			   PCI224_DACCON_FIFOENAB |
+			   PCI224_DACCON_FIFOINTR_EMPTY);
 	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
-		dev->iobase + PCI224_DACCON);
+	     dev->iobase + PCI224_DACCON);
 
 	/* Allocate subdevices.  There is only one!  */
 	ret = alloc_subdevices(dev, 1);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1427,22 +1442,22 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		const struct comedi_lrange **range_table_list;
 
 		s->range_table_list = range_table_list =
-			kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
+			    GFP_KERNEL);
 		if (!s->range_table_list) {
 			return -ENOMEM;
 		}
 		for (n = 2; n < 3 + s->n_chan; n++) {
 			if (it->options[n] < 0 || it->options[n] > 1) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
-					"bad options[%u]=%d\n",
-					dev->minor, DRIVER_NAME, n,
-					it->options[n]);
+				       "bad options[%u]=%d\n",
+				       dev->minor, DRIVER_NAME, n,
+				       it->options[n]);
 			}
 		}
 		for (n = 0; n < s->n_chan; n++) {
 			if (n < COMEDI_NDEVCONFOPTS - 3 &&
-				it->options[3 + n] == 1) {
+			    it->options[3 + n] == 1) {
 				if (it->options[2] == 1) {
 					range_table_list[n] = &range_pci234_ext;
 				} else {
@@ -1451,7 +1466,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			} else {
 				if (it->options[2] == 1) {
 					range_table_list[n] =
-						&range_pci234_ext2;
+					    &range_pci234_ext2;
 				} else {
 					range_table_list[n] = &range_bipolar10;
 				}
@@ -1466,9 +1481,8 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		} else {
 			if (it->options[2] != 0) {
 				printk(KERN_WARNING "comedi%d: %s: warning! "
-					"bad options[2]=%d\n",
-					dev->minor, DRIVER_NAME,
-					it->options[2]);
+				       "bad options[2]=%d\n",
+				       dev->minor, DRIVER_NAME, it->options[2]);
 			}
 			s->range_table = &range_pci224_internal;
 			devpriv->hwrange = hwrange_pci224_internal;
@@ -1482,7 +1496,7 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				  DRIVER_NAME, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "comedi%d: error! "
-				"unable to allocate irq %u\n", dev->minor, irq);
+			       "unable to allocate irq %u\n", dev->minor, irq);
 			return ret;
 		} else {
 			dev->irq = irq;
@@ -1545,7 +1559,7 @@ static int pci224_detach(struct comedi_device *dev)
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 
 	return 0;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 6b53cb4b93f9..d1a64e80cddb 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -542,7 +542,7 @@ static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 		return;
 	}
 
-	comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	/* Kill the interrupts. */
 	devpriv->intsce = 0;
 	outb(0, devpriv->iobase1 + PCI224_INT_SCE);
@@ -558,10 +558,10 @@ static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s
 	 * routine.
 	 */
 	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 	}
-	comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+	spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	/* Reconfigure DAC for insn_write usage. */
 	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
 	devpriv->daccon = COMBINE(devpriv->daccon,
@@ -587,14 +587,14 @@ static void pci224_ao_start(struct comedi_device *dev, struct comedi_subdevice *
 		comedi_event(dev, s);
 	} else {
 		/* Enable interrupts. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (cmd->stop_src == TRIG_EXT) {
 			devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
 		} else {
 			devpriv->intsce = PCI224_INTR_DAC;
 		}
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	}
 }
 
@@ -655,7 +655,7 @@ static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subde
 			/* Nothing left to put in the FIFO. */
 			pci224_ao_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
-			rt_printk(KERN_ERR "comedi%d: "
+			printk(KERN_ERR "comedi%d: "
 				"AO buffer underrun\n", dev->minor);
 		}
 	}
@@ -1155,16 +1155,16 @@ static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	switch (cmd->start_src) {
 	case TRIG_INT:
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		s->async->inttrig = &pci224_ao_inttrig_start;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		break;
 	case TRIG_EXT:
 		/* Enable external interrupt trigger to start acquisition. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		devpriv->intsce |= PCI224_INTR_EXT;
 		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		break;
 	}
 
@@ -1227,14 +1227,14 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 	intstat = inb(devpriv->iobase1 + PCI224_INT_SCE) & 0x3F;
 	if (intstat) {
 		retval = 1;
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		valid_intstat = devpriv->intsce & intstat;
 		/* Temporarily disable interrupt sources. */
 		curenab = devpriv->intsce & ~intstat;
 		outb(curenab, devpriv->iobase1 + PCI224_INT_SCE);
 		devpriv->intr_running = 1;
 		devpriv->intr_cpuid = THISCPU;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 		if (valid_intstat != 0) {
 			cmd = &s->async->cmd;
 			if (valid_intstat & PCI224_INTR_EXT) {
@@ -1250,13 +1250,13 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
 			}
 		}
 		/* Reenable interrupt sources. */
-		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		spin_lock_irqsave(&devpriv->ao_spinlock, flags);
 		if (curenab != devpriv->intsce) {
 			outb(devpriv->intsce,
 				devpriv->iobase1 + PCI224_INT_SCE);
 		}
 		devpriv->intr_running = 0;
-		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
 	}
 	return IRQ_RETVAL(retval);
 }
@@ -1478,8 +1478,8 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_name = thisboard->name;
 
 	if (irq) {
-		ret = comedi_request_irq(irq, pci224_interrupt, IRQF_SHARED,
-			DRIVER_NAME, dev);
+		ret = request_irq(irq, pci224_interrupt, IRQF_SHARED,
+				  DRIVER_NAME, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "comedi%d: error! "
 				"unable to allocate irq %u\n", dev->minor, irq);
@@ -1515,7 +1515,7 @@ static int pci224_detach(struct comedi_device *dev)
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->subdevices) {
 		struct comedi_subdevice *s;

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 19e4428c3380..6b53cb4b93f9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -437,7 +437,7 @@ static struct comedi_driver driver_amplc_pci224 = {
 	.detach = pci224_detach,
 	.board_name = &pci224_boards[0].name,
 	.offset = sizeof(struct pci224_board),
-	.num_names = sizeof(pci224_boards) / sizeof(struct pci224_board),
+	.num_names = ARRAY_SIZE(pci224_boards),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 7cc594b38070..19e4428c3380 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -358,23 +358,23 @@ struct pci224_board {
 
 static const struct pci224_board pci224_boards[] = {
 	{
-	      name:	"pci224",
-	      devid: PCI_DEVICE_ID_AMPLICON_PCI224,
-	      model:	pci224_model,
-	      ao_chans:16,
-	      ao_bits:	12,
+	.name = "pci224",
+	.devid = PCI_DEVICE_ID_AMPLICON_PCI224,
+	.model = pci224_model,
+	.ao_chans = 16,
+	.ao_bits = 12,
 		},
 	{
-	      name:	"pci234",
-	      devid: PCI_DEVICE_ID_AMPLICON_PCI234,
-	      model:	pci234_model,
-	      ao_chans:4,
-	      ao_bits:	16,
+	.name = "pci234",
+	.devid = PCI_DEVICE_ID_AMPLICON_PCI234,
+	.model = pci234_model,
+	.ao_chans = 4,
+	.ao_bits = 16,
 		},
 	{
-	      name:	DRIVER_NAME,
-	      devid: PCI_DEVICE_ID_INVALID,
-	      model:	any_model,	/* wildcard */
+	.name = DRIVER_NAME,
+	.devid = PCI_DEVICE_ID_INVALID,
+	.model = any_model,	/* wildcard */
 		},
 };
 
@@ -431,13 +431,13 @@ struct pci224_private {
 static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int pci224_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci224 = {
-      driver_name:DRIVER_NAME,
-      module:THIS_MODULE,
-      attach:pci224_attach,
-      detach:pci224_detach,
-      board_name:&pci224_boards[0].name,
-      offset:sizeof(struct pci224_board),
-      num_names:sizeof(pci224_boards) / sizeof(struct pci224_board),
+	.driver_name = DRIVER_NAME,
+	.module = THIS_MODULE,
+	.attach = pci224_attach,
+	.detach = pci224_detach,
+	.board_name = &pci224_boards[0].name,
+	.offset = sizeof(struct pci224_board),
+	.num_names = sizeof(pci224_boards) / sizeof(struct pci224_board),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 9037ff4bf0e6..7cc594b38070 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1338,16 +1338,20 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	bus = it->options[0];
 	slot = it->options[1];
-	if ((ret = alloc_private(dev, sizeof(struct pci224_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci224_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
 	}
-	if ((ret = pci224_find_pci(dev, bus, slot, &pci_dev)) < 0)
+
+	ret = pci224_find_pci(dev, bus, slot, &pci_dev);
+	if (ret < 0)
 		return ret;
-	devpriv->pci_dev = pci_dev;
 
-	if ((ret = comedi_pci_enable(pci_dev, DRIVER_NAME)) < 0) {
+	devpriv->pci_dev = pci_dev;
+	ret = comedi_pci_enable(pci_dev, DRIVER_NAME);
+	if (ret < 0) {
 		printk(KERN_ERR
 			"comedi%d: error! cannot enable PCI device "
 			"and request regions!\n", dev->minor);
@@ -1394,7 +1398,8 @@ static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		dev->iobase + PCI224_DACCON);
 
 	/* Allocate subdevices.  There is only one!  */
-	if ((ret = alloc_subdevices(dev, 1)) < 0) {
+	ret = alloc_subdevices(dev, 1);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 70381b5c015b..9037ff4bf0e6 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -428,8 +428,8 @@ struct pci224_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pci224_detach(struct comedi_device * dev);
+static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci224_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_pci224 = {
       driver_name:DRIVER_NAME,
       module:THIS_MODULE,
@@ -446,7 +446,7 @@ COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
  * Called from the 'insn_write' function to perform a single write.
  */
 static void
-pci224_ao_set_data(struct comedi_device * dev, int chan, int range, unsigned int data)
+pci224_ao_set_data(struct comedi_device *dev, int chan, int range, unsigned int data)
 {
 	unsigned short mangled;
 
@@ -479,8 +479,8 @@ pci224_ao_set_data(struct comedi_device * dev, int chan, int range, unsigned int
  * 'insn_write' function for AO subdevice.
  */
 static int
-pci224_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+pci224_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan, range;
@@ -506,8 +506,8 @@ pci224_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
  * command.
  */
 static int
-pci224_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+pci224_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan;
@@ -534,7 +534,7 @@ pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
 /*
  * Kills a command running on the AO subdevice.
  */
-static void pci224_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci224_ao_stop(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -574,7 +574,7 @@ static void pci224_ao_stop(struct comedi_device * dev, struct comedi_subdevice *
 /*
  * Handles start of acquisition for the AO subdevice.
  */
-static void pci224_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci224_ao_start(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -601,7 +601,7 @@ static void pci224_ao_start(struct comedi_device * dev, struct comedi_subdevice
 /*
  * Handles interrupts from the DAC FIFO.
  */
-static void pci224_ao_handle_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
+static void pci224_ao_handle_fifo(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
@@ -730,7 +730,7 @@ static void pci224_ao_handle_fifo(struct comedi_device * dev, struct comedi_subd
  * Internal trigger function to start acquisition on AO subdevice.
  */
 static int
-pci224_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
+pci224_ao_inttrig_start(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -750,7 +750,7 @@ pci224_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
+pci224_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1017,7 +1017,7 @@ pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struc
 /*
  * 'do_cmd' function for AO subdevice.
  */
-static int pci224_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci224_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -1174,7 +1174,7 @@ static int pci224_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 /*
  * 'cancel' function for AO subdevice.
  */
-static int pci224_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci224_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	pci224_ao_stop(dev, s);
 	return 0;
@@ -1184,7 +1184,7 @@ static int pci224_ao_cancel(struct comedi_device * dev, struct comedi_subdevice
  * 'munge' data for AO command.
  */
 static void
-pci224_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s, void *data,
+pci224_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s, void *data,
 	unsigned int num_bytes, unsigned int chan_index)
 {
 	struct comedi_async *async = s->async;
@@ -1266,7 +1266,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d)
  * bus and slot.
  */
 static int
-pci224_find_pci(struct comedi_device * dev, int bus, int slot,
+pci224_find_pci(struct comedi_device *dev, int bus, int slot,
 	struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
@@ -1325,7 +1325,7 @@ pci224_find_pci(struct comedi_device * dev, int bus, int slot,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pci224_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pci_dev;
@@ -1505,7 +1505,7 @@ static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pci224_detach(struct comedi_device * dev)
+static int pci224_detach(struct comedi_device *dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 770b96648932..70381b5c015b 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -103,6 +103,8 @@ Passing a zero for an option is the same as leaving it unspecified.
      correctly.
 */
 
+#include <linux/interrupt.h>
+
 #include "../comedidev.h"
 
 #include "comedi_pci.h"
@@ -1212,7 +1214,7 @@ pci224_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s, void *d
 /*
  * Interrupt handler.
  */
-static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t pci224_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = &dev->subdevices[0];

commit a27872bf7b3fc4ac7ddb561662cf7eb06e8b3895
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:10:17 2009 -0400

    Staging: comedi: Remove pci224_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 74c5a2a9485f..770b96648932 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -398,7 +398,7 @@ MODULE_DEVICE_TABLE(pci, pci224_pci_table);
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct pci224_private {
 	struct pci_dev *pci_dev;	/* PCI device */
 	const unsigned short *hwrange;
 	unsigned long iobase1;
@@ -416,9 +416,9 @@ typedef struct {
 	short ao_stop_continuous;
 	unsigned short ao_enab;	/* max 16 channels so 'short' will do */
 	unsigned char intsce;
-} pci224_private;
+};
 
-#define devpriv ((pci224_private *)dev->private)
+#define devpriv ((struct pci224_private *)dev->private)
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -1336,7 +1336,7 @@ static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * i
 
 	bus = it->options[0];
 	slot = it->options[1];
-	if ((ret = alloc_private(dev, sizeof(pci224_private))) < 0) {
+	if ((ret = alloc_private(dev, sizeof(struct pci224_private))) < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;

commit 5a676a21f496b68506d6ebc94bc137b7acecdbd3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:10:12 2009 -0400

    Staging: comedi: Remove pci224_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index f0beaa69256e..74c5a2a9485f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -346,15 +346,15 @@ static const unsigned short hwrange_pci234[1] = {
 
 enum pci224_model { any_model, pci224_model, pci234_model };
 
-typedef struct pci224_board_struct {
+struct pci224_board {
 	const char *name;
 	unsigned short devid;
 	enum pci224_model model;
 	unsigned int ao_chans;
 	unsigned int ao_bits;
-} pci224_board;
+};
 
-static const pci224_board pci224_boards[] = {
+static const struct pci224_board pci224_boards[] = {
 	{
 	      name:	"pci224",
 	      devid: PCI_DEVICE_ID_AMPLICON_PCI224,
@@ -393,7 +393,7 @@ MODULE_DEVICE_TABLE(pci, pci224_pci_table);
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((pci224_board *)dev->board_ptr)
+#define thisboard ((struct pci224_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -434,8 +434,8 @@ static struct comedi_driver driver_amplc_pci224 = {
       attach:pci224_attach,
       detach:pci224_detach,
       board_name:&pci224_boards[0].name,
-      offset:sizeof(pci224_board),
-      num_names:sizeof(pci224_boards) / sizeof(pci224_board),
+      offset:sizeof(struct pci224_board),
+      num_names:sizeof(pci224_boards) / sizeof(struct pci224_board),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index ec60574786a9..f0beaa69256e 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -426,7 +426,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pci224_detach(struct comedi_device * dev);
 static struct comedi_driver driver_amplc_pci224 = {
       driver_name:DRIVER_NAME,
@@ -1323,7 +1323,7 @@ pci224_find_pci(struct comedi_device * dev, int bus, int slot,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pci224_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pci_dev;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 639bd2f588c5..ec60574786a9 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -478,7 +478,7 @@ pci224_ao_set_data(struct comedi_device * dev, int chan, int range, unsigned int
  */
 static int
 pci224_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan, range;
@@ -505,7 +505,7 @@ pci224_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
  */
 static int
 pci224_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 7ef57bf309cb..639bd2f588c5 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -574,7 +574,7 @@ static void pci224_ao_stop(struct comedi_device * dev, struct comedi_subdevice *
  */
 static void pci224_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 
 	set_bit(AO_CMD_STARTED, &devpriv->state);
@@ -601,7 +601,7 @@ static void pci224_ao_start(struct comedi_device * dev, struct comedi_subdevice
  */
 static void pci224_ao_handle_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
 	unsigned int room;
 	unsigned short dacstat;
@@ -748,7 +748,7 @@ pci224_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
+pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1017,7 +1017,7 @@ pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comed
  */
 static int pci224_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
 	unsigned int i, j;
 	unsigned int ch;
@@ -1216,7 +1216,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = &dev->subdevices[0];
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	unsigned char intstat, valid_intstat;
 	unsigned char curenab;
 	int retval = 0;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 4ca283bb58ae..7ef57bf309cb 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -278,7 +278,7 @@ Passing a zero for an option is the same as leaving it unspecified.
  */
 
 /* The software selectable internal ranges for PCI224 (option[2] == 0). */
-static const comedi_lrange range_pci224_internal = {
+static const struct comedi_lrange range_pci224_internal = {
 	8,
 	{
 			BIP_RANGE(10),
@@ -304,7 +304,7 @@ static const unsigned short hwrange_pci224_internal[8] = {
 };
 
 /* The software selectable external ranges for PCI224 (option[2] == 1). */
-static const comedi_lrange range_pci224_external = {
+static const struct comedi_lrange range_pci224_external = {
 	2,
 	{
 			RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
@@ -319,7 +319,7 @@ static const unsigned short hwrange_pci224_external[2] = {
 
 /* The hardware selectable Vref*2 external range for PCI234
  * (option[2] == 1, option[3+n] == 0). */
-static const comedi_lrange range_pci234_ext2 = {
+static const struct comedi_lrange range_pci234_ext2 = {
 	1,
 	{
 			RANGE_ext(-2, 2),
@@ -328,7 +328,7 @@ static const comedi_lrange range_pci234_ext2 = {
 
 /* The hardware selectable Vref external range for PCI234
  * (option[2] == 1, option[3+n] == 1). */
-static const comedi_lrange range_pci234_ext = {
+static const struct comedi_lrange range_pci234_ext = {
 	1,
 	{
 			RANGE_ext(-1, 1),
@@ -1417,10 +1417,10 @@ static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it)
 	/* Sort out channel range options. */
 	if (thisboard->model == pci234_model) {
 		/* PCI234 range options. */
-		const comedi_lrange **range_table_list;
+		const struct comedi_lrange **range_table_list;
 
 		s->range_table_list = range_table_list =
-			kmalloc(sizeof(comedi_lrange *) * s->n_chan,
+			kmalloc(sizeof(struct comedi_lrange *) * s->n_chan,
 			GFP_KERNEL);
 		if (!s->range_table_list) {
 			return -ENOMEM;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index e575f7deb31d..4ca283bb58ae 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -421,14 +421,14 @@ typedef struct {
 #define devpriv ((pci224_private *)dev->private)
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int pci224_detach(struct comedi_device * dev);
-static comedi_driver driver_amplc_pci224 = {
+static struct comedi_driver driver_amplc_pci224 = {
       driver_name:DRIVER_NAME,
       module:THIS_MODULE,
       attach:pci224_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index 247b1eaaa17f..e575f7deb31d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -1185,7 +1185,7 @@ static void
 pci224_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s, void *data,
 	unsigned int num_bytes, unsigned int chan_index)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
 	unsigned int offset;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index afb110a868e2..247b1eaaa17f 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -477,7 +477,7 @@ pci224_ao_set_data(struct comedi_device * dev, int chan, int range, unsigned int
  * 'insn_write' function for AO subdevice.
  */
 static int
-pci224_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+pci224_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -504,7 +504,7 @@ pci224_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
  * command.
  */
 static int
-pci224_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+pci224_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -532,7 +532,7 @@ pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
 /*
  * Kills a command running on the AO subdevice.
  */
-static void pci224_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_stop(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -572,7 +572,7 @@ static void pci224_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
 /*
  * Handles start of acquisition for the AO subdevice.
  */
-static void pci224_ao_start(struct comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_start(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -599,7 +599,7 @@ static void pci224_ao_start(struct comedi_device * dev, comedi_subdevice * s)
 /*
  * Handles interrupts from the DAC FIFO.
  */
-static void pci224_ao_handle_fifo(struct comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_handle_fifo(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
@@ -728,7 +728,7 @@ static void pci224_ao_handle_fifo(struct comedi_device * dev, comedi_subdevice *
  * Internal trigger function to start acquisition on AO subdevice.
  */
 static int
-pci224_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
+pci224_ao_inttrig_start(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -748,7 +748,7 @@ pci224_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pci224_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1015,7 +1015,7 @@ pci224_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd *
 /*
  * 'do_cmd' function for AO subdevice.
  */
-static int pci224_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pci224_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -1172,7 +1172,7 @@ static int pci224_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 /*
  * 'cancel' function for AO subdevice.
  */
-static int pci224_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pci224_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	pci224_ao_stop(dev, s);
 	return 0;
@@ -1182,7 +1182,7 @@ static int pci224_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
  * 'munge' data for AO command.
  */
 static void
-pci224_ao_munge(struct comedi_device * dev, comedi_subdevice * s, void *data,
+pci224_ao_munge(struct comedi_device * dev, struct comedi_subdevice * s, void *data,
 	unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -1215,7 +1215,7 @@ pci224_ao_munge(struct comedi_device * dev, comedi_subdevice * s, void *data,
 static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	comedi_cmd *cmd;
 	unsigned char intstat, valid_intstat;
 	unsigned char curenab;
@@ -1325,7 +1325,7 @@ pci224_find_pci(struct comedi_device * dev, int bus, int slot,
  */
 static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	struct pci_dev *pci_dev;
 	unsigned int irq;
 	int bus = 0, slot = 0;
@@ -1511,7 +1511,7 @@ static int pci224_detach(struct comedi_device * dev)
 		comedi_free_irq(dev->irq, dev);
 	}
 	if (dev->subdevices) {
-		comedi_subdevice *s;
+		struct comedi_subdevice *s;
 
 		s = dev->subdevices + 0;
 		/* AO subdevice */

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b936ccf9bb4d..afb110a868e2 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -397,7 +397,7 @@ MODULE_DEVICE_TABLE(pci, pci224_pci_table);
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 	struct pci_dev *pci_dev;	/* PCI device */
 	const unsigned short *hwrange;
@@ -426,8 +426,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int pci224_attach(comedi_device * dev, comedi_devconfig * it);
-static int pci224_detach(comedi_device * dev);
+static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci224_detach(struct comedi_device * dev);
 static comedi_driver driver_amplc_pci224 = {
       driver_name:DRIVER_NAME,
       module:THIS_MODULE,
@@ -444,7 +444,7 @@ COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
  * Called from the 'insn_write' function to perform a single write.
  */
 static void
-pci224_ao_set_data(comedi_device * dev, int chan, int range, unsigned int data)
+pci224_ao_set_data(struct comedi_device * dev, int chan, int range, unsigned int data)
 {
 	unsigned short mangled;
 
@@ -477,7 +477,7 @@ pci224_ao_set_data(comedi_device * dev, int chan, int range, unsigned int data)
  * 'insn_write' function for AO subdevice.
  */
 static int
-pci224_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+pci224_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -504,7 +504,7 @@ pci224_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
  * command.
  */
 static int
-pci224_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+pci224_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -532,7 +532,7 @@ pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
 /*
  * Kills a command running on the AO subdevice.
  */
-static void pci224_ao_stop(comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_stop(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -572,7 +572,7 @@ static void pci224_ao_stop(comedi_device * dev, comedi_subdevice * s)
 /*
  * Handles start of acquisition for the AO subdevice.
  */
-static void pci224_ao_start(comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_start(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
@@ -599,7 +599,7 @@ static void pci224_ao_start(comedi_device * dev, comedi_subdevice * s)
 /*
  * Handles interrupts from the DAC FIFO.
  */
-static void pci224_ao_handle_fifo(comedi_device * dev, comedi_subdevice * s)
+static void pci224_ao_handle_fifo(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_scans;
@@ -728,7 +728,7 @@ static void pci224_ao_handle_fifo(comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition on AO subdevice.
  */
 static int
-pci224_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+pci224_ao_inttrig_start(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -748,7 +748,7 @@ pci224_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
  * 'do_cmdtest' function for AO subdevice.
  */
 static int
-pci224_ao_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+pci224_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -1015,7 +1015,7 @@ pci224_ao_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
 /*
  * 'do_cmd' function for AO subdevice.
  */
-static int pci224_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pci224_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int range;
@@ -1172,7 +1172,7 @@ static int pci224_ao_cmd(comedi_device * dev, comedi_subdevice * s)
 /*
  * 'cancel' function for AO subdevice.
  */
-static int pci224_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pci224_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	pci224_ao_stop(dev, s);
 	return 0;
@@ -1182,7 +1182,7 @@ static int pci224_ao_cancel(comedi_device * dev, comedi_subdevice * s)
  * 'munge' data for AO command.
  */
 static void
-pci224_ao_munge(comedi_device * dev, comedi_subdevice * s, void *data,
+pci224_ao_munge(struct comedi_device * dev, comedi_subdevice * s, void *data,
 	unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
@@ -1214,7 +1214,7 @@ pci224_ao_munge(comedi_device * dev, comedi_subdevice * s, void *data,
  */
 static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = &dev->subdevices[0];
 	comedi_cmd *cmd;
 	unsigned char intstat, valid_intstat;
@@ -1264,7 +1264,7 @@ static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
  * bus and slot.
  */
 static int
-pci224_find_pci(comedi_device * dev, int bus, int slot,
+pci224_find_pci(struct comedi_device * dev, int bus, int slot,
 	struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
@@ -1323,7 +1323,7 @@ pci224_find_pci(comedi_device * dev, int bus, int slot,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int pci224_attach(comedi_device * dev, comedi_devconfig * it)
+static int pci224_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	struct pci_dev *pci_dev;
@@ -1503,7 +1503,7 @@ static int pci224_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int pci224_detach(comedi_device * dev)
+static int pci224_detach(struct comedi_device * dev)
 {
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
index b821a0bb3b53..b936ccf9bb4d 100644
--- a/drivers/staging/comedi/drivers/amplc_pci224.c
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -404,8 +404,8 @@ typedef struct {
 	unsigned long iobase1;
 	unsigned long state;
 	spinlock_t ao_spinlock;
-	lsampl_t *ao_readback;
-	sampl_t *ao_scan_vals;
+	unsigned int *ao_readback;
+	short *ao_scan_vals;
 	unsigned char *ao_scan_order;
 	int intr_cpuid;
 	short intr_running;
@@ -444,7 +444,7 @@ COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
  * Called from the 'insn_write' function to perform a single write.
  */
 static void
-pci224_ao_set_data(comedi_device * dev, int chan, int range, lsampl_t data)
+pci224_ao_set_data(comedi_device * dev, int chan, int range, unsigned int data)
 {
 	unsigned short mangled;
 
@@ -478,7 +478,7 @@ pci224_ao_set_data(comedi_device * dev, int chan, int range, lsampl_t data)
  */
 static int
 pci224_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan, range;
@@ -505,7 +505,7 @@ pci224_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
  */
 static int
 pci224_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan;
@@ -609,10 +609,10 @@ static void pci224_ao_handle_fifo(comedi_device * dev, comedi_subdevice * s)
 	unsigned int bytes_per_scan;
 
 	if (cmd->chanlist_len) {
-		bytes_per_scan = cmd->chanlist_len * sizeof(sampl_t);
+		bytes_per_scan = cmd->chanlist_len * sizeof(short);
 	} else {
 		/* Shouldn't get here! */
-		bytes_per_scan = sizeof(sampl_t);
+		bytes_per_scan = sizeof(short);
 	}
 	/* Determine number of scans available in buffer. */
 	num_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;
@@ -1186,7 +1186,7 @@ pci224_ao_munge(comedi_device * dev, comedi_subdevice * s, void *data,
 	unsigned int num_bytes, unsigned int chan_index)
 {
 	comedi_async *async = s->async;
-	sampl_t *array = data;
+	short *array = data;
 	unsigned int length = num_bytes / sizeof(*array);
 	unsigned int offset;
 	unsigned int shift;

commit ea1aeae44eb43cd9a42e01bbc4daa36679c1359f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Feb 18 15:25:54 2009 -0800

    Staging: comedi: add amplc_pci224 driver
    
    Driver for Amplicon PCI224 and PCI234 AO boards
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_pci224.c b/drivers/staging/comedi/drivers/amplc_pci224.c
new file mode 100644
index 000000000000..b821a0bb3b53
--- /dev/null
+++ b/drivers/staging/comedi/drivers/amplc_pci224.c
@@ -0,0 +1,1545 @@
+/*
+    comedi/drivers/amplc_pci224.c
+    Driver for Amplicon PCI224 and PCI234 AO boards.
+
+    Copyright (C) 2005 MEV Ltd. <http://www.mev.co.uk/>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: amplc_pci224
+Description: Amplicon PCI224, PCI234
+Author: Ian Abbott <abbotti@mev.co.uk>
+Devices: [Amplicon] PCI224 (amplc_pci224 or pci224),
+  PCI234 (amplc_pci224 or pci234)
+Updated: Wed, 22 Oct 2008 12:25:08 +0100
+Status: works, but see caveats
+
+Supports:
+
+  - ao_insn read/write
+  - ao_do_cmd mode with the following sources:
+
+    - start_src         TRIG_INT        TRIG_EXT
+    - scan_begin_src    TRIG_TIMER      TRIG_EXT
+    - convert_src       TRIG_NOW
+    - scan_end_src      TRIG_COUNT
+    - stop_src          TRIG_COUNT      TRIG_EXT        TRIG_NONE
+
+    The channel list must contain at least one channel with no repeated
+    channels.  The scan end count must equal the number of channels in
+    the channel list.
+
+    There is only one external trigger source so only one of start_src,
+    scan_begin_src or stop_src may use TRIG_EXT.
+
+Configuration options - PCI224:
+  [0] - PCI bus of device (optional).
+  [1] - PCI slot of device (optional).
+          If bus/slot is not specified, the first available PCI device
+          will be used.
+  [2] - Select available ranges according to jumper LK1.  All channels
+        are set to the same range:
+        0=Jumper position 1-2 (factory default), 4 software-selectable
+          internal voltage references, giving 4 bipolar and 4 unipolar
+          ranges:
+            [-10V,+10V], [-5V,+5V], [-2.5V,+2.5V], [-1.25V,+1.25V],
+            [0,+10V], [0,+5V], [0,+2.5V], [0,1.25V].
+        1=Jumper position 2-3, 1 external voltage reference, giving
+          1 bipolar and 1 unipolar range:
+            [-Vext,+Vext], [0,+Vext].
+
+Configuration options - PCI234:
+  [0] - PCI bus of device (optional).
+  [1] - PCI slot of device (optional).
+          If bus/slot is not specified, the first available PCI device
+          will be used.
+  [2] - Select internal or external voltage reference according to
+        jumper LK1.  This affects all channels:
+        0=Jumper position 1-2 (factory default), Vref=5V internal.
+        1=Jumper position 2-3, Vref=Vext external.
+  [3] - Select channel 0 range according to jumper LK2:
+        0=Jumper position 2-3 (factory default), range [-2*Vref,+2*Vref]
+          (10V bipolar when options[2]=0).
+        1=Jumper position 1-2, range [-Vref,+Vref]
+          (5V bipolar when options[2]=0).
+  [4] - Select channel 1 range according to jumper LK3: cf. options[3].
+  [5] - Select channel 2 range according to jumper LK4: cf. options[3].
+  [6] - Select channel 3 range according to jumper LK5: cf. options[3].
+
+Passing a zero for an option is the same as leaving it unspecified.
+
+Caveats:
+
+  1) All channels on the PCI224 share the same range.  Any change to the
+     range as a result of insn_write or a streaming command will affect
+     the output voltages of all channels, including those not specified
+     by the instruction or command.
+
+  2) For the analog output command,  the first scan may be triggered
+     falsely at the start of acquisition.  This occurs when the DAC scan
+     trigger source is switched from 'none' to 'timer' (scan_begin_src =
+     TRIG_TIMER) or 'external' (scan_begin_src == TRIG_EXT) at the start
+     of acquisition and the trigger source is at logic level 1 at the
+     time of the switch.  This is very likely for TRIG_TIMER.  For
+     TRIG_EXT, it depends on the state of the external line and whether
+     the CR_INVERT flag has been set.  The remaining scans are triggered
+     correctly.
+*/
+
+#include "../comedidev.h"
+
+#include "comedi_pci.h"
+
+#include "comedi_fc.h"
+#include "8253.h"
+
+#define DRIVER_NAME	"amplc_pci224"
+
+/*
+ * PCI IDs.
+ */
+/* #define PCI_VENDOR_ID_AMPLICON 0x14dc */
+#define PCI_DEVICE_ID_AMPLICON_PCI224 0x0007
+#define PCI_DEVICE_ID_AMPLICON_PCI234 0x0008
+#define PCI_DEVICE_ID_INVALID 0xffff
+
+/*
+ * PCI224/234 i/o space 1 (PCIBAR2) registers.
+ */
+#define PCI224_IO1_SIZE	0x20	/* Size of i/o space 1 (8-bit registers) */
+#define PCI224_Z2_CT0	0x14	/* 82C54 counter/timer 0 */
+#define PCI224_Z2_CT1	0x15	/* 82C54 counter/timer 1 */
+#define PCI224_Z2_CT2	0x16	/* 82C54 counter/timer 2 */
+#define PCI224_Z2_CTC	0x17	/* 82C54 counter/timer control word */
+#define PCI224_ZCLK_SCE	0x1A	/* Group Z Clock Configuration Register */
+#define PCI224_ZGAT_SCE	0x1D	/* Group Z Gate Configuration Register */
+#define PCI224_INT_SCE	0x1E	/* ISR Interrupt source mask register */
+				/* /Interrupt status */
+
+/*
+ * PCI224/234 i/o space 2 (PCIBAR3) 16-bit registers.
+ */
+#define PCI224_IO2_SIZE	0x10	/* Size of i/o space 2 (16-bit registers). */
+#define PCI224_DACDATA	0x00	/* (w-o) DAC FIFO data. */
+#define PCI224_SOFTTRIG	0x00	/* (r-o) DAC software scan trigger. */
+#define PCI224_DACCON	0x02	/* (r/w) DAC status/configuration. */
+#define PCI224_FIFOSIZ	0x04	/* (w-o) FIFO size for wraparound mode. */
+#define PCI224_DACCEN	0x06	/* (w-o) DAC channel enable register. */
+
+/*
+ * DACCON values.
+ */
+/* (r/w) Scan trigger. */
+#define PCI224_DACCON_TRIG_MASK		(7 << 0)
+#define PCI224_DACCON_TRIG_NONE		(0 << 0)	/* none */
+#define PCI224_DACCON_TRIG_SW		(1 << 0)	/* software trig */
+#define PCI224_DACCON_TRIG_EXTP		(2 << 0)	/* ext +ve edge */
+#define PCI224_DACCON_TRIG_EXTN		(3 << 0)	/* ext -ve edge */
+#define PCI224_DACCON_TRIG_Z2CT0	(4 << 0)	/* Z2 CT0 out */
+#define PCI224_DACCON_TRIG_Z2CT1	(5 << 0)	/* Z2 CT1 out */
+#define PCI224_DACCON_TRIG_Z2CT2	(6 << 0)	/* Z2 CT2 out */
+/* (r/w) Polarity (PCI224 only, PCI234 always bipolar!). */
+#define PCI224_DACCON_POLAR_MASK	(1 << 3)
+#define PCI224_DACCON_POLAR_UNI		(0 << 3)	/* range [0,Vref] */
+#define PCI224_DACCON_POLAR_BI		(1 << 3)	/* range [-Vref,Vref] */
+/* (r/w) Internal Vref (PCI224 only, when LK1 in position 1-2). */
+#define PCI224_DACCON_VREF_MASK		(3 << 4)
+#define PCI224_DACCON_VREF_1_25		(0 << 4)	/* Vref = 1.25V */
+#define PCI224_DACCON_VREF_2_5		(1 << 4)	/* Vref = 2.5V */
+#define PCI224_DACCON_VREF_5		(2 << 4)	/* Vref = 5V */
+#define PCI224_DACCON_VREF_10		(3 << 4)	/* Vref = 10V */
+/* (r/w) Wraparound mode enable (to play back stored waveform). */
+#define PCI224_DACCON_FIFOWRAP		(1 << 7)
+/* (r/w) FIFO enable.  It MUST be set! */
+#define PCI224_DACCON_FIFOENAB		(1 << 8)
+/* (r/w) FIFO interrupt trigger level (most values are not very useful). */
+#define PCI224_DACCON_FIFOINTR_MASK	(7 << 9)
+#define PCI224_DACCON_FIFOINTR_EMPTY	(0 << 9)	/* when empty */
+#define PCI224_DACCON_FIFOINTR_NEMPTY	(1 << 9)	/* when not empty */
+#define PCI224_DACCON_FIFOINTR_NHALF	(2 << 9)	/* when not half full */
+#define PCI224_DACCON_FIFOINTR_HALF	(3 << 9)	/* when half full */
+#define PCI224_DACCON_FIFOINTR_NFULL	(4 << 9)	/* when not full */
+#define PCI224_DACCON_FIFOINTR_FULL	(5 << 9)	/* when full */
+/* (r-o) FIFO fill level. */
+#define PCI224_DACCON_FIFOFL_MASK	(7 << 12)
+#define PCI224_DACCON_FIFOFL_EMPTY	(1 << 12)	/* 0 */
+#define PCI224_DACCON_FIFOFL_ONETOHALF	(0 << 12)	/* [1,2048] */
+#define PCI224_DACCON_FIFOFL_HALFTOFULL	(4 << 12)	/* [2049,4095] */
+#define PCI224_DACCON_FIFOFL_FULL	(6 << 12)	/* 4096 */
+/* (r-o) DAC busy flag. */
+#define PCI224_DACCON_BUSY		(1 << 15)
+/* (w-o) FIFO reset. */
+#define PCI224_DACCON_FIFORESET		(1 << 12)
+/* (w-o) Global reset (not sure what it does). */
+#define PCI224_DACCON_GLOBALRESET	(1 << 13)
+
+/*
+ * DAC FIFO size.
+ */
+#define PCI224_FIFO_SIZE	4096
+
+/*
+ * DAC FIFO guaranteed minimum room available, depending on reported fill level.
+ * The maximum room available depends on the reported fill level and how much
+ * has been written!
+ */
+#define PCI224_FIFO_ROOM_EMPTY		PCI224_FIFO_SIZE
+#define PCI224_FIFO_ROOM_ONETOHALF	(PCI224_FIFO_SIZE / 2)
+#define PCI224_FIFO_ROOM_HALFTOFULL	1
+#define PCI224_FIFO_ROOM_FULL		0
+
+/*
+ * Counter/timer clock input configuration sources.
+ */
+#define CLK_CLK		0	/* reserved (channel-specific clock) */
+#define CLK_10MHZ	1	/* internal 10 MHz clock */
+#define CLK_1MHZ	2	/* internal 1 MHz clock */
+#define CLK_100KHZ	3	/* internal 100 kHz clock */
+#define CLK_10KHZ	4	/* internal 10 kHz clock */
+#define CLK_1KHZ	5	/* internal 1 kHz clock */
+#define CLK_OUTNM1	6	/* output of channel-1 modulo total */
+#define CLK_EXT		7	/* external clock */
+/* Macro to construct clock input configuration register value. */
+#define CLK_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+/* Timebases in ns. */
+#define TIMEBASE_10MHZ		100
+#define TIMEBASE_1MHZ		1000
+#define TIMEBASE_100KHZ		10000
+#define TIMEBASE_10KHZ		100000
+#define TIMEBASE_1KHZ		1000000
+
+/*
+ * Counter/timer gate input configuration sources.
+ */
+#define GAT_VCC		0	/* VCC (i.e. enabled) */
+#define GAT_GND		1	/* GND (i.e. disabled) */
+#define GAT_EXT		2	/* reserved (external gate input) */
+#define GAT_NOUTNM2	3	/* inverted output of channel-2 modulo total */
+/* Macro to construct gate input configuration register value. */
+#define GAT_CONFIG(chan, src)	((((chan) & 3) << 3) | ((src) & 7))
+
+/*
+ * Summary of CLK_OUTNM1 and GAT_NOUTNM2 connections for PCI224 and PCI234:
+ *
+ *              Channel's       Channel's
+ *              clock input     gate input
+ * Channel      CLK_OUTNM1      GAT_NOUTNM2
+ * -------      ----------      -----------
+ * Z2-CT0       Z2-CT2-OUT      /Z2-CT1-OUT
+ * Z2-CT1       Z2-CT0-OUT      /Z2-CT2-OUT
+ * Z2-CT2       Z2-CT1-OUT      /Z2-CT0-OUT
+ */
+
+/*
+ * Interrupt enable/status bits
+ */
+#define PCI224_INTR_EXT		0x01	/* rising edge on external input */
+#define PCI224_INTR_DAC		0x04	/* DAC (FIFO) interrupt */
+#define PCI224_INTR_Z2CT1	0x20	/* rising edge on Z2-CT1 output */
+
+#define PCI224_INTR_EDGE_BITS	(PCI224_INTR_EXT | PCI224_INTR_Z2CT1)
+#define PCI224_INTR_LEVEL_BITS	PCI224_INTR_DACFIFO
+
+/*
+ * Handy macros.
+ */
+
+/* Combine old and new bits. */
+#define COMBINE(old, new, mask)	(((old) & ~(mask)) | ((new) & (mask)))
+
+/* A generic null function pointer value.  */
+#define NULLFUNC	0
+
+/* Current CPU.  XXX should this be hard_smp_processor_id()? */
+#define THISCPU		smp_processor_id()
+
+/* State bits for use with atomic bit operations. */
+#define AO_CMD_STARTED	0
+
+/*
+ * Range tables.
+ */
+
+/* The software selectable internal ranges for PCI224 (option[2] == 0). */
+static const comedi_lrange range_pci224_internal = {
+	8,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+		}
+};
+
+static const unsigned short hwrange_pci224_internal[8] = {
+	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_10,
+	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_5,
+	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_2_5,
+	PCI224_DACCON_POLAR_BI | PCI224_DACCON_VREF_1_25,
+	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_10,
+	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_5,
+	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_2_5,
+	PCI224_DACCON_POLAR_UNI | PCI224_DACCON_VREF_1_25,
+};
+
+/* The software selectable external ranges for PCI224 (option[2] == 1). */
+static const comedi_lrange range_pci224_external = {
+	2,
+	{
+			RANGE_ext(-1, 1),	/* bipolar [-Vref,+Vref] */
+			RANGE_ext(0, 1),	/* unipolar [0,+Vref] */
+		}
+};
+
+static const unsigned short hwrange_pci224_external[2] = {
+	PCI224_DACCON_POLAR_BI,
+	PCI224_DACCON_POLAR_UNI,
+};
+
+/* The hardware selectable Vref*2 external range for PCI234
+ * (option[2] == 1, option[3+n] == 0). */
+static const comedi_lrange range_pci234_ext2 = {
+	1,
+	{
+			RANGE_ext(-2, 2),
+		}
+};
+
+/* The hardware selectable Vref external range for PCI234
+ * (option[2] == 1, option[3+n] == 1). */
+static const comedi_lrange range_pci234_ext = {
+	1,
+	{
+			RANGE_ext(-1, 1),
+		}
+};
+
+/* This serves for all the PCI234 ranges. */
+static const unsigned short hwrange_pci234[1] = {
+	PCI224_DACCON_POLAR_BI,	/* bipolar - hardware ignores it! */
+};
+
+/*
+ * Board descriptions.
+ */
+
+enum pci224_model { any_model, pci224_model, pci234_model };
+
+typedef struct pci224_board_struct {
+	const char *name;
+	unsigned short devid;
+	enum pci224_model model;
+	unsigned int ao_chans;
+	unsigned int ao_bits;
+} pci224_board;
+
+static const pci224_board pci224_boards[] = {
+	{
+	      name:	"pci224",
+	      devid: PCI_DEVICE_ID_AMPLICON_PCI224,
+	      model:	pci224_model,
+	      ao_chans:16,
+	      ao_bits:	12,
+		},
+	{
+	      name:	"pci234",
+	      devid: PCI_DEVICE_ID_AMPLICON_PCI234,
+	      model:	pci234_model,
+	      ao_chans:4,
+	      ao_bits:	16,
+		},
+	{
+	      name:	DRIVER_NAME,
+	      devid: PCI_DEVICE_ID_INVALID,
+	      model:	any_model,	/* wildcard */
+		},
+};
+
+/*
+ * PCI driver table.
+ */
+
+static DEFINE_PCI_DEVICE_TABLE(pci224_pci_table) = {
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI224,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI234,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, pci224_pci_table);
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((pci224_board *)dev->board_ptr)
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+	struct pci_dev *pci_dev;	/* PCI device */
+	const unsigned short *hwrange;
+	unsigned long iobase1;
+	unsigned long state;
+	spinlock_t ao_spinlock;
+	lsampl_t *ao_readback;
+	sampl_t *ao_scan_vals;
+	unsigned char *ao_scan_order;
+	int intr_cpuid;
+	short intr_running;
+	unsigned short daccon;
+	unsigned int cached_div1;
+	unsigned int cached_div2;
+	unsigned int ao_stop_count;
+	short ao_stop_continuous;
+	unsigned short ao_enab;	/* max 16 channels so 'short' will do */
+	unsigned char intsce;
+} pci224_private;
+
+#define devpriv ((pci224_private *)dev->private)
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int pci224_attach(comedi_device * dev, comedi_devconfig * it);
+static int pci224_detach(comedi_device * dev);
+static comedi_driver driver_amplc_pci224 = {
+      driver_name:DRIVER_NAME,
+      module:THIS_MODULE,
+      attach:pci224_attach,
+      detach:pci224_detach,
+      board_name:&pci224_boards[0].name,
+      offset:sizeof(pci224_board),
+      num_names:sizeof(pci224_boards) / sizeof(pci224_board),
+};
+
+COMEDI_PCI_INITCLEANUP(driver_amplc_pci224, pci224_pci_table);
+
+/*
+ * Called from the 'insn_write' function to perform a single write.
+ */
+static void
+pci224_ao_set_data(comedi_device * dev, int chan, int range, lsampl_t data)
+{
+	unsigned short mangled;
+
+	/* Store unmangled data for readback. */
+	devpriv->ao_readback[chan] = data;
+	/* Enable the channel. */
+	outw(1 << chan, dev->iobase + PCI224_DACCEN);
+	/* Set range and reset FIFO. */
+	devpriv->daccon = COMBINE(devpriv->daccon, devpriv->hwrange[range],
+		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK));
+	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
+		dev->iobase + PCI224_DACCON);
+	/*
+	 * Mangle the data.  The hardware expects:
+	 * - bipolar: 16-bit 2's complement
+	 * - unipolar: 16-bit unsigned
+	 */
+	mangled = (unsigned short)data << (16 - thisboard->ao_bits);
+	if ((devpriv->daccon & PCI224_DACCON_POLAR_MASK) ==
+		PCI224_DACCON_POLAR_BI) {
+		mangled ^= 0x8000;
+	}
+	/* Write mangled data to the FIFO. */
+	outw(mangled, dev->iobase + PCI224_DACDATA);
+	/* Trigger the conversion. */
+	inw(dev->iobase + PCI224_SOFTTRIG);
+}
+
+/*
+ * 'insn_write' function for AO subdevice.
+ */
+static int
+pci224_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan, range;
+
+	/* Unpack channel and range. */
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+
+	/* Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined. */
+	for (i = 0; i < insn->n; i++) {
+		pci224_ao_set_data(dev, chan, range, data[i]);
+	}
+	return i;
+}
+
+/*
+ * 'insn_read' function for AO subdevice.
+ *
+ * N.B. The value read will not be valid if the DAC channel has
+ * never been written successfully since the device was attached
+ * or since the channel has been used by an AO streaming write
+ * command.
+ */
+static int
+pci224_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	for (i = 0; i < insn->n; i++) {
+		data[i] = devpriv->ao_readback[chan];
+	}
+
+	return i;
+}
+
+/*
+ * Just a wrapper for the inline function 'i8253_cascade_ns_to_timer'.
+ */
+static void
+pci224_cascade_ns_to_timer(int osc_base, unsigned int *d1, unsigned int *d2,
+	unsigned int *nanosec, int round_mode)
+{
+	i8253_cascade_ns_to_timer(osc_base, d1, d2, nanosec, round_mode);
+}
+
+/*
+ * Kills a command running on the AO subdevice.
+ */
+static void pci224_ao_stop(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	if (!test_and_clear_bit(AO_CMD_STARTED, &devpriv->state)) {
+		return;
+	}
+
+	comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	/* Kill the interrupts. */
+	devpriv->intsce = 0;
+	outb(0, devpriv->iobase1 + PCI224_INT_SCE);
+	/*
+	 * Interrupt routine may or may not be running.  We may or may not
+	 * have been called from the interrupt routine (directly or
+	 * indirectly via a comedi_events() callback routine).  It's highly
+	 * unlikely that we've been called from some other interrupt routine
+	 * but who knows what strange things coders get up to!
+	 *
+	 * If the interrupt routine is currently running, wait for it to
+	 * finish, unless we appear to have been called via the interrupt
+	 * routine.
+	 */
+	while (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+	}
+	comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+	/* Reconfigure DAC for insn_write usage. */
+	outw(0, dev->iobase + PCI224_DACCEN);	/* Disable channels. */
+	devpriv->daccon = COMBINE(devpriv->daccon,
+		PCI224_DACCON_TRIG_SW | PCI224_DACCON_FIFOINTR_EMPTY,
+		PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK);
+	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
+		dev->iobase + PCI224_DACCON);
+}
+
+/*
+ * Handles start of acquisition for the AO subdevice.
+ */
+static void pci224_ao_start(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+
+	set_bit(AO_CMD_STARTED, &devpriv->state);
+	if (!devpriv->ao_stop_continuous && devpriv->ao_stop_count == 0) {
+		/* An empty acquisition! */
+		pci224_ao_stop(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
+		comedi_event(dev, s);
+	} else {
+		/* Enable interrupts. */
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		if (cmd->stop_src == TRIG_EXT) {
+			devpriv->intsce = PCI224_INTR_EXT | PCI224_INTR_DAC;
+		} else {
+			devpriv->intsce = PCI224_INTR_DAC;
+		}
+		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+	}
+}
+
+/*
+ * Handles interrupts from the DAC FIFO.
+ */
+static void pci224_ao_handle_fifo(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int num_scans;
+	unsigned int room;
+	unsigned short dacstat;
+	unsigned int i, n;
+	unsigned int bytes_per_scan;
+
+	if (cmd->chanlist_len) {
+		bytes_per_scan = cmd->chanlist_len * sizeof(sampl_t);
+	} else {
+		/* Shouldn't get here! */
+		bytes_per_scan = sizeof(sampl_t);
+	}
+	/* Determine number of scans available in buffer. */
+	num_scans = comedi_buf_read_n_available(s->async) / bytes_per_scan;
+	if (!devpriv->ao_stop_continuous) {
+		/* Fixed number of scans. */
+		if (num_scans > devpriv->ao_stop_count) {
+			num_scans = devpriv->ao_stop_count;
+		}
+	}
+
+	/* Determine how much room is in the FIFO (in samples). */
+	dacstat = inw(dev->iobase + PCI224_DACCON);
+	switch (dacstat & PCI224_DACCON_FIFOFL_MASK) {
+	case PCI224_DACCON_FIFOFL_EMPTY:
+		room = PCI224_FIFO_ROOM_EMPTY;
+		if (!devpriv->ao_stop_continuous
+			&& devpriv->ao_stop_count == 0) {
+			/* FIFO empty at end of counted acquisition. */
+			pci224_ao_stop(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(dev, s);
+			return;
+		}
+		break;
+	case PCI224_DACCON_FIFOFL_ONETOHALF:
+		room = PCI224_FIFO_ROOM_ONETOHALF;
+		break;
+	case PCI224_DACCON_FIFOFL_HALFTOFULL:
+		room = PCI224_FIFO_ROOM_HALFTOFULL;
+		break;
+	default:
+		room = PCI224_FIFO_ROOM_FULL;
+		break;
+	}
+	if (room >= PCI224_FIFO_ROOM_ONETOHALF) {
+		/* FIFO is less than half-full. */
+		if (num_scans == 0) {
+			/* Nothing left to put in the FIFO. */
+			pci224_ao_stop(dev, s);
+			s->async->events |= COMEDI_CB_OVERFLOW;
+			rt_printk(KERN_ERR "comedi%d: "
+				"AO buffer underrun\n", dev->minor);
+		}
+	}
+	/* Determine how many new scans can be put in the FIFO. */
+	if (cmd->chanlist_len) {
+		room /= cmd->chanlist_len;
+	}
+	/* Determine how many scans to process. */
+	if (num_scans > room) {
+		num_scans = room;
+	}
+	/* Process scans. */
+	for (n = 0; n < num_scans; n++) {
+		cfc_read_array_from_buffer(s, &devpriv->ao_scan_vals[0],
+			bytes_per_scan);
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			outw(devpriv->ao_scan_vals[devpriv->
+					ao_scan_order[i]],
+				dev->iobase + PCI224_DACDATA);
+		}
+	}
+	if (!devpriv->ao_stop_continuous) {
+		devpriv->ao_stop_count -= num_scans;
+		if (devpriv->ao_stop_count == 0) {
+			/*
+			 * Change FIFO interrupt trigger level to wait
+			 * until FIFO is empty.
+			 */
+			devpriv->daccon = COMBINE(devpriv->daccon,
+				PCI224_DACCON_FIFOINTR_EMPTY,
+				PCI224_DACCON_FIFOINTR_MASK);
+			outw(devpriv->daccon,
+				dev->iobase + PCI224_DACCON);
+		}
+	}
+	if ((devpriv->daccon & PCI224_DACCON_TRIG_MASK) ==
+		PCI224_DACCON_TRIG_NONE) {
+		unsigned short trig;
+
+		/*
+		 * This is the initial DAC FIFO interrupt at the
+		 * start of the acquisition.  The DAC's scan trigger
+		 * has been set to 'none' up until now.
+		 *
+		 * Now that data has been written to the FIFO, the
+		 * DAC's scan trigger source can be set to the
+		 * correct value.
+		 *
+		 * BUG: The first scan will be triggered immediately
+		 * if the scan trigger source is at logic level 1.
+		 */
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			trig = PCI224_DACCON_TRIG_Z2CT0;
+		} else {
+			/* cmd->scan_begin_src == TRIG_EXT */
+			if (cmd->scan_begin_arg & CR_INVERT) {
+				trig = PCI224_DACCON_TRIG_EXTN;
+			} else {
+				trig = PCI224_DACCON_TRIG_EXTP;
+			}
+		}
+		devpriv->daccon = COMBINE(devpriv->daccon, trig,
+			PCI224_DACCON_TRIG_MASK);
+		outw(devpriv->daccon, dev->iobase + PCI224_DACCON);
+	}
+	if (s->async->events) {
+		comedi_event(dev, s);
+	}
+}
+
+/*
+ * Internal trigger function to start acquisition on AO subdevice.
+ */
+static int
+pci224_ao_inttrig_start(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	if (trignum != 0)
+		return -EINVAL;
+
+	s->async->inttrig = NULLFUNC;
+	pci224_ao_start(dev, s);
+
+	return 1;
+}
+
+#define MAX_SCAN_PERIOD		0xFFFFFFFFU
+#define MIN_SCAN_PERIOD		2500
+#define CONVERT_PERIOD		625
+
+/*
+ * 'do_cmdtest' function for AO subdevice.
+ */
+static int
+pci224_ao_cmdtest(comedi_device * dev, comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* Step 1: make sure trigger sources are trivially valid. */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT | TRIG_TIMER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* Step 2: make sure trigger sources are unique and mutually
+	 * compatible. */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	/* There's only one external trigger signal (which makes these
+	 * tests easier).  Only one thing can use it. */
+	tmp = 0;
+	if (cmd->start_src & TRIG_EXT)
+		tmp++;
+	if (cmd->scan_begin_src & TRIG_EXT)
+		tmp++;
+	if (cmd->stop_src & TRIG_EXT)
+		tmp++;
+	if (tmp > 1)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* Step 3: make sure arguments are trivially compatible. */
+
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		if (cmd->start_arg != 0) {
+			cmd->start_arg = 0;
+			err++;
+		}
+		break;
+	case TRIG_EXT:
+		/* Force to external trigger 0. */
+		if ((cmd->start_arg & ~CR_FLAGS_MASK) != 0) {
+			cmd->start_arg = COMBINE(cmd->start_arg, 0,
+				~CR_FLAGS_MASK);
+			err++;
+		}
+		/* The only flag allowed is CR_EDGE, which is ignored. */
+		if ((cmd->start_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+			cmd->start_arg = COMBINE(cmd->start_arg, 0,
+				CR_FLAGS_MASK & ~CR_EDGE);
+			err++;
+		}
+		break;
+	}
+
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		if (cmd->scan_begin_arg > MAX_SCAN_PERIOD) {
+			cmd->scan_begin_arg = MAX_SCAN_PERIOD;
+			err++;
+		}
+		tmp = cmd->chanlist_len * CONVERT_PERIOD;
+		if (tmp < MIN_SCAN_PERIOD) {
+			tmp = MIN_SCAN_PERIOD;
+		}
+		if (cmd->scan_begin_arg < tmp) {
+			cmd->scan_begin_arg = tmp;
+			err++;
+		}
+		break;
+	case TRIG_EXT:
+		/* Force to external trigger 0. */
+		if ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+				~CR_FLAGS_MASK);
+			err++;
+		}
+		/* Only allow flags CR_EDGE and CR_INVERT.  Ignore CR_EDGE. */
+		if ((cmd->scan_begin_arg & CR_FLAGS_MASK &
+				~(CR_EDGE | CR_INVERT)) != 0) {
+			cmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,
+				CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+			err++;
+		}
+		break;
+	}
+
+	/* cmd->convert_src == TRIG_NOW */
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_end_arg == TRIG_COUNT */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* Any count allowed. */
+		break;
+	case TRIG_EXT:
+		/* Force to external trigger 0. */
+		if ((cmd->stop_arg & ~CR_FLAGS_MASK) != 0) {
+			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
+				~CR_FLAGS_MASK);
+			err++;
+		}
+		/* The only flag allowed is CR_EDGE, which is ignored. */
+		if ((cmd->stop_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {
+			cmd->stop_arg = COMBINE(cmd->stop_arg, 0,
+				CR_FLAGS_MASK & ~CR_EDGE);
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* Step 4: fix up any arguments. */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		unsigned int div1, div2, round;
+		int round_mode = cmd->flags & TRIG_ROUND_MASK;
+
+		tmp = cmd->scan_begin_arg;
+		/* Check whether to use a single timer. */
+		switch (round_mode) {
+		case TRIG_ROUND_NEAREST:
+		default:
+			round = TIMEBASE_10MHZ / 2;
+			break;
+		case TRIG_ROUND_DOWN:
+			round = 0;
+			break;
+		case TRIG_ROUND_UP:
+			round = TIMEBASE_10MHZ - 1;
+			break;
+		}
+		/* Be careful to avoid overflow! */
+		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
+		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
+			TIMEBASE_10MHZ;
+		if (div2 <= 0x10000) {
+			/* A single timer will suffice. */
+			if (div2 < 2)
+				div2 = 2;
+			cmd->scan_begin_arg = div2 * TIMEBASE_10MHZ;
+			if (cmd->scan_begin_arg < div2 ||
+				cmd->scan_begin_arg < TIMEBASE_10MHZ) {
+				/* Overflow! */
+				cmd->scan_begin_arg = MAX_SCAN_PERIOD;
+			}
+		} else {
+			/* Use two timers. */
+			div1 = devpriv->cached_div1;
+			div2 = devpriv->cached_div2;
+			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
+				&cmd->scan_begin_arg, round_mode);
+			devpriv->cached_div1 = div1;
+			devpriv->cached_div2 = div2;
+		}
+		if (tmp != cmd->scan_begin_arg) {
+			err++;
+		}
+	}
+
+	if (err)
+		return 4;
+
+	/* Step 5: check channel list. */
+
+	if (cmd->chanlist && (cmd->chanlist_len > 0)) {
+		unsigned int range;
+		enum { range_err = 1, dupchan_err = 2, };
+		unsigned errors;
+		unsigned int n;
+		unsigned int ch;
+
+		/*
+		 * Check all channels have the same range index.  Don't care
+		 * about analogue reference, as we can't configure it.
+		 *
+		 * Check the list has no duplicate channels.
+		 */
+		range = CR_RANGE(cmd->chanlist[0]);
+		errors = 0;
+		tmp = 0;
+		for (n = 0; n < cmd->chanlist_len; n++) {
+			ch = CR_CHAN(cmd->chanlist[n]);
+			if (tmp & (1U << ch)) {
+				errors |= dupchan_err;
+			}
+			tmp |= (1U << ch);
+			if (CR_RANGE(cmd->chanlist[n]) != range) {
+				errors |= range_err;
+			}
+		}
+		if (errors) {
+			if (errors & dupchan_err) {
+				DPRINTK("comedi%d: " DRIVER_NAME
+					": ao_cmdtest: "
+					"entries in chanlist must contain no "
+					"duplicate channels\n", dev->minor);
+			}
+			if (errors & range_err) {
+				DPRINTK("comedi%d: " DRIVER_NAME
+					": ao_cmdtest: "
+					"entries in chanlist must all have "
+					"the same range index\n", dev->minor);
+			}
+			err++;
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+/*
+ * 'do_cmd' function for AO subdevice.
+ */
+static int pci224_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int range;
+	unsigned int i, j;
+	unsigned int ch;
+	unsigned int rank;
+	unsigned long flags;
+
+	/* Cannot handle null/empty chanlist. */
+	if (cmd->chanlist == NULL || cmd->chanlist_len == 0) {
+		return -EINVAL;
+	}
+
+	/* Determine which channels are enabled and their load order.  */
+	devpriv->ao_enab = 0;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		ch = CR_CHAN(cmd->chanlist[i]);
+		devpriv->ao_enab |= 1U << ch;
+		rank = 0;
+		for (j = 0; j < cmd->chanlist_len; j++) {
+			if (CR_CHAN(cmd->chanlist[j]) < ch) {
+				rank++;
+			}
+		}
+		devpriv->ao_scan_order[rank] = i;
+	}
+
+	/* Set enabled channels. */
+	outw(devpriv->ao_enab, dev->iobase + PCI224_DACCEN);
+
+	/* Determine range and polarity.  All channels the same.  */
+	range = CR_RANGE(cmd->chanlist[0]);
+
+	/*
+	 * Set DAC range and polarity.
+	 * Set DAC scan trigger source to 'none'.
+	 * Set DAC FIFO interrupt trigger level to 'not half full'.
+	 * Reset DAC FIFO.
+	 *
+	 * N.B. DAC FIFO interrupts are currently disabled.
+	 */
+	devpriv->daccon = COMBINE(devpriv->daccon,
+		(devpriv->hwrange[range] | PCI224_DACCON_TRIG_NONE |
+			PCI224_DACCON_FIFOINTR_NHALF),
+		(PCI224_DACCON_POLAR_MASK | PCI224_DACCON_VREF_MASK |
+			PCI224_DACCON_TRIG_MASK | PCI224_DACCON_FIFOINTR_MASK));
+	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
+		dev->iobase + PCI224_DACCON);
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		unsigned int div1, div2, round;
+		unsigned int ns = cmd->scan_begin_arg;
+		int round_mode = cmd->flags & TRIG_ROUND_MASK;
+
+		/* Check whether to use a single timer. */
+		switch (round_mode) {
+		case TRIG_ROUND_NEAREST:
+		default:
+			round = TIMEBASE_10MHZ / 2;
+			break;
+		case TRIG_ROUND_DOWN:
+			round = 0;
+			break;
+		case TRIG_ROUND_UP:
+			round = TIMEBASE_10MHZ - 1;
+			break;
+		}
+		/* Be careful to avoid overflow! */
+		div2 = cmd->scan_begin_arg / TIMEBASE_10MHZ;
+		div2 += (round + cmd->scan_begin_arg % TIMEBASE_10MHZ) /
+			TIMEBASE_10MHZ;
+		if (div2 <= 0x10000) {
+			/* A single timer will suffice. */
+			if (div2 < 2)
+				div2 = 2;
+			div2 &= 0xffff;
+			div1 = 1;	/* Flag that single timer to be used. */
+		} else {
+			/* Use two timers. */
+			div1 = devpriv->cached_div1;
+			div2 = devpriv->cached_div2;
+			pci224_cascade_ns_to_timer(TIMEBASE_10MHZ, &div1, &div2,
+				&ns, round_mode);
+		}
+
+		/*
+		 * The output of timer Z2-0 will be used as the scan trigger
+		 * source.
+		 */
+		/* Make sure Z2-0 is gated on.  */
+		outb(GAT_CONFIG(0, GAT_VCC),
+			devpriv->iobase1 + PCI224_ZGAT_SCE);
+		if (div1 == 1) {
+			/* Not cascading.  Z2-0 needs 10 MHz clock. */
+			outb(CLK_CONFIG(0, CLK_10MHZ),
+				devpriv->iobase1 + PCI224_ZCLK_SCE);
+		} else {
+			/* Cascading with Z2-2. */
+			/* Make sure Z2-2 is gated on.  */
+			outb(GAT_CONFIG(2, GAT_VCC),
+				devpriv->iobase1 + PCI224_ZGAT_SCE);
+			/* Z2-2 needs 10 MHz clock. */
+			outb(CLK_CONFIG(2, CLK_10MHZ),
+				devpriv->iobase1 + PCI224_ZCLK_SCE);
+			/* Load Z2-2 mode (2) and counter (div1). */
+			i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0,
+				2, div1, 2);
+			/* Z2-0 is clocked from Z2-2's output. */
+			outb(CLK_CONFIG(0, CLK_OUTNM1),
+				devpriv->iobase1 + PCI224_ZCLK_SCE);
+		}
+		/* Load Z2-0 mode (2) and counter (div2). */
+		i8254_load(devpriv->iobase1 + PCI224_Z2_CT0, 0, 0, div2, 2);
+	}
+
+	/*
+	 * Sort out end of acquisition.
+	 */
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* Fixed number of scans.  */
+		devpriv->ao_stop_continuous = 0;
+		devpriv->ao_stop_count = cmd->stop_arg;
+		break;
+	default:
+		/* Continuous scans. */
+		devpriv->ao_stop_continuous = 1;
+		devpriv->ao_stop_count = 0;
+		break;
+	}
+
+	/*
+	 * Sort out start of acquisition.
+	 */
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		s->async->inttrig = &pci224_ao_inttrig_start;
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		break;
+	case TRIG_EXT:
+		/* Enable external interrupt trigger to start acquisition. */
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		devpriv->intsce |= PCI224_INTR_EXT;
+		outb(devpriv->intsce, devpriv->iobase1 + PCI224_INT_SCE);
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * 'cancel' function for AO subdevice.
+ */
+static int pci224_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	pci224_ao_stop(dev, s);
+	return 0;
+}
+
+/*
+ * 'munge' data for AO command.
+ */
+static void
+pci224_ao_munge(comedi_device * dev, comedi_subdevice * s, void *data,
+	unsigned int num_bytes, unsigned int chan_index)
+{
+	comedi_async *async = s->async;
+	sampl_t *array = data;
+	unsigned int length = num_bytes / sizeof(*array);
+	unsigned int offset;
+	unsigned int shift;
+	unsigned int i;
+
+	/* The hardware expects 16-bit numbers. */
+	shift = 16 - thisboard->ao_bits;
+	/* Channels will be all bipolar or all unipolar. */
+	if ((devpriv->hwrange[CR_RANGE(async->cmd.chanlist[0])] &
+			PCI224_DACCON_POLAR_MASK) == PCI224_DACCON_POLAR_UNI) {
+		/* Unipolar */
+		offset = 0;
+	} else {
+		/* Bipolar */
+		offset = 32768;
+	}
+	/* Munge the data. */
+	for (i = 0; i < length; i++) {
+		array[i] = (array[i] << shift) - offset;
+	}
+}
+
+/*
+ * Interrupt handler.
+ */
+static irqreturn_t pci224_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = &dev->subdevices[0];
+	comedi_cmd *cmd;
+	unsigned char intstat, valid_intstat;
+	unsigned char curenab;
+	int retval = 0;
+	unsigned long flags;
+
+	intstat = inb(devpriv->iobase1 + PCI224_INT_SCE) & 0x3F;
+	if (intstat) {
+		retval = 1;
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		valid_intstat = devpriv->intsce & intstat;
+		/* Temporarily disable interrupt sources. */
+		curenab = devpriv->intsce & ~intstat;
+		outb(curenab, devpriv->iobase1 + PCI224_INT_SCE);
+		devpriv->intr_running = 1;
+		devpriv->intr_cpuid = THISCPU;
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+		if (valid_intstat != 0) {
+			cmd = &s->async->cmd;
+			if (valid_intstat & PCI224_INTR_EXT) {
+				devpriv->intsce &= ~PCI224_INTR_EXT;
+				if (cmd->start_src == TRIG_EXT) {
+					pci224_ao_start(dev, s);
+				} else if (cmd->stop_src == TRIG_EXT) {
+					pci224_ao_stop(dev, s);
+				}
+			}
+			if (valid_intstat & PCI224_INTR_DAC) {
+				pci224_ao_handle_fifo(dev, s);
+			}
+		}
+		/* Reenable interrupt sources. */
+		comedi_spin_lock_irqsave(&devpriv->ao_spinlock, flags);
+		if (curenab != devpriv->intsce) {
+			outb(devpriv->intsce,
+				devpriv->iobase1 + PCI224_INT_SCE);
+		}
+		devpriv->intr_running = 0;
+		comedi_spin_unlock_irqrestore(&devpriv->ao_spinlock, flags);
+	}
+	return IRQ_RETVAL(retval);
+}
+
+/*
+ * This function looks for a PCI device matching the requested board name,
+ * bus and slot.
+ */
+static int
+pci224_find_pci(comedi_device * dev, int bus, int slot,
+	struct pci_dev **pci_dev_p)
+{
+	struct pci_dev *pci_dev = NULL;
+
+	*pci_dev_p = NULL;
+
+	/* Look for matching PCI device. */
+	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+		pci_dev != NULL;
+		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID,
+			pci_dev)) {
+		/* If bus/slot specified, check them. */
+		if (bus || slot) {
+			if (bus != pci_dev->bus->number
+				|| slot != PCI_SLOT(pci_dev->devfn))
+				continue;
+		}
+		if (thisboard->model == any_model) {
+			/* Match any supported model. */
+			int i;
+
+			for (i = 0; i < ARRAY_SIZE(pci224_boards); i++) {
+				if (pci_dev->device == pci224_boards[i].devid) {
+					/* Change board_ptr to matched board. */
+					dev->board_ptr = &pci224_boards[i];
+					break;
+				}
+			}
+			if (i == ARRAY_SIZE(pci224_boards))
+				continue;
+		} else {
+			/* Match specific model name. */
+			if (thisboard->devid != pci_dev->device)
+				continue;
+		}
+
+		/* Found a match. */
+		*pci_dev_p = pci_dev;
+		return 0;
+	}
+	/* No match found. */
+	if (bus || slot) {
+		printk(KERN_ERR "comedi%d: error! "
+			"no %s found at pci %02x:%02x!\n",
+			dev->minor, thisboard->name, bus, slot);
+	} else {
+		printk(KERN_ERR "comedi%d: error! no %s found!\n",
+			dev->minor, thisboard->name);
+	}
+	return -EIO;
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int pci224_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	struct pci_dev *pci_dev;
+	unsigned int irq;
+	int bus = 0, slot = 0;
+	unsigned n;
+	int ret;
+
+	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor, DRIVER_NAME);
+
+	bus = it->options[0];
+	slot = it->options[1];
+	if ((ret = alloc_private(dev, sizeof(pci224_private))) < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return ret;
+	}
+	if ((ret = pci224_find_pci(dev, bus, slot, &pci_dev)) < 0)
+		return ret;
+	devpriv->pci_dev = pci_dev;
+
+	if ((ret = comedi_pci_enable(pci_dev, DRIVER_NAME)) < 0) {
+		printk(KERN_ERR
+			"comedi%d: error! cannot enable PCI device "
+			"and request regions!\n", dev->minor);
+		return ret;
+	}
+	spin_lock_init(&devpriv->ao_spinlock);
+
+	devpriv->iobase1 = pci_resource_start(pci_dev, 2);
+	dev->iobase = pci_resource_start(pci_dev, 3);
+	irq = pci_dev->irq;
+
+	/* Allocate readback buffer for AO channels. */
+	devpriv->ao_readback = kmalloc(sizeof(devpriv->ao_readback[0]) *
+		thisboard->ao_chans, GFP_KERNEL);
+	if (!devpriv->ao_readback) {
+		return -ENOMEM;
+	}
+
+	/* Allocate buffer to hold values for AO channel scan. */
+	devpriv->ao_scan_vals = kmalloc(sizeof(devpriv->ao_scan_vals[0]) *
+		thisboard->ao_chans, GFP_KERNEL);
+	if (!devpriv->ao_scan_vals) {
+		return -ENOMEM;
+	}
+
+	/* Allocate buffer to hold AO channel scan order. */
+	devpriv->ao_scan_order = kmalloc(sizeof(devpriv->ao_scan_order[0]) *
+		thisboard->ao_chans, GFP_KERNEL);
+	if (!devpriv->ao_scan_order) {
+		return -ENOMEM;
+	}
+
+	/* Disable interrupt sources. */
+	devpriv->intsce = 0;
+	outb(0, devpriv->iobase1 + PCI224_INT_SCE);
+
+	/* Initialize the DAC hardware. */
+	outw(PCI224_DACCON_GLOBALRESET, dev->iobase + PCI224_DACCON);
+	outw(0, dev->iobase + PCI224_DACCEN);
+	outw(0, dev->iobase + PCI224_FIFOSIZ);
+	devpriv->daccon = (PCI224_DACCON_TRIG_SW | PCI224_DACCON_POLAR_BI |
+		PCI224_DACCON_FIFOENAB | PCI224_DACCON_FIFOINTR_EMPTY);
+	outw(devpriv->daccon | PCI224_DACCON_FIFORESET,
+		dev->iobase + PCI224_DACCON);
+
+	/* Allocate subdevices.  There is only one!  */
+	if ((ret = alloc_subdevices(dev, 1)) < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return ret;
+	}
+
+	s = dev->subdevices + 0;
+	/* Analog output subdevice. */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	s->n_chan = thisboard->ao_chans;
+	s->maxdata = (1 << thisboard->ao_bits) - 1;
+	s->insn_write = &pci224_ao_insn_write;
+	s->insn_read = &pci224_ao_insn_read;
+	s->len_chanlist = s->n_chan;
+
+	dev->write_subdev = s;
+	s->do_cmd = &pci224_ao_cmd;
+	s->do_cmdtest = &pci224_ao_cmdtest;
+	s->cancel = &pci224_ao_cancel;
+	s->munge = &pci224_ao_munge;
+
+	/* Sort out channel range options. */
+	if (thisboard->model == pci234_model) {
+		/* PCI234 range options. */
+		const comedi_lrange **range_table_list;
+
+		s->range_table_list = range_table_list =
+			kmalloc(sizeof(comedi_lrange *) * s->n_chan,
+			GFP_KERNEL);
+		if (!s->range_table_list) {
+			return -ENOMEM;
+		}
+		for (n = 2; n < 3 + s->n_chan; n++) {
+			if (it->options[n] < 0 || it->options[n] > 1) {
+				printk(KERN_WARNING "comedi%d: %s: warning! "
+					"bad options[%u]=%d\n",
+					dev->minor, DRIVER_NAME, n,
+					it->options[n]);
+			}
+		}
+		for (n = 0; n < s->n_chan; n++) {
+			if (n < COMEDI_NDEVCONFOPTS - 3 &&
+				it->options[3 + n] == 1) {
+				if (it->options[2] == 1) {
+					range_table_list[n] = &range_pci234_ext;
+				} else {
+					range_table_list[n] = &range_bipolar5;
+				}
+			} else {
+				if (it->options[2] == 1) {
+					range_table_list[n] =
+						&range_pci234_ext2;
+				} else {
+					range_table_list[n] = &range_bipolar10;
+				}
+			}
+		}
+		devpriv->hwrange = hwrange_pci234;
+	} else {
+		/* PCI224 range options. */
+		if (it->options[2] == 1) {
+			s->range_table = &range_pci224_external;
+			devpriv->hwrange = hwrange_pci224_external;
+		} else {
+			if (it->options[2] != 0) {
+				printk(KERN_WARNING "comedi%d: %s: warning! "
+					"bad options[2]=%d\n",
+					dev->minor, DRIVER_NAME,
+					it->options[2]);
+			}
+			s->range_table = &range_pci224_internal;
+			devpriv->hwrange = hwrange_pci224_internal;
+		}
+	}
+
+	dev->board_name = thisboard->name;
+
+	if (irq) {
+		ret = comedi_request_irq(irq, pci224_interrupt, IRQF_SHARED,
+			DRIVER_NAME, dev);
+		if (ret < 0) {
+			printk(KERN_ERR "comedi%d: error! "
+				"unable to allocate irq %u\n", dev->minor, irq);
+			return ret;
+		} else {
+			dev->irq = irq;
+		}
+	}
+
+	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
+	printk("(pci %s) ", pci_name(pci_dev));
+	if (irq) {
+		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
+	} else {
+		printk("(no irq) ");
+	}
+
+	printk("attached\n");
+
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int pci224_detach(comedi_device * dev)
+{
+	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor, DRIVER_NAME);
+
+	if (dev->irq) {
+		comedi_free_irq(dev->irq, dev);
+	}
+	if (dev->subdevices) {
+		comedi_subdevice *s;
+
+		s = dev->subdevices + 0;
+		/* AO subdevice */
+		if (s->range_table_list) {
+			kfree(s->range_table_list);
+		}
+	}
+	if (devpriv) {
+		if (devpriv->ao_readback) {
+			kfree(devpriv->ao_readback);
+		}
+		if (devpriv->ao_scan_vals) {
+			kfree(devpriv->ao_scan_vals);
+		}
+		if (devpriv->ao_scan_order) {
+			kfree(devpriv->ao_scan_order);
+		}
+		if (devpriv->pci_dev) {
+			if (dev->iobase) {
+				comedi_pci_disable(devpriv->pci_dev);
+			}
+			pci_dev_put(devpriv->pci_dev);
+		}
+	}
+	if (dev->board_name) {
+		printk(KERN_INFO "comedi%d: %s removed\n",
+			dev->minor, dev->board_name);
+	}
+
+	return 0;
+}
