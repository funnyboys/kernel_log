commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index b7934039459b..76e8d047f71e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c69cd676f357..b7934039459b 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Comedi driver for National Instruments AT-A2150 boards
  * Copyright (C) 2001, 2002 Frank Mori Hess <fmhess@users.sourceforge.net>

commit 8bd05c98b29fa6889004de13849676f3536f519b
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Fri Feb 10 01:03:27 2017 +0330

    staging: comedi: ni_at_a2150: usleep_range is preferred over udelay
    
    Fix the checkpatch.pl issue:
    CHECK: usleep_range is preferred over udelay
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 5a4dcc6e61d8..c69cd676f357 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -757,7 +757,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;
-		udelay(1000);
+		usleep_range(1000, 3000);
 	}
 	if (i == timeout) {
 		dev_err(dev->class_dev,

commit 4281c748d6dfe81fe6a8d9b06847a11545b71000
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:14:23 2016 -0400

    staging: comedi: ni_at_a2150: Fix checkpatch warning
    
    Fix checkpatch.pl warning 'line over 80 characters'
    Remove extra space after /*
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 957fb9f8ef9c..5a4dcc6e61d8 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -58,48 +58,52 @@
 
 /* Registers and bits */
 #define CONFIG_REG		0x0
-#define   CHANNEL_BITS(x)		((x) & 0x7)
+#define   CHANNEL_BITS(x)	((x) & 0x7)
 #define   CHANNEL_MASK		0x7
-#define   CLOCK_SELECT_BITS(x)		(((x) & 0x3) << 3)
-#define   CLOCK_DIVISOR_BITS(x)		(((x) & 0x3) << 5)
+#define   CLOCK_SELECT_BITS(x)	(((x) & 0x3) << 3)
+#define   CLOCK_DIVISOR_BITS(x)	(((x) & 0x3) << 5)
 #define   CLOCK_MASK		(0xf << 3)
-#define   ENABLE0_BIT		0x80	/*  enable (don't internally ground) channels 0 and 1 */
-#define   ENABLE1_BIT		0x100	/*  enable (don't internally ground) channels 2 and 3 */
-#define   AC0_BIT		0x200	/*  ac couple channels 0,1 */
-#define   AC1_BIT		0x400	/*  ac couple channels 2,3 */
-#define   APD_BIT		0x800	/*  analog power down */
-#define   DPD_BIT		0x1000	/*  digital power down */
-#define TRIGGER_REG		0x2	/*  trigger config register */
-#define   POST_TRIGGER_BITS		0x2
-#define   DELAY_TRIGGER_BITS		0x3
-#define   HW_TRIG_EN		0x10	/*  enable hardware trigger */
-#define FIFO_START_REG		0x6	/*  software start aquistion trigger */
-#define FIFO_RESET_REG		0x8	/*  clears fifo + fifo flags */
-#define FIFO_DATA_REG		0xa	/*  read data */
-#define DMA_TC_CLEAR_REG		0xe	/*  clear dma terminal count interrupt */
-#define STATUS_REG		0x12	/*  read only */
-#define   FNE_BIT		0x1	/*  fifo not empty */
-#define   OVFL_BIT		0x8	/*  fifo overflow */
-#define   EDAQ_BIT		0x10	/*  end of acquisition interrupt */
-#define   DCAL_BIT		0x20	/*  offset calibration in progress */
-#define   INTR_BIT		0x40	/*  interrupt has occurred */
-#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occurred */
-#define   ID_BITS(x)	(((x) >> 8) & 0x3)
-#define IRQ_DMA_CNTRL_REG		0x12	/*  write only */
-#define   DMA_CHAN_BITS(x)		((x) & 0x7)	/*  sets dma channel */
-#define   DMA_EN_BIT		0x8	/*  enables dma */
-#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	/*  sets irq level */
-#define   FIFO_INTR_EN_BIT		0x100	/*  enable fifo interrupts */
-#define   FIFO_INTR_FHF_BIT		0x200	/*  interrupt fifo half full */
-#define   DMA_INTR_EN_BIT		0x800	/*  enable interrupt on dma terminal count */
-#define   DMA_DEM_EN_BIT	0x1000	/*  enables demand mode dma */
+/* enable (don't internally ground) channels 0 and 1 */
+#define   ENABLE0_BIT		0x80
+/* enable (don't internally ground) channels 2 and 3 */
+#define   ENABLE1_BIT		0x100
+#define   AC0_BIT		0x200	/* ac couple channels 0,1 */
+#define   AC1_BIT		0x400	/* ac couple channels 2,3 */
+#define   APD_BIT		0x800	/* analog power down */
+#define   DPD_BIT		0x1000	/* digital power down */
+#define TRIGGER_REG		0x2	/* trigger config register */
+#define   POST_TRIGGER_BITS	0x2
+#define   DELAY_TRIGGER_BITS	0x3
+#define   HW_TRIG_EN		0x10	/* enable hardware trigger */
+#define FIFO_START_REG		0x6	/* software start aquistion trigger */
+#define FIFO_RESET_REG		0x8	/* clears fifo + fifo flags */
+#define FIFO_DATA_REG		0xa	/* read data */
+#define DMA_TC_CLEAR_REG	0xe	/* clear dma terminal count interrupt */
+#define STATUS_REG		0x12	/* read only */
+#define   FNE_BIT		0x1	/* fifo not empty */
+#define   OVFL_BIT		0x8	/* fifo overflow */
+#define   EDAQ_BIT		0x10	/* end of acquisition interrupt */
+#define   DCAL_BIT		0x20	/* offset calibration in progress */
+#define   INTR_BIT		0x40	/* interrupt has occurred */
+/* dma terminal count interrupt has occurred */
+#define   DMA_TC_BIT		0x80
+#define   ID_BITS(x)		(((x) >> 8) & 0x3)
+#define IRQ_DMA_CNTRL_REG	0x12			/* write only */
+#define   DMA_CHAN_BITS(x)	((x) & 0x7)		/* sets dma channel */
+#define   DMA_EN_BIT		0x8			/* enables dma */
+#define   IRQ_LVL_BITS(x)	(((x) & 0xf) << 4)	/* sets irq level */
+#define   FIFO_INTR_EN_BIT	0x100	/* enable fifo interrupts */
+#define   FIFO_INTR_FHF_BIT	0x200	/* interrupt fifo half full */
+/* enable interrupt on dma terminal count */
+#define   DMA_INTR_EN_BIT	0x800
+#define   DMA_DEM_EN_BIT	0x1000	/* enables demand mode dma */
 #define I8253_BASE_REG		0x14
 
 struct a2150_board {
 	const char *name;
-	int clock[4];		/*  master clock periods, in nanoseconds */
-	int num_clocks;		/*  number of available master clock speeds */
-	int ai_speed;		/*  maximum conversion rate in nanoseconds */
+	int clock[4];		/* master clock periods, in nanoseconds */
+	int num_clocks;		/* number of available master clock speeds */
+	int ai_speed;		/* maximum conversion rate in nanoseconds */
 };
 
 /* analog input range */
@@ -129,8 +133,8 @@ static const struct a2150_board a2150_boards[] = {
 struct a2150_private {
 	struct comedi_isadma *dma;
 	unsigned int count;	/* number of data points left to be taken */
-	int irq_dma_bits;	/*  irq/dma register bits */
-	int config_bits;	/*  config register bits */
+	int irq_dma_bits;	/* irq/dma register bits */
+	int config_bits;	/* config register bits */
 };
 
 /* interrupt service routine */
@@ -174,13 +178,13 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	 */
 	residue = comedi_isadma_disable(desc->chan);
 
-	/*  figure out how many points to read */
+	/* figure out how many points to read */
 	max_points = comedi_bytes_to_samples(s, desc->size);
 	num_points = max_points - comedi_bytes_to_samples(s, residue);
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
-	/*  figure out how many points will be stored next time */
+	/* figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
 		leftover = comedi_bytes_to_samples(s, desc->size);
@@ -189,7 +193,8 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 		if (leftover > max_points)
 			leftover = max_points;
 	}
-	/* there should only be a residue if collection was stopped by having
+	/*
+	 * There should only be a residue if collection was stopped by having
 	 * the stop_src set to an external trigger, in which case there
 	 * will be no more data
 	 */
@@ -199,7 +204,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	for (i = 0; i < num_points; i++) {
 		/* write data point to comedi buffer */
 		dpnt = buf[i];
-		/*  convert from 2's complement to unsigned coding */
+		/* convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
 		comedi_buf_write_samples(s, &dpnt, 1);
 		if (cmd->stop_src == TRIG_COUNT) {
@@ -229,14 +234,14 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_isadma_desc *desc = &dma->desc[0];
 
-	/*  disable dma on card */
+	/* disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	/*  disable computer's dma */
+	/* disable computer's dma */
 	comedi_isadma_disable(desc->chan);
 
-	/*  clear fifo and reset triggering circuitry */
+	/* clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return 0;
@@ -255,7 +260,7 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
 	int i, j;
 
-	/*  initialize greatest lower and least upper bounds */
+	/* initialize greatest lower and least upper bounds */
 	lub_divisor_shift = 3;
 	lub_index = 0;
 	lub = board->clock[lub_index] * (1 << lub_divisor_shift);
@@ -263,19 +268,19 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	glb_index = board->num_clocks - 1;
 	glb = board->clock[glb_index] * (1 << glb_divisor_shift);
 
-	/*  make sure period is in available range */
+	/* make sure period is in available range */
 	if (*period < glb)
 		*period = glb;
 	if (*period > lub)
 		*period = lub;
 
-	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
+	/* we can multiply period by 1, 2, 4, or 8, using (1 << i) */
 	for (i = 0; i < 4; i++) {
-		/*  there are a maximum of 4 master clocks */
+		/* there are a maximum of 4 master clocks */
 		for (j = 0; j < board->num_clocks; j++) {
-			/*  temp is the period in nanosec we are evaluating */
+			/* temp is the period in nanosec we are evaluating */
 			temp = board->clock[j] * (1 << i);
-			/*  if it is the best match yet */
+			/* if it is the best match yet */
 			if (temp < lub && temp >= *period) {
 				lub_divisor_shift = i;
 				lub_index = j;
@@ -291,7 +296,7 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	switch (flags & CMDF_ROUND_MASK) {
 	case CMDF_ROUND_NEAREST:
 	default:
-		/*  if least upper bound is better approximation */
+		/* if least upper bound is better approximation */
 		if (lub - *period < *period - glb)
 			*period = lub;
 		else
@@ -305,7 +310,7 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 		break;
 	}
 
-	/*  set clock bits for config register appropriately */
+	/* set clock bits for config register appropriately */
 	devpriv->config_bits &= ~CLOCK_MASK;
 	if (*period == lub) {
 		devpriv->config_bits |=
@@ -480,7 +485,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			"dma incompatible with hard real-time interrupt (CMDF_PRIORITY), aborting\n");
 		return -1;
 	}
-	/*  clear fifo and reset triggering circuitry */
+	/* clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
@@ -488,7 +493,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			       cmd->chanlist_len) < 0)
 		return -1;
 
-	/*  setup ac/dc coupling */
+	/* setup ac/dc coupling */
 	if (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)
 		devpriv->config_bits |= AC0_BIT;
 	else
@@ -498,18 +503,18 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	else
 		devpriv->config_bits &= ~AC1_BIT;
 
-	/*  setup timing */
+	/* setup timing */
 	a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
 
-	/*  send timing, channel, config bits */
+	/* send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	/*  initialize number of samples remaining */
+	/* initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
 	comedi_isadma_disable(desc->chan);
 
-	/*  set size of transfer to fill in 1/3 second */
+	/* set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	desc->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
 		    ONE_THIRD_SECOND / cmd->scan_begin_arg;
@@ -527,36 +532,39 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
 
-	/*  enable dma on card */
+	/* enable dma on card */
 	devpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	/*  may need to wait 72 sampling periods if timing was changed */
+	/* may need to wait 72 sampling periods if timing was changed */
 	comedi_8254_load(dev->pacer, 2, 72, I8254_MODE0 | I8254_BINARY);
 
-	/*  setup start triggering */
+	/* setup start triggering */
 	trigger_bits = 0;
-	/*  decide if we need to wait 72 periods for valid data */
+	/* decide if we need to wait 72 periods for valid data */
 	if (cmd->start_src == TRIG_NOW &&
 	    (old_config_bits & CLOCK_MASK) !=
 	    (devpriv->config_bits & CLOCK_MASK)) {
-		/*  set trigger source to delay trigger */
+		/* set trigger source to delay trigger */
 		trigger_bits |= DELAY_TRIGGER_BITS;
 	} else {
-		/*  otherwise no delay */
+		/* otherwise no delay */
 		trigger_bits |= POST_TRIGGER_BITS;
 	}
-	/*  enable external hardware trigger */
+	/* enable external hardware trigger */
 	if (cmd->start_src == TRIG_EXT) {
 		trigger_bits |= HW_TRIG_EN;
 	} else if (cmd->start_src == TRIG_OTHER) {
-		/*  XXX add support for level/slope start trigger using TRIG_OTHER */
+		/*
+		 * XXX add support for level/slope start trigger
+		 * using TRIG_OTHER
+		 */
 		dev_err(dev->class_dev, "you shouldn't see this?\n");
 	}
-	/*  send trigger config bits */
+	/* send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
-	/*  start acquisition for soft trigger */
+	/* start acquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW)
 		outw(0, dev->iobase + FIFO_START_REG);
 
@@ -583,28 +591,28 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int n;
 	int ret;
 
-	/*  clear fifo and reset triggering circuitry */
+	/* clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
 	if (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)
 		return -1;
 
-	/*  set dc coupling */
+	/* set dc coupling */
 	devpriv->config_bits &= ~AC0_BIT;
 	devpriv->config_bits &= ~AC1_BIT;
 
-	/*  send timing, channel, config bits */
+	/* send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	/*  disable dma on card */
+	/* disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	/*  setup start triggering */
+	/* setup start triggering */
 	outw(0, dev->iobase + TRIGGER_REG);
 
-	/*  start acquisition for soft trigger */
+	/* start acquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
 	/*
@@ -619,7 +627,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		inw(dev->iobase + FIFO_DATA_REG);
 	}
 
-	/*  read data */
+	/* read data */
 	for (n = 0; n < insn->n; n++) {
 		ret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);
 		if (ret)
@@ -629,7 +637,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		data[n] ^= 0x8000;
 	}
 
-	/*  clear fifo and reset triggering circuitry */
+	/* clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return n;
@@ -736,16 +744,16 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel = a2150_cancel;
 	}
 
-	/*  set card's irq and dma levels */
+	/* set card's irq and dma levels */
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	/*  reset and sync adc clock circuitry */
+	/* reset and sync adc clock circuitry */
 	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
 	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
-	/*  initialize configuration register */
+	/* initialize configuration register */
 	devpriv->config_bits = 0;
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
-	/*  wait until offset calibration is done, then enable analog inputs */
+	/* wait until offset calibration is done, then enable analog inputs */
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;

commit 27fa082b33b92285b8f38e73c838f224d2038c7b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 20 11:39:36 2016 -0700

    staging: comedi: ni_at_a2150: fix block comments
    
    Fix the checkpatch.pl issues:
    WARNING: Block comments use * on subsequent lines
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 9b444f8c4e33..957fb9f8ef9c 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -1,62 +1,47 @@
 /*
-    comedi/drivers/ni_at_a2150.c
-    Driver for National Instruments AT-A2150 boards
-    Copyright (C) 2001, 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
-/*
-Driver: ni_at_a2150
-Description: National Instruments AT-A2150
-Author: Frank Mori Hess
-Status: works
-Devices: [National Instruments] AT-A2150C (at_a2150c), AT-2150S (at_a2150s)
-
-If you want to ac couple the board's inputs, use AREF_OTHER.
-
-Configuration options:
-  [0] - I/O port base address
-  [1] - IRQ (optional, required for timed conversions)
-  [2] - DMA (optional, required for timed conversions)
+ * Comedi driver for National Instruments AT-A2150 boards
+ * Copyright (C) 2001, 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-*/
 /*
-Yet another driver for obsolete hardware brought to you by Frank Hess.
-Testing and debugging help provided by Dave Andruczyk.
-
-This driver supports the boards:
-
-AT-A2150C
-AT-A2150S
-
-The only difference is their master clock frequencies.
-
-Options:
-	[0] - base io address
-	[1] - irq
-	[2] - dma channel
-
-References (from ftp://ftp.natinst.com/support/manuals):
-
-	   320360.pdf  AT-A2150 User Manual
-
-TODO:
-
-analog level triggering
-TRIG_WAKE_EOS
-
-*/
+ * Driver: ni_at_a2150
+ * Description: National Instruments AT-A2150
+ * Author: Frank Mori Hess
+ * Status: works
+ * Devices: [National Instruments] AT-A2150C (at_a2150c), AT-2150S (at_a2150s)
+ *
+ * Configuration options:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional, required for timed conversions)
+ *   [2] - DMA (optional, required for timed conversions)
+ *
+ * Yet another driver for obsolete hardware brought to you by Frank Hess.
+ * Testing and debugging help provided by Dave Andruczyk.
+ *
+ * If you want to ac couple the board's inputs, use AREF_OTHER.
+ *
+ * The only difference in the boards is their master clock frequencies.
+ *
+ * References (from ftp://ftp.natinst.com/support/manuals):
+ *   320360.pdf  AT-A2150 User Manual
+ *
+ * TODO:
+ * - analog level triggering
+ * - TRIG_WAKE_EOS
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>
@@ -536,8 +521,10 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	comedi_isadma_program(desc);
 
-	/* clear dma interrupt before enabling it, to try and get rid of that
-	 * one spurious interrupt that has been happening */
+	/*
+	 * Clear dma interrupt before enabling it, to try and get rid of
+	 * that one spurious interrupt that has been happening.
+	 */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
 
 	/*  enable dma on card */

commit 94be3ef2a8ddcf3e97b2f598ada2c701fcec41fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:44 2015 -0700

    staging: comedi: ni_at_a2150: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 1cd4869d3286..9b444f8c4e33 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -264,7 +264,7 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    unsigned int flags)
 {
-	const struct a2150_board *thisboard = dev->board_ptr;
+	const struct a2150_board *board = dev->board_ptr;
 	struct a2150_private *devpriv = dev->private;
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
@@ -273,10 +273,10 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	/*  initialize greatest lower and least upper bounds */
 	lub_divisor_shift = 3;
 	lub_index = 0;
-	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
+	lub = board->clock[lub_index] * (1 << lub_divisor_shift);
 	glb_divisor_shift = 0;
-	glb_index = thisboard->num_clocks - 1;
-	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
+	glb_index = board->num_clocks - 1;
+	glb = board->clock[glb_index] * (1 << glb_divisor_shift);
 
 	/*  make sure period is in available range */
 	if (*period < glb)
@@ -287,9 +287,9 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
 	for (i = 0; i < 4; i++) {
 		/*  there are a maximum of 4 master clocks */
-		for (j = 0; j < thisboard->num_clocks; j++) {
+		for (j = 0; j < board->num_clocks; j++) {
 			/*  temp is the period in nanosec we are evaluating */
-			temp = thisboard->clock[j] * (1 << i);
+			temp = board->clock[j] * (1 << i);
 			/*  if it is the best match yet */
 			if (temp < lub && temp >= *period) {
 				lub_divisor_shift = i;
@@ -413,7 +413,7 @@ static int a2150_ai_check_chanlist(struct comedi_device *dev,
 static int a2150_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct a2150_board *thisboard = dev->board_ptr;
+	const struct a2150_board *board = dev->board_ptr;
 	int err = 0;
 	unsigned int arg;
 
@@ -444,7 +444,7 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-						    thisboard->ai_speed);
+						    board->ai_speed);
 	}
 
 	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
@@ -699,7 +699,7 @@ static const struct a2150_board *a2150_probe(struct comedi_device *dev)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct a2150_board *thisboard;
+	const struct a2150_board *board;
 	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
 	static const int timeout = 2000;
@@ -714,11 +714,11 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	thisboard = a2150_probe(dev);
-	if (!thisboard)
+	board = a2150_probe(dev);
+	if (!board)
 		return -ENODEV;
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	/* an IRQ and DMA are required to support async commands */
 	a2150_alloc_irq_and_dma(dev, it);

commit 30f23066424f8fc46e56f41195c51b33fdf36f58
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:43 2015 -0700

    staging: comedi: ni_at_a2150: cleanup a2150_probe()
    
    Make this function return a pointer to the boardinfo instead of an index.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 60469bb77ee4..1cd4869d3286 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -687,12 +687,14 @@ static void a2150_free_dma(struct comedi_device *dev)
 		comedi_isadma_free(devpriv->dma);
 }
 
-/* probes board type, returns offset */
-static int a2150_probe(struct comedi_device *dev)
+static const struct a2150_board *a2150_probe(struct comedi_device *dev)
 {
-	int status = inw(dev->iobase + STATUS_REG);
+	int id = ID_BITS(inw(dev->iobase + STATUS_REG));
 
-	return ID_BITS(status);
+	if (id >= ARRAY_SIZE(a2150_boards))
+		return NULL;
+
+	return &a2150_boards[id];
 }
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -712,12 +714,10 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	i = a2150_probe(dev);
-	if (i >= ARRAY_SIZE(a2150_boards))
+	thisboard = a2150_probe(dev);
+	if (!thisboard)
 		return -ENODEV;
-
-	dev->board_ptr = a2150_boards + i;
-	thisboard = dev->board_ptr;
+	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
 	/* an IRQ and DMA are required to support async commands */

commit 51bb618bff1e77c891f68405c3f8f3a492fecc17
Author: Joglekar Tejas <joglekartejas@gmail.com>
Date:   Mon Jun 1 09:44:51 2015 +0530

    Staging: comedi: ni_at_a2150: remove extra spaces before tab
    
    This patch fix warning given by checkpatch.pl abouts spaces given
    before tab
    
    Signed-off-by: Joglekar Tejas <joglekartejas@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 3a972d1538ab..60469bb77ee4 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -106,7 +106,7 @@ TRIG_WAKE_EOS
 #define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	/*  sets irq level */
 #define   FIFO_INTR_EN_BIT		0x100	/*  enable fifo interrupts */
 #define   FIFO_INTR_FHF_BIT		0x200	/*  interrupt fifo half full */
-#define   DMA_INTR_EN_BIT 		0x800	/*  enable interrupt on dma terminal count */
+#define   DMA_INTR_EN_BIT		0x800	/*  enable interrupt on dma terminal count */
 #define   DMA_DEM_EN_BIT	0x1000	/*  enables demand mode dma */
 #define I8253_BASE_REG		0x14
 

commit ded2468314ea8f81be3ee16f398ee8206fe22f37
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:21 2015 +0000

    staging: comedi: ni_at_a2150: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 66c0e65a953a..3a972d1538ab 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -67,7 +67,6 @@ TRIG_WAKE_EOS
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 #define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
@@ -420,19 +419,19 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -441,19 +440,21 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 thisboard->ai_speed);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    thisboard->ai_speed);
+	}
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -463,7 +464,7 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		a2150_get_timing(dev, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit e875132a3a6d5dce0211f69ac5ad5ba6356b5180
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:44 2015 -0700

    staging: comedi: ni_at_a2150: convert driver to use the comedi_8254 module
    
    The hardware supported by this driver includes an 8254 timer. For aesthetics,
    convert it to use the comedi_8254 module to provide support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index a1ce0b0b8c41..66c0e65a953a 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -68,7 +68,7 @@ TRIG_WAKE_EOS
 
 #include "comedi_isadma.h"
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 
 #define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
@@ -110,8 +110,6 @@ TRIG_WAKE_EOS
 #define   DMA_INTR_EN_BIT 		0x800	/*  enable interrupt on dma terminal count */
 #define   DMA_DEM_EN_BIT	0x1000	/*  enables demand mode dma */
 #define I8253_BASE_REG		0x14
-#define I8253_MODE_REG		0x17
-#define   HW_COUNT_DISABLE		0x30	/*  disable hardware counting of conversions */
 
 struct a2150_board {
 	const char *name;
@@ -488,7 +486,6 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned long timer_base = dev->iobase + I8253_BASE_REG;
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;
 
@@ -547,8 +544,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
 	/*  may need to wait 72 sampling periods if timing was changed */
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
-	i8254_write(timer_base, 0, 2, 72);
+	comedi_8254_load(dev->pacer, 2, 72, I8254_MODE0 | I8254_BINARY);
 
 	/*  setup start triggering */
 	trigger_bits = 0;
@@ -726,6 +722,11 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* an IRQ and DMA are required to support async commands */
 	a2150_alloc_irq_and_dma(dev, it);
 
+	dev->pacer = comedi_8254_init(dev->iobase + I8253_BASE_REG,
+				      0, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)
 		return ret;
@@ -747,10 +748,6 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel = a2150_cancel;
 	}
 
-	/* need to do this for software counting of completed conversions, to
-	 * prevent hardware count from stopping acquisition */
-	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
-
 	/*  set card's irq and dma levels */
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 250014805e0b..a1ce0b0b8c41 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -175,12 +175,12 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	if (status & OVFL_BIT) {
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
 		comedi_handle_events(dev, s);
 	}
 
 	if ((status & DMA_TC_BIT) == 0) {
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
 		comedi_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}

commit 1a97f144e3d3e9d7efc5c0837bed016da9ae43c7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:09 2015 -0700

    staging: comedi: ni_at_a2150: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 73768d0cbfe0..250014805e0b 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -62,14 +62,13 @@ TRIG_WAKE_EOS
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-#include "../comedidev.h"
-
 #include <linux/io.h>
 
-#include <asm/dma.h>
+#include "../comedidev.h"
 
-#include "8253.h"
+#include "comedi_isadma.h"
 #include "comedi_fc.h"
+#include "8253.h"
 
 #define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
@@ -145,85 +144,42 @@ static const struct a2150_board a2150_boards[] = {
 	 },
 };
 
-struct a2150_dma_desc {
-	unsigned int chan;	/* DMA channel */
-	void *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* size of DMA transfer (in bytes) */
-};
-
 struct a2150_private {
-	struct a2150_dma_desc dma_desc;
+	struct comedi_isadma *dma;
 	unsigned int count;	/* number of data points left to be taken */
 	int irq_dma_bits;	/*  irq/dma register bits */
 	int config_bits;	/*  config register bits */
 };
 
-static void a2150_isadma_program(struct a2150_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma->chan);
-	set_dma_mode(dma->chan, DMA_MODE_READ);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
-	release_dma_lock(flags);
-}
-
-static unsigned int a2150_isadma_disable(struct a2150_dma_desc *dma)
-{
-	unsigned long flags;
-	unsigned int residue;
-
-	flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	residue = get_dma_residue(dma->chan);
-	release_dma_lock(flags);
-
-	return residue;
-}
-
 /* interrupt service routine */
 static irqreturn_t a2150_interrupt(int irq, void *d)
 {
-	int i;
-	int status;
 	struct comedi_device *dev = d;
 	struct a2150_private *devpriv = dev->private;
-	struct a2150_dma_desc *dma = &devpriv->dma_desc;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
-	unsigned short *buf = dma->virt_addr;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned short *buf = desc->virt_addr;
 	unsigned int max_points, num_points, residue, leftover;
 	unsigned short dpnt;
+	int status;
+	int i;
 
-	if (!dev->attached) {
-		dev_err(dev->class_dev, "premature interrupt\n");
+	if (!dev->attached)
 		return IRQ_HANDLED;
-	}
-	/*  initialize async here to make sure s is not NULL */
-	async = s->async;
-	cmd = &async->cmd;
 
 	status = inw(dev->iobase + STATUS_REG);
-
-	if ((status & INTR_BIT) == 0) {
-		dev_err(dev->class_dev, "spurious interrupt\n");
+	if ((status & INTR_BIT) == 0)
 		return IRQ_NONE;
-	}
 
 	if (status & OVFL_BIT) {
-		dev_err(dev->class_dev, "fifo overflow\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_handle_events(dev, s);
 	}
 
 	if ((status & DMA_TC_BIT) == 0) {
-		dev_err(dev->class_dev,
-			"caught non-dma interrupt?  Aborting.\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		comedi_handle_events(dev, s);
 		return IRQ_HANDLED;
@@ -234,10 +190,10 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	 * transfer.  It should always be zero at this point unless
 	 * the stop_src is set to external triggering.
 	 */
-	residue = a2150_isadma_disable(dma);
+	residue = comedi_isadma_disable(desc->chan);
 
 	/*  figure out how many points to read */
-	max_points = comedi_bytes_to_samples(s, dma->size);
+	max_points = comedi_bytes_to_samples(s, desc->size);
 	num_points = max_points - comedi_bytes_to_samples(s, residue);
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
@@ -245,7 +201,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
-		leftover = comedi_bytes_to_samples(s, dma->size);
+		leftover = comedi_bytes_to_samples(s, desc->size);
 	} else if (devpriv->count > max_points) {
 		leftover = devpriv->count - max_points;
 		if (leftover > max_points)
@@ -273,8 +229,8 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 	/* re-enable dma */
 	if (leftover) {
-		dma->size = comedi_samples_to_bytes(s, leftover);
-		a2150_isadma_program(dma);
+		desc->size = comedi_samples_to_bytes(s, leftover);
+		comedi_isadma_program(desc);
 	}
 
 	comedi_handle_events(dev, s);
@@ -288,14 +244,15 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct a2150_private *devpriv = dev->private;
-	struct a2150_dma_desc *dma = &devpriv->dma_desc;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 
 	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
 	/*  disable computer's dma */
-	a2150_isadma_disable(dma);
+	comedi_isadma_disable(desc->chan);
 
 	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
@@ -527,7 +484,8 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct a2150_private *devpriv = dev->private;
-	struct a2150_dma_desc *dma = &devpriv->dma_desc;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long timer_base = dev->iobase + I8253_BASE_REG;
@@ -566,19 +524,19 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
-	a2150_isadma_disable(dma);
+	comedi_isadma_disable(desc->chan);
 
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
-	dma->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
+	desc->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
 		    ONE_THIRD_SECOND / cmd->scan_begin_arg;
-	if (dma->size > A2150_DMA_BUFFER_SIZE)
-		dma->size = A2150_DMA_BUFFER_SIZE;
-	if (dma->size < comedi_bytes_per_sample(s))
-		dma->size = comedi_bytes_per_sample(s);
-	dma->size -= dma->size % comedi_bytes_per_sample(s);
+	if (desc->size > desc->maxsize)
+		desc->size = desc->maxsize;
+	if (desc->size < comedi_bytes_per_sample(s))
+		desc->size = comedi_bytes_per_sample(s);
+	desc->size -= desc->size % comedi_bytes_per_sample(s);
 
-	a2150_isadma_program(dma);
+	comedi_isadma_program(desc);
 
 	/* clear dma interrupt before enabling it, to try and get rid of that
 	 * one spurious interrupt that has been happening */
@@ -693,64 +651,43 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-static void a2150_alloc_irq_dma(struct comedi_device *dev,
-				struct comedi_devconfig *it)
+static void a2150_alloc_irq_and_dma(struct comedi_device *dev,
+				    struct comedi_devconfig *it)
 {
 	struct a2150_private *devpriv = dev->private;
-	struct a2150_dma_desc *dma = &devpriv->dma_desc;
 	unsigned int irq_num = it->options[1];
 	unsigned int dma_chan = it->options[2];
 
 	/*
 	 * Only IRQs 15, 14, 12-9, and 7-3 are valid.
 	 * Only DMA channels 7-5 and 3-0 are valid.
-	 *
-	 * Both must be valid for async command support.
 	 */
 	if (irq_num > 15 || dma_chan > 7 ||
 	    !((1 << irq_num) & 0xdef8) || !((1 << dma_chan) & 0xef))
 		return;
 
-	/*
-	 * Request the IRQ and DMA channels and allocate the DMA buffer.
-	 * If the requests or allocation fail async command supprt will
-	 * not be available.
-	 */
 	if (request_irq(irq_num, a2150_interrupt, 0, dev->board_name, dev))
 		return;
-	if (request_dma(dma_chan, dev->board_name)) {
-		free_irq(irq_num, dev);
-		return;
-	}
-	dma->virt_addr = dma_alloc_coherent(NULL, A2150_DMA_BUFFER_SIZE,
-					    &dma->hw_addr, GFP_KERNEL);
-	if (!dma->virt_addr) {
-		free_dma(dma_chan);
+
+	/* DMA uses 1 buffer */
+	devpriv->dma = comedi_isadma_alloc(dev, 1, dma_chan, dma_chan,
+					   A2150_DMA_BUFFER_SIZE,
+					   COMEDI_ISADMA_READ);
+	if (!devpriv->dma) {
 		free_irq(irq_num, dev);
-		return;
+	} else {
+		dev->irq = irq_num;
+		devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) |
+					DMA_CHAN_BITS(dma_chan);
 	}
-
-	dev->irq = irq_num;
-	dma->chan = dma_chan;
-	devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) | DMA_CHAN_BITS(dma_chan);
-
-	a2150_isadma_disable(dma);
 }
 
 static void a2150_free_dma(struct comedi_device *dev)
 {
 	struct a2150_private *devpriv = dev->private;
-	struct a2150_dma_desc *dma;
-
-	if (!devpriv)
-		return;
 
-	dma = &devpriv->dma_desc;
-	if (dma->chan)
-		free_dma(dma->chan);
-	if (dma->virt_addr)
-		dma_free_coherent(NULL, A2150_DMA_BUFFER_SIZE,
-				  dma->virt_addr, dma->hw_addr);
+	if (devpriv)
+		comedi_isadma_free(devpriv->dma);
 }
 
 /* probes board type, returns offset */
@@ -786,7 +723,8 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
-	a2150_alloc_irq_dma(dev, it);
+	/* an IRQ and DMA are required to support async commands */
+	a2150_alloc_irq_and_dma(dev, it);
 
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)

commit 10f3a2dca81ace26daacf26c5d79c5876576e7ea
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:36 2015 -0700

    staging: comedi: ni_at_a2150: introduce a2150_isadma_disable()
    
    Introduce a helper function to disable and the ISA DMA controller and
    return the residue as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 23c59cb9412f..73768d0cbfe0 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -172,12 +172,24 @@ static void a2150_isadma_program(struct a2150_dma_desc *dma)
 	release_dma_lock(flags);
 }
 
+static unsigned int a2150_isadma_disable(struct a2150_dma_desc *dma)
+{
+	unsigned long flags;
+	unsigned int residue;
+
+	flags = claim_dma_lock();
+	disable_dma(dma->chan);
+	residue = get_dma_residue(dma->chan);
+	release_dma_lock(flags);
+
+	return residue;
+}
+
 /* interrupt service routine */
 static irqreturn_t a2150_interrupt(int irq, void *d)
 {
 	int i;
 	int status;
-	unsigned long flags;
 	struct comedi_device *dev = d;
 	struct a2150_private *devpriv = dev->private;
 	struct a2150_dma_desc *dma = &devpriv->dma_desc;
@@ -217,21 +229,16 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(dma->chan);
-
-	/*  figure out how many points to read */
-	max_points = comedi_bytes_to_samples(s, dma->size);
-	/* residue is the number of points left to be done on the dma
+	/*
+	 * residue is the number of bytes left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
 	 * the stop_src is set to external triggering.
 	 */
-	residue = comedi_bytes_to_samples(s, get_dma_residue(dma->chan));
-	release_dma_lock(flags);
-	num_points = max_points - residue;
+	residue = a2150_isadma_disable(dma);
+
+	/*  figure out how many points to read */
+	max_points = comedi_bytes_to_samples(s, dma->size);
+	num_points = max_points - comedi_bytes_to_samples(s, residue);
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
@@ -288,7 +295,7 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
 	/*  disable computer's dma */
-	disable_dma(dma->chan);
+	a2150_isadma_disable(dma);
 
 	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
@@ -524,7 +531,6 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long timer_base = dev->iobase + I8253_BASE_REG;
-	unsigned long lock_flags;
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;
 
@@ -560,9 +566,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
-	lock_flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	release_dma_lock(lock_flags);
+	a2150_isadma_disable(dma);
 
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
@@ -730,7 +734,7 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 	dma->chan = dma_chan;
 	devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) | DMA_CHAN_BITS(dma_chan);
 
-	disable_dma(dma_chan);
+	a2150_isadma_disable(dma);
 }
 
 static void a2150_free_dma(struct comedi_device *dev)

commit c92b0b29819bc2b3f504b8341b26bb7c1421ad22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:35 2015 -0700

    staging: comedi: ni_at_a2150: introduce a2150_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 3905097ef6d8..23c59cb9412f 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -159,6 +159,19 @@ struct a2150_private {
 	int config_bits;	/*  config register bits */
 };
 
+static void a2150_isadma_program(struct a2150_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma->chan);
+	set_dma_mode(dma->chan, DMA_MODE_READ);
+	set_dma_addr(dma->chan, dma->hw_addr);
+	set_dma_count(dma->chan, dma->size);
+	enable_dma(dma->chan);
+	release_dma_lock(flags);
+}
+
 /* interrupt service routine */
 static irqreturn_t a2150_interrupt(int irq, void *d)
 {
@@ -217,6 +230,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	 * the stop_src is set to external triggering.
 	 */
 	residue = comedi_bytes_to_samples(s, get_dma_residue(dma->chan));
+	release_dma_lock(flags);
 	num_points = max_points - residue;
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
@@ -250,14 +264,11 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 			}
 		}
 	}
-	/*  re-enable  dma */
+	/* re-enable dma */
 	if (leftover) {
-		set_dma_addr(dma->chan, dma->hw_addr);
-		set_dma_count(dma->chan,
-			      comedi_samples_to_bytes(s, leftover));
-		enable_dma(dma->chan);
+		dma->size = comedi_samples_to_bytes(s, leftover);
+		a2150_isadma_program(dma);
 	}
-	release_dma_lock(flags);
 
 	comedi_handle_events(dev, s);
 
@@ -549,13 +560,10 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
-	/*  enable computer's dma */
 	lock_flags = claim_dma_lock();
 	disable_dma(dma->chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, dma->hw_addr);
+	release_dma_lock(lock_flags);
+
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	dma->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
@@ -565,9 +573,8 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (dma->size < comedi_bytes_per_sample(s))
 		dma->size = comedi_bytes_per_sample(s);
 	dma->size -= dma->size % comedi_bytes_per_sample(s);
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
-	release_dma_lock(lock_flags);
+
+	a2150_isadma_program(dma);
 
 	/* clear dma interrupt before enabling it, to try and get rid of that
 	 * one spurious interrupt that has been happening */
@@ -724,7 +731,6 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 	devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) | DMA_CHAN_BITS(dma_chan);
 
 	disable_dma(dma_chan);
-	set_dma_mode(dma_chan, DMA_MODE_READ);
 }
 
 static void a2150_free_dma(struct comedi_device *dev)

commit 6d26275177e9fb086273944b3e8fc51db5aff460
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:51 2015 -0700

    staging: comedi: ni_at_a2150: remove VIRT_TO_BUS dependancy
    
    Use dma_{alloc,free}_coherent() to allocate and free the DMA buffers.
    This removes the dependancy on VIRT_TO_BUS.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index a1300e0b7900..3905097ef6d8 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -147,7 +147,8 @@ static const struct a2150_board a2150_boards[] = {
 
 struct a2150_dma_desc {
 	unsigned int chan;	/* DMA channel */
-	uint16_t *virt_addr;	/* virtual address of DMA buffer */
+	void *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 	unsigned int size;	/* size of DMA transfer (in bytes) */
 };
 
@@ -170,6 +171,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
+	unsigned short *buf = dma->virt_addr;
 	unsigned int max_points, num_points, residue, leftover;
 	unsigned short dpnt;
 
@@ -237,7 +239,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 	for (i = 0; i < num_points; i++) {
 		/* write data point to comedi buffer */
-		dpnt = dma->virt_addr[i];
+		dpnt = buf[i];
 		/*  convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
 		comedi_buf_write_samples(s, &dpnt, 1);
@@ -250,7 +252,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 	/*  re-enable  dma */
 	if (leftover) {
-		set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+		set_dma_addr(dma->chan, dma->hw_addr);
 		set_dma_count(dma->chan,
 			      comedi_samples_to_bytes(s, leftover));
 		enable_dma(dma->chan);
@@ -553,7 +555,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
 	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_addr(dma->chan, dma->hw_addr);
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	dma->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
@@ -709,7 +711,8 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 		free_irq(irq_num, dev);
 		return;
 	}
-	dma->virt_addr = kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+	dma->virt_addr = dma_alloc_coherent(NULL, A2150_DMA_BUFFER_SIZE,
+					    &dma->hw_addr, GFP_KERNEL);
 	if (!dma->virt_addr) {
 		free_dma(dma_chan);
 		free_irq(irq_num, dev);
@@ -735,7 +738,9 @@ static void a2150_free_dma(struct comedi_device *dev)
 	dma = &devpriv->dma_desc;
 	if (dma->chan)
 		free_dma(dma->chan);
-	kfree(dma->virt_addr);
+	if (dma->virt_addr)
+		dma_free_coherent(NULL, A2150_DMA_BUFFER_SIZE,
+				  dma->virt_addr, dma->hw_addr);
 }
 
 /* probes board type, returns offset */

commit 5bf7d295610a0789dc649e4e45714fecd7d042b4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:50 2015 -0700

    staging: comedi: ni_at_a2150: introduce struct a2150_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index de2e87780de9..a1300e0b7900 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -145,11 +145,15 @@ static const struct a2150_board a2150_boards[] = {
 	 },
 };
 
+struct a2150_dma_desc {
+	unsigned int chan;	/* DMA channel */
+	uint16_t *virt_addr;	/* virtual address of DMA buffer */
+	unsigned int size;	/* size of DMA transfer (in bytes) */
+};
+
 struct a2150_private {
+	struct a2150_dma_desc dma_desc;
 	unsigned int count;	/* number of data points left to be taken */
-	unsigned int dma;	/*  dma channel */
-	uint16_t *dma_buffer;	/*  dma buffer */
-	unsigned int dma_transfer_size;	/*  size in bytes of dma transfers */
 	int irq_dma_bits;	/*  irq/dma register bits */
 	int config_bits;	/*  config register bits */
 };
@@ -162,6 +166,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	unsigned long flags;
 	struct comedi_device *dev = d;
 	struct a2150_private *devpriv = dev->private;
+	struct a2150_dma_desc *dma = &devpriv->dma_desc;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
@@ -198,18 +203,18 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 
 	flags = claim_dma_lock();
-	disable_dma(devpriv->dma);
+	disable_dma(dma->chan);
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma);
+	clear_dma_ff(dma->chan);
 
 	/*  figure out how many points to read */
-	max_points = comedi_bytes_to_samples(s, devpriv->dma_transfer_size);
+	max_points = comedi_bytes_to_samples(s, dma->size);
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
 	 * the stop_src is set to external triggering.
 	 */
-	residue = comedi_bytes_to_samples(s, get_dma_residue(devpriv->dma));
+	residue = comedi_bytes_to_samples(s, get_dma_residue(dma->chan));
 	num_points = max_points - residue;
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
@@ -217,8 +222,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
-		leftover = comedi_bytes_to_samples(s,
-						   devpriv->dma_transfer_size);
+		leftover = comedi_bytes_to_samples(s, dma->size);
 	} else if (devpriv->count > max_points) {
 		leftover = devpriv->count - max_points;
 		if (leftover > max_points)
@@ -233,7 +237,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 	for (i = 0; i < num_points; i++) {
 		/* write data point to comedi buffer */
-		dpnt = devpriv->dma_buffer[i];
+		dpnt = dma->virt_addr[i];
 		/*  convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
 		comedi_buf_write_samples(s, &dpnt, 1);
@@ -246,10 +250,10 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 	/*  re-enable  dma */
 	if (leftover) {
-		set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
-		set_dma_count(devpriv->dma,
+		set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+		set_dma_count(dma->chan,
 			      comedi_samples_to_bytes(s, leftover));
-		enable_dma(devpriv->dma);
+		enable_dma(dma->chan);
 	}
 	release_dma_lock(flags);
 
@@ -264,13 +268,14 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct a2150_private *devpriv = dev->private;
+	struct a2150_dma_desc *dma = &devpriv->dma_desc;
 
 	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
 	/*  disable computer's dma */
-	disable_dma(devpriv->dma);
+	disable_dma(dma->chan);
 
 	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
@@ -502,6 +507,7 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct a2150_private *devpriv = dev->private;
+	struct a2150_dma_desc *dma = &devpriv->dma_desc;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long timer_base = dev->iobase + I8253_BASE_REG;
@@ -543,24 +549,22 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  enable computer's dma */
 	lock_flags = claim_dma_lock();
-	disable_dma(devpriv->dma);
+	disable_dma(dma->chan);
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma);
-	set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
+	clear_dma_ff(dma->chan);
+	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
-	devpriv->dma_transfer_size =
-	    comedi_bytes_per_sample(s) * cmd->chanlist_len *
-	    ONE_THIRD_SECOND / cmd->scan_begin_arg;
-	if (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)
-		devpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;
-	if (devpriv->dma_transfer_size < comedi_bytes_per_sample(s))
-		devpriv->dma_transfer_size = comedi_bytes_per_sample(s);
-	devpriv->dma_transfer_size -=
-	    devpriv->dma_transfer_size % comedi_bytes_per_sample(s);
-	set_dma_count(devpriv->dma, devpriv->dma_transfer_size);
-	enable_dma(devpriv->dma);
+	dma->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *
+		    ONE_THIRD_SECOND / cmd->scan_begin_arg;
+	if (dma->size > A2150_DMA_BUFFER_SIZE)
+		dma->size = A2150_DMA_BUFFER_SIZE;
+	if (dma->size < comedi_bytes_per_sample(s))
+		dma->size = comedi_bytes_per_sample(s);
+	dma->size -= dma->size % comedi_bytes_per_sample(s);
+	set_dma_count(dma->chan, dma->size);
+	enable_dma(dma->chan);
 	release_dma_lock(lock_flags);
 
 	/* clear dma interrupt before enabling it, to try and get rid of that
@@ -680,6 +684,7 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 				struct comedi_devconfig *it)
 {
 	struct a2150_private *devpriv = dev->private;
+	struct a2150_dma_desc *dma = &devpriv->dma_desc;
 	unsigned int irq_num = it->options[1];
 	unsigned int dma_chan = it->options[2];
 
@@ -704,16 +709,15 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 		free_irq(irq_num, dev);
 		return;
 	}
-	devpriv->dma_buffer = kmalloc(A2150_DMA_BUFFER_SIZE,
-				      GFP_KERNEL | GFP_DMA);
-	if (!devpriv->dma_buffer) {
+	dma->virt_addr = kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+	if (!dma->virt_addr) {
 		free_dma(dma_chan);
 		free_irq(irq_num, dev);
 		return;
 	}
 
 	dev->irq = irq_num;
-	devpriv->dma = dma_chan;
+	dma->chan = dma_chan;
 	devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) | DMA_CHAN_BITS(dma_chan);
 
 	disable_dma(dma_chan);
@@ -723,13 +727,15 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 static void a2150_free_dma(struct comedi_device *dev)
 {
 	struct a2150_private *devpriv = dev->private;
+	struct a2150_dma_desc *dma;
 
 	if (!devpriv)
 		return;
 
-	if (devpriv->dma)
-		free_dma(devpriv->dma);
-	kfree(devpriv->dma_buffer);
+	dma = &devpriv->dma_desc;
+	if (dma->chan)
+		free_dma(dma->chan);
+	kfree(dma->virt_addr);
 }
 
 /* probes board type, returns offset */

commit b1478901b677dd430f4e97989f7f6e2dc8e54556
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jan 12 10:55:49 2015 -0700

    staging: comedi: ni_at_a2150: introduce a2150_free_dma()
    
    For aesthetics, introduce a helper function to free the DMA channel and
    buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 11b168156a6a..de2e87780de9 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -720,6 +720,18 @@ static void a2150_alloc_irq_dma(struct comedi_device *dev,
 	set_dma_mode(dma_chan, DMA_MODE_READ);
 }
 
+static void a2150_free_dma(struct comedi_device *dev)
+{
+	struct a2150_private *devpriv = dev->private;
+
+	if (!devpriv)
+		return;
+
+	if (devpriv->dma)
+		free_dma(devpriv->dma);
+	kfree(devpriv->dma_buffer);
+}
+
 /* probes board type, returns offset */
 static int a2150_probe(struct comedi_device *dev)
 {
@@ -808,15 +820,9 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void a2150_detach(struct comedi_device *dev)
 {
-	struct a2150_private *devpriv = dev->private;
-
 	if (dev->iobase)
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
-	if (devpriv) {
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		kfree(devpriv->dma_buffer);
-	}
+	a2150_free_dma(dev);
 	comedi_legacy_detach(dev);
 };
 

commit 7cbb0ef93a63f7c0574d852607af71f348ccc751
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jan 12 10:55:48 2015 -0700

    staging: comedi: ni_at_a2150: introduce a2150_alloc_irq_dma()
    
    This driver requires an IRQ and DMA in order to support async commands.
    
    For aesthetics, introduce a helper function to request the IRQ and DMA
    channels and allocate the DMA buffer. Since the async command support
    is optional, make the helper function handle any request/allocation
    errors and allow the driver to still attach without async command support.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 7380dac9215c..11b168156a6a 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -676,6 +676,50 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
+static void a2150_alloc_irq_dma(struct comedi_device *dev,
+				struct comedi_devconfig *it)
+{
+	struct a2150_private *devpriv = dev->private;
+	unsigned int irq_num = it->options[1];
+	unsigned int dma_chan = it->options[2];
+
+	/*
+	 * Only IRQs 15, 14, 12-9, and 7-3 are valid.
+	 * Only DMA channels 7-5 and 3-0 are valid.
+	 *
+	 * Both must be valid for async command support.
+	 */
+	if (irq_num > 15 || dma_chan > 7 ||
+	    !((1 << irq_num) & 0xdef8) || !((1 << dma_chan) & 0xef))
+		return;
+
+	/*
+	 * Request the IRQ and DMA channels and allocate the DMA buffer.
+	 * If the requests or allocation fail async command supprt will
+	 * not be available.
+	 */
+	if (request_irq(irq_num, a2150_interrupt, 0, dev->board_name, dev))
+		return;
+	if (request_dma(dma_chan, dev->board_name)) {
+		free_irq(irq_num, dev);
+		return;
+	}
+	devpriv->dma_buffer = kmalloc(A2150_DMA_BUFFER_SIZE,
+				      GFP_KERNEL | GFP_DMA);
+	if (!devpriv->dma_buffer) {
+		free_dma(dma_chan);
+		free_irq(irq_num, dev);
+		return;
+	}
+
+	dev->irq = irq_num;
+	devpriv->dma = dma_chan;
+	devpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) | DMA_CHAN_BITS(dma_chan);
+
+	disable_dma(dma_chan);
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+}
+
 /* probes board type, returns offset */
 static int a2150_probe(struct comedi_device *dev)
 {
@@ -689,8 +733,6 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct a2150_board *thisboard;
 	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
-	unsigned int irq = it->options[1];
-	unsigned int dma = it->options[2];
 	static const int timeout = 2000;
 	int i;
 	int ret;
@@ -711,31 +753,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
-	if ((irq >= 3 && irq <= 7) || (irq >= 9 && irq <= 12) ||
-	    irq == 14 || irq == 15) {
-		ret = request_irq(irq, a2150_interrupt, 0,
-				  dev->board_name, dev);
-		if (ret == 0) {
-			devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
-			dev->irq = irq;
-		}
-	}
-
-	if (dev->irq && dma <= 7 && dma != 4) {
-		ret = request_dma(dma, dev->board_name);
-		if (ret == 0) {
-			devpriv->dma = dma;
-			devpriv->dma_buffer = kmalloc(A2150_DMA_BUFFER_SIZE,
-						      GFP_KERNEL | GFP_DMA);
-			if (!devpriv->dma_buffer)
-				return -ENOMEM;
-
-			disable_dma(dma);
-			set_dma_mode(dma, DMA_MODE_READ);
-
-			devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
-		}
-	}
+	a2150_alloc_irq_dma(dev, it);
 
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)
@@ -749,7 +767,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = 0xffff;
 	s->range_table = &range_a2150;
 	s->insn_read = a2150_ai_rinsn;
-	if (dev->irq && devpriv->dma) {
+	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
 		s->len_chanlist = s->n_chan;

commit 2447a27c877a1a4995a85eb4bc456551c0c5a5f9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jan 12 10:55:47 2015 -0700

    staging: comedi: ni_at_a2150: use comedi_bytes_per_sample()
    
    For aesthetics, use the helper function to get the byte size of each sample
    instead of using sizeof() the first buffer element.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 8265322d4d4c..7380dac9215c 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -551,14 +551,14 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	devpriv->dma_transfer_size =
-	    sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
+	    comedi_bytes_per_sample(s) * cmd->chanlist_len *
 	    ONE_THIRD_SECOND / cmd->scan_begin_arg;
 	if (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)
 		devpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;
-	if (devpriv->dma_transfer_size < sizeof(devpriv->dma_buffer[0]))
-		devpriv->dma_transfer_size = sizeof(devpriv->dma_buffer[0]);
+	if (devpriv->dma_transfer_size < comedi_bytes_per_sample(s))
+		devpriv->dma_transfer_size = comedi_bytes_per_sample(s);
 	devpriv->dma_transfer_size -=
-	    devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
+	    devpriv->dma_transfer_size % comedi_bytes_per_sample(s);
 	set_dma_count(devpriv->dma, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma);
 	release_dma_lock(lock_flags);

commit 45478548425cc84d2d39cdac9daf446e5744877d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:46 2015 -0700

    staging: comedi: ni_at_a2150: remove 'volatile' from private data variable
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...", the 'count' member of the private data does not need to
    be volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 69e543a0bf22..8265322d4d4c 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -146,8 +146,7 @@ static const struct a2150_board a2150_boards[] = {
 };
 
 struct a2150_private {
-
-	volatile unsigned int count;	/* number of data points left to be taken */
+	unsigned int count;	/* number of data points left to be taken */
 	unsigned int dma;	/*  dma channel */
 	uint16_t *dma_buffer;	/*  dma buffer */
 	unsigned int dma_transfer_size;	/*  size in bytes of dma transfers */

commit 26561101b8c82a9eaf5656e3109b0d94f790fcdb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:36 2014 -0700

    staging: comedi: ni_at_a2150: use sample manipulation helpers
    
    Use the recently added sample manipulation helpers to remove the hardcoded
    assumption of the sample size.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 5c17def29f8d..69e543a0bf22 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -168,7 +168,6 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	struct comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
 	unsigned short dpnt;
-	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
 
 	if (!dev->attached) {
 		dev_err(dev->class_dev, "premature interrupt\n");
@@ -206,12 +205,12 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	clear_dma_ff(devpriv->dma);
 
 	/*  figure out how many points to read */
-	max_points = devpriv->dma_transfer_size / sample_size;
+	max_points = comedi_bytes_to_samples(s, devpriv->dma_transfer_size);
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
 	 * the stop_src is set to external triggering.
 	 */
-	residue = get_dma_residue(devpriv->dma) / sample_size;
+	residue = comedi_bytes_to_samples(s, get_dma_residue(devpriv->dma));
 	num_points = max_points - residue;
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
@@ -219,7 +218,8 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
-		leftover = devpriv->dma_transfer_size / sample_size;
+		leftover = comedi_bytes_to_samples(s,
+						   devpriv->dma_transfer_size);
 	} else if (devpriv->count > max_points) {
 		leftover = devpriv->count - max_points;
 		if (leftover > max_points)
@@ -248,7 +248,8 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	/*  re-enable  dma */
 	if (leftover) {
 		set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
-		set_dma_count(devpriv->dma, leftover * sample_size);
+		set_dma_count(devpriv->dma,
+			      comedi_samples_to_bytes(s, leftover));
 		enable_dma(devpriv->dma);
 	}
 	release_dma_lock(flags);

commit 7138e892a627215fad394160808d2084b51456d8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:28 2014 -0700

    staging: comedi: ni_at_a2150: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() instead of cfc_write_to_buffer() to add the
    single sample to the async buffer.
    
    The core will add the COMEDI_CB_BLOCK event when data is written to the
    async buffer. Remove the unnecessary event in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index f1fe9efda6df..5c17def29f8d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -237,7 +237,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 		dpnt = devpriv->dma_buffer[i];
 		/*  convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
-		cfc_write_to_buffer(s, dpnt);
+		comedi_buf_write_samples(s, &dpnt, 1);
 		if (cmd->stop_src == TRIG_COUNT) {
 			if (--devpriv->count == 0) {	/* end of acquisition */
 				async->events |= COMEDI_CB_EOA;
@@ -253,8 +253,6 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 	release_dma_lock(flags);
 
-	async->events |= COMEDI_CB_BLOCK;
-
 	comedi_handle_events(dev, s);
 
 	/* clear interrupt */

commit 4a706e2e2de33db474c67a7011c29326d2891693
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:28 2014 -0700

    staging: comedi: ni_at_a2150: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 72ec857d073e..f1fe9efda6df 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -188,14 +188,14 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	if (status & OVFL_BIT) {
 		dev_err(dev->class_dev, "fifo overflow\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
+		comedi_handle_events(dev, s);
 	}
 
 	if ((status & DMA_TC_BIT) == 0) {
 		dev_err(dev->class_dev,
 			"caught non-dma interrupt?  Aborting.\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
+		comedi_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}
 
@@ -255,7 +255,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 	async->events |= COMEDI_CB_BLOCK;
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 
 	/* clear interrupt */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);

commit 02cf9703e183424c0a1766b9581daa433ce342d2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:38 2014 +0100

    staging: comedi: ni_at_a2150: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index d4904907bb89..72ec857d073e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -287,7 +287,7 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    unsigned int flags)
 {
-	const struct a2150_board *thisboard = comedi_board(dev);
+	const struct a2150_board *thisboard = dev->board_ptr;
 	struct a2150_private *devpriv = dev->private;
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
@@ -436,7 +436,7 @@ static int a2150_ai_check_chanlist(struct comedi_device *dev,
 static int a2150_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	const struct a2150_board *thisboard = comedi_board(dev);
+	const struct a2150_board *thisboard = dev->board_ptr;
 	int err = 0;
 	unsigned int arg;
 
@@ -710,7 +710,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENODEV;
 
 	dev->board_ptr = a2150_boards + i;
-	thisboard = comedi_board(dev);
+	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
 	if ((irq >= 3 && irq <= 7) || (irq >= 9 && irq <= 12) ||

commit b544bd69cb8141ce2bb3ccbfb4f88afa2d7cc07e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:55 2014 +0100

    staging: comedi: ni_at_a2150: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4ff412d5e71d..d4904907bb89 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -326,8 +326,8 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			}
 		}
 	}
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_NEAREST:
+	switch (flags & CMDF_ROUND_MASK) {
+	case CMDF_ROUND_NEAREST:
 	default:
 		/*  if least upper bound is better approximation */
 		if (lub - *period < *period - glb)
@@ -335,10 +335,10 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 		else
 			*period = glb;
 		break;
-	case TRIG_ROUND_UP:
+	case CMDF_ROUND_UP:
 		*period = lub;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		*period = glb;
 		break;
 	}

commit 34ae4160504a82891208eaf8599ec432f340e169
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:27 2014 +0100

    staging: comedi: ni_at_a2150: use CMDF_PRIORITY
    
    Replace use of `TRIG_RT` command flag with the equivalent flag
    `CMDF_PRIORITY`.  The numeric value is unchanged.  Also replace
    "TRIG_RT" with "CMDF_PRIORITY" in the kernel messages.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 32e7bf277781..4ff412d5e71d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -511,9 +511,9 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;
 
-	if (cmd->flags & TRIG_RT) {
+	if (cmd->flags & CMDF_PRIORITY) {
 		dev_err(dev->class_dev,
-			"dma incompatible with hard real-time interrupt (TRIG_RT), aborting\n");
+			"dma incompatible with hard real-time interrupt (CMDF_PRIORITY), aborting\n");
 		return -1;
 	}
 	/*  clear fifo and reset triggering circuitry */

commit e988e1f3f975a9d6013c6356c5b9369540c091f9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 1 14:13:30 2014 +0100

    staging: comedi: ni_at_a2150: range check board index
    
    The "ni_at_a2150" driver determines the board type by calling
    `a2150_probe()`.  This reads a register and converts it to a board index
    in the range 0 to 3.  However, the board table array it indexes into
    (`a2150_boards[]`) only has 2 entries.  Return an error from the
    Comedi driver "attach" handler `a2150_attach()` if the probed board
    index is beyond the end of the array.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index de67161f6185..32e7bf277781 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -705,7 +705,11 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	dev->board_ptr = a2150_boards + a2150_probe(dev);
+	i = a2150_probe(dev);
+	if (i >= ARRAY_SIZE(a2150_boards))
+		return -ENODEV;
+
+	dev->board_ptr = a2150_boards + i;
 	thisboard = comedi_board(dev);
 	dev->board_name = thisboard->name;
 

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 76fed317403e..de67161f6185 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -71,7 +71,6 @@ TRIG_WAKE_EOS
 #include "8253.h"
 #include "comedi_fc.h"
 
-#define A2150_SIZE           28
 #define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
 /* Registers and bits */
@@ -702,7 +701,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!devpriv)
 		return -ENOMEM;
 
-	ret = comedi_request_region(dev, it->options[0], A2150_SIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x1c);
 	if (ret)
 		return ret;
 

commit c9bef032de05fb93ded8c20a0c66eae70e2b83d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:17 2014 -0700

    staging: comedi: ni_at_a2150: remove forward declarations
    
    Move some of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 0638c1ac8cbf..76fed317403e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -156,13 +156,6 @@ struct a2150_private {
 	int config_bits;	/*  config register bits */
 };
 
-static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-
-static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-			    unsigned int flags);
-static int a2150_set_chanlist(struct comedi_device *dev,
-			      unsigned int start_channel,
-			      unsigned int num_channels);
 /* interrupt service routine */
 static irqreturn_t a2150_interrupt(int irq, void *d)
 {
@@ -288,6 +281,117 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+/*
+ * sets bits in devpriv->clock_bits to nearest approximation of requested
+ * period, adjusts requested period to actual timing.
+ */
+static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
+			    unsigned int flags)
+{
+	const struct a2150_board *thisboard = comedi_board(dev);
+	struct a2150_private *devpriv = dev->private;
+	int lub, glb, temp;
+	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
+	int i, j;
+
+	/*  initialize greatest lower and least upper bounds */
+	lub_divisor_shift = 3;
+	lub_index = 0;
+	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
+	glb_divisor_shift = 0;
+	glb_index = thisboard->num_clocks - 1;
+	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
+
+	/*  make sure period is in available range */
+	if (*period < glb)
+		*period = glb;
+	if (*period > lub)
+		*period = lub;
+
+	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
+	for (i = 0; i < 4; i++) {
+		/*  there are a maximum of 4 master clocks */
+		for (j = 0; j < thisboard->num_clocks; j++) {
+			/*  temp is the period in nanosec we are evaluating */
+			temp = thisboard->clock[j] * (1 << i);
+			/*  if it is the best match yet */
+			if (temp < lub && temp >= *period) {
+				lub_divisor_shift = i;
+				lub_index = j;
+				lub = temp;
+			}
+			if (temp > glb && temp <= *period) {
+				glb_divisor_shift = i;
+				glb_index = j;
+				glb = temp;
+			}
+		}
+	}
+	switch (flags & TRIG_ROUND_MASK) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		/*  if least upper bound is better approximation */
+		if (lub - *period < *period - glb)
+			*period = lub;
+		else
+			*period = glb;
+		break;
+	case TRIG_ROUND_UP:
+		*period = lub;
+		break;
+	case TRIG_ROUND_DOWN:
+		*period = glb;
+		break;
+	}
+
+	/*  set clock bits for config register appropriately */
+	devpriv->config_bits &= ~CLOCK_MASK;
+	if (*period == lub) {
+		devpriv->config_bits |=
+		    CLOCK_SELECT_BITS(lub_index) |
+		    CLOCK_DIVISOR_BITS(lub_divisor_shift);
+	} else {
+		devpriv->config_bits |=
+		    CLOCK_SELECT_BITS(glb_index) |
+		    CLOCK_DIVISOR_BITS(glb_divisor_shift);
+	}
+
+	return 0;
+}
+
+static int a2150_set_chanlist(struct comedi_device *dev,
+			      unsigned int start_channel,
+			      unsigned int num_channels)
+{
+	struct a2150_private *devpriv = dev->private;
+
+	if (start_channel + num_channels > 4)
+		return -1;
+
+	devpriv->config_bits &= ~CHANNEL_MASK;
+
+	switch (num_channels) {
+	case 1:
+		devpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);
+		break;
+	case 2:
+		if (start_channel == 0)
+			devpriv->config_bits |= CHANNEL_BITS(0x2);
+		else if (start_channel == 2)
+			devpriv->config_bits |= CHANNEL_BITS(0x3);
+		else
+			return -1;
+		break;
+	case 4:
+		devpriv->config_bits |= CHANNEL_BITS(0x1);
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
 static int a2150_ai_check_chanlist(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_cmd *cmd)
@@ -575,117 +679,6 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-/*
- * sets bits in devpriv->clock_bits to nearest approximation of requested
- * period, adjusts requested period to actual timing.
- */
-static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-			    unsigned int flags)
-{
-	const struct a2150_board *thisboard = comedi_board(dev);
-	struct a2150_private *devpriv = dev->private;
-	int lub, glb, temp;
-	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
-	int i, j;
-
-	/*  initialize greatest lower and least upper bounds */
-	lub_divisor_shift = 3;
-	lub_index = 0;
-	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
-	glb_divisor_shift = 0;
-	glb_index = thisboard->num_clocks - 1;
-	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
-
-	/*  make sure period is in available range */
-	if (*period < glb)
-		*period = glb;
-	if (*period > lub)
-		*period = lub;
-
-	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
-	for (i = 0; i < 4; i++) {
-		/*  there are a maximum of 4 master clocks */
-		for (j = 0; j < thisboard->num_clocks; j++) {
-			/*  temp is the period in nanosec we are evaluating */
-			temp = thisboard->clock[j] * (1 << i);
-			/*  if it is the best match yet */
-			if (temp < lub && temp >= *period) {
-				lub_divisor_shift = i;
-				lub_index = j;
-				lub = temp;
-			}
-			if (temp > glb && temp <= *period) {
-				glb_divisor_shift = i;
-				glb_index = j;
-				glb = temp;
-			}
-		}
-	}
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_NEAREST:
-	default:
-		/*  if least upper bound is better approximation */
-		if (lub - *period < *period - glb)
-			*period = lub;
-		else
-			*period = glb;
-		break;
-	case TRIG_ROUND_UP:
-		*period = lub;
-		break;
-	case TRIG_ROUND_DOWN:
-		*period = glb;
-		break;
-	}
-
-	/*  set clock bits for config register appropriately */
-	devpriv->config_bits &= ~CLOCK_MASK;
-	if (*period == lub) {
-		devpriv->config_bits |=
-		    CLOCK_SELECT_BITS(lub_index) |
-		    CLOCK_DIVISOR_BITS(lub_divisor_shift);
-	} else {
-		devpriv->config_bits |=
-		    CLOCK_SELECT_BITS(glb_index) |
-		    CLOCK_DIVISOR_BITS(glb_divisor_shift);
-	}
-
-	return 0;
-}
-
-static int a2150_set_chanlist(struct comedi_device *dev,
-			      unsigned int start_channel,
-			      unsigned int num_channels)
-{
-	struct a2150_private *devpriv = dev->private;
-
-	if (start_channel + num_channels > 4)
-		return -1;
-
-	devpriv->config_bits &= ~CHANNEL_MASK;
-
-	switch (num_channels) {
-	case 1:
-		devpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);
-		break;
-	case 2:
-		if (start_channel == 0)
-			devpriv->config_bits |= CHANNEL_BITS(0x2);
-		else if (start_channel == 2)
-			devpriv->config_bits |= CHANNEL_BITS(0x3);
-		else
-			return -1;
-		break;
-	case 4:
-		devpriv->config_bits |= CHANNEL_BITS(0x1);
-		break;
-	default:
-		return -1;
-	}
-
-	return 0;
-}
-
 /* probes board type, returns offset */
 static int a2150_probe(struct comedi_device *dev)
 {

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c0ac8fd6ecab..0638c1ac8cbf 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -159,7 +159,7 @@ struct a2150_private {
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-			    int flags);
+			    unsigned int flags);
 static int a2150_set_chanlist(struct comedi_device *dev,
 			      unsigned int start_channel,
 			      unsigned int num_channels);
@@ -580,7 +580,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
  * period, adjusts requested period to actual timing.
  */
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-			    int flags)
+			    unsigned int flags)
 {
 	const struct a2150_board *thisboard = comedi_board(dev);
 	struct a2150_private *devpriv = dev->private;
@@ -621,8 +621,7 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			}
 		}
 	}
-	flags &= TRIG_ROUND_MASK;
-	switch (flags) {
+	switch (flags & TRIG_ROUND_MASK) {
 	case TRIG_ROUND_NEAREST:
 	default:
 		/*  if least upper bound is better approximation */

commit bc0640a7957cd5928e93d350cd49009f4774b2fd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 13:29:56 2014 -0700

    staging: comedi: ni_at_a2150: convert printk to dev_err
    
    Convert the printk() message to dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 86c05e382d09..c0ac8fd6ecab 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -785,8 +785,8 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		udelay(1000);
 	}
 	if (i == timeout) {
-		printk
-		    (" timed out waiting for offset calibration to complete\n");
+		dev_err(dev->class_dev,
+			"timed out waiting for offset calibration to complete\n");
 		return -ETIME;
 	}
 	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;

commit 770bc73dc5d030d26e5179b819bdcf021ff5d6e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:35 2014 -0700

    staging: comedi: ni_at_a2150: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 465c729ee685..86c05e382d09 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -179,7 +179,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
 
 	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
+		dev_err(dev->class_dev, "premature interrupt\n");
 		return IRQ_HANDLED;
 	}
 	/*  initialize async here to make sure s is not NULL */
@@ -189,18 +189,19 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	status = inw(dev->iobase + STATUS_REG);
 
 	if ((status & INTR_BIT) == 0) {
-		comedi_error(dev, "spurious interrupt");
+		dev_err(dev->class_dev, "spurious interrupt\n");
 		return IRQ_NONE;
 	}
 
 	if (status & OVFL_BIT) {
-		comedi_error(dev, "fifo overflow");
+		dev_err(dev->class_dev, "fifo overflow\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 	}
 
 	if ((status & DMA_TC_BIT) == 0) {
-		comedi_error(dev, "caught non-dma interrupt?  Aborting.");
+		dev_err(dev->class_dev,
+			"caught non-dma interrupt?  Aborting.\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		return IRQ_HANDLED;
@@ -408,8 +409,8 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int trigger_bits;
 
 	if (cmd->flags & TRIG_RT) {
-		comedi_error(dev,
-			     " dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
+		dev_err(dev->class_dev,
+			"dma incompatible with hard real-time interrupt (TRIG_RT), aborting\n");
 		return -1;
 	}
 	/*  clear fifo and reset triggering circuitry */
@@ -490,7 +491,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		trigger_bits |= HW_TRIG_EN;
 	} else if (cmd->start_src == TRIG_OTHER) {
 		/*  XXX add support for level/slope start trigger using TRIG_OTHER */
-		comedi_error(dev, "you shouldn't see this?");
+		dev_err(dev->class_dev, "you shouldn't see this?\n");
 	}
 	/*  send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);

commit a95b7ccf594feddbd47500d1d713ff8d883edcb7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:02:03 2014 -0700

    staging: comedi: ni_at_a2150: checkpatch.pl cleanup (missing blank line)
    
    Fix the checkpatch.pl warning:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index a862dc33444b..465c729ee685 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -690,6 +690,7 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 static int a2150_probe(struct comedi_device *dev)
 {
 	int status = inw(dev->iobase + STATUS_REG);
+
 	return ID_BITS(status);
 }
 

commit 1c404be2b3a6d90141b20d7433e65bc2a5fc4b3e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:26 2014 -0700

    staging: comedi: ni_at_a2150: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 5bd19494dbf6..a862dc33444b 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -681,7 +681,6 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 		break;
 	default:
 		return -1;
-		break;
 	}
 
 	return 0;

commit 75cff543a5c9a4a8b553359024f58f1bc6be4988
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:51 2014 -0700

    staging: comedi: ni_at_a2150: use comedi_fc helpers to validate timer arg
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger argument when the source is TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index f8d6bfce17e6..5bd19494dbf6 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -334,7 +334,7 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 {
 	const struct a2150_board *thisboard = comedi_board(dev);
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -379,10 +379,9 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
-		a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+		arg = cmd->scan_begin_arg;
+		a2150_get_timing(dev, &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit 22e09dff089fe93d6e3ef7cc0fb8f645a87153c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:57 2014 -0700

    staging: comedi: ni_at_a2150: clarify 8254 timer programming
    
    Refactor the 8254 timer programming to use the i8254_set_mode()
    and i8254_write() helpers instead of i8254_load(). This allows
    us to use the I8254_MODE* defines to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index fefd97e2344d..f8d6bfce17e6 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -403,6 +403,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct a2150_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned long timer_base = dev->iobase + I8253_BASE_REG;
 	unsigned long lock_flags;
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;
@@ -470,7 +471,8 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
 	/*  may need to wait 72 sampling periods if timing was changed */
-	i8254_load(dev->iobase + I8253_BASE_REG, 0, 2, 72, 0);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE0 | I8254_BINARY);
+	i8254_write(timer_base, 0, 2, 72);
 
 	/*  setup start triggering */
 	trigger_bits = 0;

commit 1d57261c96cf37949b87d9d239afb3734846d78e
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Sat Apr 26 16:04:29 2014 +0200

    staging: comedi: remove duplicate pointer assignments in attach functions
    
    Some board pointer are assigned twice via comedi_board() in the comedi low
    level driver attach functions. Remove the duplicate assignment from the
    variable definition where the pointer is not used anyway until assigned later
    in the function when dev->board_ptr, that comedi_board() relies on, is setup
    correctly.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index afbf251ba270..fefd97e2344d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -695,7 +695,7 @@ static int a2150_probe(struct comedi_device *dev)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct a2150_board *thisboard = comedi_board(dev);
+	const struct a2150_board *thisboard;
 	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];

commit 8f61419f1dc2def067e941e077f0f7cf0244f90e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:18 2014 -0700

    staging: comedi: ni_at_a2150: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input async command
    support. Tidy up the factored out code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4e39b1f63d81..afbf251ba270 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -287,14 +287,54 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int a2150_ai_check_chanlist(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
+	int i;
+
+	if (cmd->chanlist_len == 2 && (chan0 == 1 || chan0 == 3)) {
+		dev_dbg(dev->class_dev,
+			"length 2 chanlist must be channels 0,1 or channels 2,3\n");
+		return -EINVAL;
+	}
+
+	if (cmd->chanlist_len == 3) {
+		dev_dbg(dev->class_dev,
+			"chanlist must have 1,2 or 4 channels\n");
+		return -EINVAL;
+	}
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int aref = CR_AREF(cmd->chanlist[i]);
+
+		if (chan != (chan0 + i)) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must be consecutive channels, counting upwards\n");
+			return -EINVAL;
+		}
+
+		if (chan == 2)
+			aref0 = aref;
+		if (aref != aref0) {
+			dev_dbg(dev->class_dev,
+				"channels 0/1 and 2/3 must have the same analog reference\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int a2150_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	const struct a2150_board *thisboard = comedi_board(dev);
 	int err = 0;
 	int tmp;
-	int startChan;
-	int i;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -348,33 +388,9 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/*  check channel/gain list against card's limitations */
-	if (cmd->chanlist) {
-		startChan = CR_CHAN(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) != (startChan + i)) {
-				comedi_error(dev,
-					     "entries in chanlist must be consecutive channels, counting upwards\n");
-				err++;
-			}
-		}
-		if (cmd->chanlist_len == 2 && CR_CHAN(cmd->chanlist[0]) == 1) {
-			comedi_error(dev,
-				     "length 2 chanlist must be channels 0,1 or channels 2,3");
-			err++;
-		}
-		if (cmd->chanlist_len == 3) {
-			comedi_error(dev,
-				     "chanlist must have 1,2 or 4 channels");
-			err++;
-		}
-		if (CR_AREF(cmd->chanlist[0]) != CR_AREF(cmd->chanlist[1]) ||
-		    CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3])) {
-			comedi_error(dev,
-				     "channels 0/1 and 2/3 must have the same analog reference");
-			err++;
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= a2150_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit e5bdf51216fafe4d21121bad2f8a36371d4c8f88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:34 2014 -0700

    staging: comedi: ni_at_a2150: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Also, remove the clearing of the events, comedi_event() does that.
    
    In the Kconfig, COMEDI_NI_AT_A2150 already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 740f14994f97..4e39b1f63d81 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -184,7 +184,6 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	}
 	/*  initialize async here to make sure s is not NULL */
 	async = s->async;
-	async->events = 0;
 	cmd = &async->cmd;
 
 	status = inw(dev->iobase + STATUS_REG);
@@ -196,15 +195,14 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 	if (status & OVFL_BIT) {
 		comedi_error(dev, "fifo overflow");
-		a2150_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		cfc_handle_events(dev, s);
 	}
 
 	if ((status & DMA_TC_BIT) == 0) {
 		comedi_error(dev, "caught non-dma interrupt?  Aborting.");
-		a2150_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		return IRQ_HANDLED;
 	}
 
@@ -249,7 +247,6 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 		cfc_write_to_buffer(s, dpnt);
 		if (cmd->stop_src == TRIG_COUNT) {
 			if (--devpriv->count == 0) {	/* end of acquisition */
-				a2150_cancel(dev, s);
 				async->events |= COMEDI_CB_EOA;
 				break;
 			}
@@ -265,7 +262,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 	async->events |= COMEDI_CB_BLOCK;
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 
 	/* clear interrupt */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 07239c967f9d..740f14994f97 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -538,10 +538,8 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	 */
 	for (n = 0; n < 36; n++) {
 		ret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);
-		if (ret) {
-			comedi_error(dev, "timeout");
+		if (ret)
 			return ret;
-		}
 
 		inw(dev->iobase + FIFO_DATA_REG);
 	}
@@ -549,10 +547,8 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  read data */
 	for (n = 0; n < insn->n; n++) {
 		ret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);
-		if (ret) {
-			comedi_error(dev, "timeout");
+		if (ret)
 			return ret;
-		}
 
 		data[n] = inw(dev->iobase + FIFO_DATA_REG);
 		data[n] ^= 0x8000;

commit 33a6d44bbdf24d84833736ea691555f8c459f0c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:25 2014 -0700

    staging: comedi: ni_at_a2150: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index f83eb9ebe278..07239c967f9d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -488,13 +488,25 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int a2150_ai_eoc(struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned long context)
+{
+	unsigned int status;
+
+	status = inw(dev->iobase + STATUS_REG);
+	if (status & FNE_BIT)
+		return 0;
+	return -EBUSY;
+}
+
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
 	struct a2150_private *devpriv = dev->private;
-	unsigned int i, n;
-	static const int timeout = 100000;
-	static const int filter_delay = 36;
+	unsigned int n;
+	int ret;
 
 	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
@@ -524,30 +536,24 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	 * there is a 35.6 sample delay for data to get through the
 	 * antialias filter
 	 */
-	for (n = 0; n < filter_delay; n++) {
-		for (i = 0; i < timeout; i++) {
-			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
-				break;
-			udelay(1);
-		}
-		if (i == timeout) {
+	for (n = 0; n < 36; n++) {
+		ret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);
+		if (ret) {
 			comedi_error(dev, "timeout");
-			return -ETIME;
+			return ret;
 		}
+
 		inw(dev->iobase + FIFO_DATA_REG);
 	}
 
 	/*  read data */
 	for (n = 0; n < insn->n; n++) {
-		for (i = 0; i < timeout; i++) {
-			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
-				break;
-			udelay(1);
-		}
-		if (i == timeout) {
+		ret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);
+		if (ret) {
 			comedi_error(dev, "timeout");
-			return -ETIME;
+			return ret;
 		}
+
 		data[n] = inw(dev->iobase + FIFO_DATA_REG);
 		data[n] ^= 0x8000;
 	}

commit 168a21038a5fdc532dbbde7d546996441e2f37e7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:24 2013 -0700

    staging: comedi: ni_at_a2150: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Use the BIP_RANGE macro instead of the more generic RANGE macro to
    reduce the potential for typos.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 0c71fdfecac2..f83eb9ebe278 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -124,10 +124,9 @@ struct a2150_board {
 
 /* analog input range */
 static const struct comedi_lrange range_a2150 = {
-	1,
-	{
-	 RANGE(-2.828, 2.828),
-	 }
+	1, {
+		BIP_RANGE(2.828)
+	}
 };
 
 /* enum must match board indices */

commit 530376bfb7c82f50f20f9d28acd017194894eb66
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 11:32:58 2013 -0700

    staging: comedi: ni_at_a2150: fix an always true condition test
    
    As pointed out by the kbuild test robot, and Ian Abbott, the dma >= 0 test
    is always true because dma is unsigned. This generates a warn message:
    
    drivers/staging/comedi/drivers/ni_at_a2150.c:715 a2150_attach()
      warn: always true condition '(dma >= 0) => (0-u32max >= 0)'
    
    Fix the test as suggested by Ian Abbott.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 0876bc5c0209..0c71fdfecac2 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -712,7 +712,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	if (dev->irq && ((dma >= 0 && dma <= 4) || (dma >= 5 && dma <= 7))) {
+	if (dev->irq && dma <= 7 && dma != 4) {
 		ret = request_dma(dma, dev->board_name);
 		if (ret == 0) {
 			devpriv->dma = dma;

commit 6cb8e1a27ad7a966ba2cce1b968404b590943105
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:21 2013 -0700

    staging: comedi: ni_at_2150: tidy up irq/dma request
    
    This driver needs both an irq and dma in order to support async
    commands. If the irq and dma are not available the driver will
    still function for single analog input reads.
    
    Tidy up the code that does the irq and dma requests so that the
    driver will still attach if they are not avaliable. The attach
    will still fail, with -ENOMEM, if the dma buffer cannot be allocated.
    
    Remove the noise about the irq and dma during the attach.
    
    Only hook up the async commands support if the irq and dma are
    available. Remove the then unnecessary sanity check in a2150_ai_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index cc69ddef0a67..0876bc5c0209 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -395,11 +395,6 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;
 
-	if (!dev->irq || !devpriv->dma) {
-		comedi_error(dev,
-			     " irq and dma required, cannot do hardware conversions");
-		return -1;
-	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
 			     " dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
@@ -703,46 +698,35 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	/* grab our IRQ */
-	if (irq) {
-		/*  check that irq is supported */
-		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
-			printk(" invalid irq line %u\n", irq);
-			return -EINVAL;
-		}
-		if (request_irq(irq, a2150_interrupt, 0,
-				dev->driver->driver_name, dev)) {
-			printk("unable to allocate irq %u\n", irq);
-			return -EINVAL;
+	dev->board_ptr = a2150_boards + a2150_probe(dev);
+	thisboard = comedi_board(dev);
+	dev->board_name = thisboard->name;
+
+	if ((irq >= 3 && irq <= 7) || (irq >= 9 && irq <= 12) ||
+	    irq == 14 || irq == 15) {
+		ret = request_irq(irq, a2150_interrupt, 0,
+				  dev->board_name, dev);
+		if (ret == 0) {
+			devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
+			dev->irq = irq;
 		}
-		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
-		dev->irq = irq;
 	}
-	/*  initialize dma */
-	if (dma) {
-		if (dma == 4 || dma > 7) {
-			printk(" invalid dma channel %u\n", dma);
-			return -EINVAL;
-		}
-		if (request_dma(dma, dev->driver->driver_name)) {
-			printk(" failed to allocate dma channel %u\n", dma);
-			return -EINVAL;
-		}
-		devpriv->dma = dma;
-		devpriv->dma_buffer =
-		    kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer == NULL)
-			return -ENOMEM;
 
-		disable_dma(dma);
-		set_dma_mode(dma, DMA_MODE_READ);
+	if (dev->irq && ((dma >= 0 && dma <= 4) || (dma >= 5 && dma <= 7))) {
+		ret = request_dma(dma, dev->board_name);
+		if (ret == 0) {
+			devpriv->dma = dma;
+			devpriv->dma_buffer = kmalloc(A2150_DMA_BUFFER_SIZE,
+						      GFP_KERNEL | GFP_DMA);
+			if (!devpriv->dma_buffer)
+				return -ENOMEM;
 
-		devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
-	}
+			disable_dma(dma);
+			set_dma_mode(dma, DMA_MODE_READ);
 
-	dev->board_ptr = a2150_boards + a2150_probe(dev);
-	thisboard = comedi_board(dev);
-	dev->board_name = thisboard->name;
+			devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
+		}
+	}
 
 	ret = comedi_alloc_subdevices(dev, 1);
 	if (ret)
@@ -750,17 +734,20 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* analog input subdevice */
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER;
 	s->n_chan = 4;
-	s->len_chanlist = 4;
 	s->maxdata = 0xffff;
 	s->range_table = &range_a2150;
-	s->do_cmd = a2150_ai_cmd;
-	s->do_cmdtest = a2150_ai_cmdtest;
 	s->insn_read = a2150_ai_rinsn;
-	s->cancel = a2150_cancel;
+	if (dev->irq && devpriv->dma) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->len_chanlist = s->n_chan;
+		s->do_cmd = a2150_ai_cmd;
+		s->do_cmdtest = a2150_ai_cmdtest;
+		s->cancel = a2150_cancel;
+	}
 
 	/* need to do this for software counting of completed conversions, to
 	 * prevent hardware count from stopping acquisition */

commit 05d701b169411c32c89d4bea92c876d5c63f2e04
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:20 2013 -0700

    staging: comedi: ni_at_a2150: remove A2150_DEBUG
    
    The A2150_DEBUG define enables some development messages, specifically
    the ni_dum_regs() function. These messages are just added noise. Remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 63c847932eb8..cc69ddef0a67 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -74,9 +74,6 @@ TRIG_WAKE_EOS
 #define A2150_SIZE           28
 #define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
-/* #define A2150_DEBUG     enable debugging code */
-#undef A2150_DEBUG		/*  disable debugging code */
-
 /* Registers and bits */
 #define CONFIG_REG		0x0
 #define   CHANNEL_BITS(x)		((x) & 0x7)
@@ -167,19 +164,6 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 static int a2150_set_chanlist(struct comedi_device *dev,
 			      unsigned int start_channel,
 			      unsigned int num_channels);
-#ifdef A2150_DEBUG
-
-static void ni_dump_regs(struct comedi_device *dev)
-{
-	struct a2150_private *devpriv = dev->private;
-
-	printk("config bits 0x%x\n", devpriv->config_bits);
-	printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
-	printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
-}
-
-#endif
-
 /* interrupt service routine */
 static irqreturn_t a2150_interrupt(int irq, void *d)
 {
@@ -506,9 +490,6 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  start acquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW)
 		outw(0, dev->iobase + FIFO_START_REG);
-#ifdef A2150_DEBUG
-	ni_dump_regs(dev);
-#endif
 
 	return 0;
 }
@@ -573,13 +554,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			comedi_error(dev, "timeout");
 			return -ETIME;
 		}
-#ifdef A2150_DEBUG
-		ni_dump_regs(dev);
-#endif
 		data[n] = inw(dev->iobase + FIFO_DATA_REG);
-#ifdef A2150_DEBUG
-		printk(" data is %i\n", data[n]);
-#endif
 		data[n] ^= 0x8000;
 	}
 

commit 2fb5cd385cb7ed56ce1ffd24264c3d5584972345
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:24 2013 +0100

    staging: comedi: ni_at_a2150: sample types are unsigned
    
    Sample values in comedi are generally represented by unsigned values.
    Change the type of the `dma_buffer` member of `struct a2150_private`
    from `s16 *` to `uint16_t *`, and change the type of the `dpnt` variable
    in `a2150_interrupt()` to `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c77d34306119..63c847932eb8 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -154,7 +154,7 @@ struct a2150_private {
 
 	volatile unsigned int count;	/* number of data points left to be taken */
 	unsigned int dma;	/*  dma channel */
-	s16 *dma_buffer;	/*  dma buffer */
+	uint16_t *dma_buffer;	/*  dma buffer */
 	unsigned int dma_transfer_size;	/*  size in bytes of dma transfers */
 	int irq_dma_bits;	/*  irq/dma register bits */
 	int config_bits;	/*  config register bits */
@@ -192,7 +192,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
-	short dpnt;
+	unsigned short dpnt;
 	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
 
 	if (!dev->attached) {

commit cb30fc50feb70762d7d82dab9f832ede3de1d067
Author: Sean Williams <unixed@gmail.com>
Date:   Sat Sep 7 15:51:34 2013 -0700

    Staging: comedi: ni_at_a2150: Remove a few superfluous braces
    
    Please don't flame me :) I'm getting my feet wet with kernel contribution.
    One example I saw in a video by GKH suggested cleaning up coding style as a good first commit.
    
    Signed-off-by: Sean Williams <unixed@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 2512ce8dfcaa..c77d34306119 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -684,13 +684,12 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 		devpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);
 		break;
 	case 2:
-		if (start_channel == 0) {
+		if (start_channel == 0)
 			devpriv->config_bits |= CHANNEL_BITS(0x2);
-		} else if (start_channel == 2) {
+		else if (start_channel == 2)
 			devpriv->config_bits |= CHANNEL_BITS(0x3);
-		} else {
+		else
 			return -1;
-		}
 		break;
 	case 4:
 		devpriv->config_bits |= CHANNEL_BITS(0x1);

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index e13d5c83fb48..2512ce8dfcaa 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -64,7 +64,6 @@ TRIG_WAKE_EOS
 #include <linux/slab.h>
 #include "../comedidev.h"
 
-#include <linux/ioport.h>
 #include <linux/io.h>
 
 #include <asm/dma.h>

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 82c5ca686300..e13d5c83fb48 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -58,12 +58,15 @@ TRIG_WAKE_EOS
 
 */
 
+#include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>
 #include <linux/io.h>
+
 #include <asm/dma.h>
 
 #include "8253.h"

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 7ea5aa32e9d2..82c5ca686300 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -719,10 +719,9 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_request_region(dev, it->options[0], A2150_SIZE);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 2d375168f36d..7ea5aa32e9d2 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -15,12 +15,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
 */
 /*
 Driver: ni_at_a2150

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 3079615b8a29..2d375168f36d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -829,8 +829,6 @@ static void a2150_detach(struct comedi_device *dev)
 
 	if (dev->iobase)
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->dma)
 			free_dma(devpriv->dma);

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 8cd66046872a..3079615b8a29 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -827,10 +827,8 @@ static void a2150_detach(struct comedi_device *dev)
 {
 	struct a2150_private *devpriv = dev->private;
 
-	if (dev->iobase) {
+	if (dev->iobase)
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
-		release_region(dev->iobase, A2150_SIZE);
-	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
@@ -838,6 +836,7 @@ static void a2150_detach(struct comedi_device *dev)
 			free_dma(devpriv->dma);
 		kfree(devpriv->dma_buffer);
 	}
+	comedi_legacy_detach(dev);
 };
 
 static struct comedi_driver ni_at_a2150_driver = {

commit 3671cae1d8fd4bc7fa7d85ec35f2d2149652c7ad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:24:42 2013 -0700

    staging: comedi: ni_at_a2150: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 974704f1f9c0..8cd66046872a 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -719,43 +719,20 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct a2150_board *thisboard = comedi_board(dev);
 	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
-	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned int dma = it->options[2];
 	static const int timeout = 2000;
 	int i;
 	int ret;
 
-	printk("comedi%d: %s: io 0x%lx", dev->minor, dev->driver->driver_name,
-	       iobase);
-	if (irq) {
-		printk(", irq %u", irq);
-	} else {
-		printk(", no irq");
-	}
-	if (dma) {
-		printk(", dma %u", dma);
-	} else {
-		printk(", no dma");
-	}
-	printk("\n");
-
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	if (iobase == 0) {
-		printk(" io base address required\n");
-		return -EINVAL;
-	}
-
-	/* check if io addresses are available */
-	if (!request_region(iobase, A2150_SIZE, dev->driver->driver_name)) {
-		printk(" I/O port conflict\n");
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], A2150_SIZE);
+	if (ret)
+		return ret;
 
 	/* grab our IRQ */
 	if (irq) {

commit e8e1560a02a46b06071433d2478452985076f35f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 5 17:36:40 2013 -0700

    staging: comedi: ni_at_a2150: remove 'thisboard' macro
    
    The 'thisboard' macro relies on a local variable having a specific
    name and yields a pointer derived from that local variable.
    
    Replace the macro with local variables and use the comedi_board()
    helper to get the pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 2a4a7a472142..974704f1f9c0 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -154,11 +154,6 @@ static const struct a2150_board a2150_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct a2150_board *)dev->board_ptr)
-
 struct a2150_private {
 
 	volatile unsigned int count;	/* number of data points left to be taken */
@@ -319,6 +314,7 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static int a2150_ai_cmdtest(struct comedi_device *dev,
 			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct a2150_board *thisboard = comedi_board(dev);
 	int err = 0;
 	int tmp;
 	int startChan;
@@ -604,6 +600,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    int flags)
 {
+	const struct a2150_board *thisboard = comedi_board(dev);
 	struct a2150_private *devpriv = dev->private;
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
@@ -719,6 +716,7 @@ static int a2150_probe(struct comedi_device *dev)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct a2150_board *thisboard = comedi_board(dev);
 	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -797,6 +795,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	dev->board_ptr = a2150_boards + a2150_probe(dev);
+	thisboard = comedi_board(dev);
 	dev->board_name = thisboard->name;
 
 	ret = comedi_alloc_subdevices(dev, 1);

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 06de25bb2f56..2a4a7a472142 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -204,7 +204,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	short dpnt;
 	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
 
-	if (dev->attached == 0) {
+	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}

commit dd254844f1dff6ee1b3be499b2730a4ff1d9ca51
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:56:26 2012 -0700

    staging: comedi: ni_at_a2150: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of a2150_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 0222def373c2..06de25bb2f56 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -345,37 +345,21 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
-			err++;
-		}
-	}
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
-	} else {		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 thisboard->ai_speed);
+
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 34c186b9dce1..0222def373c2 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -758,10 +758,10 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	printk("\n");
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	if (iobase == 0) {
 		printk(" io base address required\n");

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 83950807b672..34c186b9dce1 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -169,8 +169,6 @@ struct a2150_private {
 	int config_bits;	/*  config register bits */
 };
 
-#define devpriv ((struct a2150_private *)dev->private)
-
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
@@ -182,6 +180,8 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 
 static void ni_dump_regs(struct comedi_device *dev)
 {
+	struct a2150_private *devpriv = dev->private;
+
 	printk("config bits 0x%x\n", devpriv->config_bits);
 	printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
 	printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
@@ -196,6 +196,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	int status;
 	unsigned long flags;
 	struct comedi_device *dev = d;
+	struct a2150_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
@@ -300,6 +301,8 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct a2150_private *devpriv = dev->private;
+
 	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
@@ -425,6 +428,7 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 
 static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct a2150_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long lock_flags;
@@ -536,6 +540,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct a2150_private *devpriv = dev->private;
 	unsigned int i, n;
 	static const int timeout = 100000;
 	static const int filter_delay = 36;
@@ -615,6 +620,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    int flags)
 {
+	struct a2150_private *devpriv = dev->private;
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
 	int i, j;
@@ -689,6 +695,8 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 			      unsigned int start_channel,
 			      unsigned int num_channels)
 {
+	struct a2150_private *devpriv = dev->private;
+
 	if (start_channel + num_channels > 4)
 		return -1;
 
@@ -727,6 +735,7 @@ static int a2150_probe(struct comedi_device *dev)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct a2150_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
@@ -749,9 +758,10 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	printk("\n");
 
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct a2150_private)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	if (iobase == 0) {
 		printk(" io base address required\n");
@@ -855,6 +865,8 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void a2150_detach(struct comedi_device *dev)
 {
+	struct a2150_private *devpriv = dev->private;
+
 	if (dev->iobase) {
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
 		release_region(dev->iobase, A2150_SIZE);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 5895d4dce30f..83950807b672 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -321,45 +321,23 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	int startChan;
 	int i;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique and mutually
-	 * compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit ca3caabbb192fa8b1faef17830dff12cb1d0fb72
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:48:20 2012 -0700

    staging: comedi: ni_at_a2150: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index b53a4286f8cb..5895d4dce30f 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -832,7 +832,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	/* analog input subdevice */
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 9d1a0f745bf8..b53a4286f8cb 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -755,6 +755,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int dma = it->options[2];
 	static const int timeout = 2000;
 	int i;
+	int ret;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, dev->driver->driver_name,
 	       iobase);
@@ -826,8 +827,9 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_ptr = a2150_boards + a2150_probe(dev);
 	dev->board_name = thisboard->name;
 
-	if (comedi_alloc_subdevices(dev, 1) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 1);
+	if (ret)
+		return ret;
 
 	/* analog input subdevice */
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index ae896a094150..9d1a0f745bf8 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -826,7 +826,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_ptr = a2150_boards + a2150_probe(dev);
 	dev->board_name = thisboard->name;
 
-	if (alloc_subdevices(dev, 1) < 0)
+	if (comedi_alloc_subdevices(dev, 1) < 0)
 		return -ENOMEM;
 
 	/* analog input subdevice */

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 3231d102839e..ae896a094150 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -873,17 +873,12 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 };
 
-static int a2150_detach(struct comedi_device *dev)
+static void a2150_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: %s: remove\n", dev->minor, dev->driver->driver_name);
-
-	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase) {
-		/*  put board in power-down mode */
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
 		release_region(dev->iobase, A2150_SIZE);
 	}
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
@@ -891,8 +886,6 @@ static int a2150_detach(struct comedi_device *dev)
 			free_dma(devpriv->dma);
 		kfree(devpriv->dma_buffer);
 	}
-
-	return 0;
 };
 
 static struct comedi_driver ni_at_a2150_driver = {

commit fe14fa2b243f301841ef193de334376bab686643
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 17:17:14 2012 -0700

    staging: comedi: refactor ni_at_a2150 driver and use module_comedi_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive to the end of the source. This is more
    typical of how other drivers are written and removes the need
    for the forward declarations.
    
    Convert the driver to use the module_comedi_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4fc469da45e2..3231d102839e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -171,46 +171,13 @@ struct a2150_private {
 
 #define devpriv ((struct a2150_private *)dev->private)
 
-static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int a2150_detach(struct comedi_device *dev);
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
-static struct comedi_driver driver_a2150 = {
-	.driver_name = "ni_at_a2150",
-	.module = THIS_MODULE,
-	.attach = a2150_attach,
-	.detach = a2150_detach,
-};
-
-static irqreturn_t a2150_interrupt(int irq, void *d);
-static int a2150_ai_cmdtest(struct comedi_device *dev,
-			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
-static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    int flags);
-static int a2150_probe(struct comedi_device *dev);
 static int a2150_set_chanlist(struct comedi_device *dev,
 			      unsigned int start_channel,
 			      unsigned int num_channels);
-/*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
- */
-static int __init driver_a2150_init_module(void)
-{
-	return comedi_driver_register(&driver_a2150);
-}
-
-static void __exit driver_a2150_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_a2150);
-}
-
-module_init(driver_a2150_init_module);
-module_exit(driver_a2150_cleanup_module);
-
 #ifdef A2150_DEBUG
 
 static void ni_dump_regs(struct comedi_device *dev)
@@ -331,161 +298,6 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* probes board type, returns offset */
-static int a2150_probe(struct comedi_device *dev)
-{
-	int status = inw(dev->iobase + STATUS_REG);
-	return ID_BITS(status);
-}
-
-static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	struct comedi_subdevice *s;
-	unsigned long iobase = it->options[0];
-	unsigned int irq = it->options[1];
-	unsigned int dma = it->options[2];
-	static const int timeout = 2000;
-	int i;
-
-	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_a2150.driver_name,
-	       iobase);
-	if (irq) {
-		printk(", irq %u", irq);
-	} else {
-		printk(", no irq");
-	}
-	if (dma) {
-		printk(", dma %u", dma);
-	} else {
-		printk(", no dma");
-	}
-	printk("\n");
-
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct a2150_private)) < 0)
-		return -ENOMEM;
-
-	if (iobase == 0) {
-		printk(" io base address required\n");
-		return -EINVAL;
-	}
-
-	/* check if io addresses are available */
-	if (!request_region(iobase, A2150_SIZE, driver_a2150.driver_name)) {
-		printk(" I/O port conflict\n");
-		return -EIO;
-	}
-	dev->iobase = iobase;
-
-	/* grab our IRQ */
-	if (irq) {
-		/*  check that irq is supported */
-		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
-			printk(" invalid irq line %u\n", irq);
-			return -EINVAL;
-		}
-		if (request_irq(irq, a2150_interrupt, 0,
-				driver_a2150.driver_name, dev)) {
-			printk("unable to allocate irq %u\n", irq);
-			return -EINVAL;
-		}
-		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
-		dev->irq = irq;
-	}
-	/*  initialize dma */
-	if (dma) {
-		if (dma == 4 || dma > 7) {
-			printk(" invalid dma channel %u\n", dma);
-			return -EINVAL;
-		}
-		if (request_dma(dma, driver_a2150.driver_name)) {
-			printk(" failed to allocate dma channel %u\n", dma);
-			return -EINVAL;
-		}
-		devpriv->dma = dma;
-		devpriv->dma_buffer =
-		    kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
-		if (devpriv->dma_buffer == NULL)
-			return -ENOMEM;
-
-		disable_dma(dma);
-		set_dma_mode(dma, DMA_MODE_READ);
-
-		devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
-	}
-
-	dev->board_ptr = a2150_boards + a2150_probe(dev);
-	dev->board_name = thisboard->name;
-
-	if (alloc_subdevices(dev, 1) < 0)
-		return -ENOMEM;
-
-	/* analog input subdevice */
-	s = dev->subdevices + 0;
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;
-	s->n_chan = 4;
-	s->len_chanlist = 4;
-	s->maxdata = 0xffff;
-	s->range_table = &range_a2150;
-	s->do_cmd = a2150_ai_cmd;
-	s->do_cmdtest = a2150_ai_cmdtest;
-	s->insn_read = a2150_ai_rinsn;
-	s->cancel = a2150_cancel;
-
-	/* need to do this for software counting of completed conversions, to
-	 * prevent hardware count from stopping acquisition */
-	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
-
-	/*  set card's irq and dma levels */
-	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
-
-	/*  reset and sync adc clock circuitry */
-	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
-	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
-	/*  initialize configuration register */
-	devpriv->config_bits = 0;
-	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
-	/*  wait until offset calibration is done, then enable analog inputs */
-	for (i = 0; i < timeout; i++) {
-		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
-			break;
-		udelay(1000);
-	}
-	if (i == timeout) {
-		printk
-		    (" timed out waiting for offset calibration to complete\n");
-		return -ETIME;
-	}
-	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;
-	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
-
-	return 0;
-};
-
-static int a2150_detach(struct comedi_device *dev)
-{
-	printk("comedi%d: %s: remove\n", dev->minor, driver_a2150.driver_name);
-
-	/* only free stuff if it has been allocated by _attach */
-	if (dev->iobase) {
-		/*  put board in power-down mode */
-		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
-		release_region(dev->iobase, A2150_SIZE);
-	}
-
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (devpriv) {
-		if (devpriv->dma)
-			free_dma(devpriv->dma);
-		kfree(devpriv->dma_buffer);
-	}
-
-	return 0;
-};
-
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	/*  disable dma on card */
@@ -928,6 +740,169 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 	return 0;
 }
 
+/* probes board type, returns offset */
+static int a2150_probe(struct comedi_device *dev)
+{
+	int status = inw(dev->iobase + STATUS_REG);
+	return ID_BITS(status);
+}
+
+static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct comedi_subdevice *s;
+	unsigned long iobase = it->options[0];
+	unsigned int irq = it->options[1];
+	unsigned int dma = it->options[2];
+	static const int timeout = 2000;
+	int i;
+
+	printk("comedi%d: %s: io 0x%lx", dev->minor, dev->driver->driver_name,
+	       iobase);
+	if (irq) {
+		printk(", irq %u", irq);
+	} else {
+		printk(", no irq");
+	}
+	if (dma) {
+		printk(", dma %u", dma);
+	} else {
+		printk(", no dma");
+	}
+	printk("\n");
+
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(struct a2150_private)) < 0)
+		return -ENOMEM;
+
+	if (iobase == 0) {
+		printk(" io base address required\n");
+		return -EINVAL;
+	}
+
+	/* check if io addresses are available */
+	if (!request_region(iobase, A2150_SIZE, dev->driver->driver_name)) {
+		printk(" I/O port conflict\n");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	/* grab our IRQ */
+	if (irq) {
+		/*  check that irq is supported */
+		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
+			printk(" invalid irq line %u\n", irq);
+			return -EINVAL;
+		}
+		if (request_irq(irq, a2150_interrupt, 0,
+				dev->driver->driver_name, dev)) {
+			printk("unable to allocate irq %u\n", irq);
+			return -EINVAL;
+		}
+		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
+		dev->irq = irq;
+	}
+	/*  initialize dma */
+	if (dma) {
+		if (dma == 4 || dma > 7) {
+			printk(" invalid dma channel %u\n", dma);
+			return -EINVAL;
+		}
+		if (request_dma(dma, dev->driver->driver_name)) {
+			printk(" failed to allocate dma channel %u\n", dma);
+			return -EINVAL;
+		}
+		devpriv->dma = dma;
+		devpriv->dma_buffer =
+		    kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer == NULL)
+			return -ENOMEM;
+
+		disable_dma(dma);
+		set_dma_mode(dma, DMA_MODE_READ);
+
+		devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
+	}
+
+	dev->board_ptr = a2150_boards + a2150_probe(dev);
+	dev->board_name = thisboard->name;
+
+	if (alloc_subdevices(dev, 1) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;
+	s->n_chan = 4;
+	s->len_chanlist = 4;
+	s->maxdata = 0xffff;
+	s->range_table = &range_a2150;
+	s->do_cmd = a2150_ai_cmd;
+	s->do_cmdtest = a2150_ai_cmdtest;
+	s->insn_read = a2150_ai_rinsn;
+	s->cancel = a2150_cancel;
+
+	/* need to do this for software counting of completed conversions, to
+	 * prevent hardware count from stopping acquisition */
+	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
+
+	/*  set card's irq and dma levels */
+	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
+
+	/*  reset and sync adc clock circuitry */
+	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
+	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
+	/*  initialize configuration register */
+	devpriv->config_bits = 0;
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+	/*  wait until offset calibration is done, then enable analog inputs */
+	for (i = 0; i < timeout; i++) {
+		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
+			break;
+		udelay(1000);
+	}
+	if (i == timeout) {
+		printk
+		    (" timed out waiting for offset calibration to complete\n");
+		return -ETIME;
+	}
+	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+
+	return 0;
+};
+
+static int a2150_detach(struct comedi_device *dev)
+{
+	printk("comedi%d: %s: remove\n", dev->minor, dev->driver->driver_name);
+
+	/* only free stuff if it has been allocated by _attach */
+	if (dev->iobase) {
+		/*  put board in power-down mode */
+		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
+		release_region(dev->iobase, A2150_SIZE);
+	}
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (devpriv) {
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		kfree(devpriv->dma_buffer);
+	}
+
+	return 0;
+};
+
+static struct comedi_driver ni_at_a2150_driver = {
+	.driver_name	= "ni_at_a2150",
+	.module		= THIS_MODULE,
+	.attach		= a2150_attach,
+	.detach		= a2150_detach,
+};
+module_comedi_driver(ni_at_a2150_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 949fd38c7b22168bc16fea100a51c8d4a3eab144
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Thu Apr 26 15:32:20 2012 +0530

    Staging: comedi: fix line over 80 character issue in ni_at_a2150.c
    
    This is a patch to the ni_at_a2150.c file that fixes up a line
    over 80 character warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c25e44c1905e..4fc469da45e2 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -539,7 +539,10 @@ static int a2150_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources are unique and mutually
+	 * compatible
+	 */
 
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
@@ -771,7 +774,10 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  start acquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
-	/* there is a 35.6 sample delay for data to get through the antialias filter */
+	/*
+	 * there is a 35.6 sample delay for data to get through the
+	 * antialias filter
+	 */
 	for (n = 0; n < filter_delay; n++) {
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
@@ -812,8 +818,10 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-/* sets bits in devpriv->clock_bits to nearest approximation of requested period,
- * adjusts requested period to actual timing. */
+/*
+ * sets bits in devpriv->clock_bits to nearest approximation of requested
+ * period, adjusts requested period to actual timing.
+ */
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 			    int flags)
 {

commit a96b98f218fa7c854a591f4eb3cff90c13036d25
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:26 2011 +0530

    Staging: comedi: fix brace coding style issue in ni_at_a2150.c
    
    This is a patch to the ni_at_a2150.c file that fixes up a brace
    warning found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 32e675e3f0b9..c25e44c1905e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -731,9 +731,8 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
 	/*  start acquisition for soft trigger */
-	if (cmd->start_src == TRIG_NOW) {
+	if (cmd->start_src == TRIG_NOW)
 		outw(0, dev->iobase + FIFO_START_REG);
-	}
 #ifdef A2150_DEBUG
 	ni_dump_regs(dev);
 #endif
@@ -860,11 +859,10 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	case TRIG_ROUND_NEAREST:
 	default:
 		/*  if least upper bound is better approximation */
-		if (lub - *period < *period - glb) {
+		if (lub - *period < *period - glb)
 			*period = lub;
-		} else {
+		else
 			*period = glb;
-		}
 		break;
 	case TRIG_ROUND_UP:
 		*period = lub;

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c192b71ec04f..32e675e3f0b9 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -69,6 +69,7 @@ TRIG_WAKE_EOS
 #include "../comedidev.h"
 
 #include <linux/ioport.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 
 #include "8253.h"

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4d0053ea2465..c192b71ec04f 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -104,10 +104,10 @@ TRIG_WAKE_EOS
 #define STATUS_REG		0x12	/*  read only */
 #define   FNE_BIT		0x1	/*  fifo not empty */
 #define   OVFL_BIT		0x8	/*  fifo overflow */
-#define   EDAQ_BIT		0x10	/*  end of aquisition interrupt */
+#define   EDAQ_BIT		0x10	/*  end of acquisition interrupt */
 #define   DCAL_BIT		0x20	/*  offset calibration in progress */
-#define   INTR_BIT		0x40	/*  interrupt has occured */
-#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occured */
+#define   INTR_BIT		0x40	/*  interrupt has occurred */
+#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occurred */
 #define   ID_BITS(x)	(((x) >> 8) & 0x3)
 #define IRQ_DMA_CNTRL_REG		0x12	/*  write only */
 #define   DMA_CHAN_BITS(x)		((x) & 0x7)	/*  sets dma channel */
@@ -434,7 +434,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->cancel = a2150_cancel;
 
 	/* need to do this for software counting of completed conversions, to
-	 * prevent hardware count from stopping aquisition */
+	 * prevent hardware count from stopping acquisition */
 	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
 
 	/*  set card's irq and dma levels */
@@ -729,7 +729,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
-	/*  start aquisition for soft trigger */
+	/*  start acquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW) {
 		outw(0, dev->iobase + FIFO_START_REG);
 	}
@@ -768,7 +768,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  setup start triggering */
 	outw(0, dev->iobase + TRIGGER_REG);
 
-	/*  start aquisition for soft trigger */
+	/*  start acquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
 	/* there is a 35.6 sample delay for data to get through the antialias filter */

commit e4e1f289be88a75dc8b63d50ade1f9a2e6168021
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:28:57 2011 -0500

    staging: comedi: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index e46d62b75fc0..4d0053ea2465 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -479,8 +479,7 @@ static int a2150_detach(struct comedi_device *dev)
 	if (devpriv) {
 		if (devpriv->dma)
 			free_dma(devpriv->dma);
-		if (devpriv->dma_buffer)
-			kfree(devpriv->dma_buffer);
+		kfree(devpriv->dma_buffer);
 	}
 
 	return 0;

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 709fc85ac703..e46d62b75fc0 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -197,7 +197,18 @@ static int a2150_set_chanlist(struct comedi_device *dev,
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver_a2150);
+static int __init driver_a2150_init_module(void)
+{
+	return comedi_driver_register(&driver_a2150);
+}
+
+static void __exit driver_a2150_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_a2150);
+}
+
+module_init(driver_a2150_init_module);
+module_exit(driver_a2150_cleanup_module);
 
 #ifdef A2150_DEBUG
 

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 9bff34cf06d1..709fc85ac703 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -910,3 +910,7 @@ static int a2150_set_chanlist(struct comedi_device *dev,
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index dd75dfb34309..9bff34cf06d1 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -65,6 +65,7 @@ TRIG_WAKE_EOS
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 45c6809031db..dd75dfb34309 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -131,25 +131,25 @@ struct a2150_board {
 static const struct comedi_lrange range_a2150 = {
 	1,
 	{
-			RANGE(-2.828, 2.828),
-		}
+	 RANGE(-2.828, 2.828),
+	 }
 };
 
 /* enum must match board indices */
 enum { a2150_c, a2150_s };
 static const struct a2150_board a2150_boards[] = {
 	{
-	.name = "at-a2150c",
-	.clock = {31250, 22676, 20833, 19531},
-	.num_clocks = 4,
-	.ai_speed = 19531,
-		},
+	 .name = "at-a2150c",
+	 .clock = {31250, 22676, 20833, 19531},
+	 .num_clocks = 4,
+	 .ai_speed = 19531,
+	 },
 	{
-	.name = "at-a2150s",
-	.clock = {62500, 50000, 41667, 0},
-	.num_clocks = 3,
-	.ai_speed = 41667,
-		},
+	 .name = "at-a2150s",
+	 .clock = {62500, 50000, 41667, 0},
+	 .num_clocks = 3,
+	 .ai_speed = 41667,
+	 },
 };
 
 /*
@@ -167,7 +167,6 @@ struct a2150_private {
 	int config_bits;	/*  config register bits */
 };
 
-
 #define devpriv ((struct a2150_private *)dev->private)
 
 static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it);
@@ -182,16 +181,17 @@ static struct comedi_driver driver_a2150 = {
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d);
-static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int a2150_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd);
 static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-	int flags);
+			    int flags);
 static int a2150_probe(struct comedi_device *dev);
-static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
-	unsigned int num_channels);
+static int a2150_set_chanlist(struct comedi_device *dev,
+			      unsigned int start_channel,
+			      unsigned int num_channels);
 /*
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
@@ -335,7 +335,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_a2150.driver_name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 	} else {
@@ -391,7 +391,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		devpriv->dma = dma;
 		devpriv->dma_buffer =
-			kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+		    kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
 		if (devpriv->dma_buffer == NULL)
 			return -ENOMEM;
 
@@ -441,7 +441,8 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		udelay(1000);
 	}
 	if (i == timeout) {
-		printk(" timed out waiting for offset calibration to complete\n");
+		printk
+		    (" timed out waiting for offset calibration to complete\n");
 		return -ETIME;
 	}
 	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;
@@ -488,8 +489,8 @@ static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int a2150_ai_cmdtest(struct comedi_device *dev,
+			    struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -589,25 +590,24 @@ static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) != (startChan + i)) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 		}
 		if (cmd->chanlist_len == 2 && CR_CHAN(cmd->chanlist[0]) == 1) {
 			comedi_error(dev,
-				"length 2 chanlist must be channels 0,1 or channels 2,3");
+				     "length 2 chanlist must be channels 0,1 or channels 2,3");
 			err++;
 		}
 		if (cmd->chanlist_len == 3) {
 			comedi_error(dev,
-				"chanlist must have 1,2 or 4 channels");
+				     "chanlist must have 1,2 or 4 channels");
 			err++;
 		}
 		if (CR_AREF(cmd->chanlist[0]) != CR_AREF(cmd->chanlist[1]) ||
-			CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3]))
-		{
+		    CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3])) {
 			comedi_error(dev,
-				"channels 0/1 and 2/3 must have the same analog reference");
+				     "channels 0/1 and 2/3 must have the same analog reference");
 			err++;
 		}
 	}
@@ -628,12 +628,12 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (!dev->irq || !devpriv->dma) {
 		comedi_error(dev,
-			" irq and dma required, cannot do hardware conversions");
+			     " irq and dma required, cannot do hardware conversions");
 		return -1;
 	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
-			" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
+			     " dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
 		return -1;
 	}
 	/*  clear fifo and reset triggering circuitry */
@@ -641,7 +641,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* setup chanlist */
 	if (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),
-			cmd->chanlist_len) < 0)
+			       cmd->chanlist_len) < 0)
 		return -1;
 
 	/*  setup ac/dc coupling */
@@ -673,14 +673,14 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	devpriv->dma_transfer_size =
-		sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
-		ONE_THIRD_SECOND / cmd->scan_begin_arg;
+	    sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
+	    ONE_THIRD_SECOND / cmd->scan_begin_arg;
 	if (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)
 		devpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;
 	if (devpriv->dma_transfer_size < sizeof(devpriv->dma_buffer[0]))
 		devpriv->dma_transfer_size = sizeof(devpriv->dma_buffer[0]);
 	devpriv->dma_transfer_size -=
-		devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
+	    devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
 	set_dma_count(devpriv->dma, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma);
 	release_dma_lock(lock_flags);
@@ -700,8 +700,8 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	trigger_bits = 0;
 	/*  decide if we need to wait 72 periods for valid data */
 	if (cmd->start_src == TRIG_NOW &&
-		(old_config_bits & CLOCK_MASK) !=
-		(devpriv->config_bits & CLOCK_MASK)) {
+	    (old_config_bits & CLOCK_MASK) !=
+	    (devpriv->config_bits & CLOCK_MASK)) {
 		/*  set trigger source to delay trigger */
 		trigger_bits |= DELAY_TRIGGER_BITS;
 	} else {
@@ -730,7 +730,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int i, n;
 	static const int timeout = 100000;
@@ -804,7 +804,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 /* sets bits in devpriv->clock_bits to nearest approximation of requested period,
  * adjusts requested period to actual timing. */
 static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
-	int flags)
+			    int flags)
 {
 	int lub, glb, temp;
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
@@ -866,19 +866,20 @@ static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	devpriv->config_bits &= ~CLOCK_MASK;
 	if (*period == lub) {
 		devpriv->config_bits |=
-			CLOCK_SELECT_BITS(lub_index) |
-			CLOCK_DIVISOR_BITS(lub_divisor_shift);
+		    CLOCK_SELECT_BITS(lub_index) |
+		    CLOCK_DIVISOR_BITS(lub_divisor_shift);
 	} else {
 		devpriv->config_bits |=
-			CLOCK_SELECT_BITS(glb_index) |
-			CLOCK_DIVISOR_BITS(glb_divisor_shift);
+		    CLOCK_SELECT_BITS(glb_index) |
+		    CLOCK_DIVISOR_BITS(glb_divisor_shift);
 	}
 
 	return 0;
 }
 
-static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
-	unsigned int num_channels)
+static int a2150_set_chanlist(struct comedi_device *dev,
+			      unsigned int start_channel,
+			      unsigned int num_channels)
 {
 	if (start_channel + num_channels > 4)
 		return -1;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4f348b77bb4a..45c6809031db 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -64,6 +64,7 @@ TRIG_WAKE_EOS
 
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index e6afc42d5d37..4f348b77bb4a 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -201,9 +201,9 @@ COMEDI_INITCLEANUP(driver_a2150);
 
 static void ni_dump_regs(struct comedi_device *dev)
 {
-	rt_printk("config bits 0x%x\n", devpriv->config_bits);
-	rt_printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
-	rt_printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
+	printk("config bits 0x%x\n", devpriv->config_bits);
+	printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
+	printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
 }
 
 #endif
@@ -370,7 +370,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			printk(" invalid irq line %u\n", irq);
 			return -EINVAL;
 		}
-		if (comedi_request_irq(irq, a2150_interrupt, 0,
+		if (request_irq(irq, a2150_interrupt, 0,
 				driver_a2150.driver_name, dev)) {
 			printk("unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -437,7 +437,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;
-		comedi_udelay(1000);
+		udelay(1000);
 	}
 	if (i == timeout) {
 		printk(" timed out waiting for offset calibration to complete\n");
@@ -461,7 +461,7 @@ static int a2150_detach(struct comedi_device *dev)
 	}
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->dma)
 			free_dma(devpriv->dma);
@@ -764,7 +764,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -778,7 +778,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
 				break;
-			comedi_udelay(1);
+			udelay(1);
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
@@ -789,7 +789,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 #endif
 		data[n] = inw(dev->iobase + FIFO_DATA_REG);
 #ifdef A2150_DEBUG
-		rt_printk(" data is %i\n", data[n]);
+		printk(" data is %i\n", data[n]);
 #endif
 		data[n] ^= 0x8000;
 	}

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 0e42f18cdbfe..e6afc42d5d37 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -181,15 +181,15 @@ static struct comedi_driver driver_a2150 = {
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d);
-static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
+static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	int flags);
-static int a2150_probe(struct comedi_device * dev);
-static int a2150_set_chanlist(struct comedi_device * dev, unsigned int start_channel,
+static int a2150_probe(struct comedi_device *dev);
+static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
 	unsigned int num_channels);
 /*
  * A convenient macro that defines init_module() and cleanup_module(),

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 62754d5372ae..0e42f18cdbfe 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -138,16 +138,16 @@ static const struct comedi_lrange range_a2150 = {
 enum { a2150_c, a2150_s };
 static const struct a2150_board a2150_boards[] = {
 	{
-	      name:	"at-a2150c",
-	      clock:	{31250, 22676, 20833, 19531},
-	      num_clocks:4,
-	      ai_speed:19531,
+	.name = "at-a2150c",
+	.clock = {31250, 22676, 20833, 19531},
+	.num_clocks = 4,
+	.ai_speed = 19531,
 		},
 	{
-	      name:	"at-a2150s",
-	      clock:	{62500, 50000, 41667, 0},
-	      num_clocks:3,
-	      ai_speed:41667,
+	.name = "at-a2150s",
+	.clock = {62500, 50000, 41667, 0},
+	.num_clocks = 3,
+	.ai_speed = 41667,
 		},
 };
 
@@ -174,10 +174,10 @@ static int a2150_detach(struct comedi_device *dev);
 static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_a2150 = {
-      driver_name:"ni_at_a2150",
-      module:THIS_MODULE,
-      attach:a2150_attach,
-      detach:a2150_detach,
+	.driver_name = "ni_at_a2150",
+	.module = THIS_MODULE,
+	.attach = a2150_attach,
+	.detach = a2150_detach,
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d);

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 8b73a793ad0f..62754d5372ae 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -169,9 +169,9 @@ struct a2150_private {
 
 #define devpriv ((struct a2150_private *)dev->private)
 
-static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int a2150_detach(struct comedi_device * dev);
-static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int a2150_detach(struct comedi_device *dev);
+static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 
 static struct comedi_driver driver_a2150 = {
       driver_name:"ni_at_a2150",
@@ -199,7 +199,7 @@ COMEDI_INITCLEANUP(driver_a2150);
 
 #ifdef A2150_DEBUG
 
-static void ni_dump_regs(struct comedi_device * dev)
+static void ni_dump_regs(struct comedi_device *dev)
 {
 	rt_printk("config bits 0x%x\n", devpriv->config_bits);
 	rt_printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
@@ -318,13 +318,13 @@ static irqreturn_t a2150_interrupt(int irq, void *d)
 }
 
 /* probes board type, returns offset */
-static int a2150_probe(struct comedi_device * dev)
+static int a2150_probe(struct comedi_device *dev)
 {
 	int status = inw(dev->iobase + STATUS_REG);
 	return ID_BITS(status);
 }
 
-static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -449,7 +449,7 @@ static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	return 0;
 };
 
-static int a2150_detach(struct comedi_device * dev)
+static int a2150_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: %s: remove\n", dev->minor, driver_a2150.driver_name);
 
@@ -472,7 +472,7 @@ static int a2150_detach(struct comedi_device * dev)
 	return 0;
 };
 
-static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
@@ -487,8 +487,8 @@ static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int a2150_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -617,7 +617,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -728,8 +728,8 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int i, n;
 	static const int timeout = 100000;
@@ -802,7 +802,7 @@ static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 
 /* sets bits in devpriv->clock_bits to nearest approximation of requested period,
  * adjusts requested period to actual timing. */
-static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
+static int a2150_get_timing(struct comedi_device *dev, unsigned int *period,
 	int flags)
 {
 	int lub, glb, temp;
@@ -876,7 +876,7 @@ static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	return 0;
 }
 
-static int a2150_set_chanlist(struct comedi_device * dev, unsigned int start_channel,
+static int a2150_set_chanlist(struct comedi_device *dev, unsigned int start_channel,
 	unsigned int num_channels)
 {
 	if (start_channel + num_channels > 4)

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index f956ee1ff72d..8b73a793ad0f 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -180,7 +180,7 @@ static struct comedi_driver driver_a2150 = {
       detach:a2150_detach,
 };
 
-static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t a2150_interrupt(int irq, void *d);
 static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
 static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -209,7 +209,7 @@ static void ni_dump_regs(struct comedi_device * dev)
 #endif
 
 /* interrupt service routine */
-static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t a2150_interrupt(int irq, void *d)
 {
 	int i;
 	int status;

commit 30c687c1b8f4977ad72c544dfcccb27586d0a72c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:31:06 2009 -0400

    Staging: comedi: remove C99 comments in ni_at_a2150.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 5d45bf24a5ef..f956ee1ff72d 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -73,10 +73,10 @@ TRIG_WAKE_EOS
 #include "comedi_fc.h"
 
 #define A2150_SIZE           28
-#define A2150_DMA_BUFFER_SIZE	0xff00	// size in bytes of dma buffer
+#define A2150_DMA_BUFFER_SIZE	0xff00	/*  size in bytes of dma buffer */
 
-//#define A2150_DEBUG   // enable debugging code
-#undef A2150_DEBUG		// disable debugging code
+/* #define A2150_DEBUG     enable debugging code */
+#undef A2150_DEBUG		/*  disable debugging code */
 
 /* Registers and bits */
 #define CONFIG_REG		0x0
@@ -85,48 +85,48 @@ TRIG_WAKE_EOS
 #define   CLOCK_SELECT_BITS(x)		(((x) & 0x3) << 3)
 #define   CLOCK_DIVISOR_BITS(x)		(((x) & 0x3) << 5)
 #define   CLOCK_MASK		(0xf << 3)
-#define   ENABLE0_BIT		0x80	// enable (don't internally ground) channels 0 and 1
-#define   ENABLE1_BIT		0x100	// enable (don't internally ground) channels 2 and 3
-#define   AC0_BIT		0x200	// ac couple channels 0,1
-#define   AC1_BIT		0x400	// ac couple channels 2,3
-#define   APD_BIT		0x800	// analog power down
-#define   DPD_BIT		0x1000	// digital power down
-#define TRIGGER_REG		0x2	// trigger config register
+#define   ENABLE0_BIT		0x80	/*  enable (don't internally ground) channels 0 and 1 */
+#define   ENABLE1_BIT		0x100	/*  enable (don't internally ground) channels 2 and 3 */
+#define   AC0_BIT		0x200	/*  ac couple channels 0,1 */
+#define   AC1_BIT		0x400	/*  ac couple channels 2,3 */
+#define   APD_BIT		0x800	/*  analog power down */
+#define   DPD_BIT		0x1000	/*  digital power down */
+#define TRIGGER_REG		0x2	/*  trigger config register */
 #define   POST_TRIGGER_BITS		0x2
 #define   DELAY_TRIGGER_BITS		0x3
-#define   HW_TRIG_EN		0x10	// enable hardware trigger
-#define FIFO_START_REG		0x6	// software start aquistion trigger
-#define FIFO_RESET_REG		0x8	// clears fifo + fifo flags
-#define FIFO_DATA_REG		0xa	// read data
-#define DMA_TC_CLEAR_REG		0xe	// clear dma terminal count interrupt
-#define STATUS_REG		0x12	// read only
-#define   FNE_BIT		0x1	// fifo not empty
-#define   OVFL_BIT		0x8	// fifo overflow
-#define   EDAQ_BIT		0x10	// end of aquisition interrupt
-#define   DCAL_BIT		0x20	// offset calibration in progress
-#define   INTR_BIT		0x40	// interrupt has occured
-#define   DMA_TC_BIT		0x80	// dma terminal count interrupt has occured
+#define   HW_TRIG_EN		0x10	/*  enable hardware trigger */
+#define FIFO_START_REG		0x6	/*  software start aquistion trigger */
+#define FIFO_RESET_REG		0x8	/*  clears fifo + fifo flags */
+#define FIFO_DATA_REG		0xa	/*  read data */
+#define DMA_TC_CLEAR_REG		0xe	/*  clear dma terminal count interrupt */
+#define STATUS_REG		0x12	/*  read only */
+#define   FNE_BIT		0x1	/*  fifo not empty */
+#define   OVFL_BIT		0x8	/*  fifo overflow */
+#define   EDAQ_BIT		0x10	/*  end of aquisition interrupt */
+#define   DCAL_BIT		0x20	/*  offset calibration in progress */
+#define   INTR_BIT		0x40	/*  interrupt has occured */
+#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occured */
 #define   ID_BITS(x)	(((x) >> 8) & 0x3)
-#define IRQ_DMA_CNTRL_REG		0x12	// write only
-#define   DMA_CHAN_BITS(x)		((x) & 0x7)	// sets dma channel
-#define   DMA_EN_BIT		0x8	// enables dma
-#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	// sets irq level
-#define   FIFO_INTR_EN_BIT		0x100	// enable fifo interrupts
-#define   FIFO_INTR_FHF_BIT		0x200	// interrupt fifo half full
-#define   DMA_INTR_EN_BIT 		0x800	// enable interrupt on dma terminal count
-#define   DMA_DEM_EN_BIT	0x1000	// enables demand mode dma
+#define IRQ_DMA_CNTRL_REG		0x12	/*  write only */
+#define   DMA_CHAN_BITS(x)		((x) & 0x7)	/*  sets dma channel */
+#define   DMA_EN_BIT		0x8	/*  enables dma */
+#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	/*  sets irq level */
+#define   FIFO_INTR_EN_BIT		0x100	/*  enable fifo interrupts */
+#define   FIFO_INTR_FHF_BIT		0x200	/*  interrupt fifo half full */
+#define   DMA_INTR_EN_BIT 		0x800	/*  enable interrupt on dma terminal count */
+#define   DMA_DEM_EN_BIT	0x1000	/*  enables demand mode dma */
 #define I8253_BASE_REG		0x14
 #define I8253_MODE_REG		0x17
-#define   HW_COUNT_DISABLE		0x30	// disable hardware counting of conversions
+#define   HW_COUNT_DISABLE		0x30	/*  disable hardware counting of conversions */
 
 struct a2150_board {
 	const char *name;
-	int clock[4];		// master clock periods, in nanoseconds
-	int num_clocks;		// number of available master clock speeds
-	int ai_speed;		// maximum conversion rate in nanoseconds
+	int clock[4];		/*  master clock periods, in nanoseconds */
+	int num_clocks;		/*  number of available master clock speeds */
+	int ai_speed;		/*  maximum conversion rate in nanoseconds */
 };
 
-//analog input range
+/* analog input range */
 static const struct comedi_lrange range_a2150 = {
 	1,
 	{
@@ -134,7 +134,7 @@ static const struct comedi_lrange range_a2150 = {
 		}
 };
 
-// enum must match board indices
+/* enum must match board indices */
 enum { a2150_c, a2150_s };
 static const struct a2150_board a2150_boards[] = {
 	{
@@ -159,11 +159,11 @@ static const struct a2150_board a2150_boards[] = {
 struct a2150_private {
 
 	volatile unsigned int count;	/* number of data points left to be taken */
-	unsigned int dma;	// dma channel
-	s16 *dma_buffer;	// dma buffer
-	unsigned int dma_transfer_size;	// size in bytes of dma transfers
-	int irq_dma_bits;	// irq/dma register bits
-	int config_bits;	// config register bits
+	unsigned int dma;	/*  dma channel */
+	s16 *dma_buffer;	/*  dma buffer */
+	unsigned int dma_transfer_size;	/*  size in bytes of dma transfers */
+	int irq_dma_bits;	/*  irq/dma register bits */
+	int config_bits;	/*  config register bits */
 };
 
 
@@ -226,7 +226,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	// initialize async here to make sure s is not NULL
+	/*  initialize async here to make sure s is not NULL */
 	async = s->async;
 	async->events = 0;
 	cmd = &async->cmd;
@@ -258,7 +258,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	max_points = devpriv->dma_transfer_size / sample_size;
 	/* residue is the number of points left to be done on the dma
 	 * transfer.  It should always be zero at this point unless
@@ -269,7 +269,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
 		num_points = devpriv->count;
 
-	// figure out how many points will be stored next time
+	/*  figure out how many points will be stored next time */
 	leftover = 0;
 	if (cmd->stop_src == TRIG_NONE) {
 		leftover = devpriv->dma_transfer_size / sample_size;
@@ -288,7 +288,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	for (i = 0; i < num_points; i++) {
 		/* write data point to comedi buffer */
 		dpnt = devpriv->dma_buffer[i];
-		// convert from 2's complement to unsigned coding
+		/*  convert from 2's complement to unsigned coding */
 		dpnt ^= 0x8000;
 		cfc_write_to_buffer(s, dpnt);
 		if (cmd->stop_src == TRIG_COUNT) {
@@ -299,7 +299,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 			}
 		}
 	}
-	// re-enable  dma
+	/*  re-enable  dma */
 	if (leftover) {
 		set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
 		set_dma_count(devpriv->dma, leftover * sample_size);
@@ -317,7 +317,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-// probes board type, returns offset
+/* probes board type, returns offset */
 static int a2150_probe(struct comedi_device * dev)
 {
 	int status = inw(dev->iobase + STATUS_REG);
@@ -365,7 +365,7 @@ static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it
 
 	/* grab our IRQ */
 	if (irq) {
-		// check that irq is supported
+		/*  check that irq is supported */
 		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
 			printk(" invalid irq line %u\n", irq);
 			return -EINVAL;
@@ -378,7 +378,7 @@ static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
 		dev->irq = irq;
 	}
-	// initialize dma
+	/*  initialize dma */
 	if (dma) {
 		if (dma == 4 || dma > 7) {
 			printk(" invalid dma channel %u\n", dma);
@@ -424,16 +424,16 @@ static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	 * prevent hardware count from stopping aquisition */
 	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
 
-	// set card's irq and dma levels
+	/*  set card's irq and dma levels */
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// reset and sync adc clock circuitry
+	/*  reset and sync adc clock circuitry */
 	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
 	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
-	// initialize configuration register
+	/*  initialize configuration register */
 	devpriv->config_bits = 0;
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
-	// wait until offset calibration is done, then enable analog inputs
+	/*  wait until offset calibration is done, then enable analog inputs */
 	for (i = 0; i < timeout; i++) {
 		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
 			break;
@@ -455,7 +455,7 @@ static int a2150_detach(struct comedi_device * dev)
 
 	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase) {
-		// put board in power-down mode
+		/*  put board in power-down mode */
 		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
 		release_region(dev->iobase, A2150_SIZE);
 	}
@@ -474,14 +474,14 @@ static int a2150_detach(struct comedi_device * dev)
 
 static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	// disable dma on card
+	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// disable computer's dma
+	/*  disable computer's dma */
 	disable_dma(devpriv->dma);
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return 0;
@@ -582,7 +582,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		startChan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
@@ -635,7 +635,7 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 			" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
 		return -1;
 	}
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
@@ -643,7 +643,7 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 			cmd->chanlist_len) < 0)
 		return -1;
 
-	// setup ac/dc coupling
+	/*  setup ac/dc coupling */
 	if (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)
 		devpriv->config_bits |= AC0_BIT;
 	else
@@ -653,23 +653,23 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	else
 		devpriv->config_bits &= ~AC1_BIT;
 
-	// setup timing
+	/*  setup timing */
 	a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
 
-	// send timing, channel, config bits
+	/*  send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	// initialize number of samples remaining
+	/*  initialize number of samples remaining */
 	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
-	// enable computer's dma
+	/*  enable computer's dma */
 	lock_flags = claim_dma_lock();
 	disable_dma(devpriv->dma);
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma);
 	set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
-	// set size of transfer to fill in 1/3 second
+	/*  set size of transfer to fill in 1/3 second */
 #define ONE_THIRD_SECOND 333333333
 	devpriv->dma_transfer_size =
 		sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
@@ -688,36 +688,36 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	 * one spurious interrupt that has been happening */
 	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
 
-	// enable dma on card
+	/*  enable dma on card */
 	devpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// may need to wait 72 sampling periods if timing was changed
+	/*  may need to wait 72 sampling periods if timing was changed */
 	i8254_load(dev->iobase + I8253_BASE_REG, 0, 2, 72, 0);
 
-	// setup start triggering
+	/*  setup start triggering */
 	trigger_bits = 0;
-	// decide if we need to wait 72 periods for valid data
+	/*  decide if we need to wait 72 periods for valid data */
 	if (cmd->start_src == TRIG_NOW &&
 		(old_config_bits & CLOCK_MASK) !=
 		(devpriv->config_bits & CLOCK_MASK)) {
-		// set trigger source to delay trigger
+		/*  set trigger source to delay trigger */
 		trigger_bits |= DELAY_TRIGGER_BITS;
 	} else {
-		// otherwise no delay
+		/*  otherwise no delay */
 		trigger_bits |= POST_TRIGGER_BITS;
 	}
-	// enable external hardware trigger
+	/*  enable external hardware trigger */
 	if (cmd->start_src == TRIG_EXT) {
 		trigger_bits |= HW_TRIG_EN;
 	} else if (cmd->start_src == TRIG_OTHER) {
-		// XXX add support for level/slope start trigger using TRIG_OTHER
+		/*  XXX add support for level/slope start trigger using TRIG_OTHER */
 		comedi_error(dev, "you shouldn't see this?");
 	}
-	// send trigger config bits
+	/*  send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
-	// start aquisition for soft trigger
+	/*  start aquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW) {
 		outw(0, dev->iobase + FIFO_START_REG);
 	}
@@ -735,28 +735,28 @@ static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	static const int timeout = 100000;
 	static const int filter_delay = 36;
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	/* setup chanlist */
 	if (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)
 		return -1;
 
-	// set dc coupling
+	/*  set dc coupling */
 	devpriv->config_bits &= ~AC0_BIT;
 	devpriv->config_bits &= ~AC1_BIT;
 
-	// send timing, channel, config bits
+	/*  send timing, channel, config bits */
 	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
 
-	// disable dma on card
+	/*  disable dma on card */
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
 	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
 
-	// setup start triggering
+	/*  setup start triggering */
 	outw(0, dev->iobase + TRIGGER_REG);
 
-	// start aquisition for soft trigger
+	/*  start aquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
 	/* there is a 35.6 sample delay for data to get through the antialias filter */
@@ -773,7 +773,7 @@ static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 		inw(dev->iobase + FIFO_DATA_REG);
 	}
 
-	// read data
+	/*  read data */
 	for (n = 0; n < insn->n; n++) {
 		for (i = 0; i < timeout; i++) {
 			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
@@ -794,7 +794,7 @@ static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 		data[n] ^= 0x8000;
 	}
 
-	// clear fifo and reset triggering circuitry
+	/*  clear fifo and reset triggering circuitry */
 	outw(0, dev->iobase + FIFO_RESET_REG);
 
 	return n;
@@ -809,7 +809,7 @@ static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
 	int i, j;
 
-	// initialize greatest lower and least upper bounds
+	/*  initialize greatest lower and least upper bounds */
 	lub_divisor_shift = 3;
 	lub_index = 0;
 	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
@@ -817,19 +817,19 @@ static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	glb_index = thisboard->num_clocks - 1;
 	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
 
-	// make sure period is in available range
+	/*  make sure period is in available range */
 	if (*period < glb)
 		*period = glb;
 	if (*period > lub)
 		*period = lub;
 
-	// we can multiply period by 1, 2, 4, or 8, using (1 << i)
+	/*  we can multiply period by 1, 2, 4, or 8, using (1 << i) */
 	for (i = 0; i < 4; i++) {
-		// there are a maximum of 4 master clocks
+		/*  there are a maximum of 4 master clocks */
 		for (j = 0; j < thisboard->num_clocks; j++) {
-			// temp is the period in nanosec we are evaluating
+			/*  temp is the period in nanosec we are evaluating */
 			temp = thisboard->clock[j] * (1 << i);
-			// if it is the best match yet
+			/*  if it is the best match yet */
 			if (temp < lub && temp >= *period) {
 				lub_divisor_shift = i;
 				lub_index = j;
@@ -846,7 +846,7 @@ static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	switch (flags) {
 	case TRIG_ROUND_NEAREST:
 	default:
-		// if least upper bound is better approximation
+		/*  if least upper bound is better approximation */
 		if (lub - *period < *period - glb) {
 			*period = lub;
 		} else {
@@ -861,7 +861,7 @@ static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 		break;
 	}
 
-	// set clock bits for config register appropriately
+	/*  set clock bits for config register appropriately */
 	devpriv->config_bits &= ~CLOCK_MASK;
 	if (*period == lub) {
 		devpriv->config_bits |=

commit 92b635c5bea18d7eb3c46bfdcc930d9d86d3d177
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Mar 19 17:59:18 2009 -0400

    Staging: comedi: Remove a2150_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index ed5f5576d992..5d45bf24a5ef 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -119,12 +119,12 @@ TRIG_WAKE_EOS
 #define I8253_MODE_REG		0x17
 #define   HW_COUNT_DISABLE		0x30	// disable hardware counting of conversions
 
-typedef struct a2150_board_struct {
+struct a2150_board {
 	const char *name;
 	int clock[4];		// master clock periods, in nanoseconds
 	int num_clocks;		// number of available master clock speeds
 	int ai_speed;		// maximum conversion rate in nanoseconds
-} a2150_board;
+};
 
 //analog input range
 static const struct comedi_lrange range_a2150 = {
@@ -136,7 +136,7 @@ static const struct comedi_lrange range_a2150 = {
 
 // enum must match board indices
 enum { a2150_c, a2150_s };
-static const a2150_board a2150_boards[] = {
+static const struct a2150_board a2150_boards[] = {
 	{
 	      name:	"at-a2150c",
 	      clock:	{31250, 22676, 20833, 19531},
@@ -154,7 +154,7 @@ static const a2150_board a2150_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const a2150_board *)dev->board_ptr)
+#define thisboard ((const struct a2150_board *)dev->board_ptr)
 
 struct a2150_private {
 

commit 3cc3872bbd097a2bcbe740b7041b3d35cc8f0d3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:16:07 2009 -0400

    Staging: comedi: Remove a2150_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index d14227826817..ed5f5576d992 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -156,16 +156,18 @@ static const a2150_board a2150_boards[] = {
  */
 #define thisboard ((const a2150_board *)dev->board_ptr)
 
-typedef struct {
+struct a2150_private {
+
 	volatile unsigned int count;	/* number of data points left to be taken */
 	unsigned int dma;	// dma channel
 	s16 *dma_buffer;	// dma buffer
 	unsigned int dma_transfer_size;	// size in bytes of dma transfers
 	int irq_dma_bits;	// irq/dma register bits
 	int config_bits;	// config register bits
-} a2150_private;
+};
+
 
-#define devpriv ((a2150_private *)dev->private)
+#define devpriv ((struct a2150_private *)dev->private)
 
 static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int a2150_detach(struct comedi_device * dev);
@@ -346,7 +348,7 @@ static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	printk("\n");
 
 	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(a2150_private)) < 0)
+	if (alloc_private(dev, sizeof(struct a2150_private)) < 0)
 		return -ENOMEM;
 
 	if (iobase == 0) {

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 6f2f8d35dc11..d14227826817 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -167,7 +167,7 @@ typedef struct {
 
 #define devpriv ((a2150_private *)dev->private)
 
-static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int a2150_detach(struct comedi_device * dev);
 static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
@@ -322,7 +322,7 @@ static int a2150_probe(struct comedi_device * dev)
 	return ID_BITS(status);
 }
 
-static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int a2150_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 8a13e8624b04..6f2f8d35dc11 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -183,7 +183,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	struct comedi_cmd * cmd);
 static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	int flags);
 static int a2150_probe(struct comedi_device * dev);
@@ -727,7 +727,7 @@ static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int i, n;
 	static const int timeout = 100000;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 2a3032bbcced..8a13e8624b04 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -180,7 +180,7 @@ static struct comedi_driver driver_a2150 = {
 
 static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG);
 static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
@@ -215,7 +215,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
 	short dpnt;
 	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
@@ -486,7 +486,7 @@ static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 }
 
 static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -618,7 +618,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long lock_flags;
 	unsigned int old_config_bits = devpriv->config_bits;
 	unsigned int trigger_bits;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 87edc61f6a4e..2a3032bbcced 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -127,7 +127,7 @@ typedef struct a2150_board_struct {
 } a2150_board;
 
 //analog input range
-static const comedi_lrange range_a2150 = {
+static const struct comedi_lrange range_a2150 = {
 	1,
 	{
 			RANGE(-2.828, 2.828),

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index c15568d3cd46..87edc61f6a4e 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -171,7 +171,7 @@ static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int a2150_detach(struct comedi_device * dev);
 static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
-static comedi_driver driver_a2150 = {
+static struct comedi_driver driver_a2150 = {
       driver_name:"ni_at_a2150",
       module:THIS_MODULE,
       attach:a2150_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4ac5313ea43f..c15568d3cd46 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -214,7 +214,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	unsigned long flags;
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async;
+	struct comedi_async *async;
 	comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
 	short dpnt;
@@ -617,7 +617,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 
 static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned long lock_flags;
 	unsigned int old_config_bits = devpriv->config_bits;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index bf16e1273825..4ac5313ea43f 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -169,7 +169,7 @@ typedef struct {
 
 static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int a2150_detach(struct comedi_device * dev);
-static int a2150_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 
 static comedi_driver driver_a2150 = {
       driver_name:"ni_at_a2150",
@@ -179,10 +179,10 @@ static comedi_driver driver_a2150 = {
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG);
-static int a2150_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int a2150_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int a2150_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	int flags);
@@ -213,7 +213,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	int status;
 	unsigned long flags;
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
@@ -324,7 +324,7 @@ static int a2150_probe(struct comedi_device * dev)
 
 static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned int dma = it->options[2];
@@ -470,7 +470,7 @@ static int a2150_detach(struct comedi_device * dev)
 	return 0;
 };
 
-static int a2150_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int a2150_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	// disable dma on card
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
@@ -485,7 +485,7 @@ static int a2150_cancel(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -615,7 +615,7 @@ static int a2150_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int a2150_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int a2150_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -726,7 +726,7 @@ static int a2150_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int i, n;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 2d7f5528b402..bf16e1273825 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -167,9 +167,9 @@ typedef struct {
 
 #define devpriv ((a2150_private *)dev->private)
 
-static int a2150_attach(comedi_device * dev, comedi_devconfig * it);
-static int a2150_detach(comedi_device * dev);
-static int a2150_cancel(comedi_device * dev, comedi_subdevice * s);
+static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int a2150_detach(struct comedi_device * dev);
+static int a2150_cancel(struct comedi_device * dev, comedi_subdevice * s);
 
 static comedi_driver driver_a2150 = {
       driver_name:"ni_at_a2150",
@@ -179,15 +179,15 @@ static comedi_driver driver_a2150 = {
 };
 
 static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG);
-static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int a2150_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int a2150_get_timing(comedi_device * dev, unsigned int *period,
+static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	int flags);
-static int a2150_probe(comedi_device * dev);
-static int a2150_set_chanlist(comedi_device * dev, unsigned int start_channel,
+static int a2150_probe(struct comedi_device * dev);
+static int a2150_set_chanlist(struct comedi_device * dev, unsigned int start_channel,
 	unsigned int num_channels);
 /*
  * A convenient macro that defines init_module() and cleanup_module(),
@@ -197,7 +197,7 @@ COMEDI_INITCLEANUP(driver_a2150);
 
 #ifdef A2150_DEBUG
 
-static void ni_dump_regs(comedi_device * dev)
+static void ni_dump_regs(struct comedi_device * dev)
 {
 	rt_printk("config bits 0x%x\n", devpriv->config_bits);
 	rt_printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
@@ -212,7 +212,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	int i;
 	int status;
 	unsigned long flags;
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
@@ -316,13 +316,13 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 }
 
 // probes board type, returns offset
-static int a2150_probe(comedi_device * dev)
+static int a2150_probe(struct comedi_device * dev)
 {
 	int status = inw(dev->iobase + STATUS_REG);
 	return ID_BITS(status);
 }
 
-static int a2150_attach(comedi_device * dev, comedi_devconfig * it)
+static int a2150_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -447,7 +447,7 @@ static int a2150_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 };
 
-static int a2150_detach(comedi_device * dev)
+static int a2150_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: %s: remove\n", dev->minor, driver_a2150.driver_name);
 
@@ -470,7 +470,7 @@ static int a2150_detach(comedi_device * dev)
 	return 0;
 };
 
-static int a2150_cancel(comedi_device * dev, comedi_subdevice * s)
+static int a2150_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	// disable dma on card
 	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
@@ -485,7 +485,7 @@ static int a2150_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -615,7 +615,7 @@ static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int a2150_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -726,7 +726,7 @@ static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int a2150_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int i, n;
@@ -800,7 +800,7 @@ static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 
 /* sets bits in devpriv->clock_bits to nearest approximation of requested period,
  * adjusts requested period to actual timing. */
-static int a2150_get_timing(comedi_device * dev, unsigned int *period,
+static int a2150_get_timing(struct comedi_device * dev, unsigned int *period,
 	int flags)
 {
 	int lub, glb, temp;
@@ -874,7 +874,7 @@ static int a2150_get_timing(comedi_device * dev, unsigned int *period,
 	return 0;
 }
 
-static int a2150_set_chanlist(comedi_device * dev, unsigned int start_channel,
+static int a2150_set_chanlist(struct comedi_device * dev, unsigned int start_channel,
 	unsigned int num_channels)
 {
 	if (start_channel + num_channels > 4)

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 462419b247b1..2d7f5528b402 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -183,7 +183,7 @@ static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int a2150_get_timing(comedi_device * dev, unsigned int *period,
 	int flags);
 static int a2150_probe(comedi_device * dev);
@@ -217,7 +217,7 @@ static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
 	comedi_async *async;
 	comedi_cmd *cmd;
 	unsigned int max_points, num_points, residue, leftover;
-	sampl_t dpnt;
+	short dpnt;
 	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
 
 	if (dev->attached == 0) {
@@ -727,7 +727,7 @@ static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 }
 
 static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int i, n;
 	static const int timeout = 100000;

commit 01b0a25824f2cbf1b0cf9e06705cab52dbc0b9e4
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 19 10:01:19 2009 -0800

    Staging: comedi: add ni_at_a2150 driver
    
    Driver for National Instruments AT-A2150
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
new file mode 100644
index 000000000000..462419b247b1
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -0,0 +1,907 @@
+/*
+    comedi/drivers/ni_at_a2150.c
+    Driver for National Instruments AT-A2150 boards
+    Copyright (C) 2001, 2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: ni_at_a2150
+Description: National Instruments AT-A2150
+Author: Frank Mori Hess
+Status: works
+Devices: [National Instruments] AT-A2150C (at_a2150c), AT-2150S (at_a2150s)
+
+If you want to ac couple the board's inputs, use AREF_OTHER.
+
+Configuration options:
+  [0] - I/O port base address
+  [1] - IRQ (optional, required for timed conversions)
+  [2] - DMA (optional, required for timed conversions)
+
+*/
+/*
+Yet another driver for obsolete hardware brought to you by Frank Hess.
+Testing and debugging help provided by Dave Andruczyk.
+
+This driver supports the boards:
+
+AT-A2150C
+AT-A2150S
+
+The only difference is their master clock frequencies.
+
+Options:
+	[0] - base io address
+	[1] - irq
+	[2] - dma channel
+
+References (from ftp://ftp.natinst.com/support/manuals):
+
+	   320360.pdf  AT-A2150 User Manual
+
+TODO:
+
+analog level triggering
+TRIG_WAKE_EOS
+
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <asm/dma.h>
+
+#include "8253.h"
+#include "comedi_fc.h"
+
+#define A2150_SIZE           28
+#define A2150_DMA_BUFFER_SIZE	0xff00	// size in bytes of dma buffer
+
+//#define A2150_DEBUG   // enable debugging code
+#undef A2150_DEBUG		// disable debugging code
+
+/* Registers and bits */
+#define CONFIG_REG		0x0
+#define   CHANNEL_BITS(x)		((x) & 0x7)
+#define   CHANNEL_MASK		0x7
+#define   CLOCK_SELECT_BITS(x)		(((x) & 0x3) << 3)
+#define   CLOCK_DIVISOR_BITS(x)		(((x) & 0x3) << 5)
+#define   CLOCK_MASK		(0xf << 3)
+#define   ENABLE0_BIT		0x80	// enable (don't internally ground) channels 0 and 1
+#define   ENABLE1_BIT		0x100	// enable (don't internally ground) channels 2 and 3
+#define   AC0_BIT		0x200	// ac couple channels 0,1
+#define   AC1_BIT		0x400	// ac couple channels 2,3
+#define   APD_BIT		0x800	// analog power down
+#define   DPD_BIT		0x1000	// digital power down
+#define TRIGGER_REG		0x2	// trigger config register
+#define   POST_TRIGGER_BITS		0x2
+#define   DELAY_TRIGGER_BITS		0x3
+#define   HW_TRIG_EN		0x10	// enable hardware trigger
+#define FIFO_START_REG		0x6	// software start aquistion trigger
+#define FIFO_RESET_REG		0x8	// clears fifo + fifo flags
+#define FIFO_DATA_REG		0xa	// read data
+#define DMA_TC_CLEAR_REG		0xe	// clear dma terminal count interrupt
+#define STATUS_REG		0x12	// read only
+#define   FNE_BIT		0x1	// fifo not empty
+#define   OVFL_BIT		0x8	// fifo overflow
+#define   EDAQ_BIT		0x10	// end of aquisition interrupt
+#define   DCAL_BIT		0x20	// offset calibration in progress
+#define   INTR_BIT		0x40	// interrupt has occured
+#define   DMA_TC_BIT		0x80	// dma terminal count interrupt has occured
+#define   ID_BITS(x)	(((x) >> 8) & 0x3)
+#define IRQ_DMA_CNTRL_REG		0x12	// write only
+#define   DMA_CHAN_BITS(x)		((x) & 0x7)	// sets dma channel
+#define   DMA_EN_BIT		0x8	// enables dma
+#define   IRQ_LVL_BITS(x)		(((x) & 0xf) << 4)	// sets irq level
+#define   FIFO_INTR_EN_BIT		0x100	// enable fifo interrupts
+#define   FIFO_INTR_FHF_BIT		0x200	// interrupt fifo half full
+#define   DMA_INTR_EN_BIT 		0x800	// enable interrupt on dma terminal count
+#define   DMA_DEM_EN_BIT	0x1000	// enables demand mode dma
+#define I8253_BASE_REG		0x14
+#define I8253_MODE_REG		0x17
+#define   HW_COUNT_DISABLE		0x30	// disable hardware counting of conversions
+
+typedef struct a2150_board_struct {
+	const char *name;
+	int clock[4];		// master clock periods, in nanoseconds
+	int num_clocks;		// number of available master clock speeds
+	int ai_speed;		// maximum conversion rate in nanoseconds
+} a2150_board;
+
+//analog input range
+static const comedi_lrange range_a2150 = {
+	1,
+	{
+			RANGE(-2.828, 2.828),
+		}
+};
+
+// enum must match board indices
+enum { a2150_c, a2150_s };
+static const a2150_board a2150_boards[] = {
+	{
+	      name:	"at-a2150c",
+	      clock:	{31250, 22676, 20833, 19531},
+	      num_clocks:4,
+	      ai_speed:19531,
+		},
+	{
+	      name:	"at-a2150s",
+	      clock:	{62500, 50000, 41667, 0},
+	      num_clocks:3,
+	      ai_speed:41667,
+		},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const a2150_board *)dev->board_ptr)
+
+typedef struct {
+	volatile unsigned int count;	/* number of data points left to be taken */
+	unsigned int dma;	// dma channel
+	s16 *dma_buffer;	// dma buffer
+	unsigned int dma_transfer_size;	// size in bytes of dma transfers
+	int irq_dma_bits;	// irq/dma register bits
+	int config_bits;	// config register bits
+} a2150_private;
+
+#define devpriv ((a2150_private *)dev->private)
+
+static int a2150_attach(comedi_device * dev, comedi_devconfig * it);
+static int a2150_detach(comedi_device * dev);
+static int a2150_cancel(comedi_device * dev, comedi_subdevice * s);
+
+static comedi_driver driver_a2150 = {
+      driver_name:"ni_at_a2150",
+      module:THIS_MODULE,
+      attach:a2150_attach,
+      detach:a2150_detach,
+};
+
+static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG);
+static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int a2150_get_timing(comedi_device * dev, unsigned int *period,
+	int flags);
+static int a2150_probe(comedi_device * dev);
+static int a2150_set_chanlist(comedi_device * dev, unsigned int start_channel,
+	unsigned int num_channels);
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver_a2150);
+
+#ifdef A2150_DEBUG
+
+static void ni_dump_regs(comedi_device * dev)
+{
+	rt_printk("config bits 0x%x\n", devpriv->config_bits);
+	rt_printk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);
+	rt_printk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));
+}
+
+#endif
+
+/* interrupt service routine */
+static irqreturn_t a2150_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	int i;
+	int status;
+	unsigned long flags;
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async;
+	comedi_cmd *cmd;
+	unsigned int max_points, num_points, residue, leftover;
+	sampl_t dpnt;
+	static const int sample_size = sizeof(devpriv->dma_buffer[0]);
+
+	if (dev->attached == 0) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+	// initialize async here to make sure s is not NULL
+	async = s->async;
+	async->events = 0;
+	cmd = &async->cmd;
+
+	status = inw(dev->iobase + STATUS_REG);
+
+	if ((status & INTR_BIT) == 0) {
+		comedi_error(dev, "spurious interrupt");
+		return IRQ_NONE;
+	}
+
+	if (status & OVFL_BIT) {
+		comedi_error(dev, "fifo overflow");
+		a2150_cancel(dev, s);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+	}
+
+	if ((status & DMA_TC_BIT) == 0) {
+		comedi_error(dev, "caught non-dma interrupt?  Aborting.");
+		a2150_cancel(dev, s);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		return IRQ_HANDLED;
+	}
+
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma);
+
+	// figure out how many points to read
+	max_points = devpriv->dma_transfer_size / sample_size;
+	/* residue is the number of points left to be done on the dma
+	 * transfer.  It should always be zero at this point unless
+	 * the stop_src is set to external triggering.
+	 */
+	residue = get_dma_residue(devpriv->dma) / sample_size;
+	num_points = max_points - residue;
+	if (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)
+		num_points = devpriv->count;
+
+	// figure out how many points will be stored next time
+	leftover = 0;
+	if (cmd->stop_src == TRIG_NONE) {
+		leftover = devpriv->dma_transfer_size / sample_size;
+	} else if (devpriv->count > max_points) {
+		leftover = devpriv->count - max_points;
+		if (leftover > max_points)
+			leftover = max_points;
+	}
+	/* there should only be a residue if collection was stopped by having
+	 * the stop_src set to an external trigger, in which case there
+	 * will be no more data
+	 */
+	if (residue)
+		leftover = 0;
+
+	for (i = 0; i < num_points; i++) {
+		/* write data point to comedi buffer */
+		dpnt = devpriv->dma_buffer[i];
+		// convert from 2's complement to unsigned coding
+		dpnt ^= 0x8000;
+		cfc_write_to_buffer(s, dpnt);
+		if (cmd->stop_src == TRIG_COUNT) {
+			if (--devpriv->count == 0) {	/* end of acquisition */
+				a2150_cancel(dev, s);
+				async->events |= COMEDI_CB_EOA;
+				break;
+			}
+		}
+	}
+	// re-enable  dma
+	if (leftover) {
+		set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
+		set_dma_count(devpriv->dma, leftover * sample_size);
+		enable_dma(devpriv->dma);
+	}
+	release_dma_lock(flags);
+
+	async->events |= COMEDI_CB_BLOCK;
+
+	comedi_event(dev, s);
+
+	/* clear interrupt */
+	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
+
+	return IRQ_HANDLED;
+}
+
+// probes board type, returns offset
+static int a2150_probe(comedi_device * dev)
+{
+	int status = inw(dev->iobase + STATUS_REG);
+	return ID_BITS(status);
+}
+
+static int a2150_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned long iobase = it->options[0];
+	unsigned int irq = it->options[1];
+	unsigned int dma = it->options[2];
+	static const int timeout = 2000;
+	int i;
+
+	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_a2150.driver_name,
+		iobase);
+	if (irq) {
+		printk(", irq %u", irq);
+	} else {
+		printk(", no irq");
+	}
+	if (dma) {
+		printk(", dma %u", dma);
+	} else {
+		printk(", no dma");
+	}
+	printk("\n");
+
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(a2150_private)) < 0)
+		return -ENOMEM;
+
+	if (iobase == 0) {
+		printk(" io base address required\n");
+		return -EINVAL;
+	}
+
+	/* check if io addresses are available */
+	if (!request_region(iobase, A2150_SIZE, driver_a2150.driver_name)) {
+		printk(" I/O port conflict\n");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	/* grab our IRQ */
+	if (irq) {
+		// check that irq is supported
+		if (irq < 3 || irq == 8 || irq == 13 || irq > 15) {
+			printk(" invalid irq line %u\n", irq);
+			return -EINVAL;
+		}
+		if (comedi_request_irq(irq, a2150_interrupt, 0,
+				driver_a2150.driver_name, dev)) {
+			printk("unable to allocate irq %u\n", irq);
+			return -EINVAL;
+		}
+		devpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);
+		dev->irq = irq;
+	}
+	// initialize dma
+	if (dma) {
+		if (dma == 4 || dma > 7) {
+			printk(" invalid dma channel %u\n", dma);
+			return -EINVAL;
+		}
+		if (request_dma(dma, driver_a2150.driver_name)) {
+			printk(" failed to allocate dma channel %u\n", dma);
+			return -EINVAL;
+		}
+		devpriv->dma = dma;
+		devpriv->dma_buffer =
+			kmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+		if (devpriv->dma_buffer == NULL)
+			return -ENOMEM;
+
+		disable_dma(dma);
+		set_dma_mode(dma, DMA_MODE_READ);
+
+		devpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);
+	}
+
+	dev->board_ptr = a2150_boards + a2150_probe(dev);
+	dev->board_name = thisboard->name;
+
+	if (alloc_subdevices(dev, 1) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;
+	s->n_chan = 4;
+	s->len_chanlist = 4;
+	s->maxdata = 0xffff;
+	s->range_table = &range_a2150;
+	s->do_cmd = a2150_ai_cmd;
+	s->do_cmdtest = a2150_ai_cmdtest;
+	s->insn_read = a2150_ai_rinsn;
+	s->cancel = a2150_cancel;
+
+	/* need to do this for software counting of completed conversions, to
+	 * prevent hardware count from stopping aquisition */
+	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
+
+	// set card's irq and dma levels
+	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
+
+	// reset and sync adc clock circuitry
+	outw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);
+	outw_p(DPD_BIT, dev->iobase + CONFIG_REG);
+	// initialize configuration register
+	devpriv->config_bits = 0;
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+	// wait until offset calibration is done, then enable analog inputs
+	for (i = 0; i < timeout; i++) {
+		if ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)
+			break;
+		comedi_udelay(1000);
+	}
+	if (i == timeout) {
+		printk(" timed out waiting for offset calibration to complete\n");
+		return -ETIME;
+	}
+	devpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+
+	return 0;
+};
+
+static int a2150_detach(comedi_device * dev)
+{
+	printk("comedi%d: %s: remove\n", dev->minor, driver_a2150.driver_name);
+
+	/* only free stuff if it has been allocated by _attach */
+	if (dev->iobase) {
+		// put board in power-down mode
+		outw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);
+		release_region(dev->iobase, A2150_SIZE);
+	}
+
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (devpriv) {
+		if (devpriv->dma)
+			free_dma(devpriv->dma);
+		if (devpriv->dma_buffer)
+			kfree(devpriv->dma_buffer);
+	}
+
+	return 0;
+};
+
+static int a2150_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	// disable dma on card
+	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
+	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
+
+	// disable computer's dma
+	disable_dma(devpriv->dma);
+
+	// clear fifo and reset triggering circuitry
+	outw(0, dev->iobase + FIFO_RESET_REG);
+
+	return 0;
+}
+
+static int a2150_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int startChan;
+	int i;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	// check channel/gain list against card's limitations
+	if (cmd->chanlist) {
+		startChan = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) != (startChan + i)) {
+				comedi_error(dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
+				err++;
+			}
+		}
+		if (cmd->chanlist_len == 2 && CR_CHAN(cmd->chanlist[0]) == 1) {
+			comedi_error(dev,
+				"length 2 chanlist must be channels 0,1 or channels 2,3");
+			err++;
+		}
+		if (cmd->chanlist_len == 3) {
+			comedi_error(dev,
+				"chanlist must have 1,2 or 4 channels");
+			err++;
+		}
+		if (CR_AREF(cmd->chanlist[0]) != CR_AREF(cmd->chanlist[1]) ||
+			CR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3]))
+		{
+			comedi_error(dev,
+				"channels 0/1 and 2/3 must have the same analog reference");
+			err++;
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int a2150_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned long lock_flags;
+	unsigned int old_config_bits = devpriv->config_bits;
+	unsigned int trigger_bits;
+
+	if (!dev->irq || !devpriv->dma) {
+		comedi_error(dev,
+			" irq and dma required, cannot do hardware conversions");
+		return -1;
+	}
+	if (cmd->flags & TRIG_RT) {
+		comedi_error(dev,
+			" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");
+		return -1;
+	}
+	// clear fifo and reset triggering circuitry
+	outw(0, dev->iobase + FIFO_RESET_REG);
+
+	/* setup chanlist */
+	if (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),
+			cmd->chanlist_len) < 0)
+		return -1;
+
+	// setup ac/dc coupling
+	if (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)
+		devpriv->config_bits |= AC0_BIT;
+	else
+		devpriv->config_bits &= ~AC0_BIT;
+	if (CR_AREF(cmd->chanlist[2]) == AREF_OTHER)
+		devpriv->config_bits |= AC1_BIT;
+	else
+		devpriv->config_bits &= ~AC1_BIT;
+
+	// setup timing
+	a2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);
+
+	// send timing, channel, config bits
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+
+	// initialize number of samples remaining
+	devpriv->count = cmd->stop_arg * cmd->chanlist_len;
+
+	// enable computer's dma
+	lock_flags = claim_dma_lock();
+	disable_dma(devpriv->dma);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma);
+	set_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));
+	// set size of transfer to fill in 1/3 second
+#define ONE_THIRD_SECOND 333333333
+	devpriv->dma_transfer_size =
+		sizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *
+		ONE_THIRD_SECOND / cmd->scan_begin_arg;
+	if (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)
+		devpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;
+	if (devpriv->dma_transfer_size < sizeof(devpriv->dma_buffer[0]))
+		devpriv->dma_transfer_size = sizeof(devpriv->dma_buffer[0]);
+	devpriv->dma_transfer_size -=
+		devpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);
+	set_dma_count(devpriv->dma, devpriv->dma_transfer_size);
+	enable_dma(devpriv->dma);
+	release_dma_lock(lock_flags);
+
+	/* clear dma interrupt before enabling it, to try and get rid of that
+	 * one spurious interrupt that has been happening */
+	outw(0x00, dev->iobase + DMA_TC_CLEAR_REG);
+
+	// enable dma on card
+	devpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;
+	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
+
+	// may need to wait 72 sampling periods if timing was changed
+	i8254_load(dev->iobase + I8253_BASE_REG, 0, 2, 72, 0);
+
+	// setup start triggering
+	trigger_bits = 0;
+	// decide if we need to wait 72 periods for valid data
+	if (cmd->start_src == TRIG_NOW &&
+		(old_config_bits & CLOCK_MASK) !=
+		(devpriv->config_bits & CLOCK_MASK)) {
+		// set trigger source to delay trigger
+		trigger_bits |= DELAY_TRIGGER_BITS;
+	} else {
+		// otherwise no delay
+		trigger_bits |= POST_TRIGGER_BITS;
+	}
+	// enable external hardware trigger
+	if (cmd->start_src == TRIG_EXT) {
+		trigger_bits |= HW_TRIG_EN;
+	} else if (cmd->start_src == TRIG_OTHER) {
+		// XXX add support for level/slope start trigger using TRIG_OTHER
+		comedi_error(dev, "you shouldn't see this?");
+	}
+	// send trigger config bits
+	outw(trigger_bits, dev->iobase + TRIGGER_REG);
+
+	// start aquisition for soft trigger
+	if (cmd->start_src == TRIG_NOW) {
+		outw(0, dev->iobase + FIFO_START_REG);
+	}
+#ifdef A2150_DEBUG
+	ni_dump_regs(dev);
+#endif
+
+	return 0;
+}
+
+static int a2150_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int i, n;
+	static const int timeout = 100000;
+	static const int filter_delay = 36;
+
+	// clear fifo and reset triggering circuitry
+	outw(0, dev->iobase + FIFO_RESET_REG);
+
+	/* setup chanlist */
+	if (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)
+		return -1;
+
+	// set dc coupling
+	devpriv->config_bits &= ~AC0_BIT;
+	devpriv->config_bits &= ~AC1_BIT;
+
+	// send timing, channel, config bits
+	outw(devpriv->config_bits, dev->iobase + CONFIG_REG);
+
+	// disable dma on card
+	devpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;
+	outw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);
+
+	// setup start triggering
+	outw(0, dev->iobase + TRIGGER_REG);
+
+	// start aquisition for soft trigger
+	outw(0, dev->iobase + FIFO_START_REG);
+
+	/* there is a 35.6 sample delay for data to get through the antialias filter */
+	for (n = 0; n < filter_delay; n++) {
+		for (i = 0; i < timeout; i++) {
+			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
+				break;
+			comedi_udelay(1);
+		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+		inw(dev->iobase + FIFO_DATA_REG);
+	}
+
+	// read data
+	for (n = 0; n < insn->n; n++) {
+		for (i = 0; i < timeout; i++) {
+			if (inw(dev->iobase + STATUS_REG) & FNE_BIT)
+				break;
+			comedi_udelay(1);
+		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+#ifdef A2150_DEBUG
+		ni_dump_regs(dev);
+#endif
+		data[n] = inw(dev->iobase + FIFO_DATA_REG);
+#ifdef A2150_DEBUG
+		rt_printk(" data is %i\n", data[n]);
+#endif
+		data[n] ^= 0x8000;
+	}
+
+	// clear fifo and reset triggering circuitry
+	outw(0, dev->iobase + FIFO_RESET_REG);
+
+	return n;
+}
+
+/* sets bits in devpriv->clock_bits to nearest approximation of requested period,
+ * adjusts requested period to actual timing. */
+static int a2150_get_timing(comedi_device * dev, unsigned int *period,
+	int flags)
+{
+	int lub, glb, temp;
+	int lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;
+	int i, j;
+
+	// initialize greatest lower and least upper bounds
+	lub_divisor_shift = 3;
+	lub_index = 0;
+	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
+	glb_divisor_shift = 0;
+	glb_index = thisboard->num_clocks - 1;
+	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
+
+	// make sure period is in available range
+	if (*period < glb)
+		*period = glb;
+	if (*period > lub)
+		*period = lub;
+
+	// we can multiply period by 1, 2, 4, or 8, using (1 << i)
+	for (i = 0; i < 4; i++) {
+		// there are a maximum of 4 master clocks
+		for (j = 0; j < thisboard->num_clocks; j++) {
+			// temp is the period in nanosec we are evaluating
+			temp = thisboard->clock[j] * (1 << i);
+			// if it is the best match yet
+			if (temp < lub && temp >= *period) {
+				lub_divisor_shift = i;
+				lub_index = j;
+				lub = temp;
+			}
+			if (temp > glb && temp <= *period) {
+				glb_divisor_shift = i;
+				glb_index = j;
+				glb = temp;
+			}
+		}
+	}
+	flags &= TRIG_ROUND_MASK;
+	switch (flags) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		// if least upper bound is better approximation
+		if (lub - *period < *period - glb) {
+			*period = lub;
+		} else {
+			*period = glb;
+		}
+		break;
+	case TRIG_ROUND_UP:
+		*period = lub;
+		break;
+	case TRIG_ROUND_DOWN:
+		*period = glb;
+		break;
+	}
+
+	// set clock bits for config register appropriately
+	devpriv->config_bits &= ~CLOCK_MASK;
+	if (*period == lub) {
+		devpriv->config_bits |=
+			CLOCK_SELECT_BITS(lub_index) |
+			CLOCK_DIVISOR_BITS(lub_divisor_shift);
+	} else {
+		devpriv->config_bits |=
+			CLOCK_SELECT_BITS(glb_index) |
+			CLOCK_DIVISOR_BITS(glb_divisor_shift);
+	}
+
+	return 0;
+}
+
+static int a2150_set_chanlist(comedi_device * dev, unsigned int start_channel,
+	unsigned int num_channels)
+{
+	if (start_channel + num_channels > 4)
+		return -1;
+
+	devpriv->config_bits &= ~CHANNEL_MASK;
+
+	switch (num_channels) {
+	case 1:
+		devpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);
+		break;
+	case 2:
+		if (start_channel == 0) {
+			devpriv->config_bits |= CHANNEL_BITS(0x2);
+		} else if (start_channel == 2) {
+			devpriv->config_bits |= CHANNEL_BITS(0x3);
+		} else {
+			return -1;
+		}
+		break;
+	case 4:
+		devpriv->config_bits |= CHANNEL_BITS(0x1);
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
