commit 7beaea29453bcd59ac8034f0d8fe9656f4f6fa14
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:54 2019 +0200

    staging: comedi: quatec_daqp_cs: add proper SPDX identifier to driver
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.  Because of this, add the
    GPL-2.0 identifier to the quatec_daqp_cs driver which did not have any license
    identifiers in it at all.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Brent Baccala <baccala@freesoft.org>
    Cc: David A. Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 257b0daff01f..6daaacf7a26a 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * quatech_daqp_cs.c
  * Quatech DAQP PCMCIA data capture cards COMEDI client driver

commit 1376b0a2160319125c3a2822e8c09bd283cd8141
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 5 12:36:30 2018 +0300

    staging: comedi: quatech_daqp_cs: fix no-op loop daqp_ao_insn_write()
    
    There is a '>' vs '<' typo so this loop is a no-op.
    
    Fixes: d35dcc89fc93 ("staging: comedi: quatech_daqp_cs: fix daqp_ao_insn_write()")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ea194aa01a64..257b0daff01f 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -642,7 +642,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	/* Make sure D/A update mode is direct update */
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
-	for (i = 0; i > insn->n; i++) {
+	for (i = 0; i < insn->n; i++) {
 		unsigned int val = data[i];
 		int ret;
 

commit 38614ed80220f74c08333fb5e9b2c98a2fe9cacc
Author: Eisha Chen-yen-su <chenyensu0@gmail.com>
Date:   Tue Feb 20 10:05:25 2018 +0100

    staging: comedi: Use '"%s:", __func__' instead of function name
    
    Replace all occurrences of functions' names in strings by a reference
    to __func__, to improve robustness. Problem found with checkpatch.
    
    Signed-off-by: Eisha Chen-yen-su <chenyensu0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 802f51e46405..ea194aa01a64 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -248,7 +248,7 @@ static irqreturn_t daqp_interrupt(int irq, void *dev_id)
 
 	if (loop_limit <= 0) {
 		dev_warn(dev->class_dev,
-			 "loop_limit reached in daqp_interrupt()\n");
+			 "loop_limit reached in %s()\n", __func__);
 		s->async->events |= COMEDI_CB_ERROR;
 	}
 

commit f7ede00d609d24dae6ef47d294630e81b8ce3091
Author: Nikita Eshkeev <kastolom@gmail.com>
Date:   Tue May 3 18:22:23 2016 +0300

    staging:comedi:Use unsigned int instead of unsigned
    
    This patch fixed the checkpatch.pl warning:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Nikita Eshkeev <kastolom@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index e9e43139157d..802f51e46405 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -643,7 +643,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	for (i = 0; i > insn->n; i++) {
-		unsigned val = data[i];
+		unsigned int val = data[i];
 		int ret;
 
 		/* D/A transfer rate is about 8ms */

commit 62319bceef42015d5e774e1db2e21fb5853a01bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:11 2015 -0700

    staging: comedi: quatech_daqp_cs: avoid calculating pacer divisor multiple times
    
    The pacer will either be used to trigger each conversion or to start each
    scan. Modify the (*do_cmdtest) so that one one divisor calculation is needed.
    Save the divisor value in the private data so that the (*do_cmd) does not
    have to do the calculation again.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b56d126869e3..e9e43139157d 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -144,6 +144,7 @@
 #define DAQP_MAX_TIMER_SPEED		10000	/* 100 kHz in nanoseconds */
 
 struct daqp_private {
+	unsigned int pacer_div;
 	int stop;
 };
 
@@ -359,17 +360,18 @@ static int daqp_ns_to_timer(unsigned int *ns, unsigned int flags)
 	return timer;
 }
 
-/* cmdtest tests a particular command to see if it is valid.
- * Using the cmdtest ioctl, a user can create a valid cmd
- * and then have it executed by the cmd ioctl.
- *
- * cmdtest returns 1,2,3,4 or 0, depending on which tests
- * the command passes.
- */
+static void daqp_set_pacer(struct comedi_device *dev, unsigned int val)
+{
+	outb(val & 0xff, dev->iobase + DAQP_PACER_LOW_REG);
+	outb((val >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);
+	outb((val >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);
+}
 
 static int daqp_ai_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			   struct comedi_subdevice *s,
+			   struct comedi_cmd *cmd)
 {
+	struct daqp_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -440,16 +442,14 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		arg = cmd->scan_begin_arg;
-		daqp_ns_to_timer(&arg, cmd->flags);
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
-	}
-
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		daqp_ns_to_timer(&arg, cmd->flags);
+		devpriv->pacer_div = daqp_ns_to_timer(&arg, cmd->flags);
 		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
+	} else if (cmd->scan_begin_src == TRIG_TIMER) {
+		arg = cmd->scan_begin_arg;
+		devpriv->pacer_div = daqp_ns_to_timer(&arg, cmd->flags);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)
@@ -462,7 +462,6 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct daqp_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int counter;
 	int scanlist_start_on_every_entry;
 	int threshold;
 	int ret;
@@ -488,20 +487,12 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * each scan, so we program the pacer clock to this frequency
 	 * and only set the SCANLIST_START bit on the first entry.
 	 */
+	daqp_set_pacer(dev, devpriv->pacer_div);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		counter = daqp_ns_to_timer(&cmd->convert_arg, cmd->flags);
-		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW_REG);
-		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);
-		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);
+	if (cmd->convert_src == TRIG_TIMER)
 		scanlist_start_on_every_entry = 1;
-	} else {
-		counter = daqp_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);
-		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW_REG);
-		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);
-		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);
+	else
 		scanlist_start_on_every_entry = 0;
-	}
 
 	/* Program scan list */
 	for (i = 0; i < cmd->chanlist_len; i++) {

commit 0d77ef8b43d6a9124f37b2f098b6d65573db0de3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:10 2015 -0700

    staging: comedi: quatech_daqp_cs: ai async command requires a pacer
    
    The ai (*do_cmd) assumes that either the convert_src is TRIG_TIMER or
    the scan_begin_src is TRIG_TIMER and always programs the pacer clock
    with the appropriate trigger argument.
    
    Add a Step 2b check to the (*do_cmdtest) to ensure that at least one
    of the triggers is TRIG_TIMER.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 0ea02f0e1aa2..b56d126869e3 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -394,6 +394,10 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 2b : and mutually compatible */
 
+	/* the async command requires a pacer */
+	if (cmd->scan_begin_src != TRIG_TIMER && cmd->convert_src != TRIG_TIMER)
+		err |= -EINVAL;
+
 	if (err)
 		return 2;
 

commit ac315c17f91d740c3cba4e83fcc73d7f75c967c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:09 2015 -0700

    staging: comedi: quatech_daqp_cs: cleanup Step 3 of ai (*do_cmdtest)
    
    Step 3 of the (*do_cmdtest) trivially validates the async command arguments.
    The validations also modify the arguments if they are invalid so that the
    user gets valid values if the test fails.
    
    Reorder the checks so that if any of the checks fail proper values are
    used for subsequent checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 4b9626b832ca..0ea02f0e1aa2 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -141,6 +141,8 @@
 
 #define DAQP_FIFO_SIZE			4096
 
+#define DAQP_MAX_TIMER_SPEED		10000	/* 100 kHz in nanoseconds */
+
 struct daqp_private {
 	int stop;
 };
@@ -399,31 +401,31 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-#define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
+	if (cmd->scan_begin_src == TRIG_TIMER)
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
-						    MAX_SPEED);
-	}
-
-	/* If both scan_begin and convert are both timer values, the only
-	 * way that can make sense is if the scan time is the number of
-	 * conversions times the convert time
-	 */
-
-	if (cmd->scan_begin_src == TRIG_TIMER && cmd->convert_src == TRIG_TIMER
-	    && cmd->scan_begin_arg != cmd->convert_arg * cmd->scan_end_arg) {
-		err |= -EINVAL;
-	}
+						    DAQP_MAX_TIMER_SPEED);
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-						    MAX_SPEED);
+						    DAQP_MAX_TIMER_SPEED);
+
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			/*
+			 * If both scan_begin and convert are both timer
+			 * values, the only way that can make sense is if
+			 * the scan time is the number of conversions times
+			 * the convert time.
+			 */
+			arg = cmd->convert_arg * cmd->scan_end_arg;
+			err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,
+							   arg);
+		}
 	}
 
-	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
-					   cmd->chanlist_len);
-
 	if (cmd->stop_src == TRIG_COUNT)
 		err |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
 	else	/* TRIG_NONE */

commit 848a7f7af0fb490274dc6031b0a79f4440a4948f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:08 2015 -0700

    staging: comedi: quatech_daqp_cs: fix daqp_ai_cancel()
    
    Make sure interrupts are disabled and the event flags are cleared when
    an analog input async command is canceled.
    
    Remove the unnecessary calls to stop any running conversions in the
    (*insn_read) and (*do_cmd) functions. The comedi core will only call
    these functions if the subdevice is not busy (it has already been
    canceled).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index c44e7ec19e47..4b9626b832ca 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -171,19 +171,21 @@ static int daqp_clear_events(struct comedi_device *dev, int loops)
 	return -EBUSY;
 }
 
-/* Cancel a running acquisition */
-
-static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int daqp_ai_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s)
 {
 	struct daqp_private *devpriv = dev->private;
 
 	if (devpriv->stop)
 		return -EIO;
 
+	/*
+	 * Stop any conversions, disable interrupts, and clear
+	 * the status event flags.
+	 */
 	outb(DAQP_CMD_STOP, dev->iobase + DAQP_CMD_REG);
-
-	/* flush any linguring data in FIFO - superfluous here */
-	/* outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG); */
+	outb(0, dev->iobase + DAQP_CTRL_REG);
+	inb(dev->iobase + DAQP_STATUS_REG);
 
 	return 0;
 }
@@ -298,9 +300,6 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	if (devpriv->stop)
 		return -EIO;
 
-	/* Stop any running conversion */
-	daqp_ai_cancel(dev, s);
-
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */
@@ -466,9 +465,6 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->stop)
 		return -EIO;
 
-	/* Stop any running conversion */
-	daqp_ai_cancel(dev, s);
-
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */

commit 77e7c200f37536e05f714bcebc34f58aba9eabfc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:07 2015 -0700

    staging: comedi: quatech_daqp_cs: handle shared interrupt
    
    This is a PCMCIA driver and interrupts are always shared. Detect if
    the hardware did not produce the interrupt and return IRQ_NONE so
    that other drivers might handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 7432e5761539..c44e7ec19e47 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -214,6 +214,9 @@ static irqreturn_t daqp_interrupt(int irq, void *dev_id)
 		return IRQ_NONE;
 
 	status = inb(dev->iobase + DAQP_STATUS_REG);
+	if (!(status & DAQP_STATUS_EVENTS))
+		return IRQ_NONE;
+
 	while (!(status & DAQP_STATUS_FIFO_EMPTY)) {
 		unsigned short data;
 

commit f676376d692d8e02603e2bf1d0b4e8ca1b56506d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:06 2015 -0700

    staging: comedi: quatech_daqp_cs: remove 'interrupt_mode'
    
    The interrupt handler is now only used for the ai async command.
    Remove the unnecessary 'interrupt_mode' from the private data and
    tidy up the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index bab3293a8705..7432e5761539 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -143,8 +143,6 @@
 
 struct daqp_private {
 	int stop;
-
-	enum { semaphore, buffer } interrupt_mode;
 };
 
 static const struct comedi_lrange range_daqp_ai = {
@@ -187,8 +185,6 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* flush any linguring data in FIFO - superfluous here */
 	/* outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG); */
 
-	devpriv->interrupt_mode = semaphore;
-
 	return 0;
 }
 
@@ -206,10 +202,9 @@ static unsigned int daqp_ai_get_sample(struct comedi_device *dev,
 	return comedi_offset_munge(s, val);
 }
 
-static enum irqreturn daqp_interrupt(int irq, void *dev_id)
+static irqreturn_t daqp_interrupt(int irq, void *dev_id)
 {
 	struct comedi_device *dev = dev_id;
-	struct daqp_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int loop_limit = 10000;
@@ -218,46 +213,39 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	switch (devpriv->interrupt_mode) {
-	case semaphore:
-		break;
+	status = inb(dev->iobase + DAQP_STATUS_REG);
+	while (!(status & DAQP_STATUS_FIFO_EMPTY)) {
+		unsigned short data;
 
-	case buffer:
-		while (!((status = inb(dev->iobase + DAQP_STATUS_REG))
-			 & DAQP_STATUS_FIFO_EMPTY)) {
-			unsigned short data;
+		if (status & DAQP_STATUS_DATA_LOST) {
+			s->async->events |= COMEDI_CB_OVERFLOW;
+			dev_warn(dev->class_dev, "data lost\n");
+			break;
+		}
 
-			if (status & DAQP_STATUS_DATA_LOST) {
-				s->async->events |= COMEDI_CB_OVERFLOW;
-				dev_warn(dev->class_dev, "data lost\n");
-				break;
-			}
+		data = daqp_ai_get_sample(dev, s);
+		comedi_buf_write_samples(s, &data, 1);
 
-			data = daqp_ai_get_sample(dev, s);
-			comedi_buf_write_samples(s, &data, 1);
+		if (cmd->stop_src == TRIG_COUNT &&
+		    s->async->scans_done >= cmd->stop_arg) {
+			s->async->events |= COMEDI_CB_EOA;
+			break;
+		}
 
-			/* If there's a limit, decrement it
-			 * and stop conversion if zero
-			 */
+		if ((loop_limit--) <= 0)
+			break;
 
-			if (cmd->stop_src == TRIG_COUNT &&
-			    s->async->scans_done >= cmd->stop_arg) {
-				s->async->events |= COMEDI_CB_EOA;
-				break;
-			}
+		status = inb(dev->iobase + DAQP_STATUS_REG);
+	}
 
-			if ((loop_limit--) <= 0)
-				break;
-		}
+	if (loop_limit <= 0) {
+		dev_warn(dev->class_dev,
+			 "loop_limit reached in daqp_interrupt()\n");
+		s->async->events |= COMEDI_CB_ERROR;
+	}
 
-		if (loop_limit <= 0) {
-			dev_warn(dev->class_dev,
-				 "loop_limit reached in daqp_interrupt()\n");
-			s->async->events |= COMEDI_CB_ERROR;
-		}
+	comedi_handle_events(dev, s);
 
-		comedi_handle_events(dev, s);
-	}
 	return IRQ_HANDLED;
 }
 
@@ -624,8 +612,6 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (ret)
 		return ret;
 
-	devpriv->interrupt_mode = buffer;
-
 	/* Start conversion */
 	outb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA, dev->iobase + DAQP_CMD_REG);
 

commit 7689f55b62836a5e5de2f9a5cd8d215071636013
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:05 2015 -0700

    staging: comedi: quatech_daqp_cs: only hook up cmd support if we have an IRQ
    
    Interrupts are only needed by this driver to support the analog input async
    commands. Don't hook up the command support if pcmcia_request_irq() fails
    instead of completely failing the (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 82378263a317..bab3293a8705 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -732,25 +732,28 @@ static int daqp_auto_attach(struct comedi_device *dev,
 
 	link->priv = dev;
 	ret = pcmcia_request_irq(link, daqp_interrupt);
-	if (ret)
-		return ret;
+	if (ret == 0)
+		dev->irq = link->irq;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
 
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF;
 	s->n_chan	= 8;
-	s->len_chanlist	= 2048;
 	s->maxdata	= 0xffff;
 	s->range_table	= &range_daqp_ai;
 	s->insn_read	= daqp_ai_insn_read;
-	s->do_cmdtest	= daqp_ai_cmdtest;
-	s->do_cmd	= daqp_ai_cmd;
-	s->cancel	= daqp_ai_cancel;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= 2048;
+		s->do_cmdtest	= daqp_ai_cmdtest;
+		s->do_cmd	= daqp_ai_cmd;
+		s->cancel	= daqp_ai_cancel;
+	}
 
 	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_AO;

commit 16d6b58753ccc34e6d915118984b60457d2c3327
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:04 2015 -0700

    staging: comedi: quatech_daqp_cs: don't use interrupts for ai (*insn_read)
    
    The comedi (*insn_read) functions are supposed to do simple one-shot
    reading of an analog input channel. Currently this driver enables
    interrupts and uses wait_for_completion_interruptible() to allow the
    interrupt routine to let the analog input (*insn_read) know that
    the end-of-conversion has occured.
    
    Simplify the function by using the comedi_timeout() helper to check
    the aux status register to see when the conversion is finished.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 17b614c1f831..82378263a317 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -40,8 +40,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/semaphore.h>
-#include <linux/completion.h>
 
 #include "../comedi_pcmcia.h"
 
@@ -147,8 +145,6 @@ struct daqp_private {
 	int stop;
 
 	enum { semaphore, buffer } interrupt_mode;
-
-	struct completion eos;
 };
 
 static const struct comedi_lrange range_daqp_ai = {
@@ -210,15 +206,6 @@ static unsigned int daqp_ai_get_sample(struct comedi_device *dev,
 	return comedi_offset_munge(s, val);
 }
 
-/* Interrupt handler
- *
- * Operates in one of two modes.  If devpriv->interrupt_mode is
- * 'semaphore', just signal the devpriv->eos completion and return
- * (one-shot mode).  Otherwise (continuous mode), read data in from
- * the card, transfer it to the buffer provided by the higher-level
- * comedi kernel module, and signal various comedi callback routines,
- * which run pretty quick.
- */
 static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
 	struct comedi_device *dev = dev_id;
@@ -233,7 +220,6 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 
 	switch (devpriv->interrupt_mode) {
 	case semaphore:
-		complete(&devpriv->eos);
 		break;
 
 	case buffer:
@@ -296,14 +282,26 @@ static void daqp_ai_set_one_scanlist_entry(struct comedi_device *dev,
 	outb((val >> 8) & 0xff, dev->iobase + DAQP_SCANLIST_REG);
 }
 
-/* One-shot analog data acquisition routine */
+static int daqp_ai_eos(struct comedi_device *dev,
+		       struct comedi_subdevice *s,
+		       struct comedi_insn *insn,
+		       unsigned long context)
+{
+	unsigned int status;
+
+	status = inb(dev->iobase + DAQP_AUX_REG);
+	if (status & DAQP_AUX_CONVERSION)
+		return 0;
+	return -EBUSY;
+}
 
 static int daqp_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
-	int ret;
+	int ret = 0;
 	int i;
 
 	if (devpriv->stop)
@@ -321,34 +319,35 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	daqp_ai_set_one_scanlist_entry(dev, insn->chanspec, 1);
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
-
 	outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG);
 
-	/* Set trigger - one-shot, internal */
-	outb(DAQP_CTRL_PACER_CLK_100KHZ | DAQP_CTRL_EOS_INT_ENA,
-	     dev->iobase + DAQP_CTRL_REG);
+	/* Set trigger - one-shot, internal, no interrupts */
+	outb(DAQP_CTRL_PACER_CLK_100KHZ, dev->iobase + DAQP_CTRL_REG);
 
 	ret = daqp_clear_events(dev, 10000);
 	if (ret)
 		return ret;
 
-	init_completion(&devpriv->eos);
-	devpriv->interrupt_mode = semaphore;
-
 	for (i = 0; i < insn->n; i++) {
 		/* Start conversion */
 		outb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA,
 		     dev->iobase + DAQP_CMD_REG);
 
-		/* Wait for interrupt service routine to unblock completion */
-		/* Maybe could use a timeout here, but it's interruptible */
-		if (wait_for_completion_interruptible(&devpriv->eos))
-			return -EINTR;
+		ret = comedi_timeout(dev, s, insn, daqp_ai_eos, 0);
+		if (ret)
+			break;
+
+		/* clear the status event flags */
+		inb(dev->iobase + DAQP_STATUS_REG);
 
 		data[i] = daqp_ai_get_sample(dev, s);
 	}
 
-	return insn->n;
+	/* stop any conversions and clear the status event flags */
+	outb(DAQP_CMD_STOP, dev->iobase + DAQP_CMD_REG);
+	inb(dev->iobase + DAQP_STATUS_REG);
+
+	return ret ? ret : insn->n;
 }
 
 /* This function converts ns nanoseconds to a counter value suitable

commit 3c56cdc5cc16dabd6ed0867977a6e374a3cc0da7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:03 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up aux register bitss
    
    For aesthetics, and use the BIT macro to define the bits and
    define some macros for the timer mode and d/a update bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index c575104528cf..17b614c1f831 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -116,30 +116,30 @@
 #define DAQP_TIMER_REG			0x0a	/* and 0x0b (16-bit) */
 
 #define DAQP_AUX_REG			0x0f
-
-#define DAQP_AUX_TRIGGER_TTL		0x00
-#define DAQP_AUX_TRIGGER_ANALOG		0x80
-#define DAQP_AUX_TRIGGER_PRETRIGGER	0x40
-#define DAQP_AUX_TIMER_INT_ENABLE	0x20
-#define DAQP_AUX_TIMER_RELOAD		0x00
-#define DAQP_AUX_TIMER_PAUSE		0x08
-#define DAQP_AUX_TIMER_GO		0x10
-#define DAQP_AUX_TIMER_GO_EXTERNAL	0x18
-#define DAQP_AUX_TIMER_EXTERNAL_SRC	0x04
-#define DAQP_AUX_TIMER_INTERNAL_SRC	0x00
-#define DAQP_AUX_DA_DIRECT		0x00
-#define DAQP_AUX_DA_OVERFLOW		0x01
-#define DAQP_AUX_DA_EXTERNAL		0x02
-#define DAQP_AUX_DA_PACER		0x03
-
-#define DAQP_AUX_RUNNING		0x80
-#define DAQP_AUX_TRIGGERED		0x40
-#define DAQP_AUX_DA_BUFFER		0x20
-#define DAQP_AUX_TIMER_OVERFLOW		0x10
-#define DAQP_AUX_CONVERSION		0x08
-#define DAQP_AUX_DATA_LOST		0x04
-#define DAQP_AUX_FIFO_NEARFULL		0x02
-#define DAQP_AUX_FIFO_EMPTY		0x01
+/* Auxiliary Control register bits (write) */
+#define DAQP_AUX_EXT_ANALOG_TRIG	BIT(7)
+#define DAQP_AUX_PRETRIG		BIT(6)
+#define DAQP_AUX_TIMER_INT_ENA		BIT(5)
+#define DAQP_AUX_TIMER_MODE(x)		(((x) & 0x3) << 3)
+#define DAQP_AUX_TIMER_MODE_RELOAD	DAQP_AUX_TIMER_MODE(0)
+#define DAQP_AUX_TIMER_MODE_PAUSE	DAQP_AUX_TIMER_MODE(1)
+#define DAQP_AUX_TIMER_MODE_GO		DAQP_AUX_TIMER_MODE(2)
+#define DAQP_AUX_TIMER_MODE_EXT		DAQP_AUX_TIMER_MODE(3)
+#define DAQP_AUX_TIMER_CLK_SRC_EXT	BIT(2)
+#define DAQP_AUX_DA_UPDATE(x)		(((x) & 0x3) << 0)
+#define DAQP_AUX_DA_UPDATE_DIRECT	DAQP_AUX_DA_UPDATE(0)
+#define DAQP_AUX_DA_UPDATE_OVERFLOW	DAQP_AUX_DA_UPDATE(1)
+#define DAQP_AUX_DA_UPDATE_EXTERNAL	DAQP_AUX_DA_UPDATE(2)
+#define DAQP_AUX_DA_UPDATE_PACER	DAQP_AUX_DA_UPDATE(3)
+/* Auxiliary Status register bits (read) */
+#define DAQP_AUX_RUNNING		BIT(7)
+#define DAQP_AUX_TRIGGERED		BIT(6)
+#define DAQP_AUX_DA_BUFFER		BIT(5)
+#define DAQP_AUX_TIMER_OVERFLOW		BIT(4)
+#define DAQP_AUX_CONVERSION		BIT(3)
+#define DAQP_AUX_DATA_LOST		BIT(2)
+#define DAQP_AUX_FIFO_NEARFULL		BIT(1)
+#define DAQP_AUX_FIFO_EMPTY		BIT(0)
 
 #define DAQP_FIFO_SIZE			4096
 

commit c06c3c953a9b89c1ffe70ba57762fbaafdcd6613
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:02 2015 -0700

    staging: comedi: quatech_daqp_cs: document the 16-bit registers
    
    All the registers are 8-bit except for the analog output and timer
    registers. For clarity, add some comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b7a20f7e9f35..c575104528cf 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -111,8 +111,10 @@
 #define DAQP_CMD_SCANRATE_25KHZ		DAQP_CMD_SCANRATE(2)
 #define DAQP_CMD_FIFO_DATA		BIT(0)
 
-#define DAQP_AO_REG			0x08
-#define DAQP_TIMER_REG			0x0a
+#define DAQP_AO_REG			0x08	/* and 0x09 (16-bit) */
+
+#define DAQP_TIMER_REG			0x0a	/* and 0x0b (16-bit) */
+
 #define DAQP_AUX_REG			0x0f
 
 #define DAQP_AUX_TRIGGER_TTL		0x00

commit f765b2f4fb45a9625bce619c6652b9f48510cef1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:01 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up command register bits
    
    For aesthetics, move the bit defines for this register and use the
    BIT macro to define the bits. Define a macro for the scanrate bits
    and use it to remove the CamelCase. Rename the defines to match the
    register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 29df086aa37e..b7a20f7e9f35 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -93,25 +93,28 @@
 
 #define DAQP_DI_REG			0x03
 #define DAQP_DO_REG			0x03
+
 #define DAQP_PACER_LOW_REG		0x04
 #define DAQP_PACER_MID_REG		0x05
 #define DAQP_PACER_HIGH_REG		0x06
+
 #define DAQP_CMD_REG			0x07
+/* the monostable bits are self-clearing after the function is complete */
+#define DAQP_CMD_ARM			BIT(7)	/* monostable */
+#define DAQP_CMD_RSTF			BIT(6)	/* monostable */
+#define DAQP_CMD_RSTQ			BIT(5)	/* monostable */
+#define DAQP_CMD_STOP			BIT(4)	/* monostable */
+#define DAQP_CMD_LATCH			BIT(3)	/* monostable */
+#define DAQP_CMD_SCANRATE(x)		(((x) & 0x3) << 1)
+#define DAQP_CMD_SCANRATE_100KHZ	DAQP_CMD_SCANRATE(0)
+#define DAQP_CMD_SCANRATE_50KHZ		DAQP_CMD_SCANRATE(1)
+#define DAQP_CMD_SCANRATE_25KHZ		DAQP_CMD_SCANRATE(2)
+#define DAQP_CMD_FIFO_DATA		BIT(0)
+
 #define DAQP_AO_REG			0x08
 #define DAQP_TIMER_REG			0x0a
 #define DAQP_AUX_REG			0x0f
 
-#define DAQP_COMMAND_ARM		0x80
-#define DAQP_COMMAND_RSTF		0x40
-#define DAQP_COMMAND_RSTQ		0x20
-#define DAQP_COMMAND_STOP		0x10
-#define DAQP_COMMAND_LATCH		0x08
-#define DAQP_COMMAND_100kHz		0x00
-#define DAQP_COMMAND_50kHz		0x02
-#define DAQP_COMMAND_25kHz		0x04
-#define DAQP_COMMAND_FIFO_DATA		0x01
-#define DAQP_COMMAND_FIFO_PROGRAM	0x00
-
 #define DAQP_AUX_TRIGGER_TTL		0x00
 #define DAQP_AUX_TRIGGER_ANALOG		0x80
 #define DAQP_AUX_TRIGGER_PRETRIGGER	0x40
@@ -181,10 +184,10 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->stop)
 		return -EIO;
 
-	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_STOP, dev->iobase + DAQP_CMD_REG);
 
 	/* flush any linguring data in FIFO - superfluous here */
-	/* outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG); */
+	/* outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG); */
 
 	devpriv->interrupt_mode = semaphore;
 
@@ -310,14 +313,14 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */
-	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_RSTQ, dev->iobase + DAQP_CMD_REG);
 
 	/* Program one scan list entry */
 	daqp_ai_set_one_scanlist_entry(dev, insn->chanspec, 1);
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
 
-	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG);
 
 	/* Set trigger - one-shot, internal */
 	outb(DAQP_CTRL_PACER_CLK_100KHZ | DAQP_CTRL_EOS_INT_ENA,
@@ -332,7 +335,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		/* Start conversion */
-		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
+		outb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA,
 		     dev->iobase + DAQP_CMD_REG);
 
 		/* Wait for interrupt service routine to unblock completion */
@@ -477,7 +480,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */
-	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_RSTQ, dev->iobase + DAQP_CMD_REG);
 
 	/* Program pacer clock
 	 *
@@ -595,7 +598,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
 
-	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG);
 
 	/* Set FIFO threshold.  First two bytes are near-empty
 	 * threshold, which is unused; next two bytes are near-full
@@ -623,8 +626,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->interrupt_mode = buffer;
 
 	/* Start conversion */
-	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-	     dev->iobase + DAQP_CMD_REG);
+	outb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA, dev->iobase + DAQP_CMD_REG);
 
 	return 0;
 }

commit cd644206e2db1d0249534e2c4e86cbfada4f5bd2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:23:00 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up status register bits
    
    For aesthetics, move the bit defines for this register and use the
    BIT macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 825661559cbc..29df086aa37e 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -78,6 +78,19 @@
 #define DAQP_CTRL_TRIG_EDGE		BIT(0)	/* 0=rising; 1=falling */
 
 #define DAQP_STATUS_REG			0x02
+#define DAQP_STATUS_IDLE		BIT(7)
+#define DAQP_STATUS_RUNNING		BIT(6)
+#define DAQP_STATUS_DATA_LOST		BIT(5)
+#define DAQP_STATUS_END_OF_SCAN		BIT(4)
+#define DAQP_STATUS_FIFO_THRESHOLD	BIT(3)
+#define DAQP_STATUS_FIFO_FULL		BIT(2)
+#define DAQP_STATUS_FIFO_NEARFULL	BIT(1)
+#define DAQP_STATUS_FIFO_EMPTY		BIT(0)
+/* these bits clear when the status register is read */
+#define DAQP_STATUS_EVENTS		(DAQP_STATUS_DATA_LOST |	\
+					 DAQP_STATUS_END_OF_SCAN |	\
+					 DAQP_STATUS_FIFO_THRESHOLD)
+
 #define DAQP_DI_REG			0x03
 #define DAQP_DO_REG			0x03
 #define DAQP_PACER_LOW_REG		0x04
@@ -88,16 +101,6 @@
 #define DAQP_TIMER_REG			0x0a
 #define DAQP_AUX_REG			0x0f
 
-#define DAQP_STATUS_IDLE		0x80
-#define DAQP_STATUS_RUNNING		0x40
-#define DAQP_STATUS_EVENTS		0x38
-#define DAQP_STATUS_DATA_LOST		0x20
-#define DAQP_STATUS_END_OF_SCAN		0x10
-#define DAQP_STATUS_FIFO_THRESHOLD	0x08
-#define DAQP_STATUS_FIFO_FULL		0x04
-#define DAQP_STATUS_FIFO_NEARFULL	0x02
-#define DAQP_STATUS_FIFO_EMPTY		0x01
-
 #define DAQP_COMMAND_ARM		0x80
 #define DAQP_COMMAND_RSTF		0x40
 #define DAQP_COMMAND_RSTQ		0x20

commit b0f9b0ad0fe7146fd5b23ad592ffafc541be286d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:59 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up control register bits
    
    For aesthetics, move the bit defines for this register and use the
    BIT macro to define the bits. Rename the defines to match the
    register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 8d8ffd371a08..825661559cbc 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -65,6 +65,18 @@
 #define DAQP_SCANLIST_EXT_CHANNEL(x)	(((x) & 0xf) << 0)
 
 #define DAQP_CTRL_REG			0x02
+#define DAQP_CTRL_PACER_CLK(x)		(((x) & 0x3) << 6)
+#define DAQP_CTRL_PACER_CLK_EXT		DAQP_CTRL_PACER_CLK(0)
+#define DAQP_CTRL_PACER_CLK_5MHZ	DAQP_CTRL_PACER_CLK(1)
+#define DAQP_CTRL_PACER_CLK_1MHZ	DAQP_CTRL_PACER_CLK(2)
+#define DAQP_CTRL_PACER_CLK_100KHZ	DAQP_CTRL_PACER_CLK(3)
+#define DAQP_CTRL_EXPANSION		BIT(5)
+#define DAQP_CTRL_EOS_INT_ENA		BIT(4)
+#define DAQP_CTRL_FIFO_INT_ENA		BIT(3)
+#define DAQP_CTRL_TRIG_MODE		BIT(2)	/* 0=one-shot; 1=continuous */
+#define DAQP_CTRL_TRIG_SRC		BIT(1)	/* 0=internal; 1=external */
+#define DAQP_CTRL_TRIG_EDGE		BIT(0)	/* 0=rising; 1=falling */
+
 #define DAQP_STATUS_REG			0x02
 #define DAQP_DI_REG			0x03
 #define DAQP_DO_REG			0x03
@@ -76,21 +88,6 @@
 #define DAQP_TIMER_REG			0x0a
 #define DAQP_AUX_REG			0x0f
 
-#define DAQP_CONTROL_PACER_CLK(x)	(((x) & 0x3) << 6)
-#define DAQP_CONTROL_PACER_CLK_EXT	DAQP_CONTROL_PACER_CLK(0)
-#define DAQP_CONTROL_PACER_CLK_5MHZ	DAQP_CONTROL_PACER_CLK(1)
-#define DAQP_CONTROL_PACER_CLK_1MHZ	DAQP_CONTROL_PACER_CLK(2)
-#define DAQP_CONTROL_PACER_CLK_100KHZ	DAQP_CONTROL_PACER_CLK(3)
-#define DAQP_CONTORL_EXPANSION		0x20
-#define DAQP_CONTROL_EOS_INT_ENABLE	0x10
-#define DAQP_CONTROL_FIFO_INT_ENABLE	0x08
-#define DAQP_CONTROL_TRIGGER_ONESHOT	0x00
-#define DAQP_CONTROL_TRIGGER_CONTINUOUS	0x04
-#define DAQP_CONTROL_TRIGGER_INTERNAL	0x00
-#define DAQP_CONTROL_TRIGGER_EXTERNAL	0x02
-#define DAQP_CONTROL_TRIGGER_RISING	0x00
-#define DAQP_CONTROL_TRIGGER_FALLING	0x01
-
 #define DAQP_STATUS_IDLE		0x80
 #define DAQP_STATUS_RUNNING		0x40
 #define DAQP_STATUS_EVENTS		0x38
@@ -319,9 +316,8 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG);
 
-	/* Set trigger */
-	outb(DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL |
-	     DAQP_CONTROL_PACER_CLK_100KHZ | DAQP_CONTROL_EOS_INT_ENABLE,
+	/* Set trigger - one-shot, internal */
+	outb(DAQP_CTRL_PACER_CLK_100KHZ | DAQP_CTRL_EOS_INT_ENA,
 	     dev->iobase + DAQP_CTRL_REG);
 
 	ret = daqp_clear_events(dev, 10000);
@@ -613,10 +609,9 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	     dev->iobase + DAQP_AI_FIFO_REG);
 	outb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_AI_FIFO_REG);
 
-	/* Set trigger */
-	outb(DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL |
-	     DAQP_CONTROL_PACER_CLK_5MHZ | DAQP_CONTROL_FIFO_INT_ENABLE,
-	     dev->iobase + DAQP_CTRL_REG);
+	/* Set trigger - continuous, internal */
+	outb(DAQP_CTRL_TRIG_MODE | DAQP_CTRL_PACER_CLK_5MHZ |
+	     DAQP_CTRL_FIFO_INT_ENA, dev->iobase + DAQP_CTRL_REG);
 
 	ret = daqp_clear_events(dev, 100);
 	if (ret)

commit 77e546de4cc688b8045686b079e438dafbf9812c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:58 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up scanlist register bits
    
    For aesthetics, move the bit defines for this register and use the
    BIT macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 29eb5bcaa9f5..8d8ffd371a08 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -55,7 +55,15 @@
  * access the 16-bit data. Data is transferred LSB then MSB.
  */
 #define DAQP_AI_FIFO_REG		0x00
+
 #define DAQP_SCANLIST_REG		0x01
+#define DAQP_SCANLIST_DIFFERENTIAL	BIT(14)
+#define DAQP_SCANLIST_GAIN(x)		(((x) & 0x3) << 12)
+#define DAQP_SCANLIST_CHANNEL(x)	(((x) & 0xf) << 8)
+#define DAQP_SCANLIST_START		BIT(7)
+#define DAQP_SCANLIST_EXT_GAIN(x)	(((x) & 0x3) << 4)
+#define DAQP_SCANLIST_EXT_CHANNEL(x)	(((x) & 0xf) << 0)
+
 #define DAQP_CTRL_REG			0x02
 #define DAQP_STATUS_REG			0x02
 #define DAQP_DI_REG			0x03
@@ -68,13 +76,6 @@
 #define DAQP_TIMER_REG			0x0a
 #define DAQP_AUX_REG			0x0f
 
-#define DAQP_SCANLIST_DIFFERENTIAL	0x4000
-#define DAQP_SCANLIST_GAIN(x)		((x) << 12)
-#define DAQP_SCANLIST_CHANNEL(x)	((x) << 8)
-#define DAQP_SCANLIST_START		0x0080
-#define DAQP_SCANLIST_EXT_GAIN(x)	((x) << 4)
-#define DAQP_SCANLIST_EXT_CHANNEL(x)	(x)
-
 #define DAQP_CONTROL_PACER_CLK(x)	(((x) & 0x3) << 6)
 #define DAQP_CONTROL_PACER_CLK_EXT	DAQP_CONTROL_PACER_CLK(0)
 #define DAQP_CONTROL_PACER_CLK_5MHZ	DAQP_CONTROL_PACER_CLK(1)

commit bd9d00f105bf0fb26a85f5ad3b75d0b161304478
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:57 2015 -0700

    staging: comedi: quatech_daqp_cs: rename register offsets
    
    For aesthetics, rename the register map defines and convert the
    values to hex. Also, move the private data definition and
    DAQP_FIFO_SIZE define after the register definitions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a027d20b9763..29eb5bcaa9f5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -45,30 +45,28 @@
 
 #include "../comedi_pcmcia.h"
 
-struct daqp_private {
-	int stop;
-
-	enum { semaphore, buffer } interrupt_mode;
-
-	struct completion eos;
-};
-
-/* The DAQP communicates with the system through a 16 byte I/O window. */
-
-#define DAQP_FIFO_SIZE		4096
-
-#define DAQP_FIFO		0
-#define DAQP_SCANLIST		1
-#define DAQP_CONTROL		2
-#define DAQP_STATUS		2
-#define DAQP_DIGITAL_IO		3
-#define DAQP_PACER_LOW		4
-#define DAQP_PACER_MID		5
-#define DAQP_PACER_HIGH		6
-#define DAQP_COMMAND		7
-#define DAQP_DA			8
-#define DAQP_TIMER		10
-#define DAQP_AUX		15
+/*
+ * Register I/O map
+ *
+ * The D/A and timer registers can be accessed with 16-bit or 8-bit I/O
+ * instructions. All other registers can only use 8-bit instructions.
+ *
+ * The FIFO and scanlist registers require two 8-bit instructions to
+ * access the 16-bit data. Data is transferred LSB then MSB.
+ */
+#define DAQP_AI_FIFO_REG		0x00
+#define DAQP_SCANLIST_REG		0x01
+#define DAQP_CTRL_REG			0x02
+#define DAQP_STATUS_REG			0x02
+#define DAQP_DI_REG			0x03
+#define DAQP_DO_REG			0x03
+#define DAQP_PACER_LOW_REG		0x04
+#define DAQP_PACER_MID_REG		0x05
+#define DAQP_PACER_HIGH_REG		0x06
+#define DAQP_CMD_REG			0x07
+#define DAQP_AO_REG			0x08
+#define DAQP_TIMER_REG			0x0a
+#define DAQP_AUX_REG			0x0f
 
 #define DAQP_SCANLIST_DIFFERENTIAL	0x4000
 #define DAQP_SCANLIST_GAIN(x)		((x) << 12)
@@ -137,6 +135,16 @@ struct daqp_private {
 #define DAQP_AUX_FIFO_NEARFULL		0x02
 #define DAQP_AUX_FIFO_EMPTY		0x01
 
+#define DAQP_FIFO_SIZE			4096
+
+struct daqp_private {
+	int stop;
+
+	enum { semaphore, buffer } interrupt_mode;
+
+	struct completion eos;
+};
+
 static const struct comedi_lrange range_daqp_ai = {
 	4, {
 		BIP_RANGE(10),
@@ -155,7 +163,7 @@ static int daqp_clear_events(struct comedi_device *dev, int loops)
 	 * require multiple reads on the status register to achieve this).
 	 */
 	while (--loops) {
-		status = inb(dev->iobase + DAQP_STATUS);
+		status = inb(dev->iobase + DAQP_STATUS_REG);
 		if ((status & DAQP_STATUS_EVENTS) == 0)
 			return 0;
 	}
@@ -172,10 +180,10 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->stop)
 		return -EIO;
 
-	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_COMMAND);
+	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_CMD_REG);
 
 	/* flush any linguring data in FIFO - superfluous here */
-	/* outb(DAQP_COMMAND_RSTF, dev->iobase+DAQP_COMMAND); */
+	/* outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG); */
 
 	devpriv->interrupt_mode = semaphore;
 
@@ -191,8 +199,8 @@ static unsigned int daqp_ai_get_sample(struct comedi_device *dev,
 	 * Get a two's complement sample from the FIFO and
 	 * return the munged offset binary value.
 	 */
-	val = inb(dev->iobase + DAQP_FIFO);
-	val |= inb(dev->iobase + DAQP_FIFO) << 8;
+	val = inb(dev->iobase + DAQP_AI_FIFO_REG);
+	val |= inb(dev->iobase + DAQP_AI_FIFO_REG) << 8;
 	return comedi_offset_munge(s, val);
 }
 
@@ -223,7 +231,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 		break;
 
 	case buffer:
-		while (!((status = inb(dev->iobase + DAQP_STATUS))
+		while (!((status = inb(dev->iobase + DAQP_STATUS_REG))
 			 & DAQP_STATUS_FIFO_EMPTY)) {
 			unsigned short data;
 
@@ -278,8 +286,8 @@ static void daqp_ai_set_one_scanlist_entry(struct comedi_device *dev,
 	if (start)
 		val |= DAQP_SCANLIST_START;
 
-	outb(val & 0xff, dev->iobase + DAQP_SCANLIST);
-	outb((val >> 8) & 0xff, dev->iobase + DAQP_SCANLIST);
+	outb(val & 0xff, dev->iobase + DAQP_SCANLIST_REG);
+	outb((val >> 8) & 0xff, dev->iobase + DAQP_SCANLIST_REG);
 }
 
 /* One-shot analog data acquisition routine */
@@ -298,22 +306,22 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
 
-	outb(0, dev->iobase + DAQP_AUX);
+	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */
-	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_COMMAND);
+	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_CMD_REG);
 
 	/* Program one scan list entry */
 	daqp_ai_set_one_scanlist_entry(dev, insn->chanspec, 1);
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
 
-	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_COMMAND);
+	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG);
 
 	/* Set trigger */
 	outb(DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL |
 	     DAQP_CONTROL_PACER_CLK_100KHZ | DAQP_CONTROL_EOS_INT_ENABLE,
-	     dev->iobase + DAQP_CONTROL);
+	     dev->iobase + DAQP_CTRL_REG);
 
 	ret = daqp_clear_events(dev, 10000);
 	if (ret)
@@ -325,7 +333,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	for (i = 0; i < insn->n; i++) {
 		/* Start conversion */
 		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-		     dev->iobase + DAQP_COMMAND);
+		     dev->iobase + DAQP_CMD_REG);
 
 		/* Wait for interrupt service routine to unblock completion */
 		/* Maybe could use a timeout here, but it's interruptible */
@@ -466,10 +474,10 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
 
-	outb(0, dev->iobase + DAQP_AUX);
+	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	/* Reset scan list queue */
-	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_COMMAND);
+	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_CMD_REG);
 
 	/* Program pacer clock
 	 *
@@ -486,15 +494,15 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		counter = daqp_ns_to_timer(&cmd->convert_arg, cmd->flags);
-		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
-		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
-		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
+		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW_REG);
+		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);
+		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);
 		scanlist_start_on_every_entry = 1;
 	} else {
 		counter = daqp_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);
-		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
-		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
-		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
+		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW_REG);
+		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);
+		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);
 		scanlist_start_on_every_entry = 0;
 	}
 
@@ -587,7 +595,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
 
-	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_COMMAND);
+	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_CMD_REG);
 
 	/* Set FIFO threshold.  First two bytes are near-empty
 	 * threshold, which is unused; next two bytes are near-full
@@ -597,16 +605,17 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * when the interrupt is to happen.
 	 */
 
-	outb(0x00, dev->iobase + DAQP_FIFO);
-	outb(0x00, dev->iobase + DAQP_FIFO);
+	outb(0x00, dev->iobase + DAQP_AI_FIFO_REG);
+	outb(0x00, dev->iobase + DAQP_AI_FIFO_REG);
 
-	outb((DAQP_FIFO_SIZE - threshold) & 0xff, dev->iobase + DAQP_FIFO);
-	outb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_FIFO);
+	outb((DAQP_FIFO_SIZE - threshold) & 0xff,
+	     dev->iobase + DAQP_AI_FIFO_REG);
+	outb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_AI_FIFO_REG);
 
 	/* Set trigger */
 	outb(DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL |
 	     DAQP_CONTROL_PACER_CLK_5MHZ | DAQP_CONTROL_FIFO_INT_ENABLE,
-	     dev->iobase + DAQP_CONTROL);
+	     dev->iobase + DAQP_CTRL_REG);
 
 	ret = daqp_clear_events(dev, 100);
 	if (ret)
@@ -616,7 +625,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* Start conversion */
 	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-	     dev->iobase + DAQP_COMMAND);
+	     dev->iobase + DAQP_CMD_REG);
 
 	return 0;
 }
@@ -628,7 +637,7 @@ static int daqp_ao_empty(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inb(dev->iobase + DAQP_AUX);
+	status = inb(dev->iobase + DAQP_AUX_REG);
 	if ((status & DAQP_AUX_DA_BUFFER) == 0)
 		return 0;
 	return -EBUSY;
@@ -647,7 +656,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 		return -EIO;
 
 	/* Make sure D/A update mode is direct update */
-	outb(0, dev->iobase + DAQP_AUX);
+	outb(0, dev->iobase + DAQP_AUX_REG);
 
 	for (i = 0; i > insn->n; i++) {
 		unsigned val = data[i];
@@ -660,7 +669,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 
 		/* write the two's complement value to the channel */
 		outw((chan << 12) | comedi_offset_munge(s, val),
-		     dev->iobase + DAQP_DA);
+		     dev->iobase + DAQP_AO_REG);
 
 		s->readback[chan] = val;
 	}
@@ -678,7 +687,7 @@ static int daqp_di_insn_bits(struct comedi_device *dev,
 	if (devpriv->stop)
 		return -EIO;
 
-	data[0] = inb(dev->iobase + DAQP_DIGITAL_IO);
+	data[0] = inb(dev->iobase + DAQP_DI_REG);
 
 	return insn->n;
 }
@@ -694,7 +703,7 @@ static int daqp_do_insn_bits(struct comedi_device *dev,
 		return -EIO;
 
 	if (comedi_dio_update_state(s, data))
-		outb(s->state, dev->iobase + DAQP_DIGITAL_IO);
+		outb(s->state, dev->iobase + DAQP_DO_REG);
 
 	data[1] = s->state;
 

commit ed811a328a161794e1e2dda0a75c6925cfd6ddcd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:56 2015 -0700

    staging: comedi: quatech_daqp_cs: tidy up multi-line comments
    
    Reformat the multi-line comments in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 2f353050e9e6..a027d20b9763 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1,51 +1,43 @@
-/*======================================================================
-
-    comedi/drivers/quatech_daqp_cs.c
-
-    Quatech DAQP PCMCIA data capture cards COMEDI client driver
-    Copyright (C) 2000, 2003 Brent Baccala <baccala@freesoft.org>
-    The DAQP interface code in this file is released into the public domain.
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1998 David A. Schleef <ds@schleef.org>
-    http://www.comedi.org/
-
-    quatech_daqp_cs.c 1.10
-
-    Documentation for the DAQP PCMCIA cards can be found on Quatech's site:
-
-		ftp://ftp.quatech.com/Manuals/daqp-208.pdf
-
-    This manual is for both the DAQP-208 and the DAQP-308.
-
-    What works:
-
-	- A/D conversion
-	    - 8 channels
-	    - 4 gain ranges
-	    - ground ref or differential
-	    - single-shot and timed both supported
-	- D/A conversion, single-shot
-	- digital I/O
-
-    What doesn't:
-
-	- any kind of triggering - external or D/A channel 1
-	- the card's optional expansion board
-	- the card's timer (for anything other than A/D conversion)
-	- D/A update modes other than immediate (i.e, timed)
-	- fancier timing modes
-	- setting card's FIFO buffer thresholds to anything but default
-
-======================================================================*/
+/*
+ * quatech_daqp_cs.c
+ * Quatech DAQP PCMCIA data capture cards COMEDI client driver
+ * Copyright (C) 2000, 2003 Brent Baccala <baccala@freesoft.org>
+ * The DAQP interface code in this file is released into the public domain.
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1998 David A. Schleef <ds@schleef.org>
+ * http://www.comedi.org/
+ *
+ * Documentation for the DAQP PCMCIA cards can be found on Quatech's site:
+ *	ftp://ftp.quatech.com/Manuals/daqp-208.pdf
+ *
+ * This manual is for both the DAQP-208 and the DAQP-308.
+ *
+ * What works:
+ * - A/D conversion
+ *	- 8 channels
+ *	- 4 gain ranges
+ *	- ground ref or differential
+ *	- single-shot and timed both supported
+ * - D/A conversion, single-shot
+ * - digital I/O
+ *
+ * What doesn't:
+ * - any kind of triggering - external or D/A channel 1
+ * - the card's optional expansion board
+ * - the card's timer (for anything other than A/D conversion)
+ * - D/A update modes other than immediate (i.e, timed)
+ * - fancier timing modes
+ * - setting card's FIFO buffer thresholds to anything but default
+ */
 
 /*
-Driver: quatech_daqp_cs
-Description: Quatech DAQP PCMCIA data capture cards
-Author: Brent Baccala <baccala@freesoft.org>
-Status: works
-Devices: [Quatech] DAQP-208 (daqp), DAQP-308
-*/
+ * Driver: quatech_daqp_cs
+ * Description: Quatech DAQP PCMCIA data capture cards
+ * Devices: [Quatech] DAQP-208 (daqp), DAQP-308
+ * Author: Brent Baccala <baccala@freesoft.org>
+ * Status: works
+ */
 
 #include <linux/module.h>
 #include <linux/semaphore.h>

commit d9952688a33a79cf756de6a8392b9c1eec90cab1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:55 2015 -0700

    staging: comedi: quatech_daqp_cs: introduce daqp_clear_events()
    
    Introduce a helper function for the common code used to clear any
    pending interrupts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 0d814fff94ff..2f353050e9e6 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -154,6 +154,23 @@ static const struct comedi_lrange range_daqp_ai = {
 	}
 };
 
+static int daqp_clear_events(struct comedi_device *dev, int loops)
+{
+	unsigned int status;
+
+	/*
+	 * Reset any pending interrupts (my card has a tendency to require
+	 * require multiple reads on the status register to achieve this).
+	 */
+	while (--loops) {
+		status = inb(dev->iobase + DAQP_STATUS);
+		if ((status & DAQP_STATUS_EVENTS) == 0)
+			return 0;
+	}
+	dev_err(dev->class_dev, "couldn't clear events in status register\n");
+	return -EBUSY;
+}
+
 /* Cancel a running acquisition */
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -280,8 +297,8 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
+	int ret;
 	int i;
-	int counter = 10000;
 
 	if (devpriv->stop)
 		return -EIO;
@@ -306,18 +323,9 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	     DAQP_CONTROL_PACER_CLK_100KHZ | DAQP_CONTROL_EOS_INT_ENABLE,
 	     dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendency to require
-	 * require multiple reads on the status register to achieve this)
-	 */
-
-	while (--counter
-	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS))
-		;
-	if (!counter) {
-		dev_err(dev->class_dev,
-			"couldn't clear interrupts in status register\n");
-		return -1;
-	}
+	ret = daqp_clear_events(dev, 10000);
+	if (ret)
+		return ret;
 
 	init_completion(&devpriv->eos);
 	devpriv->interrupt_mode = semaphore;
@@ -457,6 +465,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int counter;
 	int scanlist_start_on_every_entry;
 	int threshold;
+	int ret;
 	int i;
 
 	if (devpriv->stop)
@@ -607,18 +616,9 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	     DAQP_CONTROL_PACER_CLK_5MHZ | DAQP_CONTROL_FIFO_INT_ENABLE,
 	     dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendency to require
-	 * require multiple reads on the status register to achieve this)
-	 */
-	counter = 100;
-	while (--counter
-	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS))
-		;
-	if (!counter) {
-		dev_err(dev->class_dev,
-			"couldn't clear interrupts in status register\n");
-		return -1;
-	}
+	ret = daqp_clear_events(dev, 100);
+	if (ret)
+		return ret;
 
 	devpriv->interrupt_mode = buffer;
 

commit 075d58164e1271d9da3796fb883db9928b13f91b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:54 2015 -0700

    staging: comedi: quatech_daqp_cs: redefine pacer clock options
    
    For aesthetics, define a macro for the pacer clock options and rename
    the CamelCase.
    
    Remove the unnecessary local variables used to set the control register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a2bbba1bfc04..0d814fff94ff 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -85,10 +85,11 @@ struct daqp_private {
 #define DAQP_SCANLIST_EXT_GAIN(x)	((x) << 4)
 #define DAQP_SCANLIST_EXT_CHANNEL(x)	(x)
 
-#define DAQP_CONTROL_PACER_100kHz	0xc0
-#define DAQP_CONTROL_PACER_1MHz		0x80
-#define DAQP_CONTROL_PACER_5MHz		0x40
-#define DAQP_CONTROL_PACER_EXTERNAL	0x00
+#define DAQP_CONTROL_PACER_CLK(x)	(((x) & 0x3) << 6)
+#define DAQP_CONTROL_PACER_CLK_EXT	DAQP_CONTROL_PACER_CLK(0)
+#define DAQP_CONTROL_PACER_CLK_5MHZ	DAQP_CONTROL_PACER_CLK(1)
+#define DAQP_CONTROL_PACER_CLK_1MHZ	DAQP_CONTROL_PACER_CLK(2)
+#define DAQP_CONTROL_PACER_CLK_100KHZ	DAQP_CONTROL_PACER_CLK(3)
 #define DAQP_CONTORL_EXPANSION		0x20
 #define DAQP_CONTROL_EOS_INT_ENABLE	0x10
 #define DAQP_CONTROL_FIFO_INT_ENABLE	0x08
@@ -280,7 +281,6 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 {
 	struct daqp_private *devpriv = dev->private;
 	int i;
-	int v;
 	int counter = 10000;
 
 	if (devpriv->stop)
@@ -302,11 +302,9 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_COMMAND);
 
 	/* Set trigger */
-
-	v = DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL
-	    | DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
-
-	outb(v, dev->iobase + DAQP_CONTROL);
+	outb(DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL |
+	     DAQP_CONTROL_PACER_CLK_100KHZ | DAQP_CONTROL_EOS_INT_ENABLE,
+	     dev->iobase + DAQP_CONTROL);
 
 	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)
@@ -459,9 +457,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int counter;
 	int scanlist_start_on_every_entry;
 	int threshold;
-
 	int i;
-	int v;
 
 	if (devpriv->stop)
 		return -EIO;
@@ -607,11 +603,9 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_FIFO);
 
 	/* Set trigger */
-
-	v = DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL
-	    | DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
-
-	outb(v, dev->iobase + DAQP_CONTROL);
+	outb(DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL |
+	     DAQP_CONTROL_PACER_CLK_5MHZ | DAQP_CONTROL_FIFO_INT_ENABLE,
+	     dev->iobase + DAQP_CONTROL);
 
 	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)

commit 491205bbc6fbab7388732297037a9a2fc16c3616
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:53 2015 -0700

    staging: comedi: quatech_daqp_cs: spaces preferred around that '<<'
    
    Fix the checkpatch.pl issues about:
    CHECK: spaces preferred around that '<<' (ctx:VxV)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ab336ce329f2..a2bbba1bfc04 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -79,10 +79,10 @@ struct daqp_private {
 #define DAQP_AUX		15
 
 #define DAQP_SCANLIST_DIFFERENTIAL	0x4000
-#define DAQP_SCANLIST_GAIN(x)		((x)<<12)
-#define DAQP_SCANLIST_CHANNEL(x)	((x)<<8)
+#define DAQP_SCANLIST_GAIN(x)		((x) << 12)
+#define DAQP_SCANLIST_CHANNEL(x)	((x) << 8)
 #define DAQP_SCANLIST_START		0x0080
-#define DAQP_SCANLIST_EXT_GAIN(x)	((x)<<4)
+#define DAQP_SCANLIST_EXT_GAIN(x)	((x) << 4)
 #define DAQP_SCANLIST_EXT_CHANNEL(x)	(x)
 
 #define DAQP_CONTROL_PACER_100kHz	0xc0

commit e031642eccc040648b09cfc7d632e2e8d0b6f94f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:52 2015 -0700

    staging: comedi: quatech_daqp_cs: use comedi_timeout() in ao (*insn_write)
    
    The data link between the D/A data port and the D/A converter is a serial
    link. The serial link requires about 8ms to complete a transfer. Use the
    comedi_timeout() helper to ensure that there is not a previous transfer
    still happening before trying to write new data to the channel.
    
    For aesthetics, save the readback value after updating the hardware.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 4f87147213d1..ab336ce329f2 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -635,6 +635,19 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int daqp_ao_empty(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 struct comedi_insn *insn,
+			 unsigned long context)
+{
+	unsigned int status;
+
+	status = inb(dev->iobase + DAQP_AUX);
+	if ((status & DAQP_AUX_DA_BUFFER) == 0)
+		return 0;
+	return -EBUSY;
+}
+
 static int daqp_ao_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn,
@@ -652,12 +665,18 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 
 	for (i = 0; i > insn->n; i++) {
 		unsigned val = data[i];
+		int ret;
 
-		s->readback[chan] = val;
+		/* D/A transfer rate is about 8ms */
+		ret = comedi_timeout(dev, s, insn, daqp_ao_empty, 0);
+		if (ret)
+			return ret;
 
 		/* write the two's complement value to the channel */
 		outw((chan << 12) | comedi_offset_munge(s, val),
 		     dev->iobase + DAQP_DA);
+
+		s->readback[chan] = val;
 	}
 
 	return insn->n;

commit 1271dd24c63478b08fc574ec8b4fa50902b368f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:51 2015 -0700

    staging: comedi: quatech_daqp_cs: use comedi_offset_munge() in ao (*insn_write)
    
    Use the comedi_offset_munge() helper to do the offset binary to two's
    complement conversion when writing a new analog output value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index cf144ce553c1..4f87147213d1 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -655,11 +655,9 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 
 		s->readback[chan] = val;
 
-		val &= 0x0fff;
-		val ^= 0x0800;		/* Flip the sign */
-		val |= (chan << 12);
-
-		outw(val, dev->iobase + DAQP_DA);
+		/* write the two's complement value to the channel */
+		outw((chan << 12) | comedi_offset_munge(s, val),
+		     dev->iobase + DAQP_DA);
 	}
 
 	return insn->n;

commit c3f7e15383a9e86a56820c34d5ef761c4682e47b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:50 2015 -0700

    staging: comedi: quatech_daqp_cs: introduce daqp_ai_get_sample()
    
    Introduce a helper function to get a two's complement sample from
    the FIFO and munge it to the offset binary format that comedi uses.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b2effb876b77..cf144ce553c1 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -172,6 +172,20 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static unsigned int daqp_ai_get_sample(struct comedi_device *dev,
+				       struct comedi_subdevice *s)
+{
+	unsigned int val;
+
+	/*
+	 * Get a two's complement sample from the FIFO and
+	 * return the munged offset binary value.
+	 */
+	val = inb(dev->iobase + DAQP_FIFO);
+	val |= inb(dev->iobase + DAQP_FIFO) << 8;
+	return comedi_offset_munge(s, val);
+}
+
 /* Interrupt handler
  *
  * Operates in one of two modes.  If devpriv->interrupt_mode is
@@ -209,10 +223,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 				break;
 			}
 
-			data = inb(dev->iobase + DAQP_FIFO);
-			data |= inb(dev->iobase + DAQP_FIFO) << 8;
-			data ^= 0x8000;
-
+			data = daqp_ai_get_sample(dev, s);
 			comedi_buf_write_samples(s, &data, 1);
 
 			/* If there's a limit, decrement it
@@ -323,9 +334,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 		if (wait_for_completion_interruptible(&devpriv->eos))
 			return -EINTR;
 
-		data[i] = inb(dev->iobase + DAQP_FIFO);
-		data[i] |= inb(dev->iobase + DAQP_FIFO) << 8;
-		data[i] ^= 0x8000;
+		data[i] = daqp_ai_get_sample(dev, s);
 	}
 
 	return insn->n;

commit 4d6b700801bfeef15a059fc6739bfcd741cd9c15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:49 2015 -0700

    staging: comedi: quatech_daqp_cs: there are 4 digital inputs
    
    This board has 4 digital inputs not 1. Fix the subdevice init.
    
    The digital input lines are shared with other functions. Add a
    comment about this.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a4a5244ab8a8..b2effb876b77 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -741,10 +741,21 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
+	/*
+	 * Digital Input subdevice
+	 * NOTE: The digital input lines are shared:
+	 *
+	 * Chan  Normal Mode        Expansion Mode
+	 * ----  -----------------  ----------------------------
+	 *  0    DI0, ext. trigger  Same as normal mode
+	 *  1    DI1                External gain select, lo bit
+	 *  2    DI2, ext. clock    Same as normal mode
+	 *  3    DI3                External gain select, hi bit
+	 */
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DI;
 	s->subdev_flags	= SDF_READABLE;
-	s->n_chan	= 1;
+	s->n_chan	= 4;
 	s->maxdata	= 1;
 	s->insn_bits	= daqp_di_insn_bits;
 

commit 23d4f0245f6f48ee374069110b86c75166d1e152
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 5 14:22:48 2015 -0700

    staging: comedi: quatech_daqp_cs: there are 4 digital outputs
    
    This board has 4 digital outputs not 1. Fix the subdevice init.
    
    The digital output lines are used for the external channel selection
    when the expansion mode is enabled. Add a comment about this.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 152cb146fc16..a4a5244ab8a8 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -748,10 +748,17 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 1;
 	s->insn_bits	= daqp_di_insn_bits;
 
+	/*
+	 * Digital Output subdevice
+	 * NOTE: The digital output lines share the same pins on the
+	 * interface connector as the four external channel selection
+	 * bits. If expansion mode is used the digital outputs do not
+	 * work.
+	 */
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_DO;
 	s->subdev_flags	= SDF_WRITABLE;
-	s->n_chan	= 1;
+	s->n_chan	= 4;
 	s->maxdata	= 1;
 	s->insn_bits	= daqp_do_insn_bits;
 

commit 75a12586cb717fb57197d3b3a9467ebab216c984
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:34 2015 +0000

    staging: comedi: quatech_daqp_cs: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index aa8653465771..152cb146fc16 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -52,7 +52,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #include <linux/completion.h>
 
 #include "../comedi_pcmcia.h"
-#include "comedi_fc.h"
 
 struct daqp_private {
 	int stop;
@@ -365,22 +364,22 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_TIMER | TRIG_FOLLOW);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
+	err |= comedi_check_trigger_src(&cmd->convert_src,
 					TRIG_TIMER | TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -389,13 +388,14 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 #define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 MAX_SPEED);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    MAX_SPEED);
+	}
 
 	/* If both scan_begin and convert are both timer values, the only
 	 * way that can make sense is if the scan time is the number of
@@ -407,15 +407,18 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 		err |= -EINVAL;
 	}
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, MAX_SPEED);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    MAX_SPEED);
+	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+		err |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -425,13 +428,13 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		daqp_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
 		daqp_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 8387fd0e4b7e..aa8653465771 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -315,7 +315,6 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	devpriv->interrupt_mode = semaphore;
 
 	for (i = 0; i < insn->n; i++) {
-
 		/* Start conversion */
 		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
 		     dev->iobase + DAQP_COMMAND);

commit f0dff1a4b1fb21c499eb25969abea41dcabf9987
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Jan 30 09:57:25 2015 +0000

    staging: comedi: quatech_daqp_cs: include new "comedi_pcmcia.h" header
    
    Include the new "../comedi_pcmcia.h" header instead of
    <pcmcia/cistpl.h>, <pcmcia/cisreg.h>, <pcmcia/ds.h> and
    "../comedidev.h".  <pcmcia/cisreg.h> isn't needed and the others will
    now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index dd06734f2158..8387fd0e4b7e 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -48,15 +48,10 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 */
 
 #include <linux/module.h>
-#include "../comedidev.h"
 #include <linux/semaphore.h>
-
-#include <pcmcia/cistpl.h>
-#include <pcmcia/cisreg.h>
-#include <pcmcia/ds.h>
-
 #include <linux/completion.h>
 
+#include "../comedi_pcmcia.h"
 #include "comedi_fc.h"
 
 struct daqp_private {

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 96098110b0b3..dd06734f2158 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -210,8 +210,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			unsigned short data;
 
 			if (status & DAQP_STATUS_DATA_LOST) {
-				s->async->events |=
-				    COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
+				s->async->events |= COMEDI_CB_OVERFLOW;
 				dev_warn(dev->class_dev, "data lost\n");
 				break;
 			}
@@ -239,7 +238,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 		if (loop_limit <= 0) {
 			dev_warn(dev->class_dev,
 				 "loop_limit reached in daqp_interrupt()\n");
-			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+			s->async->events |= COMEDI_CB_ERROR;
 		}
 
 		comedi_handle_events(dev, s);

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f77485b28fe2..96098110b0b3 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -740,7 +740,6 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar5;
 	s->insn_write	= daqp_ao_insn_write;
-	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 2d7840c70dcf526326a770d8a993c80ef7cae43f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:40 2014 -0700

    staging: comedi: quatech_daqp_cs: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 0630df367494..f77485b28fe2 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -65,8 +65,6 @@ struct daqp_private {
 	enum { semaphore, buffer } interrupt_mode;
 
 	struct completion eos;
-
-	int count;
 };
 
 /* The DAQP communicates with the system through a 16 byte I/O window. */
@@ -194,6 +192,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	struct comedi_device *dev = dev_id;
 	struct daqp_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int loop_limit = 10000;
 	int status;
 
@@ -227,12 +226,10 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			 * and stop conversion if zero
 			 */
 
-			if (devpriv->count > 0) {
-				devpriv->count--;
-				if (devpriv->count == 0) {
-					s->async->events |= COMEDI_CB_EOA;
-					break;
-				}
+			if (cmd->stop_src == TRIG_COUNT &&
+			    s->async->scans_done >= cmd->stop_arg) {
+				s->async->events |= COMEDI_CB_EOA;
+				break;
 			}
 
 			if ((loop_limit--) <= 0)
@@ -573,12 +570,16 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->count = cmd->stop_arg * cmd->scan_end_arg;
-		threshold = 2 * devpriv->count;
-		while (threshold > DAQP_FIFO_SIZE * 3 / 4)
-			threshold /= 2;
+		unsigned long long nsamples;
+		unsigned long long nbytes;
+
+		nsamples = (unsigned long long)cmd->stop_arg *
+			   cmd->scan_end_arg;
+		nbytes = nsamples * comedi_bytes_per_sample(s);
+		while (nbytes > DAQP_FIFO_SIZE * 3 / 4)
+			nbytes /= 2;
+		threshold = nbytes;
 	} else {
-		devpriv->count = -1;
 		threshold = DAQP_FIFO_SIZE / 2;
 	}
 

commit ef49d8329e25ee1686520315713b86419cddcb45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:34 2014 -0700

    staging: comedi: drivers: replace SDF_WRITEABLE with SDF_WRITABLE
    
    As indicated in the comedi.h uapi header, SDF_WRITEABLE was a spelling
    error in the API, SDF_WRITABLE is prefered.
    
    For aesthetics, replace all the SDF_WRITEABLE uses with SDF_WRITABLE.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f6c678eef8d5..0630df367494 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -734,7 +734,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[1];
 	s->type		= COMEDI_SUBD_AO;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 2;
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar5;
@@ -754,7 +754,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_DO;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 1;
 	s->maxdata	= 1;
 	s->insn_bits	= daqp_do_insn_bits;

commit a4a68fe2a264778d1452b64964ebf65670ef774d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:05 2014 -0700

    staging: comedi: quatech_daqp_cs: use comedi_buf_write_samples()
    
    For aesthetics, use comedi_buf_write_samples() to add the sample to the
    async buffer.
    
    The core will add the COMEDI_CB_BLOCK event when data is written to the
    async buffer. Remove the unnecessary event in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 21e99fdf28ad..f6c678eef8d5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -221,7 +221,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			data |= inb(dev->iobase + DAQP_FIFO) << 8;
 			data ^= 0x8000;
 
-			comedi_buf_put(s, data);
+			comedi_buf_write_samples(s, &data, 1);
 
 			/* If there's a limit, decrement it
 			 * and stop conversion if zero
@@ -245,8 +245,6 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		}
 
-		s->async->events |= COMEDI_CB_BLOCK;
-
 		comedi_handle_events(dev, s);
 	}
 	return IRQ_HANDLED;

commit 44aaad2d5f775e9dcb269f5202d2bc4b9d10d3fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:35 2014 -0700

    staging: comedi: quatech_daqp_cs: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 6407df0404f0..21e99fdf28ad 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -247,7 +247,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 
 		s->async->events |= COMEDI_CB_BLOCK;
 
-		cfc_handle_events(dev, s);
+		comedi_handle_events(dev, s);
 	}
 	return IRQ_HANDLED;
 }

commit 92b667754628ac86d8354378c839266e07b8a295
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:34 2014 -0700

    staging: comedi: quatech_daqp_cs: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 489f4c8ab862..6407df0404f0 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -649,6 +649,8 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	for (i = 0; i > insn->n; i++) {
 		unsigned val = data[i];
 
+		s->readback[chan] = val;
+
 		val &= 0x0fff;
 		val ^= 0x0800;		/* Flip the sign */
 		val |= (chan << 12);
@@ -739,6 +741,11 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar5;
 	s->insn_write	= daqp_ao_insn_write;
+	s->insn_read	= comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
 
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DI;

commit e024181b02ed6b833358bede3f2d0c52cb5fb6bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:33 2014 -0700

    staging: comedi: quatech_daqp_cs: fix bug in daqp_ao_insn_write()
    
    The comedi core expects (*insn_write) functions to write insn->n values
    to the hardware and return the number of values written.
    
    Currently, this function only writes the first value. Fix it to work
    like the core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b1db61d9d834..489f4c8ab862 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -638,7 +638,6 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 {
 	struct daqp_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val;
 	int i;
 
 	if (devpriv->stop)
@@ -648,7 +647,8 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	outb(0, dev->iobase + DAQP_AUX);
 
 	for (i = 0; i > insn->n; i++) {
-		val = data[0];
+		unsigned val = data[i];
+
 		val &= 0x0fff;
 		val ^= 0x0800;		/* Flip the sign */
 		val |= (chan << 12);

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b3bbec0a0d23..b1db61d9d834 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -351,7 +351,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
  * time that the device will use.
  */
 
-static int daqp_ns_to_timer(unsigned int *ns, int round)
+static int daqp_ns_to_timer(unsigned int *ns, unsigned int flags)
 {
 	int timer;
 
@@ -436,13 +436,13 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		daqp_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		daqp_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		daqp_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		daqp_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
@@ -488,15 +488,13 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		counter = daqp_ns_to_timer(&cmd->convert_arg,
-					       cmd->flags & TRIG_ROUND_MASK);
+		counter = daqp_ns_to_timer(&cmd->convert_arg, cmd->flags);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
 		scanlist_start_on_every_entry = 1;
 	} else {
-		counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
-					       cmd->flags & TRIG_ROUND_MASK);
+		counter = daqp_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);

commit 6c71941d3da2714602b2ccc146882647824d270e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:57 2014 -0700

    staging: comedi: quatech_daqp_cs: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 0a8edb8cc190..b3bbec0a0d23 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -373,7 +373,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -435,19 +435,15 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
-		daqp_ns_to_timer(&cmd->scan_begin_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+		arg = cmd->scan_begin_arg;
+		daqp_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
-		daqp_ns_to_timer(&cmd->convert_arg,
-				 cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->convert_arg)
-			err++;
+		arg = cmd->convert_arg;
+		daqp_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 298dba03f902..0a8edb8cc190 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -221,7 +221,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			data |= inb(dev->iobase + DAQP_FIFO) << 8;
 			data ^= 0x8000;
 
-			comedi_buf_put(s->async, data);
+			comedi_buf_put(s, data);
 
 			/* If there's a limit, decrement it
 			 * and stop conversion if zero

commit fb6aa25009ff7c8ec65673d5a34d7191dc6c5894
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:45 2014 -0700

    staging: comedi: quatech_daqp_cs: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Update the Kconfig so that COMEDI_QUATECH_DAQP_CS selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 96a46954b3c0..298dba03f902 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -214,7 +214,6 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 				s->async->events |=
 				    COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
 				dev_warn(dev->class_dev, "data lost\n");
-				daqp_ai_cancel(dev, s);
 				break;
 			}
 
@@ -231,7 +230,6 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			if (devpriv->count > 0) {
 				devpriv->count--;
 				if (devpriv->count == 0) {
-					daqp_ai_cancel(dev, s);
 					s->async->events |= COMEDI_CB_EOA;
 					break;
 				}
@@ -244,13 +242,12 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 		if (loop_limit <= 0) {
 			dev_warn(dev->class_dev,
 				 "loop_limit reached in daqp_interrupt()\n");
-			daqp_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		}
 
 		s->async->events |= COMEDI_CB_BLOCK;
 
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 	}
 	return IRQ_HANDLED;
 }

commit 8bab0d680e247f47e5d6f063b68684ad25bad450
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:34 2013 +0100

    staging: comedi: quatech_daqp_cs: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change `daqp_interrupt()` to use unsigned sample values for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ece3031711eb..96a46954b3c0 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -208,8 +208,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	case buffer:
 		while (!((status = inb(dev->iobase + DAQP_STATUS))
 			 & DAQP_STATUS_FIFO_EMPTY)) {
-
-			short data;
+			unsigned short data;
 
 			if (status & DAQP_STATUS_DATA_LOST) {
 				s->async->events |=

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 9775d3622a62..ece3031711eb 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -690,18 +690,12 @@ static int daqp_do_insn_bits(struct comedi_device *dev,
 			     unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
 
 	if (devpriv->stop)
 		return -EIO;
 
-	if (mask) {
-		s->state &= ~mask;
-		s->state |= (bits & mask);
-
+	if (comedi_dio_update_state(s, data))
 		outb(s->state, dev->iobase + DAQP_DIGITAL_IO);
-	}
 
 	data[1] = s->state;
 

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 478a97271a48..9775d3622a62 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -47,6 +47,7 @@ Status: works
 Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 */
 
+#include <linux/module.h>
 #include "../comedidev.h"
 #include <linux/semaphore.h>
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index e092ce87722e..478a97271a48 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -715,10 +715,9 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
 	ret = comedi_pcmcia_enable(dev, NULL);

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 911eb6b32296..e092ce87722e 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -715,8 +715,6 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;

commit a9d50943b80803bfeca18632d75645062e02f133
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Feb 6 14:12:07 2013 -0700

    staging: comedi: quatech_daqp_cs: fix build error
    
    The kbuild test robot reported a build error in this driver caused by:
    
    commit: a3ac95195b020a0a8fa2a9b0649145324ba64c83
    staging: comedi: comedi_pcmcia: allow drivers to use a custom conf_check()
    
    This commit changed the comedi_pcmcia_enable() function so that it now
    takes two arguments. The new argument is an optional (*conf_check)
    function that is passed to pcmcia_loop_config().
    
    This driver uses the default (*conf_check) in comedi_pcmcia.c so just
    pass a NULL as the second arg.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 6ab9083a032f..911eb6b32296 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -723,7 +723,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	dev->private = devpriv;
 
 	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
-	ret = comedi_pcmcia_enable(dev);
+	ret = comedi_pcmcia_enable(dev, NULL);
 	if (ret)
 		return ret;
 	dev->iobase = link->resource[0]->start;

commit bd7807f96464d1053c6c5fd867461c6e64a766f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:44:57 2013 -0700

    staging: comedi: quatech_daqp_cs: factor out common ai scanlist code
    
    Factor the code that programs the analog input scanlist out of the
    daqp_ai_insn_read() and daqp_ai_cmd() functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b50ba5466e91..6ab9083a032f 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -255,6 +255,27 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void daqp_ai_set_one_scanlist_entry(struct comedi_device *dev,
+					   unsigned int chanspec,
+					   int start)
+{
+	unsigned int chan = CR_CHAN(chanspec);
+	unsigned int range = CR_RANGE(chanspec);
+	unsigned int aref = CR_AREF(chanspec);
+	unsigned int val;
+
+	val = DAQP_SCANLIST_CHANNEL(chan) | DAQP_SCANLIST_GAIN(range);
+
+	if (aref == AREF_DIFF)
+		val |= DAQP_SCANLIST_DIFFERENTIAL;
+
+	if (start)
+		val |= DAQP_SCANLIST_START;
+
+	outb(val & 0xff, dev->iobase + DAQP_SCANLIST);
+	outb((val >> 8) & 0xff, dev->iobase + DAQP_SCANLIST);
+}
+
 /* One-shot analog data acquisition routine */
 
 static int daqp_ai_insn_read(struct comedi_device *dev,
@@ -278,18 +299,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_COMMAND);
 
 	/* Program one scan list entry */
-
-	v = DAQP_SCANLIST_CHANNEL(CR_CHAN(insn->chanspec))
-	    | DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
-
-	if (CR_AREF(insn->chanspec) == AREF_DIFF)
-		v |= DAQP_SCANLIST_DIFFERENTIAL;
-
-
-	v |= DAQP_SCANLIST_START;
-
-	outb(v & 0xff, dev->iobase + DAQP_SCANLIST);
-	outb(v >> 8, dev->iobase + DAQP_SCANLIST);
+	daqp_ai_set_one_scanlist_entry(dev, insn->chanspec, 1);
 
 	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
 
@@ -501,24 +511,10 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* Program scan list */
-
 	for (i = 0; i < cmd->chanlist_len; i++) {
+		int start = (i == 0 || scanlist_start_on_every_entry);
 
-		int chanspec = cmd->chanlist[i];
-
-		/* Program one scan list entry */
-
-		v = DAQP_SCANLIST_CHANNEL(CR_CHAN(chanspec))
-		    | DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
-
-		if (CR_AREF(chanspec) == AREF_DIFF)
-			v |= DAQP_SCANLIST_DIFFERENTIAL;
-
-		if (i == 0 || scanlist_start_on_every_entry)
-			v |= DAQP_SCANLIST_START;
-
-		outb(v & 0xff, dev->iobase + DAQP_SCANLIST);
-		outb(v >> 8, dev->iobase + DAQP_SCANLIST);
+		daqp_ai_set_one_scanlist_entry(dev, cmd->chanlist[i], start);
 	}
 
 	/* Now it's time to program the FIFO threshold, basically the

commit d35dcc89fc93d8f071fc7f88ae87697a77bb99d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:44:37 2013 -0700

    staging: comedi: quatech_daqp_cs: fix daqp_ao_insn_write()
    
    The (*insn_write) functions are expected to write 'insn->n' number
    of samples to the channel. Fix this function so it works as the
    comedi core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f11104252c96..b50ba5466e91 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -644,31 +644,32 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/* Single-shot analog output routine */
-
 static int daqp_ao_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
-	int d;
-	unsigned int chan;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val;
+	int i;
 
 	if (devpriv->stop)
 		return -EIO;
 
-	chan = CR_CHAN(insn->chanspec);
-	d = data[0];
-	d &= 0x0fff;
-	d ^= 0x0800;		/* Flip the sign */
-	d |= chan << 12;
-
 	/* Make sure D/A update mode is direct update */
 	outb(0, dev->iobase + DAQP_AUX);
 
-	outw(d, dev->iobase + DAQP_DA);
+	for (i = 0; i > insn->n; i++) {
+		val = data[0];
+		val &= 0x0fff;
+		val ^= 0x0800;		/* Flip the sign */
+		val |= (chan << 12);
 
-	return 1;
+		outw(val, dev->iobase + DAQP_DA);
+	}
+
+	return insn->n;
 }
 
 static int daqp_di_insn_bits(struct comedi_device *dev,

commit 6a911d8aa54bc79256e766580a19bbd91e76d48f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:44:17 2013 -0700

    staging: comedi: quatech_daqp_cs: use (*insn_bits) for digital outputs
    
    Change the subdevice operation used to write the digital outputs from
    a (*insn_write) to a (*insn_bits) function. The (*insn_write) functions
    are expected to write 'insn->n' number of samples. The (*insn_bits)
    functions just write a single sample (insn->n = 1). Change the return
    from '1' to 'insn->n' to clarify what the return is.
    
    Using an (*insn_bits) function to write the digital outputs also allows
    the user to read the current state of the output channels.
    
    Fix the io operation used to update the digital outputs. The register is
    only 8-bits and should by updated with an outb() not an outw().
    
    Also, set the 'maxdata' for the subdevice. For digital io this value
    should be '1' (digital io can only be 1 or 0).
    
    Remove the setting of the len_chanlist for the subdevice. This variable
    only has meaning for subdevices that support asynchronous commands. The
    comedi core will initialize it appropriately during the postconfig.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index dbb8593a8db8..f11104252c96 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -686,20 +686,28 @@ static int daqp_di_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* Digital output routine */
-
-static int daqp_do_insn_write(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+static int daqp_do_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
 
 	if (devpriv->stop)
 		return -EIO;
 
-	outw(data[0] & 0xf, dev->iobase + DAQP_DIGITAL_IO);
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
 
-	return 1;
+		outb(s->state, dev->iobase + DAQP_DIGITAL_IO);
+	}
+
+	data[1] = s->state;
+
+	return insn->n;
 }
 
 static int daqp_auto_attach(struct comedi_device *dev,
@@ -764,8 +772,8 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->type		= COMEDI_SUBD_DO;
 	s->subdev_flags	= SDF_WRITEABLE;
 	s->n_chan	= 1;
-	s->len_chanlist	= 1;
-	s->insn_write	= daqp_do_insn_write;
+	s->maxdata	= 1;
+	s->insn_bits	= daqp_do_insn_bits;
 
 	return 0;
 }

commit 62100fefbc4f7f45149df1f537de17b4acf01391
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:43:56 2013 -0700

    staging: comedi: quatech_daqp_cs: use (*insn_bits) for digital inputs
    
    Change the subdevice operation used to read the digital inputs from
    a (*insn_read) to a (*insn_bits) function. The (*insn_read) functions
    are expected to read 'insn->n' number of samples. The (*insn_bits)
    functions just read a single sample (insn->n = 1). Change the return
    from '1' to 'insn->n' to clarify what the return is.
    
    Also, set the 'maxdata' for the subdevice. For digital io this value
    should be '1' (digital io can only be 1 or 0).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 7046ebdee01d..dbb8593a8db8 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -671,11 +671,10 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-/* Digital input routine */
-
-static int daqp_di_insn_read(struct comedi_device *dev,
+static int daqp_di_insn_bits(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
 	struct daqp_private *devpriv = dev->private;
 
@@ -684,7 +683,7 @@ static int daqp_di_insn_read(struct comedi_device *dev,
 
 	data[0] = inb(dev->iobase + DAQP_DIGITAL_IO);
 
-	return 1;
+	return insn->n;
 }
 
 /* Digital output routine */
@@ -758,7 +757,8 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->type		= COMEDI_SUBD_DI;
 	s->subdev_flags	= SDF_READABLE;
 	s->n_chan	= 1;
-	s->insn_read	= daqp_di_insn_read;
+	s->maxdata	= 1;
+	s->insn_bits	= daqp_di_insn_bits;
 
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_DO;

commit 491cc0b042c2c2e7db0b2013e802f1d0124d1611
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:43:37 2013 -0700

    staging: comedi: quatech_daqp_cs: remove unused define
    
    The MAX_DEV define is no longer used in this driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f91e5f595a80..7046ebdee01d 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -58,9 +58,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 
 #include "comedi_fc.h"
 
-/* Maximum number of separate DAQP devices we'll allow */
-#define MAX_DEV         4
-
 struct daqp_private {
 	int stop;
 

commit 1801726e87787273d8473bd35a95935629a4e947
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:43:19 2013 -0700

    staging: comedi: quatech_daqp_cs: rename the private data struct
    
    The private data in this driver is associated with the comedi_device
    pointer not the pcmcia_device. For aesthetic reasons, rename the
    private data struct from local_into_t to daqp_private.
    
    Also, rename the local variables used for the private data from
    local to devpriv as that is more common in the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 8b644f567656..f91e5f595a80 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -61,7 +61,7 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 /* Maximum number of separate DAQP devices we'll allow */
 #define MAX_DEV         4
 
-struct local_info_t {
+struct daqp_private {
 	int stop;
 
 	enum { semaphore, buffer } interrupt_mode;
@@ -167,26 +167,25 @@ static const struct comedi_lrange range_daqp_ai = {
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
-
 	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_COMMAND);
 
 	/* flush any linguring data in FIFO - superfluous here */
 	/* outb(DAQP_COMMAND_RSTF, dev->iobase+DAQP_COMMAND); */
 
-	local->interrupt_mode = semaphore;
+	devpriv->interrupt_mode = semaphore;
 
 	return 0;
 }
 
 /* Interrupt handler
  *
- * Operates in one of two modes.  If local->interrupt_mode is
- * 'semaphore', just signal the local->eos completion and return
+ * Operates in one of two modes.  If devpriv->interrupt_mode is
+ * 'semaphore', just signal the devpriv->eos completion and return
  * (one-shot mode).  Otherwise (continuous mode), read data in from
  * the card, transfer it to the buffer provided by the higher-level
  * comedi kernel module, and signal various comedi callback routines,
@@ -195,7 +194,7 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
 	struct comedi_device *dev = dev_id;
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	int loop_limit = 10000;
 	int status;
@@ -203,15 +202,12 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	switch (local->interrupt_mode) {
-
+	switch (devpriv->interrupt_mode) {
 	case semaphore:
-
-		complete(&local->eos);
+		complete(&devpriv->eos);
 		break;
 
 	case buffer:
-
 		while (!((status = inb(dev->iobase + DAQP_STATUS))
 			 & DAQP_STATUS_FIFO_EMPTY)) {
 
@@ -235,9 +231,9 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			 * and stop conversion if zero
 			 */
 
-			if (local->count > 0) {
-				local->count--;
-				if (local->count == 0) {
+			if (devpriv->count > 0) {
+				devpriv->count--;
+				if (devpriv->count == 0) {
 					daqp_ai_cancel(dev, s);
 					s->async->events |= COMEDI_CB_EOA;
 					break;
@@ -268,15 +264,14 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 	int i;
 	int v;
 	int counter = 10000;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
-
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
 
@@ -323,8 +318,8 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 		return -1;
 	}
 
-	init_completion(&local->eos);
-	local->interrupt_mode = semaphore;
+	init_completion(&devpriv->eos);
+	devpriv->interrupt_mode = semaphore;
 
 	for (i = 0; i < insn->n; i++) {
 
@@ -334,7 +329,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 		/* Wait for interrupt service routine to unblock completion */
 		/* Maybe could use a timeout here, but it's interruptible */
-		if (wait_for_completion_interruptible(&local->eos))
+		if (wait_for_completion_interruptible(&devpriv->eos))
 			return -EINTR;
 
 		data[i] = inb(dev->iobase + DAQP_FIFO);
@@ -459,7 +454,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter;
 	int scanlist_start_on_every_entry;
@@ -468,10 +463,9 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int i;
 	int v;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
-
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
 
@@ -593,16 +587,16 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* Save away the number of conversions we should perform, and
 	 * compute the FIFO threshold (in bytes, not samples - that's
-	 * why we multiple local->count by 2 = sizeof(sample))
+	 * why we multiple devpriv->count by 2 = sizeof(sample))
 	 */
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		local->count = cmd->stop_arg * cmd->scan_end_arg;
-		threshold = 2 * local->count;
+		devpriv->count = cmd->stop_arg * cmd->scan_end_arg;
+		threshold = 2 * devpriv->count;
 		while (threshold > DAQP_FIFO_SIZE * 3 / 4)
 			threshold /= 2;
 	} else {
-		local->count = -1;
+		devpriv->count = -1;
 		threshold = DAQP_FIFO_SIZE / 2;
 	}
 
@@ -644,7 +638,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -1;
 	}
 
-	local->interrupt_mode = buffer;
+	devpriv->interrupt_mode = buffer;
 
 	/* Start conversion */
 	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
@@ -659,11 +653,11 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 	int d;
 	unsigned int chan;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
 	chan = CR_CHAN(insn->chanspec);
@@ -686,9 +680,9 @@ static int daqp_di_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
 	data[0] = inb(dev->iobase + DAQP_DIGITAL_IO);
@@ -702,9 +696,9 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = dev->private;
+	struct daqp_private *devpriv = dev->private;
 
-	if (local->stop)
+	if (devpriv->stop)
 		return -EIO;
 
 	outw(data[0] & 0xf, dev->iobase + DAQP_DIGITAL_IO);
@@ -716,17 +710,16 @@ static int daqp_auto_attach(struct comedi_device *dev,
 			    unsigned long context)
 {
 	struct pcmcia_device *link = comedi_to_pcmcia_dev(dev);
-	struct local_info_t *local;
+	struct daqp_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
 	dev->board_name = dev->driver->driver_name;
 
-	/* Allocate space for private device-specific data */
-	local = kzalloc(sizeof(*local), GFP_KERNEL);
-	if (!local)
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
 		return -ENOMEM;
-	dev->private = local;
+	dev->private = devpriv;
 
 	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
 	ret = comedi_pcmcia_enable(dev);
@@ -790,11 +783,11 @@ static struct comedi_driver driver_daqp = {
 static int daqp_cs_suspend(struct pcmcia_device *link)
 {
 	struct comedi_device *dev = link->priv;
-	struct local_info_t *local = dev ? dev->private : NULL;
+	struct daqp_private *devpriv = dev ? dev->private : NULL;
 
 	/* Mark the device as stopped, to block IO until later */
-	if (local)
-		local->stop = 1;
+	if (devpriv)
+		devpriv->stop = 1;
 
 	return 0;
 }
@@ -802,10 +795,10 @@ static int daqp_cs_suspend(struct pcmcia_device *link)
 static int daqp_cs_resume(struct pcmcia_device *link)
 {
 	struct comedi_device *dev = link->priv;
-	struct local_info_t *local = dev ? dev->private : NULL;
+	struct daqp_private *devpriv = dev ? dev->private : NULL;
 
-	if (local)
-		local->stop = 0;
+	if (devpriv)
+		devpriv->stop = 0;
 
 	return 0;
 }

commit c12717423e1c61682fada53193813248095cba44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:42:56 2013 -0700

    staging: comedi: quatech_daqp_cs: store private data in the comedi_device
    
    All the comedi_subdevices in this driver use the same 'local' private data.
    Instead of storing the pointer to the private data in each subdevice, just
    store it in the comedi_device.
    
    Also, instead of passing the private data pointer to pcmcia_request_irq()
    in link->priv, pass the comedi_device pointer. This allows removing the
    comedi_device and comedi_subdevice pointers from the private data. We can
    get them as needed from the void * in the interrupt function.
    
    Fix the pcmcia suspend/resume functions so they use the comedi_device
    pointer stored in link->priv to then get the private data pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 40d525c57786..8b644f567656 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -68,8 +68,6 @@ struct local_info_t {
 
 	struct completion eos;
 
-	struct comedi_device *dev;
-	struct comedi_subdevice *s;
 	int count;
 };
 
@@ -169,7 +167,7 @@ static const struct comedi_lrange range_daqp_ai = {
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 
 	if (local->stop)
 		return -EIO;
@@ -196,13 +194,13 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  */
 static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
-	struct local_info_t *local = dev_id;
-	struct comedi_device *dev = local ? local->dev : NULL;
-	struct comedi_subdevice *s = local ? local->s : NULL;
+	struct comedi_device *dev = dev_id;
+	struct local_info_t *local = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
 	int loop_limit = 10000;
 	int status;
 
-	if (!dev || !dev->attached || !s || s->private != local)
+	if (!dev->attached)
 		return IRQ_NONE;
 
 	switch (local->interrupt_mode) {
@@ -270,7 +268,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 	int i;
 	int v;
 	int counter = 10000;
@@ -327,8 +325,6 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 	init_completion(&local->eos);
 	local->interrupt_mode = semaphore;
-	local->dev = dev;
-	local->s = s;
 
 	for (i = 0; i < insn->n; i++) {
 
@@ -463,7 +459,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter;
 	int scanlist_start_on_every_entry;
@@ -649,8 +645,6 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	local->interrupt_mode = buffer;
-	local->dev = dev;
-	local->s = s;
 
 	/* Start conversion */
 	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
@@ -665,7 +659,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 	int d;
 	unsigned int chan;
 
@@ -692,7 +686,7 @@ static int daqp_di_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 
 	if (local->stop)
 		return -EIO;
@@ -708,7 +702,7 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = s->private;
+	struct local_info_t *local = dev->private;
 
 	if (local->stop)
 		return -EIO;
@@ -732,6 +726,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	local = kzalloc(sizeof(*local), GFP_KERNEL);
 	if (!local)
 		return -ENOMEM;
+	dev->private = local;
 
 	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
 	ret = comedi_pcmcia_enable(dev);
@@ -739,7 +734,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 		return ret;
 	dev->iobase = link->resource[0]->start;
 
-	link->priv = local;
+	link->priv = dev;
 	ret = pcmcia_request_irq(link, daqp_interrupt);
 	if (ret)
 		return ret;
@@ -750,7 +745,6 @@ static int daqp_auto_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
-	s->private	= local;
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
 	s->n_chan	= 8;
@@ -763,7 +757,6 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->cancel	= daqp_ai_cancel;
 
 	s = &dev->subdevices[1];
-	s->private	= local;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITEABLE;
 	s->n_chan	= 2;
@@ -772,14 +765,12 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->insn_write	= daqp_ao_insn_write;
 
 	s = &dev->subdevices[2];
-	s->private	= local;
 	s->type		= COMEDI_SUBD_DI;
 	s->subdev_flags	= SDF_READABLE;
 	s->n_chan	= 1;
 	s->insn_read	= daqp_di_insn_read;
 
 	s = &dev->subdevices[3];
-	s->private	= local;
 	s->type		= COMEDI_SUBD_DO;
 	s->subdev_flags	= SDF_WRITEABLE;
 	s->n_chan	= 1;
@@ -798,18 +789,23 @@ static struct comedi_driver driver_daqp = {
 
 static int daqp_cs_suspend(struct pcmcia_device *link)
 {
-	struct local_info_t *local = link->priv;
+	struct comedi_device *dev = link->priv;
+	struct local_info_t *local = dev ? dev->private : NULL;
 
 	/* Mark the device as stopped, to block IO until later */
-	local->stop = 1;
+	if (local)
+		local->stop = 1;
+
 	return 0;
 }
 
 static int daqp_cs_resume(struct pcmcia_device *link)
 {
-	struct local_info_t *local = link->priv;
+	struct comedi_device *dev = link->priv;
+	struct local_info_t *local = dev ? dev->private : NULL;
 
-	local->stop = 0;
+	if (local)
+		local->stop = 0;
 
 	return 0;
 }

commit 9c1dcce9c64c2b53042f2cfb730348201d176855
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:42:32 2013 -0700

    staging: comedi: quatech_daqp_cs: ao subdevice does not support commands
    
    The analog output subdevice does not support aynchronous commands.
    Don't set the dev->write_subdev to this subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 6eab3bbb378b..40d525c57786 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -763,7 +763,6 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	s->cancel	= daqp_ai_cancel;
 
 	s = &dev->subdevices[1];
-	dev->write_subdev = s;
 	s->private	= local;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITEABLE;

commit 25736670bce6b860910ca789ab628bde46be71e6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:42:09 2013 -0700

    staging: comedi: quatech_daqp_cs: use comedi_pcmcia_disable() for (*detach)
    
    The (*detach) function, daqp_detach() is now a simple wrapper around
    comedi_pcmcia_disable(). Just use comedi_pcmcia_disable() directly for
    the (*detach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 869a4afc440e..6eab3bbb378b 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -790,16 +790,11 @@ static int daqp_auto_attach(struct comedi_device *dev,
 	return 0;
 }
 
-static void daqp_detach(struct comedi_device *dev)
-{
-	comedi_pcmcia_disable(dev);
-}
-
 static struct comedi_driver driver_daqp = {
 	.driver_name	= "quatech_daqp_cs",
 	.module		= THIS_MODULE,
 	.auto_attach	= daqp_auto_attach,
-	.detach		= daqp_detach,
+	.detach		= comedi_pcmcia_disable,
 };
 
 static int daqp_cs_suspend(struct pcmcia_device *link)

commit 87fe1452c6b0154e43fa7c544977279a504ad0e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:41:49 2013 -0700

    staging: comedi: quatech_daqp_cs: use comedi_pcmcia_{enable, disable}
    
    Use the comedi_pcmcia_{enable,disable} helpers to enable/disable
    the PCMCIA device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 64092363fd31..869a4afc440e 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -718,14 +718,6 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
-{
-	if (p_dev->config_index == 0)
-		return -EINVAL;
-
-	return pcmcia_request_io(p_dev);
-}
-
 static int daqp_auto_attach(struct comedi_device *dev,
 			    unsigned long context)
 {
@@ -742,20 +734,16 @@ static int daqp_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 
 	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
-	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
+	ret = comedi_pcmcia_enable(dev);
 	if (ret)
 		return ret;
+	dev->iobase = link->resource[0]->start;
 
 	link->priv = local;
 	ret = pcmcia_request_irq(link, daqp_interrupt);
 	if (ret)
 		return ret;
 
-	ret = pcmcia_enable_device(link);
-	if (ret)
-		return ret;
-	dev->iobase = link->resource[0]->start;
-
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
@@ -804,9 +792,7 @@ static int daqp_auto_attach(struct comedi_device *dev,
 
 static void daqp_detach(struct comedi_device *dev)
 {
-	struct pcmcia_device *link = comedi_to_pcmcia_dev(dev);
-
-	pcmcia_disable_device(link);
+	comedi_pcmcia_disable(dev);
 }
 
 static struct comedi_driver driver_daqp = {

commit c04edbf2f4194d1f76dd6d0fc5d64600867eae70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 4 16:41:30 2013 -0700

    staging: comedi: quatech_daqp_cs: convert to auto attach
    
    Convert this pcmcia driver to the comedi auto attach mechanism.
    
    This allows getting rid of the static data that held "A list of
    "instances" of the device" that was used to pass the pcmcia_device
    pointer from the pcmcia_driver to the comedi_driver.
    
    Also, remove the now unused variables in the private data that
    were used to pass the pcmcia_device.
    
    Remove the code that pulled the model number of the card out of
    the PCMCIA CIS and stashed it in the private data since it is
    not used in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 2c35d75aef52..64092363fd31 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -62,10 +62,7 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #define MAX_DEV         4
 
 struct local_info_t {
-	struct pcmcia_device *link;
 	int stop;
-	int table_index;
-	char board_name[32];
 
 	enum { semaphore, buffer } interrupt_mode;
 
@@ -76,10 +73,6 @@ struct local_info_t {
 	int count;
 };
 
-/* A list of "instances" of the device. */
-
-static struct local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
-
 /* The DAQP communicates with the system through a 16 byte I/O window. */
 
 #define DAQP_FIFO_SIZE		4096
@@ -725,43 +718,43 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 	return 1;
 }
 
-/* daqp_attach is called via comedi_config to attach a comedi device
- * to a /dev/comedi*.  Note that this is different from daqp_cs_attach()
- * which is called by the pcmcia subsystem to attach the PCMCIA card
- * when it is inserted.
- */
+static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
+{
+	if (p_dev->config_index == 0)
+		return -EINVAL;
+
+	return pcmcia_request_io(p_dev);
+}
 
-static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int daqp_auto_attach(struct comedi_device *dev,
+			    unsigned long context)
 {
+	struct pcmcia_device *link = comedi_to_pcmcia_dev(dev);
 	struct local_info_t *local;
 	struct comedi_subdevice *s;
 	int ret;
 
-	if (it->options[0] < 0 || it->options[0] >= MAX_DEV)
-		return -ENODEV;
+	dev->board_name = dev->driver->driver_name;
 
-	local = dev_table[it->options[0]];
+	/* Allocate space for private device-specific data */
+	local = kzalloc(sizeof(*local), GFP_KERNEL);
 	if (!local)
-		return -ENODEV;
-
-	/* Typically brittle code that I don't completely understand,
-	 * but "it works on my card".  The intent is to pull the model
-	 * number of the card out the PCMCIA CIS and stash it away as
-	 * the COMEDI board_name.  Looks like the third field in
-	 * CISTPL_VERS_1 (offset 2) holds what we're looking for.  If
-	 * it doesn't work, who cares, just leave it as "DAQP".
-	 */
+		return -ENOMEM;
 
-	strcpy(local->board_name, "DAQP");
-	dev->board_name = local->board_name;
-	if (local->link->prod_id[2]) {
-		if (strncmp(local->link->prod_id[2], "DAQP", 4) == 0) {
-			strncpy(local->board_name, local->link->prod_id[2],
-				sizeof(local->board_name));
-		}
-	}
+	link->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;
+	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
+	if (ret)
+		return ret;
 
-	dev->iobase = local->link->resource[0]->start;
+	link->priv = local;
+	ret = pcmcia_request_irq(link, daqp_interrupt);
+	if (ret)
+		return ret;
+
+	ret = pcmcia_enable_device(link);
+	if (ret)
+		return ret;
+	dev->iobase = link->resource[0]->start;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
@@ -811,51 +804,18 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void daqp_detach(struct comedi_device *dev)
 {
-	/* Nothing to cleanup */
+	struct pcmcia_device *link = comedi_to_pcmcia_dev(dev);
+
+	pcmcia_disable_device(link);
 }
 
 static struct comedi_driver driver_daqp = {
 	.driver_name	= "quatech_daqp_cs",
 	.module		= THIS_MODULE,
-	.attach		= daqp_attach,
+	.auto_attach	= daqp_auto_attach,
 	.detach		= daqp_detach,
 };
 
-/*====================================================================
-
-    PCMCIA interface code
-
-    The rest of the code in this file is based on dummy_cs.c v1.24
-    from the Linux pcmcia_cs distribution v3.1.8 and is subject
-    to the following license agreement.
-
-    The remaining contents of this file are subject to the Mozilla Public
-    License Version 1.1 (the "License"); you may not use this file
-    except in compliance with the License. You may obtain a copy of
-    the License at http://www.mozilla.org/MPL/
-
-    Software distributed under the License is distributed on an "AS
-    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-    implied. See the License for the specific language governing
-    rights and limitations under the License.
-
-    The initial developer of the original code is David A. Hinds
-    <dhinds@pcmcia.sourceforge.org>.  Portions created by David A. Hinds
-    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
-
-    Alternatively, the contents of this file may be used under the
-    terms of the GNU Public License version 2 (the "GPL"), in which
-    case the provisions of the GPL are applicable instead of the
-    above.  If you wish to allow the use of your version of this file
-    only under the terms of the GPL and not to allow others to use
-    your version of this file under the MPL, indicate your decision
-    by deleting the provisions above and replace them with the notice
-    and other provisions required by the GPL.  If you do not delete
-    the provisions above, a recipient may use your version of this
-    file under either the MPL or the GPL.
-
-======================================================================*/
-
 static int daqp_cs_suspend(struct pcmcia_device *link)
 {
 	struct local_info_t *local = link->priv;
@@ -874,74 +834,11 @@ static int daqp_cs_resume(struct pcmcia_device *link)
 	return 0;
 }
 
-static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
-{
-	if (p_dev->config_index == 0)
-		return -EINVAL;
-
-	return pcmcia_request_io(p_dev);
-}
-
 static int daqp_cs_attach(struct pcmcia_device *link)
 {
-	struct local_info_t *local;
-	int ret;
-	int i;
-
-	for (i = 0; i < MAX_DEV; i++)
-		if (dev_table[i] == NULL)
-			break;
-	if (i == MAX_DEV) {
-		dev_notice(&link->dev, "no devices available\n");
-		return -ENODEV;
-	}
-
-	/* Allocate space for private device-specific data */
-	local = kzalloc(sizeof(*local), GFP_KERNEL);
-	if (!local)
-		return -ENOMEM;
-
-	local->table_index = i;
-	dev_table[i] = local;
-	local->link = link;
-	link->priv = local;
-
-	link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
-
-	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
-	if (ret) {
-		dev_warn(&link->dev, "no configuration found\n");
-		goto failed;
-	}
-
-	ret = pcmcia_request_irq(link, daqp_interrupt);
-	if (ret)
-		goto failed;
-
-	ret = pcmcia_enable_device(link);
-	if (ret)
-		goto failed;
-
-	return 0;
-
-failed:
-	pcmcia_disable_device(link);
-	return ret;
-}
-
-static void daqp_cs_detach(struct pcmcia_device *link)
-{
-	struct local_info_t *dev = link->priv;
-
-	dev->stop = 1;
-	pcmcia_disable_device(link);
-
-	/* Unlink device structure, and free it */
-	dev_table[dev->table_index] = NULL;
-	kfree(dev);
+	return comedi_pcmcia_auto_config(link, &driver_daqp);
 }
 
-/*====================================================================*/
 static const struct pcmcia_device_id daqp_cs_id_table[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),
 	PCMCIA_DEVICE_NULL
@@ -953,7 +850,7 @@ static struct pcmcia_driver daqp_cs_driver = {
 	.owner		= THIS_MODULE,
 	.id_table	= daqp_cs_id_table,
 	.probe		= daqp_cs_attach,
-	.remove		= daqp_cs_detach,
+	.remove		= comedi_pcmcia_auto_unconfig,
 	.suspend	= daqp_cs_suspend,
 	.resume		= daqp_cs_resume,
 };

commit b7c0afa4b68c7b1cacaa4511721347682f7e1558
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:02:28 2013 -0700

    staging: comedi: quatech_daqp_cs: cleanup subdevice init
    
    Remove the dev_info() board attach noise.
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Remove the init of the s->len_chanlist for the subdevices that do
    not support commands. It's not used by them and the comedi core
    will handle initializing it properly in the postconfig.
    
    Change the return after a successful attach to "0". The comedi
    core expects a < 0 value to indicate an error and "0" is the
    typical value returned to indicate success.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 2a5f9ab6f7c1..2c35d75aef52 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -767,51 +767,46 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	dev_info(dev->class_dev, "attaching daqp%d (io 0x%04lx)\n",
-		 it->options[0], dev->iobase);
-
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
-	s->private = local;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = 8;
-	s->len_chanlist = 2048;
-	s->maxdata = 0xffff;
-	s->range_table = &range_daqp_ai;
-	s->insn_read = daqp_ai_insn_read;
-	s->do_cmdtest = daqp_ai_cmdtest;
-	s->do_cmd = daqp_ai_cmd;
-	s->cancel = daqp_ai_cancel;
+	s->private	= local;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan	= 8;
+	s->len_chanlist	= 2048;
+	s->maxdata	= 0xffff;
+	s->range_table	= &range_daqp_ai;
+	s->insn_read	= daqp_ai_insn_read;
+	s->do_cmdtest	= daqp_ai_cmdtest;
+	s->do_cmd	= daqp_ai_cmd;
+	s->cancel	= daqp_ai_cancel;
 
 	s = &dev->subdevices[1];
 	dev->write_subdev = s;
-	s->private = local;
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 2;
-	s->len_chanlist = 1;
-	s->maxdata = 0x0fff;
-	s->range_table = &range_bipolar5;
-	s->insn_write = daqp_ao_insn_write;
+	s->private	= local;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 2;
+	s->maxdata	= 0x0fff;
+	s->range_table	= &range_bipolar5;
+	s->insn_write	= daqp_ao_insn_write;
 
 	s = &dev->subdevices[2];
-	s->private = local;
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 1;
-	s->len_chanlist = 1;
-	s->insn_read = daqp_di_insn_read;
+	s->private	= local;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 1;
+	s->insn_read	= daqp_di_insn_read;
 
 	s = &dev->subdevices[3];
-	s->private = local;
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 1;
-	s->len_chanlist = 1;
-	s->insn_write = daqp_do_insn_write;
+	s->private	= local;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 1;
+	s->len_chanlist	= 1;
+	s->insn_write	= daqp_do_insn_write;
 
-	return 1;
+	return 0;
 }
 
 static void daqp_detach(struct comedi_device *dev)

commit c65c64d0f0b269b1239fdce253fd4717281cc98d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:02:06 2013 -0700

    staging: comedi: quatech_daqp_cs: fix possible memory dereference issue
    
    In daqp_attach(), the first options value passed in the comedi_devconfig
    is used as an index to the private dev_table[] in this driver. This table
    is used to pass the pcmcia_device to the comedi_driver.
    
    Fix the code so that the index is checked before the table is accessed
    so that we don't get a possible memory dereference BUG.
    
    Change the error returned to the comedi core from -EIO to -ENODEV.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 185632e70b97..2a5f9ab6f7c1 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -733,15 +733,16 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 
 static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	int ret;
-	struct local_info_t *local = dev_table[it->options[0]];
+	struct local_info_t *local;
 	struct comedi_subdevice *s;
+	int ret;
 
-	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
-		dev_err(dev->class_dev, "No such daqp device %d\n",
-			it->options[0]);
-		return -EIO;
-	}
+	if (it->options[0] < 0 || it->options[0] >= MAX_DEV)
+		return -ENODEV;
+
+	local = dev_table[it->options[0]];
+	if (!local)
+		return -ENODEV;
 
 	/* Typically brittle code that I don't completely understand,
 	 * but "it works on my card".  The intent is to pull the model

commit e23fe9a1bf80eee77d4cc97504bcec0c40ed973d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:01:46 2013 -0700

    staging: comedi: quatech_daqp_cs: cleanup the comedi_lrange tables
    
    For aesthetic reasons, cleanup the whitespace of the range_daqp_ai
    table.
    
    Remove the range_daqp_ao table and use the comedi core provided
    range table for bipolar 5V (range_bipolar5).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a74581f60200..185632e70b97 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -163,21 +163,15 @@ static struct local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
 #define DAQP_AUX_FIFO_NEARFULL		0x02
 #define DAQP_AUX_FIFO_EMPTY		0x01
 
-/* These range structures tell COMEDI how the sample values map to
- * voltages.  The A/D converter has four	.ranges = +/- 10V through
- * +/- 1.25V, and the D/A converter has only	.one = +/- 5V.
- */
-
-static const struct comedi_lrange range_daqp_ai = { 4, {
-							BIP_RANGE(10),
-							BIP_RANGE(5),
-							BIP_RANGE(2.5),
-							BIP_RANGE(1.25)
-							}
+static const struct comedi_lrange range_daqp_ai = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
-
 /* Cancel a running acquisition */
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -797,7 +791,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan = 2;
 	s->len_chanlist = 1;
 	s->maxdata = 0x0fff;
-	s->range_table = &range_daqp_ao;
+	s->range_table = &range_bipolar5;
 	s->insn_write = daqp_ao_insn_write;
 
 	s = &dev->subdevices[2];

commit 7b947d6116d6408afe7ffaa176e634c715cef9b9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:01:25 2013 -0700

    staging: comedi: quatech_daqp_cs: remove #define pr_fmt
    
    There are not pr_[level] uses in this file. Remove the pr_fmt
    define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index c6a79432befe..a74581f60200 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -47,8 +47,6 @@ Status: works
 Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include "../comedidev.h"
 #include <linux/semaphore.h>
 

commit 79a53df7fa7913d4589d5785130f6781430c64ce
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:01:06 2013 -0700

    staging: comedi: quatech_daqp_cs: remove debug functions
    
    The functions daqp_dump() and hex_dump() are not used in this
    driver. Just remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index fe36450cf8cc..c6a79432befe 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -180,32 +180,6 @@ static const struct comedi_lrange range_daqp_ai = { 4, {
 
 static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
-#ifdef DAQP_DEBUG
-
-static void daqp_dump(struct comedi_device *dev)
-{
-	dev_info(dev->class_dev, "status %02x; aux status %02x\n",
-		 inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
-}
-
-static void hex_dump(char *str, void *ptr, int len)
-{
-	unsigned char *cptr = ptr;
-	int i;
-
-	printk(str);
-
-	for (i = 0; i < len; i++) {
-		if (i % 16 == 0)
-			printk("\n%p:", cptr);
-
-		printk(" %02x", *(cptr++));
-	}
-	printk("\n");
-}
-
-#endif
-
 /* Cancel a running acquisition */
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)

commit 90967d66269f20f24e8465121dadb99e51ad1f64
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:00:48 2013 -0700

    staging: comedi: quatech_daqp_cs: simplify IRQ_NONE checks in daqp_interrupt()
    
    Remove all the pr_warn() noise in the sanity checks that make sure
    the interrupt is for this device.
    
    Simplify the sanity checks into one if() condition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 39af1565c066..fe36450cf8cc 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -238,37 +238,13 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
 	struct local_info_t *local = dev_id;
-	struct comedi_device *dev;
-	struct comedi_subdevice *s;
+	struct comedi_device *dev = local ? local->dev : NULL;
+	struct comedi_subdevice *s = local ? local->s : NULL;
 	int loop_limit = 10000;
 	int status;
 
-	if (local == NULL) {
-		pr_warn("irq %d for unknown device.\n", irq);
-		return IRQ_NONE;
-	}
-
-	dev = local->dev;
-	if (dev == NULL) {
-		pr_warn("NULL comedi_device.\n");
-		return IRQ_NONE;
-	}
-
-	if (!dev->attached) {
-		pr_warn("struct comedi_device not yet attached.\n");
+	if (!dev || !dev->attached || !s || s->private != local)
 		return IRQ_NONE;
-	}
-
-	s = local->s;
-	if (s == NULL) {
-		pr_warn("NULL comedi_subdevice.\n");
-		return IRQ_NONE;
-	}
-
-	if (s->private != local) {
-		pr_warn("invalid comedi_subdevice.\n");
-		return IRQ_NONE;
-	}
 
 	switch (local->interrupt_mode) {
 

commit b8319710de2d3f14e11c2d951d238797e2aa489d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 15:00:22 2013 -0700

    staging: comedi: quatech_daqp_cs: remove casts of void *
    
    Casting a void * is not necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 8eea8a9ca843..39af1565c066 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -210,7 +210,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 
 	if (local->stop)
 		return -EIO;
@@ -237,7 +237,7 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  */
 static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
-	struct local_info_t *local = (struct local_info_t *)dev_id;
+	struct local_info_t *local = dev_id;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	int loop_limit = 10000;
@@ -265,7 +265,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 		return IRQ_NONE;
 	}
 
-	if ((struct local_info_t *)s->private != local) {
+	if (s->private != local) {
 		pr_warn("invalid comedi_subdevice.\n");
 		return IRQ_NONE;
 	}
@@ -335,7 +335,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 	int i;
 	int v;
 	int counter = 10000;
@@ -528,7 +528,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter;
 	int scanlist_start_on_every_entry;
@@ -730,7 +730,7 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 	int d;
 	unsigned int chan;
 
@@ -757,7 +757,7 @@ static int daqp_di_insn_read(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 
 	if (local->stop)
 		return -EIO;
@@ -773,7 +773,7 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *)s->private;
+	struct local_info_t *local = s->private;
 
 	if (local->stop)
 		return -EIO;

commit cdcc02291bea28b85b81230cb9bd328ab7a3cb35
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 14:59:56 2013 -0700

    staging: comedi: quatech_daqp_cs: cleanup daqp_cs_attach()
    
    Absorb the code from daqp_cs_config() into this function and
    properly return the error if the configuration fails.
    
    Remove the dev_dbg() function trace messages.
    
    Fix the kzalloc(). The preferred form for passing a size of a struct
    is:
    
            p = kzalloc(sizeof(*p), ...);
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b2b755f031b1..8eea8a9ca843 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -944,41 +944,12 @@ static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
 	return pcmcia_request_io(p_dev);
 }
 
-static void daqp_cs_config(struct pcmcia_device *link)
-{
-	int ret;
-
-	dev_dbg(&link->dev, "daqp_cs_config\n");
-
-	link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
-
-	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
-	if (ret) {
-		dev_warn(&link->dev, "no configuration found\n");
-		goto failed;
-	}
-
-	ret = pcmcia_request_irq(link, daqp_interrupt);
-	if (ret)
-		goto failed;
-
-	ret = pcmcia_enable_device(link);
-	if (ret)
-		goto failed;
-
-	return;
-
-failed:
-	pcmcia_disable_device(link);
-}
-
 static int daqp_cs_attach(struct pcmcia_device *link)
 {
 	struct local_info_t *local;
+	int ret;
 	int i;
 
-	dev_dbg(&link->dev, "daqp_cs_attach()\n");
-
 	for (i = 0; i < MAX_DEV; i++)
 		if (dev_table[i] == NULL)
 			break;
@@ -988,7 +959,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	}
 
 	/* Allocate space for private device-specific data */
-	local = kzalloc(sizeof(struct local_info_t), GFP_KERNEL);
+	local = kzalloc(sizeof(*local), GFP_KERNEL);
 	if (!local)
 		return -ENOMEM;
 
@@ -997,9 +968,27 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	local->link = link;
 	link->priv = local;
 
-	daqp_cs_config(link);
+	link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
+
+	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
+	if (ret) {
+		dev_warn(&link->dev, "no configuration found\n");
+		goto failed;
+	}
+
+	ret = pcmcia_request_irq(link, daqp_interrupt);
+	if (ret)
+		goto failed;
+
+	ret = pcmcia_enable_device(link);
+	if (ret)
+		goto failed;
 
 	return 0;
+
+failed:
+	pcmcia_disable_device(link);
+	return ret;
 }
 
 static void daqp_cs_detach(struct pcmcia_device *link)

commit 86be5680f5804690654519751ed77aaa54b01826
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 14:59:36 2013 -0700

    staging: comedi: quatech_daqp_cs: remove daqp_cs_release()
    
    This function justs emits a dev_dbg() message then calls
    pcmcia_disable_device(). The dev_dbg() is just added noise.
    
    Remove the function and just call pcmcia_disable_device().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 748aa6a7a88a..b2b755f031b1 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -936,13 +936,6 @@ static int daqp_cs_resume(struct pcmcia_device *link)
 	return 0;
 }
 
-static void daqp_cs_release(struct pcmcia_device *link)
-{
-	dev_dbg(&link->dev, "daqp_cs_release\n");
-
-	pcmcia_disable_device(link);
-}
-
 static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
 {
 	if (p_dev->config_index == 0)
@@ -976,7 +969,7 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	return;
 
 failed:
-	daqp_cs_release(link);
+	pcmcia_disable_device(link);
 }
 
 static int daqp_cs_attach(struct pcmcia_device *link)
@@ -1014,7 +1007,7 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 	struct local_info_t *dev = link->priv;
 
 	dev->stop = 1;
-	daqp_cs_release(link);
+	pcmcia_disable_device(link);
 
 	/* Unlink device structure, and free it */
 	dev_table[dev->table_index] = NULL;

commit d1db2a4134bb486b28f943baac175e3edcc51053
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 14:59:17 2013 -0700

    staging: comedi: quatech_daqp_cs: remove forward declarations
    
    Move some of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index c4a03eb4c84a..748aa6a7a88a 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -180,19 +180,6 @@ static const struct comedi_lrange range_daqp_ai = { 4, {
 
 static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
-/*====================================================================*/
-
-/* comedi interface code */
-
-static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static void daqp_detach(struct comedi_device *dev);
-static struct comedi_driver driver_daqp = {
-	.driver_name = "quatech_daqp_cs",
-	.module = THIS_MODULE,
-	.attach = daqp_attach,
-	.detach = daqp_detach,
-};
-
 #ifdef DAQP_DEBUG
 
 static void daqp_dump(struct comedi_device *dev)
@@ -889,6 +876,13 @@ static void daqp_detach(struct comedi_device *dev)
 	/* Nothing to cleanup */
 }
 
+static struct comedi_driver driver_daqp = {
+	.driver_name	= "quatech_daqp_cs",
+	.module		= THIS_MODULE,
+	.attach		= daqp_attach,
+	.detach		= daqp_detach,
+};
+
 /*====================================================================
 
     PCMCIA interface code
@@ -924,55 +918,29 @@ static void daqp_detach(struct comedi_device *dev)
 
 ======================================================================*/
 
-static void daqp_cs_config(struct pcmcia_device *link);
-static void daqp_cs_release(struct pcmcia_device *link);
-static int daqp_cs_suspend(struct pcmcia_device *p_dev);
-static int daqp_cs_resume(struct pcmcia_device *p_dev);
-
-static int daqp_cs_attach(struct pcmcia_device *);
-static void daqp_cs_detach(struct pcmcia_device *);
-
-static int daqp_cs_attach(struct pcmcia_device *link)
+static int daqp_cs_suspend(struct pcmcia_device *link)
 {
-	struct local_info_t *local;
-	int i;
-
-	dev_dbg(&link->dev, "daqp_cs_attach()\n");
-
-	for (i = 0; i < MAX_DEV; i++)
-		if (dev_table[i] == NULL)
-			break;
-	if (i == MAX_DEV) {
-		dev_notice(&link->dev, "no devices available\n");
-		return -ENODEV;
-	}
+	struct local_info_t *local = link->priv;
 
-	/* Allocate space for private device-specific data */
-	local = kzalloc(sizeof(struct local_info_t), GFP_KERNEL);
-	if (!local)
-		return -ENOMEM;
+	/* Mark the device as stopped, to block IO until later */
+	local->stop = 1;
+	return 0;
+}
 
-	local->table_index = i;
-	dev_table[i] = local;
-	local->link = link;
-	link->priv = local;
+static int daqp_cs_resume(struct pcmcia_device *link)
+{
+	struct local_info_t *local = link->priv;
 
-	daqp_cs_config(link);
+	local->stop = 0;
 
 	return 0;
-}				/* daqp_cs_attach */
+}
 
-static void daqp_cs_detach(struct pcmcia_device *link)
+static void daqp_cs_release(struct pcmcia_device *link)
 {
-	struct local_info_t *dev = link->priv;
-
-	dev->stop = 1;
-	daqp_cs_release(link);
-
-	/* Unlink device structure, and free it */
-	dev_table[dev->table_index] = NULL;
-	kfree(dev);
+	dev_dbg(&link->dev, "daqp_cs_release\n");
 
+	pcmcia_disable_device(link);
 }
 
 static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
@@ -1009,32 +977,48 @@ static void daqp_cs_config(struct pcmcia_device *link)
 
 failed:
 	daqp_cs_release(link);
+}
 
-}				/* daqp_cs_config */
-
-static void daqp_cs_release(struct pcmcia_device *link)
+static int daqp_cs_attach(struct pcmcia_device *link)
 {
-	dev_dbg(&link->dev, "daqp_cs_release\n");
+	struct local_info_t *local;
+	int i;
 
-	pcmcia_disable_device(link);
-}				/* daqp_cs_release */
+	dev_dbg(&link->dev, "daqp_cs_attach()\n");
 
-static int daqp_cs_suspend(struct pcmcia_device *link)
-{
-	struct local_info_t *local = link->priv;
+	for (i = 0; i < MAX_DEV; i++)
+		if (dev_table[i] == NULL)
+			break;
+	if (i == MAX_DEV) {
+		dev_notice(&link->dev, "no devices available\n");
+		return -ENODEV;
+	}
+
+	/* Allocate space for private device-specific data */
+	local = kzalloc(sizeof(struct local_info_t), GFP_KERNEL);
+	if (!local)
+		return -ENOMEM;
+
+	local->table_index = i;
+	dev_table[i] = local;
+	local->link = link;
+	link->priv = local;
+
+	daqp_cs_config(link);
 
-	/* Mark the device as stopped, to block IO until later */
-	local->stop = 1;
 	return 0;
 }
 
-static int daqp_cs_resume(struct pcmcia_device *link)
+static void daqp_cs_detach(struct pcmcia_device *link)
 {
-	struct local_info_t *local = link->priv;
+	struct local_info_t *dev = link->priv;
 
-	local->stop = 0;
+	dev->stop = 1;
+	daqp_cs_release(link);
 
-	return 0;
+	/* Unlink device structure, and free it */
+	dev_table[dev->table_index] = NULL;
+	kfree(dev);
 }
 
 /*====================================================================*/

commit 433a0e22132d132844875764bda2911db28b36ad
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 14:58:58 2013 -0700

    staging: comedi: quatech_daqp_cs: cleanup pcmcia_driver
    
    For aesthetic reasons, reorder the pcmcia_driver variables and
    add some whitespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ca087ea42ad3..c4a03eb4c84a 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1045,13 +1045,13 @@ static const struct pcmcia_device_id daqp_cs_id_table[] = {
 MODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);
 
 static struct pcmcia_driver daqp_cs_driver = {
-	.probe = daqp_cs_attach,
-	.remove = daqp_cs_detach,
-	.suspend = daqp_cs_suspend,
-	.resume = daqp_cs_resume,
-	.id_table = daqp_cs_id_table,
-	.owner = THIS_MODULE,
-	.name = "quatech_daqp_cs",
+	.name		= "quatech_daqp_cs",
+	.owner		= THIS_MODULE,
+	.id_table	= daqp_cs_id_table,
+	.probe		= daqp_cs_attach,
+	.remove		= daqp_cs_detach,
+	.suspend	= daqp_cs_suspend,
+	.resume		= daqp_cs_resume,
 };
 module_comedi_pcmcia_driver(driver_daqp, daqp_cs_driver);
 

commit 04c5904155839920afaffb083742f8bd603b88cb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 25 14:58:36 2013 -0700

    staging: comedi: quatech_daqp_cs: move MODULE_* info to end of file
    
    For aesthetic reasons, move all the MODULE_* information to the end
    of the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 55d8cc641967..ca087ea42ad3 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1042,11 +1042,7 @@ static const struct pcmcia_device_id daqp_cs_id_table[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),
 	PCMCIA_DEVICE_NULL
 };
-
 MODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);
-MODULE_AUTHOR("Brent Baccala <baccala@freesoft.org>");
-MODULE_DESCRIPTION("Comedi driver for Quatech DAQP PCMCIA data capture cards");
-MODULE_LICENSE("GPL");
 
 static struct pcmcia_driver daqp_cs_driver = {
 	.probe = daqp_cs_attach,
@@ -1057,5 +1053,8 @@ static struct pcmcia_driver daqp_cs_driver = {
 	.owner = THIS_MODULE,
 	.name = "quatech_daqp_cs",
 };
-
 module_comedi_pcmcia_driver(driver_daqp, daqp_cs_driver);
+
+MODULE_DESCRIPTION("Comedi driver for Quatech DAQP PCMCIA data capture cards");
+MODULE_AUTHOR("Brent Baccala <baccala@freesoft.org>");
+MODULE_LICENSE("GPL");

commit f3493a973d5e8985e2c61730257ffa43cbabdb09
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Jan 14 22:00:51 2013 +0100

    staging/comedi/quatech_daqp_cs: Convert to module_comedi_pcmcia_driver
    
    This patch removes the boring init/exit functions with the new
    module_comedi_pcmcia_driver macro.
    
    Also removed the superflous #ifdef MODULE
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ef0cdaa7f02e..55d8cc641967 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1038,9 +1038,6 @@ static int daqp_cs_resume(struct pcmcia_device *link)
 }
 
 /*====================================================================*/
-
-#ifdef MODULE
-
 static const struct pcmcia_device_id daqp_cs_id_table[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),
 	PCMCIA_DEVICE_NULL
@@ -1061,17 +1058,4 @@ static struct pcmcia_driver daqp_cs_driver = {
 	.name = "quatech_daqp_cs",
 };
 
-int __init init_module(void)
-{
-	pcmcia_register_driver(&daqp_cs_driver);
-	comedi_driver_register(&driver_daqp);
-	return 0;
-}
-
-void __exit cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_daqp);
-	pcmcia_unregister_driver(&daqp_cs_driver);
-}
-
-#endif
+module_comedi_pcmcia_driver(driver_daqp, daqp_cs_driver);

commit 42cae4a1c030403883277aecc53a726e329f64cf
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:58:47 2012 -0700

    staging: comedi: quatech_daqp_cs: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of daqp_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ee9158b203c9..ef0cdaa7f02e 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -482,19 +482,15 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
 #define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
 
-	if (cmd->scan_begin_src == TRIG_TIMER
-	    && cmd->scan_begin_arg < MAX_SPEED) {
-		cmd->scan_begin_arg = MAX_SPEED;
-		err++;
-	}
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 MAX_SPEED);
 
 	/* If both scan_begin and convert are both timer values, the only
 	 * way that can make sense is if the scan time is the number of
@@ -503,30 +499,18 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER && cmd->convert_src == TRIG_TIMER
 	    && cmd->scan_begin_arg != cmd->convert_arg * cmd->scan_end_arg) {
-		err++;
+		err |= -EINVAL;
 	}
 
-	if (cmd->convert_src == TRIG_TIMER && cmd->convert_arg < MAX_SPEED) {
-		cmd->convert_arg = MAX_SPEED;
-		err++;
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, MAX_SPEED);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (cmd->stop_arg > 0x00ffffff) {
-			cmd->stop_arg = 0x00ffffff;
-			err++;
-		}
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 53f63dc7986ef72e5a2b1f046f1f65f484bdb51b
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Sun Oct 28 06:47:26 2012 +0900

    staging/comedi: Use dev_ printks in drivers/quatech_daqp_cs.c
    
    fixed below checkpatch warnings.
    - WARNING: printk() should include KERN_ facility level
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 806523c4c464..ee9158b203c9 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -300,7 +300,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 			if (status & DAQP_STATUS_DATA_LOST) {
 				s->async->events |=
 				    COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
-				printk("daqp: data lost\n");
+				dev_warn(dev->class_dev, "data lost\n");
 				daqp_ai_cancel(dev, s);
 				break;
 			}
@@ -398,7 +398,8 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS))
 		;
 	if (!counter) {
-		printk("daqp: couldn't clear interrupts in status register\n");
+		dev_err(dev->class_dev,
+			"couldn't clear interrupts in status register\n");
 		return -1;
 	}
 
@@ -824,8 +825,8 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 
 	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
-		printk("comedi%d: No such daqp device %d\n",
-		       dev->minor, it->options[0]);
+		dev_err(dev->class_dev, "No such daqp device %d\n",
+			it->options[0]);
 		return -EIO;
 	}
 

commit 543a09e9cf1485a8b55f6459b28f3fbab7bb55c3
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Sun Oct 28 06:46:33 2012 +0900

    staging/comedi: Fix trailing statements should be on next line in drivers/quatech_daqp_cs.c
    
    fixed below checkpatch errors.
    - ERROR: trailing statements should be on next line
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index d15bd8ac3d4f..806523c4c464 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -395,7 +395,8 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	 */
 
 	while (--counter
-	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS))
+		;
 	if (!counter) {
 		printk("daqp: couldn't clear interrupts in status register\n");
 		return -1;
@@ -732,7 +733,8 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	counter = 100;
 	while (--counter
-	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS))
+		;
 	if (!counter) {
 		dev_err(dev->class_dev,
 			"couldn't clear interrupts in status register\n");

commit ce3ed9f0cefac1b0e16640100928a6abacabc39b
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Sat Oct 6 14:52:34 2012 +0900

    staging/comedi: Use dev_ printks in drivers/quatech_daqp_cs.c
    
    fixed below checkpatch warnings.
    - WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    - WARNING: Prefer netdev_warn(netdev, ... then dev_warn(dev, ... then pr_warn(...  to printk(KERN_WARNING ...
    - WARNING: Prefer netdev_err(netdev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    - WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    - WARNING: Prefer netdev_notice(netdev, ... then dev_notice(dev, ... then pr_notice(...  to printk(KERN_NOTICE ...
    
    and added pr_fmt.
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 3e276f7a3380..d15bd8ac3d4f 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -47,6 +47,8 @@ Status: works
 Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include "../comedidev.h"
 #include <linux/semaphore.h>
 
@@ -195,8 +197,8 @@ static struct comedi_driver driver_daqp = {
 
 static void daqp_dump(struct comedi_device *dev)
 {
-	printk(KERN_INFO "DAQP: status %02x; aux status %02x\n",
-	       inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
+	dev_info(dev->class_dev, "status %02x; aux status %02x\n",
+		 inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
 }
 
 static void hex_dump(char *str, void *ptr, int len)
@@ -255,33 +257,29 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 	int status;
 
 	if (local == NULL) {
-		printk(KERN_WARNING
-		       "daqp_interrupt(): irq %d for unknown device.\n", irq);
+		pr_warn("irq %d for unknown device.\n", irq);
 		return IRQ_NONE;
 	}
 
 	dev = local->dev;
 	if (dev == NULL) {
-		printk(KERN_WARNING "daqp_interrupt(): NULL comedi_device.\n");
+		pr_warn("NULL comedi_device.\n");
 		return IRQ_NONE;
 	}
 
 	if (!dev->attached) {
-		printk(KERN_WARNING
-		       "daqp_interrupt(): struct comedi_device not yet attached.\n");
+		pr_warn("struct comedi_device not yet attached.\n");
 		return IRQ_NONE;
 	}
 
 	s = local->s;
 	if (s == NULL) {
-		printk(KERN_WARNING
-		       "daqp_interrupt(): NULL comedi_subdevice.\n");
+		pr_warn("NULL comedi_subdevice.\n");
 		return IRQ_NONE;
 	}
 
 	if ((struct local_info_t *)s->private != local) {
-		printk(KERN_WARNING
-		       "daqp_interrupt(): invalid comedi_subdevice.\n");
+		pr_warn("invalid comedi_subdevice.\n");
 		return IRQ_NONE;
 	}
 
@@ -331,8 +329,8 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 		}
 
 		if (loop_limit <= 0) {
-			printk(KERN_WARNING
-			       "loop_limit reached in daqp_interrupt()\n");
+			dev_warn(dev->class_dev,
+				 "loop_limit reached in daqp_interrupt()\n");
 			daqp_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		}
@@ -736,8 +734,8 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	while (--counter
 	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
-		printk(KERN_ERR
-		       "daqp: couldn't clear interrupts in status register\n");
+		dev_err(dev->class_dev,
+			"couldn't clear interrupts in status register\n");
 		return -1;
 	}
 
@@ -852,8 +850,8 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	printk(KERN_INFO "comedi%d: attaching daqp%d (io 0x%04lx)\n",
-	       dev->minor, it->options[0], dev->iobase);
+	dev_info(dev->class_dev, "attaching daqp%d (io 0x%04lx)\n",
+		 it->options[0], dev->iobase);
 
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
@@ -958,7 +956,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 		if (dev_table[i] == NULL)
 			break;
 	if (i == MAX_DEV) {
-		printk(KERN_NOTICE "daqp_cs: no devices available\n");
+		dev_notice(&link->dev, "no devices available\n");
 		return -ENODEV;
 	}
 

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index e95a4eb0a67d..3e276f7a3380 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -56,6 +56,8 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 
 #include <linux/completion.h>
 
+#include "comedi_fc.h"
+
 /* Maximum number of separate DAQP devices we'll allow */
 #define MAX_DEV         4
 
@@ -456,51 +458,26 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources
-	 * are unique and mutually compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
-	if (cmd->convert_src != TRIG_NOW && cmd->convert_src != TRIG_TIMER)
-		err++;
-	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 123c0e03a49986fbe63509f7511484f929eb1a42
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:55:46 2012 -0700

    staging: comedi: quatech_daqp_cs: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a029147c9b69..e95a4eb0a67d 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -878,7 +878,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(KERN_INFO "comedi%d: attaching daqp%d (io 0x%04lx)\n",
 	       dev->minor, it->options[0], dev->iobase);
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->private = local;
 	s->type = COMEDI_SUBD_AI;
@@ -892,7 +892,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->do_cmd = daqp_ai_cmd;
 	s->cancel = daqp_ai_cancel;
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	dev->write_subdev = s;
 	s->private = local;
 	s->type = COMEDI_SUBD_AO;
@@ -903,7 +903,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table = &range_daqp_ao;
 	s->insn_write = daqp_ao_insn_write;
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	s->private = local;
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE;
@@ -911,7 +911,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->len_chanlist = 1;
 	s->insn_read = daqp_di_insn_read;
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	s->private = local;
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITEABLE;

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 38a13ba38e18..a029147c9b69 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -872,7 +872,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->iobase = local->link->resource[0]->start;
 
 	ret = comedi_alloc_subdevices(dev, 4);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	printk(KERN_INFO "comedi%d: attaching daqp%d (io 0x%04lx)\n",

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 2f130b3095e9..38a13ba38e18 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -871,7 +871,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->iobase = local->link->resource[0]->start;
 
-	ret = alloc_subdevices(dev, 4);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret < 0)
 		return ret;
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index e0bb73445dd8..2f130b3095e9 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -181,7 +181,7 @@ static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 /* comedi interface code */
 
 static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int daqp_detach(struct comedi_device *dev);
+static void daqp_detach(struct comedi_device *dev);
 static struct comedi_driver driver_daqp = {
 	.driver_name = "quatech_daqp_cs",
 	.module = THIS_MODULE,
@@ -922,15 +922,9 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-/* daqp_detach (called from comedi_comdig) does nothing. If the PCMCIA
- * card is removed, daqp_cs_detach() is called by the pcmcia subsystem.
- */
-
-static int daqp_detach(struct comedi_device *dev)
+static void daqp_detach(struct comedi_device *dev)
 {
-	printk(KERN_INFO "comedi%d: detaching daqp\n", dev->minor);
-
-	return 0;
+	/* Nothing to cleanup */
 }
 
 /*====================================================================
@@ -1010,8 +1004,6 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 {
 	struct local_info_t *dev = link->priv;
 
-	dev_dbg(&link->dev, "daqp_cs_detach\n");
-
 	dev->stop = 1;
 	daqp_cs_release(link);
 
@@ -1019,7 +1011,7 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 	dev_table[dev->table_index] = NULL;
 	kfree(dev);
 
-}				/* daqp_cs_detach */
+}
 
 static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
 {

commit 2202a5a7490a9de282846ea8d4a56d0249e09033
Author: Joe Perches <joe@perches.com>
Date:   Tue May 3 19:29:02 2011 -0700

    staging: pcmcia: Convert pcmcia_device_id declarations to const
    
    Reduces data, increases text.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 82942e5728a5..e0bb73445dd8 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1087,7 +1087,7 @@ static int daqp_cs_resume(struct pcmcia_device *link)
 
 #ifdef MODULE
 
-static struct pcmcia_device_id daqp_cs_id_table[] = {
+static const struct pcmcia_device_id daqp_cs_id_table[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),
 	PCMCIA_DEVICE_NULL
 };

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ebba9bb47777..82942e5728a5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -390,7 +390,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendancy to require
+	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)
 	 */
 
@@ -752,7 +752,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendancy to require
+	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)
 	 */
 	counter = 100;

commit 2262054e74b4b26ed56a8535c1259f6c6c2862a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 15 08:38:38 2010 +0200

    pcmcia: remove obsolete and wrong comments
    
    What's worse than no comment? A wrong comment.
    
    Several PCMCIA device drivers contained the same comments, which
    were based on how the PCMCIA subsystem worked in the old days of 2.4.,
    and which were originally part of a "dummy_cs" driver. These comments
    no longer matched at all what is happening now, and therefore should
    be removed.
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 32fecf57868d..ebba9bb47777 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -968,43 +968,14 @@ static int daqp_detach(struct comedi_device *dev)
 
 ======================================================================*/
 
-/*
-   The event() function is this driver's Card Services event handler.
-   It will be called by Card Services when an appropriate card status
-   event is received.  The config() and release() entry points are
-   used to configure or release a socket, in response to card
-   insertion and ejection events.
-
-   Kernel version 2.6.16 upwards uses suspend() and resume() functions
-   instead of an event() function.
-*/
-
 static void daqp_cs_config(struct pcmcia_device *link);
 static void daqp_cs_release(struct pcmcia_device *link);
 static int daqp_cs_suspend(struct pcmcia_device *p_dev);
 static int daqp_cs_resume(struct pcmcia_device *p_dev);
 
-/*
-   The attach() and detach() entry points are used to create and destroy
-   "instances" of the driver, where each instance represents everything
-   needed to manage one actual PCMCIA card.
-*/
-
 static int daqp_cs_attach(struct pcmcia_device *);
 static void daqp_cs_detach(struct pcmcia_device *);
 
-/*======================================================================
-
-    daqp_cs_attach() creates an "instance" of the driver, allocating
-    local data structures for one device.  The device is registered
-    with Card Services.
-
-    The dev_link structure is initialized, but we don't actually
-    configure the card at this point -- we wait until we receive a
-    card insertion event.
-
-======================================================================*/
-
 static int daqp_cs_attach(struct pcmcia_device *link)
 {
 	struct local_info_t *local;
@@ -1035,15 +1006,6 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	return 0;
 }				/* daqp_cs_attach */
 
-/*======================================================================
-
-    This deletes a driver "instance".  The device is de-registered
-    with Card Services.  If it has been released, all local data
-    structures are freed.  Otherwise, the structures will be freed
-    when the device is released.
-
-======================================================================*/
-
 static void daqp_cs_detach(struct pcmcia_device *link)
 {
 	struct local_info_t *dev = link->priv;
@@ -1059,15 +1021,6 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 
 }				/* daqp_cs_detach */
 
-/*======================================================================
-
-    daqp_cs_config() is scheduled to run after a CARD_INSERTION event
-    is received, to configure the PCMCIA socket, and to make the
-    device available to the system.
-
-======================================================================*/
-
-
 static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
 {
 	if (p_dev->config_index == 0)
@@ -1094,11 +1047,6 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	if (ret)
 		goto failed;
 
-	/*
-	   This actually configures the PCMCIA socket -- setting up
-	   the I/O windows and the interrupt mapping, and putting the
-	   card and host interface into "Memory and IO" mode.
-	 */
 	ret = pcmcia_enable_device(link);
 	if (ret)
 		goto failed;
@@ -1117,18 +1065,6 @@ static void daqp_cs_release(struct pcmcia_device *link)
 	pcmcia_disable_device(link);
 }				/* daqp_cs_release */
 
-/*======================================================================
-
-    The card status event handler.  Mostly, this schedules other
-    stuff to run after an event is received.
-
-    When a CARD_REMOVAL event is received, we immediately set a
-    private flag to block future accesses to this device.  All the
-    functions that actually access the device should check this flag
-    to make sure the card is still present.
-
-======================================================================*/
-
 static int daqp_cs_suspend(struct pcmcia_device *link)
 {
 	struct local_info_t *local = link->priv;

commit 2e9b981a7c63ee8278df6823f8389d69dad1a499
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 8 11:36:26 2010 +0200

    pcmcia: move driver name to struct pcmcia_driver
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index de37ff70a9e7..32fecf57868d 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1168,9 +1168,7 @@ static struct pcmcia_driver daqp_cs_driver = {
 	.resume = daqp_cs_resume,
 	.id_table = daqp_cs_id_table,
 	.owner = THIS_MODULE,
-	.drv = {
-		.name = "quatech_daqp_cs",
-		},
+	.name = "quatech_daqp_cs",
 };
 
 int __init init_module(void)

commit 1cc745d1cdca8086b472a06671f0830fc0e98861
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 1 11:21:14 2010 +0200

    pcmcia: remove the "Finally, report what we've done" message
    
    Remove this unnecessary message -- this info is either available
    in sysfs or by enabling dynamic debug from the PCMCIA core.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index afd283d0e711..de37ff70a9e7 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1103,15 +1103,6 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	if (ret)
 		goto failed;
 
-	/* Finally, report what we've done */
-	dev_info(&link->dev, "index 0x%02x", link->config_index);
-	printk(", irq %u", link->irq);
-	if (link->resource[0])
-		printk(" & %pR", link->resource[0]);
-	if (link->resource[1])
-		printk(" & %pR", link->resource[1]);
-	printk("\n");
-
 	return;
 
 failed:

commit 00990e7ce0b0e596fe41d9c64d6933ea70084003
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jul 30 13:13:46 2010 +0200

    pcmcia: use autoconfiguration feature for ioports and iomem
    
    When CONF_AUTO_SET_IO or CONF_AUTO_SET_IOMEM are set, the corresponding
    fields in struct pcmcia_device *p_dev->resource[0,1,2] are set
    accordinly. Drivers wishing to override certain settings may do so in
    the callback function, but they no longer need to parse the CIS entries
    stored in cistpl_cftable_entry_t themselves.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: linux-bluetooth@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 03a72d7ac676..afd283d0e711 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1068,35 +1068,11 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 ======================================================================*/
 
 
-static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
-				cistpl_cftable_entry_t *cfg,
-				cistpl_cftable_entry_t *dflt,
-				void *priv_data)
+static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)
 {
-	if (cfg->index == 0)
-		return -ENODEV;
+	if (p_dev->config_index == 0)
+		return -EINVAL;
 
-	/* Do we need to allocate an interrupt? */
-	p_dev->config_flags |= CONF_ENABLE_IRQ;
-
-	/* IO window settings */
-	p_dev->resource[0]->end = p_dev->resource[1]->end = 0;
-	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
-		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
-		p_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;
-		p_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
-		p_dev->resource[0]->flags |=
-			pcmcia_io_cfg_data_width(io->flags);
-		p_dev->resource[0]->start = io->win[0].base;
-		p_dev->resource[0]->end = io->win[0].len;
-		if (io->nwin > 1) {
-			p_dev->resource[1]->flags = p_dev->resource[0]->flags;
-			p_dev->resource[1]->start = io->win[1].base;
-			p_dev->resource[1]->end = io->win[1].len;
-		}
-	}
-
-	/* This reserves IO space but doesn't actually enable it */
 	return pcmcia_request_io(p_dev);
 }
 
@@ -1106,6 +1082,8 @@ static void daqp_cs_config(struct pcmcia_device *link)
 
 	dev_dbg(&link->dev, "daqp_cs_config\n");
 
+	link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
+
 	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
 	if (ret) {
 		dev_warn(&link->dev, "no configuration found\n");

commit 440eed43e2a95bb842488755683716814da10f2b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jul 30 09:51:52 2010 +0200

    pcmcia: introduce autoconfiguration feature
    
    Introduce an autoconfiguration feature to set certain values in
    pcmcia_loop_config(), instead of copying the same code over and over
    in each PCMCIA driver. At first, introduce the following options:
    
    CONF_AUTO_CHECK_VCC     check or matching Vcc entry
    CONF_AUTO_SET_VPP       set Vpp
    CONF_AUTO_AUDIO         enable the speaker line
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index b8940d7f4155..03a72d7ac676 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1071,7 +1071,6 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
 				cistpl_cftable_entry_t *cfg,
 				cistpl_cftable_entry_t *dflt,
-				unsigned int vcc,
 				void *priv_data)
 {
 	if (cfg->index == 0)

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a2a32de044c8..b8940d7f4155 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -50,7 +50,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #include "../comedidev.h"
 #include <linux/semaphore.h>
 
-#include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
@@ -1031,15 +1030,6 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	local->link = link;
 	link->priv = local;
 
-	/*
-	   General socket configuration defaults can go here.  In this
-	   client, we assume very little, and rely on the CIS for almost
-	   everything.  In most clients, many details (i.e., number, sizes,
-	   and attributes of IO windows) are fixed by the nature of the
-	   device, and can be hard-wired here.
-	 */
-	link->conf.Attributes = 0;
-
 	daqp_cs_config(link);
 
 	return 0;
@@ -1088,7 +1078,7 @@ static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
 		return -ENODEV;
 
 	/* Do we need to allocate an interrupt? */
-	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
+	p_dev->config_flags |= CONF_ENABLE_IRQ;
 
 	/* IO window settings */
 	p_dev->resource[0]->end = p_dev->resource[1]->end = 0;
@@ -1132,14 +1122,13 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	ret = pcmcia_request_configuration(link, &link->conf);
+	ret = pcmcia_enable_device(link);
 	if (ret)
 		goto failed;
 
 	/* Finally, report what we've done */
 	dev_info(&link->dev, "index 0x%02x", link->config_index);
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		printk(", irq %u", link->irq);
+	printk(", irq %u", link->irq);
 	if (link->resource[0])
 		printk(" & %pR", link->resource[0]);
 	if (link->resource[1])

commit 7feabb6412ea23edd298c0fa90e5aa6733eb4a42
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 18:35:47 2010 +0200

    pcmcia: move config_{base,index,regs} to struct pcmcia_device
    
    Several drivers prefer to explicitly set config_{base,index,regs},
    formerly known as ConfigBase, ConfigIndex and Present. Instead of
    passing these values inside config_req_t, store it in struct
    pcmcia_device.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index cd818fbd9185..a2a32de044c8 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1137,7 +1137,7 @@ static void daqp_cs_config(struct pcmcia_device *link)
 		goto failed;
 
 	/* Finally, report what we've done */
-	dev_info(&link->dev, "index 0x%02x", link->conf.ConfigIndex);
+	dev_info(&link->dev, "index 0x%02x", link->config_index);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq);
 	if (link->resource[0])

commit 37979e1546a790c44adbc7f27a85569944480ebc
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 16:33:23 2010 +0200

    pcmcia: simplify IntType
    
    IntType was only set to INT_MEMORY (driver pcmciamtd) or INT_MEMORY_AND_IO
    (all other drivers). As this flags seems to relate to ioport access, make
    it conditional to the driver having requested IO port access. There are two
    drivers which do not request IO ports, but did set INT_MEMORY_AND_IO:
    ray_cs and b43. For those, we consistently only set INT_MEMORY in future.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index bf489d7f4990..cd818fbd9185 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1039,7 +1039,6 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	   device, and can be hard-wired here.
 	 */
 	link->conf.Attributes = 0;
-	link->conf.IntType = INT_MEMORY_AND_IO;
 
 	daqp_cs_config(link);
 

commit 1685e633b396b0f3dabbc9fa5d65dfefe6435250
Merge: 1cfd2bda8c48 127c03cdbad9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 12:25:06 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6:
      pcmcia: avoid buffer overflow in pcmcia_setup_isa_irq
      pcmcia: do not request windows if you don't need to
      pcmcia: insert PCMCIA device resources into resource tree
      pcmcia: export resource information to sysfs
      pcmcia: use struct resource for PCMCIA devices, part 2
      pcmcia: remove memreq_t
      pcmcia: move local definitions out of include/pcmcia/cs.h
      pcmcia: do not use io_req_t when calling pcmcia_request_io()
      pcmcia: do not use io_req_t after call to pcmcia_request_io()
      pcmcia: use struct resource for PCMCIA devices
      pcmcia: clean up cs.h
      pcmcia: use pcmica_{read,write}_config_byte
      pcmcia: remove cs_types.h
      pcmcia: remove unused flag, simplify headers
      pcmcia: remove obsolete CS_EVENT_ definitions
      pcmcia: split up central event handler
      pcmcia: simplify event callback
      pcmcia: remove obsolete ioctl
    
    Conflicts in:
     - drivers/staging/comedi/drivers/*
     - drivers/staging/wlags49_h2/wl_cs.c
    due to dev_info_t and whitespace changes

commit 90abdc3b973229bae98dd96649d9f7106cc177a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 17:23:51 2010 +0200

    pcmcia: do not use io_req_t when calling pcmcia_request_io()
    
    Instead of io_req_t, drivers are now requested to fill out
    struct pcmcia_device *p_dev->resource[0,1] for up to two ioport
    ranges. After a call to pcmcia_request_io(), the ports found there
    are reserved, after calling pcmcia_request_configuration(), they may
    be used.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Michael Buesch <mb@bu3sch.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 80b8d57c6842..25f4e67e3e89 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1102,26 +1102,24 @@ static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
 	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
 
 	/* IO window settings */
-	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
+	p_dev->resource[0]->end = p_dev->resource[1]->end = 0;
 	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
 		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
-		p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
-		if (!(io->flags & CISTPL_IO_8BIT))
-			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
-		if (!(io->flags & CISTPL_IO_16BIT))
-			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-		p_dev->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
-		p_dev->io.BasePort1 = io->win[0].base;
-		p_dev->io.NumPorts1 = io->win[0].len;
+		p_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;
+		p_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
+		p_dev->resource[0]->flags |=
+			pcmcia_io_cfg_data_width(io->flags);
+		p_dev->resource[0]->start = io->win[0].base;
+		p_dev->resource[0]->end = io->win[0].len;
 		if (io->nwin > 1) {
-			p_dev->io.Attributes2 = p_dev->io.Attributes1;
-			p_dev->io.BasePort2 = io->win[1].base;
-			p_dev->io.NumPorts2 = io->win[1].len;
+			p_dev->resource[1]->flags = p_dev->resource[0]->flags;
+			p_dev->resource[1]->start = io->win[1].base;
+			p_dev->resource[1]->end = io->win[1].len;
 		}
 	}
 
 	/* This reserves IO space but doesn't actually enable it */
-	return pcmcia_request_io(p_dev, &p_dev->io);
+	return pcmcia_request_io(p_dev);
 }
 
 static void daqp_cs_config(struct pcmcia_device *link)

commit 9a017a910346afd88ec2e065989903bf211a7d37
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 15:58:54 2010 +0200

    pcmcia: do not use io_req_t after call to pcmcia_request_io()
    
    After pcmcia_request_io(), do not make use of the values stored in
    io_req_t, but instead use those found in struct pcmcia_device->resource[].
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 67c0fa6a2b06..80b8d57c6842 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -871,7 +871,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	dev->iobase = local->link->io.BasePort1;
+	dev->iobase = local->link->resource[0]->start;
 
 	ret = alloc_subdevices(dev, 4);
 	if (ret < 0)
@@ -1153,12 +1153,10 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	dev_info(&link->dev, "index 0x%02x", link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq);
-	if (link->io.NumPorts1)
-		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-		       link->io.BasePort1 + link->io.NumPorts1 - 1);
-	if (link->io.NumPorts2)
-		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-		       link->io.BasePort2 + link->io.NumPorts2 - 1);
+	if (link->resource[0])
+		printk(" & %pR", link->resource[0]);
+	if (link->resource[1])
+		printk(" & %pR", link->resource[1]);
 	printk("\n");
 
 	return;

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a91db6c42028..67c0fa6a2b06 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -50,7 +50,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #include "../comedidev.h"
 #include <linux/semaphore.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>

commit 5fc9e4d527f059a996f4725a596698fa76c0370f
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Wed Jul 14 22:05:17 2010 +0400

    staging: comedi: formatting of pointers in printk()
    
    Use %p instead of %08x in printk().
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 8d16380744b2..8b49cb12c2e5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -208,7 +208,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 	for (i = 0; i < len; i++) {
 		if (i % 16 == 0)
-			printk("\n0x%08x:", (unsigned int)cptr);
+			printk("\n%p:", cptr);
 
 		printk(" %02x", *(cptr++));
 	}

commit 3420f6b4c1ac731e80d0911e0092705992cef14f
Author: Gustavo Silva <silvagustavosilva@gmail.com>
Date:   Wed Jun 16 01:01:07 2010 -0500

    Staging: comedi: drivers: fix coding style issues in quatech_daqp_cs.c
    
    This is a patch to the quatech_daqp_cs.c file that fixes up the following
    issues:
    
    ERROR: code indent should use tabs where possible                  x  1
    WARNING: line over 80 characters                                   x  1
    WARNING: braces {} are not necessary for single statement blocks   x 10
    WARNING: printk() should include KERN_ facility level              x  6
    
    Signed-off-by: Gustavo Silva <silvagustavo@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 78eb254bd619..8d16380744b2 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -14,7 +14,7 @@
 
     Documentation for the DAQP PCMCIA cards can be found on Quatech's site:
 
-                ftp://ftp.quatech.com/Manuals/daqp-208.pdf
+		ftp://ftp.quatech.com/Manuals/daqp-208.pdf
 
     This manual is for both the DAQP-208 and the DAQP-308.
 
@@ -195,7 +195,7 @@ static struct comedi_driver driver_daqp = {
 
 static void daqp_dump(struct comedi_device *dev)
 {
-	printk("DAQP: status %02x; aux status %02x\n",
+	printk(KERN_INFO "DAQP: status %02x; aux status %02x\n",
 	       inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
 }
 
@@ -207,9 +207,9 @@ static void hex_dump(char *str, void *ptr, int len)
 	printk(str);
 
 	for (i = 0; i < len; i++) {
-		if (i % 16 == 0) {
+		if (i % 16 == 0)
 			printk("\n0x%08x:", (unsigned int)cptr);
-		}
+
 		printk(" %02x", *(cptr++));
 	}
 	printk("\n");
@@ -223,9 +223,9 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct local_info_t *local = (struct local_info_t *)s->private;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
+
 
 	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_COMMAND);
 
@@ -355,9 +355,9 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	int v;
 	int counter = 10000;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
+
 
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
@@ -372,9 +372,9 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 	v = DAQP_SCANLIST_CHANNEL(CR_CHAN(insn->chanspec))
 	    | DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
 
-	if (CR_AREF(insn->chanspec) == AREF_DIFF) {
+	if (CR_AREF(insn->chanspec) == AREF_DIFF)
 		v |= DAQP_SCANLIST_DIFFERENTIAL;
-	}
+
 
 	v |= DAQP_SCANLIST_START;
 
@@ -488,7 +488,10 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources
+	 * are unique and mutually compatible
+	 */
 
 	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
@@ -588,9 +591,9 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int i;
 	int v;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
+
 
 	/* Stop any running conversion */
 	daqp_ai_cancel(dev, s);
@@ -640,13 +643,11 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		v = DAQP_SCANLIST_CHANNEL(CR_CHAN(chanspec))
 		    | DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
 
-		if (CR_AREF(chanspec) == AREF_DIFF) {
+		if (CR_AREF(chanspec) == AREF_DIFF)
 			v |= DAQP_SCANLIST_DIFFERENTIAL;
-		}
 
-		if (i == 0 || scanlist_start_on_every_entry) {
+		if (i == 0 || scanlist_start_on_every_entry)
 			v |= DAQP_SCANLIST_START;
-		}
 
 		outb(v & 0xff, dev->iobase + DAQP_SCANLIST);
 		outb(v >> 8, dev->iobase + DAQP_SCANLIST);
@@ -760,7 +761,8 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	while (--counter
 	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
-		printk("daqp: couldn't clear interrupts in status register\n");
+		printk(KERN_ERR
+		       "daqp: couldn't clear interrupts in status register\n");
 		return -1;
 	}
 
@@ -785,9 +787,8 @@ static int daqp_ao_insn_write(struct comedi_device *dev,
 	int d;
 	unsigned int chan;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
 
 	chan = CR_CHAN(insn->chanspec);
 	d = data[0];
@@ -811,9 +812,8 @@ static int daqp_di_insn_read(struct comedi_device *dev,
 {
 	struct local_info_t *local = (struct local_info_t *)s->private;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
 
 	data[0] = inb(dev->iobase + DAQP_DIGITAL_IO);
 
@@ -828,9 +828,8 @@ static int daqp_do_insn_write(struct comedi_device *dev,
 {
 	struct local_info_t *local = (struct local_info_t *)s->private;
 
-	if (local->stop) {
+	if (local->stop)
 		return -EIO;
-	}
 
 	outw(data[0] & 0xf, dev->iobase + DAQP_DIGITAL_IO);
 
@@ -878,7 +877,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0)
 		return ret;
 
-	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
+	printk(KERN_INFO "comedi%d: attaching daqp%d (io 0x%04lx)\n",
 	       dev->minor, it->options[0], dev->iobase);
 
 	s = dev->subdevices + 0;
@@ -931,7 +930,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static int daqp_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: detaching daqp\n", dev->minor);
+	printk(KERN_INFO "comedi%d: detaching daqp\n", dev->minor);
 
 	return 0;
 }
@@ -1152,7 +1151,7 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	/* Finally, report what we've done */
 	dev_info(&link->dev, "index 0x%02x", link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		printk(", irq %u", link->irq);
+		printk(KERN_INFO ", irq %u", link->irq);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
 		       link->io.BasePort1 + link->io.NumPorts1 - 1);

commit f25bd6bfdf9bccd8164c151b027f9c14ec07960b
Author: Dan Carpenter <error27@gmail.com>
Date:   Sat May 22 22:42:38 2010 +0200

    Staging: comedi: cleanup: remove unneeded null checks
    
    These checks are obviously pointless because kfree() can handle null
    dereferences.
    
    But really the main problem is that if the pointers were null that would
    cause problems on the ealier lines.  The dereferences would cause an
    oops and the _release() functions use ->priv to determine which IRQ to
    free.  I looked into it and quite a few of the detach functions assume
    link->priv is non-null.  It seems like we can remove these checks.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a91db6c42028..78eb254bd619 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1076,8 +1076,7 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 
 	/* Unlink device structure, and free it */
 	dev_table[dev->table_index] = NULL;
-	if (dev)
-		kfree(dev);
+	kfree(dev);
 
 }				/* daqp_cs_detach */
 

commit d79df0b1eda0099a22cbcece01ce5e7d222450de
Merge: 6e80e8ed5eb9 c8d1a126924f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 15:26:46 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging-2.6: (577 commits)
      Staging: ramzswap: Handler for swap slot free callback
      swap: Add swap slot free callback to block_device_operations
      swap: Add flag to identify block swap devices
      Staging: vt6655: use ETH_FRAME_LEN macro instead of custom one
      Staging: vt6655: use ETH_DATA_LEN macro instead of custom one
      Staging: vt6655: use ETH_FCS_LEN macro instead of custom one
      Staging: vt6656: use ETH_HLEN macro instead of custom one
      Staging: comedi: quatech_daqp_cs.c Replace eos semaphore with a completion.
      Staging: dt3155v4l: remove private memory allocator
      Staging: crystalhd: Remove typedefs from driver
      Staging: winbond: Fix for pointer name format issue in mds.c
      Staging: vt6656: removed custom UCHAR/USHORT/UINT/ULONG/ULONGLONG typedefs
      Staging: vt6656: removed custom CHAR/SHORT/INT/LONG typedefs
      Staging: comedi: Altered the way printk is used in 8255.c
      staging: iio: adis16350 and similar IMU driver
      Staging: iio: max1363 Fix two bugs in single_channel_from_ring
      Staging: iio: adis16220 extract bin_attribute structures from state
      Staging: iio: adis16220 vibration sensor driver
      Staging: comedi: Kconfig dependancy fixes
      Staging: comedi: fix up build error from last Kconfig changes
      ...

commit c8d1a126924fcbc1d61ceb830226e0c7afdcc841
Merge: d7dbf4ffee1c 107c161b7dde
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 21 12:48:55 2010 -0700

    Merge staging-next tree into Linus's latest version
    
    Conflicts:
            drivers/staging/arlan/arlan-main.c
            drivers/staging/comedi/drivers/cb_das16_cs.c
            drivers/staging/cx25821/cx25821-alsa.c
            drivers/staging/dt3155/dt3155_drv.c
            drivers/staging/hv/hv.c
            drivers/staging/netwave/netwave_cs.c
            drivers/staging/wavelan/wavelan.c
            drivers/staging/wavelan/wavelan_cs.c
            drivers/staging/wlags49_h2/wl_cs.c
    
    This required a bit of hand merging due to the conflicts
    that happened in the later .34-rc releases, as well as
    some staging driver changing coming in through other trees
    (v4l and pcmcia).
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3142788b7967ccfd2f1813ee9e11aeb1e1cf7de2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 29 20:39:02 2010 +0000

    drivers/base: Convert dev->sem to mutex
    
    The semaphore is semantically a mutex. Convert it to a real mutex and
    fix up a few places where code was relying on semaphore.h to be included
    by device.h, as well as the users of the trylock function, as that value
    is now reversed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 1786db2f3378..8b274b708259 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -48,6 +48,7 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 */
 
 #include "../comedidev.h"
+#include <linux/semaphore.h>
 
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>

commit 7ec52ed25013533248d929d4405225d30c4272b2
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Tue May 18 13:12:32 2010 +0200

    Staging: comedi: quatech_daqp_cs.c Replace eos semaphore with a completion.
    
    Build tested only.
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index be62face6a71..d77ae81dd128 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -55,6 +55,8 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
 
+#include <linux/completion.h>
+
 /* Maximum number of separate DAQP devices we'll allow */
 #define MAX_DEV         4
 
@@ -67,7 +69,7 @@ struct local_info_t {
 
 	enum { semaphore, buffer } interrupt_mode;
 
-	struct semaphore eos;
+	struct completion eos;
 
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
@@ -238,7 +240,7 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 /* Interrupt handler
  *
  * Operates in one of two modes.  If local->interrupt_mode is
- * 'semaphore', just signal the local->eos semaphore and return
+ * 'semaphore', just signal the local->eos completion and return
  * (one-shot mode).  Otherwise (continuous mode), read data in from
  * the card, transfer it to the buffer provided by the higher-level
  * comedi kernel module, and signal various comedi callback routines,
@@ -287,7 +289,7 @@ static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 
 	case semaphore:
 
-		up(&local->eos);
+		complete(&local->eos);
 		break;
 
 	case buffer:
@@ -401,8 +403,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 		return -1;
 	}
 
-	/* Make sure semaphore is blocked */
-	sema_init(&local->eos, 0);
+	init_completion(&local->eos);
 	local->interrupt_mode = semaphore;
 	local->dev = dev;
 	local->s = s;
@@ -413,9 +414,9 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
 		     dev->iobase + DAQP_COMMAND);
 
-		/* Wait for interrupt service routine to unblock semaphore */
+		/* Wait for interrupt service routine to unblock completion */
 		/* Maybe could use a timeout here, but it's interruptible */
-		if (down_interruptible(&local->eos))
+		if (wait_for_completion_interruptible(&local->eos))
 			return -EINTR;
 
 		data[i] = inb(dev->iobase + DAQP_FIFO);

commit 7622802e479e30a2258afdbfd31acaf829636e7a
Author: Javier Martinez Canillas <martinez.javier@gmail.com>
Date:   Fri Apr 30 16:31:48 2010 -0400

    drivers/staging/comedi: dev_node removal (quatech_daqp_cs)
    
    Signed-off-by: Javier Martinez Canillas <martinez.javier@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 7aa17f92968c..1786db2f3378 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -60,7 +60,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 
 struct local_info_t {
 	struct pcmcia_device *link;
-	dev_node_t node;
 	int stop;
 	int table_index;
 	char board_name[32];
@@ -1070,10 +1069,8 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 
 	dev_dbg(&link->dev, "daqp_cs_detach\n");
 
-	if (link->dev_node) {
-		dev->stop = 1;
-		daqp_cs_release(link);
-	}
+	dev->stop = 1;
+	daqp_cs_release(link);
 
 	/* Unlink device structure, and free it */
 	dev_table[dev->table_index] = NULL;
@@ -1128,7 +1125,6 @@ static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
 
 static void daqp_cs_config(struct pcmcia_device *link)
 {
-	struct local_info_t *dev = link->priv;
 	int ret;
 
 	dev_dbg(&link->dev, "daqp_cs_config\n");
@@ -1152,21 +1148,8 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	if (ret)
 		goto failed;
 
-	/*
-	   At this point, the dev_node_t structure(s) need to be
-	   initialized and arranged in a linked list at link->dev.
-	 */
-	/* Comedi's PCMCIA script uses this device name (extracted
-	 * from /var/lib/pcmcia/stab) to pass to comedi_config
-	 */
-	/* sprintf(dev->node.dev_name, "daqp%d", dev->table_index); */
-	sprintf(dev->node.dev_name, "quatech_daqp_cs");
-	dev->node.major = dev->node.minor = 0;
-	link->dev_node = &dev->node;
-
 	/* Finally, report what we've done */
-	printk(KERN_INFO "%s: index 0x%02x",
-	       dev->node.dev_name, link->conf.ConfigIndex);
+	dev_info(&link->dev, "index 0x%02x", link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq);
 	if (link->io.NumPorts1)

commit 6c7f81967b8984e6fb6b1f04c63f32d90a15c479
Author: Alexander Kurz <linux@blala.de>
Date:   Thu May 13 13:56:16 2010 +0400

    staging: comedi PCMCIA-drivers: adding MODULE_AUTHOR, MODULE_DESCRIPTION and MODULE_LICENSE
    
    this adds and sorts the module labels MODULE_AUTHOR, MODULE_DESCRIPTION
    and MODULE_LICENSE for all comedi PCMCIA drivers.
    
    Signed-off-by: Alexander Kurz <linux@kbdbabel.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index fb427dbe98f5..be62face6a71 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1243,6 +1243,9 @@ static struct pcmcia_device_id daqp_cs_id_table[] = {
 };
 
 MODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);
+MODULE_AUTHOR("Brent Baccala <baccala@freesoft.org>");
+MODULE_DESCRIPTION("Comedi driver for Quatech DAQP PCMCIA data capture cards");
+MODULE_LICENSE("GPL");
 
 static struct pcmcia_driver daqp_cs_driver = {
 	.probe = daqp_cs_attach,

commit e3752a1dfd8a003139dee2c80de3d915534e2b39
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:05:09 2010 -0700

    Staging: comedi: quatech_daqp_cs.c: fix up the irq
    
    The irq needs to return the correct type.  Also fix up some other
    sparse warnings that were found.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 3325f24448b5..fb427dbe98f5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -244,8 +244,7 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
  * comedi kernel module, and signal various comedi callback routines,
  * which run pretty quick.
  */
-
-static void daqp_interrupt(int irq, void *dev_id)
+static enum irqreturn daqp_interrupt(int irq, void *dev_id)
 {
 	struct local_info_t *local = (struct local_info_t *)dev_id;
 	struct comedi_device *dev;
@@ -256,32 +255,32 @@ static void daqp_interrupt(int irq, void *dev_id)
 	if (local == NULL) {
 		printk(KERN_WARNING
 		       "daqp_interrupt(): irq %d for unknown device.\n", irq);
-		return;
+		return IRQ_NONE;
 	}
 
 	dev = local->dev;
 	if (dev == NULL) {
 		printk(KERN_WARNING "daqp_interrupt(): NULL comedi_device.\n");
-		return;
+		return IRQ_NONE;
 	}
 
 	if (!dev->attached) {
 		printk(KERN_WARNING
 		       "daqp_interrupt(): struct comedi_device not yet attached.\n");
-		return;
+		return IRQ_NONE;
 	}
 
 	s = local->s;
 	if (s == NULL) {
 		printk(KERN_WARNING
 		       "daqp_interrupt(): NULL comedi_subdevice.\n");
-		return;
+		return IRQ_NONE;
 	}
 
 	if ((struct local_info_t *)s->private != local) {
 		printk(KERN_WARNING
 		       "daqp_interrupt(): invalid comedi_subdevice.\n");
-		return;
+		return IRQ_NONE;
 	}
 
 	switch (local->interrupt_mode) {
@@ -340,6 +339,7 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 		comedi_event(dev, s);
 	}
+	return IRQ_HANDLED;
 }
 
 /* One-shot analog data acquisition routine */
@@ -580,7 +580,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct local_info_t *local = (struct local_info_t *)s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int counter = 100;
+	int counter;
 	int scanlist_start_on_every_entry;
 	int threshold;
 
@@ -613,14 +613,14 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		int counter = daqp_ns_to_timer(&cmd->convert_arg,
+		counter = daqp_ns_to_timer(&cmd->convert_arg,
 					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
 		scanlist_start_on_every_entry = 1;
 	} else {
-		int counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
+		counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
 					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
@@ -755,7 +755,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* Reset any pending interrupts (my card has a tendancy to require
 	 * require multiple reads on the status register to achieve this)
 	 */
-
+	counter = 100;
 	while (--counter
 	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
@@ -1244,7 +1244,7 @@ static struct pcmcia_device_id daqp_cs_id_table[] = {
 
 MODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);
 
-struct pcmcia_driver daqp_cs_driver = {
+static struct pcmcia_driver daqp_cs_driver = {
 	.probe = daqp_cs_attach,
 	.remove = daqp_cs_detach,
 	.suspend = daqp_cs_suspend,

commit eb14120f743d29744d9475bffec56ff4ad43a749
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 7 12:21:16 2010 +0100

    pcmcia: re-work pcmcia_request_irq()
    
    Instead of the old pcmcia_request_irq() interface, drivers may now
    choose between:
    
    - calling request_irq/free_irq directly. Use the IRQ from *p_dev->irq.
    
    - use pcmcia_request_irq(p_dev, handler_t); the PCMCIA core will
      clean up automatically on calls to pcmcia_disable_device() or
      device ejection.
    
    - drivers still not capable of IRQF_SHARED (or not telling us so) may
      use the deprecated pcmcia_request_exclusive_irq() for the time
      being; they might receive a shared IRQ nonetheless.
    
    CC: linux-bluetooth@vger.kernel.org
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-serial@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-usb@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 3325f24448b5..7aa17f92968c 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1040,10 +1040,6 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	local->link = link;
 	link->priv = local;
 
-	/* Interrupt setup */
-	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
-	link->irq.Handler = daqp_interrupt;
-
 	/*
 	   General socket configuration defaults can go here.  In this
 	   client, we assume very little, and rely on the CIS for almost
@@ -1105,8 +1101,7 @@ static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
 		return -ENODEV;
 
 	/* Do we need to allocate an interrupt? */
-	if (cfg->irq.IRQInfo1 || dflt->irq.IRQInfo1)
-		p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
+	p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
 
 	/* IO window settings */
 	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
@@ -1144,16 +1139,9 @@ static void daqp_cs_config(struct pcmcia_device *link)
 		goto failed;
 	}
 
-	/*
-	   Allocate an interrupt line.  Note that this does not assign a
-	   handler to the interrupt, unless the 'Handler' member of the
-	   irq structure is initialized.
-	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
-		ret = pcmcia_request_irq(link, &link->irq);
-		if (ret)
-			goto failed;
-	}
+	ret = pcmcia_request_irq(link, daqp_interrupt);
+	if (ret)
+		goto failed;
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
@@ -1180,7 +1168,7 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	printk(KERN_INFO "%s: index 0x%02x",
 	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		printk(", irq %u", link->irq.AssignedIRQ);
+		printk(", irq %u", link->irq);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
 		       link->io.BasePort1 + link->io.NumPorts1 - 1);

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 5256fd933162..3325f24448b5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -489,7 +489,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;

commit 5fa9167a1bf5f5a4b7282f5e7ac56a4a5a1fa044
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Nov 8 17:24:46 2009 +0100

    pcmcia: rework the irq_req_t typedef
    
    Most of the irq_req_t typedef'd struct can be re-worked quite
    easily:
    
    (1) IRQInfo2 was unused in any case, so drop it.
    
    (2) IRQInfo1 was used write-only, so drop it.
    
    (3) Instance (private data to be passed to the IRQ handler):
            Most PCMCIA drivers using pcmcia_request_irq() to actually
            register an IRQ handler set the "dev_id" to the same pointer
            as the "priv" pointer in struct pcmcia_device. Modify the two
            exceptions (ipwireless, ibmtr_cs) to also work this waym and
            set the IRQ handler's "dev_id" to p_dev->priv unconditionally.
    
    (4) Handler is to be of type irq_handler_t.
    
    (5) Handler != NULL already tells whether an IRQ handler is present.
            Therefore, we do not need the IRQ_HANDLER_PRESENT flag in
            irq_req_t.Attributes.
    
    CC: netdev@vger.kernel.org
    CC: linux-bluetooth@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: Jaroslav Kysela <perex@perex.cz>
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: Karsten Keil <isdn@linux-pingi.de>
    for the Bluetooth parts: Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 48e7c27ed87a..5256fd933162 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1041,10 +1041,8 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	link->priv = local;
 
 	/* Interrupt setup */
-	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
-	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
 	link->irq.Handler = daqp_interrupt;
-	link->irq.Instance = local;
 
 	/*
 	   General socket configuration defaults can go here.  In this

commit 55a19b39acb8888af8e9cfe5b762d03c52fdb48c
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Oct 29 00:54:49 2009 +0100

    pcmcia/staging: update comedi drivers
    
    Update comedi PCMCIA drivers to work with recent PCMCIA changes documented
    in Documentation/pcmcia/driver-changes.txt:
    
    - use pcmcia_config_loop()
    - don't use PCMCIA_DEBUG, but use dev_dbg()
    - don't use cs_error()
    - re-use prod_id and card_id values already stored
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 344b82353e08..48e7c27ed87a 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -55,23 +55,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
 
-/*
-   All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
-   you do not define PCMCIA_DEBUG at all, all the debug code will be
-   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
-   be present but disabled -- but it can then be enabled for specific
-   modules at load time with a 'pc_debug=#' option to insmod.
-*/
-
-#ifdef PCMCIA_DEBUG
-static int pc_debug = PCMCIA_DEBUG;
-module_param(pc_debug, int, 0644);
-#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
-static char *version = "quatech_daqp_cs.c 1.10 2003/04/21 (Brent Baccala)";
-#else
-#define DEBUG(n, args...)
-#endif
-
 /* Maximum number of separate DAQP devices we'll allow */
 #define MAX_DEV         4
 
@@ -863,8 +846,6 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	struct local_info_t *local = dev_table[it->options[0]];
-	tuple_t tuple;
-	int i;
 	struct comedi_subdevice *s;
 
 	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
@@ -883,29 +864,10 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	strcpy(local->board_name, "DAQP");
 	dev->board_name = local->board_name;
-
-	tuple.DesiredTuple = CISTPL_VERS_1;
-	if (pcmcia_get_first_tuple(local->link, &tuple) == 0) {
-		u_char buf[128];
-
-		buf[0] = buf[sizeof(buf) - 1] = 0;
-		tuple.TupleData = buf;
-		tuple.TupleDataMax = sizeof(buf);
-		tuple.TupleOffset = 2;
-		if (pcmcia_get_tuple_data(local->link, &tuple) == 0) {
-
-			for (i = 0; i < tuple.TupleDataLen - 4; i++)
-				if (buf[i] == 0)
-					break;
-			for (i++; i < tuple.TupleDataLen - 4; i++)
-				if (buf[i] == 0)
-					break;
-			i++;
-			if ((i < tuple.TupleDataLen - 4)
-			    && (strncmp(buf + i, "DAQP", 4) == 0)) {
-				strncpy(local->board_name, buf + i,
-					sizeof(local->board_name));
-			}
+	if (local->link->prod_id[2]) {
+		if (strncmp(local->link->prod_id[2], "DAQP", 4) == 0) {
+			strncpy(local->board_name, local->link->prod_id[2],
+				sizeof(local->board_name));
 		}
 	}
 
@@ -1058,7 +1020,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	struct local_info_t *local;
 	int i;
 
-	DEBUG(0, "daqp_cs_attach()\n");
+	dev_dbg(&link->dev, "daqp_cs_attach()\n");
 
 	for (i = 0; i < MAX_DEV; i++)
 		if (dev_table[i] == NULL)
@@ -1112,7 +1074,7 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 {
 	struct local_info_t *dev = link->priv;
 
-	DEBUG(0, "daqp_cs_detach(0x%p)\n", link);
+	dev_dbg(&link->dev, "daqp_cs_detach\n");
 
 	if (link->dev_node) {
 		dev->stop = 1;
@@ -1134,115 +1096,54 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 
 ======================================================================*/
 
-static void daqp_cs_config(struct pcmcia_device *link)
-{
-	struct local_info_t *dev = link->priv;
-	tuple_t tuple;
-	cisparse_t parse;
-	int last_ret;
-	u_char buf[64];
-
-	DEBUG(0, "daqp_cs_config(0x%p)\n", link);
-
-	/*
-	   This reads the card's CONFIG tuple to find its configuration
-	   registers.
-	 */
-	tuple.DesiredTuple = CISTPL_CONFIG;
-	tuple.Attributes = 0;
-	tuple.TupleData = buf;
-	tuple.TupleDataMax = sizeof(buf);
-	tuple.TupleOffset = 0;
-
-	last_ret = pcmcia_get_first_tuple(link, &tuple);
-	if (last_ret) {
-		cs_error(link, GetFirstTuple, last_ret);
-		goto cs_failed;
-	}
 
-	last_ret = pcmcia_get_tuple_data(link, &tuple);
-	if (last_ret) {
-		cs_error(link, GetTupleData, last_ret);
-		goto cs_failed;
-	}
-
-	last_ret = pcmcia_parse_tuple(&tuple, &parse);
-	if (last_ret) {
-		cs_error(link, ParseTuple, last_ret);
-		goto cs_failed;
-	}
-	link->conf.ConfigBase = parse.config.base;
-	link->conf.Present = parse.config.rmask[0];
+static int daqp_pcmcia_config_loop(struct pcmcia_device *p_dev,
+				cistpl_cftable_entry_t *cfg,
+				cistpl_cftable_entry_t *dflt,
+				unsigned int vcc,
+				void *priv_data)
+{
+	if (cfg->index == 0)
+		return -ENODEV;
 
-	/*
-	   In this loop, we scan the CIS for configuration table entries,
-	   each of which describes a valid card configuration, including
-	   voltage, IO window, memory window, and interrupt settings.
-
-	   We make no assumptions about the card to be configured: we use
-	   just the information available in the CIS.  In an ideal world,
-	   this would work for any PCMCIA card, but it requires a complete
-	   and accurate CIS.  In practice, a driver usually "knows" most of
-	   these things without consulting the CIS, and most client drivers
-	   will only use the CIS to fill in implementation-defined details.
-	 */
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	last_ret = pcmcia_get_first_tuple(link, &tuple);
-	if (last_ret) {
-		cs_error(link, GetFirstTuple, last_ret);
-		goto cs_failed;
+	/* Do we need to allocate an interrupt? */
+	if (cfg->irq.IRQInfo1 || dflt->irq.IRQInfo1)
+		p_dev->conf.Attributes |= CONF_ENABLE_IRQ;
+
+	/* IO window settings */
+	p_dev->io.NumPorts1 = p_dev->io.NumPorts2 = 0;
+	if ((cfg->io.nwin > 0) || (dflt->io.nwin > 0)) {
+		cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;
+		p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+		if (!(io->flags & CISTPL_IO_8BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+		if (!(io->flags & CISTPL_IO_16BIT))
+			p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+		p_dev->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+		p_dev->io.BasePort1 = io->win[0].base;
+		p_dev->io.NumPorts1 = io->win[0].len;
+		if (io->nwin > 1) {
+			p_dev->io.Attributes2 = p_dev->io.Attributes1;
+			p_dev->io.BasePort2 = io->win[1].base;
+			p_dev->io.NumPorts2 = io->win[1].len;
+		}
 	}
 
-	while (1) {
-		cistpl_cftable_entry_t dflt = { 0 };
-		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
-		if (pcmcia_get_tuple_data(link, &tuple))
-			goto next_entry;
-		if (pcmcia_parse_tuple(&tuple, &parse))
-			goto next_entry;
-
-		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
-			dflt = *cfg;
-		if (cfg->index == 0)
-			goto next_entry;
-		link->conf.ConfigIndex = cfg->index;
-
-		/* Do we need to allocate an interrupt? */
-		if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1)
-			link->conf.Attributes |= CONF_ENABLE_IRQ;
-
-		/* IO window settings */
-		link->io.NumPorts1 = link->io.NumPorts2 = 0;
-		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
-			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
-			link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
-			if (!(io->flags & CISTPL_IO_8BIT))
-				link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
-			if (!(io->flags & CISTPL_IO_16BIT))
-				link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-			link->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
-			link->io.BasePort1 = io->win[0].base;
-			link->io.NumPorts1 = io->win[0].len;
-			if (io->nwin > 1) {
-				link->io.Attributes2 = link->io.Attributes1;
-				link->io.BasePort2 = io->win[1].base;
-				link->io.NumPorts2 = io->win[1].len;
-			}
-		}
+	/* This reserves IO space but doesn't actually enable it */
+	return pcmcia_request_io(p_dev, &p_dev->io);
+}
 
-		/* This reserves IO space but doesn't actually enable it */
-		if (pcmcia_request_io(link, &link->io))
-			goto next_entry;
+static void daqp_cs_config(struct pcmcia_device *link)
+{
+	struct local_info_t *dev = link->priv;
+	int ret;
 
-		/* If we got this far, we're cool! */
-		break;
+	dev_dbg(&link->dev, "daqp_cs_config\n");
 
-next_entry:
-		last_ret = pcmcia_get_next_tuple(link, &tuple);
-		if (last_ret) {
-			cs_error(link, GetNextTuple, last_ret);
-			goto cs_failed;
-		}
+	ret = pcmcia_loop_config(link, daqp_pcmcia_config_loop, NULL);
+	if (ret) {
+		dev_warn(&link->dev, "no configuration found\n");
+		goto failed;
 	}
 
 	/*
@@ -1251,11 +1152,9 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	   irq structure is initialized.
 	 */
 	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
-		last_ret = pcmcia_request_irq(link, &link->irq);
-		if (last_ret) {
-			cs_error(link, RequestIRQ, last_ret);
-			goto cs_failed;
-		}
+		ret = pcmcia_request_irq(link, &link->irq);
+		if (ret)
+			goto failed;
 	}
 
 	/*
@@ -1263,11 +1162,9 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	last_ret = pcmcia_request_configuration(link, &link->conf);
-	if (last_ret) {
-		cs_error(link, RequestConfiguration, last_ret);
-		goto cs_failed;
-	}
+	ret = pcmcia_request_configuration(link, &link->conf);
+	if (ret)
+		goto failed;
 
 	/*
 	   At this point, the dev_node_t structure(s) need to be
@@ -1296,14 +1193,14 @@ static void daqp_cs_config(struct pcmcia_device *link)
 
 	return;
 
-cs_failed:
+failed:
 	daqp_cs_release(link);
 
 }				/* daqp_cs_config */
 
 static void daqp_cs_release(struct pcmcia_device *link)
 {
-	DEBUG(0, "daqp_cs_release(0x%p)\n", link);
+	dev_dbg(&link->dev, "daqp_cs_release\n");
 
 	pcmcia_disable_device(link);
 }				/* daqp_cs_release */
@@ -1363,7 +1260,6 @@ struct pcmcia_driver daqp_cs_driver = {
 
 int __init init_module(void)
 {
-	DEBUG(0, "%s\n", version);
 	pcmcia_register_driver(&daqp_cs_driver);
 	comedi_driver_register(&driver_daqp);
 	return 0;
@@ -1371,7 +1267,6 @@ int __init init_module(void)
 
 void __exit cleanup_module(void)
 {
-	DEBUG(0, "daqp_cs: unloading\n");
 	comedi_driver_unregister(&driver_daqp);
 	pcmcia_unregister_driver(&daqp_cs_driver);
 }

commit 3d1c28848ea37bf117940e10826f7a485aa32337
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Tue Sep 22 16:32:55 2009 -0400

    Staging: comedi: pcmcia irq fixes
    
    Replaced IRQ_TYPE_EXCLUSIVE with IRQ_TYPE_DYNAMIC_SHARING for pcmcia
    drivers.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f63bdc35cffd..344b82353e08 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -1079,7 +1079,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	link->priv = local;
 
 	/* Interrupt setup */
-	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+	link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
 	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
 	link->irq.Handler = daqp_interrupt;
 	link->irq.Instance = local;

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 85b53c93e135..f63bdc35cffd 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -184,11 +184,11 @@ static struct local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
  */
 
 static const struct comedi_lrange range_daqp_ai = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25)
-	}
+							BIP_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(2.5),
+							BIP_RANGE(1.25)
+							}
 };
 
 static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
@@ -211,7 +211,7 @@ static struct comedi_driver driver_daqp = {
 static void daqp_dump(struct comedi_device *dev)
 {
 	printk("DAQP: status %02x; aux status %02x\n",
-		inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
+	       inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
 }
 
 static void hex_dump(char *str, void *ptr, int len)
@@ -236,7 +236,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -264,7 +264,7 @@ static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void daqp_interrupt(int irq, void *dev_id)
 {
-	struct local_info_t *local = (struct local_info_t *) dev_id;
+	struct local_info_t *local = (struct local_info_t *)dev_id;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	int loop_limit = 10000;
@@ -272,7 +272,7 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 	if (local == NULL) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): irq %d for unknown device.\n", irq);
+		       "daqp_interrupt(): irq %d for unknown device.\n", irq);
 		return;
 	}
 
@@ -284,20 +284,20 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 	if (!dev->attached) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): struct comedi_device not yet attached.\n");
+		       "daqp_interrupt(): struct comedi_device not yet attached.\n");
 		return;
 	}
 
 	s = local->s;
 	if (s == NULL) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): NULL comedi_subdevice.\n");
+		       "daqp_interrupt(): NULL comedi_subdevice.\n");
 		return;
 	}
 
-	if ((struct local_info_t *) s->private != local) {
+	if ((struct local_info_t *)s->private != local) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): invalid comedi_subdevice.\n");
+		       "daqp_interrupt(): invalid comedi_subdevice.\n");
 		return;
 	}
 
@@ -311,13 +311,13 @@ static void daqp_interrupt(int irq, void *dev_id)
 	case buffer:
 
 		while (!((status = inb(dev->iobase + DAQP_STATUS))
-				& DAQP_STATUS_FIFO_EMPTY)) {
+			 & DAQP_STATUS_FIFO_EMPTY)) {
 
 			short data;
 
 			if (status & DAQP_STATUS_DATA_LOST) {
 				s->async->events |=
-					COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
+				    COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
 				printk("daqp: data lost\n");
 				daqp_ai_cancel(dev, s);
 				break;
@@ -348,7 +348,7 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 		if (loop_limit <= 0) {
 			printk(KERN_WARNING
-				"loop_limit reached in daqp_interrupt()\n");
+			       "loop_limit reached in daqp_interrupt()\n");
 			daqp_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		}
@@ -361,10 +361,11 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 /* One-shot analog data acquisition routine */
 
-static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	int i;
 	int v;
 	int counter = 10000;
@@ -384,7 +385,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	/* Program one scan list entry */
 
 	v = DAQP_SCANLIST_CHANNEL(CR_CHAN(insn->chanspec))
-		| DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
+	    | DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
 
 	if (CR_AREF(insn->chanspec) == AREF_DIFF) {
 		v |= DAQP_SCANLIST_DIFFERENTIAL;
@@ -402,7 +403,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	/* Set trigger */
 
 	v = DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL
-		| DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
+	    | DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
@@ -411,7 +412,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 	 */
 
 	while (--counter
-		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
 		printk("daqp: couldn't clear interrupts in status register\n");
 		return -1;
@@ -427,7 +428,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice
 
 		/* Start conversion */
 		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-			dev->iobase + DAQP_COMMAND);
+		     dev->iobase + DAQP_COMMAND);
 
 		/* Wait for interrupt service routine to unblock semaphore */
 		/* Maybe could use a timeout here, but it's interruptible */
@@ -467,8 +468,8 @@ static int daqp_ns_to_timer(unsigned int *ns, int round)
  * the command passes.
  */
 
-static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int daqp_ai_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -507,7 +508,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_NOW && cmd->convert_src != TRIG_TIMER)
 		err++;
@@ -528,7 +529,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 #define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER
-		&& cmd->scan_begin_arg < MAX_SPEED) {
+	    && cmd->scan_begin_arg < MAX_SPEED) {
 		cmd->scan_begin_arg = MAX_SPEED;
 		err++;
 	}
@@ -539,8 +540,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 	 */
 
 	if (cmd->scan_begin_src == TRIG_TIMER && cmd->convert_src == TRIG_TIMER
-		&& cmd->scan_begin_arg !=
-		cmd->convert_arg * cmd->scan_end_arg) {
+	    && cmd->scan_begin_arg != cmd->convert_arg * cmd->scan_end_arg) {
 		err++;
 	}
 
@@ -574,7 +574,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		daqp_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -582,7 +582,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		daqp_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				 cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -595,7 +595,7 @@ static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 
 static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter = 100;
 	int scanlist_start_on_every_entry;
@@ -631,14 +631,14 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		int counter = daqp_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
 		scanlist_start_on_every_entry = 1;
 	} else {
 		int counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					       cmd->flags & TRIG_ROUND_MASK);
 		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
 		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
 		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
@@ -654,7 +654,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* Program one scan list entry */
 
 		v = DAQP_SCANLIST_CHANNEL(CR_CHAN(chanspec))
-			| DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
+		    | DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
 
 		if (CR_AREF(chanspec) == AREF_DIFF) {
 			v |= DAQP_SCANLIST_DIFFERENTIAL;
@@ -765,7 +765,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* Set trigger */
 
 	v = DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL
-		| DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
+	    | DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
@@ -774,7 +774,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 
 	while (--counter
-		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	       && (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
 	if (!counter) {
 		printk("daqp: couldn't clear interrupts in status register\n");
 		return -1;
@@ -786,17 +786,18 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* Start conversion */
 	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
-		dev->iobase + DAQP_COMMAND);
+	     dev->iobase + DAQP_COMMAND);
 
 	return 0;
 }
 
 /* Single-shot analog output routine */
 
-static int daqp_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_ao_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 	int d;
 	unsigned int chan;
 
@@ -820,10 +821,11 @@ static int daqp_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice
 
 /* Digital input routine */
 
-static int daqp_di_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_di_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -836,10 +838,11 @@ static int daqp_di_insn_read(struct comedi_device *dev, struct comedi_subdevice
 
 /* Digital output routine */
 
-static int daqp_do_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int daqp_do_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
-	struct local_info_t *local = (struct local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *)s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -866,7 +869,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
 		printk("comedi%d: No such daqp device %d\n",
-			dev->minor, it->options[0]);
+		       dev->minor, it->options[0]);
 		return -EIO;
 	}
 
@@ -899,7 +902,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					break;
 			i++;
 			if ((i < tuple.TupleDataLen - 4)
-				&& (strncmp(buf + i, "DAQP", 4) == 0)) {
+			    && (strncmp(buf + i, "DAQP", 4) == 0)) {
 				strncpy(local->board_name, buf + i,
 					sizeof(local->board_name));
 			}
@@ -913,7 +916,7 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
-		dev->minor, it->options[0], dev->iobase);
+	       dev->minor, it->options[0], dev->iobase);
 
 	s = dev->subdevices + 0;
 	dev->read_subdev = s;
@@ -1234,7 +1237,7 @@ static void daqp_cs_config(struct pcmcia_device *link)
 		/* If we got this far, we're cool! */
 		break;
 
-	      next_entry:
+next_entry:
 		last_ret = pcmcia_get_next_tuple(link, &tuple);
 		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
@@ -1280,20 +1283,20 @@ static void daqp_cs_config(struct pcmcia_device *link)
 
 	/* Finally, report what we've done */
 	printk(KERN_INFO "%s: index 0x%02x",
-		dev->node.dev_name, link->conf.ConfigIndex);
+	       dev->node.dev_name, link->conf.ConfigIndex);
 	if (link->conf.Attributes & CONF_ENABLE_IRQ)
 		printk(", irq %u", link->irq.AssignedIRQ);
 	if (link->io.NumPorts1)
 		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
-			link->io.BasePort1 + link->io.NumPorts1 - 1);
+		       link->io.BasePort1 + link->io.NumPorts1 - 1);
 	if (link->io.NumPorts2)
 		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
-			link->io.BasePort2 + link->io.NumPorts2 - 1);
+		       link->io.BasePort2 + link->io.NumPorts2 - 1);
 	printk("\n");
 
 	return;
 
-      cs_failed:
+cs_failed:
 	daqp_cs_release(link);
 
 }				/* daqp_cs_config */
@@ -1354,7 +1357,7 @@ struct pcmcia_driver daqp_cs_driver = {
 	.id_table = daqp_cs_id_table,
 	.owner = THIS_MODULE,
 	.drv = {
-			.name = dev_info,
+		.name = dev_info,
 		},
 };
 

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index d6427e2fc14c..85b53c93e135 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -179,8 +179,8 @@ static struct local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
 #define DAQP_AUX_FIFO_EMPTY		0x01
 
 /* These range structures tell COMEDI how the sample values map to
- * voltages.  The A/D converter has four ranges: +/- 10V through
- * +/- 1.25V, and the D/A converter has only one: +/- 5V.
+ * voltages.  The A/D converter has four	.ranges = +/- 10V through
+ * +/- 1.25V, and the D/A converter has only	.one = +/- 5V.
  */
 
 static const struct comedi_lrange range_daqp_ai = { 4, {
@@ -200,10 +200,10 @@ static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int daqp_detach(struct comedi_device *dev);
 static struct comedi_driver driver_daqp = {
-      driver_name:"quatech_daqp_cs",
-      module:THIS_MODULE,
-      attach:daqp_attach,
-      detach:daqp_detach,
+	.driver_name = "quatech_daqp_cs",
+	.module = THIS_MODULE,
+	.attach = daqp_attach,
+	.detach = daqp_detach,
 };
 
 #ifdef DAQP_DEBUG

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 0066218dba48..d6427e2fc14c 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -908,7 +908,8 @@ static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->iobase = local->link->io.BasePort1;
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
@@ -1149,15 +1150,21 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	tuple.TupleData = buf;
 	tuple.TupleDataMax = sizeof(buf);
 	tuple.TupleOffset = 0;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_get_tuple_data(link, &tuple))) {
+
+	last_ret = pcmcia_get_tuple_data(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetTupleData, last_ret);
 		goto cs_failed;
 	}
-	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse))) {
+
+	last_ret = pcmcia_parse_tuple(&tuple, &parse);
+	if (last_ret) {
 		cs_error(link, ParseTuple, last_ret);
 		goto cs_failed;
 	}
@@ -1177,10 +1184,12 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	   will only use the CIS to fill in implementation-defined details.
 	 */
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+	last_ret = pcmcia_get_first_tuple(link, &tuple);
+	if (last_ret) {
 		cs_error(link, GetFirstTuple, last_ret);
 		goto cs_failed;
 	}
+
 	while (1) {
 		cistpl_cftable_entry_t dflt = { 0 };
 		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
@@ -1226,7 +1235,8 @@ static void daqp_cs_config(struct pcmcia_device *link)
 		break;
 
 	      next_entry:
-		if ((last_ret = pcmcia_get_next_tuple(link, &tuple))) {
+		last_ret = pcmcia_get_next_tuple(link, &tuple);
+		if (last_ret) {
 			cs_error(link, GetNextTuple, last_ret);
 			goto cs_failed;
 		}
@@ -1237,18 +1247,21 @@ static void daqp_cs_config(struct pcmcia_device *link)
 	   handler to the interrupt, unless the 'Handler' member of the
 	   irq structure is initialized.
 	 */
-	if (link->conf.Attributes & CONF_ENABLE_IRQ)
-		if ((last_ret = pcmcia_request_irq(link, &link->irq))) {
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		last_ret = pcmcia_request_irq(link, &link->irq);
+		if (last_ret) {
 			cs_error(link, RequestIRQ, last_ret);
 			goto cs_failed;
 		}
+	}
 
 	/*
 	   This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping, and putting the
 	   card and host interface into "Memory and IO" mode.
 	 */
-	if ((last_ret = pcmcia_request_configuration(link, &link->conf))) {
+	last_ret = pcmcia_request_configuration(link, &link->conf);
+	if (last_ret) {
 		cs_error(link, RequestConfiguration, last_ret);
 		goto cs_failed;
 	}

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index d05f33bac4a1..0066218dba48 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -197,8 +197,8 @@ static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
 /* comedi interface code */
 
-static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int daqp_detach(struct comedi_device * dev);
+static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int daqp_detach(struct comedi_device *dev);
 static struct comedi_driver driver_daqp = {
       driver_name:"quatech_daqp_cs",
       module:THIS_MODULE,
@@ -208,7 +208,7 @@ static struct comedi_driver driver_daqp = {
 
 #ifdef DAQP_DEBUG
 
-static void daqp_dump(struct comedi_device * dev)
+static void daqp_dump(struct comedi_device *dev)
 {
 	printk("DAQP: status %02x; aux status %02x\n",
 		inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
@@ -234,7 +234,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 /* Cancel a running acquisition */
 
-static int daqp_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int daqp_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 
@@ -361,8 +361,8 @@ static void daqp_interrupt(int irq, void *dev_id)
 
 /* One-shot analog data acquisition routine */
 
-static int daqp_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int daqp_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 	int i;
@@ -467,8 +467,8 @@ static int daqp_ns_to_timer(unsigned int *ns, int round)
  * the command passes.
  */
 
-static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int daqp_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -593,7 +593,7 @@ static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -793,8 +793,8 @@ static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 
 /* Single-shot analog output routine */
 
-static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int daqp_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 	int d;
@@ -820,8 +820,8 @@ static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevic
 
 /* Digital input routine */
 
-static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int daqp_di_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 
@@ -836,8 +836,8 @@ static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice
 
 /* Digital output routine */
 
-static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int daqp_do_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct local_info_t *local = (struct local_info_t *) s->private;
 
@@ -856,7 +856,7 @@ static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevic
  * when it is inserted.
  */
 
-static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int daqp_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	struct local_info_t *local = dev_table[it->options[0]];
@@ -962,7 +962,7 @@ static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it)
  * card is removed, daqp_cs_detach() is called by the pcmcia subsystem.
  */
 
-static int daqp_detach(struct comedi_device * dev)
+static int daqp_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: detaching daqp\n", dev->minor);
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 795c4522867f..d05f33bac4a1 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -262,7 +262,7 @@ static int daqp_ai_cancel(struct comedi_device * dev, struct comedi_subdevice *
  * which run pretty quick.
  */
 
-static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
+static void daqp_interrupt(int irq, void *dev_id)
 {
 	struct local_info_t *local = (struct local_info_t *) dev_id;
 	struct comedi_device *dev;

commit ab64f663412716193ccafefd7e6cc27dcf691ac8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:53 2009 -0400

    Staging: comedi: quatech_daqp_cs: Remove local_info_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index f405341c95f6..795c4522867f 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -75,7 +75,7 @@ static char *version = "quatech_daqp_cs.c 1.10 2003/04/21 (Brent Baccala)";
 /* Maximum number of separate DAQP devices we'll allow */
 #define MAX_DEV         4
 
-typedef struct local_info_t {
+struct local_info_t {
 	struct pcmcia_device *link;
 	dev_node_t node;
 	int stop;
@@ -89,11 +89,11 @@ typedef struct local_info_t {
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	int count;
-} local_info_t;
+};
 
 /* A list of "instances" of the device. */
 
-static local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
+static struct local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
 
 /* The DAQP communicates with the system through a 16 byte I/O window. */
 
@@ -236,7 +236,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 static int daqp_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -264,7 +264,7 @@ static int daqp_ai_cancel(struct comedi_device * dev, struct comedi_subdevice *
 
 static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 {
-	local_info_t *local = (local_info_t *) dev_id;
+	struct local_info_t *local = (struct local_info_t *) dev_id;
 	struct comedi_device *dev;
 	struct comedi_subdevice *s;
 	int loop_limit = 10000;
@@ -295,7 +295,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 		return;
 	}
 
-	if ((local_info_t *) s->private != local) {
+	if ((struct local_info_t *) s->private != local) {
 		printk(KERN_WARNING
 			"daqp_interrupt(): invalid comedi_subdevice.\n");
 		return;
@@ -364,7 +364,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 static int daqp_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 	int i;
 	int v;
 	int counter = 10000;
@@ -595,7 +595,7 @@ static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 
 static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter = 100;
 	int scanlist_start_on_every_entry;
@@ -796,7 +796,7 @@ static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 	int d;
 	unsigned int chan;
 
@@ -823,7 +823,7 @@ static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevic
 static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -839,7 +839,7 @@ static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice
 static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	local_info_t *local = (local_info_t *) s->private;
+	struct local_info_t *local = (struct local_info_t *) s->private;
 
 	if (local->stop) {
 		return -EIO;
@@ -859,7 +859,7 @@ static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevic
 static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int ret;
-	local_info_t *local = dev_table[it->options[0]];
+	struct local_info_t *local = dev_table[it->options[0]];
 	tuple_t tuple;
 	int i;
 	struct comedi_subdevice *s;
@@ -1051,7 +1051,7 @@ static const dev_info_t dev_info = "quatech_daqp_cs";
 
 static int daqp_cs_attach(struct pcmcia_device *link)
 {
-	local_info_t *local;
+	struct local_info_t *local;
 	int i;
 
 	DEBUG(0, "daqp_cs_attach()\n");
@@ -1065,7 +1065,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 	}
 
 	/* Allocate space for private device-specific data */
-	local = kzalloc(sizeof(local_info_t), GFP_KERNEL);
+	local = kzalloc(sizeof(struct local_info_t), GFP_KERNEL);
 	if (!local)
 		return -ENOMEM;
 
@@ -1106,7 +1106,7 @@ static int daqp_cs_attach(struct pcmcia_device *link)
 
 static void daqp_cs_detach(struct pcmcia_device *link)
 {
-	local_info_t *dev = link->priv;
+	struct local_info_t *dev = link->priv;
 
 	DEBUG(0, "daqp_cs_detach(0x%p)\n", link);
 
@@ -1132,7 +1132,7 @@ static void daqp_cs_detach(struct pcmcia_device *link)
 
 static void daqp_cs_config(struct pcmcia_device *link)
 {
-	local_info_t *dev = link->priv;
+	struct local_info_t *dev = link->priv;
 	tuple_t tuple;
 	cisparse_t parse;
 	int last_ret;
@@ -1306,7 +1306,7 @@ static void daqp_cs_release(struct pcmcia_device *link)
 
 static int daqp_cs_suspend(struct pcmcia_device *link)
 {
-	local_info_t *local = link->priv;
+	struct local_info_t *local = link->priv;
 
 	/* Mark the device as stopped, to block IO until later */
 	local->stop = 1;
@@ -1315,7 +1315,7 @@ static int daqp_cs_suspend(struct pcmcia_device *link)
 
 static int daqp_cs_resume(struct pcmcia_device *link)
 {
-	local_info_t *local = link->priv;
+	struct local_info_t *local = link->priv;
 
 	local->stop = 0;
 

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 6494312cb169..f405341c95f6 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -197,7 +197,7 @@ static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
 /* comedi interface code */
 
-static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int daqp_detach(struct comedi_device * dev);
 static struct comedi_driver driver_daqp = {
       driver_name:"quatech_daqp_cs",
@@ -856,7 +856,7 @@ static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevic
  * when it is inserted.
  */
 
-static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int daqp_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int ret;
 	local_info_t *local = dev_table[it->options[0]];

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 9a188d44551f..6494312cb169 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -362,7 +362,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 /* One-shot analog data acquisition routine */
 
 static int daqp_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	int i;
@@ -794,7 +794,7 @@ static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 /* Single-shot analog output routine */
 
 static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	int d;
@@ -821,7 +821,7 @@ static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevic
 /* Digital input routine */
 
 static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 
@@ -837,7 +837,7 @@ static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice
 /* Digital output routine */
 
 static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index d83cc3295dd4..9a188d44551f 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -468,7 +468,7 @@ static int daqp_ns_to_timer(unsigned int *ns, int round)
  */
 
 static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -596,7 +596,7 @@ static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	local_info_t *local = (local_info_t *) s->private;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int counter = 100;
 	int scanlist_start_on_every_entry;
 	int threshold;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index c30b1ccb2903..d83cc3295dd4 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -183,7 +183,7 @@ static local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
  * +/- 1.25V, and the D/A converter has only one: +/- 5V.
  */
 
-static const comedi_lrange range_daqp_ai = { 4, {
+static const struct comedi_lrange range_daqp_ai = { 4, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -191,7 +191,7 @@ static const comedi_lrange range_daqp_ai = { 4, {
 	}
 };
 
-static const comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
+static const struct comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
 /*====================================================================*/
 

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index a3bfa6465b56..c30b1ccb2903 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -199,7 +199,7 @@ static const comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
 static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int daqp_detach(struct comedi_device * dev);
-static comedi_driver driver_daqp = {
+static struct comedi_driver driver_daqp = {
       driver_name:"quatech_daqp_cs",
       module:THIS_MODULE,
       attach:daqp_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index cc6a6daa1f9a..a3bfa6465b56 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -87,7 +87,7 @@ typedef struct local_info_t {
 	struct semaphore eos;
 
 	struct comedi_device *dev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int count;
 } local_info_t;
 
@@ -234,7 +234,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 /* Cancel a running acquisition */
 
-static int daqp_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int daqp_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	local_info_t *local = (local_info_t *) s->private;
 
@@ -266,7 +266,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 {
 	local_info_t *local = (local_info_t *) dev_id;
 	struct comedi_device *dev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int loop_limit = 10000;
 	int status;
 
@@ -361,7 +361,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 
 /* One-shot analog data acquisition routine */
 
-static int daqp_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int daqp_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -467,7 +467,7 @@ static int daqp_ns_to_timer(unsigned int *ns, int round)
  * the command passes.
  */
 
-static int daqp_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int daqp_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -593,7 +593,7 @@ static int daqp_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int daqp_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int daqp_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -793,7 +793,7 @@ static int daqp_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 
 /* Single-shot analog output routine */
 
-static int daqp_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int daqp_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -820,7 +820,7 @@ static int daqp_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 
 /* Digital input routine */
 
-static int daqp_di_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int daqp_di_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -836,7 +836,7 @@ static int daqp_di_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 
 /* Digital output routine */
 
-static int daqp_do_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int daqp_do_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -862,7 +862,7 @@ static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it)
 	local_info_t *local = dev_table[it->options[0]];
 	tuple_t tuple;
 	int i;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
 		printk("comedi%d: No such daqp device %d\n",

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ac34c5183c0c..cc6a6daa1f9a 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -86,7 +86,7 @@ typedef struct local_info_t {
 
 	struct semaphore eos;
 
-	comedi_device *dev;
+	struct comedi_device *dev;
 	comedi_subdevice *s;
 	int count;
 } local_info_t;
@@ -197,8 +197,8 @@ static const comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
 
 /* comedi interface code */
 
-static int daqp_attach(comedi_device * dev, comedi_devconfig * it);
-static int daqp_detach(comedi_device * dev);
+static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int daqp_detach(struct comedi_device * dev);
 static comedi_driver driver_daqp = {
       driver_name:"quatech_daqp_cs",
       module:THIS_MODULE,
@@ -208,7 +208,7 @@ static comedi_driver driver_daqp = {
 
 #ifdef DAQP_DEBUG
 
-static void daqp_dump(comedi_device * dev)
+static void daqp_dump(struct comedi_device * dev)
 {
 	printk("DAQP: status %02x; aux status %02x\n",
 		inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
@@ -234,7 +234,7 @@ static void hex_dump(char *str, void *ptr, int len)
 
 /* Cancel a running acquisition */
 
-static int daqp_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int daqp_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	local_info_t *local = (local_info_t *) s->private;
 
@@ -265,7 +265,7 @@ static int daqp_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 {
 	local_info_t *local = (local_info_t *) dev_id;
-	comedi_device *dev;
+	struct comedi_device *dev;
 	comedi_subdevice *s;
 	int loop_limit = 10000;
 	int status;
@@ -284,7 +284,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 
 	if (!dev->attached) {
 		printk(KERN_WARNING
-			"daqp_interrupt(): comedi_device not yet attached.\n");
+			"daqp_interrupt(): struct comedi_device not yet attached.\n");
 		return;
 	}
 
@@ -361,7 +361,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 
 /* One-shot analog data acquisition routine */
 
-static int daqp_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int daqp_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -467,7 +467,7 @@ static int daqp_ns_to_timer(unsigned int *ns, int round)
  * the command passes.
  */
 
-static int daqp_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int daqp_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -593,7 +593,7 @@ static int daqp_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int daqp_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int daqp_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -793,7 +793,7 @@ static int daqp_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 /* Single-shot analog output routine */
 
-static int daqp_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int daqp_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -820,7 +820,7 @@ static int daqp_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 
 /* Digital input routine */
 
-static int daqp_di_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int daqp_di_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -836,7 +836,7 @@ static int daqp_di_insn_read(comedi_device * dev, comedi_subdevice * s,
 
 /* Digital output routine */
 
-static int daqp_do_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int daqp_do_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
@@ -856,7 +856,7 @@ static int daqp_do_insn_write(comedi_device * dev, comedi_subdevice * s,
  * when it is inserted.
  */
 
-static int daqp_attach(comedi_device * dev, comedi_devconfig * it)
+static int daqp_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int ret;
 	local_info_t *local = dev_table[it->options[0]];
@@ -962,7 +962,7 @@ static int daqp_attach(comedi_device * dev, comedi_devconfig * it)
  * card is removed, daqp_cs_detach() is called by the pcmcia subsystem.
  */
 
-static int daqp_detach(comedi_device * dev)
+static int daqp_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: detaching daqp\n", dev->minor);
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index 04fe5e397b55..ac34c5183c0c 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -313,7 +313,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 		while (!((status = inb(dev->iobase + DAQP_STATUS))
 				& DAQP_STATUS_FIFO_EMPTY)) {
 
-			sampl_t data;
+			short data;
 
 			if (status & DAQP_STATUS_DATA_LOST) {
 				s->async->events |=
@@ -362,7 +362,7 @@ static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
 /* One-shot analog data acquisition routine */
 
 static int daqp_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	int i;
@@ -794,7 +794,7 @@ static int daqp_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 /* Single-shot analog output routine */
 
 static int daqp_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 	int d;
@@ -821,7 +821,7 @@ static int daqp_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 /* Digital input routine */
 
 static int daqp_di_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 
@@ -837,7 +837,7 @@ static int daqp_di_insn_read(comedi_device * dev, comedi_subdevice * s,
 /* Digital output routine */
 
 static int daqp_do_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	local_info_t *local = (local_info_t *) s->private;
 

commit 4dc6b15bce9c0635850a9f5c1a493e09d2e8fe61
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:38 2009 +0100

    Staging: comedi: remove unnecessary #include <linux/version.h>
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ef736ba3fefd..04fe5e397b55 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -49,7 +49,6 @@ Devices: [Quatech] DAQP-208 (daqp), DAQP-308
 
 #include "../comedidev.h"
 
-#include <linux/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>

commit 62ed666238aba1b5199e746299fc079c17794ee2
Author: Brent Baccala <baccala@freesoft.org>
Date:   Tue Feb 17 16:24:32 2009 -0800

    Staging: comedi: add quatech_daqp_cs driver
    
    Driver for Quatech DAQP PCMCIA data capture cards
    
    From: Brent Baccala <baccala@freesoft.org>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
new file mode 100644
index 000000000000..ef736ba3fefd
--- /dev/null
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -0,0 +1,1364 @@
+/*======================================================================
+
+    comedi/drivers/quatech_daqp_cs.c
+
+    Quatech DAQP PCMCIA data capture cards COMEDI client driver
+    Copyright (C) 2000, 2003 Brent Baccala <baccala@freesoft.org>
+    The DAQP interface code in this file is released into the public domain.
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1998 David A. Schleef <ds@schleef.org>
+    http://www.comedi.org/
+
+    quatech_daqp_cs.c 1.10
+
+    Documentation for the DAQP PCMCIA cards can be found on Quatech's site:
+
+                ftp://ftp.quatech.com/Manuals/daqp-208.pdf
+
+    This manual is for both the DAQP-208 and the DAQP-308.
+
+    What works:
+
+	- A/D conversion
+	    - 8 channels
+	    - 4 gain ranges
+	    - ground ref or differential
+	    - single-shot and timed both supported
+	- D/A conversion, single-shot
+	- digital I/O
+
+    What doesn't:
+
+	- any kind of triggering - external or D/A channel 1
+	- the card's optional expansion board
+	- the card's timer (for anything other than A/D conversion)
+	- D/A update modes other than immediate (i.e, timed)
+	- fancier timing modes
+	- setting card's FIFO buffer thresholds to anything but default
+
+======================================================================*/
+
+/*
+Driver: quatech_daqp_cs
+Description: Quatech DAQP PCMCIA data capture cards
+Author: Brent Baccala <baccala@freesoft.org>
+Status: works
+Devices: [Quatech] DAQP-208 (daqp), DAQP-308
+*/
+
+#include "../comedidev.h"
+
+#include <linux/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/cisreg.h>
+#include <pcmcia/ds.h>
+
+/*
+   All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
+   you do not define PCMCIA_DEBUG at all, all the debug code will be
+   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
+   be present but disabled -- but it can then be enabled for specific
+   modules at load time with a 'pc_debug=#' option to insmod.
+*/
+
+#ifdef PCMCIA_DEBUG
+static int pc_debug = PCMCIA_DEBUG;
+module_param(pc_debug, int, 0644);
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
+static char *version = "quatech_daqp_cs.c 1.10 2003/04/21 (Brent Baccala)";
+#else
+#define DEBUG(n, args...)
+#endif
+
+/* Maximum number of separate DAQP devices we'll allow */
+#define MAX_DEV         4
+
+typedef struct local_info_t {
+	struct pcmcia_device *link;
+	dev_node_t node;
+	int stop;
+	int table_index;
+	char board_name[32];
+
+	enum { semaphore, buffer } interrupt_mode;
+
+	struct semaphore eos;
+
+	comedi_device *dev;
+	comedi_subdevice *s;
+	int count;
+} local_info_t;
+
+/* A list of "instances" of the device. */
+
+static local_info_t *dev_table[MAX_DEV] = { NULL, /* ... */  };
+
+/* The DAQP communicates with the system through a 16 byte I/O window. */
+
+#define DAQP_FIFO_SIZE		4096
+
+#define DAQP_FIFO		0
+#define DAQP_SCANLIST		1
+#define DAQP_CONTROL		2
+#define DAQP_STATUS		2
+#define DAQP_DIGITAL_IO		3
+#define DAQP_PACER_LOW		4
+#define DAQP_PACER_MID		5
+#define DAQP_PACER_HIGH		6
+#define DAQP_COMMAND		7
+#define DAQP_DA			8
+#define DAQP_TIMER		10
+#define DAQP_AUX		15
+
+#define DAQP_SCANLIST_DIFFERENTIAL	0x4000
+#define DAQP_SCANLIST_GAIN(x)		((x)<<12)
+#define DAQP_SCANLIST_CHANNEL(x)	((x)<<8)
+#define DAQP_SCANLIST_START		0x0080
+#define DAQP_SCANLIST_EXT_GAIN(x)	((x)<<4)
+#define DAQP_SCANLIST_EXT_CHANNEL(x)	(x)
+
+#define DAQP_CONTROL_PACER_100kHz	0xc0
+#define DAQP_CONTROL_PACER_1MHz		0x80
+#define DAQP_CONTROL_PACER_5MHz		0x40
+#define DAQP_CONTROL_PACER_EXTERNAL	0x00
+#define DAQP_CONTORL_EXPANSION		0x20
+#define DAQP_CONTROL_EOS_INT_ENABLE	0x10
+#define DAQP_CONTROL_FIFO_INT_ENABLE	0x08
+#define DAQP_CONTROL_TRIGGER_ONESHOT	0x00
+#define DAQP_CONTROL_TRIGGER_CONTINUOUS	0x04
+#define DAQP_CONTROL_TRIGGER_INTERNAL	0x00
+#define DAQP_CONTROL_TRIGGER_EXTERNAL	0x02
+#define DAQP_CONTROL_TRIGGER_RISING	0x00
+#define DAQP_CONTROL_TRIGGER_FALLING	0x01
+
+#define DAQP_STATUS_IDLE		0x80
+#define DAQP_STATUS_RUNNING		0x40
+#define DAQP_STATUS_EVENTS		0x38
+#define DAQP_STATUS_DATA_LOST		0x20
+#define DAQP_STATUS_END_OF_SCAN		0x10
+#define DAQP_STATUS_FIFO_THRESHOLD	0x08
+#define DAQP_STATUS_FIFO_FULL		0x04
+#define DAQP_STATUS_FIFO_NEARFULL	0x02
+#define DAQP_STATUS_FIFO_EMPTY		0x01
+
+#define DAQP_COMMAND_ARM		0x80
+#define DAQP_COMMAND_RSTF		0x40
+#define DAQP_COMMAND_RSTQ		0x20
+#define DAQP_COMMAND_STOP		0x10
+#define DAQP_COMMAND_LATCH		0x08
+#define DAQP_COMMAND_100kHz		0x00
+#define DAQP_COMMAND_50kHz		0x02
+#define DAQP_COMMAND_25kHz		0x04
+#define DAQP_COMMAND_FIFO_DATA		0x01
+#define DAQP_COMMAND_FIFO_PROGRAM	0x00
+
+#define DAQP_AUX_TRIGGER_TTL		0x00
+#define DAQP_AUX_TRIGGER_ANALOG		0x80
+#define DAQP_AUX_TRIGGER_PRETRIGGER	0x40
+#define DAQP_AUX_TIMER_INT_ENABLE	0x20
+#define DAQP_AUX_TIMER_RELOAD		0x00
+#define DAQP_AUX_TIMER_PAUSE		0x08
+#define DAQP_AUX_TIMER_GO		0x10
+#define DAQP_AUX_TIMER_GO_EXTERNAL	0x18
+#define DAQP_AUX_TIMER_EXTERNAL_SRC	0x04
+#define DAQP_AUX_TIMER_INTERNAL_SRC	0x00
+#define DAQP_AUX_DA_DIRECT		0x00
+#define DAQP_AUX_DA_OVERFLOW		0x01
+#define DAQP_AUX_DA_EXTERNAL		0x02
+#define DAQP_AUX_DA_PACER		0x03
+
+#define DAQP_AUX_RUNNING		0x80
+#define DAQP_AUX_TRIGGERED		0x40
+#define DAQP_AUX_DA_BUFFER		0x20
+#define DAQP_AUX_TIMER_OVERFLOW		0x10
+#define DAQP_AUX_CONVERSION		0x08
+#define DAQP_AUX_DATA_LOST		0x04
+#define DAQP_AUX_FIFO_NEARFULL		0x02
+#define DAQP_AUX_FIFO_EMPTY		0x01
+
+/* These range structures tell COMEDI how the sample values map to
+ * voltages.  The A/D converter has four ranges: +/- 10V through
+ * +/- 1.25V, and the D/A converter has only one: +/- 5V.
+ */
+
+static const comedi_lrange range_daqp_ai = { 4, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25)
+	}
+};
+
+static const comedi_lrange range_daqp_ao = { 1, {BIP_RANGE(5)} };
+
+/*====================================================================*/
+
+/* comedi interface code */
+
+static int daqp_attach(comedi_device * dev, comedi_devconfig * it);
+static int daqp_detach(comedi_device * dev);
+static comedi_driver driver_daqp = {
+      driver_name:"quatech_daqp_cs",
+      module:THIS_MODULE,
+      attach:daqp_attach,
+      detach:daqp_detach,
+};
+
+#ifdef DAQP_DEBUG
+
+static void daqp_dump(comedi_device * dev)
+{
+	printk("DAQP: status %02x; aux status %02x\n",
+		inb(dev->iobase + DAQP_STATUS), inb(dev->iobase + DAQP_AUX));
+}
+
+static void hex_dump(char *str, void *ptr, int len)
+{
+	unsigned char *cptr = ptr;
+	int i;
+
+	printk(str);
+
+	for (i = 0; i < len; i++) {
+		if (i % 16 == 0) {
+			printk("\n0x%08x:", (unsigned int)cptr);
+		}
+		printk(" %02x", *(cptr++));
+	}
+	printk("\n");
+}
+
+#endif
+
+/* Cancel a running acquisition */
+
+static int daqp_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	local_info_t *local = (local_info_t *) s->private;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	outb(DAQP_COMMAND_STOP, dev->iobase + DAQP_COMMAND);
+
+	/* flush any linguring data in FIFO - superfluous here */
+	/* outb(DAQP_COMMAND_RSTF, dev->iobase+DAQP_COMMAND); */
+
+	local->interrupt_mode = semaphore;
+
+	return 0;
+}
+
+/* Interrupt handler
+ *
+ * Operates in one of two modes.  If local->interrupt_mode is
+ * 'semaphore', just signal the local->eos semaphore and return
+ * (one-shot mode).  Otherwise (continuous mode), read data in from
+ * the card, transfer it to the buffer provided by the higher-level
+ * comedi kernel module, and signal various comedi callback routines,
+ * which run pretty quick.
+ */
+
+static void daqp_interrupt(int irq, void *dev_id PT_REGS_ARG)
+{
+	local_info_t *local = (local_info_t *) dev_id;
+	comedi_device *dev;
+	comedi_subdevice *s;
+	int loop_limit = 10000;
+	int status;
+
+	if (local == NULL) {
+		printk(KERN_WARNING
+			"daqp_interrupt(): irq %d for unknown device.\n", irq);
+		return;
+	}
+
+	dev = local->dev;
+	if (dev == NULL) {
+		printk(KERN_WARNING "daqp_interrupt(): NULL comedi_device.\n");
+		return;
+	}
+
+	if (!dev->attached) {
+		printk(KERN_WARNING
+			"daqp_interrupt(): comedi_device not yet attached.\n");
+		return;
+	}
+
+	s = local->s;
+	if (s == NULL) {
+		printk(KERN_WARNING
+			"daqp_interrupt(): NULL comedi_subdevice.\n");
+		return;
+	}
+
+	if ((local_info_t *) s->private != local) {
+		printk(KERN_WARNING
+			"daqp_interrupt(): invalid comedi_subdevice.\n");
+		return;
+	}
+
+	switch (local->interrupt_mode) {
+
+	case semaphore:
+
+		up(&local->eos);
+		break;
+
+	case buffer:
+
+		while (!((status = inb(dev->iobase + DAQP_STATUS))
+				& DAQP_STATUS_FIFO_EMPTY)) {
+
+			sampl_t data;
+
+			if (status & DAQP_STATUS_DATA_LOST) {
+				s->async->events |=
+					COMEDI_CB_EOA | COMEDI_CB_OVERFLOW;
+				printk("daqp: data lost\n");
+				daqp_ai_cancel(dev, s);
+				break;
+			}
+
+			data = inb(dev->iobase + DAQP_FIFO);
+			data |= inb(dev->iobase + DAQP_FIFO) << 8;
+			data ^= 0x8000;
+
+			comedi_buf_put(s->async, data);
+
+			/* If there's a limit, decrement it
+			 * and stop conversion if zero
+			 */
+
+			if (local->count > 0) {
+				local->count--;
+				if (local->count == 0) {
+					daqp_ai_cancel(dev, s);
+					s->async->events |= COMEDI_CB_EOA;
+					break;
+				}
+			}
+
+			if ((loop_limit--) <= 0)
+				break;
+		}
+
+		if (loop_limit <= 0) {
+			printk(KERN_WARNING
+				"loop_limit reached in daqp_interrupt()\n");
+			daqp_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		}
+
+		s->async->events |= COMEDI_CB_BLOCK;
+
+		comedi_event(dev, s);
+	}
+}
+
+/* One-shot analog data acquisition routine */
+
+static int daqp_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	local_info_t *local = (local_info_t *) s->private;
+	int i;
+	int v;
+	int counter = 10000;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	/* Stop any running conversion */
+	daqp_ai_cancel(dev, s);
+
+	outb(0, dev->iobase + DAQP_AUX);
+
+	/* Reset scan list queue */
+	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_COMMAND);
+
+	/* Program one scan list entry */
+
+	v = DAQP_SCANLIST_CHANNEL(CR_CHAN(insn->chanspec))
+		| DAQP_SCANLIST_GAIN(CR_RANGE(insn->chanspec));
+
+	if (CR_AREF(insn->chanspec) == AREF_DIFF) {
+		v |= DAQP_SCANLIST_DIFFERENTIAL;
+	}
+
+	v |= DAQP_SCANLIST_START;
+
+	outb(v & 0xff, dev->iobase + DAQP_SCANLIST);
+	outb(v >> 8, dev->iobase + DAQP_SCANLIST);
+
+	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
+
+	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_COMMAND);
+
+	/* Set trigger */
+
+	v = DAQP_CONTROL_TRIGGER_ONESHOT | DAQP_CONTROL_TRIGGER_INTERNAL
+		| DAQP_CONTROL_PACER_100kHz | DAQP_CONTROL_EOS_INT_ENABLE;
+
+	outb(v, dev->iobase + DAQP_CONTROL);
+
+	/* Reset any pending interrupts (my card has a tendancy to require
+	 * require multiple reads on the status register to achieve this)
+	 */
+
+	while (--counter
+		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	if (!counter) {
+		printk("daqp: couldn't clear interrupts in status register\n");
+		return -1;
+	}
+
+	/* Make sure semaphore is blocked */
+	sema_init(&local->eos, 0);
+	local->interrupt_mode = semaphore;
+	local->dev = dev;
+	local->s = s;
+
+	for (i = 0; i < insn->n; i++) {
+
+		/* Start conversion */
+		outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
+			dev->iobase + DAQP_COMMAND);
+
+		/* Wait for interrupt service routine to unblock semaphore */
+		/* Maybe could use a timeout here, but it's interruptible */
+		if (down_interruptible(&local->eos))
+			return -EINTR;
+
+		data[i] = inb(dev->iobase + DAQP_FIFO);
+		data[i] |= inb(dev->iobase + DAQP_FIFO) << 8;
+		data[i] ^= 0x8000;
+	}
+
+	return insn->n;
+}
+
+/* This function converts ns nanoseconds to a counter value suitable
+ * for programming the device.  We always use the DAQP's 5 MHz clock,
+ * which with its 24-bit counter, allows values up to 84 seconds.
+ * Also, the function adjusts ns so that it cooresponds to the actual
+ * time that the device will use.
+ */
+
+static int daqp_ns_to_timer(unsigned int *ns, int round)
+{
+	int timer;
+
+	timer = *ns / 200;
+	*ns = timer * 200;
+
+	return timer;
+}
+
+/* cmdtest tests a particular command to see if it is valid.
+ * Using the cmdtest ioctl, a user can create a valid cmd
+ * and then have it executed by the cmd ioctl.
+ *
+ * cmdtest returns 1,2,3,4 or 0, depending on which tests
+ * the command passes.
+ */
+
+static int daqp_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+	if (cmd->convert_src != TRIG_NOW && cmd->convert_src != TRIG_TIMER)
+		err++;
+	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+#define MAX_SPEED	10000	/* 100 kHz - in nanoseconds */
+
+	if (cmd->scan_begin_src == TRIG_TIMER
+		&& cmd->scan_begin_arg < MAX_SPEED) {
+		cmd->scan_begin_arg = MAX_SPEED;
+		err++;
+	}
+
+	/* If both scan_begin and convert are both timer values, the only
+	 * way that can make sense is if the scan time is the number of
+	 * conversions times the convert time
+	 */
+
+	if (cmd->scan_begin_src == TRIG_TIMER && cmd->convert_src == TRIG_TIMER
+		&& cmd->scan_begin_arg !=
+		cmd->convert_arg * cmd->scan_end_arg) {
+		err++;
+	}
+
+	if (cmd->convert_src == TRIG_TIMER && cmd->convert_arg < MAX_SPEED) {
+		cmd->convert_arg = MAX_SPEED;
+		err++;
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (cmd->stop_arg > 0x00ffffff) {
+			cmd->stop_arg = 0x00ffffff;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		daqp_ns_to_timer(&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		daqp_ns_to_timer(&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+static int daqp_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	local_info_t *local = (local_info_t *) s->private;
+	comedi_cmd *cmd = &s->async->cmd;
+	int counter = 100;
+	int scanlist_start_on_every_entry;
+	int threshold;
+
+	int i;
+	int v;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	/* Stop any running conversion */
+	daqp_ai_cancel(dev, s);
+
+	outb(0, dev->iobase + DAQP_AUX);
+
+	/* Reset scan list queue */
+	outb(DAQP_COMMAND_RSTQ, dev->iobase + DAQP_COMMAND);
+
+	/* Program pacer clock
+	 *
+	 * There's two modes we can operate in.  If convert_src is
+	 * TRIG_TIMER, then convert_arg specifies the time between
+	 * each conversion, so we program the pacer clock to that
+	 * frequency and set the SCANLIST_START bit on every scanlist
+	 * entry.  Otherwise, convert_src is TRIG_NOW, which means
+	 * we want the fastest possible conversions, scan_begin_src
+	 * is TRIG_TIMER, and scan_begin_arg specifies the time between
+	 * each scan, so we program the pacer clock to this frequency
+	 * and only set the SCANLIST_START bit on the first entry.
+	 */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		int counter = daqp_ns_to_timer(&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
+		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
+		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
+		scanlist_start_on_every_entry = 1;
+	} else {
+		int counter = daqp_ns_to_timer(&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		outb(counter & 0xff, dev->iobase + DAQP_PACER_LOW);
+		outb((counter >> 8) & 0xff, dev->iobase + DAQP_PACER_MID);
+		outb((counter >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH);
+		scanlist_start_on_every_entry = 0;
+	}
+
+	/* Program scan list */
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+
+		int chanspec = cmd->chanlist[i];
+
+		/* Program one scan list entry */
+
+		v = DAQP_SCANLIST_CHANNEL(CR_CHAN(chanspec))
+			| DAQP_SCANLIST_GAIN(CR_RANGE(chanspec));
+
+		if (CR_AREF(chanspec) == AREF_DIFF) {
+			v |= DAQP_SCANLIST_DIFFERENTIAL;
+		}
+
+		if (i == 0 || scanlist_start_on_every_entry) {
+			v |= DAQP_SCANLIST_START;
+		}
+
+		outb(v & 0xff, dev->iobase + DAQP_SCANLIST);
+		outb(v >> 8, dev->iobase + DAQP_SCANLIST);
+	}
+
+	/* Now it's time to program the FIFO threshold, basically the
+	 * number of samples the card will buffer before it interrupts
+	 * the CPU.
+	 *
+	 * If we don't have a stop count, then use half the size of
+	 * the FIFO (the manufacturer's recommendation).  Consider
+	 * that the FIFO can hold 2K samples (4K bytes).  With the
+	 * threshold set at half the FIFO size, we have a margin of
+	 * error of 1024 samples.  At the chip's maximum sample rate
+	 * of 100,000 Hz, the CPU would have to delay interrupt
+	 * service for a full 10 milliseconds in order to lose data
+	 * here (as opposed to higher up in the kernel).  I've never
+	 * seen it happen.  However, for slow sample rates it may
+	 * buffer too much data and introduce too much delay for the
+	 * user application.
+	 *
+	 * If we have a stop count, then things get more interesting.
+	 * If the stop count is less than the FIFO size (actually
+	 * three-quarters of the FIFO size - see below), we just use
+	 * the stop count itself as the threshold, the card interrupts
+	 * us when that many samples have been taken, and we kill the
+	 * acquisition at that point and are done.  If the stop count
+	 * is larger than that, then we divide it by 2 until it's less
+	 * than three quarters of the FIFO size (we always leave the
+	 * top quarter of the FIFO as protection against sluggish CPU
+	 * interrupt response) and use that as the threshold.  So, if
+	 * the stop count is 4000 samples, we divide by two twice to
+	 * get 1000 samples, use that as the threshold, take four
+	 * interrupts to get our 4000 samples and are done.
+	 *
+	 * The algorithm could be more clever.  For example, if 81000
+	 * samples are requested, we could set the threshold to 1500
+	 * samples and take 54 interrupts to get 81000.  But 54 isn't
+	 * a power of two, so this algorithm won't find that option.
+	 * Instead, it'll set the threshold at 1266 and take 64
+	 * interrupts to get 81024 samples, of which the last 24 will
+	 * be discarded... but we won't get the last interrupt until
+	 * they've been collected.  To find the first option, the
+	 * computer could look at the prime decomposition of the
+	 * sample count (81000 = 3^4 * 5^3 * 2^3) and factor it into a
+	 * threshold (1500 = 3 * 5^3 * 2^2) and an interrupt count (54
+	 * = 3^3 * 2).  Hmmm... a one-line while loop or prime
+	 * decomposition of integers... I'll leave it the way it is.
+	 *
+	 * I'll also note a mini-race condition before ignoring it in
+	 * the code.  Let's say we're taking 4000 samples, as before.
+	 * After 1000 samples, we get an interrupt.  But before that
+	 * interrupt is completely serviced, another sample is taken
+	 * and loaded into the FIFO.  Since the interrupt handler
+	 * empties the FIFO before returning, it will read 1001 samples.
+	 * If that happens four times, we'll end up taking 4004 samples,
+	 * not 4000.  The interrupt handler will discard the extra four
+	 * samples (by halting the acquisition with four samples still
+	 * in the FIFO), but we will have to wait for them.
+	 *
+	 * In short, this code works pretty well, but for either of
+	 * the two reasons noted, might end up waiting for a few more
+	 * samples than actually requested.  Shouldn't make too much
+	 * of a difference.
+	 */
+
+	/* Save away the number of conversions we should perform, and
+	 * compute the FIFO threshold (in bytes, not samples - that's
+	 * why we multiple local->count by 2 = sizeof(sample))
+	 */
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		local->count = cmd->stop_arg * cmd->scan_end_arg;
+		threshold = 2 * local->count;
+		while (threshold > DAQP_FIFO_SIZE * 3 / 4)
+			threshold /= 2;
+	} else {
+		local->count = -1;
+		threshold = DAQP_FIFO_SIZE / 2;
+	}
+
+	/* Reset data FIFO (see page 28 of DAQP User's Manual) */
+
+	outb(DAQP_COMMAND_RSTF, dev->iobase + DAQP_COMMAND);
+
+	/* Set FIFO threshold.  First two bytes are near-empty
+	 * threshold, which is unused; next two bytes are near-full
+	 * threshold.  We computed the number of bytes we want in the
+	 * FIFO when the interrupt is generated, what the card wants
+	 * is actually the number of available bytes left in the FIFO
+	 * when the interrupt is to happen.
+	 */
+
+	outb(0x00, dev->iobase + DAQP_FIFO);
+	outb(0x00, dev->iobase + DAQP_FIFO);
+
+	outb((DAQP_FIFO_SIZE - threshold) & 0xff, dev->iobase + DAQP_FIFO);
+	outb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_FIFO);
+
+	/* Set trigger */
+
+	v = DAQP_CONTROL_TRIGGER_CONTINUOUS | DAQP_CONTROL_TRIGGER_INTERNAL
+		| DAQP_CONTROL_PACER_5MHz | DAQP_CONTROL_FIFO_INT_ENABLE;
+
+	outb(v, dev->iobase + DAQP_CONTROL);
+
+	/* Reset any pending interrupts (my card has a tendancy to require
+	 * require multiple reads on the status register to achieve this)
+	 */
+
+	while (--counter
+		&& (inb(dev->iobase + DAQP_STATUS) & DAQP_STATUS_EVENTS)) ;
+	if (!counter) {
+		printk("daqp: couldn't clear interrupts in status register\n");
+		return -1;
+	}
+
+	local->interrupt_mode = buffer;
+	local->dev = dev;
+	local->s = s;
+
+	/* Start conversion */
+	outb(DAQP_COMMAND_ARM | DAQP_COMMAND_FIFO_DATA,
+		dev->iobase + DAQP_COMMAND);
+
+	return 0;
+}
+
+/* Single-shot analog output routine */
+
+static int daqp_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	local_info_t *local = (local_info_t *) s->private;
+	int d;
+	unsigned int chan;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	chan = CR_CHAN(insn->chanspec);
+	d = data[0];
+	d &= 0x0fff;
+	d ^= 0x0800;		/* Flip the sign */
+	d |= chan << 12;
+
+	/* Make sure D/A update mode is direct update */
+	outb(0, dev->iobase + DAQP_AUX);
+
+	outw(d, dev->iobase + DAQP_DA);
+
+	return 1;
+}
+
+/* Digital input routine */
+
+static int daqp_di_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	local_info_t *local = (local_info_t *) s->private;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	data[0] = inb(dev->iobase + DAQP_DIGITAL_IO);
+
+	return 1;
+}
+
+/* Digital output routine */
+
+static int daqp_do_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	local_info_t *local = (local_info_t *) s->private;
+
+	if (local->stop) {
+		return -EIO;
+	}
+
+	outw(data[0] & 0xf, dev->iobase + DAQP_DIGITAL_IO);
+
+	return 1;
+}
+
+/* daqp_attach is called via comedi_config to attach a comedi device
+ * to a /dev/comedi*.  Note that this is different from daqp_cs_attach()
+ * which is called by the pcmcia subsystem to attach the PCMCIA card
+ * when it is inserted.
+ */
+
+static int daqp_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	local_info_t *local = dev_table[it->options[0]];
+	tuple_t tuple;
+	int i;
+	comedi_subdevice *s;
+
+	if (it->options[0] < 0 || it->options[0] >= MAX_DEV || !local) {
+		printk("comedi%d: No such daqp device %d\n",
+			dev->minor, it->options[0]);
+		return -EIO;
+	}
+
+	/* Typically brittle code that I don't completely understand,
+	 * but "it works on my card".  The intent is to pull the model
+	 * number of the card out the PCMCIA CIS and stash it away as
+	 * the COMEDI board_name.  Looks like the third field in
+	 * CISTPL_VERS_1 (offset 2) holds what we're looking for.  If
+	 * it doesn't work, who cares, just leave it as "DAQP".
+	 */
+
+	strcpy(local->board_name, "DAQP");
+	dev->board_name = local->board_name;
+
+	tuple.DesiredTuple = CISTPL_VERS_1;
+	if (pcmcia_get_first_tuple(local->link, &tuple) == 0) {
+		u_char buf[128];
+
+		buf[0] = buf[sizeof(buf) - 1] = 0;
+		tuple.TupleData = buf;
+		tuple.TupleDataMax = sizeof(buf);
+		tuple.TupleOffset = 2;
+		if (pcmcia_get_tuple_data(local->link, &tuple) == 0) {
+
+			for (i = 0; i < tuple.TupleDataLen - 4; i++)
+				if (buf[i] == 0)
+					break;
+			for (i++; i < tuple.TupleDataLen - 4; i++)
+				if (buf[i] == 0)
+					break;
+			i++;
+			if ((i < tuple.TupleDataLen - 4)
+				&& (strncmp(buf + i, "DAQP", 4) == 0)) {
+				strncpy(local->board_name, buf + i,
+					sizeof(local->board_name));
+			}
+		}
+	}
+
+	dev->iobase = local->link->io.BasePort1;
+
+	if ((ret = alloc_subdevices(dev, 4)) < 0)
+		return ret;
+
+	printk("comedi%d: attaching daqp%d (io 0x%04lx)\n",
+		dev->minor, it->options[0], dev->iobase);
+
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->private = local;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = 8;
+	s->len_chanlist = 2048;
+	s->maxdata = 0xffff;
+	s->range_table = &range_daqp_ai;
+	s->insn_read = daqp_ai_insn_read;
+	s->do_cmdtest = daqp_ai_cmdtest;
+	s->do_cmd = daqp_ai_cmd;
+	s->cancel = daqp_ai_cancel;
+
+	s = dev->subdevices + 1;
+	dev->write_subdev = s;
+	s->private = local;
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITEABLE;
+	s->n_chan = 2;
+	s->len_chanlist = 1;
+	s->maxdata = 0x0fff;
+	s->range_table = &range_daqp_ao;
+	s->insn_write = daqp_ao_insn_write;
+
+	s = dev->subdevices + 2;
+	s->private = local;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 1;
+	s->len_chanlist = 1;
+	s->insn_read = daqp_di_insn_read;
+
+	s = dev->subdevices + 3;
+	s->private = local;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITEABLE;
+	s->n_chan = 1;
+	s->len_chanlist = 1;
+	s->insn_write = daqp_do_insn_write;
+
+	return 1;
+}
+
+/* daqp_detach (called from comedi_comdig) does nothing. If the PCMCIA
+ * card is removed, daqp_cs_detach() is called by the pcmcia subsystem.
+ */
+
+static int daqp_detach(comedi_device * dev)
+{
+	printk("comedi%d: detaching daqp\n", dev->minor);
+
+	return 0;
+}
+
+/*====================================================================
+
+    PCMCIA interface code
+
+    The rest of the code in this file is based on dummy_cs.c v1.24
+    from the Linux pcmcia_cs distribution v3.1.8 and is subject
+    to the following license agreement.
+
+    The remaining contents of this file are subject to the Mozilla Public
+    License Version 1.1 (the "License"); you may not use this file
+    except in compliance with the License. You may obtain a copy of
+    the License at http://www.mozilla.org/MPL/
+
+    Software distributed under the License is distributed on an "AS
+    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+    implied. See the License for the specific language governing
+    rights and limitations under the License.
+
+    The initial developer of the original code is David A. Hinds
+    <dhinds@pcmcia.sourceforge.org>.  Portions created by David A. Hinds
+    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+
+    Alternatively, the contents of this file may be used under the
+    terms of the GNU Public License version 2 (the "GPL"), in which
+    case the provisions of the GPL are applicable instead of the
+    above.  If you wish to allow the use of your version of this file
+    only under the terms of the GPL and not to allow others to use
+    your version of this file under the MPL, indicate your decision
+    by deleting the provisions above and replace them with the notice
+    and other provisions required by the GPL.  If you do not delete
+    the provisions above, a recipient may use your version of this
+    file under either the MPL or the GPL.
+
+======================================================================*/
+
+/*
+   The event() function is this driver's Card Services event handler.
+   It will be called by Card Services when an appropriate card status
+   event is received.  The config() and release() entry points are
+   used to configure or release a socket, in response to card
+   insertion and ejection events.
+
+   Kernel version 2.6.16 upwards uses suspend() and resume() functions
+   instead of an event() function.
+*/
+
+static void daqp_cs_config(struct pcmcia_device *link);
+static void daqp_cs_release(struct pcmcia_device *link);
+static int daqp_cs_suspend(struct pcmcia_device *p_dev);
+static int daqp_cs_resume(struct pcmcia_device *p_dev);
+
+/*
+   The attach() and detach() entry points are used to create and destroy
+   "instances" of the driver, where each instance represents everything
+   needed to manage one actual PCMCIA card.
+*/
+
+static int daqp_cs_attach(struct pcmcia_device *);
+static void daqp_cs_detach(struct pcmcia_device *);
+
+/*
+   The dev_info variable is the "key" that is used to match up this
+   device driver with appropriate cards, through the card configuration
+   database.
+*/
+
+static const dev_info_t dev_info = "quatech_daqp_cs";
+
+/*======================================================================
+
+    daqp_cs_attach() creates an "instance" of the driver, allocating
+    local data structures for one device.  The device is registered
+    with Card Services.
+
+    The dev_link structure is initialized, but we don't actually
+    configure the card at this point -- we wait until we receive a
+    card insertion event.
+
+======================================================================*/
+
+static int daqp_cs_attach(struct pcmcia_device *link)
+{
+	local_info_t *local;
+	int i;
+
+	DEBUG(0, "daqp_cs_attach()\n");
+
+	for (i = 0; i < MAX_DEV; i++)
+		if (dev_table[i] == NULL)
+			break;
+	if (i == MAX_DEV) {
+		printk(KERN_NOTICE "daqp_cs: no devices available\n");
+		return -ENODEV;
+	}
+
+	/* Allocate space for private device-specific data */
+	local = kzalloc(sizeof(local_info_t), GFP_KERNEL);
+	if (!local)
+		return -ENOMEM;
+
+	local->table_index = i;
+	dev_table[i] = local;
+	local->link = link;
+	link->priv = local;
+
+	/* Interrupt setup */
+	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	link->irq.Handler = daqp_interrupt;
+	link->irq.Instance = local;
+
+	/*
+	   General socket configuration defaults can go here.  In this
+	   client, we assume very little, and rely on the CIS for almost
+	   everything.  In most clients, many details (i.e., number, sizes,
+	   and attributes of IO windows) are fixed by the nature of the
+	   device, and can be hard-wired here.
+	 */
+	link->conf.Attributes = 0;
+	link->conf.IntType = INT_MEMORY_AND_IO;
+
+	daqp_cs_config(link);
+
+	return 0;
+}				/* daqp_cs_attach */
+
+/*======================================================================
+
+    This deletes a driver "instance".  The device is de-registered
+    with Card Services.  If it has been released, all local data
+    structures are freed.  Otherwise, the structures will be freed
+    when the device is released.
+
+======================================================================*/
+
+static void daqp_cs_detach(struct pcmcia_device *link)
+{
+	local_info_t *dev = link->priv;
+
+	DEBUG(0, "daqp_cs_detach(0x%p)\n", link);
+
+	if (link->dev_node) {
+		dev->stop = 1;
+		daqp_cs_release(link);
+	}
+
+	/* Unlink device structure, and free it */
+	dev_table[dev->table_index] = NULL;
+	if (dev)
+		kfree(dev);
+
+}				/* daqp_cs_detach */
+
+/*======================================================================
+
+    daqp_cs_config() is scheduled to run after a CARD_INSERTION event
+    is received, to configure the PCMCIA socket, and to make the
+    device available to the system.
+
+======================================================================*/
+
+static void daqp_cs_config(struct pcmcia_device *link)
+{
+	local_info_t *dev = link->priv;
+	tuple_t tuple;
+	cisparse_t parse;
+	int last_ret;
+	u_char buf[64];
+
+	DEBUG(0, "daqp_cs_config(0x%p)\n", link);
+
+	/*
+	   This reads the card's CONFIG tuple to find its configuration
+	   registers.
+	 */
+	tuple.DesiredTuple = CISTPL_CONFIG;
+	tuple.Attributes = 0;
+	tuple.TupleData = buf;
+	tuple.TupleDataMax = sizeof(buf);
+	tuple.TupleOffset = 0;
+	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+		cs_error(link, GetFirstTuple, last_ret);
+		goto cs_failed;
+	}
+	if ((last_ret = pcmcia_get_tuple_data(link, &tuple))) {
+		cs_error(link, GetTupleData, last_ret);
+		goto cs_failed;
+	}
+	if ((last_ret = pcmcia_parse_tuple(&tuple, &parse))) {
+		cs_error(link, ParseTuple, last_ret);
+		goto cs_failed;
+	}
+	link->conf.ConfigBase = parse.config.base;
+	link->conf.Present = parse.config.rmask[0];
+
+	/*
+	   In this loop, we scan the CIS for configuration table entries,
+	   each of which describes a valid card configuration, including
+	   voltage, IO window, memory window, and interrupt settings.
+
+	   We make no assumptions about the card to be configured: we use
+	   just the information available in the CIS.  In an ideal world,
+	   this would work for any PCMCIA card, but it requires a complete
+	   and accurate CIS.  In practice, a driver usually "knows" most of
+	   these things without consulting the CIS, and most client drivers
+	   will only use the CIS to fill in implementation-defined details.
+	 */
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	if ((last_ret = pcmcia_get_first_tuple(link, &tuple))) {
+		cs_error(link, GetFirstTuple, last_ret);
+		goto cs_failed;
+	}
+	while (1) {
+		cistpl_cftable_entry_t dflt = { 0 };
+		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
+		if (pcmcia_get_tuple_data(link, &tuple))
+			goto next_entry;
+		if (pcmcia_parse_tuple(&tuple, &parse))
+			goto next_entry;
+
+		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+			dflt = *cfg;
+		if (cfg->index == 0)
+			goto next_entry;
+		link->conf.ConfigIndex = cfg->index;
+
+		/* Do we need to allocate an interrupt? */
+		if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1)
+			link->conf.Attributes |= CONF_ENABLE_IRQ;
+
+		/* IO window settings */
+		link->io.NumPorts1 = link->io.NumPorts2 = 0;
+		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
+			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
+			link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io->flags & CISTPL_IO_8BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io->flags & CISTPL_IO_16BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			link->io.IOAddrLines = io->flags & CISTPL_IO_LINES_MASK;
+			link->io.BasePort1 = io->win[0].base;
+			link->io.NumPorts1 = io->win[0].len;
+			if (io->nwin > 1) {
+				link->io.Attributes2 = link->io.Attributes1;
+				link->io.BasePort2 = io->win[1].base;
+				link->io.NumPorts2 = io->win[1].len;
+			}
+		}
+
+		/* This reserves IO space but doesn't actually enable it */
+		if (pcmcia_request_io(link, &link->io))
+			goto next_entry;
+
+		/* If we got this far, we're cool! */
+		break;
+
+	      next_entry:
+		if ((last_ret = pcmcia_get_next_tuple(link, &tuple))) {
+			cs_error(link, GetNextTuple, last_ret);
+			goto cs_failed;
+		}
+	}
+
+	/*
+	   Allocate an interrupt line.  Note that this does not assign a
+	   handler to the interrupt, unless the 'Handler' member of the
+	   irq structure is initialized.
+	 */
+	if (link->conf.Attributes & CONF_ENABLE_IRQ)
+		if ((last_ret = pcmcia_request_irq(link, &link->irq))) {
+			cs_error(link, RequestIRQ, last_ret);
+			goto cs_failed;
+		}
+
+	/*
+	   This actually configures the PCMCIA socket -- setting up
+	   the I/O windows and the interrupt mapping, and putting the
+	   card and host interface into "Memory and IO" mode.
+	 */
+	if ((last_ret = pcmcia_request_configuration(link, &link->conf))) {
+		cs_error(link, RequestConfiguration, last_ret);
+		goto cs_failed;
+	}
+
+	/*
+	   At this point, the dev_node_t structure(s) need to be
+	   initialized and arranged in a linked list at link->dev.
+	 */
+	/* Comedi's PCMCIA script uses this device name (extracted
+	 * from /var/lib/pcmcia/stab) to pass to comedi_config
+	 */
+	/* sprintf(dev->node.dev_name, "daqp%d", dev->table_index); */
+	sprintf(dev->node.dev_name, "quatech_daqp_cs");
+	dev->node.major = dev->node.minor = 0;
+	link->dev_node = &dev->node;
+
+	/* Finally, report what we've done */
+	printk(KERN_INFO "%s: index 0x%02x",
+		dev->node.dev_name, link->conf.ConfigIndex);
+	if (link->conf.Attributes & CONF_ENABLE_IRQ)
+		printk(", irq %u", link->irq.AssignedIRQ);
+	if (link->io.NumPorts1)
+		printk(", io 0x%04x-0x%04x", link->io.BasePort1,
+			link->io.BasePort1 + link->io.NumPorts1 - 1);
+	if (link->io.NumPorts2)
+		printk(" & 0x%04x-0x%04x", link->io.BasePort2,
+			link->io.BasePort2 + link->io.NumPorts2 - 1);
+	printk("\n");
+
+	return;
+
+      cs_failed:
+	daqp_cs_release(link);
+
+}				/* daqp_cs_config */
+
+static void daqp_cs_release(struct pcmcia_device *link)
+{
+	DEBUG(0, "daqp_cs_release(0x%p)\n", link);
+
+	pcmcia_disable_device(link);
+}				/* daqp_cs_release */
+
+/*======================================================================
+
+    The card status event handler.  Mostly, this schedules other
+    stuff to run after an event is received.
+
+    When a CARD_REMOVAL event is received, we immediately set a
+    private flag to block future accesses to this device.  All the
+    functions that actually access the device should check this flag
+    to make sure the card is still present.
+
+======================================================================*/
+
+static int daqp_cs_suspend(struct pcmcia_device *link)
+{
+	local_info_t *local = link->priv;
+
+	/* Mark the device as stopped, to block IO until later */
+	local->stop = 1;
+	return 0;
+}
+
+static int daqp_cs_resume(struct pcmcia_device *link)
+{
+	local_info_t *local = link->priv;
+
+	local->stop = 0;
+
+	return 0;
+}
+
+/*====================================================================*/
+
+#ifdef MODULE
+
+static struct pcmcia_device_id daqp_cs_id_table[] = {
+	PCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),
+	PCMCIA_DEVICE_NULL
+};
+
+MODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);
+
+struct pcmcia_driver daqp_cs_driver = {
+	.probe = daqp_cs_attach,
+	.remove = daqp_cs_detach,
+	.suspend = daqp_cs_suspend,
+	.resume = daqp_cs_resume,
+	.id_table = daqp_cs_id_table,
+	.owner = THIS_MODULE,
+	.drv = {
+			.name = dev_info,
+		},
+};
+
+int __init init_module(void)
+{
+	DEBUG(0, "%s\n", version);
+	pcmcia_register_driver(&daqp_cs_driver);
+	comedi_driver_register(&driver_daqp);
+	return 0;
+}
+
+void __exit cleanup_module(void)
+{
+	DEBUG(0, "daqp_cs: unloading\n");
+	comedi_driver_unregister(&driver_daqp);
+	pcmcia_unregister_driver(&daqp_cs_driver);
+}
+
+#endif
