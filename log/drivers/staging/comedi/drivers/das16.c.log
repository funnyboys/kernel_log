commit 471c3615e5633a37db1aab44e81ae7c770a8b64c
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Mon Mar 5 09:58:08 2018 +0530

    staging: comedi: Replace "dont" with "don't
    
    Replace "dont" with "don't".
    "Dont" is not same as "Do not" or "Don't".
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 74ff204b585d..81eb51b1be25 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -619,7 +619,7 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 2b : and mutually compatible */
 
-	/*  make sure scan_begin_src and convert_src dont conflict */
+	/*  make sure scan_begin_src and convert_src don't conflict */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
 		err |= -EINVAL;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 40c514ae0ecd..74ff204b585d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -7,16 +7,6 @@
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
  * Copyright (C) 2000 Chris R. Baugher <baugher@enteract.com>
  * Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index ddd4aeab6365..40c514ae0ecd 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * das16.c
  * DAS16 driver

commit e44d4907f8b0f54d3aa0d057302f95df804aa171
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:25:03 2017 -0700

    staging/comedi: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer
    to all timer callbacks, switch to using the new timer_setup() and
    from_timer() to pass the timer pointer explicitly. Adds pointer back to
    comedi device from private struct.
    
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2b2a446af3f5..ddd4aeab6365 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -440,6 +440,7 @@ static inline int timer_period(void)
 
 struct das16_private_struct {
 	struct comedi_isadma	*dma;
+	struct comedi_device	*dev;
 	unsigned int		clockbase;
 	unsigned int		ctrl_reg;
 	unsigned int		divisor1;
@@ -525,10 +526,10 @@ static void das16_interrupt(struct comedi_device *dev)
 	comedi_handle_events(dev, s);
 }
 
-static void das16_timer_interrupt(unsigned long arg)
+static void das16_timer_interrupt(struct timer_list *t)
 {
-	struct comedi_device *dev = (struct comedi_device *)arg;
-	struct das16_private_struct *devpriv = dev->private;
+	struct das16_private_struct *devpriv = from_timer(devpriv, t, timer);
+	struct comedi_device *dev = devpriv->dev;
 	unsigned long flags;
 
 	das16_interrupt(dev);
@@ -934,8 +935,7 @@ static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct das16_private_struct *devpriv = dev->private;
 
-	setup_timer(&devpriv->timer, das16_timer_interrupt,
-		    (unsigned long)dev);
+	timer_setup(&devpriv->timer, das16_timer_interrupt, 0);
 
 	/* only DMA channels 3 and 1 are valid */
 	if (!(dma_chan == 1 || dma_chan == 3))
@@ -1044,6 +1044,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
+	devpriv->dev = dev;
 
 	if (board->size < 0x400) {
 		ret = comedi_request_region(dev, it->options[0], board->size);

commit 1c937c1390cc1ca95032e56b4ec8c4e32e54debe
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Sep 20 16:27:50 2017 -0700

    staging/comedi/das16: Make timer initialization unconditional
    
    With timer initialization made unconditional, there is no reason to
    make del_timer_sync() calls conditionally, there by removing the test
    of the .data field.
    
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 5d157951f63f..2b2a446af3f5 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -934,6 +934,9 @@ static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct das16_private_struct *devpriv = dev->private;
 
+	setup_timer(&devpriv->timer, das16_timer_interrupt,
+		    (unsigned long)dev);
+
 	/* only DMA channels 3 and 1 are valid */
 	if (!(dma_chan == 1 || dma_chan == 3))
 		return;
@@ -941,10 +944,6 @@ static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	/* DMA uses two buffers */
 	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,
 					   DAS16_DMA_SIZE, COMEDI_ISADMA_READ);
-	if (devpriv->dma) {
-		setup_timer(&devpriv->timer, das16_timer_interrupt,
-			    (unsigned long)dev);
-	}
 }
 
 static void das16_free_dma(struct comedi_device *dev)
@@ -952,8 +951,7 @@ static void das16_free_dma(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 
 	if (devpriv) {
-		if (devpriv->timer.data)
-			del_timer_sync(&devpriv->timer);
+		del_timer_sync(&devpriv->timer);
 		comedi_isadma_free(devpriv->dma);
 	}
 }

commit 55cc6164eecfa72777d34b789e066f618eb1fd93
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue Jun 7 14:06:17 2016 +0530

    Staging: comedi: Block comment issue fixed for das16.c
    
    This is a patch to the das16.c file that fixes up a
    WARNING: 'Block comments use a trailing */ on a separate line'
    found by the checkpatch.pl tool.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 8b037bd741f1..5d157951f63f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -429,8 +429,10 @@ static const struct das16_board das16_boards[] = {
 	},
 };
 
-/* Period for timer interrupt in jiffies.  It's a function
- * to deal with possibility of dynamic HZ patches  */
+/*
+ * Period for timer interrupt in jiffies.  It's a function
+ * to deal with possibility of dynamic HZ patches
+ */
 static inline int timer_period(void)
 {
 	return HZ / 20;

commit d855c3a41ff6d4b907cf24bea136a96d70e02893
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue Jun 7 14:06:16 2016 +0530

    Staging: comedi: fix blank line issue in das16.c
    
    This is a patch to the das16.c file that fixes up a blank line after
    function/struct/union/enum  check found by the checkpatch.pl tool
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 69133e3b914e..8b037bd741f1 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -198,6 +198,7 @@ enum {
 	das16_pg_1601,
 	das16_pg_1602,
 };
+
 static const int *const das16_gainlists[] = {
 	NULL,
 	das16jr_gainlist,

commit 86c7815e9773bab44d244428d083a43e5a6f7aca
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Mon Jun 6 16:31:18 2016 +0530

    Staging: comedi: Prefer using the BIT macro issue in das16.c
    
    This patch Replace all occurences of (1<<x) by BIT(x) in the file das16.c
    to get rid of checkpatch.pl "CHECK" output "Prefer using the BIT macro"
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index fd8e0b76f764..69133e3b914e 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -92,37 +92,37 @@
 #define DAS16_AO_LSB_REG(x)		((x) ? 0x06 : 0x04)
 #define DAS16_AO_MSB_REG(x)		((x) ? 0x07 : 0x05)
 #define DAS16_STATUS_REG		0x08
-#define DAS16_STATUS_BUSY		(1 << 7)
-#define DAS16_STATUS_UNIPOLAR		(1 << 6)
-#define DAS16_STATUS_MUXBIT		(1 << 5)
-#define DAS16_STATUS_INT		(1 << 4)
+#define DAS16_STATUS_BUSY		BIT(7)
+#define DAS16_STATUS_UNIPOLAR		BIT(6)
+#define DAS16_STATUS_MUXBIT		BIT(5)
+#define DAS16_STATUS_INT		BIT(4)
 #define DAS16_CTRL_REG			0x09
-#define DAS16_CTRL_INTE			(1 << 7)
+#define DAS16_CTRL_INTE			BIT(7)
 #define DAS16_CTRL_IRQ(x)		(((x) & 0x7) << 4)
-#define DAS16_CTRL_DMAE			(1 << 2)
+#define DAS16_CTRL_DMAE			BIT(2)
 #define DAS16_CTRL_PACING_MASK		(3 << 0)
 #define DAS16_CTRL_INT_PACER		(3 << 0)
 #define DAS16_CTRL_EXT_PACER		(2 << 0)
 #define DAS16_CTRL_SOFT_PACER		(0 << 0)
 #define DAS16_PACER_REG			0x0a
 #define DAS16_PACER_BURST_LEN(x)	(((x) & 0xf) << 4)
-#define DAS16_PACER_CTR0		(1 << 1)
-#define DAS16_PACER_TRIG0		(1 << 0)
+#define DAS16_PACER_CTR0		BIT(1)
+#define DAS16_PACER_TRIG0		BIT(0)
 #define DAS16_GAIN_REG			0x0b
 #define DAS16_TIMER_BASE_REG		0x0c	/* to 0x0f */
 
 #define DAS1600_CONV_REG		0x404
-#define DAS1600_CONV_DISABLE		(1 << 6)
+#define DAS1600_CONV_DISABLE		BIT(6)
 #define DAS1600_BURST_REG		0x405
-#define DAS1600_BURST_VAL		(1 << 6)
+#define DAS1600_BURST_VAL		BIT(6)
 #define DAS1600_ENABLE_REG		0x406
-#define DAS1600_ENABLE_VAL		(1 << 6)
+#define DAS1600_ENABLE_VAL		BIT(6)
 #define DAS1600_STATUS_REG		0x407
-#define DAS1600_STATUS_BME		(1 << 6)
-#define DAS1600_STATUS_ME		(1 << 5)
-#define DAS1600_STATUS_CD		(1 << 4)
-#define DAS1600_STATUS_WS		(1 << 1)
-#define DAS1600_STATUS_CLK_10MHZ	(1 << 0)
+#define DAS1600_STATUS_BME		BIT(6)
+#define DAS1600_STATUS_ME		BIT(5)
+#define DAS1600_STATUS_CD		BIT(4)
+#define DAS1600_STATUS_WS		BIT(1)
+#define DAS1600_STATUS_CLK_10MHZ	BIT(0)
 
 static const struct comedi_lrange range_das1x01_bip = {
 	4, {

commit 90e6228a995816750f96c70d94298e12c08511f4
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Thu Oct 29 21:58:16 2015 -0700

    Staging: comedi: das16: Fix sparse endian warning
    
    Fix following sparse warning:
    warning: cast to restricted __le16
    
    This change is safe because array is pointer of type void and can
    be used to store any type of data, also offset of the array would
    be the same since unsigned short and __le16 are both 16 bits in size.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 056bca9c67d5..fd8e0b76f764 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -801,9 +801,10 @@ static void das16_ai_munge(struct comedi_device *dev,
 	unsigned short *data = array;
 	unsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned int i;
+	__le16 *buf = array;
 
 	for (i = 0; i < num_samples; i++) {
-		data[i] = le16_to_cpu(data[i]);
+		data[i] = le16_to_cpu(buf[i]);
 		if (s->maxdata == 0x0fff)
 			data[i] >>= 4;
 		data[i] &= s->maxdata;

commit c15a7009325b84adac2eb0f3919d9c3ff8d5ed11
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jul 30 00:36:32 2015 +0300

    staging: comedi: das16: remove a duplicate condition
    
    We checked that "it->options[3]" was non-zero on the line before so
    there is no need to check again.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index d7cf4b153f7c..056bca9c67d5 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1032,8 +1032,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
-		if (it->options[3] != 0 &&
-		    it->options[3] != 1 && it->options[3] != 10) {
+		if (it->options[3] != 1 && it->options[3] != 10) {
 			dev_err(dev->class_dev,
 				"Invalid option. Master clock must be set to 1 or 10 (MHz)\n");
 			return -EINVAL;

commit d8cfb3fb9b22d38214791789565e4ecf0bc7337e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:08 2015 +0000

    staging: comedi: das16: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f66db97b9d4f..d7cf4b153f7c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -76,7 +76,6 @@
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 #include "8255.h"
 
@@ -599,29 +598,29 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
 
 	trig_mask = TRIG_FOLLOW;
 	if (devpriv->can_burst)
 		trig_mask |= TRIG_TIMER | TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, trig_mask);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, trig_mask);
 
 	trig_mask = TRIG_TIMER | TRIG_EXT;
 	if (devpriv->can_burst)
 		trig_mask |= TRIG_NOW;
-	err |= cfc_check_trigger_src(&cmd->convert_src, trig_mask);
+	err |= comedi_check_trigger_src(&cmd->convert_src, trig_mask);
 
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -636,26 +635,30 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	/* check against maximum frequency */
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-					board->ai_speed * cmd->chanlist_len);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    board->ai_speed *
+						    cmd->chanlist_len);
+	}
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 board->ai_speed);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    board->ai_speed);
+	}
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -664,12 +667,12 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 	if (err)
 		return 4;

commit 81906c357a37bd82ca041bbdde9c663ea656f300
Author: Somya Anand <somyaanand214@gmail.com>
Date:   Wed Mar 11 17:02:13 2015 +0530

    Staging: comedi: Use function setup_timer for combining initialization
    
    The function setup_timer combines the initialization of a timer with the
    initialization of the timer's function and data fields.
    
    So, this patch combines the multiline code for timer initialization using the function
    setup_timer. This issue is identified via coccinelle script.
    
    @@
    expression E1, E2, E3;
    type T;
    @@
    - init_timer(&E1);
    ...
    (
    - E1.function = E2;
    ...
    - E1.data = (T)E3;
    + setup_timer(&E1, E2, (T)E3);
    |
    - E1.data = (T)E3;
    ...
    - E1.function = E2;
    + setup_timer(&E1, E2, (T)E3);
    |
    - E1.function = E2;
    + setup_timer(&E1, E2, 0);
    )
    
    Signed-off-by: Somya Anand <somyaanand214@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index be6277ae4abc..f66db97b9d4f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -935,9 +935,8 @@ static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,
 					   DAS16_DMA_SIZE, COMEDI_ISADMA_READ);
 	if (devpriv->dma) {
-		init_timer(&devpriv->timer);
-		devpriv->timer.function = das16_timer_interrupt;
-		devpriv->timer.data = (unsigned long)dev;
+		setup_timer(&devpriv->timer, das16_timer_interrupt,
+			    (unsigned long)dev);
 	}
 }
 

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 4b3bdade6596..be6277ae4abc 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -708,7 +708,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->flags & CMDF_PRIORITY) {
 		dev_err(dev->class_dev,
-			 "isa dma transfers cannot be performed with CMDF_PRIORITY, aborting\n");
+			"isa dma transfers cannot be performed with CMDF_PRIORITY, aborting\n");
 		return -1;
 	}
 

commit 4ffe2b25732be9cd68ec305f4c727da75462fcd4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:52 2015 -0700

    staging: comedi: das16: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2c20311120f1..4b3bdade6596 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -77,7 +77,7 @@
 
 #include "comedi_isadma.h"
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 #include "8255.h"
 
 #define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
@@ -663,18 +663,12 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  step 4: fix up arguments */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(devpriv->clockbase,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(devpriv->clockbase,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 	if (err)
@@ -693,17 +687,9 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 				    unsigned int flags)
 {
-	struct das16_private_struct *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;
-
-	i8253_cascade_ns_to_timer(devpriv->clockbase,
-				  &devpriv->divisor1, &devpriv->divisor2,
-				  &ns, flags);
-
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-	i8254_write(timer_base, 0, 1, devpriv->divisor1);
-	i8254_write(timer_base, 0, 2, devpriv->divisor2);
+	comedi_8254_cascade_ns_to_timer(dev->pacer, &ns, flags);
+	comedi_8254_update_divisors(dev->pacer);
+	comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
 
 	return ns;
 }
@@ -935,7 +921,6 @@ static void das16_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + DAS16_STATUS_REG);
 	outb(0, dev->iobase + DAS16_CTRL_REG);
 	outb(0, dev->iobase + DAS16_PACER_REG);
-	outb(0, dev->iobase + DAS16_TIMER_BASE_REG + i8254_control_reg);
 }
 
 static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
@@ -1039,6 +1024,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
+	unsigned int osc_base;
 	unsigned int status;
 	int ret;
 
@@ -1078,21 +1064,21 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 
 	/*  get master clock speed */
+	osc_base = I8254_OSC_BASE_1MHZ;
 	if (devpriv->can_burst) {
 		status = inb(dev->iobase + DAS1600_STATUS_REG);
-
 		if (status & DAS1600_STATUS_CLK_10MHZ)
-			devpriv->clockbase = I8254_OSC_BASE_10MHZ;
-		else
-			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
+			osc_base = I8254_OSC_BASE_10MHZ;
 	} else {
 		if (it->options[3])
-			devpriv->clockbase = I8254_OSC_BASE_1MHZ /
-					     it->options[3];
-		else
-			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
+			osc_base = I8254_OSC_BASE_1MHZ / it->options[3];
 	}
 
+	dev->pacer = comedi_8254_init(dev->iobase + DAS16_TIMER_BASE_REG,
+				      osc_base, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	das16_alloc_dma(dev, it->options[2]);
 
 	ret = comedi_alloc_subdevices(dev, 4 + board->has_8255);

commit 5cd23c492ebce9ac4d9e5dd883d732c1ed1498c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:21 2015 -0700

    staging: comedi: das16: introduce das16_ai_set_mux_range()
    
    Introduce a helper function to program the mux and gain for analog input
    single channel (*insn_read) and multi-channel (*do_cmd) operations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 86e90d549de7..2c20311120f1 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -537,6 +537,29 @@ static void das16_timer_interrupt(unsigned long arg)
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
+static void das16_ai_set_mux_range(struct comedi_device *dev,
+				   unsigned int first_chan,
+				   unsigned int last_chan,
+				   unsigned int range)
+{
+	const struct das16_board *board = dev->board_ptr;
+
+	/* set multiplexer */
+	outb(first_chan | (last_chan << 4), dev->iobase + DAS16_MUX_REG);
+
+	/* some boards do not have programmable gain */
+	if (board->ai_pg == das16_pg_none)
+		return;
+
+	/*
+	 * Set gain (this is also burst rate register but according to
+	 * computer boards manual, burst rate does nothing, even on
+	 * keithley cards).
+	 */
+	outb((das16_gainlists[board->ai_pg])[range],
+	     dev->iobase + DAS16_GAIN_REG);
+}
+
 static int das16_ai_check_chanlist(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_cmd *cmd)
@@ -687,14 +710,15 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 
 static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int first_chan = CR_CHAN(cmd->chanlist[0]);
+	unsigned int last_chan = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);
+	unsigned int range = CR_RANGE(cmd->chanlist[0]);
 	unsigned int byte;
 	unsigned long flags;
-	int range;
 
 	if (cmd->flags & CMDF_PRIORITY) {
 		dev_err(dev->class_dev,
@@ -705,19 +729,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->can_burst)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);
 
-	/*  set scan limits */
-	byte = CR_CHAN(cmd->chanlist[0]);
-	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
-	outb(byte, dev->iobase + DAS16_MUX_REG);
-
-	/* set gain (this is also burst rate register but according to
-	 * computer boards manual, burst rate does nothing, even on
-	 * keithley cards) */
-	if (board->ai_pg != das16_pg_none) {
-		range = CR_RANGE(cmd->chanlist[0]);
-		outb((das16_gainlists[board->ai_pg])[range],
-		     dev->iobase + DAS16_GAIN_REG);
-	}
+	/* set mux and range for chanlist scan */
+	das16_ai_set_mux_range(dev, first_chan, last_chan, range);
 
 	/* set counter mode and counts */
 	cmd->convert_arg = das16_set_pacer(dev, cmd->convert_arg, cmd->flags);
@@ -826,21 +839,14 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	const struct das16_board *board = dev->board_ptr;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int val;
 	int ret;
 	int i;
 
-	/* set multiplexer */
-	outb(chan | (chan << 4), dev->iobase + DAS16_MUX_REG);
-
-	/* set gain */
-	if (board->ai_pg != das16_pg_none) {
-		outb((das16_gainlists[board->ai_pg])[range],
-		     dev->iobase + DAS16_GAIN_REG);
-	}
+	/* set mux and range for single channel */
+	das16_ai_set_mux_range(dev, chan, chan, range);
 
 	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */

commit 1dc6e72903f6dbefd79ea2e9ce9c9e536e4e695b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:20 2015 -0700

    staging: comedi: das16: fix DMA size for short transfers
    
    Currently this driver alwasy programs the DMA transfer to be the allocated
    size of the DMA buffer. When the async command 'stop_src' is TRIG_COUNT its
    possible (likely) for the last transfer to be less than the buffer size.
    
    Introduce a helper function, das16_ai_setup_dma(), to calculate the actual
    size of the DMA transfer based on the number of samples remaining and the
    number of unread samples.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 3a2a6ccffe3f..86e90d549de7 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -448,6 +448,28 @@ struct das16_private_struct {
 	unsigned int		timer_running:1;
 };
 
+static void das16_ai_setup_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int unread_samples)
+{
+	struct das16_private_struct *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+	unsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);
+	unsigned int nsamples;
+
+	/*
+	 * Determine dma size based on the buffer size plus the number of
+	 * unread samples and the number of samples remaining in the command.
+	 */
+	nsamples = comedi_nsamples_left(s, max_samples + unread_samples);
+	if (nsamples > unread_samples) {
+		nsamples -= unread_samples;
+		desc->size = comedi_samples_to_bytes(s, nsamples);
+		comedi_isadma_program(desc);
+	}
+}
+
 static void das16_interrupt(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
@@ -486,13 +508,9 @@ static void das16_interrupt(struct comedi_device *dev)
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 
 	/* restart DMA if more samples are needed */
-	if (nsamples && nsamples < comedi_nsamples_left(s, nsamples + 1)) {
-		struct comedi_isadma_desc *nxt_desc;
-
+	if (nsamples) {
 		dma->cur_dma = 1 - dma->cur_dma;
-		nxt_desc = &dma->desc[dma->cur_dma];
-		nxt_desc->size = nxt_desc->maxsize;
-		comedi_isadma_program(nxt_desc);
+		das16_ai_setup_dma(dev, s, nsamples);
 	}
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
@@ -672,7 +690,6 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
@@ -721,8 +738,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* set up dma transfer */
 	dma->cur_dma = 0;
-	desc->size = desc->maxsize;
-	comedi_isadma_program(desc);
+	das16_ai_setup_dma(dev, s, 0);
 
 	/*  set up timer */
 	spin_lock_irqsave(&dev->spinlock, flags);

commit 42c44682a59a6ea38a301c20a4ec807c6fabdd02
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:19 2015 -0700

    staging: comedi: das16: use comedi_async 'scans_done' to detect EOA
    
    Refactor das16_interrupt() to use the comedi_async 'scans_done' member to
    detect the End-of-Acquisition for the async command. Use the helper function
    comedi_nsamples_left() to determine if DMA needs to be restarted.
    
    This allows the removal of the private data 'adc_byte_count' and fixes a
    possible integer overflow issue when that value is calculated.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 81fa28d3c0ca..3a2a6ccffe3f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -440,7 +440,6 @@ struct das16_private_struct {
 	struct comedi_isadma	*dma;
 	unsigned int		clockbase;
 	unsigned int		ctrl_reg;
-	unsigned long		adc_byte_count;
 	unsigned int		divisor1;
 	unsigned int		divisor2;
 	struct timer_list	timer;
@@ -458,8 +457,9 @@ static void das16_interrupt(struct comedi_device *dev)
 	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 	unsigned long spin_flags;
+	unsigned int residue;
+	unsigned int nbytes;
 	unsigned int nsamples;
-	int num_bytes, residue;
 
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if (!(devpriv->ctrl_reg & DAS16_CTRL_DMAE)) {
@@ -475,36 +475,33 @@ static void das16_interrupt(struct comedi_device *dev)
 	residue = comedi_isadma_disable_on_sample(desc->chan,
 						  comedi_bytes_per_sample(s));
 
-	/*  figure out how many points to read */
+	/* figure out how many samples to read */
 	if (residue > desc->size) {
 		dev_err(dev->class_dev, "residue > transfer size!\n");
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		num_bytes = 0;
-	} else
-		num_bytes = desc->size - residue;
-
-	if (cmd->stop_src == TRIG_COUNT &&
-					num_bytes >= devpriv->adc_byte_count) {
-		num_bytes = devpriv->adc_byte_count;
-		async->events |= COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
+		nbytes = 0;
+	} else {
+		nbytes = desc->size - residue;
 	}
+	nsamples = comedi_bytes_to_samples(s, nbytes);
 
-	dma->cur_dma = 1 - dma->cur_dma;
-	devpriv->adc_byte_count -= num_bytes;
-
-	/* re-enable dma */
-	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
-		struct comedi_isadma_desc *nxt_desc = &dma->desc[dma->cur_dma];
+	/* restart DMA if more samples are needed */
+	if (nsamples && nsamples < comedi_nsamples_left(s, nsamples + 1)) {
+		struct comedi_isadma_desc *nxt_desc;
 
+		dma->cur_dma = 1 - dma->cur_dma;
+		nxt_desc = &dma->desc[dma->cur_dma];
 		nxt_desc->size = nxt_desc->maxsize;
 		comedi_isadma_program(nxt_desc);
 	}
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
-	nsamples = comedi_bytes_to_samples(s, num_bytes);
 	comedi_buf_write_samples(s, desc->virt_addr, nsamples);
 
+	if (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)
+		async->events |= COMEDI_CB_EOA;
+
 	comedi_handle_events(dev, s);
 }
 
@@ -688,8 +685,6 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -1;
 	}
 
-	devpriv->adc_byte_count = cmd->stop_arg * comedi_bytes_per_scan(s);
-
 	if (devpriv->can_burst)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);
 

commit 29538110470aec8a9b0a378d10371821d8f6e27e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:18 2015 -0700

    staging: comedi: das16: change type of private data 'timer_running'
    
    This member of the private data is a true/false flag. For aesthetics,
    change the type to an unsigned int bit-field to save a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 5ad4c383cc5c..81fa28d3c0ca 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -444,9 +444,9 @@ struct das16_private_struct {
 	unsigned int		divisor1;
 	unsigned int		divisor2;
 	struct timer_list	timer;
-	short			timer_running;
 	unsigned long		extra_iobase;
 	unsigned int		can_burst:1;
+	unsigned int		timer_running:1;
 };
 
 static void das16_interrupt(struct comedi_device *dev)

commit 23a5c3ee7c9a2e0f3bcb229bf0c14ae5971d74c9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:17 2015 -0700

    staging: comedi: das16: introduce das16_ao_range()
    
    Clarify the (*attach) a bit by introducing a helper function to handle the
    setup of the analog output 'range_table'.
    
    Some of the boards supported by this driver do not have programmable ranges.
    The analog output subdevice can use optional range information provided by
    the user during the attach of the driver. Currently this range data is
    allocated and stored in the private data.
    
    Use the subdevice private data member instead and allocate the memory with
    comedi_alloc_spriv(). The comedi core will automatically free this memory
    when the driver is detached. If the allocation fails set the 'range_table'
    to 'range_unknown' instead of failing the driver attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index cb38e4b20497..5ad4c383cc5c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -443,7 +443,6 @@ struct das16_private_struct {
 	unsigned long		adc_byte_count;
 	unsigned int		divisor1;
 	unsigned int		divisor2;
-	struct comedi_lrange	*user_ao_range_table;
 	struct timer_list	timer;
 	short			timer_running;
 	unsigned long		extra_iobase;
@@ -987,13 +986,42 @@ static const struct comedi_lrange *das16_ai_range(struct comedi_device *dev,
 	return das16_ai_bip_lranges[pg_type];
 }
 
+static const struct comedi_lrange *das16_ao_range(struct comedi_device *dev,
+						  struct comedi_subdevice *s,
+						  struct comedi_devconfig *it)
+{
+	unsigned int min = it->options[6];
+	unsigned int max = it->options[7];
+
+	/* get any user-defined output range */
+	if (min || max) {
+		struct comedi_lrange *lrange;
+		struct comedi_krange *krange;
+
+		/* allocate single-range range table */
+		lrange = comedi_alloc_spriv(s,
+					    sizeof(*lrange) + sizeof(*krange));
+		if (!lrange)
+			return &range_unknown;
+
+		/* initialize ao range */
+		lrange->length = 1;
+		krange = lrange->range;
+		krange->min = min;
+		krange->max = max;
+		krange->flags = UNIT_volt;
+
+		return lrange;
+	}
+
+	return &range_unknown;
+}
+
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
-	struct comedi_lrange *lrange;
-	struct comedi_krange *krange;
 	unsigned int status;
 	int ret;
 
@@ -1050,22 +1078,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	das16_alloc_dma(dev, it->options[2]);
 
-	/* get any user-defined output range */
-	if (it->options[6] || it->options[7]) {
-		/* allocate single-range range table */
-		lrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);
-		if (!lrange)
-			return -ENOMEM;
-
-		/* initialize ao range */
-		devpriv->user_ao_range_table = lrange;
-		lrange->length = 1;
-		krange = devpriv->user_ao_range_table->range;
-		krange->min = it->options[6];
-		krange->max = it->options[7];
-		krange->flags = UNIT_volt;
-	}
-
 	ret = comedi_alloc_subdevices(dev, 4 + board->has_8255);
 	if (ret)
 		return ret;
@@ -1103,7 +1115,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags	= SDF_WRITABLE;
 		s->n_chan	= 2;
 		s->maxdata	= 0x0fff;
-		s->range_table	= devpriv->user_ao_range_table;
+		s->range_table	= das16_ao_range(dev, s, it);
 		s->insn_write	= das16_ao_insn_write;
 
 		ret = comedi_alloc_subdev_readback(s);
@@ -1165,7 +1177,6 @@ static void das16_detach(struct comedi_device *dev)
 		if (dev->iobase)
 			das16_reset(dev);
 		das16_free_dma(dev);
-		kfree(devpriv->user_ao_range_table);
 
 		if (devpriv->extra_iobase)
 			release_region(devpriv->extra_iobase,

commit 0ce8280e2876091b5c67cb515fae8e9bf3b50bfd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:16 2015 -0700

    staging: comedi: das16: introduce das16_ai_range()
    
    Clarify the (*attach) a bit by introducing a helper function to handle the
    setup of the analog input 'range_table'.
    
    Some of the boards supported by this driver do not have programmable ranges.
    The analog input subdevice can use optional range information provided by
    the user during the attach of the driver. Currently this range data is
    allocated and stored in the private data.
    
    Use the subdevice private data member instead and allocate the memory with
    comedi_alloc_spriv(). The comedi core will automatically free this memory
    when the driver is detached. If the allocation fails set the 'range_table'
    to 'range_unknown' instead of failing the driver attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2564af0f85f7..cb38e4b20497 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -443,7 +443,6 @@ struct das16_private_struct {
 	unsigned long		adc_byte_count;
 	unsigned int		divisor1;
 	unsigned int		divisor2;
-	struct comedi_lrange	*user_ai_range_table;
 	struct comedi_lrange	*user_ao_range_table;
 	struct timer_list	timer;
 	short			timer_running;
@@ -952,6 +951,42 @@ static void das16_free_dma(struct comedi_device *dev)
 	}
 }
 
+static const struct comedi_lrange *das16_ai_range(struct comedi_device *dev,
+						  struct comedi_subdevice *s,
+						  struct comedi_devconfig *it,
+						  unsigned int pg_type,
+						  unsigned int status)
+{
+	unsigned int min = it->options[4];
+	unsigned int max = it->options[5];
+
+	/* get any user-defined input range */
+	if (pg_type == das16_pg_none && (min || max)) {
+		struct comedi_lrange *lrange;
+		struct comedi_krange *krange;
+
+		/* allocate single-range range table */
+		lrange = comedi_alloc_spriv(s,
+					    sizeof(*lrange) + sizeof(*krange));
+		if (!lrange)
+			return &range_unknown;
+
+		/* initialize ai range */
+		lrange->length = 1;
+		krange = lrange->range;
+		krange->min = min;
+		krange->max = max;
+		krange->flags = UNIT_volt;
+
+		return lrange;
+	}
+
+	/* use software programmable range */
+	if (status & DAS16_STATUS_UNIPOLAR)
+		return das16_ai_uni_lranges[pg_type];
+	return das16_ai_bip_lranges[pg_type];
+}
+
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = dev->board_ptr;
@@ -1015,23 +1050,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	das16_alloc_dma(dev, it->options[2]);
 
-	/* get any user-defined input range */
-	if (board->ai_pg == das16_pg_none &&
-	    (it->options[4] || it->options[5])) {
-		/* allocate single-range range table */
-		lrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);
-		if (!lrange)
-			return -ENOMEM;
-
-		/* initialize ai range */
-		devpriv->user_ai_range_table = lrange;
-		lrange->length = 1;
-		krange = devpriv->user_ai_range_table->range;
-		krange->min = it->options[4];
-		krange->max = it->options[5];
-		krange->flags = UNIT_volt;
-	}
-
 	/* get any user-defined output range */
 	if (it->options[6] || it->options[7]) {
 		/* allocate single-range range table */
@@ -1067,13 +1085,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	s->len_chanlist	= s->n_chan;
 	s->maxdata	= board->ai_maxdata;
-	if (devpriv->user_ai_range_table) { /*  user defined ai range */
-		s->range_table	= devpriv->user_ai_range_table;
-	} else if (status & DAS16_STATUS_UNIPOLAR) {
-		s->range_table	= das16_ai_uni_lranges[board->ai_pg];
-	} else {
-		s->range_table	= das16_ai_bip_lranges[board->ai_pg];
-	}
+	s->range_table	= das16_ai_range(dev, s, it, board->ai_pg, status);
 	s->insn_read	= das16_ai_insn_read;
 	if (devpriv->dma) {
 		dev->read_subdev = s;
@@ -1153,7 +1165,6 @@ static void das16_detach(struct comedi_device *dev)
 		if (dev->iobase)
 			das16_reset(dev);
 		das16_free_dma(dev);
-		kfree(devpriv->user_ai_range_table);
 		kfree(devpriv->user_ao_range_table);
 
 		if (devpriv->extra_iobase)

commit c2733a92a64c7f0c48d873a8f75147a8ab33f399
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:15 2015 -0700

    staging: comedi: das16: absorb das16_ai_disable()
    
    This function is only called by das16_cancel(). Absorb it to clarify code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 97e5e7dca954..2564af0f85f7 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -451,17 +451,6 @@ struct das16_private_struct {
 	unsigned int		can_burst:1;
 };
 
-static void das16_ai_disable(struct comedi_device *dev)
-{
-	struct das16_private_struct *devpriv = dev->private;
-
-	/* disable interrupts, dma and pacer clocked conversions */
-	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |
-			       DAS16_CTRL_DMAE |
-			       DAS16_CTRL_PACING_MASK);
-	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
-}
-
 static void das16_interrupt(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
@@ -772,7 +761,11 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	das16_ai_disable(dev);
+	/* disable interrupts, dma and pacer clocked conversions */
+	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE | DAS16_CTRL_DMAE |
+			       DAS16_CTRL_PACING_MASK);
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
+
 	comedi_isadma_disable(dma->chan);
 
 	/*  disable SW timer */

commit fc4e02175285c4642f50ad7b4070848d9e9f63f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:14 2015 -0700

    staging: comedi: das16: remove unnecessary das16_ai_disable()
    
    The das16_ai_disable() function disables interrupts and the pacer clock. This
    function is called by the subdevice (*cancel) operation.
    
    The comedi core will not call a subdevice (*insn_read) operation while an
    async command is running due to the s->busy check in parse_insn(). Since all
    async commands are terminated by a (*cancel), the das16_ai_disable() is not
    necessary in das16_ai_insn_read(). Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 417ea755f42b..97e5e7dca954 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -831,8 +831,6 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	das16_ai_disable(dev);
-
 	/* set multiplexer */
 	outb(chan | (chan << 4), dev->iobase + DAS16_MUX_REG);
 

commit 7157fda400c7aeeee1eb60d4c6fd31cef822dac0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 26 16:17:13 2015 -0700

    staging: comedi: das16: absorb das16_ai_enable()
    
    This function is only called by das16_cmd_exec(). Absorb it to clarify code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 4608b0106b67..417ea755f42b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -451,23 +451,6 @@ struct das16_private_struct {
 	unsigned int		can_burst:1;
 };
 
-static void das16_ai_enable(struct comedi_device *dev,
-			    unsigned int mode, unsigned int src)
-{
-	struct das16_private_struct *devpriv = dev->private;
-
-	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |
-			       DAS16_CTRL_DMAE |
-			       DAS16_CTRL_PACING_MASK);
-	devpriv->ctrl_reg |= mode;
-
-	if (src == TRIG_EXT)
-		devpriv->ctrl_reg |= DAS16_CTRL_EXT_PACER;
-	else
-		devpriv->ctrl_reg |= DAS16_CTRL_INT_PACER;
-	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
-}
-
 static void das16_ai_disable(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
@@ -765,7 +748,14 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->timer.expires = jiffies + timer_period();
 	add_timer(&devpriv->timer);
 
-	das16_ai_enable(dev, DAS16_CTRL_DMAE, cmd->convert_src);
+	/* enable DMA interrupt with external or internal pacing */
+	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE | DAS16_CTRL_PACING_MASK);
+	devpriv->ctrl_reg |= DAS16_CTRL_DMAE;
+	if (cmd->convert_src == TRIG_EXT)
+		devpriv->ctrl_reg |= DAS16_CTRL_EXT_PACER;
+	else
+		devpriv->ctrl_reg |= DAS16_CTRL_INT_PACER;
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
 
 	if (devpriv->can_burst)
 		outb(0, dev->iobase + DAS1600_CONV_REG);

commit a3b2ee1d3ef56d0221fc5b246368dc13cf6b8ba4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:01 2015 -0700

    staging: comedi: das16: use COMEDI_CB_CANCEL_MASK to see if command is running
    
    In das16_interrupt(), use COMEDI_CB_CANCEL_MASK to determine if the async
    command is still running and the dma needs to be re-enabled. This will
    cause the driver not re-enable the dma if the async buffer overflows
    (COMEDI_CB_OVERFLOW), a hardware error occurs (COMEDI_CB_ERROR), or the
    command completes (COMEDI_CB_EOA).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 466d4ef45f3a..4608b0106b67 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -523,7 +523,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	devpriv->adc_byte_count -= num_bytes;
 
 	/* re-enable dma */
-	if ((async->events & COMEDI_CB_EOA) == 0) {
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
 		struct comedi_isadma_desc *nxt_desc = &dma->desc[dma->cur_dma];
 
 		nxt_desc->size = nxt_desc->maxsize;

commit 1400964a2b5c2fcf6d713148bc7ad7707935f3d6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:06 2015 -0700

    staging: comedi: das16: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 09d65fcebd0b..466d4ef45f3a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -71,16 +71,14 @@
 
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include <asm/dma.h>
-
 #include "../comedidev.h"
 
+#include "comedi_isadma.h"
+#include "comedi_fc.h"
 #include "8253.h"
 #include "8255.h"
-#include "comedi_fc.h"
 
 #define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
@@ -438,21 +436,13 @@ static inline int timer_period(void)
 	return HZ / 20;
 }
 
-struct das16_dma_desc {
-	uint16_t *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* transfer size (in bytes) */
-};
-
 struct das16_private_struct {
+	struct comedi_isadma	*dma;
 	unsigned int		clockbase;
 	unsigned int		ctrl_reg;
 	unsigned long		adc_byte_count;
 	unsigned int		divisor1;
 	unsigned int		divisor2;
-	unsigned int		dma_chan;
-	struct das16_dma_desc	dma_desc[2];
-	unsigned int		cur_dma;
 	struct comedi_lrange	*user_ai_range_table;
 	struct comedi_lrange	*user_ao_range_table;
 	struct timer_list	timer;
@@ -461,33 +451,6 @@ struct das16_private_struct {
 	unsigned int		can_burst:1;
 };
 
-static void das16_isadma_program(unsigned int dma_chan,
-				 struct das16_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_mode(dma_chan, DMA_MODE_READ);
-	set_dma_addr(dma_chan, dma->hw_addr);
-	set_dma_count(dma_chan, dma->size);
-	enable_dma(dma_chan);
-	release_dma_lock(flags);
-}
-
-static unsigned int das16_isadma_disable(unsigned int dma_chan)
-{
-	unsigned long flags;
-	unsigned int residue;
-
-	flags = claim_dma_lock();
-	disable_dma(dma_chan);
-	residue = get_dma_residue(dma_chan);
-	release_dma_lock(flags);
-
-	return residue;
-}
-
 static void das16_ai_enable(struct comedi_device *dev,
 			    unsigned int mode, unsigned int src)
 {
@@ -516,51 +479,14 @@ static void das16_ai_disable(struct comedi_device *dev)
 	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
 }
 
-/* the pc104-das16jr (at least) has problems if the dma
-	transfer is interrupted in the middle of transferring
-	a 16 bit sample, so this function takes care to get
-	an even transfer count after disabling dma
-	channel.
-*/
-static int disable_dma_on_even(struct comedi_device *dev)
-{
-	struct das16_private_struct *devpriv = dev->private;
-	static const int disable_limit = 100;
-	static const int enable_timeout = 100;
-	unsigned long flags;
-	unsigned int residue;
-	int new_residue;
-	int i;
-	int j;
-
-	residue = das16_isadma_disable(devpriv->dma_chan);
-	for (i = 0; i < disable_limit && (residue % 2); ++i) {
-		flags = claim_dma_lock();
-		enable_dma(devpriv->dma_chan);
-		for (j = 0; j < enable_timeout; ++j) {
-			udelay(2);
-			new_residue = get_dma_residue(devpriv->dma_chan);
-			release_dma_lock(flags);
-			if (new_residue != residue)
-				break;
-		}
-		residue = das16_isadma_disable(devpriv->dma_chan);
-	}
-	if (i == disable_limit) {
-		dev_err(dev->class_dev,
-			"failed to get an even dma transfer, could be trouble\n");
-	}
-	return residue;
-}
-
 static void das16_interrupt(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	struct das16_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	struct das16_dma_desc *nxt_dma;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 	unsigned long spin_flags;
 	unsigned int nsamples;
 	int num_bytes, residue;
@@ -571,15 +497,21 @@ static void das16_interrupt(struct comedi_device *dev)
 		return;
 	}
 
-	residue = disable_dma_on_even(dev);
+	/*
+	 * The pc104-das16jr (at least) has problems if the dma
+	 * transfer is interrupted in the middle of transferring
+	 * a 16 bit sample.
+	 */
+	residue = comedi_isadma_disable_on_sample(desc->chan,
+						  comedi_bytes_per_sample(s));
 
 	/*  figure out how many points to read */
-	if (residue > dma->size) {
+	if (residue > desc->size) {
 		dev_err(dev->class_dev, "residue > transfer size!\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		num_bytes = 0;
 	} else
-		num_bytes = dma->size - residue;
+		num_bytes = desc->size - residue;
 
 	if (cmd->stop_src == TRIG_COUNT &&
 					num_bytes >= devpriv->adc_byte_count) {
@@ -587,20 +519,21 @@ static void das16_interrupt(struct comedi_device *dev)
 		async->events |= COMEDI_CB_EOA;
 	}
 
-	devpriv->cur_dma = 1 - devpriv->cur_dma;
+	dma->cur_dma = 1 - dma->cur_dma;
 	devpriv->adc_byte_count -= num_bytes;
 
 	/* re-enable dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
-		nxt_dma = &devpriv->dma_desc[devpriv->cur_dma];
-		nxt_dma->size = DAS16_DMA_SIZE;
-		das16_isadma_program(devpriv->dma_chan, nxt_dma);
+		struct comedi_isadma_desc *nxt_desc = &dma->desc[dma->cur_dma];
+
+		nxt_desc->size = nxt_desc->maxsize;
+		comedi_isadma_program(nxt_desc);
 	}
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	nsamples = comedi_bytes_to_samples(s, num_bytes);
-	comedi_buf_write_samples(s, dma->virt_addr, nsamples);
+	comedi_buf_write_samples(s, desc->virt_addr, nsamples);
 
 	comedi_handle_events(dev, s);
 }
@@ -771,7 +704,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
-	struct das16_dma_desc *dma = &devpriv->dma_desc[0];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
@@ -821,9 +755,9 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb(byte, dev->iobase + DAS16_PACER_REG);
 
 	/* set up dma transfer */
-	devpriv->cur_dma = 0;
-	dma->size = DAS16_DMA_SIZE;
-	das16_isadma_program(devpriv->dma_chan, dma);
+	dma->cur_dma = 0;
+	desc->size = desc->maxsize;
+	comedi_isadma_program(desc);
 
 	/*  set up timer */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -843,12 +777,13 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das16_private_struct *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	das16_ai_disable(dev);
-	disable_dma(devpriv->dma_chan);
+	comedi_isadma_disable(dma->chan);
 
 	/*  disable SW timer */
 	if (devpriv->timer_running) {
@@ -1007,53 +942,33 @@ static void das16_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + DAS16_TIMER_BASE_REG + i8254_control_reg);
 }
 
-static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
+static void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct das16_private_struct *devpriv = dev->private;
-	struct das16_dma_desc *dma;
-	int i;
 
+	/* only DMA channels 3 and 1 are valid */
 	if (!(dma_chan == 1 || dma_chan == 3))
-		return 0;
-
-	if (request_dma(dma_chan, dev->board_name))
-		return 0;
-	devpriv->dma_chan = dma_chan;
-
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
+		return;
 
-		dma->virt_addr = dma_alloc_coherent(NULL, DAS16_DMA_SIZE,
-						    &dma->hw_addr, GFP_KERNEL);
-		if (!dma->virt_addr)
-			return -ENOMEM;
+	/* DMA uses two buffers */
+	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,
+					   DAS16_DMA_SIZE, COMEDI_ISADMA_READ);
+	if (devpriv->dma) {
+		init_timer(&devpriv->timer);
+		devpriv->timer.function = das16_timer_interrupt;
+		devpriv->timer.data = (unsigned long)dev;
 	}
-
-	das16_isadma_disable(devpriv->dma_chan);
-
-	init_timer(&devpriv->timer);
-	devpriv->timer.function = das16_timer_interrupt;
-	devpriv->timer.data = (unsigned long)dev;
-
-	return 0;
 }
 
 static void das16_free_dma(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
-	struct das16_dma_desc *dma;
-	int i;
 
-	if (devpriv->timer.data)
-		del_timer_sync(&devpriv->timer);
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->virt_addr)
-			dma_free_coherent(NULL, DAS16_DMA_SIZE,
-					  dma->virt_addr, dma->hw_addr);
+	if (devpriv) {
+		if (devpriv->timer.data)
+			del_timer_sync(&devpriv->timer);
+		comedi_isadma_free(devpriv->dma);
 	}
-	if (devpriv->dma_chan)
-		free_dma(devpriv->dma_chan);
 }
 
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -1117,9 +1032,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
 	}
 
-	ret = das16_alloc_dma(dev, it->options[2]);
-	if (ret)
-		return ret;
+	das16_alloc_dma(dev, it->options[2]);
 
 	/* get any user-defined input range */
 	if (board->ai_pg == das16_pg_none &&
@@ -1181,7 +1094,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->range_table	= das16_ai_bip_lranges[board->ai_pg];
 	}
 	s->insn_read	= das16_ai_insn_read;
-	if (devpriv->dma_chan) {
+	if (devpriv->dma) {
 		dev->read_subdev = s;
 		s->subdev_flags	|= SDF_CMD_READ;
 		s->do_cmdtest	= das16_cmd_test;

commit a1ce5f037ee83c1addb114179a776d505be1ddd5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:32 2015 -0700

    staging: comedi: das16: introduce das16_isadma_disable()
    
    Introduce a helper function to disable and the ISA DMA controller and
    return the residue as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f99796684978..09d65fcebd0b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -475,6 +475,19 @@ static void das16_isadma_program(unsigned int dma_chan,
 	release_dma_lock(flags);
 }
 
+static unsigned int das16_isadma_disable(unsigned int dma_chan)
+{
+	unsigned long flags;
+	unsigned int residue;
+
+	flags = claim_dma_lock();
+	disable_dma(dma_chan);
+	residue = get_dma_residue(dma_chan);
+	release_dma_lock(flags);
+
+	return residue;
+}
+
 static void das16_ai_enable(struct comedi_device *dev,
 			    unsigned int mode, unsigned int src)
 {
@@ -514,23 +527,24 @@ static int disable_dma_on_even(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 	static const int disable_limit = 100;
 	static const int enable_timeout = 100;
-	int residue;
+	unsigned long flags;
+	unsigned int residue;
 	int new_residue;
 	int i;
 	int j;
 
-	disable_dma(devpriv->dma_chan);
-	residue = get_dma_residue(devpriv->dma_chan);
+	residue = das16_isadma_disable(devpriv->dma_chan);
 	for (i = 0; i < disable_limit && (residue % 2); ++i) {
+		flags = claim_dma_lock();
 		enable_dma(devpriv->dma_chan);
 		for (j = 0; j < enable_timeout; ++j) {
 			udelay(2);
 			new_residue = get_dma_residue(devpriv->dma_chan);
+			release_dma_lock(flags);
 			if (new_residue != residue)
 				break;
 		}
-		disable_dma(devpriv->dma_chan);
-		residue = get_dma_residue(devpriv->dma_chan);
+		residue = das16_isadma_disable(devpriv->dma_chan);
 	}
 	if (i == disable_limit) {
 		dev_err(dev->class_dev,
@@ -548,7 +562,6 @@ static void das16_interrupt(struct comedi_device *dev)
 	struct das16_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	struct das16_dma_desc *nxt_dma;
 	unsigned long spin_flags;
-	unsigned long dma_flags;
 	unsigned int nsamples;
 	int num_bytes, residue;
 
@@ -558,10 +571,7 @@ static void das16_interrupt(struct comedi_device *dev)
 		return;
 	}
 
-	dma_flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma_chan);
 	residue = disable_dma_on_even(dev);
-	release_dma_lock(dma_flags);
 
 	/*  figure out how many points to read */
 	if (residue > dma->size) {
@@ -1001,7 +1011,6 @@ static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 {
 	struct das16_private_struct *devpriv = dev->private;
 	struct das16_dma_desc *dma;
-	unsigned long flags;
 	int i;
 
 	if (!(dma_chan == 1 || dma_chan == 3))
@@ -1020,9 +1029,7 @@ static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 			return -ENOMEM;
 	}
 
-	flags = claim_dma_lock();
-	disable_dma(devpriv->dma_chan);
-	release_dma_lock(flags);
+	das16_isadma_disable(devpriv->dma_chan);
 
 	init_timer(&devpriv->timer);
 	devpriv->timer.function = das16_timer_interrupt;

commit 0196285ebd08e08faab32016f09ae66e1da5d398
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:31 2015 -0700

    staging: comedi: das16: introduce das16_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f8c444c87f0b..f99796684978 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -461,6 +461,20 @@ struct das16_private_struct {
 	unsigned int		can_burst:1;
 };
 
+static void das16_isadma_program(unsigned int dma_chan,
+				 struct das16_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+	set_dma_addr(dma_chan, dma->hw_addr);
+	set_dma_count(dma_chan, dma->size);
+	enable_dma(dma_chan);
+	release_dma_lock(flags);
+}
+
 static void das16_ai_enable(struct comedi_device *dev,
 			    unsigned int mode, unsigned int src)
 {
@@ -547,6 +561,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	dma_flags = claim_dma_lock();
 	clear_dma_ff(devpriv->dma_chan);
 	residue = disable_dma_on_even(dev);
+	release_dma_lock(dma_flags);
 
 	/*  figure out how many points to read */
 	if (residue > dma->size) {
@@ -565,15 +580,12 @@ static void das16_interrupt(struct comedi_device *dev)
 	devpriv->cur_dma = 1 - devpriv->cur_dma;
 	devpriv->adc_byte_count -= num_bytes;
 
-	/*  re-enable  dma */
+	/* re-enable dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		nxt_dma = &devpriv->dma_desc[devpriv->cur_dma];
-		set_dma_addr(devpriv->dma_chan, nxt_dma->hw_addr);
 		nxt_dma->size = DAS16_DMA_SIZE;
-		set_dma_count(devpriv->dma_chan, nxt_dma->size);
-		enable_dma(devpriv->dma_chan);
+		das16_isadma_program(devpriv->dma_chan, nxt_dma);
 	}
-	release_dma_lock(dma_flags);
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
@@ -798,18 +810,10 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	outb(byte, dev->iobase + DAS16_PACER_REG);
 
-	/*  set up dma transfer */
-	flags = claim_dma_lock();
-	disable_dma(devpriv->dma_chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma_chan);
+	/* set up dma transfer */
 	devpriv->cur_dma = 0;
-	set_dma_addr(devpriv->dma_chan, dma->hw_addr);
 	dma->size = DAS16_DMA_SIZE;
-	set_dma_count(devpriv->dma_chan, dma->size);
-	enable_dma(devpriv->dma_chan);
-	release_dma_lock(flags);
+	das16_isadma_program(devpriv->dma_chan, dma);
 
 	/*  set up timer */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1018,7 +1022,6 @@ static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 
 	flags = claim_dma_lock();
 	disable_dma(devpriv->dma_chan);
-	set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 	release_dma_lock(flags);
 
 	init_timer(&devpriv->timer);

commit 59e561f3a6a21ac7c10e9ac039a470d6c186eff9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:30 2015 -0700

    staging: comedi: das16: move dma transfer 'size' to dma descriptor
    
    For asethetics, move the variable that holds the dma transfer 'size' into
    the dma descriptor.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 294cd81f2009..f8c444c87f0b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -441,6 +441,7 @@ static inline int timer_period(void)
 struct das16_dma_desc {
 	uint16_t *virt_addr;	/* virtual address of DMA buffer */
 	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
+	unsigned int size;	/* transfer size (in bytes) */
 };
 
 struct das16_private_struct {
@@ -452,7 +453,6 @@ struct das16_private_struct {
 	unsigned int		dma_chan;
 	struct das16_dma_desc	dma_desc[2];
 	unsigned int		cur_dma;
-	unsigned int		dma_transfer_size;
 	struct comedi_lrange	*user_ai_range_table;
 	struct comedi_lrange	*user_ao_range_table;
 	struct timer_list	timer;
@@ -549,12 +549,12 @@ static void das16_interrupt(struct comedi_device *dev)
 	residue = disable_dma_on_even(dev);
 
 	/*  figure out how many points to read */
-	if (residue > devpriv->dma_transfer_size) {
+	if (residue > dma->size) {
 		dev_err(dev->class_dev, "residue > transfer size!\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		num_bytes = 0;
 	} else
-		num_bytes = devpriv->dma_transfer_size - residue;
+		num_bytes = dma->size - residue;
 
 	if (cmd->stop_src == TRIG_COUNT &&
 					num_bytes >= devpriv->adc_byte_count) {
@@ -569,7 +569,8 @@ static void das16_interrupt(struct comedi_device *dev)
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		nxt_dma = &devpriv->dma_desc[devpriv->cur_dma];
 		set_dma_addr(devpriv->dma_chan, nxt_dma->hw_addr);
-		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+		nxt_dma->size = DAS16_DMA_SIZE;
+		set_dma_count(devpriv->dma_chan, nxt_dma->size);
 		enable_dma(devpriv->dma_chan);
 	}
 	release_dma_lock(dma_flags);
@@ -805,8 +806,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	clear_dma_ff(devpriv->dma_chan);
 	devpriv->cur_dma = 0;
 	set_dma_addr(devpriv->dma_chan, dma->hw_addr);
-	devpriv->dma_transfer_size = DAS16_DMA_SIZE;
-	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+	dma->size = DAS16_DMA_SIZE;
+	set_dma_count(devpriv->dma_chan, dma->size);
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);
 

commit ed07758759ad3fd2b7b18a1f821c2ad7e84376d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:15 2015 -0700

    staging: comedi: das16: board is not a PCI device
    
    The DAS16 board is an ISA device not a PCI device. For aesthetics, use
    dma_{alloc,free}_coherent() to allocate and free the DMA buffers instead
    of the PCI versions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index e0b41ae2cc36..294cd81f2009 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -72,7 +72,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 
 #include <asm/dma.h>
@@ -1010,8 +1009,8 @@ static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 
-		dma->virt_addr = pci_alloc_consistent(NULL, DAS16_DMA_SIZE,
-						      &dma->hw_addr);
+		dma->virt_addr = dma_alloc_coherent(NULL, DAS16_DMA_SIZE,
+						    &dma->hw_addr, GFP_KERNEL);
 		if (!dma->virt_addr)
 			return -ENOMEM;
 	}
@@ -1039,8 +1038,8 @@ static void das16_free_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 		if (dma->virt_addr)
-			pci_free_consistent(NULL, DAS16_DMA_SIZE,
-					    dma->virt_addr, dma->hw_addr);
+			dma_free_coherent(NULL, DAS16_DMA_SIZE,
+					  dma->virt_addr, dma->hw_addr);
 	}
 	if (devpriv->dma_chan)
 		free_dma(devpriv->dma_chan);

commit 742c4a095973f696cc9337e8ae39c3c4a834f7db
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:14 2015 -0700

    staging: comedi: das16: introduce das16_free_dma()
    
    For aesthetics, move the freeing of the DMA channel and the buffers to
    a helper function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 0f4a58785477..e0b41ae2cc36 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1028,6 +1028,24 @@ static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
 	return 0;
 }
 
+static void das16_free_dma(struct comedi_device *dev)
+{
+	struct das16_private_struct *devpriv = dev->private;
+	struct das16_dma_desc *dma;
+	int i;
+
+	if (devpriv->timer.data)
+		del_timer_sync(&devpriv->timer);
+	for (i = 0; i < 2; i++) {
+		dma = &devpriv->dma_desc[i];
+		if (dma->virt_addr)
+			pci_free_consistent(NULL, DAS16_DMA_SIZE,
+					    dma->virt_addr, dma->hw_addr);
+	}
+	if (devpriv->dma_chan)
+		free_dma(devpriv->dma_chan);
+}
+
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = dev->board_ptr;
@@ -1226,24 +1244,11 @@ static void das16_detach(struct comedi_device *dev)
 {
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
-	struct das16_dma_desc *dma;
-	int i;
 
 	if (devpriv) {
-		if (devpriv->timer.data)
-			del_timer_sync(&devpriv->timer);
 		if (dev->iobase)
 			das16_reset(dev);
-
-		for (i = 0; i < 2; i++) {
-			dma = &devpriv->dma_desc[i];
-			if (dma->virt_addr)
-				pci_free_consistent(NULL, DAS16_DMA_SIZE,
-						    dma->virt_addr,
-						    dma->hw_addr);
-		}
-		if (devpriv->dma_chan)
-			free_dma(devpriv->dma_chan);
+		das16_free_dma(dev);
 		kfree(devpriv->user_ai_range_table);
 		kfree(devpriv->user_ao_range_table);
 

commit 7447cd60a3700aa915b45e18afddd338eaaec117
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:13 2015 -0700

    staging: comedi: das16 introduce das16_alloc_dma()
    
    DMA is optional with this driver. Introduce a helper function to request
    the DMA channel and allocate the buffers. Don't fail the driver attach
    if the user passed an invalid DMA channel or the channel cannot be
    requested.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 1c32cbc5ae9d..0f4a58785477 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -993,6 +993,41 @@ static void das16_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + DAS16_TIMER_BASE_REG + i8254_control_reg);
 }
 
+static int das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)
+{
+	struct das16_private_struct *devpriv = dev->private;
+	struct das16_dma_desc *dma;
+	unsigned long flags;
+	int i;
+
+	if (!(dma_chan == 1 || dma_chan == 3))
+		return 0;
+
+	if (request_dma(dma_chan, dev->board_name))
+		return 0;
+	devpriv->dma_chan = dma_chan;
+
+	for (i = 0; i < 2; i++) {
+		dma = &devpriv->dma_desc[i];
+
+		dma->virt_addr = pci_alloc_consistent(NULL, DAS16_DMA_SIZE,
+						      &dma->hw_addr);
+		if (!dma->virt_addr)
+			return -ENOMEM;
+	}
+
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma_chan);
+	set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+	release_dma_lock(flags);
+
+	init_timer(&devpriv->timer);
+	devpriv->timer.function = das16_timer_interrupt;
+	devpriv->timer.data = (unsigned long)dev;
+
+	return 0;
+}
+
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = dev->board_ptr;
@@ -1000,7 +1035,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	struct comedi_lrange *lrange;
 	struct comedi_krange *krange;
-	unsigned int dma_chan = it->options[2];
 	unsigned int status;
 	int ret;
 
@@ -1055,39 +1089,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
 	}
 
-	/* initialize dma */
-	if (dma_chan == 1 || dma_chan == 3) {
-		unsigned long flags;
-		int i;
-
-		if (request_dma(dma_chan, dev->board_name)) {
-			dev_err(dev->class_dev,
-				"failed to request dma channel %i\n",
-				dma_chan);
-			return -EINVAL;
-		}
-		devpriv->dma_chan = dma_chan;
-
-		/* allocate dma buffers */
-		for (i = 0; i < 2; i++) {
-			struct das16_dma_desc *dma = &devpriv->dma_desc[i];
-
-			dma->virt_addr = pci_alloc_consistent(NULL,
-							      DAS16_DMA_SIZE,
-							      &dma->hw_addr);
-			if (!dma->virt_addr)
-				return -ENOMEM;
-		}
-
-		flags = claim_dma_lock();
-		disable_dma(devpriv->dma_chan);
-		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
-		release_dma_lock(flags);
-
-		init_timer(&devpriv->timer);
-		devpriv->timer.function = das16_timer_interrupt;
-		devpriv->timer.data = (unsigned long)dev;
-	}
+	ret = das16_alloc_dma(dev, it->options[2]);
+	if (ret)
+		return ret;
 
 	/* get any user-defined input range */
 	if (board->ai_pg == das16_pg_none &&

commit 38a7d4999a68af0c18216279971fa7acd8ec7345
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:12 2015 -0700

    staging: comedi: das16: introduce struct das16_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 64b0adaa9ded..1c32cbc5ae9d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -439,6 +439,11 @@ static inline int timer_period(void)
 	return HZ / 20;
 }
 
+struct das16_dma_desc {
+	uint16_t *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
+};
+
 struct das16_private_struct {
 	unsigned int		clockbase;
 	unsigned int		ctrl_reg;
@@ -446,9 +451,8 @@ struct das16_private_struct {
 	unsigned int		divisor1;
 	unsigned int		divisor2;
 	unsigned int		dma_chan;
-	uint16_t		*dma_buffer[2];
-	dma_addr_t		dma_buffer_addr[2];
-	unsigned int		current_buffer;
+	struct das16_dma_desc	dma_desc[2];
+	unsigned int		cur_dma;
 	unsigned int		dma_transfer_size;
 	struct comedi_lrange	*user_ai_range_table;
 	struct comedi_lrange	*user_ao_range_table;
@@ -528,11 +532,12 @@ static void das16_interrupt(struct comedi_device *dev)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	struct das16_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct das16_dma_desc *nxt_dma;
 	unsigned long spin_flags;
 	unsigned long dma_flags;
 	unsigned int nsamples;
 	int num_bytes, residue;
-	int buffer_index;
 
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if (!(devpriv->ctrl_reg & DAS16_CTRL_DMAE)) {
@@ -558,14 +563,13 @@ static void das16_interrupt(struct comedi_device *dev)
 		async->events |= COMEDI_CB_EOA;
 	}
 
-	buffer_index = devpriv->current_buffer;
-	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
+	devpriv->cur_dma = 1 - devpriv->cur_dma;
 	devpriv->adc_byte_count -= num_bytes;
 
 	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
-		set_dma_addr(devpriv->dma_chan,
-			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
+		nxt_dma = &devpriv->dma_desc[devpriv->cur_dma];
+		set_dma_addr(devpriv->dma_chan, nxt_dma->hw_addr);
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 	}
@@ -574,8 +578,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	nsamples = comedi_bytes_to_samples(s, num_bytes);
-	comedi_buf_write_samples(s, devpriv->dma_buffer[buffer_index],
-				 nsamples);
+	comedi_buf_write_samples(s, dma->virt_addr, nsamples);
 
 	comedi_handle_events(dev, s);
 }
@@ -746,6 +749,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
+	struct das16_dma_desc *dma = &devpriv->dma_desc[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
@@ -800,9 +804,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma_chan);
-	devpriv->current_buffer = 0;
-	set_dma_addr(devpriv->dma_chan,
-		     devpriv->dma_buffer_addr[devpriv->current_buffer]);
+	devpriv->cur_dma = 0;
+	set_dma_addr(devpriv->dma_chan, dma->hw_addr);
 	devpriv->dma_transfer_size = DAS16_DMA_SIZE;
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_chan);
@@ -1067,13 +1070,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		/* allocate dma buffers */
 		for (i = 0; i < 2; i++) {
-			void *p;
+			struct das16_dma_desc *dma = &devpriv->dma_desc[i];
 
-			p = pci_alloc_consistent(NULL, DAS16_DMA_SIZE,
-						 &devpriv->dma_buffer_addr[i]);
-			if (!p)
+			dma->virt_addr = pci_alloc_consistent(NULL,
+							      DAS16_DMA_SIZE,
+							      &dma->hw_addr);
+			if (!dma->virt_addr)
 				return -ENOMEM;
-			devpriv->dma_buffer[i] = p;
 		}
 
 		flags = claim_dma_lock();
@@ -1219,6 +1222,7 @@ static void das16_detach(struct comedi_device *dev)
 {
 	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
+	struct das16_dma_desc *dma;
 	int i;
 
 	if (devpriv) {
@@ -1228,11 +1232,11 @@ static void das16_detach(struct comedi_device *dev)
 			das16_reset(dev);
 
 		for (i = 0; i < 2; i++) {
-			if (devpriv->dma_buffer[i])
+			dma = &devpriv->dma_desc[i];
+			if (dma->virt_addr)
 				pci_free_consistent(NULL, DAS16_DMA_SIZE,
-						    devpriv->dma_buffer[i],
-						    devpriv->
-						    dma_buffer_addr[i]);
+						    dma->virt_addr,
+						    dma->hw_addr);
 		}
 		if (devpriv->dma_chan)
 			free_dma(devpriv->dma_chan);

commit c3c4f0bfe9f19c2da586ac3bf39aa1e31fcff3ed
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:42 2015 +0000

    staging: comedi: das16: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2436057304a3..64b0adaa9ded 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -22,28 +22,17 @@
  * Driver: das16
  * Description: DAS16 compatible boards
  * Author: Sam Moore, Warren Jasper, ds, Chris Baugher, Frank Hess, Roman Fietze
- * Devices: (Keithley Metrabyte) DAS-16 [das-16]
- *	    (Keithley Metrabyte) DAS-16G [das-16g]
- *	    (Keithley Metrabyte) DAS-16F [das-16f]
- *	    (Keithley Metrabyte) DAS-1201 [das-1201]
- *	    (Keithley Metrabyte) DAS-1202 [das-1202]
- *	    (Keithley Metrabyte) DAS-1401 [das-1401]
- *	    (Keithley Metrabyte) DAS-1402 [das-1402]
- *	    (Keithley Metrabyte) DAS-1601 [das-1601]
- *	    (Keithley Metrabyte) DAS-1602 [das-1602]
- *	    (ComputerBoards) PC104-DAS16/JR [pc104-das16jr]
- *	    (ComputerBoards) PC104-DAS16JR/16 [pc104-das16jr/16]
- *	    (ComputerBoards) CIO-DAS16 [cio-das16]
- *	    (ComputerBoards) CIO-DAS16F [cio-das16/f]
- *	    (ComputerBoards) CIO-DAS16/JR [cio-das16/jr]
- *	    (ComputerBoards) CIO-DAS16JR/16 [cio-das16jr/16]
- *	    (ComputerBoards) CIO-DAS1401/12 [cio-das1401/12]
- *	    (ComputerBoards) CIO-DAS1402/12 [cio-das1402/12]
- *	    (ComputerBoards) CIO-DAS1402/16 [cio-das1402/16]
- *	    (ComputerBoards) CIO-DAS1601/12 [cio-das1601/12]
- *	    (ComputerBoards) CIO-DAS1602/12 [cio-das1602/12]
- *	    (ComputerBoards) CIO-DAS1602/16 [cio-das1602/16]
- *	    (ComputerBoards) CIO-DAS16/330 [cio-das16/330]
+ * Devices: [Keithley Metrabyte] DAS-16 (das-16), DAS-16G (das-16g),
+ *   DAS-16F (das-16f), DAS-1201 (das-1201), DAS-1202 (das-1202),
+ *   DAS-1401 (das-1401), DAS-1402 (das-1402), DAS-1601 (das-1601),
+ *   DAS-1602 (das-1602),
+ *   [ComputerBoards] PC104-DAS16/JR (pc104-das16jr),
+ *   PC104-DAS16JR/16 (pc104-das16jr/16), CIO-DAS16 (cio-das16),
+ *   CIO-DAS16F (cio-das16/f), CIO-DAS16/JR (cio-das16/jr),
+ *   CIO-DAS16JR/16 (cio-das16jr/16), CIO-DAS1401/12 (cio-das1401/12),
+ *   CIO-DAS1402/12 (cio-das1402/12), CIO-DAS1402/16 (cio-das1402/16),
+ *   CIO-DAS1601/12 (cio-das1601/12), CIO-DAS1602/12 (cio-das1602/12),
+ *   CIO-DAS1602/16 (cio-das1602/16), CIO-DAS16/330 (cio-das16/330)
  * Status: works
  * Updated: 2003-10-12
  *

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 8de27053666f..2436057304a3 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1175,7 +1175,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->maxdata	= 0x0fff;
 		s->range_table	= devpriv->user_ao_range_table;
 		s->insn_write	= das16_ao_insn_write;
-		s->insn_read	= comedi_readback_insn_read;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit bd508fffda8fc3dbcabab9bc31817c588f7938c2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:31 2014 -0700

    staging: comedi: das16: use sample manipulation helpers
    
    Use the recently added sample manipulation helpers to remove the hardcoded
    assumption of the sample size.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 26f54aa9d41c..8de27053666f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -863,8 +863,9 @@ static void das16_ai_munge(struct comedi_device *dev,
 			   unsigned int num_bytes,
 			   unsigned int start_chan_index)
 {
-	unsigned int i, num_samples = num_bytes / sizeof(short);
 	unsigned short *data = array;
+	unsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);
+	unsigned int i;
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 8e512b241653..26f54aa9d41c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -584,7 +584,7 @@ static void das16_interrupt(struct comedi_device *dev)
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
-	nsamples = num_bytes / bytes_per_sample(s);
+	nsamples = comedi_bytes_to_samples(s, num_bytes);
 	comedi_buf_write_samples(s, devpriv->dma_buffer[buffer_index],
 				 nsamples);
 

commit 0a43f75ef57fcf20b9637fa49889e6721ceb5ea7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 29 17:35:12 2014 +0000

    staging: comedi: das16: use spin-lock when setting timer
    
    "das16" sets a timer running in `das16_cmd_exec()` and sets
    `devpriv->timer_running` to indicate that it is running.  The timer
    expiration routine `das16_timer_interrupt()` checks
    `devpriv->timer_running` to check whether it needs to reschedule the
    timer, but this is not synchronized with `das16_cmd_exec()`.  Since
    `das16_cancel()` acquires the `dev->spinlock` spin-lock when clearing
    `devpriv->timer_running` and removing the timer from the queue, use the
    same spin-lock in `das16_cmd_exec()` and `das16_timer_interrupt()`
    around the setting and checking of `devpriv->timer_running`.
    
    Since `das16_interrupt()` (called from `das16_timer_interrupt()`) checks
    whether DMA is enabled in the device while holding `dev->spinlock`, and
    DMA is enabled by `das16_cmd_exec()` around the time it schedules the
    timer, enable the DMA in the device while holding the spin-lock.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 4556af109eae..8e512b241653 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -595,11 +595,14 @@ static void das16_timer_interrupt(unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
 	struct das16_private_struct *devpriv = dev->private;
+	unsigned long flags;
 
 	das16_interrupt(dev);
 
+	spin_lock_irqsave(&dev->spinlock, flags);
 	if (devpriv->timer_running)
 		mod_timer(&devpriv->timer, jiffies + timer_period());
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int das16_ai_check_chanlist(struct comedi_device *dev,
@@ -816,7 +819,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);
 
-	/*  set up interrupt */
+	/*  set up timer */
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->timer_running = 1;
 	devpriv->timer.expires = jiffies + timer_period();
 	add_timer(&devpriv->timer);
@@ -825,6 +829,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->can_burst)
 		outb(0, dev->iobase + DAS1600_CONV_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }

commit ab784e5075698ed3b767d5e264a50aab39add209
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 29 17:35:11 2014 +0000

    staging: comedi: das16: deschedule timer routine on detach
    
    The "das16" driver optionally uses a kernel timer and a DMA channel to
    support asynchronous data acquisition, but currently never calls
    `del_timer_sync()`.  There is some possibility the timer routine could
    still be scheduled to run when the comedi "detach" handler is run to
    clean up the device and cause a certain amount of havoc.  Avoid that by
    calling `del_time_sync()` in the comedi "detach" handler
    `das16_detach()` if the timer was initialized by the "attach" handler
    `das16_attach()`.  Use the timer's `data` member to tell whether it was
    initialized or not.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index aa9e3e10d59d..4556af109eae 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1228,6 +1228,8 @@ static void das16_detach(struct comedi_device *dev)
 	int i;
 
 	if (devpriv) {
+		if (devpriv->timer.data)
+			del_timer_sync(&devpriv->timer);
 		if (dev->iobase)
 			das16_reset(dev);
 

commit 2e7b65e4bbe3b35ece1b8c8179a77071be042c38
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:41 2014 -0700

    staging: comedi: das16: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will determining the number of bytes to add based on the
    bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 5d47d0a1d45f..aa9e3e10d59d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -541,6 +541,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long spin_flags;
 	unsigned long dma_flags;
+	unsigned int nsamples;
 	int num_bytes, residue;
 	int buffer_index;
 
@@ -583,8 +584,9 @@ static void das16_interrupt(struct comedi_device *dev)
 
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
-	cfc_write_array_to_buffer(s,
-				  devpriv->dma_buffer[buffer_index], num_bytes);
+	nsamples = num_bytes / bytes_per_sample(s);
+	comedi_buf_write_samples(s, devpriv->dma_buffer[buffer_index],
+				 nsamples);
 
 	comedi_handle_events(dev, s);
 }

commit 1b8db39fd9c403e90238797529694ba45d36b4e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:41:15 2014 -0700

    staging: comedi: das16: use comedi_bytes_per_scan()
    
    This inline function is just a wrapper around comedi_bytes_per_scan().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 222a32ff0d32..5d47d0a1d45f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -764,7 +764,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -1;
 	}
 
-	devpriv->adc_byte_count = cmd->stop_arg * cfc_bytes_per_scan(s);
+	devpriv->adc_byte_count = cmd->stop_arg * comedi_bytes_per_scan(s);
 
 	if (devpriv->can_burst)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);

commit 2588ab409c6eaf82061b7ac1b4e86801862fbf13
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:20 2014 -0700

    staging: comedi: das16: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2d8e86cec47a..222a32ff0d32 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -586,7 +586,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	cfc_write_array_to_buffer(s,
 				  devpriv->dma_buffer[buffer_index], num_bytes);
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static void das16_timer_interrupt(unsigned long arg)

commit 2c8af779c4c205ff379dcc3ac52831730ec0f5d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:46 2014 -0700

    staging: comedi: das16: prevent "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. The (*do_cmd) then sets up and starts the command without handling the "empty
    acquisition". This results in the interrupt function trying to transfer 0 data
    samples.
    
    Validate that the cmd->stop_arg is >= 1 in the (*do_cmdtest) to prevent the
    "empty acquisition".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index baec9f2bd43c..2d8e86cec47a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -692,7 +692,9 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
 						 board->ai_speed);
 
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)

commit 7a5bd23d9e91a5d410c9fe9a449464efe69ccf03
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:27 2014 +0100

    staging: comedi: das16: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index aa52a5b83c43..baec9f2bd43c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -631,7 +631,7 @@ static int das16_ai_check_chanlist(struct comedi_device *dev,
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
 	int err = 0;
 	unsigned int trig_mask;
@@ -748,7 +748,7 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 
 static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -883,7 +883,7 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int val;
@@ -968,7 +968,7 @@ static int das16_do_insn_bits(struct comedi_device *dev,
 
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	int diobits;
 
 	/* diobits indicates boards */
@@ -993,7 +993,7 @@ static void das16_reset(struct comedi_device *dev)
 
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
 	struct comedi_lrange *lrange;
@@ -1219,7 +1219,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void das16_detach(struct comedi_device *dev)
 {
-	const struct das16_board *board = comedi_board(dev);
+	const struct das16_board *board = dev->board_ptr;
 	struct das16_private_struct *devpriv = dev->private;
 	int i;
 

commit 0dbcf9c1c85643794ea5ce58378682002069bfe5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:25 2014 +0100

    staging: comedi: das16: use CMDF_PRIORITY
    
    Replace use of `TRIG_RT` command flag with the equivalent flag
    `CMDF_PRIORITY`.  The numeric value is unchanged.  Also replace
    "TRIG_RT" with "CMDF_PRIORITY" in kernel log messages.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a7b4981a949b..aa52a5b83c43 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -756,9 +756,9 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 	int range;
 
-	if (cmd->flags & TRIG_RT) {
+	if (cmd->flags & CMDF_PRIORITY) {
 		dev_err(dev->class_dev,
-			 "isa dma transfers cannot be performed with TRIG_RT, aborting\n");
+			 "isa dma transfers cannot be performed with CMDF_PRIORITY, aborting\n");
 		return -1;
 	}
 

commit 551739b0d349448ca4bf34c43754c2f1ab7593cc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:03 2014 -0700

    staging: comedi: das16: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a347bcdff29c..a7b4981a949b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -927,11 +927,13 @@ static int das16_ao_insn_write(struct comedi_device *dev,
 			       unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val;
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
-		val = data[i];
+		unsigned int val = data[i];
+
+		s->readback[chan] = val;
+
 		val <<= 4;
 
 		outb(val & 0xff, dev->iobase + DAS16_AO_LSB_REG(chan));
@@ -1163,6 +1165,11 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->maxdata	= 0x0fff;
 		s->range_table	= devpriv->user_ao_range_table;
 		s->insn_write	= das16_ao_insn_write;
+		s->insn_read	= comedi_readback_insn_read;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}

commit 4085e93b9fecfad454159694c19efc36e7ac1cdf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:26 2014 -0700

    staging: comedi: 8255: refactor how the (*io) function works
    
    Currently, all users of is module that use the default (*io) function
    pass an 'iobase' to subdev_8255_init() of the form:
    
      dev->iobase + OFFSET_TO_8255_BASE_REG
    
    Now that the (*io) callback includes the comedi_device 'dev' pointer
    the 'dev->iobase' does not need to be included.
    
    Modify the default (*io) function, subdev_8255_io(), to automatically
    add the dev->iobase to the address when reading/writing the port.
    
    For aesthetics, rename the subdevice private data member to 'regbase'.
    Also, rename the local variables in this module that are used to
    access this member.
    
    Add a comment in dev_8255_attach() about the 'iobase' that is passed
    to subdev_8255_init(). For manually attached 8255 devices the io
    region is requested with __comedi_request_region() which does not
    set dev->iobase. For these devices the 'regbase' is actually the
    'iobase'.
    
    Remove the, now unnecessary, dev->iobase from all the callers of
    subdev_8255_init(). There are a couple drivers that only passed the
    dev->iobase. For those drivers pass a 'regbase' of 0x00.
    
    Note that the das16m1 driver is a bit goofy. The devpriv->extra_iobase
    is requested using __comedi_request_region() which does not set the
    dev->iobase. But the starting address passed is dev->iobase + DAS16M1_82C55
    so a 'regbase' of DAS16M1_82C55 is passed to subdev_8255_init().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 057bc16f8ddc..a347bcdff29c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1191,8 +1191,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* 8255 Digital I/O subdevice */
 	if (board->has_8255) {
 		s = &dev->subdevices[4];
-		ret = subdev_8255_init(dev, s, NULL,
-				       dev->iobase + board->i8255_offset);
+		ret = subdev_8255_init(dev, s, NULL, board->i8255_offset);
 		if (ret)
 			return ret;
 	}

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index d92cc181112d..057bc16f8ddc 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -729,14 +729,14 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-				    int rounding_flags)
+				    unsigned int flags)
 {
 	struct das16_private_struct *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;
 
 	i8253_cascade_ns_to_timer(devpriv->clockbase,
 				  &devpriv->divisor1, &devpriv->divisor2,
-				  &ns, rounding_flags);
+				  &ns, flags);
 
 	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
@@ -782,9 +782,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* set counter mode and counts */
-	cmd->convert_arg =
-	    das16_set_pacer(dev, cmd->convert_arg,
-			    cmd->flags & TRIG_ROUND_MASK);
+	cmd->convert_arg = das16_set_pacer(dev, cmd->convert_arg, cmd->flags);
 
 	/* enable counters */
 	byte = 0;

commit d7e31e5661aa9b6f945f2cf3aa57442a92d2f5d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:01:55 2014 -0700

    staging: comedi: das16: checkpatch.pl cleanup (missing blank line)
    
    Fix thess checkpatch.pl warnings:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2feecf199f27..d92cc181112d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -506,18 +506,18 @@ static void das16_ai_disable(struct comedi_device *dev)
 static int disable_dma_on_even(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
-	int residue;
-	int i;
 	static const int disable_limit = 100;
 	static const int enable_timeout = 100;
+	int residue;
+	int new_residue;
+	int i;
+	int j;
 
 	disable_dma(devpriv->dma_chan);
 	residue = get_dma_residue(devpriv->dma_chan);
 	for (i = 0; i < disable_limit && (residue % 2); ++i) {
-		int j;
 		enable_dma(devpriv->dma_chan);
 		for (j = 0; j < enable_timeout; ++j) {
-			int new_residue;
 			udelay(2);
 			new_residue = get_dma_residue(devpriv->dma_chan);
 			if (new_residue != residue)

commit 4bc030446fd6d4ad3d719228f2f30be2b989c575
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:31:09 2014 -0700

    staging: comedi: das16: use cfc_bytes_per_scan()
    
    Use the comedi_fc helper to get the number of bytes per scan.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f40d42298a11..2feecf199f27 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -762,8 +762,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -1;
 	}
 
-	devpriv->adc_byte_count =
-	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
+	devpriv->adc_byte_count = cmd->stop_arg * cfc_bytes_per_scan(s);
 
 	if (devpriv->can_burst)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);

commit 0e21721125e6fe9677ed9c2eb07057ae6e466fcf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:45 2014 -0700

    staging: comedi: das16: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    Tidy up the local varaibles in the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a18c6b696ecf..f40d42298a11 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -633,23 +633,23 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
-	int err = 0, tmp;
-	int mask;
+	int err = 0;
+	unsigned int trig_mask;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
 
-	mask = TRIG_FOLLOW;
+	trig_mask = TRIG_FOLLOW;
 	if (devpriv->can_burst)
-		mask |= TRIG_TIMER | TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, mask);
+		trig_mask |= TRIG_TIMER | TRIG_EXT;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, trig_mask);
 
-	tmp = cmd->convert_src;
-	mask = TRIG_TIMER | TRIG_EXT;
+	trig_mask = TRIG_TIMER | TRIG_EXT;
 	if (devpriv->can_burst)
-		mask |= TRIG_NOW;
-	err |= cfc_check_trigger_src(&cmd->convert_src, mask);
+		trig_mask |= TRIG_NOW;
+	err |= cfc_check_trigger_src(&cmd->convert_src, trig_mask);
 
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
@@ -700,22 +700,20 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/*  step 4: fix up arguments */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		unsigned int tmp = cmd->scan_begin_arg;
-		/*  set divisors, correct timing arguments */
+		arg = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer(devpriv->clockbase,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->scan_begin_arg, cmd->flags);
-		err += (tmp != cmd->scan_begin_arg);
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		unsigned int tmp = cmd->convert_arg;
-		/*  set divisors, correct timing arguments */
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->clockbase,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		err += (tmp != cmd->convert_arg);
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 	if (err)
 		return 4;

commit 8383b8c4a9b81ad5fa446a9b4c9bd5ac4b382c2a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:59 2014 -0700

    staging: comedi: das16: clarify 8254 timer programming
    
    Refactor the 8254 timer programming to use the i8254_set_mode()
    and i8254_write() helpers instead of i8254_load(). This allows
    us to use the I8254_MODE* defines to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index eb774c3ef17f..a18c6b696ecf 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -740,9 +740,10 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 				  &devpriv->divisor1, &devpriv->divisor2,
 				  &ns, rounding_flags);
 
-	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-	i8254_load(timer_base, 0, 1, devpriv->divisor1, 2);
-	i8254_load(timer_base, 0, 2, devpriv->divisor2, 2);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+	i8254_write(timer_base, 0, 1, devpriv->divisor1);
+	i8254_write(timer_base, 0, 2, devpriv->divisor2);
 
 	return ns;
 }

commit f207eda15f49fd84aaf18db8927fd51a93970fbf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:12 2014 -0700

    staging: comedi: das16: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input async command
    support. Tidy up the factored out code.
    
    To minimize the noise, change the dev_err() to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 6a7d652ff564..eb774c3ef17f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -600,13 +600,40 @@ static void das16_timer_interrupt(unsigned long arg)
 		mod_timer(&devpriv->timer, jiffies + timer_period());
 }
 
+static int das16_ai_check_chanlist(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan != ((chan0 + i) % s->n_chan)) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must be consecutive channels, counting upwards\n");
+			return -EINVAL;
+		}
+
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must all have the same gain\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
 	int err = 0, tmp;
-	int gain, start_chan, i;
 	int mask;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -693,24 +720,10 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	/*  check channel/gain list against card's limitations */
-	if (cmd->chanlist) {
-		gain = CR_RANGE(cmd->chanlist[0]);
-		start_chan = CR_CHAN(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    (start_chan + i) % s->n_chan) {
-				dev_err(dev->class_dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
-				err++;
-			}
-			if (CR_RANGE(cmd->chanlist[i]) != gain) {
-				dev_err(dev->class_dev,
-					"entries in chanlist must all have the same gain\n");
-				err++;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= das16_ai_check_chanlist(dev, s, cmd);
+
 	if (err)
 		return 5;
 

commit fe45e153d424a009a22c0dfd86b0034926fd2342
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:03 2014 -0700

    staging: comedi: das16: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a8446ca04110..6a7d652ff564 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -856,18 +856,17 @@ static void das16_ai_munge(struct comedi_device *dev,
 	}
 }
 
-static int das16_ai_wait_for_conv(struct comedi_device *dev,
-				  unsigned int timeout)
+static int das16_ai_eoc(struct comedi_device *dev,
+			struct comedi_subdevice *s,
+			struct comedi_insn *insn,
+			unsigned long context)
 {
 	unsigned int status;
-	int i;
 
-	for (i = 0; i < timeout; i++) {
-		status = inb(dev->iobase + DAS16_STATUS_REG);
-		if (!(status & DAS16_STATUS_BUSY))
-			return 0;
-	}
-	return -ETIME;
+	status = inb(dev->iobase + DAS16_STATUS_REG);
+	if ((status & DAS16_STATUS_BUSY) == 0)
+		return 0;
+	return -EBUSY;
 }
 
 static int das16_ai_insn_read(struct comedi_device *dev,
@@ -897,7 +896,7 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS16_TRIG_REG);
 
-		ret = das16_ai_wait_for_conv(dev, 1000);
+		ret = comedi_timeout(dev, s, insn, das16_ai_eoc, 0);
 		if (ret)
 			return ret;
 

commit 920983458cbf4213e8a99567d8d22c3721723cd1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:16 2013 +0100

    staging: comedi: das16: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the type of the `data` variable in `das16_ai_munge()` from `short
    *` to `unsigned short *` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 30f3995d7297..a8446ca04110 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -846,7 +846,7 @@ static void das16_ai_munge(struct comedi_device *dev,
 			   unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
-	short *data = array;
+	unsigned short *data = array;
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index fc058f8e8702..30f3995d7297 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -675,21 +675,19 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->scan_begin_arg;
 		/*  set divisors, correct timing arguments */
-		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-					       &devpriv->divisor1,
-					       &devpriv->divisor2,
-					       &cmd->scan_begin_arg,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(devpriv->clockbase,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->scan_begin_arg, cmd->flags);
 		err += (tmp != cmd->scan_begin_arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->convert_arg;
 		/*  set divisors, correct timing arguments */
-		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-					       &devpriv->divisor1,
-					       &devpriv->divisor2,
-					       &cmd->convert_arg,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(devpriv->clockbase,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->convert_arg, cmd->flags);
 		err += (tmp != cmd->convert_arg);
 	}
 	if (err)
@@ -725,11 +723,9 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 	struct das16_private_struct *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;
 
-	i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-				       &devpriv->divisor1,
-				       &devpriv->divisor2,
-				       &ns,
-				       rounding_flags & TRIG_ROUND_MASK);
+	i8253_cascade_ns_to_timer(devpriv->clockbase,
+				  &devpriv->divisor1, &devpriv->divisor2,
+				  &ns, rounding_flags);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(timer_base, 0, 1, devpriv->divisor1, 2);
@@ -1036,14 +1032,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		status = inb(dev->iobase + DAS1600_STATUS_REG);
 
 		if (status & DAS1600_STATUS_CLK_10MHZ)
-			devpriv->clockbase = 100;
+			devpriv->clockbase = I8254_OSC_BASE_10MHZ;
 		else
-			devpriv->clockbase = 1000;
+			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
 	} else {
 		if (it->options[3])
-			devpriv->clockbase = 1000 / it->options[3];
+			devpriv->clockbase = I8254_OSC_BASE_1MHZ /
+					     it->options[3];
 		else
-			devpriv->clockbase = 1000;	/*  1 MHz default */
+			devpriv->clockbase = I8254_OSC_BASE_1MHZ;
 	}
 
 	/* initialize dma */

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 1b0793f33b9f..fc058f8e8702 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -952,15 +952,8 @@ static int das16_do_insn_bits(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
-
-	if (mask) {
-		s->state &= ~mask;
-		s->state |= (bits & mask);
-
+	if (comedi_dio_update_state(s, data))
 		outb(s->state, dev->iobase + DAS16_DIO_REG);
-	}
 
 	data[1] = s->state;
 

commit 41506a9f83c5ef8abda07d205c52b9e35d6d229a
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Aug 13 13:55:48 2013 -0700

    drivers/staging/comedi/drivers/das16.c: needs slab.h
    
    alpha allmodconfig:
    
    drivers/staging/comedi/drivers/das16.c: In function 'das16_detach':
    drivers/staging/comedi/drivers/das16.c:1234: error: implicit declaration of function 'kfree'
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 93a8f09173aa..1b0793f33b9f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -81,6 +81,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>

commit 71c9e43b88576683685e8e763eb223bf9e8193c4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:08:31 2013 -0700

    staging: comedi: das16: tidy up multi-line comments
    
    Tidy up the multi-line comments to follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 599be27d1570..93a8f09173aa 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1,77 +1,84 @@
 /*
-    comedi/drivers/das16.c
-    DAS16 driver
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-    Copyright (C) 2000 Chris R. Baugher <baugher@enteract.com>
-    Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
-/*
-Driver: das16
-Description: DAS16 compatible boards
-Author: Sam Moore, Warren Jasper, ds, Chris Baugher, Frank Hess, Roman Fietze
-Devices: [Keithley Metrabyte] DAS-16 (das-16), DAS-16G (das-16g),
-  DAS-16F (das-16f), DAS-1201 (das-1201), DAS-1202 (das-1202),
-  DAS-1401 (das-1401), DAS-1402 (das-1402), DAS-1601 (das-1601),
-  DAS-1602 (das-1602),
-  [ComputerBoards] PC104-DAS16/JR (pc104-das16jr),
-  PC104-DAS16JR/16 (pc104-das16jr/16),
-  CIO-DAS16JR/16 (cio-das16jr/16),
-  CIO-DAS16/JR (cio-das16/jr), CIO-DAS1401/12 (cio-das1401/12),
-  CIO-DAS1402/12 (cio-das1402/12), CIO-DAS1402/16 (cio-das1402/16),
-  CIO-DAS1601/12 (cio-das1601/12), CIO-DAS1602/12 (cio-das1602/12),
-  CIO-DAS1602/16 (cio-das1602/16), CIO-DAS16/330 (cio-das16/330)
-Status: works
-Updated: 2003-10-12
-
-A rewrite of the das16 and das1600 drivers.
-Options:
-	[0] - base io address
-	[1] - irq (does nothing, irq is not used anymore)
-	[2] - dma (optional, required for comedi_command support)
-	[3] - master clock speed in MHz (optional, 1 or 10, ignored if
-		board can probe clock, defaults to 1)
-	[4] - analog input range lowest voltage in microvolts (optional,
-		only useful if your board does not have software
-		programmable gain)
-	[5] - analog input range highest voltage in microvolts (optional,
-		only useful if board does not have software programmable
-		gain)
-	[6] - analog output range lowest voltage in microvolts (optional)
-	[7] - analog output range highest voltage in microvolts (optional)
-	[8] - use timer mode for DMA.  Timer mode is needed e.g. for
-		buggy DMA controllers in NS CS5530A (Geode Companion), and for
-		'jr' cards that lack a hardware fifo.  This option is no
-		longer needed, since timer mode is _always_ used.
-
-Passing a zero for an option is the same as leaving it unspecified.
+ * das16.c
+ * DAS16 driver
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ * Copyright (C) 2000 Chris R. Baugher <baugher@enteract.com>
+ * Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-*/
 /*
+ * Driver: das16
+ * Description: DAS16 compatible boards
+ * Author: Sam Moore, Warren Jasper, ds, Chris Baugher, Frank Hess, Roman Fietze
+ * Devices: (Keithley Metrabyte) DAS-16 [das-16]
+ *	    (Keithley Metrabyte) DAS-16G [das-16g]
+ *	    (Keithley Metrabyte) DAS-16F [das-16f]
+ *	    (Keithley Metrabyte) DAS-1201 [das-1201]
+ *	    (Keithley Metrabyte) DAS-1202 [das-1202]
+ *	    (Keithley Metrabyte) DAS-1401 [das-1401]
+ *	    (Keithley Metrabyte) DAS-1402 [das-1402]
+ *	    (Keithley Metrabyte) DAS-1601 [das-1601]
+ *	    (Keithley Metrabyte) DAS-1602 [das-1602]
+ *	    (ComputerBoards) PC104-DAS16/JR [pc104-das16jr]
+ *	    (ComputerBoards) PC104-DAS16JR/16 [pc104-das16jr/16]
+ *	    (ComputerBoards) CIO-DAS16 [cio-das16]
+ *	    (ComputerBoards) CIO-DAS16F [cio-das16/f]
+ *	    (ComputerBoards) CIO-DAS16/JR [cio-das16/jr]
+ *	    (ComputerBoards) CIO-DAS16JR/16 [cio-das16jr/16]
+ *	    (ComputerBoards) CIO-DAS1401/12 [cio-das1401/12]
+ *	    (ComputerBoards) CIO-DAS1402/12 [cio-das1402/12]
+ *	    (ComputerBoards) CIO-DAS1402/16 [cio-das1402/16]
+ *	    (ComputerBoards) CIO-DAS1601/12 [cio-das1601/12]
+ *	    (ComputerBoards) CIO-DAS1602/12 [cio-das1602/12]
+ *	    (ComputerBoards) CIO-DAS1602/16 [cio-das1602/16]
+ *	    (ComputerBoards) CIO-DAS16/330 [cio-das16/330]
+ * Status: works
+ * Updated: 2003-10-12
+ *
+ * A rewrite of the das16 and das1600 drivers.
+ *
+ * Options:
+ *	[0] - base io address
+ *	[1] - irq (does nothing, irq is not used anymore)
+ *	[2] - dma channel (optional, required for comedi_command support)
+ *	[3] - master clock speed in MHz (optional, 1 or 10, ignored if
+ *		board can probe clock, defaults to 1)
+ *	[4] - analog input range lowest voltage in microvolts (optional,
+ *		only useful if your board does not have software
+ *		programmable gain)
+ *	[5] - analog input range highest voltage in microvolts (optional,
+ *		only useful if board does not have software programmable
+ *		gain)
+ *	[6] - analog output range lowest voltage in microvolts (optional)
+ *	[7] - analog output range highest voltage in microvolts (optional)
+ *
+ * Passing a zero for an option is the same as leaving it unspecified.
+ */
 
-Testing and debugging help provided by Daniel Koch.
-
-Keithley Manuals:
-	2309.PDF (das16)
-	4919.PDF (das1400, 1600)
-	4922.PDF (das-1400)
-	4923.PDF (das1200, 1400, 1600)
-
-Computer boards manuals also available from their website
-www.measurementcomputing.com
-
-*/
+/*
+ * Testing and debugging help provided by Daniel Koch.
+ *
+ * Keithley Manuals:
+ *	2309.PDF (das16)
+ *	4919.PDF (das1400, 1600)
+ *	4922.PDF (das-1400)
+ *	4923.PDF (das1200, 1400, 1600)
+ *
+ * Computer boards manuals also available from their website
+ * www.measurementcomputing.com
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>

commit 27b579be13a4edbb71eeec2d16748a28e788888a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:08:13 2013 -0700

    staging: comedi: das16: remove some unnecessary parentheses
    
    These parentheses are not necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index da640803d825..599be27d1570 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -668,9 +668,9 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned int tmp = cmd->scan_begin_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-					       &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd->scan_begin_arg),
+					       &devpriv->divisor1,
+					       &devpriv->divisor2,
+					       &cmd->scan_begin_arg,
 					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->scan_begin_arg);
 	}
@@ -678,9 +678,9 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned int tmp = cmd->convert_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-					       &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd->convert_arg),
+					       &devpriv->divisor1,
+					       &devpriv->divisor2,
+					       &cmd->convert_arg,
 					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->convert_arg);
 	}
@@ -717,8 +717,10 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 	struct das16_private_struct *devpriv = dev->private;
 	unsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;
 
-	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
-				       &(devpriv->divisor2), &ns,
+	i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
+				       &devpriv->divisor1,
+				       &devpriv->divisor2,
+				       &ns,
 				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
@@ -1072,7 +1074,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 		release_dma_lock(flags);
 
-		init_timer(&(devpriv->timer));
+		init_timer(&devpriv->timer);
 		devpriv->timer.function = das16_timer_interrupt;
 		devpriv->timer.data = (unsigned long)dev;
 	}

commit 05591eaf71a9c2ad57e2d59a398ade423a9bda00
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:07:53 2013 -0700

    staging: comedi: das16: tidy up user ai/ao range initialization
    
    The allocation of the user range tables could fail. Make sure to check
    for it.
    
    Change the kmalloc()'s to kzalloc()'s to make sure the allocated range
    tables are initialized to a known state.
    
    Change the local variables so they can be used for both the ai and ao
    range initialization and use shorter names to keep the lines < 80 chars.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 00ecb3c010d7..da640803d825 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -987,8 +987,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
-	struct comedi_krange *user_ai_range;
-	struct comedi_krange *user_ao_range;
+	struct comedi_lrange *lrange;
+	struct comedi_krange *krange;
 	unsigned int dma_chan = it->options[2];
 	unsigned int status;
 	int ret;
@@ -1077,32 +1077,37 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->timer.data = (unsigned long)dev;
 	}
 
-	/*  get any user-defined input range */
+	/* get any user-defined input range */
 	if (board->ai_pg == das16_pg_none &&
 	    (it->options[4] || it->options[5])) {
-		/*  allocate single-range range table */
-		devpriv->user_ai_range_table =
-		    kmalloc(sizeof(struct comedi_lrange) +
-			    sizeof(struct comedi_krange), GFP_KERNEL);
-		/*  initialize ai range */
-		devpriv->user_ai_range_table->length = 1;
-		user_ai_range = devpriv->user_ai_range_table->range;
-		user_ai_range->min = it->options[4];
-		user_ai_range->max = it->options[5];
-		user_ai_range->flags = UNIT_volt;
+		/* allocate single-range range table */
+		lrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);
+		if (!lrange)
+			return -ENOMEM;
+
+		/* initialize ai range */
+		devpriv->user_ai_range_table = lrange;
+		lrange->length = 1;
+		krange = devpriv->user_ai_range_table->range;
+		krange->min = it->options[4];
+		krange->max = it->options[5];
+		krange->flags = UNIT_volt;
 	}
-	/*  get any user-defined output range */
+
+	/* get any user-defined output range */
 	if (it->options[6] || it->options[7]) {
-		/*  allocate single-range range table */
-		devpriv->user_ao_range_table =
-		    kmalloc(sizeof(struct comedi_lrange) +
-			    sizeof(struct comedi_krange), GFP_KERNEL);
-		/*  initialize ao range */
-		devpriv->user_ao_range_table->length = 1;
-		user_ao_range = devpriv->user_ao_range_table->range;
-		user_ao_range->min = it->options[6];
-		user_ao_range->max = it->options[7];
-		user_ao_range->flags = UNIT_volt;
+		/* allocate single-range range table */
+		lrange = kzalloc(sizeof(*lrange) + sizeof(*krange), GFP_KERNEL);
+		if (!lrange)
+			return -ENOMEM;
+
+		/* initialize ao range */
+		devpriv->user_ao_range_table = lrange;
+		lrange->length = 1;
+		krange = devpriv->user_ao_range_table->range;
+		krange->min = it->options[6];
+		krange->max = it->options[7];
+		krange->flags = UNIT_volt;
 	}
 
 	ret = comedi_alloc_subdevices(dev, 4 + board->has_8255);

commit 3ffb03e62a12d82f7ce1b1aaa471f780e2e42743
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:07:30 2013 -0700

    staging: comedi: das16: remove an unnecessary check in the attach
    
    If the user does not specify the analog output range the private data
    'user_ao_range_table' will not be allocated. The comedi core will detect
    the NULL s->range_table and automatically set it to &range_unknown.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 9944f715b5da..00ecb3c010d7 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1148,11 +1148,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags	= SDF_WRITABLE;
 		s->n_chan	= 2;
 		s->maxdata	= 0x0fff;
-		if (devpriv->user_ao_range_table)
-			s->range_table	= devpriv->user_ao_range_table;
-		else
-			s->range_table	= &range_unknown;
-
+		s->range_table	= devpriv->user_ao_range_table;
 		s->insn_write	= das16_ao_insn_write;
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;

commit cb09d912e29605bc5a7bc6a204dda8c8f01cf10d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:07:10 2013 -0700

    staging: comedi: das16: fix das16_detach()
    
    The function das16_reset() needs a valid dev->iobase. Since the iobase
    is requested after the devpriv has been allocated in the attach, move
    the das16_reset() call into the if (devpriv) and add a if (dev->iobase).
    
    Also, move the release of the extra iobase into the if (devpriv) to
    prevent an invalid memory access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 60895e658c43..9944f715b5da 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1206,10 +1206,12 @@ static void das16_detach(struct comedi_device *dev)
 {
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
+	int i;
 
-	das16_reset(dev);
 	if (devpriv) {
-		int i;
+		if (dev->iobase)
+			das16_reset(dev);
+
 		for (i = 0; i < 2; i++) {
 			if (devpriv->dma_buffer[i])
 				pci_free_consistent(NULL, DAS16_DMA_SIZE,
@@ -1221,9 +1223,12 @@ static void das16_detach(struct comedi_device *dev)
 			free_dma(devpriv->dma_chan);
 		kfree(devpriv->user_ai_range_table);
 		kfree(devpriv->user_ao_range_table);
+
+		if (devpriv->extra_iobase)
+			release_region(devpriv->extra_iobase,
+				       board->size & 0x3ff);
 	}
-	if (devpriv->extra_iobase)
-		release_region(devpriv->extra_iobase, board->size & 0x3ff);
+
 	comedi_legacy_detach(dev);
 }
 

commit efb623168225ee2f49b607d5aaca15caed20e8e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:06:52 2013 -0700

    staging: comedi: das16: change MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something useful instead of the
    generic "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index e7b7bcd9220c..60895e658c43 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1239,5 +1239,5 @@ static struct comedi_driver das16_driver = {
 module_comedi_driver(das16_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for DAS16 compatible boards");
 MODULE_LICENSE("GPL");

commit 10206ef6328609cbb07b8c5b09cedfaa339c4d42
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:06:34 2013 -0700

    staging: comedi: das16: tidy up private data definition
    
    Remove the comments and add some whitespace to help readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index fb3e0e07551d..e7b7bcd9220c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -443,30 +443,22 @@ static inline int timer_period(void)
 }
 
 struct das16_private_struct {
-	unsigned int clockbase;	/*  master clock speed in ns */
-	unsigned int ctrl_reg;
-	unsigned long adc_byte_count;	/*  number of bytes remaining */
-	/*  divisor dividing master clock to get conversion frequency */
-	unsigned int divisor1;
-	/*  divisor dividing master clock to get conversion frequency */
-	unsigned int divisor2;
-	unsigned int dma_chan;	/*  dma channel */
-	uint16_t *dma_buffer[2];
-	dma_addr_t dma_buffer_addr[2];
-	unsigned int current_buffer;
-	unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
-	/**
-	 * user-defined analog input and output ranges
-	 * defined from config options
-	 */
-	struct comedi_lrange *user_ai_range_table;
-	struct comedi_lrange *user_ao_range_table;
-
-	struct timer_list timer;	/*  for timed interrupt */
-	short timer_running;
-
-	unsigned long extra_iobase;
-	unsigned int can_burst:1;
+	unsigned int		clockbase;
+	unsigned int		ctrl_reg;
+	unsigned long		adc_byte_count;
+	unsigned int		divisor1;
+	unsigned int		divisor2;
+	unsigned int		dma_chan;
+	uint16_t		*dma_buffer[2];
+	dma_addr_t		dma_buffer_addr[2];
+	unsigned int		current_buffer;
+	unsigned int		dma_transfer_size;
+	struct comedi_lrange	*user_ai_range_table;
+	struct comedi_lrange	*user_ao_range_table;
+	struct timer_list	timer;
+	short			timer_running;
+	unsigned long		extra_iobase;
+	unsigned int		can_burst:1;
 };
 
 static void das16_ai_enable(struct comedi_device *dev,

commit c04fc1a5898bb2ea7ba884bf747e17f548897afb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:06:16 2013 -0700

    staging: comedi: das16: cleanup comedi_error() messages
    
    Some of these messages are missing the terminating '\n' and most of them
    have the quoted string split across lines.
    
    Change all of them to dev_err() messages and fix the issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c4f0853c7247..fb3e0e07551d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -527,8 +527,8 @@ static int disable_dma_on_even(struct comedi_device *dev)
 		residue = get_dma_residue(devpriv->dma_chan);
 	}
 	if (i == disable_limit) {
-		comedi_error(dev, "failed to get an even dma transfer, "
-							"could be trouble.");
+		dev_err(dev->class_dev,
+			"failed to get an even dma transfer, could be trouble\n");
 	}
 	return residue;
 }
@@ -556,7 +556,7 @@ static void das16_interrupt(struct comedi_device *dev)
 
 	/*  figure out how many points to read */
 	if (residue > devpriv->dma_transfer_size) {
-		comedi_error(dev, "residue > transfer size!\n");
+		dev_err(dev->class_dev, "residue > transfer size!\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		num_bytes = 0;
 	} else
@@ -702,16 +702,13 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
 			    (start_chan + i) % s->n_chan) {
-				comedi_error(dev,
-						"entries in chanlist must be "
-						"consecutive channels, "
-						"counting upwards\n");
+				dev_err(dev->class_dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
-				comedi_error(dev,
-						"entries in chanlist must all "
-						"have the same gain\n");
+				dev_err(dev->class_dev,
+					"entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -750,8 +747,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	int range;
 
 	if (cmd->flags & TRIG_RT) {
-		comedi_error(dev, "isa dma transfers cannot be performed with "
-							"TRIG_RT, aborting");
+		dev_err(dev->class_dev,
+			 "isa dma transfers cannot be performed with TRIG_RT, aborting\n");
 		return -1;
 	}
 

commit 0541144e80e95265325160385bd267ecf9216ed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:05:59 2013 -0700

    staging: comedi: das16: fix a > 80 char line issue
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 7dae83e1f96a..c4f0853c7247 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -784,7 +784,8 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	byte = 0;
 	if (devpriv->can_burst) {
 		if (cmd->convert_src == TRIG_NOW) {
-			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST_REG);
+			outb(DAS1600_BURST_VAL,
+			     dev->iobase + DAS1600_BURST_REG);
 			/*  set burst length */
 			byte |= DAS16_PACER_BURST_LEN(cmd->chanlist_len - 1);
 		} else {

commit f2e92ee1af58128b554203fafbbd2ae37f694fec
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:05:37 2013 -0700

    staging: comedi: das16: absorb das1600_mode_detect() into caller
    
    This function is only called during the board attach to determine the
    pacer clock speed for the boards capable of bursting.
    
    Absorb it into the caller and remove the attach noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2169cd728655..7dae83e1f96a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -984,24 +984,6 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-static int das1600_mode_detect(struct comedi_device *dev)
-{
-	struct das16_private_struct *devpriv = dev->private;
-	int status = 0;
-
-	status = inb(dev->iobase + DAS1600_STATUS_REG);
-
-	if (status & DAS1600_STATUS_CLK_10MHZ) {
-		devpriv->clockbase = 100;
-		printk(KERN_INFO " 10MHz pacer clock\n");
-	} else {
-		devpriv->clockbase = 1000;
-		printk(KERN_INFO " 1MHz pacer clock\n");
-	}
-
-	return 0;
-}
-
 static void das16_reset(struct comedi_device *dev)
 {
 	outb(0, dev->iobase + DAS16_STATUS_REG);
@@ -1058,7 +1040,12 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  get master clock speed */
 	if (devpriv->can_burst) {
-		das1600_mode_detect(dev);
+		status = inb(dev->iobase + DAS1600_STATUS_REG);
+
+		if (status & DAS1600_STATUS_CLK_10MHZ)
+			devpriv->clockbase = 100;
+		else
+			devpriv->clockbase = 1000;
 	} else {
 		if (it->options[3])
 			devpriv->clockbase = 1000 / it->options[3];

commit ccb26aa72c9a5e7bf95ec148c734ca0821331922
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:05:20 2013 -0700

    staging: comedi: das16: cleanup printk message in board attach
    
    Convert this printk message into a dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 8f4b3dd3170f..2169cd728655 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1025,9 +1025,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
 		    it->options[3] != 1 && it->options[3] != 10) {
-			printk
-			    ("\n Invalid option.  Master clock must be set "
-							"to 1 or 10 (MHz)\n");
+			dev_err(dev->class_dev,
+				"Invalid option. Master clock must be set to 1 or 10 (MHz)\n");
 			return -EINVAL;
 		}
 	}

commit b08c4015e6042113625d92f9e3e32bdaa652bf76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:05:00 2013 -0700

    staging: comedi: das16: fail attach if board id is incorrect
    
    This driver probes the board id during the attach to ensure that the
    user is attempting to attach to the correct board type. Currently an
    error message is output if the ids are not consistent but the attach
    continues anyway.
    
    Make the attach fail if the id bits do not match. Also, cleanup the
    printk messages and use a dev_err() only if the probe fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 97ba2bd88485..8f4b3dd3170f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -974,11 +974,11 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* diobits indicates boards */
 	diobits = inb(dev->iobase + DAS16_DIO_REG) & 0xf0;
-
-	printk(KERN_INFO " id bits are 0x%02x\n", diobits);
 	if (board->id != diobits) {
-		printk(KERN_INFO " requested board's id bits are 0x%x (ignore)\n",
-		       board->id);
+		dev_err(dev->class_dev,
+			"requested board's id bits are incorrect (0x%x != 0x%x)\n",
+			board->id, diobits);
+		return -EINVAL;
 	}
 
 	return 0;
@@ -1054,10 +1054,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/*  probe id bits to make sure they are consistent */
-	if (das16_probe(dev, it)) {
-		printk(KERN_ERR " id bits do not match selected board, aborting\n");
+	if (das16_probe(dev, it))
 		return -EINVAL;
-	}
 
 	/*  get master clock speed */
 	if (devpriv->can_burst) {

commit 0f13a8d02741f3fd301c5c0184e2c2d734f31a85
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:04:41 2013 -0700

    staging: comedi: das16: tidy up the register map defines
    
    Add the suffix _REG to all the register defines to better indicate
    what they are.
    
    Add a prefix to all the register bit defines to avoid namespace clashes
    and to better indicate what they are.
    
    Tidy up the whitesapce.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 8da7ee34d57d..97ba2bd88485 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -91,55 +91,45 @@ www.measurementcomputing.com
 /*
  * Register I/O map
  */
-#define DAS16_TRIG		0
-#define DAS16_AI_LSB		0
-#define DAS16_AI_MSB		1
-#define DAS16_MUX		2
-#define DAS16_DIO		3
-#define DAS16_AO_LSB(x)	((x) ? 6 : 4)
-#define DAS16_AO_MSB(x)	((x) ? 7 : 5)
-#define DAS16_STATUS		8
-#define   BUSY			(1<<7)
-#define   UNIPOLAR			(1<<6)
-#define   DAS16_MUXBIT			(1<<5)
-#define   DAS16_INT			(1<<4)
-#define DAS16_CONTROL		9
-#define   DAS16_INTE			(1<<7)
-#define   DAS16_IRQ(x)			(((x) & 0x7) << 4)
-#define   DMA_ENABLE			(1<<2)
-#define   PACING_MASK	0x3
-#define   INT_PACER		0x03
-#define   EXT_PACER			0x02
-#define   DAS16_SOFT		0x00
-#define DAS16_PACER		0x0A
-#define   DAS16_CTR0			(1<<1)
-#define   DAS16_TRIG0			(1<<0)
-#define   BURST_LEN_BITS(x)			(((x) & 0xf) << 4)
-#define DAS16_GAIN		0x0B
-#define DAS16_CNTR0_DATA		0x0C
-#define DAS16_CNTR1_DATA		0x0D
-#define DAS16_CNTR2_DATA		0x0E
-#define DAS16_CNTR_CONTROL	0x0F
-#define   DAS16_TERM_CNT	0x00
-#define   DAS16_ONE_SHOT	0x02
-#define   DAS16_RATE_GEN	0x04
-#define   DAS16_CNTR_LSB_MSB	0x30
-#define   DAS16_CNTR0		0x00
-#define   DAS16_CNTR1		0x40
-#define   DAS16_CNTR2		0x80
-
-#define DAS1600_CONV		0x404
-#define   DAS1600_CONV_DISABLE		0x40
-#define DAS1600_BURST		0x405
-#define   DAS1600_BURST_VAL		0x40
-#define DAS1600_ENABLE		0x406
-#define   DAS1600_ENABLE_VAL		0x40
-#define DAS1600_STATUS_B	0x407
-#define   DAS1600_BME		0x40
-#define   DAS1600_ME		0x20
-#define   DAS1600_CD			0x10
-#define   DAS1600_WS			0x02
-#define   DAS1600_CLK_10MHZ		0x01
+#define DAS16_TRIG_REG			0x00
+#define DAS16_AI_LSB_REG		0x00
+#define DAS16_AI_MSB_REG		0x01
+#define DAS16_MUX_REG			0x02
+#define DAS16_DIO_REG			0x03
+#define DAS16_AO_LSB_REG(x)		((x) ? 0x06 : 0x04)
+#define DAS16_AO_MSB_REG(x)		((x) ? 0x07 : 0x05)
+#define DAS16_STATUS_REG		0x08
+#define DAS16_STATUS_BUSY		(1 << 7)
+#define DAS16_STATUS_UNIPOLAR		(1 << 6)
+#define DAS16_STATUS_MUXBIT		(1 << 5)
+#define DAS16_STATUS_INT		(1 << 4)
+#define DAS16_CTRL_REG			0x09
+#define DAS16_CTRL_INTE			(1 << 7)
+#define DAS16_CTRL_IRQ(x)		(((x) & 0x7) << 4)
+#define DAS16_CTRL_DMAE			(1 << 2)
+#define DAS16_CTRL_PACING_MASK		(3 << 0)
+#define DAS16_CTRL_INT_PACER		(3 << 0)
+#define DAS16_CTRL_EXT_PACER		(2 << 0)
+#define DAS16_CTRL_SOFT_PACER		(0 << 0)
+#define DAS16_PACER_REG			0x0a
+#define DAS16_PACER_BURST_LEN(x)	(((x) & 0xf) << 4)
+#define DAS16_PACER_CTR0		(1 << 1)
+#define DAS16_PACER_TRIG0		(1 << 0)
+#define DAS16_GAIN_REG			0x0b
+#define DAS16_TIMER_BASE_REG		0x0c	/* to 0x0f */
+
+#define DAS1600_CONV_REG		0x404
+#define DAS1600_CONV_DISABLE		(1 << 6)
+#define DAS1600_BURST_REG		0x405
+#define DAS1600_BURST_VAL		(1 << 6)
+#define DAS1600_ENABLE_REG		0x406
+#define DAS1600_ENABLE_VAL		(1 << 6)
+#define DAS1600_STATUS_REG		0x407
+#define DAS1600_STATUS_BME		(1 << 6)
+#define DAS1600_STATUS_ME		(1 << 5)
+#define DAS1600_STATUS_CD		(1 << 4)
+#define DAS1600_STATUS_WS		(1 << 1)
+#define DAS1600_STATUS_CLK_10MHZ	(1 << 0)
 
 static const struct comedi_lrange range_das1x01_bip = {
 	4, {
@@ -484,14 +474,16 @@ static void das16_ai_enable(struct comedi_device *dev,
 {
 	struct das16_private_struct *devpriv = dev->private;
 
-	devpriv->ctrl_reg &= ~(DAS16_INTE | DMA_ENABLE | PACING_MASK);
+	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |
+			       DAS16_CTRL_DMAE |
+			       DAS16_CTRL_PACING_MASK);
 	devpriv->ctrl_reg |= mode;
 
 	if (src == TRIG_EXT)
-		devpriv->ctrl_reg |= EXT_PACER;
+		devpriv->ctrl_reg |= DAS16_CTRL_EXT_PACER;
 	else
-		devpriv->ctrl_reg |= INT_PACER;
-	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
+		devpriv->ctrl_reg |= DAS16_CTRL_INT_PACER;
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
 }
 
 static void das16_ai_disable(struct comedi_device *dev)
@@ -499,8 +491,10 @@ static void das16_ai_disable(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 
 	/* disable interrupts, dma and pacer clocked conversions */
-	devpriv->ctrl_reg &= ~(DAS16_INTE | DMA_ENABLE | PACING_MASK);
-	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
+	devpriv->ctrl_reg &= ~(DAS16_CTRL_INTE |
+			       DAS16_CTRL_DMAE |
+			       DAS16_CTRL_PACING_MASK);
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
 }
 
 /* the pc104-das16jr (at least) has problems if the dma
@@ -551,7 +545,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	int buffer_index;
 
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
-	if ((devpriv->ctrl_reg & DMA_ENABLE) == 0) {
+	if (!(devpriv->ctrl_reg & DAS16_CTRL_DMAE)) {
 		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 		return;
 	}
@@ -732,14 +726,15 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 				    int rounding_flags)
 {
 	struct das16_private_struct *devpriv = dev->private;
+	unsigned long timer_base = dev->iobase + DAS16_TIMER_BASE_REG;
 
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
 				       &(devpriv->divisor2), &ns,
 				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
-	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 2, devpriv->divisor2, 2);
+	i8254_load(timer_base, 0, 1, devpriv->divisor1, 2);
+	i8254_load(timer_base, 0, 2, devpriv->divisor2, 2);
 
 	return ns;
 }
@@ -764,12 +759,12 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
 	if (devpriv->can_burst)
-		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
+		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);
 
 	/*  set scan limits */
 	byte = CR_CHAN(cmd->chanlist[0]);
 	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
-	outb(byte, dev->iobase + DAS16_MUX);
+	outb(byte, dev->iobase + DAS16_MUX_REG);
 
 	/* set gain (this is also burst rate register but according to
 	 * computer boards manual, burst rate does nothing, even on
@@ -777,7 +772,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (board->ai_pg != das16_pg_none) {
 		range = CR_RANGE(cmd->chanlist[0]);
 		outb((das16_gainlists[board->ai_pg])[range],
-		     dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN_REG);
 	}
 
 	/* set counter mode and counts */
@@ -789,14 +784,14 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	byte = 0;
 	if (devpriv->can_burst) {
 		if (cmd->convert_src == TRIG_NOW) {
-			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
+			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST_REG);
 			/*  set burst length */
-			byte |= BURST_LEN_BITS(cmd->chanlist_len - 1);
+			byte |= DAS16_PACER_BURST_LEN(cmd->chanlist_len - 1);
 		} else {
-			outb(0, dev->iobase + DAS1600_BURST);
+			outb(0, dev->iobase + DAS1600_BURST_REG);
 		}
 	}
-	outb(byte, dev->iobase + DAS16_PACER);
+	outb(byte, dev->iobase + DAS16_PACER_REG);
 
 	/*  set up dma transfer */
 	flags = claim_dma_lock();
@@ -817,10 +812,10 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->timer.expires = jiffies + timer_period();
 	add_timer(&devpriv->timer);
 
-	das16_ai_enable(dev, DMA_ENABLE, cmd->convert_src);
+	das16_ai_enable(dev, DAS16_CTRL_DMAE, cmd->convert_src);
 
 	if (devpriv->can_burst)
-		outb(0, dev->iobase + DAS1600_CONV);
+		outb(0, dev->iobase + DAS1600_CONV_REG);
 
 	return 0;
 }
@@ -842,7 +837,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	if (devpriv->can_burst)
-		outb(0, dev->iobase + DAS1600_BURST);
+		outb(0, dev->iobase + DAS1600_BURST_REG);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -872,8 +867,8 @@ static int das16_ai_wait_for_conv(struct comedi_device *dev,
 	int i;
 
 	for (i = 0; i < timeout; i++) {
-		status = inb(dev->iobase + DAS16_STATUS);
-		if (!(status & BUSY))
+		status = inb(dev->iobase + DAS16_STATUS_REG);
+		if (!(status & DAS16_STATUS_BUSY))
 			return 0;
 	}
 	return -ETIME;
@@ -894,24 +889,24 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	das16_ai_disable(dev);
 
 	/* set multiplexer */
-	outb(chan | (chan << 4), dev->iobase + DAS16_MUX);
+	outb(chan | (chan << 4), dev->iobase + DAS16_MUX_REG);
 
 	/* set gain */
 	if (board->ai_pg != das16_pg_none) {
 		outb((das16_gainlists[board->ai_pg])[range],
-		     dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN_REG);
 	}
 
 	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
-		outb_p(0, dev->iobase + DAS16_TRIG);
+		outb_p(0, dev->iobase + DAS16_TRIG_REG);
 
 		ret = das16_ai_wait_for_conv(dev, 1000);
 		if (ret)
 			return ret;
 
-		val = inb(dev->iobase + DAS16_AI_MSB) << 8;
-		val |= inb(dev->iobase + DAS16_AI_LSB);
+		val = inb(dev->iobase + DAS16_AI_MSB_REG) << 8;
+		val |= inb(dev->iobase + DAS16_AI_LSB_REG);
 		if (s->maxdata == 0x0fff)
 			val >>= 4;
 		val &= s->maxdata;
@@ -935,8 +930,8 @@ static int das16_ao_insn_write(struct comedi_device *dev,
 		val = data[i];
 		val <<= 4;
 
-		outb(val & 0xff, dev->iobase + DAS16_AO_LSB(chan));
-		outb((val >> 8) & 0xff, dev->iobase + DAS16_AO_MSB(chan));
+		outb(val & 0xff, dev->iobase + DAS16_AO_LSB_REG(chan));
+		outb((val >> 8) & 0xff, dev->iobase + DAS16_AO_MSB_REG(chan));
 	}
 
 	return insn->n;
@@ -947,7 +942,7 @@ static int das16_di_insn_bits(struct comedi_device *dev,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
-	data[1] = inb(dev->iobase + DAS16_DIO) & 0xf;
+	data[1] = inb(dev->iobase + DAS16_DIO_REG) & 0xf;
 
 	return insn->n;
 }
@@ -964,7 +959,7 @@ static int das16_do_insn_bits(struct comedi_device *dev,
 		s->state &= ~mask;
 		s->state |= (bits & mask);
 
-		outb(s->state, dev->iobase + DAS16_DIO);
+		outb(s->state, dev->iobase + DAS16_DIO_REG);
 	}
 
 	data[1] = s->state;
@@ -978,7 +973,7 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 	int diobits;
 
 	/* diobits indicates boards */
-	diobits = inb(dev->iobase + DAS16_DIO) & 0xf0;
+	diobits = inb(dev->iobase + DAS16_DIO_REG) & 0xf0;
 
 	printk(KERN_INFO " id bits are 0x%02x\n", diobits);
 	if (board->id != diobits) {
@@ -994,9 +989,9 @@ static int das1600_mode_detect(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 	int status = 0;
 
-	status = inb(dev->iobase + DAS1600_STATUS_B);
+	status = inb(dev->iobase + DAS1600_STATUS_REG);
 
-	if (status & DAS1600_CLK_10MHZ) {
+	if (status & DAS1600_STATUS_CLK_10MHZ) {
 		devpriv->clockbase = 100;
 		printk(KERN_INFO " 10MHz pacer clock\n");
 	} else {
@@ -1009,10 +1004,10 @@ static int das1600_mode_detect(struct comedi_device *dev)
 
 static void das16_reset(struct comedi_device *dev)
 {
-	outb(0, dev->iobase + DAS16_STATUS);
-	outb(0, dev->iobase + DAS16_CONTROL);
-	outb(0, dev->iobase + DAS16_PACER);
-	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
+	outb(0, dev->iobase + DAS16_STATUS_REG);
+	outb(0, dev->iobase + DAS16_CTRL_REG);
+	outb(0, dev->iobase + DAS16_PACER_REG);
+	outb(0, dev->iobase + DAS16_TIMER_BASE_REG + i8254_control_reg);
 }
 
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -1140,13 +1135,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	status = inb(dev->iobase + DAS16_STATUS);
+	status = inb(dev->iobase + DAS16_STATUS_REG);
 
 	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE;
-	if (status & DAS16_MUXBIT) {
+	if (status & DAS16_STATUS_MUXBIT) {
 		s->subdev_flags	|= SDF_GROUND;
 		s->n_chan	= 16;
 	} else {
@@ -1157,7 +1152,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= board->ai_maxdata;
 	if (devpriv->user_ai_range_table) { /*  user defined ai range */
 		s->range_table	= devpriv->user_ai_range_table;
-	} else if (status & UNIPOLAR) {
+	} else if (status & DAS16_STATUS_UNIPOLAR) {
 		s->range_table	= das16_ai_uni_lranges[board->ai_pg];
 	} else {
 		s->range_table	= das16_ai_bip_lranges[board->ai_pg];
@@ -1208,7 +1203,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits	= das16_do_insn_bits;
 
 	/* initialize digital output lines */
-	outb(s->state, dev->iobase + DAS16_DIO);
+	outb(s->state, dev->iobase + DAS16_DIO_REG);
 
 	/* 8255 Digital I/O subdevice */
 	if (board->has_8255) {
@@ -1221,13 +1216,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	das16_reset(dev);
 	/* set the interrupt level */
-	devpriv->ctrl_reg = DAS16_IRQ(dev->irq);
-	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
+	devpriv->ctrl_reg = DAS16_CTRL_IRQ(dev->irq);
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);
 
 	if (devpriv->can_burst) {
-		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
-		outb(0, dev->iobase + DAS1600_CONV);
-		outb(0, dev->iobase + DAS1600_BURST);
+		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE_REG);
+		outb(0, dev->iobase + DAS1600_CONV_REG);
+		outb(0, dev->iobase + DAS1600_BURST_REG);
 	}
 
 	return 0;

commit 21b8f248976f7270595f27e878f0026baf99e6e3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:04:13 2013 -0700

    staging: comedi: das16: tidy up 8255 digital i/o subdevice
    
    The 8255 digital i/o subdevice is only available on some of the boards
    supported by this driver. Currently the 'i8255_offset' member of the
    boardinfo is used to indicate that it is available.
    
    To clarify this support, add a 'has_8255' bit-field flag to the boardinfo.
    We can then use this flag to conditionally allocate the space for the
    subdevice only when it is needed.
    
    Also, make sure to check that subdev_8255_init() is successful and propagate
    any errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c7b664ae5c79..8da7ee34d57d 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -245,6 +245,7 @@ struct das16_board {
 	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
 	unsigned int has_ao:1;
+	unsigned int has_8255:1;
 
 	unsigned int i8255_offset;
 
@@ -259,6 +260,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x10,
 		.size		= 0x14,
 		.id		= 0x00,
@@ -268,6 +270,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x10,
 		.size		= 0x14,
 		.id		= 0x00,
@@ -277,6 +280,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 8500,
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x10,
 		.size		= 0x14,
 		.id		= 0x00,
@@ -286,6 +290,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x10,
 		.size		= 0x14,
 		.id		= 0x80,
@@ -295,6 +300,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x10,
 		.size		= 0x14,
 		.id		= 0x80,
@@ -303,7 +309,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -311,7 +316,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -319,7 +323,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
-		.i8255_offset	= 0,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -327,7 +330,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
-		.i8255_offset	= 0,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -335,6 +337,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0x20,
@@ -343,6 +346,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0x20,
@@ -351,7 +355,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
-		.i8255_offset	= 0x0,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -359,7 +362,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0x0,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -368,6 +370,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0xc0,
@@ -377,6 +380,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0xc0,
@@ -385,7 +389,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
-		.i8255_offset	= 0,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -393,7 +396,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -401,7 +403,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -410,6 +411,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0xc0,
@@ -419,6 +421,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0xc0,
@@ -428,6 +431,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
+		.has_8255	= 1,
 		.i8255_offset	= 0x400,
 		.size		= 0x408,
 		.id		= 0xc0,
@@ -436,7 +440,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
 		.size		= 0x14,
 		.id		= 0xf0,
 	},
@@ -1133,7 +1136,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		user_ao_range->flags = UNIT_volt;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 5);
+	ret = comedi_alloc_subdevices(dev, 4 + board->has_8255);
 	if (ret)
 		return ret;
 
@@ -1207,13 +1210,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* initialize digital output lines */
 	outb(s->state, dev->iobase + DAS16_DIO);
 
-	s = &dev->subdevices[4];
-	/* 8255 */
-	if (board->i8255_offset != 0) {
-		subdev_8255_init(dev, s, NULL, (dev->iobase +
-						board->i8255_offset));
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+	/* 8255 Digital I/O subdevice */
+	if (board->has_8255) {
+		s = &dev->subdevices[4];
+		ret = subdev_8255_init(dev, s, NULL,
+				       dev->iobase + board->i8255_offset);
+		if (ret)
+			return ret;
 	}
 
 	das16_reset(dev);

commit 22cfc772f5e55341708ac31881df69e233787b8a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:03:46 2013 -0700

    staging: comedi: das16: remove 'i8254_offset' from boardinfo
    
    All the boards supported by this driver have an 8254 timer at offset
    0x0c. Remove this unused information from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index b04b3ae6bf03..c7b664ae5c79 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -247,7 +247,6 @@ struct das16_board {
 	unsigned int has_ao:1;
 
 	unsigned int i8255_offset;
-	unsigned int i8254_offset;
 
 	unsigned int size;
 	unsigned int id;
@@ -261,7 +260,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
 		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0x00,
 	}, {
@@ -271,7 +269,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
 		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0x00,
 	}, {
@@ -281,7 +278,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
 		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0x00,
 	}, {
@@ -291,7 +287,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
 		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0x80,
 	}, {
@@ -301,7 +296,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.has_ao		= 1,
 		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0x80,
 	}, {
@@ -310,7 +304,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -319,7 +312,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -328,7 +320,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -337,7 +328,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x10,
 		.id		= 0x00,
 	}, {
@@ -346,7 +336,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0x20,
 	}, {
@@ -355,7 +344,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0x20,
 	}, {
@@ -364,7 +352,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.i8255_offset	= 0x0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -373,7 +360,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.i8255_offset	= 0x0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -383,7 +369,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.has_ao		= 1,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -393,7 +378,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -402,7 +386,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -411,7 +394,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -420,7 +402,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -430,7 +411,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.has_ao		= 1,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -440,7 +420,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -450,7 +429,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.has_ao		= 1,
 		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
 		.size		= 0x408,
 		.id		= 0xc0,
 	}, {
@@ -459,7 +437,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
 		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
 		.size		= 0x14,
 		.id		= 0xf0,
 	},

commit 46399a84b730d9c27e9e967eabe45d280ee79163
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:03:28 2013 -0700

    staging: comedi: das16: move boardinfo declaration
    
    Now that the boardinfo does not require any forward declarations,
    move it near the definition of the struct.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index df7bf1e26c5e..b04b3ae6bf03 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -253,6 +253,218 @@ struct das16_board {
 	unsigned int id;
 };
 
+static const struct das16_board das16_boards[] = {
+	{
+		.name		= "das-16",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 15000,
+		.ai_pg		= das16_pg_none,
+		.has_ao		= 1,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "das-16g",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 15000,
+		.ai_pg		= das16_pg_none,
+		.has_ao		= 1,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "das-16f",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 8500,
+		.ai_pg		= das16_pg_none,
+		.has_ao		= 1,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "cio-das16",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 20000,
+		.ai_pg		= das16_pg_none,
+		.has_ao		= 1,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x80,
+	}, {
+		.name		= "cio-das16/f",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_none,
+		.has_ao		= 1,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x80,
+	}, {
+		.name		= "cio-das16/jr",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 7692,
+		.ai_pg		= das16_pg_16jr,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "pc104-das16jr",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 3300,
+		.ai_pg		= das16_pg_16jr,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "cio-das16jr/16",
+		.ai_maxdata	= 0xffff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_16jr_16,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "pc104-das16jr/16",
+		.ai_maxdata	= 0xffff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_16jr_16,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "das-1201",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 20000,
+		.ai_pg		= das16_pg_none,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0x20,
+	}, {
+		.name		= "das-1202",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_none,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0x20,
+	}, {
+		.name		= "das-1401",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1601,
+		.i8255_offset	= 0x0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1402",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.i8255_offset	= 0x0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1601",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1601,
+		.has_ao		= 1,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1602",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.has_ao		= 1,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1401/12",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1601,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1402/12",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1602,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1402/16",
+		.ai_maxdata	= 0xffff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1601/12",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1601,
+		.has_ao		= 1,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1602/12",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.has_ao		= 1,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1602/16",
+		.ai_maxdata	= 0xffff,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.has_ao		= 1,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das16/330",
+		.ai_maxdata	= 0x0fff,
+		.ai_speed	= 3030,
+		.ai_pg		= das16_pg_16jr,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0xf0,
+	},
+};
+
 /* Period for timer interrupt in jiffies.  It's a function
  * to deal with possibility of dynamic HZ patches  */
 static inline int timer_period(void)
@@ -1066,218 +1278,6 @@ static void das16_detach(struct comedi_device *dev)
 	comedi_legacy_detach(dev);
 }
 
-static const struct das16_board das16_boards[] = {
-	{
-		.name		= "das-16",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 15000,
-		.ai_pg		= das16_pg_none,
-		.has_ao		= 1,
-		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0x00,
-	}, {
-		.name		= "das-16g",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 15000,
-		.ai_pg		= das16_pg_none,
-		.has_ao		= 1,
-		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0x00,
-	}, {
-		.name		= "das-16f",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 8500,
-		.ai_pg		= das16_pg_none,
-		.has_ao		= 1,
-		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0x00,
-	}, {
-		.name		= "cio-das16",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 20000,
-		.ai_pg		= das16_pg_none,
-		.has_ao		= 1,
-		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0x80,
-	}, {
-		.name		= "cio-das16/f",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_none,
-		.has_ao		= 1,
-		.i8255_offset	= 0x10,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0x80,
-	}, {
-		.name		= "cio-das16/jr",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 7692,
-		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x10,
-		.id		= 0x00,
-	}, {
-		.name		= "pc104-das16jr",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 3300,
-		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x10,
-		.id		= 0x00,
-	}, {
-		.name		= "cio-das16jr/16",
-		.ai_maxdata	= 0xffff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_16jr_16,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x10,
-		.id		= 0x00,
-	}, {
-		.name		= "pc104-das16jr/16",
-		.ai_maxdata	= 0xffff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_16jr_16,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x10,
-		.id		= 0x00,
-	}, {
-		.name		= "das-1201",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 20000,
-		.ai_pg		= das16_pg_none,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0x20,
-	}, {
-		.name		= "das-1202",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_none,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0x20,
-	}, {
-		.name		= "das-1401",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1601,
-		.i8255_offset	= 0x0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "das-1402",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0x0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "das-1601",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1601,
-		.has_ao		= 1,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "das-1602",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1602,
-		.has_ao		= 1,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1401/12",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 6250,
-		.ai_pg		= das16_pg_1601,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1402/12",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 6250,
-		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1402/16",
-		.ai_maxdata	= 0xffff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1602,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1601/12",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 6250,
-		.ai_pg		= das16_pg_1601,
-		.has_ao		= 1,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1602/12",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1602,
-		.has_ao		= 1,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das1602/16",
-		.ai_maxdata	= 0xffff,
-		.ai_speed	= 10000,
-		.ai_pg		= das16_pg_1602,
-		.has_ao		= 1,
-		.i8255_offset	= 0x400,
-		.i8254_offset	= 0x0c,
-		.size		= 0x408,
-		.id		= 0xc0,
-	}, {
-		.name		= "cio-das16/330",
-		.ai_maxdata	= 0x0fff,
-		.ai_speed	= 3030,
-		.ai_pg		= das16_pg_16jr,
-		.i8255_offset	= 0,
-		.i8254_offset	= 0x0c,
-		.size		= 0x14,
-		.id		= 0xf0,
-	},
-};
-
 static struct comedi_driver das16_driver = {
 	.driver_name	= "das16",
 	.module		= THIS_MODULE,

commit b65daeef1d2401a18ecdcc73fa8f263cb64cdd5d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:03:11 2013 -0700

    staging: comedi: das16: remove unnecessary test in das16_interrupt()
    
    The timer is only started by the ai subdevice in das16_cmd_exec()
    and this function can only be called if the device is attached.
    
    Remove the unnecessary sanity check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index cd2fa4cafc44..df7bf1e26c5e 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -350,21 +350,14 @@ static int disable_dma_on_even(struct comedi_device *dev)
 static void das16_interrupt(struct comedi_device *dev)
 {
 	struct das16_private_struct *devpriv = dev->private;
-	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned long spin_flags;
+	unsigned long dma_flags;
 	int num_bytes, residue;
 	int buffer_index;
 
-	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
-		return;
-	}
-	/*  initialize async here to make sure it is not NULL */
-	async = s->async;
-	cmd = &async->cmd;
-
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if ((devpriv->ctrl_reg & DMA_ENABLE) == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, spin_flags);

commit 372f3bb949482c6f0a53c03942d6def634fc2804
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:02:48 2013 -0700

    staging: comedi: das16: move some functions to improve readability
    
    For aesthetics, move some of the functions to make the code easier
    to follow.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a482bd524e9b..cd2fa4cafc44 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -311,6 +311,116 @@ static void das16_ai_disable(struct comedi_device *dev)
 	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
 }
 
+/* the pc104-das16jr (at least) has problems if the dma
+	transfer is interrupted in the middle of transferring
+	a 16 bit sample, so this function takes care to get
+	an even transfer count after disabling dma
+	channel.
+*/
+static int disable_dma_on_even(struct comedi_device *dev)
+{
+	struct das16_private_struct *devpriv = dev->private;
+	int residue;
+	int i;
+	static const int disable_limit = 100;
+	static const int enable_timeout = 100;
+
+	disable_dma(devpriv->dma_chan);
+	residue = get_dma_residue(devpriv->dma_chan);
+	for (i = 0; i < disable_limit && (residue % 2); ++i) {
+		int j;
+		enable_dma(devpriv->dma_chan);
+		for (j = 0; j < enable_timeout; ++j) {
+			int new_residue;
+			udelay(2);
+			new_residue = get_dma_residue(devpriv->dma_chan);
+			if (new_residue != residue)
+				break;
+		}
+		disable_dma(devpriv->dma_chan);
+		residue = get_dma_residue(devpriv->dma_chan);
+	}
+	if (i == disable_limit) {
+		comedi_error(dev, "failed to get an even dma transfer, "
+							"could be trouble.");
+	}
+	return residue;
+}
+
+static void das16_interrupt(struct comedi_device *dev)
+{
+	struct das16_private_struct *devpriv = dev->private;
+	unsigned long dma_flags, spin_flags;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async;
+	struct comedi_cmd *cmd;
+	int num_bytes, residue;
+	int buffer_index;
+
+	if (!dev->attached) {
+		comedi_error(dev, "premature interrupt");
+		return;
+	}
+	/*  initialize async here to make sure it is not NULL */
+	async = s->async;
+	cmd = &async->cmd;
+
+	spin_lock_irqsave(&dev->spinlock, spin_flags);
+	if ((devpriv->ctrl_reg & DMA_ENABLE) == 0) {
+		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+		return;
+	}
+
+	dma_flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma_chan);
+	residue = disable_dma_on_even(dev);
+
+	/*  figure out how many points to read */
+	if (residue > devpriv->dma_transfer_size) {
+		comedi_error(dev, "residue > transfer size!\n");
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		num_bytes = 0;
+	} else
+		num_bytes = devpriv->dma_transfer_size - residue;
+
+	if (cmd->stop_src == TRIG_COUNT &&
+					num_bytes >= devpriv->adc_byte_count) {
+		num_bytes = devpriv->adc_byte_count;
+		async->events |= COMEDI_CB_EOA;
+	}
+
+	buffer_index = devpriv->current_buffer;
+	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
+	devpriv->adc_byte_count -= num_bytes;
+
+	/*  re-enable  dma */
+	if ((async->events & COMEDI_CB_EOA) == 0) {
+		set_dma_addr(devpriv->dma_chan,
+			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
+		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+		enable_dma(devpriv->dma_chan);
+	}
+	release_dma_lock(dma_flags);
+
+	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+
+	cfc_write_array_to_buffer(s,
+				  devpriv->dma_buffer[buffer_index], num_bytes);
+
+	cfc_handle_events(dev, s);
+}
+
+static void das16_timer_interrupt(unsigned long arg)
+{
+	struct comedi_device *dev = (struct comedi_device *)arg;
+	struct das16_private_struct *devpriv = dev->private;
+
+	das16_interrupt(dev);
+
+	if (devpriv->timer_running)
+		mod_timer(&devpriv->timer, jiffies + timer_period());
+}
+
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
@@ -554,12 +664,20 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static void das16_reset(struct comedi_device *dev)
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index)
 {
-	outb(0, dev->iobase + DAS16_STATUS);
-	outb(0, dev->iobase + DAS16_CONTROL);
-	outb(0, dev->iobase + DAS16_PACER);
-	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
+	unsigned int i, num_samples = num_bytes / sizeof(short);
+	short *data = array;
+
+	for (i = 0; i < num_samples; i++) {
+		data[i] = le16_to_cpu(data[i]);
+		if (s->maxdata == 0x0fff)
+			data[i] >>= 4;
+		data[i] &= s->maxdata;
+	}
 }
 
 static int das16_ai_wait_for_conv(struct comedi_device *dev,
@@ -619,36 +737,6 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das16_di_insn_bits(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn,
-			      unsigned int *data)
-{
-	data[1] = inb(dev->iobase + DAS16_DIO) & 0xf;
-
-	return insn->n;
-}
-
-static int das16_do_insn_bits(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn,
-			      unsigned int *data)
-{
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
-
-	if (mask) {
-		s->state &= ~mask;
-		s->state |= (bits & mask);
-
-		outb(s->state, dev->iobase + DAS16_DIO);
-	}
-
-	data[1] = s->state;
-
-	return insn->n;
-}
-
 static int das16_ao_insn_write(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn,
@@ -669,114 +757,34 @@ static int das16_ao_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* the pc104-das16jr (at least) has problems if the dma
-	transfer is interrupted in the middle of transferring
-	a 16 bit sample, so this function takes care to get
-	an even transfer count after disabling dma
-	channel.
-*/
-static int disable_dma_on_even(struct comedi_device *dev)
+static int das16_di_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	struct das16_private_struct *devpriv = dev->private;
-	int residue;
-	int i;
-	static const int disable_limit = 100;
-	static const int enable_timeout = 100;
+	data[1] = inb(dev->iobase + DAS16_DIO) & 0xf;
 
-	disable_dma(devpriv->dma_chan);
-	residue = get_dma_residue(devpriv->dma_chan);
-	for (i = 0; i < disable_limit && (residue % 2); ++i) {
-		int j;
-		enable_dma(devpriv->dma_chan);
-		for (j = 0; j < enable_timeout; ++j) {
-			int new_residue;
-			udelay(2);
-			new_residue = get_dma_residue(devpriv->dma_chan);
-			if (new_residue != residue)
-				break;
-		}
-		disable_dma(devpriv->dma_chan);
-		residue = get_dma_residue(devpriv->dma_chan);
-	}
-	if (i == disable_limit) {
-		comedi_error(dev, "failed to get an even dma transfer, "
-							"could be trouble.");
-	}
-	return residue;
+	return insn->n;
 }
 
-static void das16_interrupt(struct comedi_device *dev)
+static int das16_do_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	struct das16_private_struct *devpriv = dev->private;
-	unsigned long dma_flags, spin_flags;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
-	int num_bytes, residue;
-	int buffer_index;
-
-	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
-		return;
-	}
-	/*  initialize async here to make sure it is not NULL */
-	async = s->async;
-	cmd = &async->cmd;
-
-	spin_lock_irqsave(&dev->spinlock, spin_flags);
-	if ((devpriv->ctrl_reg & DMA_ENABLE) == 0) {
-		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
-		return;
-	}
-
-	dma_flags = claim_dma_lock();
-	clear_dma_ff(devpriv->dma_chan);
-	residue = disable_dma_on_even(dev);
-
-	/*  figure out how many points to read */
-	if (residue > devpriv->dma_transfer_size) {
-		comedi_error(dev, "residue > transfer size!\n");
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		num_bytes = 0;
-	} else
-		num_bytes = devpriv->dma_transfer_size - residue;
-
-	if (cmd->stop_src == TRIG_COUNT &&
-					num_bytes >= devpriv->adc_byte_count) {
-		num_bytes = devpriv->adc_byte_count;
-		async->events |= COMEDI_CB_EOA;
-	}
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
 
-	buffer_index = devpriv->current_buffer;
-	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
-	devpriv->adc_byte_count -= num_bytes;
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
 
-	/*  re-enable  dma */
-	if ((async->events & COMEDI_CB_EOA) == 0) {
-		set_dma_addr(devpriv->dma_chan,
-			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
-		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
-		enable_dma(devpriv->dma_chan);
+		outb(s->state, dev->iobase + DAS16_DIO);
 	}
-	release_dma_lock(dma_flags);
-
-	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
-	cfc_write_array_to_buffer(s,
-				  devpriv->dma_buffer[buffer_index], num_bytes);
-
-	cfc_handle_events(dev, s);
-}
-
-static void das16_timer_interrupt(unsigned long arg)
-{
-	struct comedi_device *dev = (struct comedi_device *)arg;
-	struct das16_private_struct *devpriv = dev->private;
-
-	das16_interrupt(dev);
+	data[1] = s->state;
 
-	if (devpriv->timer_running)
-		mod_timer(&devpriv->timer, jiffies + timer_period());
+	return insn->n;
 }
 
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -814,30 +822,14 @@ static int das1600_mode_detect(struct comedi_device *dev)
 	return 0;
 }
 
-static void das16_ai_munge(struct comedi_device *dev,
-			   struct comedi_subdevice *s, void *array,
-			   unsigned int num_bytes,
-			   unsigned int start_chan_index)
+static void das16_reset(struct comedi_device *dev)
 {
-	unsigned int i, num_samples = num_bytes / sizeof(short);
-	short *data = array;
-
-	for (i = 0; i < num_samples; i++) {
-		data[i] = le16_to_cpu(data[i]);
-		if (s->maxdata == 0x0fff)
-			data[i] >>= 4;
-		data[i] &= s->maxdata;
-	}
+	outb(0, dev->iobase + DAS16_STATUS);
+	outb(0, dev->iobase + DAS16_CONTROL);
+	outb(0, dev->iobase + DAS16_PACER);
+	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
-/*
- *
- * Options list:
- *   0  I/O base
- *   1  IRQ
- *   2  DMA
- *   3  Clock speed (in MHz)
- */
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = comedi_board(dev);

commit 73ef2b5387ff95ac24487934250e9749e8aaa217
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 14:02:22 2013 -0700

    staging: comedi: das16: tidy up das16_ai_insn_read()
    
    Factor out the loop that waits for the ai conversion to complete.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f6d0f7e868b2..a482bd524e9b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -253,8 +253,6 @@ struct das16_board {
 	unsigned int id;
 };
 
-#define DAS16_TIMEOUT 1000
-
 /* Period for timer interrupt in jiffies.  It's a function
  * to deal with possibility of dynamic HZ patches  */
 static inline int timer_period(void)
@@ -564,55 +562,61 @@ static void das16_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
+static int das16_ai_wait_for_conv(struct comedi_device *dev,
+				  unsigned int timeout)
+{
+	unsigned int status;
+	int i;
+
+	for (i = 0; i < timeout; i++) {
+		status = inb(dev->iobase + DAS16_STATUS);
+		if (!(status & BUSY))
+			return 0;
+	}
+	return -ETIME;
+}
+
 static int das16_ai_insn_read(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn,
 			      unsigned int *data)
 {
 	const struct das16_board *board = comedi_board(dev);
-	int i, n;
-	int range;
-	int chan;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val;
+	int ret;
+	int i;
 
 	das16_ai_disable(dev);
 
 	/* set multiplexer */
-	chan = CR_CHAN(insn->chanspec);
-	chan |= CR_CHAN(insn->chanspec) << 4;
-	outb(chan, dev->iobase + DAS16_MUX);
+	outb(chan | (chan << 4), dev->iobase + DAS16_MUX);
 
 	/* set gain */
 	if (board->ai_pg != das16_pg_none) {
-		range = CR_RANGE(insn->chanspec);
 		outb((das16_gainlists[board->ai_pg])[range],
 		     dev->iobase + DAS16_GAIN);
 	}
 
-	for (n = 0; n < insn->n; n++) {
-		unsigned int val;
-
+	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS16_TRIG);
 
-		for (i = 0; i < DAS16_TIMEOUT; i++) {
-			if (!(inb(dev->iobase + DAS16_STATUS) & BUSY))
-				break;
-		}
-		if (i == DAS16_TIMEOUT) {
-			printk("das16: timeout\n");
-			return -ETIME;
-		}
+		ret = das16_ai_wait_for_conv(dev, 1000);
+		if (ret)
+			return ret;
 
 		val = inb(dev->iobase + DAS16_AI_MSB) << 8;
 		val |= inb(dev->iobase + DAS16_AI_LSB);
 		if (s->maxdata == 0x0fff)
-			data[n] >>= 4;
+			val >>= 4;
 		val &= s->maxdata;
 
-		data[n] = val;
+		data[i] = val;
 	}
 
-	return n;
+	return insn->n;
 }
 
 static int das16_di_insn_bits(struct comedi_device *dev,

commit b53ceaf71af836bfc209b68f5d6c7c93895c7329
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:58:36 2013 -0700

    staging: comedi: das16: introduce das16_ai_{en, dis}able() helpers
    
    Introduce a couple helper functions to enable and disable the
    analog input interrupt/dma conversions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index bd5f516f361c..f6d0f7e868b2 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -264,7 +264,7 @@ static inline int timer_period(void)
 
 struct das16_private_struct {
 	unsigned int clockbase;	/*  master clock speed in ns */
-	unsigned int control_state;	/*  dma, interrupt and trigger control bits */
+	unsigned int ctrl_reg;
 	unsigned long adc_byte_count;	/*  number of bytes remaining */
 	/*  divisor dividing master clock to get conversion frequency */
 	unsigned int divisor1;
@@ -289,6 +289,30 @@ struct das16_private_struct {
 	unsigned int can_burst:1;
 };
 
+static void das16_ai_enable(struct comedi_device *dev,
+			    unsigned int mode, unsigned int src)
+{
+	struct das16_private_struct *devpriv = dev->private;
+
+	devpriv->ctrl_reg &= ~(DAS16_INTE | DMA_ENABLE | PACING_MASK);
+	devpriv->ctrl_reg |= mode;
+
+	if (src == TRIG_EXT)
+		devpriv->ctrl_reg |= EXT_PACER;
+	else
+		devpriv->ctrl_reg |= INT_PACER;
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
+}
+
+static void das16_ai_disable(struct comedi_device *dev)
+{
+	struct das16_private_struct *devpriv = dev->private;
+
+	/* disable interrupts, dma and pacer clocked conversions */
+	devpriv->ctrl_reg &= ~(DAS16_INTE | DMA_ENABLE | PACING_MASK);
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
+}
+
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
@@ -499,19 +523,12 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->timer_running = 1;
 	devpriv->timer.expires = jiffies + timer_period();
 	add_timer(&devpriv->timer);
-	devpriv->control_state &= ~DAS16_INTE;
-	devpriv->control_state |= DMA_ENABLE;
-	devpriv->control_state &= ~PACING_MASK;
-	if (cmd->convert_src == TRIG_EXT)
-		devpriv->control_state |= EXT_PACER;
-	else
-		devpriv->control_state |= INT_PACER;
-	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+
+	das16_ai_enable(dev, DMA_ENABLE, cmd->convert_src);
 
 	if (devpriv->can_burst)
 		outb(0, dev->iobase + DAS1600_CONV);
 
-
 	return 0;
 }
 
@@ -521,9 +538,8 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
-	/* disable interrupts, dma and pacer clocked conversions */
-	devpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;
-	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+
+	das16_ai_disable(dev);
 	disable_dma(devpriv->dma_chan);
 
 	/*  disable SW timer */
@@ -554,14 +570,11 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	const struct das16_board *board = comedi_board(dev);
-	struct das16_private_struct *devpriv = dev->private;
 	int i, n;
 	int range;
 	int chan;
 
-	/*  disable interrupts and pacing */
-	devpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;
-	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+	das16_ai_disable(dev);
 
 	/* set multiplexer */
 	chan = CR_CHAN(insn->chanspec);
@@ -707,7 +720,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	cmd = &async->cmd;
 
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
-	if ((devpriv->control_state & DMA_ENABLE) == 0) {
+	if ((devpriv->ctrl_reg & DMA_ENABLE) == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 		return;
 	}
@@ -1027,8 +1040,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	das16_reset(dev);
 	/* set the interrupt level */
-	devpriv->control_state = DAS16_IRQ(dev->irq);
-	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+	devpriv->ctrl_reg = DAS16_IRQ(dev->irq);
+	outb(devpriv->ctrl_reg, dev->iobase + DAS16_CONTROL);
 
 	if (devpriv->can_burst) {
 		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);

commit 9336140c49465a16e0fdd8385753020e275ec7d4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:58:17 2013 -0700

    staging: comedi: das16: remove the register map comments
    
    This is just extra cruft. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 96c081b48d07..bd5f516f361c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -89,91 +89,8 @@ www.measurementcomputing.com
 #define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
 /*
-    cio-das16.pdf
-
-    "das16"
-    "das16/f"
-
-  0	a/d bits 0-3		start 12 bit
-  1	a/d bits 4-11		unused
-  2	mux read		mux set
-  3	di 4 bit		do 4 bit
-  4	unused			ao0_lsb
-  5	unused			ao0_msb
-  6	unused			ao1_lsb
-  7	unused			ao1_msb
-  8	status eoc uni/bip	interrupt reset
-  9	dma, int, trig ctrl	set dma, int
-  a	pacer control		unused
-  b	reserved		reserved
-  cdef	8254
-  0123	8255
-
-*/
-
-/*
-    cio-das16jr.pdf
-
-    "das16jr"
-
-  0	a/d bits 0-3		start 12 bit
-  1	a/d bits 4-11		unused
-  2	mux read		mux set
-  3	di 4 bit		do 4 bit
-  4567	unused			unused
-  8	status eoc uni/bip	interrupt reset
-  9	dma, int, trig ctrl	set dma, int
-  a	pacer control		unused
-  b	gain status		gain control
-  cdef	8254
-
-*/
-
-/*
-    cio-das16jr_16.pdf
-
-    "das16jr_16"
-
-  0	a/d bits 0-7		start 16 bit
-  1	a/d bits 8-15		unused
-  2	mux read		mux set
-  3	di 4 bit		do 4 bit
-  4567	unused			unused
-  8	status eoc uni/bip	interrupt reset
-  9	dma, int, trig ctrl	set dma, int
-  a	pacer control		unused
-  b	gain status		gain control
-  cdef	8254
-
-*/
-/*
-    cio-das160x-1x.pdf
-
-    "das1601/12"
-    "das1602/12"
-    "das1602/16"
-
-  0	a/d bits 0-3		start 12 bit
-  1	a/d bits 4-11		unused
-  2	mux read		mux set
-  3	di 4 bit		do 4 bit
-  4	unused			ao0_lsb
-  5	unused			ao0_msb
-  6	unused			ao1_lsb
-  7	unused			ao1_msb
-  8	status eoc uni/bip	interrupt reset
-  9	dma, int, trig ctrl	set dma, int
-  a	pacer control		unused
-  b	gain status		gain control
-  cdef	8254
-  400	8255
-  404	unused			conversion enable
-  405	unused			burst enable
-  406	unused			das1600 enable
-  407	status
-
-*/
-
+ * Register I/O map
+ */
 #define DAS16_TRIG		0
 #define DAS16_AI_LSB		0
 #define DAS16_AI_MSB		1

commit 6f8f6b2d4f5255eb91d0cc2643daf3f7d48a14f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:57:58 2013 -0700

    staging: comedi: das16: remove unused static const variable
    
    This variable is not used in the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 577e2a842845..96c081b48d07 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -174,9 +174,6 @@ www.measurementcomputing.com
 
 */
 
-/*  size in bytes of a sample from board */
-static const int sample_size = 2;
-
 #define DAS16_TRIG		0
 #define DAS16_AI_LSB		0
 #define DAS16_AI_MSB		1

commit 3f7890eb24f4e8ce4f70c39595a34bdd31293033
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:57:38 2013 -0700

    staging: comedi: das16: remove unused DAS16_SIZE
    
    This define is not used in the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 009c074b664b..577e2a842845 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -86,7 +86,6 @@ www.measurementcomputing.com
 #include "8255.h"
 #include "comedi_fc.h"
 
-#define DAS16_SIZE 20		/*  number of ioports */
 #define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
 /*

commit 96334bfebf5697dce1dba23c0abdf1683a733c52
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:57:18 2013 -0700

    staging: comedi: das16: add a 'can_burst' flag to the private data
    
    If the boardinfo 'size' is > 0x400 it indicates that the board has
    additional registers that allow bursting of analog input data.
    
    To better indicate this add a flag to the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 95261a617623..009c074b664b 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -373,6 +373,7 @@ struct das16_private_struct {
 	short timer_running;
 
 	unsigned long extra_iobase;
+	unsigned int can_burst:1;
 };
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -389,15 +390,13 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
 
 	mask = TRIG_FOLLOW;
-	/*  if board supports burst mode */
-	if (board->size > 0x400)
+	if (devpriv->can_burst)
 		mask |= TRIG_TIMER | TRIG_EXT;
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src, mask);
 
 	tmp = cmd->convert_src;
 	mask = TRIG_TIMER | TRIG_EXT;
-	/*  if board supports burst mode */
-	if (board->size > 0x400)
+	if (devpriv->can_burst)
 		mask |= TRIG_NOW;
 	err |= cfc_check_trigger_src(&cmd->convert_src, mask);
 
@@ -534,8 +533,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->adc_byte_count =
 	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
-	/*  disable conversions for das1600 mode */
-	if (board->size > 0x400)
+	if (devpriv->can_burst)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
 
 	/*  set scan limits */
@@ -559,8 +557,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* enable counters */
 	byte = 0;
-	/* Enable burst mode if appropriate. */
-	if (board->size > 0x400) {
+	if (devpriv->can_burst) {
 		if (cmd->convert_src == TRIG_NOW) {
 			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
 			/*  set burst length */
@@ -598,8 +595,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->control_state |= INT_PACER;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
-	/* Enable conversions if using das1600 mode */
-	if (board->size > 0x400)
+	if (devpriv->can_burst)
 		outb(0, dev->iobase + DAS1600_CONV);
 
 
@@ -608,7 +604,6 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
 	unsigned long flags;
 
@@ -624,11 +619,9 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 		del_timer(&devpriv->timer);
 	}
 
-	/* disable burst mode */
-	if (board->size > 0x400)
+	if (devpriv->can_burst)
 		outb(0, dev->iobase + DAS1600_BURST);
 
-
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
@@ -955,6 +948,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret)
 			return ret;
 		devpriv->extra_iobase = dev->iobase + 0x400;
+		devpriv->can_burst = 1;
 	}
 
 	/*  probe id bits to make sure they are consistent */
@@ -964,13 +958,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/*  get master clock speed */
-	if (board->size < 0x400) {
+	if (devpriv->can_burst) {
+		das1600_mode_detect(dev);
+	} else {
 		if (it->options[3])
 			devpriv->clockbase = 1000 / it->options[3];
 		else
 			devpriv->clockbase = 1000;	/*  1 MHz default */
-	} else {
-		das1600_mode_detect(dev);
 	}
 
 	/* initialize dma */
@@ -1123,8 +1117,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->control_state = DAS16_IRQ(dev->irq);
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
-	/*  turn on das1600 mode if available */
-	if (board->size > 0x400) {
+	if (devpriv->can_burst) {
 		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
 		outb(0, dev->iobase + DAS1600_CONV);
 		outb(0, dev->iobase + DAS1600_BURST);

commit 6f63840447030b32662d8d425b36e8fabd7799cf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:56:59 2013 -0700

    staging: comedi: das16: remove 'volatile' on private data variables
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index d86ed2cce7c0..95261a617623 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -351,8 +351,8 @@ static inline int timer_period(void)
 
 struct das16_private_struct {
 	unsigned int clockbase;	/*  master clock speed in ns */
-	volatile unsigned int control_state;	/*  dma, interrupt and trigger control bits */
-	volatile unsigned long adc_byte_count;	/*  number of bytes remaining */
+	unsigned int control_state;	/*  dma, interrupt and trigger control bits */
+	unsigned long adc_byte_count;	/*  number of bytes remaining */
 	/*  divisor dividing master clock to get conversion frequency */
 	unsigned int divisor1;
 	/*  divisor dividing master clock to get conversion frequency */
@@ -361,7 +361,7 @@ struct das16_private_struct {
 	uint16_t *dma_buffer[2];
 	dma_addr_t dma_buffer_addr[2];
 	unsigned int current_buffer;
-	volatile unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
+	unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
 	/**
 	 * user-defined analog input and output ranges
 	 * defined from config options
@@ -370,7 +370,7 @@ struct das16_private_struct {
 	struct comedi_lrange *user_ao_range_table;
 
 	struct timer_list timer;	/*  for timed interrupt */
-	volatile short timer_running;
+	short timer_running;
 
 	unsigned long extra_iobase;
 };

commit 66eca8575525a725a105aec5ca3a5cfa57ecd524
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:56:38 2013 -0700

    staging: comedi: das16: remove DEBUG_PRINT macro
    
    This macro outputs some printk() debug info that is just added noise.
    Remove it as well as the DEBUG stuff.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index ae3a3eaef3d9..d86ed2cce7c0 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -86,16 +86,6 @@ www.measurementcomputing.com
 #include "8255.h"
 #include "comedi_fc.h"
 
-#undef DEBUG
-/* #define DEBUG */
-
-#ifdef DEBUG
-#define DEBUG_PRINT(format, args...)	\
-	printk(KERN_DEBUG "das16: " format, ## args)
-#else
-#define DEBUG_PRINT(format, args...)
-#endif
-
 #define DAS16_SIZE 20		/*  number of ioports */
 #define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
@@ -566,7 +556,6 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	cmd->convert_arg =
 	    das16_set_pacer(dev, cmd->convert_arg,
 			    cmd->flags & TRIG_ROUND_MASK);
-	DEBUG_PRINT("pacer period: %d ns\n", cmd->convert_arg);
 
 	/* enable counters */
 	byte = 0;
@@ -814,7 +803,6 @@ static void das16_interrupt(struct comedi_device *dev)
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if ((devpriv->control_state & DMA_ENABLE) == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
-		DEBUG_PRINT("interrupt while dma disabled?\n");
 		return;
 	}
 

commit 9960ad37cf501336450048137c61be21cb0c5672
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:56:21 2013 -0700

    staging: comedi: das16: remove reg_dump()
    
    This function just prints some development debug information. There is
    no reason to leave this in the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index ccb0acde6334..ae3a3eaef3d9 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -868,24 +868,6 @@ static void das16_timer_interrupt(unsigned long arg)
 		mod_timer(&devpriv->timer, jiffies + timer_period());
 }
 
-static void reg_dump(struct comedi_device *dev)
-{
-	DEBUG_PRINT("********DAS1600 REGISTER DUMP********\n");
-	DEBUG_PRINT("DAS16_MUX: %x\n", inb(dev->iobase + DAS16_MUX));
-	DEBUG_PRINT("DAS16_DIO: %x\n", inb(dev->iobase + DAS16_DIO));
-	DEBUG_PRINT("DAS16_STATUS: %x\n", inb(dev->iobase + DAS16_STATUS));
-	DEBUG_PRINT("DAS16_CONTROL: %x\n", inb(dev->iobase + DAS16_CONTROL));
-	DEBUG_PRINT("DAS16_PACER: %x\n", inb(dev->iobase + DAS16_PACER));
-	DEBUG_PRINT("DAS16_GAIN: %x\n", inb(dev->iobase + DAS16_GAIN));
-	DEBUG_PRINT("DAS16_CNTR_CONTROL: %x\n",
-		    inb(dev->iobase + DAS16_CNTR_CONTROL));
-	DEBUG_PRINT("DAS1600_CONV: %x\n", inb(dev->iobase + DAS1600_CONV));
-	DEBUG_PRINT("DAS1600_BURST: %x\n", inb(dev->iobase + DAS1600_BURST));
-	DEBUG_PRINT("DAS1600_ENABLE: %x\n", inb(dev->iobase + DAS1600_ENABLE));
-	DEBUG_PRINT("DAS1600_STATUS_B: %x\n",
-		    inb(dev->iobase + DAS1600_STATUS_B));
-}
-
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = comedi_board(dev);
@@ -918,8 +900,6 @@ static int das1600_mode_detect(struct comedi_device *dev)
 		printk(KERN_INFO " 1MHz pacer clock\n");
 	}
 
-	reg_dump(dev);
-
 	return 0;
 }
 

commit 1aa4694fb6bd5c0cdadb6d7ba0723186f5198c1b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:56:02 2013 -0700

    staging: comedi: das16: remove 'ai_unipolar' and 'ai_singleended'
    
    These members in the private data are only used during the board attach.
    
    Move the reading of the status register to the board attach and just
    check the value where needed when initializing the analog input subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 14d2aa057b88..ccb0acde6334 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -360,8 +360,6 @@ static inline int timer_period(void)
 }
 
 struct das16_private_struct {
-	unsigned int ai_unipolar;	/*  unipolar flag */
-	unsigned int ai_singleended;	/*  single ended flag */
 	unsigned int clockbase;	/*  master clock speed in ns */
 	volatile unsigned int control_state;	/*  dma, interrupt and trigger control bits */
 	volatile unsigned long adc_byte_count;	/*  number of bytes remaining */
@@ -891,28 +889,9 @@ static void reg_dump(struct comedi_device *dev)
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = comedi_board(dev);
-	struct das16_private_struct *devpriv = dev->private;
-	int status;
 	int diobits;
 
-	/* status is available on all boards */
-
-	status = inb(dev->iobase + DAS16_STATUS);
-
-	if ((status & UNIPOLAR))
-		devpriv->ai_unipolar = 1;
-	else
-		devpriv->ai_unipolar = 0;
-
-
-	if ((status & DAS16_MUXBIT))
-		devpriv->ai_singleended = 1;
-	else
-		devpriv->ai_singleended = 0;
-
-
 	/* diobits indicates boards */
-
 	diobits = inb(dev->iobase + DAS16_DIO) & 0xf0;
 
 	printk(KERN_INFO " id bits are 0x%02x\n", diobits);
@@ -976,6 +955,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_krange *user_ai_range;
 	struct comedi_krange *user_ao_range;
 	unsigned int dma_chan = it->options[2];
+	unsigned int status;
 	int ret;
 
 	/*  check that clock setting is valid */
@@ -1091,11 +1071,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
+	status = inb(dev->iobase + DAS16_STATUS);
+
 	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE;
-	if (devpriv->ai_singleended) {
+	if (status & DAS16_MUXBIT) {
 		s->subdev_flags	|= SDF_GROUND;
 		s->n_chan	= 16;
 	} else {
@@ -1106,7 +1088,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= board->ai_maxdata;
 	if (devpriv->user_ai_range_table) { /*  user defined ai range */
 		s->range_table	= devpriv->user_ai_range_table;
-	} else if (devpriv->ai_unipolar) {
+	} else if (status & UNIPOLAR) {
 		s->range_table	= das16_ai_uni_lranges[board->ai_pg];
 	} else {
 		s->range_table	= das16_ai_bip_lranges[board->ai_pg];

commit 0837e209b3519517dd252d31af02d42368ddfcc6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:55:38 2013 -0700

    staging: comedi: das16: remove unused struct definition
    
    This struct is not used by the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 93c3a8866bef..14d2aa057b88 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -336,11 +336,6 @@ static const struct comedi_lrange *const das16_ai_bip_lranges[] = {
 	&range_das1x02_bip,
 };
 
-struct munge_info {
-	uint8_t byte;
-	unsigned have_byte:1;
-};
-
 struct das16_board {
 	const char *name;
 	unsigned int ai_maxdata;

commit 6d33b860cdfe5ab3c4dca57104abb8f0d4c9cb8b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:55:20 2013 -0700

    staging: comedi: das16: tidy up the comedi_lrange tables
    
    Cleanup the whitespace in the tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index bad39d79b2c3..93c3a8866bef 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -238,62 +238,67 @@ static const int sample_size = 2;
 #define   DAS1600_WS			0x02
 #define   DAS1600_CLK_10MHZ		0x01
 
-static const struct comedi_lrange range_das1x01_bip = { 4, {
-							    BIP_RANGE(10),
-							    BIP_RANGE(1),
-							    BIP_RANGE(0.1),
-							    BIP_RANGE(0.01),
-							    }
+static const struct comedi_lrange range_das1x01_bip = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.01)
+	}
 };
 
-static const struct comedi_lrange range_das1x01_unip = { 4, {
-							     UNI_RANGE(10),
-							     UNI_RANGE(1),
-							     UNI_RANGE(0.1),
-							     UNI_RANGE(0.01),
-							     }
+static const struct comedi_lrange range_das1x01_unip = {
+	4, {
+		UNI_RANGE(10),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.01)
+	}
 };
 
-static const struct comedi_lrange range_das1x02_bip = { 4, {
-							    BIP_RANGE(10),
-							    BIP_RANGE(5),
-							    BIP_RANGE(2.5),
-							    BIP_RANGE(1.25),
-							    }
+static const struct comedi_lrange range_das1x02_bip = {
+	4, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_das1x02_unip = { 4, {
-							     UNI_RANGE(10),
-							     UNI_RANGE(5),
-							     UNI_RANGE(2.5),
-							     UNI_RANGE(1.25),
-							     }
+static const struct comedi_lrange range_das1x02_unip = {
+	4, {
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_das16jr = { 9, {
-						/*  also used by 16/330 */
-							BIP_RANGE(10),
-							BIP_RANGE(5),
-							BIP_RANGE(2.5),
-							BIP_RANGE(1.25),
-							BIP_RANGE(0.625),
-							UNI_RANGE(10),
-							UNI_RANGE(5),
-							UNI_RANGE(2.5),
-							UNI_RANGE(1.25),
-							}
+static const struct comedi_lrange range_das16jr = {
+	9, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_das16jr_16 = { 8, {
-							   BIP_RANGE(10),
-							   BIP_RANGE(5),
-							   BIP_RANGE(2.5),
-							   BIP_RANGE(1.25),
-							   UNI_RANGE(10),
-							   UNI_RANGE(5),
-							   UNI_RANGE(2.5),
-							   UNI_RANGE(1.25),
-							   }
+static const struct comedi_lrange range_das16jr_16 = {
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 static const int das16jr_gainlist[] = { 8, 0, 1, 2, 3, 4, 5, 6, 7 };

commit 6d063851933584ab812f59bb0cdfb16d584ac5b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:55:00 2013 -0700

    staging: comedi: das16: cleanup analog output subdevice
    
    All the boards supported by this driver that have analog outputs use
    the same function to handle the (*insn_write) for the subdevice. They
    all also have 12-bit resolution (maxdata = 0x0fff).
    
    Remove the 'ao' and 'ao_nbits' members from the boardinfo and replace
    them with a simple bit-field flag 'has_ao'.
    
    Tidy up the subdevice init a bit as well as the (*insn_write) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 22d2bf423d66..bad39d79b2c3 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -341,8 +341,7 @@ struct das16_board {
 	unsigned int ai_maxdata;
 	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
-	void *ao;
-	unsigned int ao_nbits;
+	unsigned int has_ao:1;
 
 	unsigned int i8255_offset;
 	unsigned int i8254_offset;
@@ -740,29 +739,24 @@ static int das16_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int das16_ao_insn_write(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
-	const struct das16_board *board = comedi_board(dev);
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val;
 	int i;
-	int lsb, msb;
-	int chan;
-
-	chan = CR_CHAN(insn->chanspec);
 
 	for (i = 0; i < insn->n; i++) {
-		if (board->ao_nbits == 12) {
-			lsb = (data[i] << 4) & 0xff;
-			msb = (data[i] >> 4) & 0xff;
-		} else {
-			lsb = data[i] & 0xff;
-			msb = (data[i] >> 8) & 0xff;
-		}
-		outb(lsb, dev->iobase + DAS16_AO_LSB(chan));
-		outb(msb, dev->iobase + DAS16_AO_MSB(chan));
+		val = data[i];
+		val <<= 4;
+
+		outb(val & 0xff, dev->iobase + DAS16_AO_LSB(chan));
+		outb((val >> 8) & 0xff, dev->iobase + DAS16_AO_MSB(chan));
 	}
 
-	return i;
+	return insn->n;
 }
 
 /* the pc104-das16jr (at least) has problems if the dma
@@ -1127,22 +1121,21 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->munge	= das16_ai_munge;
 	}
 
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	/* ao */
-	if (board->ao) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = 2;
-		s->maxdata = (1 << board->ao_nbits) - 1;
-		/*  user defined ao range */
+	if (board->has_ao) {
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE;
+		s->n_chan	= 2;
+		s->maxdata	= 0x0fff;
 		if (devpriv->user_ao_range_table)
-			s->range_table = devpriv->user_ao_range_table;
+			s->range_table	= devpriv->user_ao_range_table;
 		else
-			s->range_table = &range_unknown;
+			s->range_table	= &range_unknown;
 
-		s->insn_write = board->ao;
+		s->insn_write	= das16_ao_insn_write;
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* Digital Input subdevice */
@@ -1221,8 +1214,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1232,8 +1224,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1243,8 +1234,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 8500,
 		.ai_pg		= das16_pg_none,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1254,8 +1244,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1265,8 +1254,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1276,7 +1264,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1286,7 +1273,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1296,7 +1282,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1306,7 +1291,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1316,7 +1300,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
-		.ao		= NULL,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1326,7 +1309,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
-		.ao		= NULL,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1336,7 +1318,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
-		.ao		= NULL,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1346,7 +1327,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.ao		= NULL,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1356,8 +1336,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1367,8 +1346,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1378,7 +1356,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1388,7 +1365,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1398,7 +1374,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1408,8 +1383,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1419,8 +1393,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1430,8 +1403,7 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
-		.ao		= das16_ao_winsn,
-		.ao_nbits	= 12,
+		.has_ao		= 1,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1441,7 +1413,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
-		.ao		= NULL,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,

commit 6050cc918dd4c002ddebf76861c6d9f240c1a4dc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:54:39 2013 -0700

    staging: comedi: das16: all supported board have digital outputs
    
    All the boards supported by this driver have digital outputs and all
    of then use the same function to handle the (*insn_bits) for the
    subdevice.
    
    Remove the 'do_' member from the boardinfo and always initialize the
    digital output subdevice during the board attach.
    
    Tidy up the subdevice init a bit as well as the (*insn_bits) function.
    Remove SDF_READABLE from the subdev_flags. This is a pure digital output
    subdevice and the outputs are not readable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 3528c8257a5c..22d2bf423d66 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -343,7 +343,6 @@ struct das16_board {
 	unsigned int ai_pg;
 	void *ao;
 	unsigned int ao_nbits;
-	void *do_;
 
 	unsigned int i8255_offset;
 	unsigned int i8254_offset;
@@ -721,22 +720,22 @@ static int das16_di_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int das16_do_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	unsigned int wbits;
-
-	/*  only set bits that have been masked */
-	data[0] &= 0xf;
-	wbits = s->state;
-	/*  zero bits that have been masked */
-	wbits &= ~data[0];
-	/*  set masked bits */
-	wbits |= data[0] & data[1];
-	s->state = wbits;
-	data[1] = wbits;
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
 
-	outb(s->state, dev->iobase + DAS16_DIO);
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
+
+		outb(s->state, dev->iobase + DAS16_DIO);
+	}
+
+	data[1] = s->state;
 
 	return insn->n;
 }
@@ -1155,20 +1154,17 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table	= &range_digital;
 	s->insn_bits	= das16_di_insn_bits;
 
+	/* Digital Output subdevice */
 	s = &dev->subdevices[3];
-	/* do */
-	if (board->do_) {
-		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-		s->n_chan = 4;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = board->do_;
-		/*  initialize digital output lines */
-		outb(s->state, dev->iobase + DAS16_DIO);
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das16_do_insn_bits;
+
+	/* initialize digital output lines */
+	outb(s->state, dev->iobase + DAS16_DIO);
 
 	s = &dev->subdevices[4];
 	/* 8255 */
@@ -1227,7 +1223,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1239,7 +1234,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1251,7 +1245,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1263,7 +1256,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1275,7 +1267,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,
@@ -1286,7 +1277,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1297,7 +1287,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1308,7 +1297,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1319,7 +1307,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x10,
@@ -1330,7 +1317,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1341,7 +1327,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1352,7 +1337,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1363,7 +1347,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1375,7 +1358,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1387,7 +1369,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1398,7 +1379,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1409,7 +1389,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1420,7 +1399,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1432,7 +1410,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1444,7 +1421,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1456,7 +1432,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
 		.size		= 0x408,
@@ -1467,7 +1442,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
 		.size		= 0x14,

commit fb1864ba9535353530f43ae60386f00bc629a5bb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:54:09 2013 -0700

    staging: comedi: das16: all supported board have digital inputs
    
    All the boards supported by this driver have digital inputs and all
    of then use the same function to handle the (*insn_bits) for the
    subdevice.
    
    Remove the 'di' member from the boardinfo and always initialize the
    digital input subdevice during the board attach.
    
    Tidy up the subdevice init a bit as well as the (*insn_bits) function.
    The (*insn_bits) function does not need to clear data[0].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 11e5787dd27e..3528c8257a5c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -343,7 +343,6 @@ struct das16_board {
 	unsigned int ai_pg;
 	void *ao;
 	unsigned int ao_nbits;
-	void *di;
 	void *do_;
 
 	unsigned int i8255_offset;
@@ -712,14 +711,12 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	return n;
 }
 
-static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int das16_di_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	unsigned int bits;
-
-	bits = inb(dev->iobase + DAS16_DIO) & 0xf;
-	data[1] = bits;
-	data[0] = 0;
+	data[1] = inb(dev->iobase + DAS16_DIO) & 0xf;
 
 	return insn->n;
 }
@@ -1149,18 +1146,14 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
+	/* Digital Input subdevice */
 	s = &dev->subdevices[2];
-	/* di */
-	if (board->di) {
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE;
-		s->n_chan = 4;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = board->di;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das16_di_insn_bits;
 
 	s = &dev->subdevices[3];
 	/* do */
@@ -1234,7 +1227,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
@@ -1247,7 +1239,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
@@ -1260,7 +1251,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
@@ -1273,7 +1263,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
@@ -1286,7 +1275,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x10,
 		.i8254_offset	= 0x0c,
@@ -1298,7 +1286,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1310,7 +1297,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1322,7 +1308,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1334,7 +1319,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1346,7 +1330,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1358,7 +1341,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1370,7 +1352,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
@@ -1382,7 +1363,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x0,
 		.i8254_offset	= 0x0c,
@@ -1395,7 +1375,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1408,7 +1387,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1420,7 +1398,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1432,7 +1409,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1444,7 +1420,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,
@@ -1457,7 +1432,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1470,7 +1444,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1483,7 +1456,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
 		.ao_nbits	= 12,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0x400,
 		.i8254_offset	= 0x0c,
@@ -1495,7 +1467,6 @@ static const struct das16_board das16_boards[] = {
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
-		.di		= das16_di_rbits,
 		.do_		= das16_do_wbits,
 		.i8255_offset	= 0,
 		.i8254_offset	= 0x0c,

commit 0dc7c5db134dcd216003ea1be2b7b93a5169ea26
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:49:21 2013 -0700

    staging: comedi: das16: change boardinfo 'ai_nbits' to 'ai_maxdata'
    
    The subdevice functions that used this boardinfo can use the subdevice
    's->maxdata' value instead. Tidy up those functions.
    
    Change the boardinfo so that the calculation is not needed during the
    attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 0b76af68f957..11e5787dd27e 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -338,7 +338,7 @@ struct munge_info {
 
 struct das16_board {
 	const char *name;
-	unsigned int ai_nbits;
+	unsigned int ai_maxdata;
 	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
 	void *ao;
@@ -668,7 +668,6 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	int i, n;
 	int range;
 	int chan;
-	int msb, lsb;
 
 	/*  disable interrupts and pacing */
 	devpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;
@@ -687,6 +686,8 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (n = 0; n < insn->n; n++) {
+		unsigned int val;
+
 		/* trigger conversion */
 		outb_p(0, dev->iobase + DAS16_TRIG);
 
@@ -698,13 +699,14 @@ static int das16_ai_insn_read(struct comedi_device *dev,
 			printk("das16: timeout\n");
 			return -ETIME;
 		}
-		msb = inb(dev->iobase + DAS16_AI_MSB);
-		lsb = inb(dev->iobase + DAS16_AI_LSB);
-		if (board->ai_nbits == 12)
-			data[n] = ((lsb >> 4) & 0xf) | (msb << 4);
-		else
-			data[n] = lsb | (msb << 8);
 
+		val = inb(dev->iobase + DAS16_AI_MSB) << 8;
+		val |= inb(dev->iobase + DAS16_AI_LSB);
+		if (s->maxdata == 0x0fff)
+			data[n] >>= 4;
+		val &= s->maxdata;
+
+		data[n] = val;
 	}
 
 	return n;
@@ -957,15 +959,14 @@ static void das16_ai_munge(struct comedi_device *dev,
 			   unsigned int num_bytes,
 			   unsigned int start_chan_index)
 {
-	const struct das16_board *board = comedi_board(dev);
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *data = array;
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);
-		if (board->ai_nbits == 12)
-			data[i] = (data[i] >> 4) & 0xfff;
-
+		if (s->maxdata == 0x0fff)
+			data[i] >>= 4;
+		data[i] &= s->maxdata;
 	}
 }
 
@@ -1112,7 +1113,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->n_chan	= 8;
 	}
 	s->len_chanlist	= s->n_chan;
-	s->maxdata	= (1 << board->ai_nbits) - 1;
+	s->maxdata	= board->ai_maxdata;
 	if (devpriv->user_ai_range_table) { /*  user defined ai range */
 		s->range_table	= devpriv->user_ai_range_table;
 	} else if (devpriv->ai_unipolar) {
@@ -1228,7 +1229,7 @@ static void das16_detach(struct comedi_device *dev)
 static const struct das16_board das16_boards[] = {
 	{
 		.name		= "das-16",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
@@ -1241,7 +1242,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-16g",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
@@ -1254,7 +1255,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-16f",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 8500,
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
@@ -1267,7 +1268,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "cio-das16",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
@@ -1280,7 +1281,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x80,
 	}, {
 		.name		= "cio-das16/f",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.ao		= das16_ao_winsn,
@@ -1293,7 +1294,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x80,
 	}, {
 		.name		= "cio-das16/jr",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
@@ -1305,7 +1306,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "pc104-das16jr",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,
@@ -1317,7 +1318,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "cio-das16jr/16",
-		.ai_nbits	= 16,
+		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
@@ -1329,7 +1330,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "pc104-das16jr/16",
-		.ai_nbits	= 16,
+		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
 		.ao		= NULL,
@@ -1341,7 +1342,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-1201",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
@@ -1353,7 +1354,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x20,
 	}, {
 		.name		= "das-1202",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
 		.ao		= NULL,
@@ -1365,7 +1366,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x20,
 	}, {
 		.name		= "das-1401",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
@@ -1377,7 +1378,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1402",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
@@ -1389,7 +1390,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1601",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
@@ -1402,7 +1403,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1602",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
@@ -1415,7 +1416,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1401/12",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.ao		= NULL,
@@ -1427,7 +1428,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1402/12",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
@@ -1439,7 +1440,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1402/16",
-		.ai_nbits	= 16,
+		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= NULL,
@@ -1451,7 +1452,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1601/12",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
 		.ao		= das16_ao_winsn,
@@ -1464,7 +1465,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1602/12",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
@@ -1477,7 +1478,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1602/16",
-		.ai_nbits	= 16,
+		.ai_maxdata	= 0xffff,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
 		.ao		= das16_ao_winsn,
@@ -1490,7 +1491,7 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das16/330",
-		.ai_nbits	= 12,
+		.ai_maxdata	= 0x0fff,
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,
 		.ao		= NULL,

commit 465e25b5e143a7de07f243d50ee0f265cc132aad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:49:01 2013 -0700

    staging: comedi: das16: all supported board have analog inputs
    
    All the boards supported by this driver have analog inputs and all
    of then use the same function to handle the (*insn_read) for the
    subdevice.
    
    Remove the 'ai' member from the boardinfo and always initalize the
    analog input subdevice during the board attach.
    
    Tidy up the subdevice init a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f35aabd960f9..0b76af68f957 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -338,7 +338,6 @@ struct munge_info {
 
 struct das16_board {
 	const char *name;
-	void *ai;
 	unsigned int ai_nbits;
 	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
@@ -659,8 +658,10 @@ static void das16_reset(struct comedi_device *dev)
 	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
-static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int das16_ai_insn_read(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
@@ -1099,39 +1100,34 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	/* ai */
-	if (board->ai) {
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags = SDF_READABLE;
-		if (devpriv->ai_singleended) {
-			s->n_chan = 16;
-			s->len_chanlist = 16;
-			s->subdev_flags |= SDF_GROUND;
-		} else {
-			s->n_chan = 8;
-			s->len_chanlist = 8;
-			s->subdev_flags |= SDF_DIFF;
-		}
-		s->maxdata = (1 << board->ai_nbits) - 1;
-		if (devpriv->user_ai_range_table) { /*  user defined ai range */
-			s->range_table = devpriv->user_ai_range_table;
-		} else if (devpriv->ai_unipolar) {
-			s->range_table = das16_ai_uni_lranges[board->ai_pg];
-		} else {
-			s->range_table = das16_ai_bip_lranges[board->ai_pg];
-		}
-		s->insn_read = board->ai;
-		if (devpriv->dma_chan) {
-			dev->read_subdev = s;
-			s->subdev_flags |= SDF_CMD_READ;
-			s->do_cmdtest = das16_cmd_test;
-			s->do_cmd = das16_cmd_exec;
-			s->cancel = das16_cancel;
-			s->munge = das16_ai_munge;
-		}
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE;
+	if (devpriv->ai_singleended) {
+		s->subdev_flags	|= SDF_GROUND;
+		s->n_chan	= 16;
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->subdev_flags	|= SDF_DIFF;
+		s->n_chan	= 8;
+	}
+	s->len_chanlist	= s->n_chan;
+	s->maxdata	= (1 << board->ai_nbits) - 1;
+	if (devpriv->user_ai_range_table) { /*  user defined ai range */
+		s->range_table	= devpriv->user_ai_range_table;
+	} else if (devpriv->ai_unipolar) {
+		s->range_table	= das16_ai_uni_lranges[board->ai_pg];
+	} else {
+		s->range_table	= das16_ai_bip_lranges[board->ai_pg];
+	}
+	s->insn_read	= das16_ai_insn_read;
+	if (devpriv->dma_chan) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->do_cmdtest	= das16_cmd_test;
+		s->do_cmd	= das16_cmd_exec;
+		s->cancel	= das16_cancel;
+		s->munge	= das16_ai_munge;
 	}
 
 	s = &dev->subdevices[1];
@@ -1232,7 +1228,6 @@ static void das16_detach(struct comedi_device *dev)
 static const struct das16_board das16_boards[] = {
 	{
 		.name		= "das-16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
@@ -1246,7 +1241,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-16g",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 15000,
 		.ai_pg		= das16_pg_none,
@@ -1260,7 +1254,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-16f",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 8500,
 		.ai_pg		= das16_pg_none,
@@ -1274,7 +1267,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "cio-das16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
@@ -1288,7 +1280,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x80,
 	}, {
 		.name		= "cio-das16/f",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
@@ -1302,7 +1293,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x80,
 	}, {
 		.name		= "cio-das16/jr",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 7692,
 		.ai_pg		= das16_pg_16jr,
@@ -1315,7 +1305,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "pc104-das16jr",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 3300,
 		.ai_pg		= das16_pg_16jr,
@@ -1328,7 +1317,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "cio-das16jr/16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 16,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
@@ -1341,7 +1329,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "pc104-das16jr/16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 16,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_16jr_16,
@@ -1354,7 +1341,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x00,
 	}, {
 		.name		= "das-1201",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 20000,
 		.ai_pg		= das16_pg_none,
@@ -1367,7 +1353,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x20,
 	}, {
 		.name		= "das-1202",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_none,
@@ -1380,7 +1365,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0x20,
 	}, {
 		.name		= "das-1401",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
@@ -1393,7 +1377,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1402",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
@@ -1406,7 +1389,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1601",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1601,
@@ -1420,7 +1402,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "das-1602",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
@@ -1434,7 +1415,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1401/12",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
@@ -1447,7 +1427,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1402/12",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1602,
@@ -1460,7 +1439,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1402/16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 16,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
@@ -1473,7 +1451,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1601/12",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 6250,
 		.ai_pg		= das16_pg_1601,
@@ -1487,7 +1464,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1602/12",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
@@ -1501,7 +1477,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das1602/16",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 16,
 		.ai_speed	= 10000,
 		.ai_pg		= das16_pg_1602,
@@ -1515,7 +1490,6 @@ static const struct das16_board das16_boards[] = {
 		.id		= 0xc0,
 	}, {
 		.name		= "cio-das16/330",
-		.ai		= das16_ai_rinsn,
 		.ai_nbits	= 12,
 		.ai_speed	= 3030,
 		.ai_pg		= das16_pg_16jr,

commit b0926a7afabe49021f4fbed9baac0419ad3aa56a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:48:38 2013 -0700

    staging: comedi: das16: fix DMA init during board attach
    
    DMA support is optional in this driver. To enable it, the user
    passes the desired DMA channel during the board attach. A timer
    is then used by the driver to periodically get the analog input
    data from the DMA.
    
    Since the DMA support is optional, modify the init code so that
    it only fails if the DMA channel is unavailable or the DMA buffers
    can not be allocated. Don't fail just because the user passed an
    invalid DMA channel (only DMA channels 1 and 3 are valid).
    
    Remove the printk() noise about the DMA. Change the printk() when
    the request_dma() fails into a dev_err().
    
    Move the timer initialization so it's only setup if DMA is available.
    It's not needed otherwise. Also, only hook up the subdevice command
    support functions if DMA is available. This allows removing a couple
    sanity checks in the command support.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 52f98a71c80f..f35aabd960f9 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -633,8 +633,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* disable interrupts, dma and pacer clocked conversions */
 	devpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
-	if (devpriv->dma_chan)
-		disable_dma(devpriv->dma_chan);
+	disable_dma(devpriv->dma_chan);
 
 	/*  disable SW timer */
 	if (devpriv->timer_running) {
@@ -821,11 +820,6 @@ static void das16_interrupt(struct comedi_device *dev)
 	async = s->async;
 	cmd = &async->cmd;
 
-	if (devpriv->dma_chan == 0) {
-		comedi_error(dev, "interrupt with no dma channel?");
-		return;
-	}
-
 	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if ((devpriv->control_state & DMA_ENABLE) == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
@@ -987,10 +981,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
+	struct comedi_krange *user_ai_range;
+	struct comedi_krange *user_ao_range;
+	unsigned int dma_chan = it->options[2];
 	int ret;
-	unsigned int dma_chan;
-	unsigned long flags;
-	struct comedi_krange *user_ai_range, *user_ao_range;
 
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
@@ -1039,35 +1033,38 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		das1600_mode_detect(dev);
 	}
 
-	/*  initialize dma */
-	dma_chan = it->options[2];
+	/* initialize dma */
 	if (dma_chan == 1 || dma_chan == 3) {
-		/*  allocate dma buffers */
+		unsigned long flags;
 		int i;
-		for (i = 0; i < 2; i++) {
-			devpriv->dma_buffer[i] = pci_alloc_consistent(
-						NULL, DAS16_DMA_SIZE,
-						&devpriv->dma_buffer_addr[i]);
 
-			if (devpriv->dma_buffer[i] == NULL)
-				return -ENOMEM;
-		}
 		if (request_dma(dma_chan, dev->board_name)) {
-			printk(KERN_ERR " failed to allocate dma channel %i\n",
-			       dma_chan);
+			dev_err(dev->class_dev,
+				"failed to request dma channel %i\n",
+				dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
+
+		/* allocate dma buffers */
+		for (i = 0; i < 2; i++) {
+			void *p;
+
+			p = pci_alloc_consistent(NULL, DAS16_DMA_SIZE,
+						 &devpriv->dma_buffer_addr[i]);
+			if (!p)
+				return -ENOMEM;
+			devpriv->dma_buffer[i] = p;
+		}
+
 		flags = claim_dma_lock();
 		disable_dma(devpriv->dma_chan);
 		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 		release_dma_lock(flags);
-		printk(KERN_INFO " ( dma = %u)\n", dma_chan);
-	} else if (dma_chan == 0) {
-		printk(KERN_INFO " ( no dma )\n");
-	} else {
-		printk(KERN_ERR " invalid dma channel\n");
-		return -EINVAL;
+
+		init_timer(&(devpriv->timer));
+		devpriv->timer.function = das16_timer_interrupt;
+		devpriv->timer.data = (unsigned long)dev;
 	}
 
 	/*  get any user-defined input range */
@@ -1098,20 +1095,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		user_ao_range->flags = UNIT_volt;
 	}
 
-	init_timer(&(devpriv->timer));
-	devpriv->timer.function = das16_timer_interrupt;
-	devpriv->timer.data = (unsigned long)dev;
-
 	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)
 		return ret;
 
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	/* ai */
 	if (board->ai) {
 		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+		s->subdev_flags = SDF_READABLE;
 		if (devpriv->ai_singleended) {
 			s->n_chan = 16;
 			s->len_chanlist = 16;
@@ -1130,10 +1122,14 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->range_table = das16_ai_bip_lranges[board->ai_pg];
 		}
 		s->insn_read = board->ai;
-		s->do_cmdtest = das16_cmd_test;
-		s->do_cmd = das16_cmd_exec;
-		s->cancel = das16_cancel;
-		s->munge = das16_ai_munge;
+		if (devpriv->dma_chan) {
+			dev->read_subdev = s;
+			s->subdev_flags |= SDF_CMD_READ;
+			s->do_cmdtest = das16_cmd_test;
+			s->do_cmd = das16_cmd_exec;
+			s->cancel = das16_cancel;
+			s->munge = das16_ai_munge;
+		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}

commit 5589c7cc9f37e929754e0a14b85db7c23a28129f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:48:19 2013 -0700

    staging: comedi: das16: remove DMA irq support
    
    As noted in the driver, a timer is always used by this driver to handle
    the DMA because samples could be dropped while waiting for the DMA done
    interrupt.
    
    Remove the irq setup code as well as the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2dd03da22a2e..52f98a71c80f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -872,24 +872,6 @@ static void das16_interrupt(struct comedi_device *dev)
 	cfc_handle_events(dev, s);
 }
 
-static irqreturn_t das16_dma_interrupt(int irq, void *d)
-{
-	int status;
-	struct comedi_device *dev = d;
-
-	status = inb(dev->iobase + DAS16_STATUS);
-
-	if ((status & DAS16_INT) == 0) {
-		DEBUG_PRINT("spurious interrupt\n");
-		return IRQ_NONE;
-	}
-
-	/* clear interrupt */
-	outb(0x00, dev->iobase + DAS16_STATUS);
-	das16_interrupt(dev);
-	return IRQ_HANDLED;
-}
-
 static void das16_timer_interrupt(unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
@@ -1006,18 +988,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
-	unsigned int irq;
 	unsigned int dma_chan;
 	unsigned long flags;
 	struct comedi_krange *user_ai_range, *user_ao_range;
 
-#if 0
-	irq = it->options[1];
-#endif
-	/* always use time_mode since using irq can drop samples while
-	 * waiting for dma done interrupt (due to hardware limitations) */
-	irq = 0;
-
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
@@ -1065,22 +1039,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		das1600_mode_detect(dev);
 	}
 
-	/* now for the irq */
-	if (irq > 1 && irq < 8) {
-		ret = request_irq(irq, das16_dma_interrupt, 0,
-				  dev->board_name, dev);
-
-		if (ret < 0)
-			return ret;
-		dev->irq = irq;
-		printk(KERN_INFO " ( irq = %u )", irq);
-	} else if (irq == 0) {
-		printk(" ( no irq )");
-	} else {
-		printk(" invalid irq\n");
-		return -EINVAL;
-	}
-
 	/*  initialize dma */
 	dma_chan = it->options[2];
 	if (dma_chan == 1 || dma_chan == 3) {

commit 23cdad3360a39b1b81e1068b1027db25c9e16d97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 13:48:01 2013 -0700

    staging: comedi: das16: "timer_mode" is always used for DMA
    
    As noted in the driver, a timer is always used by this driver to handle the
    DMA due to buggy DMA controllers and the lack of a hardware fifo in some of
    the supported boards.
    
    Remove all the non-timer mode specific code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 593ec3866146..2dd03da22a2e 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -387,7 +387,6 @@ struct das16_private_struct {
 
 	struct timer_list timer;	/*  for timed interrupt */
 	volatile short timer_running;
-	volatile short timer_mode;	/*  true if using timer mode */
 
 	unsigned long extra_iobase;
 };
@@ -516,49 +515,6 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
-/* utility function that suggests a dma transfer size in bytes */
-static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-						const struct comedi_cmd *cmd)
-{
-	struct das16_private_struct *devpriv = dev->private;
-	unsigned int size;
-	unsigned int freq;
-
-	/* if we are using timer interrupt, we don't care how long it
-	 * will take to complete transfer since it will be interrupted
-	 * by timer interrupt */
-	if (devpriv->timer_mode)
-		return DAS16_DMA_SIZE;
-
-	/* otherwise, we are relying on dma terminal count interrupt,
-	 * so pick a reasonable size */
-	if (cmd->convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd->convert_arg;
-	else if (cmd->scan_begin_src == TRIG_TIMER)
-		freq = (1000000000 / cmd->scan_begin_arg) * cmd->chanlist_len;
-	/*  return some default value */
-	else
-		freq = 0xffffffff;
-
-	if (cmd->flags & TRIG_WAKE_EOS) {
-		size = sample_size * cmd->chanlist_len;
-	} else {
-		/*  make buffer fill in no more than 1/3 second */
-		size = (freq / 3) * sample_size;
-	}
-
-	/*  set a minimum and maximum size allowed */
-	if (size > DAS16_DMA_SIZE)
-		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
-	else if (size < sample_size)
-		size = sample_size;
-
-	if (cmd->stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
-		size = devpriv->adc_byte_count;
-
-	return size;
-}
-
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 				    int rounding_flags)
 {
@@ -585,13 +541,6 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 	int range;
 
-	if (devpriv->dma_chan == 0 || (dev->irq == 0
-				       && devpriv->timer_mode == 0)) {
-		comedi_error(dev,
-				"irq (or use of 'timer mode') dma required to "
-							"execute comedi_cmd");
-		return -1;
-	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev, "isa dma transfers cannot be performed with "
 							"TRIG_RT, aborting");
@@ -648,24 +597,16 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->current_buffer = 0;
 	set_dma_addr(devpriv->dma_chan,
 		     devpriv->dma_buffer_addr[devpriv->current_buffer]);
-	/*  set appropriate size of transfer */
-	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, cmd);
+	devpriv->dma_transfer_size = DAS16_DMA_SIZE;
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);
 
 	/*  set up interrupt */
-	if (devpriv->timer_mode) {
-		devpriv->timer_running = 1;
-		devpriv->timer.expires = jiffies + timer_period();
-		add_timer(&devpriv->timer);
-		devpriv->control_state &= ~DAS16_INTE;
-	} else {
-		/* clear interrupt bit */
-		outb(0x00, dev->iobase + DAS16_STATUS);
-		/* enable interrupts */
-		devpriv->control_state |= DAS16_INTE;
-	}
+	devpriv->timer_running = 1;
+	devpriv->timer.expires = jiffies + timer_period();
+	add_timer(&devpriv->timer);
+	devpriv->control_state &= ~DAS16_INTE;
 	devpriv->control_state |= DMA_ENABLE;
 	devpriv->control_state &= ~PACING_MASK;
 	if (cmd->convert_src == TRIG_EXT)
@@ -696,7 +637,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 		disable_dma(devpriv->dma_chan);
 
 	/*  disable SW timer */
-	if (devpriv->timer_mode && devpriv->timer_running) {
+	if (devpriv->timer_running) {
 		devpriv->timer_running = 0;
 		del_timer(&devpriv->timer);
 	}
@@ -864,7 +805,6 @@ static int disable_dma_on_even(struct comedi_device *dev)
 
 static void das16_interrupt(struct comedi_device *dev)
 {
-	const struct das16_board *board = comedi_board(dev);
 	struct das16_private_struct *devpriv = dev->private;
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -915,21 +855,12 @@ static void das16_interrupt(struct comedi_device *dev)
 	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
 	devpriv->adc_byte_count -= num_bytes;
 
-	/*  figure out how many bytes for next transfer */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
-	    devpriv->dma_transfer_size > devpriv->adc_byte_count)
-		devpriv->dma_transfer_size = devpriv->adc_byte_count;
-
 	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		set_dma_addr(devpriv->dma_chan,
 			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
-		/* reenable conversions for das1600 mode, (stupid hardware) */
-		if (board->size > 0x400 && devpriv->timer_mode == 0)
-			outb(0x00, dev->iobase + DAS1600_CONV);
-
 	}
 	release_dma_lock(dma_flags);
 
@@ -1077,20 +1008,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int ret;
 	unsigned int irq;
 	unsigned int dma_chan;
-	int timer_mode;
 	unsigned long flags;
 	struct comedi_krange *user_ai_range, *user_ao_range;
 
 #if 0
 	irq = it->options[1];
-	timer_mode = it->options[8];
 #endif
 	/* always use time_mode since using irq can drop samples while
 	 * waiting for dma done interrupt (due to hardware limitations) */
 	irq = 0;
-	timer_mode = 1;
-	if (timer_mode)
-		irq = 0;
 
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
@@ -1214,12 +1140,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		user_ao_range->flags = UNIT_volt;
 	}
 
-	if (timer_mode) {
-		init_timer(&(devpriv->timer));
-		devpriv->timer.function = das16_timer_interrupt;
-		devpriv->timer.data = (unsigned long)dev;
-	}
-	devpriv->timer_mode = timer_mode ? 1 : 0;
+	init_timer(&(devpriv->timer));
+	devpriv->timer.function = das16_timer_interrupt;
+	devpriv->timer.data = (unsigned long)dev;
 
 	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret)

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 66be41db59ad..593ec3866146 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -73,6 +73,8 @@ www.measurementcomputing.com
 
 */
 
+#include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index dbec3ba99548..66be41db59ad 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -74,7 +74,6 @@ www.measurementcomputing.com
 */
 
 #include <linux/pci.h>
-#include <linux/slab.h>
 #include <linux/interrupt.h>
 
 #include <asm/dma.h>
@@ -1102,10 +1101,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	if (board->size < 0x400) {
 		ret = comedi_request_region(dev, it->options[0], board->size);

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index dab7647ec2f5..dbec3ba99548 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1333,7 +1333,6 @@ static void das16_detach(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 
 	das16_reset(dev);
-	comedi_spriv_free(dev, 4);
 	if (devpriv) {
 		int i;
 		for (i = 0; i < 2; i++) {

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 762b5a6eac5a..dab7647ec2f5 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -16,12 +16,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
 */
 /*
 Driver: das16

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index b2826710cebb..762b5a6eac5a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1354,8 +1354,6 @@ static void das16_detach(struct comedi_device *dev)
 		kfree(devpriv->user_ai_range_table);
 		kfree(devpriv->user_ao_range_table);
 	}
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	if (devpriv->extra_iobase)
 		release_region(devpriv->extra_iobase, board->size & 0x3ff);
 	comedi_legacy_detach(dev);

commit adfaa207ca4140fe6a09550549308248e651e2b9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:32:12 2013 -0700

    staging: comedi: das16: use comedi_legacy_detach()
    
    Use the new comedi_legacy_detach() helper in the (*detach) to release
    the first I/O region requested by this driver.
    
    An additional I/O region is requested for some of the boards this driver
    supports. Save the iobase for that region in the private data so that
    the (*detach) knows it needs to be released.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c2b5015448ae..b2826710cebb 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -393,6 +393,8 @@ struct das16_private_struct {
 	struct timer_list timer;	/*  for timed interrupt */
 	volatile short timer_running;
 	volatile short timer_mode;	/*  true if using timer mode */
+
+	unsigned long extra_iobase;
 };
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -1122,11 +1124,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/* Request an additional region for the 8255 */
 		ret = __comedi_request_region(dev, dev->iobase + 0x400,
 					      board->size & 0x3ff);
-		if (ret) {
-			release_region(dev->iobase, 0x10);
-			dev->iobase = 0;
-			return -EIO;
-		}
+		if (ret)
+			return ret;
+		devpriv->extra_iobase = dev->iobase + 0x400;
 	}
 
 	/*  probe id bits to make sure they are consistent */
@@ -1356,15 +1356,9 @@ static void das16_detach(struct comedi_device *dev)
 	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->iobase) {
-		if (board->size < 0x400) {
-			release_region(dev->iobase, board->size);
-		} else {
-			release_region(dev->iobase, 0x10);
-			release_region(dev->iobase + 0x400,
-				       board->size & 0x3ff);
-		}
-	}
+	if (devpriv->extra_iobase)
+		release_region(devpriv->extra_iobase, board->size & 0x3ff);
+	comedi_legacy_detach(dev);
 }
 
 static const struct das16_board das16_boards[] = {

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 50902ccb5193..c2b5015448ae 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1339,8 +1339,7 @@ static void das16_detach(struct comedi_device *dev)
 	struct das16_private_struct *devpriv = dev->private;
 
 	das16_reset(dev);
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, &dev->subdevices[4]);
+	comedi_spriv_free(dev, 4);
 	if (devpriv) {
 		int i;
 		for (i = 0; i < 2; i++) {

commit 962e5a36c718678b89939a217eb527c56d9ee8a0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:30:48 2013 -0700

    staging: comedi: das16: use __comedi_request_region()
    
    Use __comedi_request_region() to request the additional I/O region
    used by this driver.
    
    Remove the error message when the request_region() fails,
    comedi_request_reqion() will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 01fe078f3914..50902ccb5193 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1120,13 +1120,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret)
 			return ret;
 		/* Request an additional region for the 8255 */
-		if (!request_region(dev->iobase + 0x400, board->size & 0x3ff,
-				    dev->board_name)) {
+		ret = __comedi_request_region(dev, dev->iobase + 0x400,
+					      board->size & 0x3ff);
+		if (ret) {
 			release_region(dev->iobase, 0x10);
-			dev_warn(dev->class_dev,
-				 "%s: I/O port conflict (%#lx,%d)\n",
-				 dev->board_name,
-				 dev->iobase + 0x400, board->size & 0x3ff);
 			dev->iobase = 0;
 			return -EIO;
 		}

commit 7c0bad23e5d7011d1d350080fcbda4bec525521d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:15:55 2013 -0700

    staging: comedi: das16: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    This driver does a second request_region() for the I/O space needed
    by the 8255 chip. Modify the error message if that request fails so
    it matches to format of the comedi_request_region() message.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c84f7795994e..01fe078f3914 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1079,13 +1079,11 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	int ret;
 	unsigned int irq;
-	unsigned long iobase;
 	unsigned int dma_chan;
 	int timer_mode;
 	unsigned long flags;
 	struct comedi_krange *user_ai_range, *user_ao_range;
 
-	iobase = it->options[0];
 #if 0
 	irq = it->options[1];
 	timer_mode = it->options[8];
@@ -1097,8 +1095,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (timer_mode)
 		irq = 0;
 
-	printk(KERN_INFO "comedi%d: das16:", dev->minor);
-
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
@@ -1116,33 +1112,26 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->private = devpriv;
 
 	if (board->size < 0x400) {
-		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + board->size);
-		if (!request_region(iobase, board->size, dev->board_name)) {
-			printk(KERN_ERR " I/O port conflict\n");
-			return -EIO;
-		}
+		ret = comedi_request_region(dev, it->options[0], board->size);
+		if (ret)
+			return ret;
 	} else {
-		printk(KERN_INFO " 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
-		       iobase, iobase + 0x0f,
-		       iobase + 0x400,
-		       iobase + 0x400 + (board->size & 0x3ff));
-		if (!request_region(iobase, 0x10, dev->board_name)) {
-			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
-			       iobase, iobase + 0x0f);
-			return -EIO;
-		}
-		if (!request_region(iobase + 0x400, board->size & 0x3ff,
+		ret = comedi_request_region(dev, it->options[0], 0x10);
+		if (ret)
+			return ret;
+		/* Request an additional region for the 8255 */
+		if (!request_region(dev->iobase + 0x400, board->size & 0x3ff,
 				    dev->board_name)) {
-			release_region(iobase, 0x10);
-			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
-			       iobase + 0x400,
-			       iobase + 0x400 + (board->size & 0x3ff));
+			release_region(dev->iobase, 0x10);
+			dev_warn(dev->class_dev,
+				 "%s: I/O port conflict (%#lx,%d)\n",
+				 dev->board_name,
+				 dev->iobase + 0x400, board->size & 0x3ff);
+			dev->iobase = 0;
 			return -EIO;
 		}
 	}
 
-	dev->iobase = iobase;
-
 	/*  probe id bits to make sure they are consistent */
 	if (das16_probe(dev, it)) {
 		printk(KERN_ERR " id bits do not match selected board, aborting\n");

commit 8234d51a280290a23e9c21d5f1a5988d984cbdc9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:15:33 2013 -0700

    staging: comedi: das16: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name and use it
    when requesting the resources instead of the open-coded strings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index caeaee8d4840..c84f7795994e 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1117,7 +1117,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	if (board->size < 0x400) {
 		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + board->size);
-		if (!request_region(iobase, board->size, "das16")) {
+		if (!request_region(iobase, board->size, dev->board_name)) {
 			printk(KERN_ERR " I/O port conflict\n");
 			return -EIO;
 		}
@@ -1126,13 +1126,13 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		       iobase, iobase + 0x0f,
 		       iobase + 0x400,
 		       iobase + 0x400 + (board->size & 0x3ff));
-		if (!request_region(iobase, 0x10, "das16")) {
+		if (!request_region(iobase, 0x10, dev->board_name)) {
 			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase, iobase + 0x0f);
 			return -EIO;
 		}
 		if (!request_region(iobase + 0x400, board->size & 0x3ff,
-				    "das16")) {
+				    dev->board_name)) {
 			release_region(iobase, 0x10);
 			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase + 0x400,
@@ -1148,7 +1148,6 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		printk(KERN_ERR " id bits do not match selected board, aborting\n");
 		return -EINVAL;
 	}
-	dev->board_name = board->name;
 
 	/*  get master clock speed */
 	if (board->size < 0x400) {
@@ -1162,7 +1161,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* now for the irq */
 	if (irq > 1 && irq < 8) {
-		ret = request_irq(irq, das16_dma_interrupt, 0, "das16", dev);
+		ret = request_irq(irq, das16_dma_interrupt, 0,
+				  dev->board_name, dev);
 
 		if (ret < 0)
 			return ret;
@@ -1188,7 +1188,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			if (devpriv->dma_buffer[i] == NULL)
 				return -ENOMEM;
 		}
-		if (request_dma(dma_chan, "das16")) {
+		if (request_dma(dma_chan, dev->board_name)) {
 			printk(KERN_ERR " failed to allocate dma channel %i\n",
 			       dma_chan);
 			return -EINVAL;

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f238a1fbccbf..caeaee8d4840 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -876,7 +876,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	int num_bytes, residue;
 	int buffer_index;
 
-	if (dev->attached == 0) {
+	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return;
 	}

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index b159f44d694f..f238a1fbccbf 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -82,7 +82,9 @@ www.measurementcomputing.com
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+
 #include <asm/dma.h>
+
 #include "../comedidev.h"
 
 #include "8253.h"

commit a48e1258b43fcd00ba0c273cd75c27003191e05e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:54:11 2012 -0700

    staging: comedi: das16: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of das16_cmd_test().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2ceadcb97408..b159f44d694f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -442,46 +442,27 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	/*  check against maximum frequency */
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg <
-		    board->ai_speed * cmd->chanlist_len) {
-			cmd->scan_begin_arg =
-			    board->ai_speed * cmd->chanlist_len;
-			err++;
-		}
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < board->ai_speed) {
-			cmd->convert_arg = board->ai_speed;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	/* check against maximum frequency */
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+					board->ai_speed * cmd->chanlist_len);
+
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 board->ai_speed);
+
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
-	if (cmd->stop_src == TRIG_NONE) {
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
 	if (err)
 		return 3;
 

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 3f614dcde8bc..2ceadcb97408 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1127,10 +1127,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	if (board->size < 0x400) {
 		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + board->size);

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index fcb8a32adb2f..3f614dcde8bc 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -392,12 +392,12 @@ struct das16_private_struct {
 	volatile short timer_running;
 	volatile short timer_mode;	/*  true if using timer mode */
 };
-#define devpriv ((struct das16_private_struct *)(dev->private))
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	int err = 0, tmp;
 	int gain, start_chan, i;
 	int mask;
@@ -540,6 +540,7 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 						const struct comedi_cmd *cmd)
 {
+	struct das16_private_struct *devpriv = dev->private;
 	unsigned int size;
 	unsigned int freq;
 
@@ -581,6 +582,8 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 				    int rounding_flags)
 {
+	struct das16_private_struct *devpriv = dev->private;
+
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
 				       &(devpriv->divisor2), &ns,
 				       rounding_flags & TRIG_ROUND_MASK);
@@ -595,6 +598,7 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
@@ -701,6 +705,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -738,6 +743,7 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	int i, n;
 	int range;
 	int chan;
@@ -848,10 +854,12 @@ static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 */
 static int disable_dma_on_even(struct comedi_device *dev)
 {
+	struct das16_private_struct *devpriv = dev->private;
 	int residue;
 	int i;
 	static const int disable_limit = 100;
 	static const int enable_timeout = 100;
+
 	disable_dma(devpriv->dma_chan);
 	residue = get_dma_residue(devpriv->dma_chan);
 	for (i = 0; i < disable_limit && (residue % 2); ++i) {
@@ -877,6 +885,7 @@ static int disable_dma_on_even(struct comedi_device *dev)
 static void das16_interrupt(struct comedi_device *dev)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
@@ -973,6 +982,7 @@ static irqreturn_t das16_dma_interrupt(int irq, void *d)
 static void das16_timer_interrupt(unsigned long arg)
 {
 	struct comedi_device *dev = (struct comedi_device *)arg;
+	struct das16_private_struct *devpriv = dev->private;
 
 	das16_interrupt(dev);
 
@@ -1001,6 +1011,7 @@ static void reg_dump(struct comedi_device *dev)
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 	int status;
 	int diobits;
 
@@ -1035,6 +1046,7 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static int das1600_mode_detect(struct comedi_device *dev)
 {
+	struct das16_private_struct *devpriv = dev->private;
 	int status = 0;
 
 	status = inb(dev->iobase + DAS1600_STATUS_B);
@@ -1080,6 +1092,7 @@ static void das16_ai_munge(struct comedi_device *dev,
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 	unsigned int irq;
@@ -1114,9 +1127,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	ret = alloc_private(dev, sizeof(struct das16_private_struct));
-	if (ret < 0)
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
+	devpriv = dev->private;
 
 	if (board->size < 0x400) {
 		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + board->size);
@@ -1353,6 +1367,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void das16_detach(struct comedi_device *dev)
 {
 	const struct das16_board *board = comedi_board(dev);
+	struct das16_private_struct *devpriv = dev->private;
 
 	das16_reset(dev);
 	if (dev->subdevices)

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 744376a49d08..fcb8a32adb2f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -402,62 +402,42 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	int gain, start_chan, i;
 	int mask;
 
-	/* make sure triggers are valid */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
 
-	tmp = cmd->scan_begin_src;
 	mask = TRIG_FOLLOW;
 	/*  if board supports burst mode */
 	if (board->size > 0x400)
 		mask |= TRIG_TIMER | TRIG_EXT;
-	cmd->scan_begin_src &= mask;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, mask);
 
 	tmp = cmd->convert_src;
 	mask = TRIG_TIMER | TRIG_EXT;
 	/*  if board supports burst mode */
 	if (board->size > 0x400)
 		mask |= TRIG_NOW;
-	cmd->convert_src &= mask;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, mask);
 
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/**
-	 * step 2: make sure trigger sources are unique and
-	 * mutually compatible
-	 */
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
-		err++;
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	/*  make sure scan_begin_src and convert_src dont conflict */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
-		err++;
+		err |= -EINVAL;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit 44b255f7b13bacb076e2789352e4a8afe19b922e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 19 19:37:40 2012 +0100

    staging: comedi: das16: pass struct comedi_cmd by reference
    
    Change `das16_suggest_transfer_size()` to take a pointer to the `struct
    comedi_cmd` instead of passing it by value.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2a38915c69e8..744376a49d08 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -558,7 +558,7 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-						struct comedi_cmd cmd)
+						const struct comedi_cmd *cmd)
 {
 	unsigned int size;
 	unsigned int freq;
@@ -571,16 +571,16 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 
 	/* otherwise, we are relying on dma terminal count interrupt,
 	 * so pick a reasonable size */
-	if (cmd.convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd.convert_arg;
-	else if (cmd.scan_begin_src == TRIG_TIMER)
-		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
+	if (cmd->convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd->convert_arg;
+	else if (cmd->scan_begin_src == TRIG_TIMER)
+		freq = (1000000000 / cmd->scan_begin_arg) * cmd->chanlist_len;
 	/*  return some default value */
 	else
 		freq = 0xffffffff;
 
-	if (cmd.flags & TRIG_WAKE_EOS) {
-		size = sample_size * cmd.chanlist_len;
+	if (cmd->flags & TRIG_WAKE_EOS) {
+		size = sample_size * cmd->chanlist_len;
 	} else {
 		/*  make buffer fill in no more than 1/3 second */
 		size = (freq / 3) * sample_size;
@@ -592,7 +592,7 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 	else if (size < sample_size)
 		size = sample_size;
 
-	if (cmd.stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
+	if (cmd->stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
 		size = devpriv->adc_byte_count;
 
 	return size;
@@ -685,7 +685,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	set_dma_addr(devpriv->dma_chan,
 		     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 	/*  set appropriate size of transfer */
-	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
+	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, cmd);
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);

commit 35d10629f19570cd0d9e7b4485f027f300a12d33
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:35:45 2012 -0700

    staging: comedi: das16: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 895cc7783c9c..2a38915c69e8 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1268,7 +1268,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	/* ai */
 	if (board->ai) {
@@ -1300,7 +1300,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	/* ao */
 	if (board->ao) {
 		s->type = COMEDI_SUBD_AO;
@@ -1318,7 +1318,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/* di */
 	if (board->di) {
 		s->type = COMEDI_SUBD_DI;
@@ -1331,7 +1331,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	/* do */
 	if (board->do_) {
 		s->type = COMEDI_SUBD_DO;
@@ -1346,7 +1346,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	s = dev->subdevices + 4;
+	s = &dev->subdevices[4];
 	/* 8255 */
 	if (board->i8255_offset != 0) {
 		subdev_8255_init(dev, s, NULL, (dev->iobase +
@@ -1376,7 +1376,7 @@ static void das16_detach(struct comedi_device *dev)
 
 	das16_reset(dev);
 	if (dev->subdevices)
-		subdev_8255_cleanup(dev, dev->subdevices + 4);
+		subdev_8255_cleanup(dev, &dev->subdevices[4]);
 	if (devpriv) {
 		int i;
 		for (i = 0; i < 2; i++) {

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 0c6ad1067055..895cc7783c9c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -812,7 +812,7 @@ static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 	data[1] = bits;
 	data[0] = 0;
 
-	return 2;
+	return insn->n;
 }
 
 static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -832,7 +832,7 @@ static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	outb(s->state, dev->iobase + DAS16_DIO);
 
-	return 2;
+	return insn->n;
 }
 
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 6a8a7eb1ae9c..0c6ad1067055 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1265,7 +1265,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->timer_mode = timer_mode ? 1 : 0;
 
 	ret = comedi_alloc_subdevices(dev, 5);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 61705366dd40..6a8a7eb1ae9c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1264,7 +1264,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	devpriv->timer_mode = timer_mode ? 1 : 0;
 
-	ret = alloc_subdevices(dev, 5);
+	ret = comedi_alloc_subdevices(dev, 5);
 	if (ret < 0)
 		return ret;
 

commit d493f213ab2bfcc41792f904abee75ecfd6afc10
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 16:09:58 2012 -0700

    staging: comedi: remove thisboard macro in the das16 driver
    
    The 'thisboard' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 998444c1ba32..61705366dd40 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -393,11 +393,11 @@ struct das16_private_struct {
 	volatile short timer_mode;	/*  true if using timer mode */
 };
 #define devpriv ((struct das16_private_struct *)(dev->private))
-#define thisboard ((struct das16_board *)(dev->board_ptr))
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_cmd *cmd)
 {
+	const struct das16_board *board = comedi_board(dev);
 	int err = 0, tmp;
 	int gain, start_chan, i;
 	int mask;
@@ -411,7 +411,7 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	tmp = cmd->scan_begin_src;
 	mask = TRIG_FOLLOW;
 	/*  if board supports burst mode */
-	if (thisboard->size > 0x400)
+	if (board->size > 0x400)
 		mask |= TRIG_TIMER | TRIG_EXT;
 	cmd->scan_begin_src &= mask;
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
@@ -420,7 +420,7 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	tmp = cmd->convert_src;
 	mask = TRIG_TIMER | TRIG_EXT;
 	/*  if board supports burst mode */
-	if (thisboard->size > 0x400)
+	if (board->size > 0x400)
 		mask |= TRIG_NOW;
 	cmd->convert_src &= mask;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -483,15 +483,15 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  check against maximum frequency */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
-		    thisboard->ai_speed * cmd->chanlist_len) {
+		    board->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-			    thisboard->ai_speed * cmd->chanlist_len;
+			    board->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
+		if (cmd->convert_arg < board->ai_speed) {
+			cmd->convert_arg = board->ai_speed;
 			err++;
 		}
 	}
@@ -614,6 +614,7 @@ static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 
 static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct das16_board *board = comedi_board(dev);
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
@@ -637,7 +638,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
 	/*  disable conversions for das1600 mode */
-	if (thisboard->size > 0x400)
+	if (board->size > 0x400)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
 
 	/*  set scan limits */
@@ -648,9 +649,9 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* set gain (this is also burst rate register but according to
 	 * computer boards manual, burst rate does nothing, even on
 	 * keithley cards) */
-	if (thisboard->ai_pg != das16_pg_none) {
+	if (board->ai_pg != das16_pg_none) {
 		range = CR_RANGE(cmd->chanlist[0]);
-		outb((das16_gainlists[thisboard->ai_pg])[range],
+		outb((das16_gainlists[board->ai_pg])[range],
 		     dev->iobase + DAS16_GAIN);
 	}
 
@@ -663,7 +664,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* enable counters */
 	byte = 0;
 	/* Enable burst mode if appropriate. */
-	if (thisboard->size > 0x400) {
+	if (board->size > 0x400) {
 		if (cmd->convert_src == TRIG_NOW) {
 			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
 			/*  set burst length */
@@ -710,7 +711,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
 	/* Enable conversions if using das1600 mode */
-	if (thisboard->size > 0x400)
+	if (board->size > 0x400)
 		outb(0, dev->iobase + DAS1600_CONV);
 
 
@@ -719,6 +720,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct das16_board *board = comedi_board(dev);
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -735,7 +737,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* disable burst mode */
-	if (thisboard->size > 0x400)
+	if (board->size > 0x400)
 		outb(0, dev->iobase + DAS1600_BURST);
 
 
@@ -755,6 +757,7 @@ static void das16_reset(struct comedi_device *dev)
 static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	const struct das16_board *board = comedi_board(dev);
 	int i, n;
 	int range;
 	int chan;
@@ -770,9 +773,9 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	outb(chan, dev->iobase + DAS16_MUX);
 
 	/* set gain */
-	if (thisboard->ai_pg != das16_pg_none) {
+	if (board->ai_pg != das16_pg_none) {
 		range = CR_RANGE(insn->chanspec);
-		outb((das16_gainlists[thisboard->ai_pg])[range],
+		outb((das16_gainlists[board->ai_pg])[range],
 		     dev->iobase + DAS16_GAIN);
 	}
 
@@ -790,7 +793,7 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		msb = inb(dev->iobase + DAS16_AI_MSB);
 		lsb = inb(dev->iobase + DAS16_AI_LSB);
-		if (thisboard->ai_nbits == 12)
+		if (board->ai_nbits == 12)
 			data[n] = ((lsb >> 4) & 0xf) | (msb << 4);
 		else
 			data[n] = lsb | (msb << 8);
@@ -835,6 +838,7 @@ static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	const struct das16_board *board = comedi_board(dev);
 	int i;
 	int lsb, msb;
 	int chan;
@@ -842,7 +846,7 @@ static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	chan = CR_CHAN(insn->chanspec);
 
 	for (i = 0; i < insn->n; i++) {
-		if (thisboard->ao_nbits == 12) {
+		if (board->ao_nbits == 12) {
 			lsb = (data[i] << 4) & 0xff;
 			msb = (data[i] >> 4) & 0xff;
 		} else {
@@ -892,6 +896,7 @@ static int disable_dma_on_even(struct comedi_device *dev)
 
 static void das16_interrupt(struct comedi_device *dev)
 {
+	const struct das16_board *board = comedi_board(dev);
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
@@ -953,7 +958,7 @@ static void das16_interrupt(struct comedi_device *dev)
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		/* reenable conversions for das1600 mode, (stupid hardware) */
-		if (thisboard->size > 0x400 && devpriv->timer_mode == 0)
+		if (board->size > 0x400 && devpriv->timer_mode == 0)
 			outb(0x00, dev->iobase + DAS1600_CONV);
 
 	}
@@ -1015,6 +1020,7 @@ static void reg_dump(struct comedi_device *dev)
 
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct das16_board *board = comedi_board(dev);
 	int status;
 	int diobits;
 
@@ -1039,9 +1045,9 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 	diobits = inb(dev->iobase + DAS16_DIO) & 0xf0;
 
 	printk(KERN_INFO " id bits are 0x%02x\n", diobits);
-	if (thisboard->id != diobits) {
+	if (board->id != diobits) {
 		printk(KERN_INFO " requested board's id bits are 0x%x (ignore)\n",
-		       thisboard->id);
+		       board->id);
 	}
 
 	return 0;
@@ -1071,12 +1077,13 @@ static void das16_ai_munge(struct comedi_device *dev,
 			   unsigned int num_bytes,
 			   unsigned int start_chan_index)
 {
+	const struct das16_board *board = comedi_board(dev);
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *data = array;
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);
-		if (thisboard->ai_nbits == 12)
+		if (board->ai_nbits == 12)
 			data[i] = (data[i] >> 4) & 0xfff;
 
 	}
@@ -1092,6 +1099,7 @@ static void das16_ai_munge(struct comedi_device *dev,
  */
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct das16_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	int ret;
 	unsigned int irq;
@@ -1130,9 +1138,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0)
 		return ret;
 
-	if (thisboard->size < 0x400) {
-		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + thisboard->size);
-		if (!request_region(iobase, thisboard->size, "das16")) {
+	if (board->size < 0x400) {
+		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + board->size);
+		if (!request_region(iobase, board->size, "das16")) {
 			printk(KERN_ERR " I/O port conflict\n");
 			return -EIO;
 		}
@@ -1140,18 +1148,18 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		printk(KERN_INFO " 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
 		       iobase, iobase + 0x0f,
 		       iobase + 0x400,
-		       iobase + 0x400 + (thisboard->size & 0x3ff));
+		       iobase + 0x400 + (board->size & 0x3ff));
 		if (!request_region(iobase, 0x10, "das16")) {
 			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase, iobase + 0x0f);
 			return -EIO;
 		}
-		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
+		if (!request_region(iobase + 0x400, board->size & 0x3ff,
 				    "das16")) {
 			release_region(iobase, 0x10);
 			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase + 0x400,
-			       iobase + 0x400 + (thisboard->size & 0x3ff));
+			       iobase + 0x400 + (board->size & 0x3ff));
 			return -EIO;
 		}
 	}
@@ -1163,10 +1171,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		printk(KERN_ERR " id bits do not match selected board, aborting\n");
 		return -EINVAL;
 	}
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 	/*  get master clock speed */
-	if (thisboard->size < 0x400) {
+	if (board->size < 0x400) {
 		if (it->options[3])
 			devpriv->clockbase = 1000 / it->options[3];
 		else
@@ -1222,7 +1230,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/*  get any user-defined input range */
-	if (thisboard->ai_pg == das16_pg_none &&
+	if (board->ai_pg == das16_pg_none &&
 	    (it->options[4] || it->options[5])) {
 		/*  allocate single-range range table */
 		devpriv->user_ai_range_table =
@@ -1263,7 +1271,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s = dev->subdevices + 0;
 	dev->read_subdev = s;
 	/* ai */
-	if (thisboard->ai) {
+	if (board->ai) {
 		s->type = COMEDI_SUBD_AI;
 		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
 		if (devpriv->ai_singleended) {
@@ -1275,15 +1283,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->len_chanlist = 8;
 			s->subdev_flags |= SDF_DIFF;
 		}
-		s->maxdata = (1 << thisboard->ai_nbits) - 1;
+		s->maxdata = (1 << board->ai_nbits) - 1;
 		if (devpriv->user_ai_range_table) { /*  user defined ai range */
 			s->range_table = devpriv->user_ai_range_table;
 		} else if (devpriv->ai_unipolar) {
-			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
+			s->range_table = das16_ai_uni_lranges[board->ai_pg];
 		} else {
-			s->range_table = das16_ai_bip_lranges[thisboard->ai_pg];
+			s->range_table = das16_ai_bip_lranges[board->ai_pg];
 		}
-		s->insn_read = thisboard->ai;
+		s->insn_read = board->ai;
 		s->do_cmdtest = das16_cmd_test;
 		s->do_cmd = das16_cmd_exec;
 		s->cancel = das16_cancel;
@@ -1294,44 +1302,44 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s = dev->subdevices + 1;
 	/* ao */
-	if (thisboard->ao) {
+	if (board->ao) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 2;
-		s->maxdata = (1 << thisboard->ao_nbits) - 1;
+		s->maxdata = (1 << board->ao_nbits) - 1;
 		/*  user defined ao range */
 		if (devpriv->user_ao_range_table)
 			s->range_table = devpriv->user_ao_range_table;
 		else
 			s->range_table = &range_unknown;
 
-		s->insn_write = thisboard->ao;
+		s->insn_write = board->ao;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
 	s = dev->subdevices + 2;
 	/* di */
-	if (thisboard->di) {
+	if (board->di) {
 		s->type = COMEDI_SUBD_DI;
 		s->subdev_flags = SDF_READABLE;
 		s->n_chan = 4;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
-		s->insn_bits = thisboard->di;
+		s->insn_bits = board->di;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
 	s = dev->subdevices + 3;
 	/* do */
-	if (thisboard->do_) {
+	if (board->do_) {
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 		s->n_chan = 4;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
-		s->insn_bits = thisboard->do_;
+		s->insn_bits = board->do_;
 		/*  initialize digital output lines */
 		outb(s->state, dev->iobase + DAS16_DIO);
 	} else {
@@ -1340,9 +1348,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s = dev->subdevices + 4;
 	/* 8255 */
-	if (thisboard->i8255_offset != 0) {
+	if (board->i8255_offset != 0) {
 		subdev_8255_init(dev, s, NULL, (dev->iobase +
-						thisboard->i8255_offset));
+						board->i8255_offset));
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
@@ -1353,7 +1361,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
 	/*  turn on das1600 mode if available */
-	if (thisboard->size > 0x400) {
+	if (board->size > 0x400) {
 		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
 		outb(0, dev->iobase + DAS1600_CONV);
 		outb(0, dev->iobase + DAS1600_BURST);
@@ -1364,6 +1372,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void das16_detach(struct comedi_device *dev)
 {
+	const struct das16_board *board = comedi_board(dev);
+
 	das16_reset(dev);
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 4);
@@ -1384,12 +1394,12 @@ static void das16_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->iobase) {
-		if (thisboard->size < 0x400) {
-			release_region(dev->iobase, thisboard->size);
+		if (board->size < 0x400) {
+			release_region(dev->iobase, board->size);
 		} else {
 			release_region(dev->iobase, 0x10);
 			release_region(dev->iobase + 0x400,
-				       thisboard->size & 0x3ff);
+				       board->size & 0x3ff);
 		}
 	}
 }

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 73c0a2d149d6..998444c1ba32 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1362,15 +1362,11 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-static int das16_detach(struct comedi_device *dev)
+static void das16_detach(struct comedi_device *dev)
 {
-	printk(KERN_INFO "comedi%d: das16: remove\n", dev->minor);
-
 	das16_reset(dev);
-
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 4);
-
 	if (devpriv) {
 		int i;
 		for (i = 0; i < 2; i++) {
@@ -1385,10 +1381,8 @@ static int das16_detach(struct comedi_device *dev)
 		kfree(devpriv->user_ai_range_table);
 		kfree(devpriv->user_ao_range_table);
 	}
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-
 	if (dev->iobase) {
 		if (thisboard->size < 0x400) {
 			release_region(dev->iobase, thisboard->size);
@@ -1398,8 +1392,6 @@ static int das16_detach(struct comedi_device *dev)
 				       thisboard->size & 0x3ff);
 		}
 	}
-
-	return 0;
 }
 
 static const struct das16_board das16_boards[] = {

commit 5cdd9b75bf58422659d824d7aabf46bdb6a8e18c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 18:10:25 2012 -0700

    staging: comedi: refactor das16 driver and use module_comedi_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive to the end of the source. This is more
    typical of how other drivers are written and removes the need
    for the forward declarations.
    
    Refactor some of the other functions to remove the remaining
    forward declarations.
    
    Convert the driver to use the module_comedi_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index e7905bac92da..73c0a2d149d6 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -339,38 +339,6 @@ struct munge_info {
 	unsigned have_byte:1;
 };
 
-static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-
-static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_cmd *cmd);
-static int das16_cmd_exec(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
-static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void das16_ai_munge(struct comedi_device *dev,
-			   struct comedi_subdevice *s, void *array,
-			   unsigned int num_bytes,
-			   unsigned int start_chan_index);
-
-static void das16_reset(struct comedi_device *dev);
-static irqreturn_t das16_dma_interrupt(int irq, void *d);
-static void das16_timer_interrupt(unsigned long arg);
-static void das16_interrupt(struct comedi_device *dev);
-
-static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-				    int flags);
-static int das1600_mode_detect(struct comedi_device *dev);
-static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-						struct comedi_cmd cmd);
-
-static void reg_dump(struct comedi_device *dev);
-
 struct das16_board {
 	const char *name;
 	void *ai;
@@ -389,344 +357,6 @@ struct das16_board {
 	unsigned int id;
 };
 
-static const struct das16_board das16_boards[] = {
-	{
-	 .name = "das-16",
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 15000,
-	 .ai_pg = das16_pg_none,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x10,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "das-16g",
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 15000,
-	 .ai_pg = das16_pg_none,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x10,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "das-16f",
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 8500,
-	 .ai_pg = das16_pg_none,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x10,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "cio-das16",	/*  cio-das16.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 20000,
-	 .ai_pg = das16_pg_none,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x10,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0x80,
-	 },
-	{
-	 .name = "cio-das16/f",	/*  das16.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_none,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x10,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0x80,
-	 },
-	{
-	 .name = "cio-das16/jr",	/*  cio-das16jr.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 7692,
-	 .ai_pg = das16_pg_16jr,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x10,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 3300,
-	 .ai_pg = das16_pg_16jr,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x10,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 16,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_16jr_16,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x10,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 16,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_16jr_16,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x10,
-	 .id = 0x00,
-	 },
-	{
-	 .name = "das-1201",	/*  4924.pdf (keithley user's manual) */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 20000,
-	 .ai_pg = das16_pg_none,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0x20,
-	 },
-	{
-	 .name = "das-1202",	/*  4924.pdf (keithley user's manual) */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_none,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0x20,
-	 },
-	{
-	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	 .name = "das-1401",
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1601,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0   /*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-	 },
-	{
-	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	 .name = "das-1402",
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1602,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0   /*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-	 },
-	{
-	 .name = "das-1601",	/*  4919.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1601,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "das-1602",	/*  4919.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1602,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 6250,
-	 .ai_pg = das16_pg_1601,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 6250,
-	 .ai_pg = das16_pg_1602,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 16,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1602,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 6250,
-	 .ai_pg = das16_pg_1601,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1602,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 16,
-	 .ai_speed = 10000,
-	 .ai_pg = das16_pg_1602,
-	 .ao = das16_ao_winsn,
-	 .ao_nbits = 12,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0x400,
-	 .i8254_offset = 0x0c,
-	 .size = 0x408,
-	 .id = 0xc0},
-	{
-	 .name = "cio-das16/330",	/*  ? */
-	 .ai = das16_ai_rinsn,
-	 .ai_nbits = 12,
-	 .ai_speed = 3030,
-	 .ai_pg = das16_pg_16jr,
-	 .ao = NULL,
-	 .di = das16_di_rbits,
-	 .do_ = das16_do_wbits,
-	 .i8255_offset = 0,
-	 .i8254_offset = 0x0c,
-	 .size = 0x14,
-	 .id = 0xf0},
-#if 0
-	{
-	 .name = "das16/330i",	/*  ? */
-	 },
-	{
-	 .name = "das16/jr/ctr5",	/*  ? */
-	 },
-	{
-	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
-	 .name = "cio-das16/m1/16",
-	 },
-#endif
-};
-
-static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int das16_detach(struct comedi_device *dev);
-static struct comedi_driver driver_das16 = {
-	.driver_name = "das16",
-	.module = THIS_MODULE,
-	.attach = das16_attach,
-	.detach = das16_detach,
-	.board_name = &das16_boards[0].name,
-	.num_names = ARRAY_SIZE(das16_boards),
-	.offset = sizeof(das16_boards[0]),
-};
-
 #define DAS16_TIMEOUT 1000
 
 /* Period for timer interrupt in jiffies.  It's a function
@@ -926,6 +556,62 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 0;
 }
 
+/* utility function that suggests a dma transfer size in bytes */
+static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
+						struct comedi_cmd cmd)
+{
+	unsigned int size;
+	unsigned int freq;
+
+	/* if we are using timer interrupt, we don't care how long it
+	 * will take to complete transfer since it will be interrupted
+	 * by timer interrupt */
+	if (devpriv->timer_mode)
+		return DAS16_DMA_SIZE;
+
+	/* otherwise, we are relying on dma terminal count interrupt,
+	 * so pick a reasonable size */
+	if (cmd.convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd.convert_arg;
+	else if (cmd.scan_begin_src == TRIG_TIMER)
+		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
+	/*  return some default value */
+	else
+		freq = 0xffffffff;
+
+	if (cmd.flags & TRIG_WAKE_EOS) {
+		size = sample_size * cmd.chanlist_len;
+	} else {
+		/*  make buffer fill in no more than 1/3 second */
+		size = (freq / 3) * sample_size;
+	}
+
+	/*  set a minimum and maximum size allowed */
+	if (size > DAS16_DMA_SIZE)
+		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
+	else if (size < sample_size)
+		size = sample_size;
+
+	if (cmd.stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
+		size = devpriv->adc_byte_count;
+
+	return size;
+}
+
+static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
+				    int rounding_flags)
+{
+	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
+				       &(devpriv->divisor2), &ns,
+				       rounding_flags & TRIG_ROUND_MASK);
+
+	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
+	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
+	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 2, devpriv->divisor2, 2);
+
+	return ns;
+}
+
 static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
@@ -1170,34 +856,6 @@ static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return i;
 }
 
-static irqreturn_t das16_dma_interrupt(int irq, void *d)
-{
-	int status;
-	struct comedi_device *dev = d;
-
-	status = inb(dev->iobase + DAS16_STATUS);
-
-	if ((status & DAS16_INT) == 0) {
-		DEBUG_PRINT("spurious interrupt\n");
-		return IRQ_NONE;
-	}
-
-	/* clear interrupt */
-	outb(0x00, dev->iobase + DAS16_STATUS);
-	das16_interrupt(dev);
-	return IRQ_HANDLED;
-}
-
-static void das16_timer_interrupt(unsigned long arg)
-{
-	struct comedi_device *dev = (struct comedi_device *)arg;
-
-	das16_interrupt(dev);
-
-	if (devpriv->timer_running)
-		mod_timer(&devpriv->timer, jiffies + timer_period());
-}
-
 /* the pc104-das16jr (at least) has problems if the dma
 	transfer is interrupted in the middle of transferring
 	a 16 bit sample, so this function takes care to get
@@ -1309,18 +967,32 @@ static void das16_interrupt(struct comedi_device *dev)
 	cfc_handle_events(dev, s);
 }
 
-static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-				    int rounding_flags)
+static irqreturn_t das16_dma_interrupt(int irq, void *d)
 {
-	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
-				       &(devpriv->divisor2), &ns,
-				       rounding_flags & TRIG_ROUND_MASK);
+	int status;
+	struct comedi_device *dev = d;
 
-	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
-	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 2, devpriv->divisor2, 2);
+	status = inb(dev->iobase + DAS16_STATUS);
 
-	return ns;
+	if ((status & DAS16_INT) == 0) {
+		DEBUG_PRINT("spurious interrupt\n");
+		return IRQ_NONE;
+	}
+
+	/* clear interrupt */
+	outb(0x00, dev->iobase + DAS16_STATUS);
+	das16_interrupt(dev);
+	return IRQ_HANDLED;
+}
+
+static void das16_timer_interrupt(unsigned long arg)
+{
+	struct comedi_device *dev = (struct comedi_device *)arg;
+
+	das16_interrupt(dev);
+
+	if (devpriv->timer_running)
+		mod_timer(&devpriv->timer, jiffies + timer_period());
 }
 
 static void reg_dump(struct comedi_device *dev)
@@ -1394,6 +1066,22 @@ static int das1600_mode_detect(struct comedi_device *dev)
 	return 0;
 }
 
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index)
+{
+	unsigned int i, num_samples = num_bytes / sizeof(short);
+	short *data = array;
+
+	for (i = 0; i < num_samples; i++) {
+		data[i] = le16_to_cpu(data[i]);
+		if (thisboard->ai_nbits == 12)
+			data[i] = (data[i] >> 4) & 0xfff;
+
+	}
+}
+
 /*
  *
  * Options list:
@@ -1402,7 +1090,6 @@ static int das1600_mode_detect(struct comedi_device *dev)
  *   2  DMA
  *   3  Clock speed (in MHz)
  */
-
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
@@ -1715,76 +1402,316 @@ static int das16_detach(struct comedi_device *dev)
 	return 0;
 }
 
-static int __init driver_das16_init_module(void)
-{
-	return comedi_driver_register(&driver_das16);
-}
-
-static void __exit driver_das16_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_das16);
-}
-
-module_init(driver_das16_init_module);
-module_exit(driver_das16_cleanup_module);
-
-/* utility function that suggests a dma transfer size in bytes */
-static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-						struct comedi_cmd cmd)
-{
-	unsigned int size;
-	unsigned int freq;
-
-	/* if we are using timer interrupt, we don't care how long it
-	 * will take to complete transfer since it will be interrupted
-	 * by timer interrupt */
-	if (devpriv->timer_mode)
-		return DAS16_DMA_SIZE;
-
-	/* otherwise, we are relying on dma terminal count interrupt,
-	 * so pick a reasonable size */
-	if (cmd.convert_src == TRIG_TIMER)
-		freq = 1000000000 / cmd.convert_arg;
-	else if (cmd.scan_begin_src == TRIG_TIMER)
-		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
-	/*  return some default value */
-	else
-		freq = 0xffffffff;
-
-	if (cmd.flags & TRIG_WAKE_EOS) {
-		size = sample_size * cmd.chanlist_len;
-	} else {
-		/*  make buffer fill in no more than 1/3 second */
-		size = (freq / 3) * sample_size;
-	}
-
-	/*  set a minimum and maximum size allowed */
-	if (size > DAS16_DMA_SIZE)
-		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
-	else if (size < sample_size)
-		size = sample_size;
-
-	if (cmd.stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
-		size = devpriv->adc_byte_count;
-
-	return size;
-}
-
-static void das16_ai_munge(struct comedi_device *dev,
-			   struct comedi_subdevice *s, void *array,
-			   unsigned int num_bytes,
-			   unsigned int start_chan_index)
-{
-	unsigned int i, num_samples = num_bytes / sizeof(short);
-	short *data = array;
-
-	for (i = 0; i < num_samples; i++) {
-		data[i] = le16_to_cpu(data[i]);
-		if (thisboard->ai_nbits == 12)
-			data[i] = (data[i] >> 4) & 0xfff;
+static const struct das16_board das16_boards[] = {
+	{
+		.name		= "das-16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 15000,
+		.ai_pg		= das16_pg_none,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "das-16g",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 15000,
+		.ai_pg		= das16_pg_none,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "das-16f",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 8500,
+		.ai_pg		= das16_pg_none,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x00,
+	}, {
+		.name		= "cio-das16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 20000,
+		.ai_pg		= das16_pg_none,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x80,
+	}, {
+		.name		= "cio-das16/f",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_none,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x10,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0x80,
+	}, {
+		.name		= "cio-das16/jr",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 7692,
+		.ai_pg		= das16_pg_16jr,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "pc104-das16jr",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 3300,
+		.ai_pg		= das16_pg_16jr,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "cio-das16jr/16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 16,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_16jr_16,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "pc104-das16jr/16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 16,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_16jr_16,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x10,
+		.id		= 0x00,
+	}, {
+		.name		= "das-1201",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 20000,
+		.ai_pg		= das16_pg_none,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0x20,
+	}, {
+		.name		= "das-1202",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_none,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0x20,
+	}, {
+		.name		= "das-1401",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1601,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1402",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1601",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1601,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "das-1602",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1401/12",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1601,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1402/12",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1602,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1402/16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 16,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1601/12",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 6250,
+		.ai_pg		= das16_pg_1601,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1602/12",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das1602/16",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 16,
+		.ai_speed	= 10000,
+		.ai_pg		= das16_pg_1602,
+		.ao		= das16_ao_winsn,
+		.ao_nbits	= 12,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0x400,
+		.i8254_offset	= 0x0c,
+		.size		= 0x408,
+		.id		= 0xc0,
+	}, {
+		.name		= "cio-das16/330",
+		.ai		= das16_ai_rinsn,
+		.ai_nbits	= 12,
+		.ai_speed	= 3030,
+		.ai_pg		= das16_pg_16jr,
+		.ao		= NULL,
+		.di		= das16_di_rbits,
+		.do_		= das16_do_wbits,
+		.i8255_offset	= 0,
+		.i8254_offset	= 0x0c,
+		.size		= 0x14,
+		.id		= 0xf0,
+	},
+};
 
-	}
-}
+static struct comedi_driver das16_driver = {
+	.driver_name	= "das16",
+	.module		= THIS_MODULE,
+	.attach		= das16_attach,
+	.detach		= das16_detach,
+	.board_name	= &das16_boards[0].name,
+	.num_names	= ARRAY_SIZE(das16_boards),
+	.offset		= sizeof(das16_boards[0]),
+};
+module_comedi_driver(das16_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit e4e1f289be88a75dc8b63d50ade1f9a2e6168021
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:28:57 2011 -0500

    staging: comedi: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 0af1b4659088..e7905bac92da 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1695,10 +1695,8 @@ static int das16_detach(struct comedi_device *dev)
 		}
 		if (devpriv->dma_chan)
 			free_dma(devpriv->dma_chan);
-		if (devpriv->user_ai_range_table)
-			kfree(devpriv->user_ai_range_table);
-		if (devpriv->user_ao_range_table)
-			kfree(devpriv->user_ao_range_table);
+		kfree(devpriv->user_ai_range_table);
+		kfree(devpriv->user_ao_range_table);
 	}
 
 	if (dev->irq)

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 407d011a7606..0af1b4659088 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1717,7 +1717,18 @@ static int das16_detach(struct comedi_device *dev)
 	return 0;
 }
 
-COMEDI_INITCLEANUP(driver_das16);
+static int __init driver_das16_init_module(void)
+{
+	return comedi_driver_register(&driver_das16);
+}
+
+static void __exit driver_das16_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_das16);
+}
+
+module_init(driver_das16_init_module);
+module_exit(driver_das16_cleanup_module);
 
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index ccee4f1802d6..407d011a7606 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1776,3 +1776,7 @@ static void das16_ai_munge(struct comedi_device *dev,
 
 	}
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 3c0d681e7d31fe747a2cbed0a93dd92049521683
Author: Gustavo Silva <silvagustavosilva@gmail.com>
Date:   Wed Apr 21 00:34:35 2010 -0500

    Staging: comedi: drivers: fix coding style issues in das16.c
    
    This is a patch to the das16.c file that fixes up the following issues
    found by the checkpatch.pl tool.
    
    WARNING: line over 80 characters x 23
    ERROR: spaces required around that '?' (ctx:VxV) x 2
    ERROR: spaces required around that ':' (ctx:VxV) x 2
    WARNING: printk() should include KERN_ facility level x 17
    WARNING: braces {} are not necessary for single statement blocks x 8
    
    Signed-off-by: Gustavo Silva <silvagustavo@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index f2aadda9b241..ccee4f1802d6 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -74,7 +74,8 @@ Keithley Manuals:
 	4922.PDF (das-1400)
 	4923.PDF (das1200, 1400, 1600)
 
-Computer boards manuals also available from their website www.measurementcomputing.com
+Computer boards manuals also available from their website
+www.measurementcomputing.com
 
 */
 
@@ -92,7 +93,8 @@ Computer boards manuals also available from their website www.measurementcomputi
 /* #define DEBUG */
 
 #ifdef DEBUG
-#define DEBUG_PRINT(format, args...) printk("das16: " format, ## args)
+#define DEBUG_PRINT(format, args...)	\
+	printk(KERN_DEBUG "das16: " format, ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -186,15 +188,16 @@ Computer boards manuals also available from their website www.measurementcomputi
 
 */
 
-static const int sample_size = 2;	/*  size in bytes of a sample from board */
+/*  size in bytes of a sample from board */
+static const int sample_size = 2;
 
 #define DAS16_TRIG		0
 #define DAS16_AI_LSB		0
 #define DAS16_AI_MSB		1
 #define DAS16_MUX		2
 #define DAS16_DIO		3
-#define DAS16_AO_LSB(x)	((x)?6:4)
-#define DAS16_AO_MSB(x)	((x)?7:5)
+#define DAS16_AO_LSB(x)	((x) ? 6 : 4)
+#define DAS16_AO_MSB(x)	((x) ? 7 : 5)
 #define DAS16_STATUS		8
 #define   BUSY			(1<<7)
 #define   UNIPOLAR			(1<<6)
@@ -271,7 +274,7 @@ static const struct comedi_lrange range_das1x02_unip = { 4, {
 };
 
 static const struct comedi_lrange range_das16jr = { 9, {
-							/*  also used by 16/330 */
+						/*  also used by 16/330 */
 							BIP_RANGE(10),
 							BIP_RANGE(5),
 							BIP_RANGE(2.5),
@@ -547,7 +550,8 @@ static const struct das16_board das16_boards[] = {
 	 .id = 0x20,
 	 },
 	{
-	 .name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .name = "das-1401",
 	 .ai = das16_ai_rinsn,
 	 .ai_nbits = 12,
 	 .ai_speed = 10000,
@@ -558,10 +562,11 @@ static const struct das16_board das16_boards[] = {
 	 .i8255_offset = 0x0,
 	 .i8254_offset = 0x0c,
 	 .size = 0x408,
-	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 .id = 0xc0   /*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 	 },
 	{
-	 .name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .name = "das-1402",
 	 .ai = das16_ai_rinsn,
 	 .ai_nbits = 12,
 	 .ai_speed = 10000,
@@ -572,7 +577,7 @@ static const struct das16_board das16_boards[] = {
 	 .i8255_offset = 0x0,
 	 .i8254_offset = 0x0c,
 	 .size = 0x408,
-	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 .id = 0xc0   /*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 	 },
 	{
 	 .name = "das-1601",	/*  4919.pdf */
@@ -704,7 +709,8 @@ static const struct das16_board das16_boards[] = {
 	 .name = "das16/jr/ctr5",	/*  ? */
 	 },
 	{
-	 .name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
+	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
+	 .name = "cio-das16/m1/16",
 	 },
 #endif
 };
@@ -736,14 +742,19 @@ struct das16_private_struct {
 	unsigned int clockbase;	/*  master clock speed in ns */
 	volatile unsigned int control_state;	/*  dma, interrupt and trigger control bits */
 	volatile unsigned long adc_byte_count;	/*  number of bytes remaining */
-	unsigned int divisor1;	/*  divisor dividing master clock to get conversion frequency */
-	unsigned int divisor2;	/*  divisor dividing master clock to get conversion frequency */
+	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int divisor1;
+	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int divisor2;
 	unsigned int dma_chan;	/*  dma channel */
 	uint16_t *dma_buffer[2];
 	dma_addr_t dma_buffer_addr[2];
 	unsigned int current_buffer;
 	volatile unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
-	/*  user-defined analog input and output ranges defined from config options */
+	/**
+	 * user-defined analog input and output ranges
+	 * defined from config options
+	 */
 	struct comedi_lrange *user_ai_range_table;
 	struct comedi_lrange *user_ao_range_table;
 
@@ -798,7 +809,10 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/**
+	 * step 2: make sure trigger sources are unique and
+	 * mutually compatible
+	 */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->scan_begin_src != TRIG_EXT &&
 	    cmd->scan_begin_src != TRIG_FOLLOW)
@@ -893,12 +907,15 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			if (CR_CHAN(cmd->chanlist[i]) !=
 			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					     "entries in chanlist must be consecutive channels, counting upwards\n");
+						"entries in chanlist must be "
+						"consecutive channels, "
+						"counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					     "entries in chanlist must all have the same gain\n");
+						"entries in chanlist must all "
+						"have the same gain\n");
 				err++;
 			}
 		}
@@ -920,12 +937,13 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->dma_chan == 0 || (dev->irq == 0
 				       && devpriv->timer_mode == 0)) {
 		comedi_error(dev,
-			     "irq (or use of 'timer mode') dma required to execute comedi_cmd");
+				"irq (or use of 'timer mode') dma required to "
+							"execute comedi_cmd");
 		return -1;
 	}
 	if (cmd->flags & TRIG_RT) {
-		comedi_error(dev,
-			     "isa dma transfers cannot be performed with TRIG_RT, aborting");
+		comedi_error(dev, "isa dma transfers cannot be performed with "
+							"TRIG_RT, aborting");
 		return -1;
 	}
 
@@ -933,16 +951,17 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
 	/*  disable conversions for das1600 mode */
-	if (thisboard->size > 0x400) {
+	if (thisboard->size > 0x400)
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
-	}
+
 	/*  set scan limits */
 	byte = CR_CHAN(cmd->chanlist[0]);
 	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
 	outb(byte, dev->iobase + DAS16_MUX);
 
 	/* set gain (this is also burst rate register but according to
-	 * computer boards manual, burst rate does nothing, even on keithley cards) */
+	 * computer boards manual, burst rate does nothing, even on
+	 * keithley cards) */
 	if (thisboard->ai_pg != das16_pg_none) {
 		range = CR_RANGE(cmd->chanlist[0]);
 		outb((das16_gainlists[thisboard->ai_pg])[range],
@@ -1005,9 +1024,9 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
 	/* Enable conversions if using das1600 mode */
-	if (thisboard->size > 0x400) {
+	if (thisboard->size > 0x400)
 		outb(0, dev->iobase + DAS1600_CONV);
-	}
+
 
 	return 0;
 }
@@ -1030,9 +1049,9 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* disable burst mode */
-	if (thisboard->size > 0x400) {
+	if (thisboard->size > 0x400)
 		outb(0, dev->iobase + DAS1600_BURST);
-	}
+
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1085,11 +1104,11 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		}
 		msb = inb(dev->iobase + DAS16_AI_MSB);
 		lsb = inb(dev->iobase + DAS16_AI_LSB);
-		if (thisboard->ai_nbits == 12) {
+		if (thisboard->ai_nbits == 12)
 			data[n] = ((lsb >> 4) & 0xf) | (msb << 4);
-		} else {
+		else
 			data[n] = lsb | (msb << 8);
-		}
+
 	}
 
 	return n;
@@ -1207,8 +1226,8 @@ static int disable_dma_on_even(struct comedi_device *dev)
 		residue = get_dma_residue(devpriv->dma_chan);
 	}
 	if (i == disable_limit) {
-		comedi_error(dev,
-			     "failed to get an even dma transfer, could be trouble.");
+		comedi_error(dev, "failed to get an even dma transfer, "
+							"could be trouble.");
 	}
 	return residue;
 }
@@ -1254,7 +1273,8 @@ static void das16_interrupt(struct comedi_device *dev)
 	} else
 		num_bytes = devpriv->dma_transfer_size - residue;
 
-	if (cmd->stop_src == TRIG_COUNT && num_bytes >= devpriv->adc_byte_count) {
+	if (cmd->stop_src == TRIG_COUNT &&
+					num_bytes >= devpriv->adc_byte_count) {
 		num_bytes = devpriv->adc_byte_count;
 		async->events |= COMEDI_CB_EOA;
 	}
@@ -1275,9 +1295,9 @@ static void das16_interrupt(struct comedi_device *dev)
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		/* reenable conversions for das1600 mode, (stupid hardware) */
-		if (thisboard->size > 0x400 && devpriv->timer_mode == 0) {
+		if (thisboard->size > 0x400 && devpriv->timer_mode == 0)
 			outb(0x00, dev->iobase + DAS1600_CONV);
-		}
+
 	}
 	release_dma_lock(dma_flags);
 
@@ -1330,25 +1350,25 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	status = inb(dev->iobase + DAS16_STATUS);
 
-	if ((status & UNIPOLAR)) {
+	if ((status & UNIPOLAR))
 		devpriv->ai_unipolar = 1;
-	} else {
+	else
 		devpriv->ai_unipolar = 0;
-	}
 
-	if ((status & DAS16_MUXBIT)) {
+
+	if ((status & DAS16_MUXBIT))
 		devpriv->ai_singleended = 1;
-	} else {
+	else
 		devpriv->ai_singleended = 0;
-	}
+
 
 	/* diobits indicates boards */
 
 	diobits = inb(dev->iobase + DAS16_DIO) & 0xf0;
 
-	printk(" id bits are 0x%02x\n", diobits);
+	printk(KERN_INFO " id bits are 0x%02x\n", diobits);
 	if (thisboard->id != diobits) {
-		printk(" requested board's id bits are 0x%x (ignore)\n",
+		printk(KERN_INFO " requested board's id bits are 0x%x (ignore)\n",
 		       thisboard->id);
 	}
 
@@ -1363,10 +1383,10 @@ static int das1600_mode_detect(struct comedi_device *dev)
 
 	if (status & DAS1600_CLK_10MHZ) {
 		devpriv->clockbase = 100;
-		printk(" 10MHz pacer clock\n");
+		printk(KERN_INFO " 10MHz pacer clock\n");
 	} else {
 		devpriv->clockbase = 1000;
-		printk(" 1MHz pacer clock\n");
+		printk(KERN_INFO " 1MHz pacer clock\n");
 	}
 
 	reg_dump(dev);
@@ -1406,14 +1426,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (timer_mode)
 		irq = 0;
 
-	printk("comedi%d: das16:", dev->minor);
+	printk(KERN_INFO "comedi%d: das16:", dev->minor);
 
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
 		    it->options[3] != 1 && it->options[3] != 10) {
 			printk
-			    ("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
+			    ("\n Invalid option.  Master clock must be set "
+							"to 1 or 10 (MHz)\n");
 			return -EINVAL;
 		}
 	}
@@ -1425,23 +1446,23 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (thisboard->size < 0x400) {
 		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + thisboard->size);
 		if (!request_region(iobase, thisboard->size, "das16")) {
-			printk(" I/O port conflict\n");
+			printk(KERN_ERR " I/O port conflict\n");
 			return -EIO;
 		}
 	} else {
-		printk(" 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
+		printk(KERN_INFO " 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
 		       iobase, iobase + 0x0f,
 		       iobase + 0x400,
 		       iobase + 0x400 + (thisboard->size & 0x3ff));
 		if (!request_region(iobase, 0x10, "das16")) {
-			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
+			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase, iobase + 0x0f);
 			return -EIO;
 		}
 		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
 				    "das16")) {
 			release_region(iobase, 0x10);
-			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
+			printk(KERN_ERR " I/O port conflict:  0x%04lx-0x%04lx\n",
 			       iobase + 0x400,
 			       iobase + 0x400 + (thisboard->size & 0x3ff));
 			return -EIO;
@@ -1452,7 +1473,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  probe id bits to make sure they are consistent */
 	if (das16_probe(dev, it)) {
-		printk(" id bits do not match selected board, aborting\n");
+		printk(KERN_ERR " id bits do not match selected board, aborting\n");
 		return -EINVAL;
 	}
 	dev->board_name = thisboard->name;
@@ -1474,7 +1495,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret < 0)
 			return ret;
 		dev->irq = irq;
-		printk(" ( irq = %u )", irq);
+		printk(KERN_INFO " ( irq = %u )", irq);
 	} else if (irq == 0) {
 		printk(" ( no irq )");
 	} else {
@@ -1488,16 +1509,15 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/*  allocate dma buffers */
 		int i;
 		for (i = 0; i < 2; i++) {
-			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
-								      DAS16_DMA_SIZE,
-								      &devpriv->
-								      dma_buffer_addr
-								      [i]);
+			devpriv->dma_buffer[i] = pci_alloc_consistent(
+						NULL, DAS16_DMA_SIZE,
+						&devpriv->dma_buffer_addr[i]);
+
 			if (devpriv->dma_buffer[i] == NULL)
 				return -ENOMEM;
 		}
 		if (request_dma(dma_chan, "das16")) {
-			printk(" failed to allocate dma channel %i\n",
+			printk(KERN_ERR " failed to allocate dma channel %i\n",
 			       dma_chan);
 			return -EINVAL;
 		}
@@ -1506,11 +1526,11 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		disable_dma(devpriv->dma_chan);
 		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
 		release_dma_lock(flags);
-		printk(" ( dma = %u)\n", dma_chan);
+		printk(KERN_INFO " ( dma = %u)\n", dma_chan);
 	} else if (dma_chan == 0) {
-		printk(" ( no dma )\n");
+		printk(KERN_INFO " ( no dma )\n");
 	} else {
-		printk(" invalid dma channel\n");
+		printk(KERN_ERR " invalid dma channel\n");
 		return -EINVAL;
 	}
 
@@ -1569,7 +1589,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->subdev_flags |= SDF_DIFF;
 		}
 		s->maxdata = (1 << thisboard->ai_nbits) - 1;
-		if (devpriv->user_ai_range_table) {	/*  user defined ai range */
+		if (devpriv->user_ai_range_table) { /*  user defined ai range */
 			s->range_table = devpriv->user_ai_range_table;
 		} else if (devpriv->ai_unipolar) {
 			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
@@ -1592,11 +1612,12 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 2;
 		s->maxdata = (1 << thisboard->ao_nbits) - 1;
-		if (devpriv->user_ao_range_table) {	/*  user defined ao range */
+		/*  user defined ao range */
+		if (devpriv->user_ao_range_table)
 			s->range_table = devpriv->user_ao_range_table;
-		} else {
+		else
 			s->range_table = &range_unknown;
-		}
+
 		s->insn_write = thisboard->ao;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -1656,7 +1677,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static int das16_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: das16: remove\n", dev->minor);
+	printk(KERN_INFO "comedi%d: das16: remove\n", dev->minor);
 
 	das16_reset(dev);
 
@@ -1750,8 +1771,8 @@ static void das16_ai_munge(struct comedi_device *dev,
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);
-		if (thisboard->ai_nbits == 12) {
+		if (thisboard->ai_nbits == 12)
 			data[i] = (data[i] >> 4) & 0xfff;
-		}
+
 	}
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 10a87e6a8095..f2aadda9b241 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -79,6 +79,7 @@ Computer boards manuals also available from their website www.measurementcomputi
 */
 
 #include <linux/pci.h>
+#include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <asm/dma.h>
 #include "../comedidev.h"

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 59af86a8bbfb..10a87e6a8095 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -238,61 +238,67 @@ static const int sample_size = 2;	/*  size in bytes of a sample from board */
 #define   DAS1600_CLK_10MHZ		0x01
 
 static const struct comedi_lrange range_das1x01_bip = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-	}
+							    BIP_RANGE(10),
+							    BIP_RANGE(1),
+							    BIP_RANGE(0.1),
+							    BIP_RANGE(0.01),
+							    }
 };
+
 static const struct comedi_lrange range_das1x01_unip = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01),
-	}
+							     UNI_RANGE(10),
+							     UNI_RANGE(1),
+							     UNI_RANGE(0.1),
+							     UNI_RANGE(0.01),
+							     }
 };
+
 static const struct comedi_lrange range_das1x02_bip = { 4, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-	}
+							    BIP_RANGE(10),
+							    BIP_RANGE(5),
+							    BIP_RANGE(2.5),
+							    BIP_RANGE(1.25),
+							    }
 };
+
 static const struct comedi_lrange range_das1x02_unip = { 4, {
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25),
+							     }
 };
+
 static const struct comedi_lrange range_das16jr = { 9, {
-			/*  also used by 16/330 */
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							/*  also used by 16/330 */
+							BIP_RANGE(10),
+							BIP_RANGE(5),
+							BIP_RANGE(2.5),
+							BIP_RANGE(1.25),
+							BIP_RANGE(0.625),
+							UNI_RANGE(10),
+							UNI_RANGE(5),
+							UNI_RANGE(2.5),
+							UNI_RANGE(1.25),
+							}
 };
+
 static const struct comedi_lrange range_das16jr_16 = { 8, {
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25),
-	}
+							   BIP_RANGE(10),
+							   BIP_RANGE(5),
+							   BIP_RANGE(2.5),
+							   BIP_RANGE(1.25),
+							   UNI_RANGE(10),
+							   UNI_RANGE(5),
+							   UNI_RANGE(2.5),
+							   UNI_RANGE(1.25),
+							   }
 };
 
 static const int das16jr_gainlist[] = { 8, 0, 1, 2, 3, 4, 5, 6, 7 };
 static const int das16jr_16_gainlist[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
 static const int das1600_gainlist[] = { 0, 1, 2, 3 };
+
 enum {
 	das16_pg_none = 0,
 	das16_pg_16jr,
@@ -307,6 +313,7 @@ static const int *const das16_gainlists[] = {
 	das1600_gainlist,
 	das1600_gainlist,
 };
+
 static const struct comedi_lrange *const das16_ai_uni_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
@@ -314,6 +321,7 @@ static const struct comedi_lrange *const das16_ai_uni_lranges[] = {
 	&range_das1x01_unip,
 	&range_das1x02_unip,
 };
+
 static const struct comedi_lrange *const das16_ai_bip_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
@@ -328,20 +336,23 @@ struct munge_info {
 };
 
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			  struct comedi_insn *insn, unsigned int *data);
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s);
+			  struct comedi_cmd *cmd);
+static int das16_cmd_exec(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *array, unsigned int num_bytes, unsigned int start_chan_index);
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index);
 
 static void das16_reset(struct comedi_device *dev);
 static irqreturn_t das16_dma_interrupt(int irq, void *d);
@@ -349,10 +360,10 @@ static void das16_timer_interrupt(unsigned long arg);
 static void das16_interrupt(struct comedi_device *dev);
 
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int flags);
+				    int flags);
 static int das1600_mode_detect(struct comedi_device *dev);
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-	struct comedi_cmd cmd);
+						struct comedi_cmd cmd);
 
 static void reg_dump(struct comedi_device *dev);
 
@@ -376,324 +387,324 @@ struct das16_board {
 
 static const struct das16_board das16_boards[] = {
 	{
-	.name = "das-16",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 15000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
+	 .name = "das-16",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 15000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
 	{
-	.name = "das-16g",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 15000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
+	 .name = "das-16g",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 15000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
 	{
-	.name = "das-16f",
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 8500,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x00,
-		},
+	 .name = "das-16f",
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 8500,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x00,
+	 },
 	{
-	.name = "cio-das16",	/*  cio-das16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 20000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x80,
-		},
+	 .name = "cio-das16",	/*  cio-das16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 20000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x80,
+	 },
 	{
-	.name = "cio-das16/f",	/*  das16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_none,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x10,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0x80,
-		},
+	 .name = "cio-das16/f",	/*  das16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_none,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x10,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0x80,
+	 },
 	{
-	.name = "cio-das16/jr",	/*  cio-das16jr.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 7692,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
+	 .name = "cio-das16/jr",	/*  cio-das16jr.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 7692,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
 	{
-	.name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 3300,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
+	 .name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 3300,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
 	{
-	.name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_16jr_16,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
+	 .name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_16jr_16,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
 	{
-	.name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_16jr_16,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x10,
-	.id = 0x00,
-		},
+	 .name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_16jr_16,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x10,
+	 .id = 0x00,
+	 },
 	{
-	.name = "das-1201",	/*  4924.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 20000,
-	.ai_pg = das16_pg_none,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0x20,
-		},
+	 .name = "das-1201",	/*  4924.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 20000,
+	 .ai_pg = das16_pg_none,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0x20,
+	 },
 	{
-	.name = "das-1202",	/*  4924.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_none,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0x20,
-		},
+	 .name = "das-1202",	/*  4924.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_none,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0x20,
+	 },
 	{
-	.name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1601,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-		},
+	 .name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1601,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 },
 	{
-	.name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
-		},
+	 .name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0		/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	 },
 	{
-	.name = "das-1601",	/*  4919.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1601,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "das-1601",	/*  4919.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1601,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "das-1602",	/*  4919.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "das-1602",	/*  4919.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1601,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1601,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 6250,
-	.ai_pg = das16_pg_1601,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 6250,
+	 .ai_pg = das16_pg_1601,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 16,
-	.ai_speed = 10000,
-	.ai_pg = das16_pg_1602,
-	.ao = das16_ao_winsn,
-	.ao_nbits = 12,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0x400,
-	.i8254_offset = 0x0c,
-	.size = 0x408,
-	.id = 0xc0},
+	 .name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 16,
+	 .ai_speed = 10000,
+	 .ai_pg = das16_pg_1602,
+	 .ao = das16_ao_winsn,
+	 .ao_nbits = 12,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0x400,
+	 .i8254_offset = 0x0c,
+	 .size = 0x408,
+	 .id = 0xc0},
 	{
-	.name = "cio-das16/330",	/*  ? */
-	.ai = das16_ai_rinsn,
-	.ai_nbits = 12,
-	.ai_speed = 3030,
-	.ai_pg = das16_pg_16jr,
-	.ao = NULL,
-	.di = das16_di_rbits,
-	.do_ = das16_do_wbits,
-	.i8255_offset = 0,
-	.i8254_offset = 0x0c,
-	.size = 0x14,
-	.id = 0xf0},
+	 .name = "cio-das16/330",	/*  ? */
+	 .ai = das16_ai_rinsn,
+	 .ai_nbits = 12,
+	 .ai_speed = 3030,
+	 .ai_pg = das16_pg_16jr,
+	 .ao = NULL,
+	 .di = das16_di_rbits,
+	 .do_ = das16_do_wbits,
+	 .i8255_offset = 0,
+	 .i8254_offset = 0x0c,
+	 .size = 0x14,
+	 .id = 0xf0},
 #if 0
 	{
-	.name = "das16/330i",	/*  ? */
-		},
+	 .name = "das16/330i",	/*  ? */
+	 },
 	{
-	.name = "das16/jr/ctr5",	/*  ? */
-		},
+	 .name = "das16/jr/ctr5",	/*  ? */
+	 },
 	{
-	.name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
-		},
+	 .name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
+	 },
 #endif
 };
 
@@ -717,6 +728,7 @@ static inline int timer_period(void)
 {
 	return HZ / 20;
 }
+
 struct das16_private_struct {
 	unsigned int ai_unipolar;	/*  unipolar flag */
 	unsigned int ai_singleended;	/*  single ended flag */
@@ -742,7 +754,7 @@ struct das16_private_struct {
 #define thisboard ((struct das16_board *)(dev->board_ptr))
 
 static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			  struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	int gain, start_chan, i;
@@ -787,11 +799,11 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_FOLLOW)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_FOLLOW)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
@@ -826,9 +838,9 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  check against maximum frequency */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -853,16 +865,20 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		unsigned int tmp = cmd->scan_begin_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->scan_begin_arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->convert_arg;
 		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		err += (tmp != cmd->convert_arg);
 	}
 	if (err)
@@ -874,14 +890,14 @@ static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -901,19 +917,19 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	int range;
 
 	if (devpriv->dma_chan == 0 || (dev->irq == 0
-			&& devpriv->timer_mode == 0)) {
+				       && devpriv->timer_mode == 0)) {
 		comedi_error(dev,
-			"irq (or use of 'timer mode') dma required to execute comedi_cmd");
+			     "irq (or use of 'timer mode') dma required to execute comedi_cmd");
 		return -1;
 	}
 	if (cmd->flags & TRIG_RT) {
 		comedi_error(dev,
-			"isa dma transfers cannot be performed with TRIG_RT, aborting");
+			     "isa dma transfers cannot be performed with TRIG_RT, aborting");
 		return -1;
 	}
 
 	devpriv->adc_byte_count =
-		cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
+	    cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
 	/*  disable conversions for das1600 mode */
 	if (thisboard->size > 0x400) {
@@ -929,13 +945,13 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (thisboard->ai_pg != das16_pg_none) {
 		range = CR_RANGE(cmd->chanlist[0]);
 		outb((das16_gainlists[thisboard->ai_pg])[range],
-			dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN);
 	}
 
 	/* set counter mode and counts */
 	cmd->convert_arg =
-		das16_set_pacer(dev, cmd->convert_arg,
-		cmd->flags & TRIG_ROUND_MASK);
+	    das16_set_pacer(dev, cmd->convert_arg,
+			    cmd->flags & TRIG_ROUND_MASK);
 	DEBUG_PRINT("pacer period: %d ns\n", cmd->convert_arg);
 
 	/* enable counters */
@@ -960,7 +976,7 @@ static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 	clear_dma_ff(devpriv->dma_chan);
 	devpriv->current_buffer = 0;
 	set_dma_addr(devpriv->dma_chan,
-		devpriv->dma_buffer_addr[devpriv->current_buffer]);
+		     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 	/*  set appropriate size of transfer */
 	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
@@ -1031,7 +1047,7 @@ static void das16_reset(struct comedi_device *dev)
 }
 
 static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int range;
@@ -1051,7 +1067,7 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (thisboard->ai_pg != das16_pg_none) {
 		range = CR_RANGE(insn->chanspec);
 		outb((das16_gainlists[thisboard->ai_pg])[range],
-			dev->iobase + DAS16_GAIN);
+		     dev->iobase + DAS16_GAIN);
 	}
 
 	for (n = 0; n < insn->n; n++) {
@@ -1079,7 +1095,7 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -1091,7 +1107,7 @@ static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1111,7 +1127,7 @@ static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int lsb, msb;
@@ -1154,7 +1170,7 @@ static irqreturn_t das16_dma_interrupt(int irq, void *d)
 
 static void das16_timer_interrupt(unsigned long arg)
 {
-	struct comedi_device *dev = (struct comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *)arg;
 
 	das16_interrupt(dev);
 
@@ -1191,7 +1207,7 @@ static int disable_dma_on_even(struct comedi_device *dev)
 	}
 	if (i == disable_limit) {
 		comedi_error(dev,
-			"failed to get an even dma transfer, could be trouble.");
+			     "failed to get an even dma transfer, could be trouble.");
 	}
 	return residue;
 }
@@ -1248,13 +1264,13 @@ static void das16_interrupt(struct comedi_device *dev)
 
 	/*  figure out how many bytes for next transfer */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
-		devpriv->dma_transfer_size > devpriv->adc_byte_count)
+	    devpriv->dma_transfer_size > devpriv->adc_byte_count)
 		devpriv->dma_transfer_size = devpriv->adc_byte_count;
 
 	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		set_dma_addr(devpriv->dma_chan,
-			devpriv->dma_buffer_addr[devpriv->current_buffer]);
+			     devpriv->dma_buffer_addr[devpriv->current_buffer]);
 		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma_chan);
 		/* reenable conversions for das1600 mode, (stupid hardware) */
@@ -1267,16 +1283,17 @@ static void das16_interrupt(struct comedi_device *dev)
 	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	cfc_write_array_to_buffer(s,
-		devpriv->dma_buffer[buffer_index], num_bytes);
+				  devpriv->dma_buffer[buffer_index], num_bytes);
 
 	cfc_handle_events(dev, s);
 }
 
 static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
-	int rounding_flags)
+				    int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
-		&(devpriv->divisor2), &ns, rounding_flags & TRIG_ROUND_MASK);
+				       &(devpriv->divisor2), &ns,
+				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
@@ -1295,12 +1312,12 @@ static void reg_dump(struct comedi_device *dev)
 	DEBUG_PRINT("DAS16_PACER: %x\n", inb(dev->iobase + DAS16_PACER));
 	DEBUG_PRINT("DAS16_GAIN: %x\n", inb(dev->iobase + DAS16_GAIN));
 	DEBUG_PRINT("DAS16_CNTR_CONTROL: %x\n",
-		inb(dev->iobase + DAS16_CNTR_CONTROL));
+		    inb(dev->iobase + DAS16_CNTR_CONTROL));
 	DEBUG_PRINT("DAS1600_CONV: %x\n", inb(dev->iobase + DAS1600_CONV));
 	DEBUG_PRINT("DAS1600_BURST: %x\n", inb(dev->iobase + DAS1600_BURST));
 	DEBUG_PRINT("DAS1600_ENABLE: %x\n", inb(dev->iobase + DAS1600_ENABLE));
 	DEBUG_PRINT("DAS1600_STATUS_B: %x\n",
-		inb(dev->iobase + DAS1600_STATUS_B));
+		    inb(dev->iobase + DAS1600_STATUS_B));
 }
 
 static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
@@ -1331,7 +1348,7 @@ static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(" id bits are 0x%02x\n", diobits);
 	if (thisboard->id != diobits) {
 		printk(" requested board's id bits are 0x%x (ignore)\n",
-			thisboard->id);
+		       thisboard->id);
 	}
 
 	return 0;
@@ -1393,8 +1410,9 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
-			it->options[3] != 1 && it->options[3] != 10) {
-			printk("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
+		    it->options[3] != 1 && it->options[3] != 10) {
+			printk
+			    ("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
 			return -EINVAL;
 		}
 	}
@@ -1411,20 +1429,20 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	} else {
 		printk(" 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
-			iobase, iobase + 0x0f,
-			iobase + 0x400,
-			iobase + 0x400 + (thisboard->size & 0x3ff));
+		       iobase, iobase + 0x0f,
+		       iobase + 0x400,
+		       iobase + 0x400 + (thisboard->size & 0x3ff));
 		if (!request_region(iobase, 0x10, "das16")) {
 			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
-				iobase, iobase + 0x0f);
+			       iobase, iobase + 0x0f);
 			return -EIO;
 		}
 		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
-				"das16")) {
+				    "das16")) {
 			release_region(iobase, 0x10);
 			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
-				iobase + 0x400,
-				iobase + 0x400 + (thisboard->size & 0x3ff));
+			       iobase + 0x400,
+			       iobase + 0x400 + (thisboard->size & 0x3ff));
 			return -EIO;
 		}
 	}
@@ -1470,13 +1488,16 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		int i;
 		for (i = 0; i < 2; i++) {
 			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
-				DAS16_DMA_SIZE, &devpriv->dma_buffer_addr[i]);
+								      DAS16_DMA_SIZE,
+								      &devpriv->
+								      dma_buffer_addr
+								      [i]);
 			if (devpriv->dma_buffer[i] == NULL)
 				return -ENOMEM;
 		}
 		if (request_dma(dma_chan, "das16")) {
 			printk(" failed to allocate dma channel %i\n",
-				dma_chan);
+			       dma_chan);
 			return -EINVAL;
 		}
 		devpriv->dma_chan = dma_chan;
@@ -1494,11 +1515,11 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  get any user-defined input range */
 	if (thisboard->ai_pg == das16_pg_none &&
-		(it->options[4] || it->options[5])) {
+	    (it->options[4] || it->options[5])) {
 		/*  allocate single-range range table */
 		devpriv->user_ai_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange) +
+			    sizeof(struct comedi_krange), GFP_KERNEL);
 		/*  initialize ai range */
 		devpriv->user_ai_range_table->length = 1;
 		user_ai_range = devpriv->user_ai_range_table->range;
@@ -1510,8 +1531,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (it->options[6] || it->options[7]) {
 		/*  allocate single-range range table */
 		devpriv->user_ao_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
-			GFP_KERNEL);
+		    kmalloc(sizeof(struct comedi_lrange) +
+			    sizeof(struct comedi_krange), GFP_KERNEL);
 		/*  initialize ao range */
 		devpriv->user_ao_range_table->length = 1;
 		user_ao_range = devpriv->user_ao_range_table->range;
@@ -1612,7 +1633,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* 8255 */
 	if (thisboard->i8255_offset != 0) {
 		subdev_8255_init(dev, s, NULL, (dev->iobase +
-				thisboard->i8255_offset));
+						thisboard->i8255_offset));
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}
@@ -1646,8 +1667,9 @@ static int das16_detach(struct comedi_device *dev)
 		for (i = 0; i < 2; i++) {
 			if (devpriv->dma_buffer[i])
 				pci_free_consistent(NULL, DAS16_DMA_SIZE,
-					devpriv->dma_buffer[i],
-					devpriv->dma_buffer_addr[i]);
+						    devpriv->dma_buffer[i],
+						    devpriv->
+						    dma_buffer_addr[i]);
 		}
 		if (devpriv->dma_chan)
 			free_dma(devpriv->dma_chan);
@@ -1666,7 +1688,7 @@ static int das16_detach(struct comedi_device *dev)
 		} else {
 			release_region(dev->iobase, 0x10);
 			release_region(dev->iobase + 0x400,
-				thisboard->size & 0x3ff);
+				       thisboard->size & 0x3ff);
 		}
 	}
 
@@ -1677,7 +1699,7 @@ COMEDI_INITCLEANUP(driver_das16);
 
 /* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
-	struct comedi_cmd cmd)
+						struct comedi_cmd cmd)
 {
 	unsigned int size;
 	unsigned int freq;
@@ -1717,8 +1739,10 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 	return size;
 }
 
-static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *array, unsigned int num_bytes, unsigned int start_chan_index)
+static void das16_ai_munge(struct comedi_device *dev,
+			   struct comedi_subdevice *s, void *array,
+			   unsigned int num_bytes,
+			   unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *data = array;

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c0fbb8516730..59af86a8bbfb 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -79,6 +79,7 @@ Computer boards manuals also available from their website www.measurementcomputi
 */
 
 #include <linux/pci.h>
+#include <linux/interrupt.h>
 #include <asm/dma.h>
 #include "../comedidev.h"
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 6ca888429e6a..c0fbb8516730 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -90,7 +90,7 @@ Computer boards manuals also available from their website www.measurementcomputi
 /* #define DEBUG */
 
 #ifdef DEBUG
-#define DEBUG_PRINT(format, args...) rt_printk("das16: " format, ## args)
+#define DEBUG_PRINT(format, args...) printk("das16: " format, ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -998,7 +998,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/* disable interrupts, dma and pacer clocked conversions */
 	devpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
@@ -1016,7 +1016,7 @@ static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(0, dev->iobase + DAS1600_BURST);
 	}
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1062,7 +1062,7 @@ static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				break;
 		}
 		if (i == DAS16_TIMEOUT) {
-			rt_printk("das16: timeout\n");
+			printk("das16: timeout\n");
 			return -ETIME;
 		}
 		msb = inb(dev->iobase + DAS16_AI_MSB);
@@ -1180,7 +1180,7 @@ static int disable_dma_on_even(struct comedi_device *dev)
 		enable_dma(devpriv->dma_chan);
 		for (j = 0; j < enable_timeout; ++j) {
 			int new_residue;
-			comedi_udelay(2);
+			udelay(2);
 			new_residue = get_dma_residue(devpriv->dma_chan);
 			if (new_residue != residue)
 				break;
@@ -1217,9 +1217,9 @@ static void das16_interrupt(struct comedi_device *dev)
 		return;
 	}
 
-	comedi_spin_lock_irqsave(&dev->spinlock, spin_flags);
+	spin_lock_irqsave(&dev->spinlock, spin_flags);
 	if ((devpriv->control_state & DMA_ENABLE) == 0) {
-		comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+		spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 		DEBUG_PRINT("interrupt while dma disabled?\n");
 		return;
 	}
@@ -1263,7 +1263,7 @@ static void das16_interrupt(struct comedi_device *dev)
 	}
 	release_dma_lock(dma_flags);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+	spin_unlock_irqrestore(&dev->spinlock, spin_flags);
 
 	cfc_write_array_to_buffer(s,
 		devpriv->dma_buffer[buffer_index], num_bytes);
@@ -1449,8 +1449,7 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* now for the irq */
 	if (irq > 1 && irq < 8) {
-		ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
-					 "das16", dev);
+		ret = request_irq(irq, das16_dma_interrupt, 0, "das16", dev);
 
 		if (ret < 0)
 			return ret;
@@ -1658,7 +1657,7 @@ static int das16_detach(struct comedi_device *dev)
 	}
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 
 	if (dev->iobase) {
 		if (thisboard->size < 0x400) {

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 982837d879ce..6ca888429e6a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -696,8 +696,6 @@ static const struct das16_board das16_boards[] = {
 #endif
 };
 
-#define n_das16_boards ((sizeof(das16_boards))/(sizeof(struct das16_board)))
-
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int das16_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das16 = {
@@ -706,7 +704,7 @@ static struct comedi_driver driver_das16 = {
 	.attach = das16_attach,
 	.detach = das16_detach,
 	.board_name = &das16_boards[0].name,
-	.num_names = n_das16_boards,
+	.num_names = ARRAY_SIZE(das16_boards),
 	.offset = sizeof(das16_boards[0]),
 };
 

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 4433f6446b3f..982837d879ce 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -326,34 +326,34 @@ struct munge_info {
 	unsigned have_byte:1;
 };
 
-static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-
-static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s);
-static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
+static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+
+static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index);
 
-static void das16_reset(struct comedi_device * dev);
+static void das16_reset(struct comedi_device *dev);
 static irqreturn_t das16_dma_interrupt(int irq, void *d);
 static void das16_timer_interrupt(unsigned long arg);
-static void das16_interrupt(struct comedi_device * dev);
+static void das16_interrupt(struct comedi_device *dev);
 
-static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
+static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 	int flags);
-static int das1600_mode_detect(struct comedi_device * dev);
-static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
+static int das1600_mode_detect(struct comedi_device *dev);
+static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 	struct comedi_cmd cmd);
 
-static void reg_dump(struct comedi_device * dev);
+static void reg_dump(struct comedi_device *dev);
 
 struct das16_board {
 	const char *name;

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 090225128ce5..4433f6446b3f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -375,323 +375,323 @@ struct das16_board {
 
 static const struct das16_board das16_boards[] = {
 	{
-	      name:	"das-16",
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:15000,
-	      ai_pg:	das16_pg_none,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x10,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-	      id:	0x00,
+	.name = "das-16",
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 15000,
+	.ai_pg = das16_pg_none,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x10,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0x00,
 		},
 	{
-	      name:	"das-16g",
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:15000,
-	      ai_pg:	das16_pg_none,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x10,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-	      id:	0x00,
+	.name = "das-16g",
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 15000,
+	.ai_pg = das16_pg_none,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x10,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0x00,
 		},
 	{
-	      name:	"das-16f",
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:8500,
-	      ai_pg:	das16_pg_none,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x10,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-	      id:	0x00,
+	.name = "das-16f",
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 8500,
+	.ai_pg = das16_pg_none,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x10,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0x00,
 		},
 	{
-	      name:	"cio-das16",	/*  cio-das16.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:20000,
-	      ai_pg:	das16_pg_none,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x10,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-	      id:	0x80,
+	.name = "cio-das16",	/*  cio-das16.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 20000,
+	.ai_pg = das16_pg_none,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x10,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0x80,
 		},
 	{
-	      name:	"cio-das16/f",	/*  das16.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_none,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x10,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-	      id:	0x80,
+	.name = "cio-das16/f",	/*  das16.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_none,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x10,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0x80,
 		},
 	{
-	      name:	"cio-das16/jr",	/*  cio-das16jr.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:7692,
-	      ai_pg:	das16_pg_16jr,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x10,
-	      id:	0x00,
+	.name = "cio-das16/jr",	/*  cio-das16jr.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 7692,
+	.ai_pg = das16_pg_16jr,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x10,
+	.id = 0x00,
 		},
 	{
-	      name:	"pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:3300,
-	      ai_pg:	das16_pg_16jr,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x10,
-	      id:	0x00,
+	.name = "pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 3300,
+	.ai_pg = das16_pg_16jr,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x10,
+	.id = 0x00,
 		},
 	{
-	      name:	"cio-das16jr/16",	/*  cio-das16jr_16.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:16,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_16jr_16,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x10,
-	      id:	0x00,
+	.name = "cio-das16jr/16",	/*  cio-das16jr_16.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 16,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_16jr_16,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x10,
+	.id = 0x00,
 		},
 	{
-	      name:	"pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:16,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_16jr_16,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x10,
-	      id:	0x00,
+	.name = "pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 16,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_16jr_16,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x10,
+	.id = 0x00,
 		},
 	{
-	      name:	"das-1201",	/*  4924.pdf (keithley user's manual) */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:20000,
-	      ai_pg:	das16_pg_none,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-	      id:	0x20,
+	.name = "das-1201",	/*  4924.pdf (keithley user's manual) */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 20000,
+	.ai_pg = das16_pg_none,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0x20,
 		},
 	{
-	      name:	"das-1202",	/*  4924.pdf (keithley user's manual) */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_none,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-	      id:	0x20,
+	.name = "das-1202",	/*  4924.pdf (keithley user's manual) */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_none,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0x20,
 		},
 	{
-	      name:	"das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1601,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x0,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	.name = "das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1601,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x0,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1602,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x0,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
+	.name = "das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1602,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x0,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1601",	/*  4919.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1601,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "das-1601",	/*  4919.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1601,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"das-1602",	/*  4919.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1602,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "das-1602",	/*  4919.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1602,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1401/12",	/*  cio-das1400_series.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:6250,
-	      ai_pg:	das16_pg_1601,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1401/12",	/*  cio-das1400_series.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 6250,
+	.ai_pg = das16_pg_1601,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1402/12",	/*  cio-das1400_series.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:6250,
-	      ai_pg:	das16_pg_1602,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1402/12",	/*  cio-das1400_series.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 6250,
+	.ai_pg = das16_pg_1602,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1402/16",	/*  cio-das1400_series.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:16,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1602,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1402/16",	/*  cio-das1400_series.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 16,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1602,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1601/12",	/*  cio-das160x-1x.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:6250,
-	      ai_pg:	das16_pg_1601,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1601/12",	/*  cio-das160x-1x.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 6250,
+	.ai_pg = das16_pg_1601,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1602/12",	/*  cio-das160x-1x.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1602,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1602/12",	/*  cio-das160x-1x.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1602,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das1602/16",	/*  cio-das160x-1x.pdf */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:16,
-	      ai_speed:10000,
-	      ai_pg:	das16_pg_1602,
-	      ao:	das16_ao_winsn,
-	      ao_nbits:12,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0x400,
-	      i8254_offset:0x0c,
-	      size:	0x408,
-      id:	0xc0},
+	.name = "cio-das1602/16",	/*  cio-das160x-1x.pdf */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 16,
+	.ai_speed = 10000,
+	.ai_pg = das16_pg_1602,
+	.ao = das16_ao_winsn,
+	.ao_nbits = 12,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0x400,
+	.i8254_offset = 0x0c,
+	.size = 0x408,
+	.id = 0xc0},
 	{
-	      name:	"cio-das16/330",	/*  ? */
-	      ai:	das16_ai_rinsn,
-	      ai_nbits:12,
-	      ai_speed:3030,
-	      ai_pg:	das16_pg_16jr,
-	      ao:	NULL,
-	      di:	das16_di_rbits,
-	      do_:	das16_do_wbits,
-	      i8255_offset:0,
-	      i8254_offset:0x0c,
-	      size:	0x14,
-      id:	0xf0},
+	.name = "cio-das16/330",	/*  ? */
+	.ai = das16_ai_rinsn,
+	.ai_nbits = 12,
+	.ai_speed = 3030,
+	.ai_pg = das16_pg_16jr,
+	.ao = NULL,
+	.di = das16_di_rbits,
+	.do_ = das16_do_wbits,
+	.i8255_offset = 0,
+	.i8254_offset = 0x0c,
+	.size = 0x14,
+	.id = 0xf0},
 #if 0
 	{
-	      name:	"das16/330i",	/*  ? */
+	.name = "das16/330i",	/*  ? */
 		},
 	{
-	      name:	"das16/jr/ctr5",	/*  ? */
+	.name = "das16/jr/ctr5",	/*  ? */
 		},
 	{
-	      name:	"cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
+	.name = "cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
 		},
 #endif
 };
@@ -701,13 +701,13 @@ static const struct das16_board das16_boards[] = {
 static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int das16_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das16 = {
-      driver_name:"das16",
-      module:THIS_MODULE,
-      attach:das16_attach,
-      detach:das16_detach,
-      board_name:&das16_boards[0].name,
-      num_names:n_das16_boards,
-      offset:sizeof(das16_boards[0]),
+	.driver_name = "das16",
+	.module = THIS_MODULE,
+	.attach = das16_attach,
+	.detach = das16_detach,
+	.board_name = &das16_boards[0].name,
+	.num_names = n_das16_boards,
+	.offset = sizeof(das16_boards[0]),
 };
 
 #define DAS16_TIMEOUT 1000

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 2082030bd4ff..090225128ce5 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1400,7 +1400,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct das16_private_struct))) < 0)
+	ret = alloc_private(dev, sizeof(struct das16_private_struct));
+	if (ret < 0)
 		return ret;
 
 	if (thisboard->size < 0x400) {
@@ -1450,8 +1451,10 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* now for the irq */
 	if (irq > 1 && irq < 8) {
-		if ((ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
-					"das16", dev)) < 0)
+		ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
+					 "das16", dev);
+
+		if (ret < 0)
 			return ret;
 		dev->irq = irq;
 		printk(" ( irq = %u )", irq);
@@ -1526,7 +1529,8 @@ static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	devpriv->timer_mode = timer_mode ? 1 : 0;
 
-	if ((ret = alloc_subdevices(dev, 5)) < 0)
+	ret = alloc_subdevices(dev, 5);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 991e3330d11f..2082030bd4ff 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -698,8 +698,8 @@ static const struct das16_board das16_boards[] = {
 
 #define n_das16_boards ((sizeof(das16_boards))/(sizeof(struct das16_board)))
 
-static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int das16_detach(struct comedi_device * dev);
+static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das16_detach(struct comedi_device *dev);
 static struct comedi_driver driver_das16 = {
       driver_name:"das16",
       module:THIS_MODULE,
@@ -742,8 +742,8 @@ struct das16_private_struct {
 #define devpriv ((struct das16_private_struct *)(dev->private))
 #define thisboard ((struct das16_board *)(dev->board_ptr))
 
-static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	int gain, start_chan, i;
@@ -893,7 +893,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -996,7 +996,7 @@ static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -1023,7 +1023,7 @@ static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static void das16_reset(struct comedi_device * dev)
+static void das16_reset(struct comedi_device *dev)
 {
 	outb(0, dev->iobase + DAS16_STATUS);
 	outb(0, dev->iobase + DAS16_CONTROL);
@@ -1031,8 +1031,8 @@ static void das16_reset(struct comedi_device * dev)
 	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
-static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int range;
@@ -1079,8 +1079,8 @@ static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	return n;
 }
 
-static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int bits;
 
@@ -1091,8 +1091,8 @@ static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice *
 	return 2;
 }
 
-static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1111,8 +1111,8 @@ static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice *
 	return 2;
 }
 
-static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int lsb, msb;
@@ -1169,7 +1169,7 @@ static void das16_timer_interrupt(unsigned long arg)
 	an even transfer count after disabling dma
 	channel.
 */
-static int disable_dma_on_even(struct comedi_device * dev)
+static int disable_dma_on_even(struct comedi_device *dev)
 {
 	int residue;
 	int i;
@@ -1197,7 +1197,7 @@ static int disable_dma_on_even(struct comedi_device * dev)
 	return residue;
 }
 
-static void das16_interrupt(struct comedi_device * dev)
+static void das16_interrupt(struct comedi_device *dev)
 {
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
@@ -1273,7 +1273,7 @@ static void das16_interrupt(struct comedi_device * dev)
 	cfc_handle_events(dev, s);
 }
 
-static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
+static unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,
 	int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
@@ -1286,7 +1286,7 @@ static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
 	return ns;
 }
 
-static void reg_dump(struct comedi_device * dev)
+static void reg_dump(struct comedi_device *dev)
 {
 	DEBUG_PRINT("********DAS1600 REGISTER DUMP********\n");
 	DEBUG_PRINT("DAS16_MUX: %x\n", inb(dev->iobase + DAS16_MUX));
@@ -1304,7 +1304,7 @@ static void reg_dump(struct comedi_device * dev)
 		inb(dev->iobase + DAS1600_STATUS_B));
 }
 
-static int das16_probe(struct comedi_device * dev, struct comedi_devconfig * it)
+static int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int status;
 	int diobits;
@@ -1338,7 +1338,7 @@ static int das16_probe(struct comedi_device * dev, struct comedi_devconfig * it)
 	return 0;
 }
 
-static int das1600_mode_detect(struct comedi_device * dev)
+static int das1600_mode_detect(struct comedi_device *dev)
 {
 	int status = 0;
 
@@ -1366,7 +1366,7 @@ static int das1600_mode_detect(struct comedi_device * dev)
  *   3  Clock speed (in MHz)
  */
 
-static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret;
@@ -1630,7 +1630,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	return 0;
 }
 
-static int das16_detach(struct comedi_device * dev)
+static int das16_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: das16: remove\n", dev->minor);
 
@@ -1674,7 +1674,7 @@ static int das16_detach(struct comedi_device * dev)
 COMEDI_INITCLEANUP(driver_das16);
 
 /* utility function that suggests a dma transfer size in bytes */
-static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
+static unsigned int das16_suggest_transfer_size(struct comedi_device *dev,
 	struct comedi_cmd cmd)
 {
 	unsigned int size;
@@ -1715,7 +1715,7 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	return size;
 }
 
-static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
+static void das16_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index b89316d5b53a..991e3330d11f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -87,7 +87,7 @@ Computer boards manuals also available from their website www.measurementcomputi
 #include "comedi_fc.h"
 
 #undef DEBUG
-//#define DEBUG
+/* #define DEBUG */
 
 #ifdef DEBUG
 #define DEBUG_PRINT(format, args...) rt_printk("das16: " format, ## args)
@@ -95,8 +95,8 @@ Computer boards manuals also available from their website www.measurementcomputi
 #define DEBUG_PRINT(format, args...)
 #endif
 
-#define DAS16_SIZE 20		// number of ioports
-#define DAS16_DMA_SIZE 0xff00	// size in bytes of allocated dma buffer
+#define DAS16_SIZE 20		/*  number of ioports */
+#define DAS16_DMA_SIZE 0xff00	/*  size in bytes of allocated dma buffer */
 
 /*
     cio-das16.pdf
@@ -184,7 +184,7 @@ Computer boards manuals also available from their website www.measurementcomputi
 
 */
 
-static const int sample_size = 2;	// size in bytes of a sample from board
+static const int sample_size = 2;	/*  size in bytes of a sample from board */
 
 #define DAS16_TRIG		0
 #define DAS16_AI_LSB		0
@@ -265,7 +265,7 @@ static const struct comedi_lrange range_das1x02_unip = { 4, {
 	}
 };
 static const struct comedi_lrange range_das16jr = { 9, {
-			// also used by 16/330
+			/*  also used by 16/330 */
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -359,7 +359,7 @@ struct das16_board {
 	const char *name;
 	void *ai;
 	unsigned int ai_nbits;
-	unsigned int ai_speed;	// max conversion speed in nanosec
+	unsigned int ai_speed;	/*  max conversion speed in nanosec */
 	unsigned int ai_pg;
 	void *ao;
 	unsigned int ao_nbits;
@@ -420,7 +420,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x00,
 		},
 	{
-	      name:	"cio-das16",	// cio-das16.pdf
+	      name:	"cio-das16",	/*  cio-das16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:20000,
@@ -435,7 +435,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x80,
 		},
 	{
-	      name:	"cio-das16/f",	// das16.pdf
+	      name:	"cio-das16/f",	/*  das16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -450,7 +450,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x80,
 		},
 	{
-	      name:	"cio-das16/jr",	// cio-das16jr.pdf
+	      name:	"cio-das16/jr",	/*  cio-das16jr.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:7692,
@@ -464,7 +464,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x00,
 		},
 	{
-	      name:	"pc104-das16jr",	// pc104-das16jr_xx.pdf
+	      name:	"pc104-das16jr",	/*  pc104-das16jr_xx.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:3300,
@@ -478,7 +478,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x00,
 		},
 	{
-	      name:	"cio-das16jr/16",	// cio-das16jr_16.pdf
+	      name:	"cio-das16jr/16",	/*  cio-das16jr_16.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -492,7 +492,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x00,
 		},
 	{
-	      name:	"pc104-das16jr/16",	// pc104-das16jr_xx.pdf
+	      name:	"pc104-das16jr/16",	/*  pc104-das16jr_xx.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -506,7 +506,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x00,
 		},
 	{
-	      name:	"das-1201",	// 4924.pdf (keithley user's manual)
+	      name:	"das-1201",	/*  4924.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:20000,
@@ -520,7 +520,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x20,
 		},
 	{
-	      name:	"das-1202",	// 4924.pdf (keithley user's manual)
+	      name:	"das-1202",	/*  4924.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -534,7 +534,7 @@ static const struct das16_board das16_boards[] = {
 	      id:	0x20,
 		},
 	{
-	      name:	"das-1401",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      name:	"das-1401",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -545,10 +545,10 @@ static const struct das16_board das16_boards[] = {
 	      i8255_offset:0x0,
 	      i8254_offset:0x0c,
 	      size:	0x408,
-	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1402",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      name:	"das-1402",	/*  4919.pdf and 4922.pdf (keithley user's manual) */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -559,10 +559,10 @@ static const struct das16_board das16_boards[] = {
 	      i8255_offset:0x0,
 	      i8254_offset:0x0c,
 	      size:	0x408,
-	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+	      id:	0xc0	/*  4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0 */
 		},
 	{
-	      name:	"das-1601",	// 4919.pdf
+	      name:	"das-1601",	/*  4919.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -576,7 +576,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"das-1602",	// 4919.pdf
+	      name:	"das-1602",	/*  4919.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -590,7 +590,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1401/12",	// cio-das1400_series.pdf
+	      name:	"cio-das1401/12",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -603,7 +603,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1402/12",	// cio-das1400_series.pdf
+	      name:	"cio-das1402/12",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -616,7 +616,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1402/16",	// cio-das1400_series.pdf
+	      name:	"cio-das1402/16",	/*  cio-das1400_series.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -629,7 +629,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1601/12",	// cio-das160x-1x.pdf
+	      name:	"cio-das1601/12",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:6250,
@@ -643,7 +643,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1602/12",	// cio-das160x-1x.pdf
+	      name:	"cio-das1602/12",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:10000,
@@ -657,7 +657,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das1602/16",	// cio-das160x-1x.pdf
+	      name:	"cio-das1602/16",	/*  cio-das160x-1x.pdf */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:16,
 	      ai_speed:10000,
@@ -671,7 +671,7 @@ static const struct das16_board das16_boards[] = {
 	      size:	0x408,
       id:	0xc0},
 	{
-	      name:	"cio-das16/330",	// ?
+	      name:	"cio-das16/330",	/*  ? */
 	      ai:	das16_ai_rinsn,
 	      ai_nbits:12,
 	      ai_speed:3030,
@@ -685,13 +685,13 @@ static const struct das16_board das16_boards[] = {
       id:	0xf0},
 #if 0
 	{
-	      name:	"das16/330i",	// ?
+	      name:	"das16/330i",	/*  ? */
 		},
 	{
-	      name:	"das16/jr/ctr5",	// ?
+	      name:	"das16/jr/ctr5",	/*  ? */
 		},
 	{
-	      name:	"cio-das16/m1/16",	// cio-das16_m1_16.pdf, this board is a bit quirky, no dma
+	      name:	"cio-das16/m1/16",	/*  cio-das16_m1_16.pdf, this board is a bit quirky, no dma */
 		},
 #endif
 };
@@ -719,25 +719,25 @@ static inline int timer_period(void)
 	return HZ / 20;
 }
 struct das16_private_struct {
-	unsigned int ai_unipolar;	// unipolar flag
-	unsigned int ai_singleended;	// single ended flag
-	unsigned int clockbase;	// master clock speed in ns
-	volatile unsigned int control_state;	// dma, interrupt and trigger control bits
-	volatile unsigned long adc_byte_count;	// number of bytes remaining
-	unsigned int divisor1;	// divisor dividing master clock to get conversion frequency
-	unsigned int divisor2;	// divisor dividing master clock to get conversion frequency
-	unsigned int dma_chan;	// dma channel
+	unsigned int ai_unipolar;	/*  unipolar flag */
+	unsigned int ai_singleended;	/*  single ended flag */
+	unsigned int clockbase;	/*  master clock speed in ns */
+	volatile unsigned int control_state;	/*  dma, interrupt and trigger control bits */
+	volatile unsigned long adc_byte_count;	/*  number of bytes remaining */
+	unsigned int divisor1;	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int divisor2;	/*  divisor dividing master clock to get conversion frequency */
+	unsigned int dma_chan;	/*  dma channel */
 	uint16_t *dma_buffer[2];
 	dma_addr_t dma_buffer_addr[2];
 	unsigned int current_buffer;
-	volatile unsigned int dma_transfer_size;	// target number of bytes to transfer per dma shot
-	// user-defined analog input and output ranges defined from config options
+	volatile unsigned int dma_transfer_size;	/*  target number of bytes to transfer per dma shot */
+	/*  user-defined analog input and output ranges defined from config options */
 	struct comedi_lrange *user_ai_range_table;
 	struct comedi_lrange *user_ao_range_table;
 
-	struct timer_list timer;	// for timed interrupt
+	struct timer_list timer;	/*  for timed interrupt */
 	volatile short timer_running;
-	volatile short timer_mode;	// true if using timer mode
+	volatile short timer_mode;	/*  true if using timer mode */
 };
 #define devpriv ((struct das16_private_struct *)(dev->private))
 #define thisboard ((struct das16_board *)(dev->board_ptr))
@@ -757,7 +757,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 
 	tmp = cmd->scan_begin_src;
 	mask = TRIG_FOLLOW;
-	// if board supports burst mode
+	/*  if board supports burst mode */
 	if (thisboard->size > 0x400)
 		mask |= TRIG_TIMER | TRIG_EXT;
 	cmd->scan_begin_src &= mask;
@@ -766,7 +766,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 
 	tmp = cmd->convert_src;
 	mask = TRIG_TIMER | TRIG_EXT;
-	// if board supports burst mode
+	/*  if board supports burst mode */
 	if (thisboard->size > 0x400)
 		mask |= TRIG_NOW;
 	cmd->convert_src &= mask;
@@ -797,7 +797,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
 		err++;
 
-	// make sure scan_begin_src and convert_src dont conflict
+	/*  make sure scan_begin_src and convert_src dont conflict */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
@@ -824,7 +824,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
 	}
-	// check against maximum frequency
+	/*  check against maximum frequency */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
 			thisboard->ai_speed * cmd->chanlist_len) {
@@ -849,10 +849,10 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 	if (err)
 		return 3;
 
-	// step 4: fix up arguments
+	/*  step 4: fix up arguments */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->scan_begin_arg;
-		// set divisors, correct timing arguments
+		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
 			&(devpriv->divisor1), &(devpriv->divisor2),
 			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
@@ -860,7 +860,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		unsigned int tmp = cmd->convert_arg;
-		// set divisors, correct timing arguments
+		/*  set divisors, correct timing arguments */
 		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
 			&(devpriv->divisor1), &(devpriv->divisor2),
 			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
@@ -869,7 +869,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		start_chan = CR_CHAN(cmd->chanlist[0]);
@@ -916,11 +916,11 @@ static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice *
 	devpriv->adc_byte_count =
 		cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
 
-	// disable conversions for das1600 mode
+	/*  disable conversions for das1600 mode */
 	if (thisboard->size > 0x400) {
 		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
 	}
-	// set scan limits
+	/*  set scan limits */
 	byte = CR_CHAN(cmd->chanlist[0]);
 	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
 	outb(byte, dev->iobase + DAS16_MUX);
@@ -945,7 +945,7 @@ static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice *
 	if (thisboard->size > 0x400) {
 		if (cmd->convert_src == TRIG_NOW) {
 			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
-			// set burst length
+			/*  set burst length */
 			byte |= BURST_LEN_BITS(cmd->chanlist_len - 1);
 		} else {
 			outb(0, dev->iobase + DAS1600_BURST);
@@ -953,7 +953,7 @@ static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice *
 	}
 	outb(byte, dev->iobase + DAS16_PACER);
 
-	// set up dma transfer
+	/*  set up dma transfer */
 	flags = claim_dma_lock();
 	disable_dma(devpriv->dma_chan);
 	/* clear flip-flop to make sure 2-byte registers for
@@ -962,13 +962,13 @@ static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice *
 	devpriv->current_buffer = 0;
 	set_dma_addr(devpriv->dma_chan,
 		devpriv->dma_buffer_addr[devpriv->current_buffer]);
-	// set appropriate size of transfer
+	/*  set appropriate size of transfer */
 	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
 	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_chan);
 	release_dma_lock(flags);
 
-	// set up interrupt
+	/*  set up interrupt */
 	if (devpriv->timer_mode) {
 		devpriv->timer_running = 1;
 		devpriv->timer.expires = jiffies + timer_period();
@@ -1007,7 +1007,7 @@ static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (devpriv->dma_chan)
 		disable_dma(devpriv->dma_chan);
 
-	// disable SW timer
+	/*  disable SW timer */
 	if (devpriv->timer_mode && devpriv->timer_running) {
 		devpriv->timer_running = 0;
 		del_timer(&devpriv->timer);
@@ -1039,7 +1039,7 @@ static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	int chan;
 	int msb, lsb;
 
-	// disable interrupts and pacing
+	/*  disable interrupts and pacing */
 	devpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
@@ -1096,12 +1096,12 @@ static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice *
 {
 	unsigned int wbits;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= 0xf;
 	wbits = s->state;
-	// zero bits that have been masked
+	/*  zero bits that have been masked */
 	wbits &= ~data[0];
-	// set masked bits
+	/*  set masked bits */
 	wbits |= data[0] & data[1];
 	s->state = wbits;
 	data[1] = wbits;
@@ -1210,7 +1210,7 @@ static void das16_interrupt(struct comedi_device * dev)
 		comedi_error(dev, "premature interrupt");
 		return;
 	}
-	// initialize async here to make sure it is not NULL
+	/*  initialize async here to make sure it is not NULL */
 	async = s->async;
 	cmd = &async->cmd;
 
@@ -1230,7 +1230,7 @@ static void das16_interrupt(struct comedi_device * dev)
 	clear_dma_ff(devpriv->dma_chan);
 	residue = disable_dma_on_even(dev);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	if (residue > devpriv->dma_transfer_size) {
 		comedi_error(dev, "residue > transfer size!\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
@@ -1247,12 +1247,12 @@ static void das16_interrupt(struct comedi_device * dev)
 	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
 	devpriv->adc_byte_count -= num_bytes;
 
-	// figure out how many bytes for next transfer
+	/*  figure out how many bytes for next transfer */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
 		devpriv->dma_transfer_size > devpriv->adc_byte_count)
 		devpriv->dma_transfer_size = devpriv->adc_byte_count;
 
-	// re-enable  dma
+	/*  re-enable  dma */
 	if ((async->events & COMEDI_CB_EOA) == 0) {
 		set_dma_addr(devpriv->dma_chan,
 			devpriv->dma_buffer_addr[devpriv->current_buffer]);
@@ -1391,7 +1391,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 
 	printk("comedi%d: das16:", dev->minor);
 
-	// check that clock setting is valid
+	/*  check that clock setting is valid */
 	if (it->options[3]) {
 		if (it->options[3] != 0 &&
 			it->options[3] != 1 && it->options[3] != 10) {
@@ -1431,19 +1431,19 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 
 	dev->iobase = iobase;
 
-	// probe id bits to make sure they are consistent
+	/*  probe id bits to make sure they are consistent */
 	if (das16_probe(dev, it)) {
 		printk(" id bits do not match selected board, aborting\n");
 		return -EINVAL;
 	}
 	dev->board_name = thisboard->name;
 
-	// get master clock speed
+	/*  get master clock speed */
 	if (thisboard->size < 0x400) {
 		if (it->options[3])
 			devpriv->clockbase = 1000 / it->options[3];
 		else
-			devpriv->clockbase = 1000;	// 1 MHz default
+			devpriv->clockbase = 1000;	/*  1 MHz default */
 	} else {
 		das1600_mode_detect(dev);
 	}
@@ -1462,10 +1462,10 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		return -EINVAL;
 	}
 
-	// initialize dma
+	/*  initialize dma */
 	dma_chan = it->options[2];
 	if (dma_chan == 1 || dma_chan == 3) {
-		// allocate dma buffers
+		/*  allocate dma buffers */
 		int i;
 		for (i = 0; i < 2; i++) {
 			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
@@ -1491,27 +1491,27 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		return -EINVAL;
 	}
 
-	// get any user-defined input range
+	/*  get any user-defined input range */
 	if (thisboard->ai_pg == das16_pg_none &&
 		(it->options[4] || it->options[5])) {
-		// allocate single-range range table
+		/*  allocate single-range range table */
 		devpriv->user_ai_range_table =
 			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
-		// initialize ai range
+		/*  initialize ai range */
 		devpriv->user_ai_range_table->length = 1;
 		user_ai_range = devpriv->user_ai_range_table->range;
 		user_ai_range->min = it->options[4];
 		user_ai_range->max = it->options[5];
 		user_ai_range->flags = UNIT_volt;
 	}
-	// get any user-defined output range
+	/*  get any user-defined output range */
 	if (it->options[6] || it->options[7]) {
-		// allocate single-range range table
+		/*  allocate single-range range table */
 		devpriv->user_ao_range_table =
 			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
-		// initialize ao range
+		/*  initialize ao range */
 		devpriv->user_ao_range_table->length = 1;
 		user_ao_range = devpriv->user_ao_range_table->range;
 		user_ao_range->min = it->options[6];
@@ -1545,7 +1545,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 			s->subdev_flags |= SDF_DIFF;
 		}
 		s->maxdata = (1 << thisboard->ai_nbits) - 1;
-		if (devpriv->user_ai_range_table) {	// user defined ai range
+		if (devpriv->user_ai_range_table) {	/*  user defined ai range */
 			s->range_table = devpriv->user_ai_range_table;
 		} else if (devpriv->ai_unipolar) {
 			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
@@ -1568,7 +1568,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = 2;
 		s->maxdata = (1 << thisboard->ao_nbits) - 1;
-		if (devpriv->user_ao_range_table) {	// user defined ao range
+		if (devpriv->user_ao_range_table) {	/*  user defined ao range */
 			s->range_table = devpriv->user_ao_range_table;
 		} else {
 			s->range_table = &range_unknown;
@@ -1600,7 +1600,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->insn_bits = thisboard->do_;
-		// initialize digital output lines
+		/*  initialize digital output lines */
 		outb(s->state, dev->iobase + DAS16_DIO);
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
@@ -1620,7 +1620,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	devpriv->control_state = DAS16_IRQ(dev->irq);
 	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
 
-	// turn on das1600 mode if available
+	/*  turn on das1600 mode if available */
 	if (thisboard->size > 0x400) {
 		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
 		outb(0, dev->iobase + DAS1600_CONV);
@@ -1673,7 +1673,7 @@ static int das16_detach(struct comedi_device * dev)
 
 COMEDI_INITCLEANUP(driver_das16);
 
-// utility function that suggests a dma transfer size in bytes
+/* utility function that suggests a dma transfer size in bytes */
 static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	struct comedi_cmd cmd)
 {
@@ -1692,18 +1692,18 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 		freq = 1000000000 / cmd.convert_arg;
 	else if (cmd.scan_begin_src == TRIG_TIMER)
 		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
-	// return some default value
+	/*  return some default value */
 	else
 		freq = 0xffffffff;
 
 	if (cmd.flags & TRIG_WAKE_EOS) {
 		size = sample_size * cmd.chanlist_len;
 	} else {
-		// make buffer fill in no more than 1/3 second
+		/*  make buffer fill in no more than 1/3 second */
 		size = (freq / 3) * sample_size;
 	}
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	if (size > DAS16_DMA_SIZE)
 		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
 	else if (size < sample_size)

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 6b6b042099de..b89316d5b53a 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -343,7 +343,7 @@ static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice *
 	void *array, unsigned int num_bytes, unsigned int start_chan_index);
 
 static void das16_reset(struct comedi_device * dev);
-static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t das16_dma_interrupt(int irq, void *d);
 static void das16_timer_interrupt(unsigned long arg);
 static void das16_interrupt(struct comedi_device * dev);
 
@@ -1135,7 +1135,7 @@ static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice *
 	return i;
 }
 
-static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t das16_dma_interrupt(int irq, void *d)
 {
 	int status;
 	struct comedi_device *dev = d;

commit 947a33fd2196209a1aa8f00de4068e8a09a19cd9
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:21 2009 -0400

    Staging: comedi: Remove das16_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 0219c32e853c..6b6b042099de 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -355,7 +355,7 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 
 static void reg_dump(struct comedi_device * dev);
 
-typedef struct das16_board_struct {
+struct das16_board {
 	const char *name;
 	void *ai;
 	unsigned int ai_nbits;
@@ -371,9 +371,9 @@ typedef struct das16_board_struct {
 
 	unsigned int size;
 	unsigned int id;
-} das16_board;
+};
 
-static const struct das16_board_struct das16_boards[] = {
+static const struct das16_board das16_boards[] = {
 	{
 	      name:	"das-16",
 	      ai:	das16_ai_rinsn,
@@ -696,7 +696,7 @@ static const struct das16_board_struct das16_boards[] = {
 #endif
 };
 
-#define n_das16_boards ((sizeof(das16_boards))/(sizeof(das16_board)))
+#define n_das16_boards ((sizeof(das16_boards))/(sizeof(struct das16_board)))
 
 static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int das16_detach(struct comedi_device * dev);
@@ -740,7 +740,7 @@ struct das16_private_struct {
 	volatile short timer_mode;	// true if using timer mode
 };
 #define devpriv ((struct das16_private_struct *)(dev->private))
-#define thisboard ((struct das16_board_struct *)(dev->board_ptr))
+#define thisboard ((struct das16_board *)(dev->board_ptr))
 
 static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd)

commit 1f6325d629ce03501e8927480495685828561f26
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:31 2009 -0400

    Staging: comedi: Remove comedi_krange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index b959ba8e29fb..0219c32e853c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -1375,7 +1375,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	unsigned int dma_chan;
 	int timer_mode;
 	unsigned long flags;
-	comedi_krange *user_ai_range, *user_ao_range;
+	struct comedi_krange *user_ai_range, *user_ao_range;
 
 	iobase = it->options[0];
 #if 0
@@ -1496,7 +1496,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 		(it->options[4] || it->options[5])) {
 		// allocate single-range range table
 		devpriv->user_ai_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(comedi_krange),
+			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
 		// initialize ai range
 		devpriv->user_ai_range_table->length = 1;
@@ -1509,7 +1509,7 @@ static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	if (it->options[6] || it->options[7]) {
 		// allocate single-range range table
 		devpriv->user_ao_range_table =
-			kmalloc(sizeof(struct comedi_lrange) + sizeof(comedi_krange),
+			kmalloc(sizeof(struct comedi_lrange) + sizeof(struct comedi_krange),
 			GFP_KERNEL);
 		// initialize ao range
 		devpriv->user_ao_range_table->length = 1;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index c4c12e6b1a71..b959ba8e29fb 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -698,7 +698,7 @@ static const struct das16_board_struct das16_boards[] = {
 
 #define n_das16_boards ((sizeof(das16_boards))/(sizeof(das16_board)))
 
-static int das16_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int das16_detach(struct comedi_device * dev);
 static struct comedi_driver driver_das16 = {
       driver_name:"das16",
@@ -1304,7 +1304,7 @@ static void reg_dump(struct comedi_device * dev)
 		inb(dev->iobase + DAS1600_STATUS_B));
 }
 
-static int das16_probe(struct comedi_device * dev, comedi_devconfig * it)
+static int das16_probe(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int status;
 	int diobits;
@@ -1366,7 +1366,7 @@ static int das1600_mode_detect(struct comedi_device * dev)
  *   3  Clock speed (in MHz)
  */
 
-static int das16_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int das16_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	int ret;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 1ca8f2eb48ab..c4c12e6b1a71 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -327,13 +327,13 @@ struct munge_info {
 };
 
 static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
@@ -1032,7 +1032,7 @@ static void das16_reset(struct comedi_device * dev)
 }
 
 static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int range;
@@ -1080,7 +1080,7 @@ static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
 
@@ -1092,7 +1092,7 @@ static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;
 
@@ -1112,7 +1112,7 @@ static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int lsb, msb;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 6c2b214dfefc..1ca8f2eb48ab 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -336,7 +336,7 @@ static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	comedi_insn * insn, unsigned int * data);
 
 static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s);
 static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
@@ -351,7 +351,7 @@ static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
 	int flags);
 static int das1600_mode_detect(struct comedi_device * dev);
 static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
-	comedi_cmd cmd);
+	struct comedi_cmd cmd);
 
 static void reg_dump(struct comedi_device * dev);
 
@@ -743,7 +743,7 @@ struct das16_private_struct {
 #define thisboard ((struct das16_board_struct *)(dev->board_ptr))
 
 static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0, tmp;
 	int gain, start_chan, i;
@@ -896,7 +896,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
 	unsigned long flags;
 	int range;
@@ -1202,7 +1202,7 @@ static void das16_interrupt(struct comedi_device * dev)
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
-	comedi_cmd *cmd;
+	struct comedi_cmd *cmd;
 	int num_bytes, residue;
 	int buffer_index;
 
@@ -1675,7 +1675,7 @@ COMEDI_INITCLEANUP(driver_das16);
 
 // utility function that suggests a dma transfer size in bytes
 static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
-	comedi_cmd cmd)
+	struct comedi_cmd cmd)
 {
 	unsigned int size;
 	unsigned int freq;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index a0998a2efd62..6c2b214dfefc 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -236,35 +236,35 @@ static const int sample_size = 2;	// size in bytes of a sample from board
 #define   DAS1600_WS			0x02
 #define   DAS1600_CLK_10MHZ		0x01
 
-static const comedi_lrange range_das1x01_bip = { 4, {
+static const struct comedi_lrange range_das1x01_bip = { 4, {
 			BIP_RANGE(10),
 			BIP_RANGE(1),
 			BIP_RANGE(0.1),
 			BIP_RANGE(0.01),
 	}
 };
-static const comedi_lrange range_das1x01_unip = { 4, {
+static const struct comedi_lrange range_das1x01_unip = { 4, {
 			UNI_RANGE(10),
 			UNI_RANGE(1),
 			UNI_RANGE(0.1),
 			UNI_RANGE(0.01),
 	}
 };
-static const comedi_lrange range_das1x02_bip = { 4, {
+static const struct comedi_lrange range_das1x02_bip = { 4, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
 			BIP_RANGE(1.25),
 	}
 };
-static const comedi_lrange range_das1x02_unip = { 4, {
+static const struct comedi_lrange range_das1x02_unip = { 4, {
 			UNI_RANGE(10),
 			UNI_RANGE(5),
 			UNI_RANGE(2.5),
 			UNI_RANGE(1.25),
 	}
 };
-static const comedi_lrange range_das16jr = { 9, {
+static const struct comedi_lrange range_das16jr = { 9, {
 			// also used by 16/330
 			BIP_RANGE(10),
 			BIP_RANGE(5),
@@ -277,7 +277,7 @@ static const comedi_lrange range_das16jr = { 9, {
 			UNI_RANGE(1.25),
 	}
 };
-static const comedi_lrange range_das16jr_16 = { 8, {
+static const struct comedi_lrange range_das16jr_16 = { 8, {
 			BIP_RANGE(10),
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
@@ -306,14 +306,14 @@ static const int *const das16_gainlists[] = {
 	das1600_gainlist,
 	das1600_gainlist,
 };
-static const comedi_lrange *const das16_ai_uni_lranges[] = {
+static const struct comedi_lrange *const das16_ai_uni_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
 	&range_das16jr_16,
 	&range_das1x01_unip,
 	&range_das1x02_unip,
 };
-static const comedi_lrange *const das16_ai_bip_lranges[] = {
+static const struct comedi_lrange *const das16_ai_bip_lranges[] = {
 	&range_unknown,
 	&range_das16jr,
 	&range_das16jr_16,
@@ -732,8 +732,8 @@ struct das16_private_struct {
 	unsigned int current_buffer;
 	volatile unsigned int dma_transfer_size;	// target number of bytes to transfer per dma shot
 	// user-defined analog input and output ranges defined from config options
-	comedi_lrange *user_ai_range_table;
-	comedi_lrange *user_ao_range_table;
+	struct comedi_lrange *user_ai_range_table;
+	struct comedi_lrange *user_ao_range_table;
 
 	struct timer_list timer;	// for timed interrupt
 	volatile short timer_running;
@@ -1496,7 +1496,7 @@ static int das16_attach(struct comedi_device * dev, comedi_devconfig * it)
 		(it->options[4] || it->options[5])) {
 		// allocate single-range range table
 		devpriv->user_ai_range_table =
-			kmalloc(sizeof(comedi_lrange) + sizeof(comedi_krange),
+			kmalloc(sizeof(struct comedi_lrange) + sizeof(comedi_krange),
 			GFP_KERNEL);
 		// initialize ai range
 		devpriv->user_ai_range_table->length = 1;
@@ -1509,7 +1509,7 @@ static int das16_attach(struct comedi_device * dev, comedi_devconfig * it)
 	if (it->options[6] || it->options[7]) {
 		// allocate single-range range table
 		devpriv->user_ao_range_table =
-			kmalloc(sizeof(comedi_lrange) + sizeof(comedi_krange),
+			kmalloc(sizeof(struct comedi_lrange) + sizeof(comedi_krange),
 			GFP_KERNEL);
 		// initialize ao range
 		devpriv->user_ao_range_table->length = 1;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 7e51137fcf5c..a0998a2efd62 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -700,7 +700,7 @@ static const struct das16_board_struct das16_boards[] = {
 
 static int das16_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int das16_detach(struct comedi_device * dev);
-static comedi_driver driver_das16 = {
+static struct comedi_driver driver_das16 = {
       driver_name:"das16",
       module:THIS_MODULE,
       attach:das16_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 94e59a5c6629..7e51137fcf5c 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -895,7 +895,7 @@ static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice *
 
 static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int byte;
 	unsigned long flags;
@@ -1201,7 +1201,7 @@ static void das16_interrupt(struct comedi_device * dev)
 {
 	unsigned long dma_flags, spin_flags;
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async;
+	struct comedi_async *async;
 	comedi_cmd *cmd;
 	int num_bytes, residue;
 	int buffer_index;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 07f8856c2c39..94e59a5c6629 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -326,20 +326,20 @@ struct munge_info {
 	unsigned have_byte:1;
 };
 
-static int das16_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int das16_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das16_cmd_exec(struct comedi_device * dev, comedi_subdevice * s);
-static int das16_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static void das16_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s);
+static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index);
 
 static void das16_reset(struct comedi_device * dev);
@@ -742,7 +742,7 @@ struct das16_private_struct {
 #define devpriv ((struct das16_private_struct *)(dev->private))
 #define thisboard ((struct das16_board_struct *)(dev->board_ptr))
 
-static int das16_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0, tmp;
@@ -893,7 +893,7 @@ static int das16_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int das16_cmd_exec(struct comedi_device * dev, comedi_subdevice * s)
+static int das16_cmd_exec(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -996,7 +996,7 @@ static int das16_cmd_exec(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int das16_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int das16_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1031,7 +1031,7 @@ static void das16_reset(struct comedi_device * dev)
 	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
-static int das16_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1079,7 +1079,7 @@ static int das16_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int das16_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -1091,7 +1091,7 @@ static int das16_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das16_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;
@@ -1111,7 +1111,7 @@ static int das16_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das16_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das16_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1200,7 +1200,7 @@ static int disable_dma_on_even(struct comedi_device * dev)
 static void das16_interrupt(struct comedi_device * dev)
 {
 	unsigned long dma_flags, spin_flags;
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	comedi_cmd *cmd;
 	int num_bytes, residue;
@@ -1368,7 +1368,7 @@ static int das1600_mode_detect(struct comedi_device * dev)
 
 static int das16_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int ret;
 	unsigned int irq;
 	unsigned long iobase;
@@ -1715,7 +1715,7 @@ static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	return size;
 }
 
-static void das16_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
+static void das16_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index dd28385fc12f..07f8856c2c39 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -326,34 +326,34 @@ struct munge_info {
 	unsigned have_byte:1;
 };
 
-static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int das16_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das16_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das16_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das16_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das16_cmd_exec(comedi_device * dev, comedi_subdevice * s);
-static int das16_cancel(comedi_device * dev, comedi_subdevice * s);
-static void das16_ai_munge(comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_exec(struct comedi_device * dev, comedi_subdevice * s);
+static int das16_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void das16_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index);
 
-static void das16_reset(comedi_device * dev);
+static void das16_reset(struct comedi_device * dev);
 static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG);
 static void das16_timer_interrupt(unsigned long arg);
-static void das16_interrupt(comedi_device * dev);
+static void das16_interrupt(struct comedi_device * dev);
 
-static unsigned int das16_set_pacer(comedi_device * dev, unsigned int ns,
+static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
 	int flags);
-static int das1600_mode_detect(comedi_device * dev);
-static unsigned int das16_suggest_transfer_size(comedi_device * dev,
+static int das1600_mode_detect(struct comedi_device * dev);
+static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	comedi_cmd cmd);
 
-static void reg_dump(comedi_device * dev);
+static void reg_dump(struct comedi_device * dev);
 
 typedef struct das16_board_struct {
 	const char *name;
@@ -698,8 +698,8 @@ static const struct das16_board_struct das16_boards[] = {
 
 #define n_das16_boards ((sizeof(das16_boards))/(sizeof(das16_board)))
 
-static int das16_attach(comedi_device * dev, comedi_devconfig * it);
-static int das16_detach(comedi_device * dev);
+static int das16_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das16_detach(struct comedi_device * dev);
 static comedi_driver driver_das16 = {
       driver_name:"das16",
       module:THIS_MODULE,
@@ -742,7 +742,7 @@ struct das16_private_struct {
 #define devpriv ((struct das16_private_struct *)(dev->private))
 #define thisboard ((struct das16_board_struct *)(dev->board_ptr))
 
-static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
+static int das16_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0, tmp;
@@ -893,7 +893,7 @@ static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int das16_cmd_exec(comedi_device * dev, comedi_subdevice * s)
+static int das16_cmd_exec(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -996,7 +996,7 @@ static int das16_cmd_exec(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int das16_cancel(comedi_device * dev, comedi_subdevice * s)
+static int das16_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1023,7 +1023,7 @@ static int das16_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static void das16_reset(comedi_device * dev)
+static void das16_reset(struct comedi_device * dev)
 {
 	outb(0, dev->iobase + DAS16_STATUS);
 	outb(0, dev->iobase + DAS16_CONTROL);
@@ -1031,7 +1031,7 @@ static void das16_reset(comedi_device * dev)
 	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
 }
 
-static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das16_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1079,7 +1079,7 @@ static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das16_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int bits;
@@ -1091,7 +1091,7 @@ static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das16_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;
@@ -1111,7 +1111,7 @@ static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int das16_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -1138,7 +1138,7 @@ static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	int status;
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 
 	status = inb(dev->iobase + DAS16_STATUS);
 
@@ -1155,7 +1155,7 @@ static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG)
 
 static void das16_timer_interrupt(unsigned long arg)
 {
-	comedi_device *dev = (comedi_device *) arg;
+	struct comedi_device *dev = (struct comedi_device *) arg;
 
 	das16_interrupt(dev);
 
@@ -1169,7 +1169,7 @@ static void das16_timer_interrupt(unsigned long arg)
 	an even transfer count after disabling dma
 	channel.
 */
-static int disable_dma_on_even(comedi_device * dev)
+static int disable_dma_on_even(struct comedi_device * dev)
 {
 	int residue;
 	int i;
@@ -1197,7 +1197,7 @@ static int disable_dma_on_even(comedi_device * dev)
 	return residue;
 }
 
-static void das16_interrupt(comedi_device * dev)
+static void das16_interrupt(struct comedi_device * dev)
 {
 	unsigned long dma_flags, spin_flags;
 	comedi_subdevice *s = dev->read_subdev;
@@ -1273,7 +1273,7 @@ static void das16_interrupt(comedi_device * dev)
 	cfc_handle_events(dev, s);
 }
 
-static unsigned int das16_set_pacer(comedi_device * dev, unsigned int ns,
+static unsigned int das16_set_pacer(struct comedi_device * dev, unsigned int ns,
 	int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
@@ -1286,7 +1286,7 @@ static unsigned int das16_set_pacer(comedi_device * dev, unsigned int ns,
 	return ns;
 }
 
-static void reg_dump(comedi_device * dev)
+static void reg_dump(struct comedi_device * dev)
 {
 	DEBUG_PRINT("********DAS1600 REGISTER DUMP********\n");
 	DEBUG_PRINT("DAS16_MUX: %x\n", inb(dev->iobase + DAS16_MUX));
@@ -1304,7 +1304,7 @@ static void reg_dump(comedi_device * dev)
 		inb(dev->iobase + DAS1600_STATUS_B));
 }
 
-static int das16_probe(comedi_device * dev, comedi_devconfig * it)
+static int das16_probe(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int status;
 	int diobits;
@@ -1338,7 +1338,7 @@ static int das16_probe(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static int das1600_mode_detect(comedi_device * dev)
+static int das1600_mode_detect(struct comedi_device * dev)
 {
 	int status = 0;
 
@@ -1366,7 +1366,7 @@ static int das1600_mode_detect(comedi_device * dev)
  *   3  Clock speed (in MHz)
  */
 
-static int das16_attach(comedi_device * dev, comedi_devconfig * it)
+static int das16_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	int ret;
@@ -1630,7 +1630,7 @@ static int das16_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static int das16_detach(comedi_device * dev)
+static int das16_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: das16: remove\n", dev->minor);
 
@@ -1674,7 +1674,7 @@ static int das16_detach(comedi_device * dev)
 COMEDI_INITCLEANUP(driver_das16);
 
 // utility function that suggests a dma transfer size in bytes
-static unsigned int das16_suggest_transfer_size(comedi_device * dev,
+static unsigned int das16_suggest_transfer_size(struct comedi_device * dev,
 	comedi_cmd cmd)
 {
 	unsigned int size;
@@ -1715,7 +1715,7 @@ static unsigned int das16_suggest_transfer_size(comedi_device * dev,
 	return size;
 }
 
-static void das16_ai_munge(comedi_device * dev, comedi_subdevice * s,
+static void das16_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
index 42a81b832a9b..dd28385fc12f 100644
--- a/drivers/staging/comedi/drivers/das16.c
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -327,13 +327,13 @@ struct munge_info {
 };
 
 static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
@@ -1032,7 +1032,7 @@ static void das16_reset(comedi_device * dev)
 }
 
 static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int range;
@@ -1080,9 +1080,9 @@ static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	lsampl_t bits;
+	unsigned int bits;
 
 	bits = inb(dev->iobase + DAS16_DIO) & 0xf;
 	data[1] = bits;
@@ -1092,9 +1092,9 @@ static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	lsampl_t wbits;
+	unsigned int wbits;
 
 	// only set bits that have been masked
 	data[0] &= 0xf;
@@ -1112,7 +1112,7 @@ static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int lsb, msb;
@@ -1718,8 +1718,8 @@ static unsigned int das16_suggest_transfer_size(comedi_device * dev,
 static void das16_ai_munge(comedi_device * dev, comedi_subdevice * s,
 	void *array, unsigned int num_bytes, unsigned int start_chan_index)
 {
-	unsigned int i, num_samples = num_bytes / sizeof(sampl_t);
-	sampl_t *data = array;
+	unsigned int i, num_samples = num_bytes / sizeof(short);
+	short *data = array;
 
 	for (i = 0; i < num_samples; i++) {
 		data[i] = le16_to_cpu(data[i]);

commit e64374f8f37c5325dd3e4dad619d49a289226d7d
Author: David Schleef <ds@schleef.org>
Date:   Thu Feb 19 09:58:16 2009 -0800

    Staging: comedi: add das16 driver
    
    Driver for DAS16 compatible boards
    
    From: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das16.c b/drivers/staging/comedi/drivers/das16.c
new file mode 100644
index 000000000000..42a81b832a9b
--- /dev/null
+++ b/drivers/staging/comedi/drivers/das16.c
@@ -0,0 +1,1730 @@
+/*
+    comedi/drivers/das16.c
+    DAS16 driver
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+    Copyright (C) 2000 Chris R. Baugher <baugher@enteract.com>
+    Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: das16
+Description: DAS16 compatible boards
+Author: Sam Moore, Warren Jasper, ds, Chris Baugher, Frank Hess, Roman Fietze
+Devices: [Keithley Metrabyte] DAS-16 (das-16), DAS-16G (das-16g),
+  DAS-16F (das-16f), DAS-1201 (das-1201), DAS-1202 (das-1202),
+  DAS-1401 (das-1401), DAS-1402 (das-1402), DAS-1601 (das-1601),
+  DAS-1602 (das-1602),
+  [ComputerBoards] PC104-DAS16/JR (pc104-das16jr),
+  PC104-DAS16JR/16 (pc104-das16jr/16),
+  CIO-DAS16JR/16 (cio-das16jr/16),
+  CIO-DAS16/JR (cio-das16/jr), CIO-DAS1401/12 (cio-das1401/12),
+  CIO-DAS1402/12 (cio-das1402/12), CIO-DAS1402/16 (cio-das1402/16),
+  CIO-DAS1601/12 (cio-das1601/12), CIO-DAS1602/12 (cio-das1602/12),
+  CIO-DAS1602/16 (cio-das1602/16), CIO-DAS16/330 (cio-das16/330)
+Status: works
+Updated: 2003-10-12
+
+A rewrite of the das16 and das1600 drivers.
+Options:
+	[0] - base io address
+	[1] - irq (does nothing, irq is not used anymore)
+	[2] - dma (optional, required for comedi_command support)
+	[3] - master clock speed in MHz (optional, 1 or 10, ignored if
+		board can probe clock, defaults to 1)
+	[4] - analog input range lowest voltage in microvolts (optional,
+		only useful if your board does not have software
+		programmable gain)
+	[5] - analog input range highest voltage in microvolts (optional,
+		only useful if board does not have software programmable
+		gain)
+	[6] - analog output range lowest voltage in microvolts (optional)
+	[7] - analog output range highest voltage in microvolts (optional)
+	[8] - use timer mode for DMA.  Timer mode is needed e.g. for
+		buggy DMA controllers in NS CS5530A (Geode Companion), and for
+		'jr' cards that lack a hardware fifo.  This option is no
+		longer needed, since timer mode is _always_ used.
+
+Passing a zero for an option is the same as leaving it unspecified.
+
+*/
+/*
+
+Testing and debugging help provided by Daniel Koch.
+
+Keithley Manuals:
+	2309.PDF (das16)
+	4919.PDF (das1400, 1600)
+	4922.PDF (das-1400)
+	4923.PDF (das1200, 1400, 1600)
+
+Computer boards manuals also available from their website www.measurementcomputing.com
+
+*/
+
+#include <linux/pci.h>
+#include <asm/dma.h>
+#include "../comedidev.h"
+
+#include "8253.h"
+#include "8255.h"
+#include "comedi_fc.h"
+
+#undef DEBUG
+//#define DEBUG
+
+#ifdef DEBUG
+#define DEBUG_PRINT(format, args...) rt_printk("das16: " format, ## args)
+#else
+#define DEBUG_PRINT(format, args...)
+#endif
+
+#define DAS16_SIZE 20		// number of ioports
+#define DAS16_DMA_SIZE 0xff00	// size in bytes of allocated dma buffer
+
+/*
+    cio-das16.pdf
+
+    "das16"
+    "das16/f"
+
+  0	a/d bits 0-3		start 12 bit
+  1	a/d bits 4-11		unused
+  2	mux read		mux set
+  3	di 4 bit		do 4 bit
+  4	unused			ao0_lsb
+  5	unused			ao0_msb
+  6	unused			ao1_lsb
+  7	unused			ao1_msb
+  8	status eoc uni/bip	interrupt reset
+  9	dma, int, trig ctrl	set dma, int
+  a	pacer control		unused
+  b	reserved		reserved
+  cdef	8254
+  0123	8255
+
+*/
+
+/*
+    cio-das16jr.pdf
+
+    "das16jr"
+
+  0	a/d bits 0-3		start 12 bit
+  1	a/d bits 4-11		unused
+  2	mux read		mux set
+  3	di 4 bit		do 4 bit
+  4567	unused			unused
+  8	status eoc uni/bip	interrupt reset
+  9	dma, int, trig ctrl	set dma, int
+  a	pacer control		unused
+  b	gain status		gain control
+  cdef	8254
+
+*/
+
+/*
+    cio-das16jr_16.pdf
+
+    "das16jr_16"
+
+  0	a/d bits 0-7		start 16 bit
+  1	a/d bits 8-15		unused
+  2	mux read		mux set
+  3	di 4 bit		do 4 bit
+  4567	unused			unused
+  8	status eoc uni/bip	interrupt reset
+  9	dma, int, trig ctrl	set dma, int
+  a	pacer control		unused
+  b	gain status		gain control
+  cdef	8254
+
+*/
+/*
+    cio-das160x-1x.pdf
+
+    "das1601/12"
+    "das1602/12"
+    "das1602/16"
+
+  0	a/d bits 0-3		start 12 bit
+  1	a/d bits 4-11		unused
+  2	mux read		mux set
+  3	di 4 bit		do 4 bit
+  4	unused			ao0_lsb
+  5	unused			ao0_msb
+  6	unused			ao1_lsb
+  7	unused			ao1_msb
+  8	status eoc uni/bip	interrupt reset
+  9	dma, int, trig ctrl	set dma, int
+  a	pacer control		unused
+  b	gain status		gain control
+  cdef	8254
+  400	8255
+  404	unused			conversion enable
+  405	unused			burst enable
+  406	unused			das1600 enable
+  407	status
+
+*/
+
+static const int sample_size = 2;	// size in bytes of a sample from board
+
+#define DAS16_TRIG		0
+#define DAS16_AI_LSB		0
+#define DAS16_AI_MSB		1
+#define DAS16_MUX		2
+#define DAS16_DIO		3
+#define DAS16_AO_LSB(x)	((x)?6:4)
+#define DAS16_AO_MSB(x)	((x)?7:5)
+#define DAS16_STATUS		8
+#define   BUSY			(1<<7)
+#define   UNIPOLAR			(1<<6)
+#define   DAS16_MUXBIT			(1<<5)
+#define   DAS16_INT			(1<<4)
+#define DAS16_CONTROL		9
+#define   DAS16_INTE			(1<<7)
+#define   DAS16_IRQ(x)			(((x) & 0x7) << 4)
+#define   DMA_ENABLE			(1<<2)
+#define   PACING_MASK	0x3
+#define   INT_PACER		0x03
+#define   EXT_PACER			0x02
+#define   DAS16_SOFT		0x00
+#define DAS16_PACER		0x0A
+#define   DAS16_CTR0			(1<<1)
+#define   DAS16_TRIG0			(1<<0)
+#define   BURST_LEN_BITS(x)			(((x) & 0xf) << 4)
+#define DAS16_GAIN		0x0B
+#define DAS16_CNTR0_DATA		0x0C
+#define DAS16_CNTR1_DATA		0x0D
+#define DAS16_CNTR2_DATA		0x0E
+#define DAS16_CNTR_CONTROL	0x0F
+#define   DAS16_TERM_CNT	0x00
+#define   DAS16_ONE_SHOT	0x02
+#define   DAS16_RATE_GEN	0x04
+#define   DAS16_CNTR_LSB_MSB	0x30
+#define   DAS16_CNTR0		0x00
+#define   DAS16_CNTR1		0x40
+#define   DAS16_CNTR2		0x80
+
+#define DAS1600_CONV		0x404
+#define   DAS1600_CONV_DISABLE		0x40
+#define DAS1600_BURST		0x405
+#define   DAS1600_BURST_VAL		0x40
+#define DAS1600_ENABLE		0x406
+#define   DAS1600_ENABLE_VAL		0x40
+#define DAS1600_STATUS_B	0x407
+#define   DAS1600_BME		0x40
+#define   DAS1600_ME		0x20
+#define   DAS1600_CD			0x10
+#define   DAS1600_WS			0x02
+#define   DAS1600_CLK_10MHZ		0x01
+
+static const comedi_lrange range_das1x01_bip = { 4, {
+			BIP_RANGE(10),
+			BIP_RANGE(1),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.01),
+	}
+};
+static const comedi_lrange range_das1x01_unip = { 4, {
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01),
+	}
+};
+static const comedi_lrange range_das1x02_bip = { 4, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+	}
+};
+static const comedi_lrange range_das1x02_unip = { 4, {
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+	}
+};
+static const comedi_lrange range_das16jr = { 9, {
+			// also used by 16/330
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			BIP_RANGE(0.625),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+	}
+};
+static const comedi_lrange range_das16jr_16 = { 8, {
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25),
+	}
+};
+
+static const int das16jr_gainlist[] = { 8, 0, 1, 2, 3, 4, 5, 6, 7 };
+static const int das16jr_16_gainlist[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
+static const int das1600_gainlist[] = { 0, 1, 2, 3 };
+enum {
+	das16_pg_none = 0,
+	das16_pg_16jr,
+	das16_pg_16jr_16,
+	das16_pg_1601,
+	das16_pg_1602,
+};
+static const int *const das16_gainlists[] = {
+	NULL,
+	das16jr_gainlist,
+	das16jr_16_gainlist,
+	das1600_gainlist,
+	das1600_gainlist,
+};
+static const comedi_lrange *const das16_ai_uni_lranges[] = {
+	&range_unknown,
+	&range_das16jr,
+	&range_das16jr_16,
+	&range_das1x01_unip,
+	&range_das1x02_unip,
+};
+static const comedi_lrange *const das16_ai_bip_lranges[] = {
+	&range_unknown,
+	&range_das16jr,
+	&range_das16jr_16,
+	&range_das1x01_bip,
+	&range_das1x02_bip,
+};
+
+struct munge_info {
+	uint8_t byte;
+	unsigned have_byte:1;
+};
+
+static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int das16_cmd_exec(comedi_device * dev, comedi_subdevice * s);
+static int das16_cancel(comedi_device * dev, comedi_subdevice * s);
+static void das16_ai_munge(comedi_device * dev, comedi_subdevice * s,
+	void *array, unsigned int num_bytes, unsigned int start_chan_index);
+
+static void das16_reset(comedi_device * dev);
+static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG);
+static void das16_timer_interrupt(unsigned long arg);
+static void das16_interrupt(comedi_device * dev);
+
+static unsigned int das16_set_pacer(comedi_device * dev, unsigned int ns,
+	int flags);
+static int das1600_mode_detect(comedi_device * dev);
+static unsigned int das16_suggest_transfer_size(comedi_device * dev,
+	comedi_cmd cmd);
+
+static void reg_dump(comedi_device * dev);
+
+typedef struct das16_board_struct {
+	const char *name;
+	void *ai;
+	unsigned int ai_nbits;
+	unsigned int ai_speed;	// max conversion speed in nanosec
+	unsigned int ai_pg;
+	void *ao;
+	unsigned int ao_nbits;
+	void *di;
+	void *do_;
+
+	unsigned int i8255_offset;
+	unsigned int i8254_offset;
+
+	unsigned int size;
+	unsigned int id;
+} das16_board;
+
+static const struct das16_board_struct das16_boards[] = {
+	{
+	      name:	"das-16",
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:15000,
+	      ai_pg:	das16_pg_none,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x10,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+	      id:	0x00,
+		},
+	{
+	      name:	"das-16g",
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:15000,
+	      ai_pg:	das16_pg_none,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x10,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+	      id:	0x00,
+		},
+	{
+	      name:	"das-16f",
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:8500,
+	      ai_pg:	das16_pg_none,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x10,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+	      id:	0x00,
+		},
+	{
+	      name:	"cio-das16",	// cio-das16.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:20000,
+	      ai_pg:	das16_pg_none,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x10,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+	      id:	0x80,
+		},
+	{
+	      name:	"cio-das16/f",	// das16.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_none,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x10,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+	      id:	0x80,
+		},
+	{
+	      name:	"cio-das16/jr",	// cio-das16jr.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:7692,
+	      ai_pg:	das16_pg_16jr,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x10,
+	      id:	0x00,
+		},
+	{
+	      name:	"pc104-das16jr",	// pc104-das16jr_xx.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:3300,
+	      ai_pg:	das16_pg_16jr,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x10,
+	      id:	0x00,
+		},
+	{
+	      name:	"cio-das16jr/16",	// cio-das16jr_16.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:16,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_16jr_16,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x10,
+	      id:	0x00,
+		},
+	{
+	      name:	"pc104-das16jr/16",	// pc104-das16jr_xx.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:16,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_16jr_16,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x10,
+	      id:	0x00,
+		},
+	{
+	      name:	"das-1201",	// 4924.pdf (keithley user's manual)
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:20000,
+	      ai_pg:	das16_pg_none,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+	      id:	0x20,
+		},
+	{
+	      name:	"das-1202",	// 4924.pdf (keithley user's manual)
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_none,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+	      id:	0x20,
+		},
+	{
+	      name:	"das-1401",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1601,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x0,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+		},
+	{
+	      name:	"das-1402",	// 4919.pdf and 4922.pdf (keithley user's manual)
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1602,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x0,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+	      id:	0xc0	// 4919.pdf says id bits are 0xe0, 4922.pdf says 0xc0
+		},
+	{
+	      name:	"das-1601",	// 4919.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1601,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"das-1602",	// 4919.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1602,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1401/12",	// cio-das1400_series.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:6250,
+	      ai_pg:	das16_pg_1601,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1402/12",	// cio-das1400_series.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:6250,
+	      ai_pg:	das16_pg_1602,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1402/16",	// cio-das1400_series.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:16,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1602,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1601/12",	// cio-das160x-1x.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:6250,
+	      ai_pg:	das16_pg_1601,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1602/12",	// cio-das160x-1x.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1602,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das1602/16",	// cio-das160x-1x.pdf
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:16,
+	      ai_speed:10000,
+	      ai_pg:	das16_pg_1602,
+	      ao:	das16_ao_winsn,
+	      ao_nbits:12,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0x400,
+	      i8254_offset:0x0c,
+	      size:	0x408,
+      id:	0xc0},
+	{
+	      name:	"cio-das16/330",	// ?
+	      ai:	das16_ai_rinsn,
+	      ai_nbits:12,
+	      ai_speed:3030,
+	      ai_pg:	das16_pg_16jr,
+	      ao:	NULL,
+	      di:	das16_di_rbits,
+	      do_:	das16_do_wbits,
+	      i8255_offset:0,
+	      i8254_offset:0x0c,
+	      size:	0x14,
+      id:	0xf0},
+#if 0
+	{
+	      name:	"das16/330i",	// ?
+		},
+	{
+	      name:	"das16/jr/ctr5",	// ?
+		},
+	{
+	      name:	"cio-das16/m1/16",	// cio-das16_m1_16.pdf, this board is a bit quirky, no dma
+		},
+#endif
+};
+
+#define n_das16_boards ((sizeof(das16_boards))/(sizeof(das16_board)))
+
+static int das16_attach(comedi_device * dev, comedi_devconfig * it);
+static int das16_detach(comedi_device * dev);
+static comedi_driver driver_das16 = {
+      driver_name:"das16",
+      module:THIS_MODULE,
+      attach:das16_attach,
+      detach:das16_detach,
+      board_name:&das16_boards[0].name,
+      num_names:n_das16_boards,
+      offset:sizeof(das16_boards[0]),
+};
+
+#define DAS16_TIMEOUT 1000
+
+/* Period for timer interrupt in jiffies.  It's a function
+ * to deal with possibility of dynamic HZ patches  */
+static inline int timer_period(void)
+{
+	return HZ / 20;
+}
+struct das16_private_struct {
+	unsigned int ai_unipolar;	// unipolar flag
+	unsigned int ai_singleended;	// single ended flag
+	unsigned int clockbase;	// master clock speed in ns
+	volatile unsigned int control_state;	// dma, interrupt and trigger control bits
+	volatile unsigned long adc_byte_count;	// number of bytes remaining
+	unsigned int divisor1;	// divisor dividing master clock to get conversion frequency
+	unsigned int divisor2;	// divisor dividing master clock to get conversion frequency
+	unsigned int dma_chan;	// dma channel
+	uint16_t *dma_buffer[2];
+	dma_addr_t dma_buffer_addr[2];
+	unsigned int current_buffer;
+	volatile unsigned int dma_transfer_size;	// target number of bytes to transfer per dma shot
+	// user-defined analog input and output ranges defined from config options
+	comedi_lrange *user_ai_range_table;
+	comedi_lrange *user_ao_range_table;
+
+	struct timer_list timer;	// for timed interrupt
+	volatile short timer_running;
+	volatile short timer_mode;	// true if using timer mode
+};
+#define devpriv ((struct das16_private_struct *)(dev->private))
+#define thisboard ((struct das16_board_struct *)(dev->board_ptr))
+
+static int das16_cmd_test(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0, tmp;
+	int gain, start_chan, i;
+	int mask;
+
+	/* make sure triggers are valid */
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	mask = TRIG_FOLLOW;
+	// if board supports burst mode
+	if (thisboard->size > 0x400)
+		mask |= TRIG_TIMER | TRIG_EXT;
+	cmd->scan_begin_src &= mask;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	mask = TRIG_TIMER | TRIG_EXT;
+	// if board supports burst mode
+	if (thisboard->size > 0x400)
+		mask |= TRIG_NOW;
+	cmd->convert_src &= mask;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)
+		err++;
+
+	// make sure scan_begin_src and convert_src dont conflict
+	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
+		err++;
+	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	// check against maximum frequency
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg <
+			thisboard->ai_speed * cmd->chanlist_len) {
+			cmd->scan_begin_arg =
+				thisboard->ai_speed * cmd->chanlist_len;
+			err++;
+		}
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+
+	if (cmd->stop_src == TRIG_NONE) {
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+	if (err)
+		return 3;
+
+	// step 4: fix up arguments
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		unsigned int tmp = cmd->scan_begin_arg;
+		// set divisors, correct timing arguments
+		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
+			&(devpriv->divisor1), &(devpriv->divisor2),
+			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+		err += (tmp != cmd->scan_begin_arg);
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		unsigned int tmp = cmd->convert_arg;
+		// set divisors, correct timing arguments
+		i8253_cascade_ns_to_timer_2div(devpriv->clockbase,
+			&(devpriv->divisor1), &(devpriv->divisor2),
+			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+		err += (tmp != cmd->convert_arg);
+	}
+	if (err)
+		return 4;
+
+	// check channel/gain list against card's limitations
+	if (cmd->chanlist) {
+		gain = CR_RANGE(cmd->chanlist[0]);
+		start_chan = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) !=
+				(start_chan + i) % s->n_chan) {
+				comedi_error(dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
+				err++;
+			}
+			if (CR_RANGE(cmd->chanlist[i]) != gain) {
+				comedi_error(dev,
+					"entries in chanlist must all have the same gain\n");
+				err++;
+			}
+		}
+	}
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int das16_cmd_exec(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int byte;
+	unsigned long flags;
+	int range;
+
+	if (devpriv->dma_chan == 0 || (dev->irq == 0
+			&& devpriv->timer_mode == 0)) {
+		comedi_error(dev,
+			"irq (or use of 'timer mode') dma required to execute comedi_cmd");
+		return -1;
+	}
+	if (cmd->flags & TRIG_RT) {
+		comedi_error(dev,
+			"isa dma transfers cannot be performed with TRIG_RT, aborting");
+		return -1;
+	}
+
+	devpriv->adc_byte_count =
+		cmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);
+
+	// disable conversions for das1600 mode
+	if (thisboard->size > 0x400) {
+		outb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);
+	}
+	// set scan limits
+	byte = CR_CHAN(cmd->chanlist[0]);
+	byte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;
+	outb(byte, dev->iobase + DAS16_MUX);
+
+	/* set gain (this is also burst rate register but according to
+	 * computer boards manual, burst rate does nothing, even on keithley cards) */
+	if (thisboard->ai_pg != das16_pg_none) {
+		range = CR_RANGE(cmd->chanlist[0]);
+		outb((das16_gainlists[thisboard->ai_pg])[range],
+			dev->iobase + DAS16_GAIN);
+	}
+
+	/* set counter mode and counts */
+	cmd->convert_arg =
+		das16_set_pacer(dev, cmd->convert_arg,
+		cmd->flags & TRIG_ROUND_MASK);
+	DEBUG_PRINT("pacer period: %d ns\n", cmd->convert_arg);
+
+	/* enable counters */
+	byte = 0;
+	/* Enable burst mode if appropriate. */
+	if (thisboard->size > 0x400) {
+		if (cmd->convert_src == TRIG_NOW) {
+			outb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);
+			// set burst length
+			byte |= BURST_LEN_BITS(cmd->chanlist_len - 1);
+		} else {
+			outb(0, dev->iobase + DAS1600_BURST);
+		}
+	}
+	outb(byte, dev->iobase + DAS16_PACER);
+
+	// set up dma transfer
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma_chan);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma_chan);
+	devpriv->current_buffer = 0;
+	set_dma_addr(devpriv->dma_chan,
+		devpriv->dma_buffer_addr[devpriv->current_buffer]);
+	// set appropriate size of transfer
+	devpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);
+	set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+	enable_dma(devpriv->dma_chan);
+	release_dma_lock(flags);
+
+	// set up interrupt
+	if (devpriv->timer_mode) {
+		devpriv->timer_running = 1;
+		devpriv->timer.expires = jiffies + timer_period();
+		add_timer(&devpriv->timer);
+		devpriv->control_state &= ~DAS16_INTE;
+	} else {
+		/* clear interrupt bit */
+		outb(0x00, dev->iobase + DAS16_STATUS);
+		/* enable interrupts */
+		devpriv->control_state |= DAS16_INTE;
+	}
+	devpriv->control_state |= DMA_ENABLE;
+	devpriv->control_state &= ~PACING_MASK;
+	if (cmd->convert_src == TRIG_EXT)
+		devpriv->control_state |= EXT_PACER;
+	else
+		devpriv->control_state |= INT_PACER;
+	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+
+	/* Enable conversions if using das1600 mode */
+	if (thisboard->size > 0x400) {
+		outb(0, dev->iobase + DAS1600_CONV);
+	}
+
+	return 0;
+}
+
+static int das16_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	/* disable interrupts, dma and pacer clocked conversions */
+	devpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;
+	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+	if (devpriv->dma_chan)
+		disable_dma(devpriv->dma_chan);
+
+	// disable SW timer
+	if (devpriv->timer_mode && devpriv->timer_running) {
+		devpriv->timer_running = 0;
+		del_timer(&devpriv->timer);
+	}
+
+	/* disable burst mode */
+	if (thisboard->size > 0x400) {
+		outb(0, dev->iobase + DAS1600_BURST);
+	}
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return 0;
+}
+
+static void das16_reset(comedi_device * dev)
+{
+	outb(0, dev->iobase + DAS16_STATUS);
+	outb(0, dev->iobase + DAS16_CONTROL);
+	outb(0, dev->iobase + DAS16_PACER);
+	outb(0, dev->iobase + DAS16_CNTR_CONTROL);
+}
+
+static int das16_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	int range;
+	int chan;
+	int msb, lsb;
+
+	// disable interrupts and pacing
+	devpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;
+	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+
+	/* set multiplexer */
+	chan = CR_CHAN(insn->chanspec);
+	chan |= CR_CHAN(insn->chanspec) << 4;
+	outb(chan, dev->iobase + DAS16_MUX);
+
+	/* set gain */
+	if (thisboard->ai_pg != das16_pg_none) {
+		range = CR_RANGE(insn->chanspec);
+		outb((das16_gainlists[thisboard->ai_pg])[range],
+			dev->iobase + DAS16_GAIN);
+	}
+
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		outb_p(0, dev->iobase + DAS16_TRIG);
+
+		for (i = 0; i < DAS16_TIMEOUT; i++) {
+			if (!(inb(dev->iobase + DAS16_STATUS) & BUSY))
+				break;
+		}
+		if (i == DAS16_TIMEOUT) {
+			rt_printk("das16: timeout\n");
+			return -ETIME;
+		}
+		msb = inb(dev->iobase + DAS16_AI_MSB);
+		lsb = inb(dev->iobase + DAS16_AI_LSB);
+		if (thisboard->ai_nbits == 12) {
+			data[n] = ((lsb >> 4) & 0xf) | (msb << 4);
+		} else {
+			data[n] = lsb | (msb << 8);
+		}
+	}
+
+	return n;
+}
+
+static int das16_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	lsampl_t bits;
+
+	bits = inb(dev->iobase + DAS16_DIO) & 0xf;
+	data[1] = bits;
+	data[0] = 0;
+
+	return 2;
+}
+
+static int das16_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	lsampl_t wbits;
+
+	// only set bits that have been masked
+	data[0] &= 0xf;
+	wbits = s->state;
+	// zero bits that have been masked
+	wbits &= ~data[0];
+	// set masked bits
+	wbits |= data[0] & data[1];
+	s->state = wbits;
+	data[1] = wbits;
+
+	outb(s->state, dev->iobase + DAS16_DIO);
+
+	return 2;
+}
+
+static int das16_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int lsb, msb;
+	int chan;
+
+	chan = CR_CHAN(insn->chanspec);
+
+	for (i = 0; i < insn->n; i++) {
+		if (thisboard->ao_nbits == 12) {
+			lsb = (data[i] << 4) & 0xff;
+			msb = (data[i] >> 4) & 0xff;
+		} else {
+			lsb = data[i] & 0xff;
+			msb = (data[i] >> 8) & 0xff;
+		}
+		outb(lsb, dev->iobase + DAS16_AO_LSB(chan));
+		outb(msb, dev->iobase + DAS16_AO_MSB(chan));
+	}
+
+	return i;
+}
+
+static irqreturn_t das16_dma_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	int status;
+	comedi_device *dev = d;
+
+	status = inb(dev->iobase + DAS16_STATUS);
+
+	if ((status & DAS16_INT) == 0) {
+		DEBUG_PRINT("spurious interrupt\n");
+		return IRQ_NONE;
+	}
+
+	/* clear interrupt */
+	outb(0x00, dev->iobase + DAS16_STATUS);
+	das16_interrupt(dev);
+	return IRQ_HANDLED;
+}
+
+static void das16_timer_interrupt(unsigned long arg)
+{
+	comedi_device *dev = (comedi_device *) arg;
+
+	das16_interrupt(dev);
+
+	if (devpriv->timer_running)
+		mod_timer(&devpriv->timer, jiffies + timer_period());
+}
+
+/* the pc104-das16jr (at least) has problems if the dma
+	transfer is interrupted in the middle of transferring
+	a 16 bit sample, so this function takes care to get
+	an even transfer count after disabling dma
+	channel.
+*/
+static int disable_dma_on_even(comedi_device * dev)
+{
+	int residue;
+	int i;
+	static const int disable_limit = 100;
+	static const int enable_timeout = 100;
+	disable_dma(devpriv->dma_chan);
+	residue = get_dma_residue(devpriv->dma_chan);
+	for (i = 0; i < disable_limit && (residue % 2); ++i) {
+		int j;
+		enable_dma(devpriv->dma_chan);
+		for (j = 0; j < enable_timeout; ++j) {
+			int new_residue;
+			comedi_udelay(2);
+			new_residue = get_dma_residue(devpriv->dma_chan);
+			if (new_residue != residue)
+				break;
+		}
+		disable_dma(devpriv->dma_chan);
+		residue = get_dma_residue(devpriv->dma_chan);
+	}
+	if (i == disable_limit) {
+		comedi_error(dev,
+			"failed to get an even dma transfer, could be trouble.");
+	}
+	return residue;
+}
+
+static void das16_interrupt(comedi_device * dev)
+{
+	unsigned long dma_flags, spin_flags;
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async;
+	comedi_cmd *cmd;
+	int num_bytes, residue;
+	int buffer_index;
+
+	if (dev->attached == 0) {
+		comedi_error(dev, "premature interrupt");
+		return;
+	}
+	// initialize async here to make sure it is not NULL
+	async = s->async;
+	cmd = &async->cmd;
+
+	if (devpriv->dma_chan == 0) {
+		comedi_error(dev, "interrupt with no dma channel?");
+		return;
+	}
+
+	comedi_spin_lock_irqsave(&dev->spinlock, spin_flags);
+	if ((devpriv->control_state & DMA_ENABLE) == 0) {
+		comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+		DEBUG_PRINT("interrupt while dma disabled?\n");
+		return;
+	}
+
+	dma_flags = claim_dma_lock();
+	clear_dma_ff(devpriv->dma_chan);
+	residue = disable_dma_on_even(dev);
+
+	// figure out how many points to read
+	if (residue > devpriv->dma_transfer_size) {
+		comedi_error(dev, "residue > transfer size!\n");
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		num_bytes = 0;
+	} else
+		num_bytes = devpriv->dma_transfer_size - residue;
+
+	if (cmd->stop_src == TRIG_COUNT && num_bytes >= devpriv->adc_byte_count) {
+		num_bytes = devpriv->adc_byte_count;
+		async->events |= COMEDI_CB_EOA;
+	}
+
+	buffer_index = devpriv->current_buffer;
+	devpriv->current_buffer = (devpriv->current_buffer + 1) % 2;
+	devpriv->adc_byte_count -= num_bytes;
+
+	// figure out how many bytes for next transfer
+	if (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&
+		devpriv->dma_transfer_size > devpriv->adc_byte_count)
+		devpriv->dma_transfer_size = devpriv->adc_byte_count;
+
+	// re-enable  dma
+	if ((async->events & COMEDI_CB_EOA) == 0) {
+		set_dma_addr(devpriv->dma_chan,
+			devpriv->dma_buffer_addr[devpriv->current_buffer]);
+		set_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);
+		enable_dma(devpriv->dma_chan);
+		/* reenable conversions for das1600 mode, (stupid hardware) */
+		if (thisboard->size > 0x400 && devpriv->timer_mode == 0) {
+			outb(0x00, dev->iobase + DAS1600_CONV);
+		}
+	}
+	release_dma_lock(dma_flags);
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, spin_flags);
+
+	cfc_write_array_to_buffer(s,
+		devpriv->dma_buffer[buffer_index], num_bytes);
+
+	cfc_handle_events(dev, s);
+}
+
+static unsigned int das16_set_pacer(comedi_device * dev, unsigned int ns,
+	int rounding_flags)
+{
+	i8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),
+		&(devpriv->divisor2), &ns, rounding_flags & TRIG_ROUND_MASK);
+
+	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
+	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);
+	i8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 2, devpriv->divisor2, 2);
+
+	return ns;
+}
+
+static void reg_dump(comedi_device * dev)
+{
+	DEBUG_PRINT("********DAS1600 REGISTER DUMP********\n");
+	DEBUG_PRINT("DAS16_MUX: %x\n", inb(dev->iobase + DAS16_MUX));
+	DEBUG_PRINT("DAS16_DIO: %x\n", inb(dev->iobase + DAS16_DIO));
+	DEBUG_PRINT("DAS16_STATUS: %x\n", inb(dev->iobase + DAS16_STATUS));
+	DEBUG_PRINT("DAS16_CONTROL: %x\n", inb(dev->iobase + DAS16_CONTROL));
+	DEBUG_PRINT("DAS16_PACER: %x\n", inb(dev->iobase + DAS16_PACER));
+	DEBUG_PRINT("DAS16_GAIN: %x\n", inb(dev->iobase + DAS16_GAIN));
+	DEBUG_PRINT("DAS16_CNTR_CONTROL: %x\n",
+		inb(dev->iobase + DAS16_CNTR_CONTROL));
+	DEBUG_PRINT("DAS1600_CONV: %x\n", inb(dev->iobase + DAS1600_CONV));
+	DEBUG_PRINT("DAS1600_BURST: %x\n", inb(dev->iobase + DAS1600_BURST));
+	DEBUG_PRINT("DAS1600_ENABLE: %x\n", inb(dev->iobase + DAS1600_ENABLE));
+	DEBUG_PRINT("DAS1600_STATUS_B: %x\n",
+		inb(dev->iobase + DAS1600_STATUS_B));
+}
+
+static int das16_probe(comedi_device * dev, comedi_devconfig * it)
+{
+	int status;
+	int diobits;
+
+	/* status is available on all boards */
+
+	status = inb(dev->iobase + DAS16_STATUS);
+
+	if ((status & UNIPOLAR)) {
+		devpriv->ai_unipolar = 1;
+	} else {
+		devpriv->ai_unipolar = 0;
+	}
+
+	if ((status & DAS16_MUXBIT)) {
+		devpriv->ai_singleended = 1;
+	} else {
+		devpriv->ai_singleended = 0;
+	}
+
+	/* diobits indicates boards */
+
+	diobits = inb(dev->iobase + DAS16_DIO) & 0xf0;
+
+	printk(" id bits are 0x%02x\n", diobits);
+	if (thisboard->id != diobits) {
+		printk(" requested board's id bits are 0x%x (ignore)\n",
+			thisboard->id);
+	}
+
+	return 0;
+}
+
+static int das1600_mode_detect(comedi_device * dev)
+{
+	int status = 0;
+
+	status = inb(dev->iobase + DAS1600_STATUS_B);
+
+	if (status & DAS1600_CLK_10MHZ) {
+		devpriv->clockbase = 100;
+		printk(" 10MHz pacer clock\n");
+	} else {
+		devpriv->clockbase = 1000;
+		printk(" 1MHz pacer clock\n");
+	}
+
+	reg_dump(dev);
+
+	return 0;
+}
+
+/*
+ *
+ * Options list:
+ *   0  I/O base
+ *   1  IRQ
+ *   2  DMA
+ *   3  Clock speed (in MHz)
+ */
+
+static int das16_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	int ret;
+	unsigned int irq;
+	unsigned long iobase;
+	unsigned int dma_chan;
+	int timer_mode;
+	unsigned long flags;
+	comedi_krange *user_ai_range, *user_ao_range;
+
+	iobase = it->options[0];
+#if 0
+	irq = it->options[1];
+	timer_mode = it->options[8];
+#endif
+	/* always use time_mode since using irq can drop samples while
+	 * waiting for dma done interrupt (due to hardware limitations) */
+	irq = 0;
+	timer_mode = 1;
+	if (timer_mode)
+		irq = 0;
+
+	printk("comedi%d: das16:", dev->minor);
+
+	// check that clock setting is valid
+	if (it->options[3]) {
+		if (it->options[3] != 0 &&
+			it->options[3] != 1 && it->options[3] != 10) {
+			printk("\n Invalid option.  Master clock must be set to 1 or 10 (MHz)\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((ret = alloc_private(dev, sizeof(struct das16_private_struct))) < 0)
+		return ret;
+
+	if (thisboard->size < 0x400) {
+		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + thisboard->size);
+		if (!request_region(iobase, thisboard->size, "das16")) {
+			printk(" I/O port conflict\n");
+			return -EIO;
+		}
+	} else {
+		printk(" 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",
+			iobase, iobase + 0x0f,
+			iobase + 0x400,
+			iobase + 0x400 + (thisboard->size & 0x3ff));
+		if (!request_region(iobase, 0x10, "das16")) {
+			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
+				iobase, iobase + 0x0f);
+			return -EIO;
+		}
+		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
+				"das16")) {
+			release_region(iobase, 0x10);
+			printk(" I/O port conflict:  0x%04lx-0x%04lx\n",
+				iobase + 0x400,
+				iobase + 0x400 + (thisboard->size & 0x3ff));
+			return -EIO;
+		}
+	}
+
+	dev->iobase = iobase;
+
+	// probe id bits to make sure they are consistent
+	if (das16_probe(dev, it)) {
+		printk(" id bits do not match selected board, aborting\n");
+		return -EINVAL;
+	}
+	dev->board_name = thisboard->name;
+
+	// get master clock speed
+	if (thisboard->size < 0x400) {
+		if (it->options[3])
+			devpriv->clockbase = 1000 / it->options[3];
+		else
+			devpriv->clockbase = 1000;	// 1 MHz default
+	} else {
+		das1600_mode_detect(dev);
+	}
+
+	/* now for the irq */
+	if (irq > 1 && irq < 8) {
+		if ((ret = comedi_request_irq(irq, das16_dma_interrupt, 0,
+					"das16", dev)) < 0)
+			return ret;
+		dev->irq = irq;
+		printk(" ( irq = %u )", irq);
+	} else if (irq == 0) {
+		printk(" ( no irq )");
+	} else {
+		printk(" invalid irq\n");
+		return -EINVAL;
+	}
+
+	// initialize dma
+	dma_chan = it->options[2];
+	if (dma_chan == 1 || dma_chan == 3) {
+		// allocate dma buffers
+		int i;
+		for (i = 0; i < 2; i++) {
+			devpriv->dma_buffer[i] = pci_alloc_consistent(NULL,
+				DAS16_DMA_SIZE, &devpriv->dma_buffer_addr[i]);
+			if (devpriv->dma_buffer[i] == NULL)
+				return -ENOMEM;
+		}
+		if (request_dma(dma_chan, "das16")) {
+			printk(" failed to allocate dma channel %i\n",
+				dma_chan);
+			return -EINVAL;
+		}
+		devpriv->dma_chan = dma_chan;
+		flags = claim_dma_lock();
+		disable_dma(devpriv->dma_chan);
+		set_dma_mode(devpriv->dma_chan, DMA_MODE_READ);
+		release_dma_lock(flags);
+		printk(" ( dma = %u)\n", dma_chan);
+	} else if (dma_chan == 0) {
+		printk(" ( no dma )\n");
+	} else {
+		printk(" invalid dma channel\n");
+		return -EINVAL;
+	}
+
+	// get any user-defined input range
+	if (thisboard->ai_pg == das16_pg_none &&
+		(it->options[4] || it->options[5])) {
+		// allocate single-range range table
+		devpriv->user_ai_range_table =
+			kmalloc(sizeof(comedi_lrange) + sizeof(comedi_krange),
+			GFP_KERNEL);
+		// initialize ai range
+		devpriv->user_ai_range_table->length = 1;
+		user_ai_range = devpriv->user_ai_range_table->range;
+		user_ai_range->min = it->options[4];
+		user_ai_range->max = it->options[5];
+		user_ai_range->flags = UNIT_volt;
+	}
+	// get any user-defined output range
+	if (it->options[6] || it->options[7]) {
+		// allocate single-range range table
+		devpriv->user_ao_range_table =
+			kmalloc(sizeof(comedi_lrange) + sizeof(comedi_krange),
+			GFP_KERNEL);
+		// initialize ao range
+		devpriv->user_ao_range_table->length = 1;
+		user_ao_range = devpriv->user_ao_range_table->range;
+		user_ao_range->min = it->options[6];
+		user_ao_range->max = it->options[7];
+		user_ao_range->flags = UNIT_volt;
+	}
+
+	if (timer_mode) {
+		init_timer(&(devpriv->timer));
+		devpriv->timer.function = das16_timer_interrupt;
+		devpriv->timer.data = (unsigned long)dev;
+	}
+	devpriv->timer_mode = timer_mode ? 1 : 0;
+
+	if ((ret = alloc_subdevices(dev, 5)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	/* ai */
+	if (thisboard->ai) {
+		s->type = COMEDI_SUBD_AI;
+		s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+		if (devpriv->ai_singleended) {
+			s->n_chan = 16;
+			s->len_chanlist = 16;
+			s->subdev_flags |= SDF_GROUND;
+		} else {
+			s->n_chan = 8;
+			s->len_chanlist = 8;
+			s->subdev_flags |= SDF_DIFF;
+		}
+		s->maxdata = (1 << thisboard->ai_nbits) - 1;
+		if (devpriv->user_ai_range_table) {	// user defined ai range
+			s->range_table = devpriv->user_ai_range_table;
+		} else if (devpriv->ai_unipolar) {
+			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
+		} else {
+			s->range_table = das16_ai_bip_lranges[thisboard->ai_pg];
+		}
+		s->insn_read = thisboard->ai;
+		s->do_cmdtest = das16_cmd_test;
+		s->do_cmd = das16_cmd_exec;
+		s->cancel = das16_cancel;
+		s->munge = das16_ai_munge;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 1;
+	/* ao */
+	if (thisboard->ao) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE;
+		s->n_chan = 2;
+		s->maxdata = (1 << thisboard->ao_nbits) - 1;
+		if (devpriv->user_ao_range_table) {	// user defined ao range
+			s->range_table = devpriv->user_ao_range_table;
+		} else {
+			s->range_table = &range_unknown;
+		}
+		s->insn_write = thisboard->ao;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 2;
+	/* di */
+	if (thisboard->di) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = thisboard->di;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 3;
+	/* do */
+	if (thisboard->do_) {
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+		s->n_chan = 4;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = thisboard->do_;
+		// initialize digital output lines
+		outb(s->state, dev->iobase + DAS16_DIO);
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s = dev->subdevices + 4;
+	/* 8255 */
+	if (thisboard->i8255_offset != 0) {
+		subdev_8255_init(dev, s, NULL, (dev->iobase +
+				thisboard->i8255_offset));
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	das16_reset(dev);
+	/* set the interrupt level */
+	devpriv->control_state = DAS16_IRQ(dev->irq);
+	outb(devpriv->control_state, dev->iobase + DAS16_CONTROL);
+
+	// turn on das1600 mode if available
+	if (thisboard->size > 0x400) {
+		outb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);
+		outb(0, dev->iobase + DAS1600_CONV);
+		outb(0, dev->iobase + DAS1600_BURST);
+	}
+
+	return 0;
+}
+
+static int das16_detach(comedi_device * dev)
+{
+	printk("comedi%d: das16: remove\n", dev->minor);
+
+	das16_reset(dev);
+
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 4);
+
+	if (devpriv) {
+		int i;
+		for (i = 0; i < 2; i++) {
+			if (devpriv->dma_buffer[i])
+				pci_free_consistent(NULL, DAS16_DMA_SIZE,
+					devpriv->dma_buffer[i],
+					devpriv->dma_buffer_addr[i]);
+		}
+		if (devpriv->dma_chan)
+			free_dma(devpriv->dma_chan);
+		if (devpriv->user_ai_range_table)
+			kfree(devpriv->user_ai_range_table);
+		if (devpriv->user_ao_range_table)
+			kfree(devpriv->user_ao_range_table);
+	}
+
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+
+	if (dev->iobase) {
+		if (thisboard->size < 0x400) {
+			release_region(dev->iobase, thisboard->size);
+		} else {
+			release_region(dev->iobase, 0x10);
+			release_region(dev->iobase + 0x400,
+				thisboard->size & 0x3ff);
+		}
+	}
+
+	return 0;
+}
+
+COMEDI_INITCLEANUP(driver_das16);
+
+// utility function that suggests a dma transfer size in bytes
+static unsigned int das16_suggest_transfer_size(comedi_device * dev,
+	comedi_cmd cmd)
+{
+	unsigned int size;
+	unsigned int freq;
+
+	/* if we are using timer interrupt, we don't care how long it
+	 * will take to complete transfer since it will be interrupted
+	 * by timer interrupt */
+	if (devpriv->timer_mode)
+		return DAS16_DMA_SIZE;
+
+	/* otherwise, we are relying on dma terminal count interrupt,
+	 * so pick a reasonable size */
+	if (cmd.convert_src == TRIG_TIMER)
+		freq = 1000000000 / cmd.convert_arg;
+	else if (cmd.scan_begin_src == TRIG_TIMER)
+		freq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;
+	// return some default value
+	else
+		freq = 0xffffffff;
+
+	if (cmd.flags & TRIG_WAKE_EOS) {
+		size = sample_size * cmd.chanlist_len;
+	} else {
+		// make buffer fill in no more than 1/3 second
+		size = (freq / 3) * sample_size;
+	}
+
+	// set a minimum and maximum size allowed
+	if (size > DAS16_DMA_SIZE)
+		size = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;
+	else if (size < sample_size)
+		size = sample_size;
+
+	if (cmd.stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)
+		size = devpriv->adc_byte_count;
+
+	return size;
+}
+
+static void das16_ai_munge(comedi_device * dev, comedi_subdevice * s,
+	void *array, unsigned int num_bytes, unsigned int start_chan_index)
+{
+	unsigned int i, num_samples = num_bytes / sizeof(sampl_t);
+	sampl_t *data = array;
+
+	for (i = 0; i < num_samples; i++) {
+		data[i] = le16_to_cpu(data[i]);
+		if (thisboard->ai_nbits == 12) {
+			data[i] = (data[i] >> 4) & 0xfff;
+		}
+	}
+}
