commit ab42b48f32d4c766420c3499ee9c0289b7028182
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 16 11:08:23 2019 +0000

    staging: comedi: gsc_hpdi: check dma_alloc_coherent() return value
    
    The "auto-attach" handler function `gsc_hpdi_auto_attach()` calls
    `dma_alloc_coherent()` in a loop to allocate some DMA data buffers, and
    also calls it to allocate a buffer for a DMA descriptor chain.  However,
    it does not check the return value of any of these calls.  Change
    `gsc_hpdi_auto_attach()` to return `-ENOMEM` if any of these
    `dma_alloc_coherent()` calls fail.  This will result in the comedi core
    calling the "detach" handler `gsc_hpdi_detach()` as part of the
    clean-up, which will call `gsc_hpdi_free_dma()` to free any allocated
    DMA coherent memory buffers.
    
    Cc: <stable@vger.kernel.org> #4.6+
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Link: https://lore.kernel.org/r/20191216110823.216237-1-abbotti@mev.co.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 4bdf44d82879..dc62db1ee1dd 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -623,6 +623,11 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 		    dma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,
 				       &devpriv->dio_buffer_phys_addr[i],
 				       GFP_KERNEL);
+		if (!devpriv->dio_buffer[i]) {
+			dev_warn(dev->class_dev,
+				 "failed to allocate DMA buffer\n");
+			return -ENOMEM;
+		}
 	}
 	/* allocate dma descriptors */
 	devpriv->dma_desc = dma_alloc_coherent(&pcidev->dev,
@@ -630,6 +635,11 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 					       NUM_DMA_DESCRIPTORS,
 					       &devpriv->dma_desc_phys_addr,
 					       GFP_KERNEL);
+	if (!devpriv->dma_desc) {
+		dev_warn(dev->class_dev,
+			 "failed to allocate DMA descriptors\n");
+		return -ENOMEM;
+	}
 	if (devpriv->dma_desc_phys_addr & 0xf) {
 		dev_warn(dev->class_dev,
 			 " dma descriptors not quad-word aligned (bug)\n");

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 39cc17c88607..4bdf44d82879 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -9,16 +9,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e5b948405fd9..39cc17c88607 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * gsc_hpdi.c
  * Comedi driver the General Standards Corporation

commit 686869b451b0b106cf6b365361fd577080fbca7a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 20 14:05:49 2016 +0100

    staging: comedi: plx9080.h: rename some macros for consistency
    
    Most of the macros in "plx9080.h" that define register values are
    single-bits flags of the form `PLX_<REG>_<FLAG>`, or are constant,
    multi-bit values of the form `PLX_<REG>_<FIELD>_<VAL>`, or are
    non-constant, function-like macros of the form `PLX_<REG>_<FIELD>(x)`.
    Some of the macros for constant, multi-bit values do not currently
    fit the pattern, so rename them for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index af4b4175af4d..e5b948405fd9 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -582,7 +582,7 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	bits |= PLX_DMAMODE_DEMAND;
 	/* enable local burst mode */
 	bits |= PLX_DMAMODE_BURSTEN;
-	bits |= PLX_DMAMODE_WIDTH32;
+	bits |= PLX_DMAMODE_WIDTH_32;
 	writel(bits, plx_iobase + PLX_REG_DMAMODE0);
 }
 

commit 3dcf1b5596603076cf127a3efdf3a33a276d8b9e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:18 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMACSRx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMACSR0 and DMACSR0 registers.  Use the prefix `PLX_DMACSR_` for the
    macros.  Make use of the `BIT(x)` macro to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f2f187492c16..af4b4175af4d 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -214,10 +214,10 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	dma0_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 	if (plx_status & PLX_INTCSR_DMA0IA) {
 		/* dma chan 0 interrupt */
-		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+		writeb((dma0_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,
 		       devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 
-		if (dma0_status & PLX_DMA_EN_BIT)
+		if (dma0_status & PLX_DMACSR_ENABLE)
 			gsc_hpdi_drain_dma(dev, 0);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -227,7 +227,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	dma1_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR1);
 	if (plx_status & PLX_INTCSR_DMA1IA) {
 		/* XXX */ /* dma chan 1 interrupt */
-		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+		writeb((dma1_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,
 		       devpriv->plx9080_mmio + PLX_REG_DMACSR1);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -316,7 +316,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 
 	/* enable dma transfer */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
+	writeb(PLX_DMACSR_ENABLE | PLX_DMACSR_START | PLX_DMACSR_CLEARINTR,
 	       devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 

commit dde90d89ae5a98a3f1420b6c20c7f58dd95ccfa3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:17 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMADPRx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMADPR0 and DMADPR1 registers.  (A little-endian version of the register
    value is also placed in the `next` member of `struct plx_dma_desc`.)
    Use the prefix `PLX_DMADPR_` for the macros.  Make use of the `BIT(x)`
    and `GENMASK(h,l)` macros to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index d63dc46acfe2..f2f187492c16 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -310,8 +310,8 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	writel(0, devpriv->plx9080_mmio + PLX_REG_DMALADR0);
 
 	/* give location of first dma descriptor */
-	bits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
-	       PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
+	bits = devpriv->dma_desc_phys_addr | PLX_DMADPR_DESCPCI |
+	       PLX_DMADPR_TCINTR | PLX_DMADPR_XFERL2P;
 	writel(bits, devpriv->plx9080_mmio + PLX_REG_DMADPR0);
 
 	/* enable dma transfer */
@@ -422,8 +422,8 @@ static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
 {
 	struct hpdi_private *devpriv = dev->private;
 	dma_addr_t phys_addr = devpriv->dma_desc_phys_addr;
-	u32 next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-			PLX_XFER_LOCAL_TO_PCI;
+	u32 next_bits = PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR |
+			PLX_DMADPR_XFERL2P;
 	unsigned int offset = 0;
 	unsigned int idx = 0;
 	unsigned int i;

commit 65bf53de830063520cfbdedd56d80f1125d62271
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:16 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 DMAMODEx register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    DMAMODE0 and DMAMODE1 registers.  Use the prefix `PLX_DMAMODE_` for the
    macros.  Make use of the `BIT(x)` and `GENMASK(h,l)` macros to define
    the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e28879801085..d63dc46acfe2 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -563,26 +563,26 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	/* configure dma0 mode */
 	bits = 0;
 	/* enable ready input */
-	bits |= PLX_DMA_EN_READYIN_BIT;
+	bits |= PLX_DMAMODE_READYIEN;
 	/* enable dma chaining */
-	bits |= PLX_EN_CHAIN_BIT;
+	bits |= PLX_DMAMODE_CHAINEN;
 	/*
 	 * enable interrupt on dma done
 	 * (probably don't need this, since chain never finishes)
 	 */
-	bits |= PLX_EN_DMA_DONE_INTR_BIT;
+	bits |= PLX_DMAMODE_DONEIEN;
 	/*
 	 * don't increment local address during transfers
 	 * (we are transferring from a fixed fifo register)
 	 */
-	bits |= PLX_LOCAL_ADDR_CONST_BIT;
+	bits |= PLX_DMAMODE_LACONST;
 	/* route dma interrupt to pci bus */
-	bits |= PLX_DMA_INTR_PCI_BIT;
+	bits |= PLX_DMAMODE_INTRPCI;
 	/* enable demand mode */
-	bits |= PLX_DEMAND_MODE_BIT;
+	bits |= PLX_DMAMODE_DEMAND;
 	/* enable local burst mode */
-	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
-	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
+	bits |= PLX_DMAMODE_BURSTEN;
+	bits |= PLX_DMAMODE_WIDTH32;
 	writel(bits, plx_iobase + PLX_REG_DMAMODE0);
 }
 

commit 9dc53852b10888f9032baf78d672b45ab4d791fe
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:13 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 INTCSR register values
    
    Replace the existing macros in "plx9080.h" that define values for the
    INTCSR register.  Use the prefix `PLX_INTCSR_` for the macros.  Make use
    of the `BIT(x)` and `GENMASK(h,l)` macros to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 536bebeb5f53..e28879801085 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -199,7 +199,8 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	plx_status = readl(devpriv->plx9080_mmio + PLX_REG_INTCSR);
-	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
+	if ((plx_status &
+	     (PLX_INTCSR_DMA0IA | PLX_INTCSR_DMA1IA | PLX_INTCSR_PLIA)) == 0)
 		return IRQ_NONE;
 
 	hpdi_intr_status = readl(dev->mmio + INTERRUPT_STATUS_REG);
@@ -211,7 +212,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR0);
-	if (plx_status & ICS_DMA0_A) {
+	if (plx_status & PLX_INTCSR_DMA0IA) {
 		/* dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_mmio + PLX_REG_DMACSR0);
@@ -224,7 +225,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR1);
-	if (plx_status & ICS_DMA1_A) {
+	if (plx_status & PLX_INTCSR_DMA1IA) {
 		/* XXX */ /* dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_mmio + PLX_REG_DMACSR1);
@@ -232,7 +233,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* clear possible plx9080 interrupt sources */
-	if (plx_status & ICS_LDIA) {
+	if (plx_status & PLX_INTCSR_LDBIA) {
 		/* clear local doorbell interrupt */
 		plx_bits = readl(devpriv->plx9080_mmio + PLX_REG_L2PDBELL);
 		writel(plx_bits, devpriv->plx9080_mmio + PLX_REG_L2PDBELL);
@@ -533,8 +534,9 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 
 	/* enable interrupts */
 	plx_intcsr_bits =
-	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-	    ICS_DMA0_E;
+	    PLX_INTCSR_LSEABORTEN | PLX_INTCSR_LSEPARITYEN | PLX_INTCSR_PIEN |
+	    PLX_INTCSR_PLIEN | PLX_INTCSR_PABORTIEN | PLX_INTCSR_LIOEN |
+	    PLX_INTCSR_DMA0IEN;
 	writel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_REG_INTCSR);
 
 	return 0;

commit a9c254a763e4641d41c4e4b7665d979180c8af27
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:09 2016 +0100

    staging: comedi: drivers: re-do PLX PCI 9080 BIGEND register values
    
    Replace `enum bigend_bits` in "plx9080.h" with a bunch of macros
    defining values for the BIGEND register.  Use the prefix `PLX_BIGEND_`
    for the macro names.  Make use of the `BIT(x)` and `GENMASK(h,l)` macros
    to define the values.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e2831e135a8d..536bebeb5f53 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -547,7 +547,7 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	void __iomem *plx_iobase = devpriv->plx9080_mmio;
 
 #ifdef __BIG_ENDIAN
-	bits = BIGEND_DMA0 | BIGEND_DMA1;
+	bits = PLX_BIGEND_DMA0 | PLX_BIGEND_DMA1;
 #else
 	bits = 0;
 #endif

commit c644a11aae6e36b6dbae425cdfa9630d2abaaa16
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 20 14:49:05 2016 +0100

    staging: comedi: drivers: rename PLX PCI 9080 register offsets
    
    Rename the macros in "plx9080.h" that define the offsets of registers,
    following the pattern `PLX_REG_<NAME>`, where `<NAME>` is the register
    name from the PLX PCI 9080 Data Book.
    
    Add defines for the "Mailbox" registers, and add parameterized macros
    for the mailbox registers and the DMA control registers.  Make use of
    the parameterized versions of the macros where it seems appropriate.
    
    The registers for supporting the I2O (Intelligent Input/Output) feature
    are largely left undefined, just defining enough to allow the I2O
    feature to be disabled.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 63b5cbc44bda..e2831e135a8d 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -158,10 +158,7 @@ static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 	unsigned int size;
 	unsigned int next;
 
-	if (channel)
-		next = readl(devpriv->plx9080_mmio + PLX_DMA1_PCI_ADDRESS_REG);
-	else
-		next = readl(devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);
+	next = readl(devpriv->plx9080_mmio + PLX_REG_DMAPADR(channel));
 
 	idx = devpriv->dma_desc_index;
 	start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);
@@ -201,7 +198,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	plx_status = readl(devpriv->plx9080_mmio + PLX_INTRCS_REG);
+	plx_status = readl(devpriv->plx9080_mmio + PLX_REG_INTCSR);
 	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
 
@@ -213,11 +210,11 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 
 	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
+	dma0_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 	if (plx_status & ICS_DMA0_A) {
 		/* dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
+		       devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 
 		if (dma0_status & PLX_DMA_EN_BIT)
 			gsc_hpdi_drain_dma(dev, 0);
@@ -226,19 +223,19 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 
 	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma1_status = readb(devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
+	dma1_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR1);
 	if (plx_status & ICS_DMA1_A) {
 		/* XXX */ /* dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_mmio + PLX_REG_DMACSR1);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {
 		/* clear local doorbell interrupt */
-		plx_bits = readl(devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
-		writel(plx_bits, devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
+		plx_bits = readl(devpriv->plx9080_mmio + PLX_REG_L2PDBELL);
+		writel(plx_bits, devpriv->plx9080_mmio + PLX_REG_L2PDBELL);
 	}
 
 	if (hpdi_board_status & RX_OVERRUN_BIT) {
@@ -307,19 +304,19 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	 * occasionally cause problems with transfer of first dma
 	 * block.  Initializing them to zero seems to fix the problem.
 	 */
-	writel(0, devpriv->plx9080_mmio + PLX_DMA0_TRANSFER_SIZE_REG);
-	writel(0, devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);
-	writel(0, devpriv->plx9080_mmio + PLX_DMA0_LOCAL_ADDRESS_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_REG_DMASIZ0);
+	writel(0, devpriv->plx9080_mmio + PLX_REG_DMAPADR0);
+	writel(0, devpriv->plx9080_mmio + PLX_REG_DMALADR0);
 
 	/* give location of first dma descriptor */
 	bits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
 	       PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
-	writel(bits, devpriv->plx9080_mmio + PLX_DMA0_DESCRIPTOR_REG);
+	writel(bits, devpriv->plx9080_mmio + PLX_REG_DMADPR0);
 
 	/* enable dma transfer */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-	       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
+	       devpriv->plx9080_mmio + PLX_REG_DMACSR0);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
@@ -538,7 +535,7 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 	plx_intcsr_bits =
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E;
-	writel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_INTRCS_REG);
+	writel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_REG_INTCSR);
 
 	return 0;
 }
@@ -554,9 +551,9 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 #else
 	bits = 0;
 #endif
-	writel(bits, devpriv->plx9080_mmio + PLX_BIGEND_REG);
+	writel(bits, devpriv->plx9080_mmio + PLX_REG_BIGEND);
 
-	writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_REG_INTCSR);
 
 	gsc_hpdi_abort_dma(dev, 0);
 	gsc_hpdi_abort_dma(dev, 1);
@@ -584,7 +581,7 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	/* enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
-	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
+	writel(bits, plx_iobase + PLX_REG_DMAMODE0);
 }
 
 static int gsc_hpdi_auto_attach(struct comedi_device *dev,
@@ -680,7 +677,7 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->plx9080_mmio) {
-			writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
+			writel(0, devpriv->plx9080_mmio + PLX_REG_INTCSR);
 			iounmap(devpriv->plx9080_mmio);
 		}
 		if (dev->mmio)

commit f3b1e4db825aeef5337501c88c15894ac33f732e
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sun Mar 6 05:51:52 2016 +0530

    staging: comedi: drivers: gsc_hpdi: Remove use of deprecated pci API
    
    Replace pci_[alloc|free]_consistent occurences with
    dma_[alloc|free]_coherent.
    
    The Coccinelle semantic patch that was used to make some of these
    changes is as follows:
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_KERNEL
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_KERNEL
      )
    )
    
    gsc_hpdi_auto_attach does not affect interrupt status but contains a
    call to comedi_alloc_devpriv() which calls kzalloc with GFP_KERNEL flag.
    Thus, there seems to be no danger that dma_alloc_coherent can be called
    with interrupts turned off, and GFP_KERNEL can be used.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 46ca5d938d5b..63b5cbc44bda 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -499,18 +499,18 @@ static void gsc_hpdi_free_dma(struct comedi_device *dev)
 	/* free pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		if (devpriv->dio_buffer[i])
-			pci_free_consistent(pcidev,
-					    DMA_BUFFER_SIZE,
-					    devpriv->dio_buffer[i],
-					    devpriv->dio_buffer_phys_addr[i]);
+			dma_free_coherent(&pcidev->dev,
+					  DMA_BUFFER_SIZE,
+					  devpriv->dio_buffer[i],
+					  devpriv->dio_buffer_phys_addr[i]);
 	}
 	/* free dma descriptors */
 	if (devpriv->dma_desc)
-		pci_free_consistent(pcidev,
-				    sizeof(struct plx_dma_desc) *
-				    NUM_DMA_DESCRIPTORS,
-				    devpriv->dma_desc,
-				    devpriv->dma_desc_phys_addr);
+		dma_free_coherent(&pcidev->dev,
+				  sizeof(struct plx_dma_desc) *
+				  NUM_DMA_DESCRIPTORS,
+				  devpriv->dma_desc,
+				  devpriv->dma_desc_phys_addr);
 }
 
 static int gsc_hpdi_init(struct comedi_device *dev)
@@ -630,14 +630,16 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	/* allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		devpriv->dio_buffer[i] =
-		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-					 &devpriv->dio_buffer_phys_addr[i]);
+		    dma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,
+				       &devpriv->dio_buffer_phys_addr[i],
+				       GFP_KERNEL);
 	}
 	/* allocate dma descriptors */
-	devpriv->dma_desc = pci_alloc_consistent(pcidev,
-						 sizeof(struct plx_dma_desc) *
-						 NUM_DMA_DESCRIPTORS,
-						 &devpriv->dma_desc_phys_addr);
+	devpriv->dma_desc = dma_alloc_coherent(&pcidev->dev,
+					       sizeof(struct plx_dma_desc) *
+					       NUM_DMA_DESCRIPTORS,
+					       &devpriv->dma_desc_phys_addr,
+					       GFP_KERNEL);
 	if (devpriv->dma_desc_phys_addr & 0xf) {
 		dev_warn(dev->class_dev,
 			 " dma descriptors not quad-word aligned (bug)\n");

commit fca0b7dcfb20e9ca22dea0fdf551a7995cb3f2a4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 7 15:31:09 2015 -0700

    staging: comedi: gsc_hpdi: use preferred kernel types
    
    Fix the checkpatch.pl issues about:
    
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e9296182236e..46ca5d938d5b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -125,7 +125,7 @@
 
 struct hpdi_private {
 	void __iomem *plx9080_mmio;
-	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/* dma buffers */
+	u32 *dio_buffer[NUM_DMA_BUFFERS];	/* dma buffers */
 	/* physical addresses of dma buffers */
 	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
 	/*
@@ -137,7 +137,7 @@ struct hpdi_private {
 	dma_addr_t dma_desc_phys_addr;
 	unsigned int num_dma_descriptors;
 	/* pointer to start of buffers indexed by descriptor */
-	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];
+	u32 *desc_dio_buffer[NUM_DMA_DESCRIPTORS];
 	/* index of the dma descriptor that is currently being used */
 	unsigned int dma_desc_index;
 	unsigned int tx_fifo_size;
@@ -169,7 +169,7 @@ static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 	for (desc = 0; (next < start || next >= start + devpriv->block_size) &&
 	     desc < devpriv->num_dma_descriptors; desc++) {
 		/* transfer data from dma buffer to comedi buffer */
-		size = devpriv->block_size / sizeof(uint32_t);
+		size = devpriv->block_size / sizeof(u32);
 		if (cmd->stop_src == TRIG_COUNT) {
 			if (size > devpriv->dio_count)
 				size = devpriv->dio_count;
@@ -192,10 +192,10 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	struct hpdi_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
-	uint32_t hpdi_intr_status, hpdi_board_status;
-	uint32_t plx_status;
-	uint32_t plx_bits;
-	uint8_t dma0_status, dma1_status;
+	u32 hpdi_intr_status, hpdi_board_status;
+	u32 plx_status;
+	u32 plx_bits;
+	u8 dma0_status, dma1_status;
 	unsigned long flags;
 
 	if (!dev->attached)
@@ -290,7 +290,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long flags;
-	uint32_t bits;
+	u32 bits;
 
 	if (s->io_bits)
 		return -EINVAL;
@@ -424,15 +424,15 @@ static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
 {
 	struct hpdi_private *devpriv = dev->private;
 	dma_addr_t phys_addr = devpriv->dma_desc_phys_addr;
-	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-			     PLX_XFER_LOCAL_TO_PCI;
+	u32 next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+			PLX_XFER_LOCAL_TO_PCI;
 	unsigned int offset = 0;
 	unsigned int idx = 0;
 	unsigned int i;
 
 	if (len > DMA_BUFFER_SIZE)
 		len = DMA_BUFFER_SIZE;
-	len -= len % sizeof(uint32_t);
+	len -= len % sizeof(u32);
 	if (len == 0)
 		return -EINVAL;
 
@@ -445,7 +445,7 @@ static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
 			(i + 1) * sizeof(devpriv->dma_desc[0])) | next_bits);
 
 		devpriv->desc_dio_buffer[i] = devpriv->dio_buffer[idx] +
-					      (offset / sizeof(uint32_t));
+					      (offset / sizeof(u32));
 
 		offset += len;
 		if (len + offset > DMA_BUFFER_SIZE) {
@@ -516,7 +516,7 @@ static void gsc_hpdi_free_dma(struct comedi_device *dev)
 static int gsc_hpdi_init(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
-	uint32_t plx_intcsr_bits;
+	u32 plx_intcsr_bits;
 
 	/* wait 10usec after reset before accessing fifos */
 	writel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);
@@ -546,7 +546,7 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
-	uint32_t bits;
+	u32 bits;
 	void __iomem *plx_iobase = devpriv->plx9080_mmio;
 
 #ifdef __BIG_ENDIAN

commit cbba89f8a8de369d7d3e54c9d7a1f00fc4a358d7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:29 2015 +0100

    staging: comedi: gsc_hpdi: use a better MODULE_DESCRIPTION()
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 51ab801e82b0..e9296182236e 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -717,5 +717,5 @@ static struct pci_driver gsc_hpdi_pci_driver = {
 module_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for General Standards PCI-HPDI32/PMC-HPDI32");
 MODULE_LICENSE("GPL");

commit 86357d8ed81ba967eca4047574e1b73b8d93772f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:28 2015 +0100

    staging: comedi: gsc_hpdi: use PCI_DEVICE_SUB()
    
    Use the `PCI_DEVICE_SUB()` macro in the initializer of the PCI module
    device table `gsc_hpdi_pci_table[]`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 2e459f6d6fe0..51ab801e82b0 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -702,8 +702,8 @@ static int gsc_hpdi_pci_probe(struct pci_dev *dev,
 }
 
 static const struct pci_device_id gsc_hpdi_pci_table[] = {
-	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
-		    0x2400, 0, 0, 0},
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080,
+			 PCI_VENDOR_ID_PLX, 0x2400) },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, gsc_hpdi_pci_table);

commit c5f2579ed3eae33d41299958af6af56c0c8a01ba
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:27 2015 +0100

    staging: comedi: gsc_hpdi: prefer using the BIT() macro
    
    Fix all the checkpatch issues "CHECK: Prefer using the BIT macro".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 31ff10807260..2e459f6d6fe0 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,45 +52,45 @@
  * PCI BAR2 Register map (dev->mmio)
  */
 #define FIRMWARE_REV_REG			0x00
-#define FEATURES_REG_PRESENT_BIT		(1 << 15)
+#define FEATURES_REG_PRESENT_BIT		BIT(15)
 #define BOARD_CONTROL_REG			0x04
-#define BOARD_RESET_BIT				(1 << 0)
-#define TX_FIFO_RESET_BIT			(1 << 1)
-#define RX_FIFO_RESET_BIT			(1 << 2)
-#define TX_ENABLE_BIT				(1 << 4)
-#define RX_ENABLE_BIT				(1 << 5)
-#define DEMAND_DMA_DIRECTION_TX_BIT		(1 << 6)  /* ch 0 only */
-#define LINE_VALID_ON_STATUS_VALID_BIT		(1 << 7)
-#define START_TX_BIT				(1 << 8)
-#define CABLE_THROTTLE_ENABLE_BIT		(1 << 9)
-#define TEST_MODE_ENABLE_BIT			(1 << 31)
+#define BOARD_RESET_BIT				BIT(0)
+#define TX_FIFO_RESET_BIT			BIT(1)
+#define RX_FIFO_RESET_BIT			BIT(2)
+#define TX_ENABLE_BIT				BIT(4)
+#define RX_ENABLE_BIT				BIT(5)
+#define DEMAND_DMA_DIRECTION_TX_BIT		BIT(6)  /* ch 0 only */
+#define LINE_VALID_ON_STATUS_VALID_BIT		BIT(7)
+#define START_TX_BIT				BIT(8)
+#define CABLE_THROTTLE_ENABLE_BIT		BIT(9)
+#define TEST_MODE_ENABLE_BIT			BIT(31)
 #define BOARD_STATUS_REG			0x08
 #define COMMAND_LINE_STATUS_MASK		(0x7f << 0)
-#define TX_IN_PROGRESS_BIT			(1 << 7)
-#define TX_NOT_EMPTY_BIT			(1 << 8)
-#define TX_NOT_ALMOST_EMPTY_BIT			(1 << 9)
-#define TX_NOT_ALMOST_FULL_BIT			(1 << 10)
-#define TX_NOT_FULL_BIT				(1 << 11)
-#define RX_NOT_EMPTY_BIT			(1 << 12)
-#define RX_NOT_ALMOST_EMPTY_BIT			(1 << 13)
-#define RX_NOT_ALMOST_FULL_BIT			(1 << 14)
-#define RX_NOT_FULL_BIT				(1 << 15)
-#define BOARD_JUMPER0_INSTALLED_BIT		(1 << 16)
-#define BOARD_JUMPER1_INSTALLED_BIT		(1 << 17)
-#define TX_OVERRUN_BIT				(1 << 21)
-#define RX_UNDERRUN_BIT				(1 << 22)
-#define RX_OVERRUN_BIT				(1 << 23)
+#define TX_IN_PROGRESS_BIT			BIT(7)
+#define TX_NOT_EMPTY_BIT			BIT(8)
+#define TX_NOT_ALMOST_EMPTY_BIT			BIT(9)
+#define TX_NOT_ALMOST_FULL_BIT			BIT(10)
+#define TX_NOT_FULL_BIT				BIT(11)
+#define RX_NOT_EMPTY_BIT			BIT(12)
+#define RX_NOT_ALMOST_EMPTY_BIT			BIT(13)
+#define RX_NOT_ALMOST_FULL_BIT			BIT(14)
+#define RX_NOT_FULL_BIT				BIT(15)
+#define BOARD_JUMPER0_INSTALLED_BIT		BIT(16)
+#define BOARD_JUMPER1_INSTALLED_BIT		BIT(17)
+#define TX_OVERRUN_BIT				BIT(21)
+#define RX_UNDERRUN_BIT				BIT(22)
+#define RX_OVERRUN_BIT				BIT(23)
 #define TX_PROG_ALMOST_REG			0x0c
 #define RX_PROG_ALMOST_REG			0x10
 #define ALMOST_EMPTY_BITS(x)			(((x) & 0xffff) << 0)
 #define ALMOST_FULL_BITS(x)			(((x) & 0xff) << 16)
 #define FEATURES_REG				0x14
-#define FIFO_SIZE_PRESENT_BIT			(1 << 0)
-#define FIFO_WORDS_PRESENT_BIT			(1 << 1)
-#define LEVEL_EDGE_INTERRUPTS_PRESENT_BIT	(1 << 2)
-#define GPIO_SUPPORTED_BIT			(1 << 3)
-#define PLX_DMA_CH1_SUPPORTED_BIT		(1 << 4)
-#define OVERRUN_UNDERRUN_SUPPORTED_BIT		(1 << 5)
+#define FIFO_SIZE_PRESENT_BIT			BIT(0)
+#define FIFO_WORDS_PRESENT_BIT			BIT(1)
+#define LEVEL_EDGE_INTERRUPTS_PRESENT_BIT	BIT(2)
+#define GPIO_SUPPORTED_BIT			BIT(3)
+#define PLX_DMA_CH1_SUPPORTED_BIT		BIT(4)
+#define OVERRUN_UNDERRUN_SUPPORTED_BIT		BIT(5)
 #define FIFO_REG				0x18
 #define TX_STATUS_COUNT_REG			0x1c
 #define TX_LINE_VALID_COUNT_REG			0x20,
@@ -98,16 +98,16 @@
 #define RX_STATUS_COUNT_REG			0x28
 #define RX_LINE_COUNT_REG			0x2c
 #define INTERRUPT_CONTROL_REG			0x30
-#define FRAME_VALID_START_INTR			(1 << 0)
-#define FRAME_VALID_END_INTR			(1 << 1)
-#define TX_FIFO_EMPTY_INTR			(1 << 8)
-#define TX_FIFO_ALMOST_EMPTY_INTR		(1 << 9)
-#define TX_FIFO_ALMOST_FULL_INTR		(1 << 10)
-#define TX_FIFO_FULL_INTR			(1 << 11)
-#define RX_EMPTY_INTR				(1 << 12)
-#define RX_ALMOST_EMPTY_INTR			(1 << 13)
-#define RX_ALMOST_FULL_INTR			(1 << 14)
-#define RX_FULL_INTR				(1 << 15)
+#define FRAME_VALID_START_INTR			BIT(0)
+#define FRAME_VALID_END_INTR			BIT(1)
+#define TX_FIFO_EMPTY_INTR			BIT(8)
+#define TX_FIFO_ALMOST_EMPTY_INTR		BIT(9)
+#define TX_FIFO_ALMOST_FULL_INTR		BIT(10)
+#define TX_FIFO_FULL_INTR			BIT(11)
+#define RX_EMPTY_INTR				BIT(12)
+#define RX_ALMOST_EMPTY_INTR			BIT(13)
+#define RX_ALMOST_FULL_INTR			BIT(14)
+#define RX_FULL_INTR				BIT(15)
 #define INTERRUPT_STATUS_REG			0x34
 #define TX_CLOCK_DIVIDER_REG			0x38
 #define TX_FIFO_SIZE_REG			0x40

commit 7b7afb469cfe9eb384028f86ce4ec2fb8946f772
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:26 2015 +0100

    staging: comedi: gsc_hpdi: usleep_range is preferred over udelay
    
    Fix checkpatch issue: "CHECK: usleep_range is preferred over udelay; see
    Documentation/timers/timers-howto.txt".  `udelay()` is only called once
    from a place where sleeping is allowed.  Replace it with a call to
    `usleep_range()` with a reasonable upper limit.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 0e04f15feb38..31ff10807260 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -520,7 +520,7 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 
 	/* wait 10usec after reset before accessing fifos */
 	writel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);
-	udelay(10);
+	usleep_range(10, 1000);
 
 	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
 	       dev->mmio + RX_PROG_ALMOST_REG);

commit e899a4165cffe3aa802f813c624e90ce7ca23189
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:25 2015 +0100

    staging: comedi: gsc_hpdi: remove multiple board type support
    
    The code for determining which board type matches the PCI device ID is
    over-the-top since only a single board type is supported.  Also, the
    method it uses match the PCI device ID to a board type is a little
    antiquated.  Most comedi drivers for PCI devices use `driver_data` from
    the probed PCI device as an index into an array of supported board
    types, but "gsc_hpdi" uses a `for` loop to find an element of
    `hpdi_boards[]` that matches the PCI device.  The only thing in
    `hpdi_boards[]` not used for finding a matching PCI device is the `name`
    member of `struct hpdi_board` which points to a string literal and ends
    up getting assigned to `dev->board_name`.
    
    Get rid of the multiple board type support, and set `dev->board_name` to
    point to the original string literal pointed to by
    `hpdi_boards[0].name`.  This string is visible to userspace.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 901025216971..0e04f15feb38 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -123,20 +123,6 @@
 #define NUM_DMA_BUFFERS				4
 #define NUM_DMA_DESCRIPTORS			256
 
-struct hpdi_board {
-	const char *name;
-	int device_id;
-	int subdevice_id;
-};
-
-static const struct hpdi_board hpdi_boards[] = {
-	{
-		.name		= "pci-hpdi32",
-		.device_id	= PCI_DEVICE_ID_PLX_9080,
-		.subdevice_id	= 0x2400,
-	 },
-};
-
 struct hpdi_private {
 	void __iomem *plx9080_mmio;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/* dma buffers */
@@ -601,35 +587,16 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 }
 
-static const struct hpdi_board *gsc_hpdi_find_board(struct pci_dev *pcidev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)
-		if (pcidev->device == hpdi_boards[i].device_id &&
-		    pcidev->subsystem_device == hpdi_boards[i].subdevice_id)
-			return &hpdi_boards[i];
-	return NULL;
-}
-
 static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct hpdi_board *thisboard;
 	struct hpdi_private *devpriv;
 	struct comedi_subdevice *s;
 	int i;
 	int retval;
 
-	thisboard = gsc_hpdi_find_board(pcidev);
-	if (!thisboard) {
-		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
-			pci_name(pcidev));
-		return -EINVAL;
-	}
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_name = "pci-hpdi32";
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)

commit dc05a7d70b824cbe26f00914e5f94e0b68d5aeda
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 5 18:47:24 2015 +0100

    staging: comedi: gsc_hpdi: tidy up comments
    
    Use the usual style for block comments.  Squash double spaces after
    comment opening sequence.  Move some comments after opening braces to
    following line.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index d9715ea1e2da..901025216971 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -139,11 +139,13 @@ static const struct hpdi_board hpdi_boards[] = {
 
 struct hpdi_private {
 	void __iomem *plx9080_mmio;
-	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
+	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/* dma buffers */
 	/* physical addresses of dma buffers */
 	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
-	/* array of dma descriptors read by plx9080, allocated to get proper
-	 * alignment */
+	/*
+	 * array of dma descriptors read by plx9080, allocated to get proper
+	 * alignment
+	 */
 	struct plx_dma_desc *dma_desc;
 	/* physical address of dma descriptor array */
 	dma_addr_t dma_desc_phys_addr;
@@ -195,7 +197,7 @@ static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 
 		devpriv->dma_desc_index = idx;
 	}
-	/*  XXX check for buffer overrun somehow */
+	/* XXX check for buffer overrun somehow */
 }
 
 static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
@@ -223,10 +225,11 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if (hpdi_intr_status)
 		writel(hpdi_intr_status, dev->mmio + INTERRUPT_STATUS_REG);
 
-	/*  spin lock makes sure no one else changes plx dma control reg */
+	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
-	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
+	if (plx_status & ICS_DMA0_A) {
+		/* dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
 
@@ -235,17 +238,19 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  spin lock makes sure no one else changes plx dma control reg */
+	/* spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
-	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
+	if (plx_status & ICS_DMA1_A) {
+		/* XXX */ /* dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  clear possible plx9080 interrupt sources */
-	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
+	/* clear possible plx9080 interrupt sources */
+	if (plx_status & ICS_LDIA) {
+		/* clear local doorbell interrupt */
 		plx_bits = readl(devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
 		writel(plx_bits, devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
 	}
@@ -273,7 +278,7 @@ static void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)
 	struct hpdi_private *devpriv = dev->private;
 	unsigned long flags;
 
-	/*  spinlock for plx dma control/status reg */
+	/* spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(devpriv->plx9080_mmio, channel);
@@ -543,7 +548,7 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 
 	writel(0, dev->mmio + INTERRUPT_CONTROL_REG);
 
-	/*  enable interrupts */
+	/* enable interrupts */
 	plx_intcsr_bits =
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E;
@@ -570,23 +575,27 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 	gsc_hpdi_abort_dma(dev, 0);
 	gsc_hpdi_abort_dma(dev, 1);
 
-	/*  configure dma0 mode */
+	/* configure dma0 mode */
 	bits = 0;
-	/*  enable ready input */
+	/* enable ready input */
 	bits |= PLX_DMA_EN_READYIN_BIT;
-	/*  enable dma chaining */
+	/* enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	/*  enable interrupt on dma done
-	 *  (probably don't need this, since chain never finishes) */
+	/*
+	 * enable interrupt on dma done
+	 * (probably don't need this, since chain never finishes)
+	 */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	/*  don't increment local address during transfers
-	 *  (we are transferring from a fixed fifo register) */
+	/*
+	 * don't increment local address during transfers
+	 * (we are transferring from a fixed fifo register)
+	 */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
-	/*  route dma interrupt to pci bus */
+	/* route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
-	/*  enable demand mode */
+	/* enable demand mode */
 	bits |= PLX_DEMAND_MODE_BIT;
-	/*  enable local burst mode */
+	/* enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
 	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
@@ -640,7 +649,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 
 	gsc_hpdi_init_plx9080(dev);
 
-	/*  get irq */
+	/* get irq */
 	if (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,
 			dev->board_name, dev)) {
 		dev_warn(dev->class_dev,
@@ -651,13 +660,13 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 
 	dev_dbg(dev->class_dev, " irq %u\n", dev->irq);
 
-	/*  allocate pci dma buffers */
+	/* allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		devpriv->dio_buffer[i] =
 		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					 &devpriv->dio_buffer_phys_addr[i]);
 	}
-	/*  allocate dma descriptors */
+	/* allocate dma descriptors */
 	devpriv->dma_desc = pci_alloc_consistent(pcidev,
 						 sizeof(struct plx_dma_desc) *
 						 NUM_DMA_DESCRIPTORS,

commit cf376ec0ee5c2078d99a60aadd742232f725b451
Author: Gujulan Elango, Hari Prasath (H.) <hgujulan@visteon.com>
Date:   Fri Apr 24 06:58:11 2015 +0000

    staging: gsc_hdpi: Remove dead code
    
    This patch removes commented code from this driver.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 3cb6409c4f01..d9715ea1e2da 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -135,13 +135,6 @@ static const struct hpdi_board hpdi_boards[] = {
 		.device_id	= PCI_DEVICE_ID_PLX_9080,
 		.subdevice_id	= 0x2400,
 	 },
-#if 0
-	{
-		.name		= "pxi-hpdi32",
-		.device_id	= 0x9656,
-		.subdevice_id	= 0x2705,
-	 },
-#endif
 };
 
 struct hpdi_private {

commit 86ca1cdda3e8e4aa76dd9289f302349f96414fc5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:17 2015 +0000

    staging: comedi: gsc_hpdi: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 8b7c475903ec..3cb6409c4f01 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -47,7 +47,6 @@
 #include "../comedi_pci.h"
 
 #include "plx9080.h"
-#include "comedi_fc.h"
 
 /*
  * PCI BAR2 Register map (dev->mmio)
@@ -385,18 +384,18 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -405,18 +404,19 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (!cmd->chanlist_len || !cmd->chanlist) {
 		cmd->chanlist_len = 32;
 		err |= -EINVAL;
 	}
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 3b806b175eda0de2fb74add45b14eee967e2bf7c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:57 2015 +0000

    staging: comedi: gsc_hpdi: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index be9988d37338..8b7c475903ec 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -41,11 +41,10 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "plx9080.h"
 #include "comedi_fc.h"

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index deada9784b69..be9988d37338 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -433,7 +433,6 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 		return 5;
 
 	return 0;
-
 }
 
 /* setup dma descriptors so a link completes every 'len' bytes */

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 0979f536ed39..deada9784b69 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -261,12 +261,12 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 
 	if (hpdi_board_status & RX_OVERRUN_BIT) {
 		dev_err(dev->class_dev, "rx fifo overrun\n");
-		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		async->events |= COMEDI_CB_ERROR;
 	}
 
 	if (hpdi_board_status & RX_UNDERRUN_BIT) {
 		dev_err(dev->class_dev, "rx fifo underrun\n");
-		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		async->events |= COMEDI_CB_ERROR;
 	}
 
 	if (devpriv->dio_count == 0)

commit ef49d8329e25ee1686520315713b86419cddcb45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:34 2014 -0700

    staging: comedi: drivers: replace SDF_WRITEABLE with SDF_WRITABLE
    
    As indicated in the comedi.h uapi header, SDF_WRITEABLE was a spelling
    error in the API, SDF_WRITABLE is prefered.
    
    For aesthetics, replace all the SDF_WRITEABLE uses with SDF_WRITABLE.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 58a99e812818..0979f536ed39 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -689,7 +689,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_DIO;
-	s->subdev_flags	= SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL |
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |
 			  SDF_CMD_READ;
 	s->n_chan	= 32;
 	s->len_chanlist	= 32;

commit 60e6644399337185a860552cba977f7c47ac0723
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:43 2014 -0700

    staging: comedi: gsc_hpdi: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will handle the '* sizeof(foo)' calculation to determine
    the number of bytes to add.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e99edaa3b9fa..58a99e812818 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -196,8 +196,8 @@ static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 				size = devpriv->dio_count;
 			devpriv->dio_count -= size;
 		}
-		cfc_write_array_to_buffer(s, devpriv->desc_dio_buffer[idx],
-					  size * sizeof(uint32_t));
+		comedi_buf_write_samples(s, devpriv->desc_dio_buffer[idx],
+					 size);
 		idx++;
 		idx %= devpriv->num_dma_descriptors;
 		start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);

commit b48e57e5b40469c81df768b2c2f0d54224feff79
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:26 2014 -0700

    staging: comedi: gsc_hpdi: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b8975a4606ea..e99edaa3b9fa 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -272,7 +272,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if (devpriv->dio_count == 0)
 		async->events |= COMEDI_CB_EOA;
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 
 	return IRQ_HANDLED;
 }

commit d558c5967741e6c551883c58441d29f5440a4ab2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:54 2014 -0700

    staging: comedi: gsc_hpdi: tidy up freeing of the dma buffers
    
    Factor the freeing of the dma buffers out of the (*detach).
    
    Move the freeing of the buffers so that it occurs after the PCI device
    has been disabled to avoid any race condition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index c1939102a820..b8975a4606ea 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -505,6 +505,32 @@ static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void gsc_hpdi_free_dma(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct hpdi_private *devpriv = dev->private;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	/* free pci dma buffers */
+	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+		if (devpriv->dio_buffer[i])
+			pci_free_consistent(pcidev,
+					    DMA_BUFFER_SIZE,
+					    devpriv->dio_buffer[i],
+					    devpriv->dio_buffer_phys_addr[i]);
+	}
+	/* free dma descriptors */
+	if (devpriv->dma_desc)
+		pci_free_consistent(pcidev,
+				    sizeof(struct plx_dma_desc) *
+				    NUM_DMA_DESCRIPTORS,
+				    devpriv->dma_desc,
+				    devpriv->dma_desc_phys_addr);
+}
+
 static int gsc_hpdi_init(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -679,9 +705,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 
 static void gsc_hpdi_detach(struct comedi_device *dev)
 {
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct hpdi_private *devpriv = dev->private;
-	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
@@ -692,24 +716,9 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 		}
 		if (dev->mmio)
 			iounmap(dev->mmio);
-		/*  free pci dma buffers */
-		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-			if (devpriv->dio_buffer[i])
-				pci_free_consistent(pcidev,
-						    DMA_BUFFER_SIZE,
-						    devpriv->dio_buffer[i],
-						    devpriv->
-						    dio_buffer_phys_addr[i]);
-		}
-		/*  free dma descriptors */
-		if (devpriv->dma_desc)
-			pci_free_consistent(pcidev,
-					    sizeof(struct plx_dma_desc) *
-					    NUM_DMA_DESCRIPTORS,
-					    devpriv->dma_desc,
-					    devpriv->dma_desc_phys_addr);
 	}
 	comedi_pci_disable(dev);
+	gsc_hpdi_free_dma(dev);
 }
 
 static struct comedi_driver gsc_hpdi_driver = {

commit 6883565484081cbaa5faca18f606bb1088549dec
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:57 2014 -0700

    staging: comedi: gsc_hpdi: remove deadcode in gsc_hpdi_cmd_test()
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 91c1e8cf5d24..c1939102a820 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -422,12 +422,10 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
-
-	if (err)
-		return 4;
+	/* Step 4: fix up any arguments */
 
 	/* Step 5: check channel list if it exists */
+
 	if (cmd->chanlist && cmd->chanlist_len > 0)
 		err |= gsc_hpdi_check_chanlist(dev, s, cmd);
 

commit c2dcf85a860da1fccd0f74c01c4517d77131a614
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:23 2014 -0700

    staging: comedi: gsc_hpdi: use the comedi_device 'mmio' member
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    base address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 22333c1ad88c..91c1e8cf5d24 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -51,7 +51,7 @@
 #include "comedi_fc.h"
 
 /*
- * PCI BAR2 Register map (devpriv->mmio)
+ * PCI BAR2 Register map (dev->mmio)
  */
 #define FIRMWARE_REV_REG			0x00
 #define FEATURES_REG_PRESENT_BIT		(1 << 15)
@@ -148,7 +148,6 @@ static const struct hpdi_board hpdi_boards[] = {
 
 struct hpdi_private {
 	void __iomem *plx9080_mmio;
-	void __iomem *mmio;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
 	/* physical addresses of dma buffers */
 	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
@@ -227,11 +226,11 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
 
-	hpdi_intr_status = readl(devpriv->mmio + INTERRUPT_STATUS_REG);
-	hpdi_board_status = readl(devpriv->mmio + BOARD_STATUS_REG);
+	hpdi_intr_status = readl(dev->mmio + INTERRUPT_STATUS_REG);
+	hpdi_board_status = readl(dev->mmio + BOARD_STATUS_REG);
 
 	if (hpdi_intr_status)
-		writel(hpdi_intr_status, devpriv->mmio + INTERRUPT_STATUS_REG);
+		writel(hpdi_intr_status, dev->mmio + INTERRUPT_STATUS_REG);
 
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -294,10 +293,8 @@ static void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)
 static int gsc_hpdi_cancel(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
-	struct hpdi_private *devpriv = dev->private;
-
-	writel(0, devpriv->mmio + BOARD_CONTROL_REG);
-	writel(0, devpriv->mmio + INTERRUPT_CONTROL_REG);
+	writel(0, dev->mmio + BOARD_CONTROL_REG);
+	writel(0, dev->mmio + INTERRUPT_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 
@@ -316,7 +313,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	if (s->io_bits)
 		return -EINVAL;
 
-	writel(RX_FIFO_RESET_BIT, devpriv->mmio + BOARD_CONTROL_REG);
+	writel(RX_FIFO_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 
@@ -349,13 +346,12 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 		devpriv->dio_count = 1;
 
 	/* clear over/under run status flags */
-	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-	       devpriv->mmio + BOARD_STATUS_REG);
+	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT, dev->mmio + BOARD_STATUS_REG);
 
 	/* enable interrupts */
-	writel(RX_FULL_INTR, devpriv->mmio + INTERRUPT_CONTROL_REG);
+	writel(RX_FULL_INTR, dev->mmio + INTERRUPT_CONTROL_REG);
 
-	writel(RX_ENABLE_BIT, devpriv->mmio + BOARD_CONTROL_REG);
+	writel(RX_ENABLE_BIT, dev->mmio + BOARD_CONTROL_REG);
 
 	return 0;
 }
@@ -517,20 +513,20 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 	uint32_t plx_intcsr_bits;
 
 	/* wait 10usec after reset before accessing fifos */
-	writel(BOARD_RESET_BIT, devpriv->mmio + BOARD_CONTROL_REG);
+	writel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);
 	udelay(10);
 
 	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
-	       devpriv->mmio + RX_PROG_ALMOST_REG);
+	       dev->mmio + RX_PROG_ALMOST_REG);
 	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
-	       devpriv->mmio + TX_PROG_ALMOST_REG);
+	       dev->mmio + TX_PROG_ALMOST_REG);
 
-	devpriv->tx_fifo_size = readl(devpriv->mmio + TX_FIFO_SIZE_REG) &
+	devpriv->tx_fifo_size = readl(dev->mmio + TX_FIFO_SIZE_REG) &
 				FIFO_SIZE_MASK;
-	devpriv->rx_fifo_size = readl(devpriv->mmio + RX_FIFO_SIZE_REG) &
+	devpriv->rx_fifo_size = readl(dev->mmio + RX_FIFO_SIZE_REG) &
 				FIFO_SIZE_MASK;
 
-	writel(0, devpriv->mmio + INTERRUPT_CONTROL_REG);
+	writel(0, dev->mmio + INTERRUPT_CONTROL_REG);
 
 	/*  enable interrupts */
 	plx_intcsr_bits =
@@ -621,8 +617,8 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	pci_set_master(pcidev);
 
 	devpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);
-	devpriv->mmio = pci_ioremap_bar(pcidev, 2);
-	if (!devpriv->plx9080_mmio || !devpriv->mmio) {
+	dev->mmio = pci_ioremap_bar(pcidev, 2);
+	if (!devpriv->plx9080_mmio || !dev->mmio) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -696,8 +692,8 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 			writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
 			iounmap(devpriv->plx9080_mmio);
 		}
-		if (devpriv->mmio)
-			iounmap(devpriv->mmio);
+		if (dev->mmio)
+			iounmap(dev->mmio);
 		/*  free pci dma buffers */
 		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 			if (devpriv->dio_buffer[i])

commit 4264cb64069e1c746483938c09e0df1099befd8b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:00 2014 -0700

    staging: comedi: gsc_hpdi: validate the cmd->start_arg
    
    The cmd->start_arg should be trivially validated in Step 3 of the
    (*do_cmdtest) functions. Add the necessary code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index bae4e9709135..22333c1ad88c 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -410,6 +410,8 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
 	if (!cmd->chanlist_len || !cmd->chanlist) {
 		cmd->chanlist_len = 32;
 		err |= -EINVAL;

commit 198b21c642a4c0dbf44d805742ff52aa25756216
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:17 2014 -0700

    staging: comedi: gsc_hpdi: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the async command support. Tidy
    up the factored out code.
    
    To minimize the noise, change the dev_err() to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 08d7655e24e7..bae4e9709135 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -360,12 +360,30 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static int gsc_hpdi_check_chanlist(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_cmd *cmd)
+{
+	int i;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
+		if (chan != i) {
+			dev_dbg(dev->class_dev,
+				"chanlist must be ch 0 to 31 in order\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int i;
 
 	if (s->io_bits)
 		return -EINVAL;
@@ -411,17 +429,9 @@ static int gsc_hpdi_cmd_test(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/* step 5: complain about special chanlist considerations */
-
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		if (CR_CHAN(cmd->chanlist[i]) != i) {
-			/*  XXX could support 8 or 16 channels */
-			dev_err(dev->class_dev,
-				"chanlist must be ch 0 to 31 in order");
-			err |= -EINVAL;
-			break;
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= gsc_hpdi_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit f0571cb44084cfbcc89f13dc2ac59dbf837b97bd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:34 2014 -0700

    staging: comedi: gsc_hpdi: tidy up multi-line comment
    
    Tidy up the comment to follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e66a7c943f59..08d7655e24e7 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -1,24 +1,24 @@
 /*
-    comedi/drivers/gsc_hpdi.c
-    This is a driver for the General Standards Corporation High
-    Speed Parallel Digital Interface rs485 boards.
-
-    Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
-    Copyright (C) 2003 Coherent Imaging Systems
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * gsc_hpdi.c
+ * Comedi driver the General Standards Corporation
+ * High Speed Parallel Digital Interface rs485 boards.
+ *
+ * Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Copyright (C) 2003 Coherent Imaging Systems
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
  * Driver: gsc_hpdi

commit 63810f3b5514cc93189b329ddf15e13069b28f96
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:33 2014 -0700

    staging: comedi: gsc_hpdi: remove pr_fmt() define
    
    This driver no longer has any pr_{level} messages. Remove the pr_fmt().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 950516bbb664..e66a7c943f59 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -40,8 +40,6 @@
  * support could be added to this driver.
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>

commit 47266aaf35c6b83a885f99f5d6b302ef221d5013
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:32 2014 -0700

    staging: comedi: gsc_hpdi: convert comedi_error() messages to dev_err()
    
    For aesthetics, convert the comedi_error() messages to dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 2db02b435dfe..950516bbb664 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -263,12 +263,12 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	}
 
 	if (hpdi_board_status & RX_OVERRUN_BIT) {
-		comedi_error(dev, "rx fifo overrun");
+		dev_err(dev->class_dev, "rx fifo overrun\n");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 
 	if (hpdi_board_status & RX_UNDERRUN_BIT) {
-		comedi_error(dev, "rx fifo underrun");
+		dev_err(dev->class_dev, "rx fifo underrun\n");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 

commit d67107fe9190c89de2971584ded0ca3c67190259
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:31 2014 -0700

    staging: comedi: gsc_hpdi: tidy up the boardinfo
    
    Remove the unnecessary comments in the boardinfo definition and
    tidy up the declaration.
    
    FWIW, I'm not sure this boardinfo is really needed...
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f95724a77de6..2db02b435dfe 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -128,22 +128,22 @@
 #define NUM_DMA_DESCRIPTORS			256
 
 struct hpdi_board {
-	const char *name;	/*  board name */
-	int device_id;		/*  pci device id */
-	int subdevice_id;	/*  pci subdevice id */
+	const char *name;
+	int device_id;
+	int subdevice_id;
 };
 
 static const struct hpdi_board hpdi_boards[] = {
 	{
-	 .name = "pci-hpdi32",
-	 .device_id = PCI_DEVICE_ID_PLX_9080,
-	 .subdevice_id = 0x2400,
+		.name		= "pci-hpdi32",
+		.device_id	= PCI_DEVICE_ID_PLX_9080,
+		.subdevice_id	= 0x2400,
 	 },
 #if 0
 	{
-	 .name = "pxi-hpdi32",
-	 .device_id = 0x9656,
-	 .subdevice_id = 0x2705,
+		.name		= "pxi-hpdi32",
+		.device_id	= 0x9656,
+		.subdevice_id	= 0x2705,
 	 },
 #endif
 };

commit fce0ff523a8a8e975432dae9ecb0934ad6e3d20f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:30 2014 -0700

    staging: comedi: gsc_hpdi: tidy up the register map
    
    For aesthetics, convert the various enums into simple defines to
    describe the register map for the board. Group the bit defines with
    the associated register define. Convert the helper functions for
    the register bit/shift/mask stuff into simple defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 0770ad17d135..f95724a77de6 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,115 +52,80 @@
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-#define TIMER_BASE 50		/*  20MHz master clock */
-#define DMA_BUFFER_SIZE 0x10000
-#define NUM_DMA_BUFFERS 4
-#define NUM_DMA_DESCRIPTORS 256
-
-enum hpdi_registers {
-	FIRMWARE_REV_REG = 0x0,
-	BOARD_CONTROL_REG = 0x4,
-	BOARD_STATUS_REG = 0x8,
-	TX_PROG_ALMOST_REG = 0xc,
-	RX_PROG_ALMOST_REG = 0x10,
-	FEATURES_REG = 0x14,
-	FIFO_REG = 0x18,
-	TX_STATUS_COUNT_REG = 0x1c,
-	TX_LINE_VALID_COUNT_REG = 0x20,
-	TX_LINE_INVALID_COUNT_REG = 0x24,
-	RX_STATUS_COUNT_REG = 0x28,
-	RX_LINE_COUNT_REG = 0x2c,
-	INTERRUPT_CONTROL_REG = 0x30,
-	INTERRUPT_STATUS_REG = 0x34,
-	TX_CLOCK_DIVIDER_REG = 0x38,
-	TX_FIFO_SIZE_REG = 0x40,
-	RX_FIFO_SIZE_REG = 0x44,
-	TX_FIFO_WORDS_REG = 0x48,
-	RX_FIFO_WORDS_REG = 0x4c,
-	INTERRUPT_EDGE_LEVEL_REG = 0x50,
-	INTERRUPT_POLARITY_REG = 0x54,
-};
-
-/* bit definitions */
-
-enum firmware_revision_bits {
-	FEATURES_REG_PRESENT_BIT = 0x8000,
-};
-
-enum board_control_bits {
-	BOARD_RESET_BIT = 0x1,	/* wait 10usec before accessing fifos */
-	TX_FIFO_RESET_BIT = 0x2,
-	RX_FIFO_RESET_BIT = 0x4,
-	TX_ENABLE_BIT = 0x10,
-	RX_ENABLE_BIT = 0x20,
-	DEMAND_DMA_DIRECTION_TX_BIT = 0x40,
-		/* for ch 0, ch 1 can only transmit (when present) */
-	LINE_VALID_ON_STATUS_VALID_BIT = 0x80,
-	START_TX_BIT = 0x10,
-	CABLE_THROTTLE_ENABLE_BIT = 0x20,
-	TEST_MODE_ENABLE_BIT = 0x80000000,
-};
-
-enum board_status_bits {
-	COMMAND_LINE_STATUS_MASK = 0x7f,
-	TX_IN_PROGRESS_BIT = 0x80,
-	TX_NOT_EMPTY_BIT = 0x100,
-	TX_NOT_ALMOST_EMPTY_BIT = 0x200,
-	TX_NOT_ALMOST_FULL_BIT = 0x400,
-	TX_NOT_FULL_BIT = 0x800,
-	RX_NOT_EMPTY_BIT = 0x1000,
-	RX_NOT_ALMOST_EMPTY_BIT = 0x2000,
-	RX_NOT_ALMOST_FULL_BIT = 0x4000,
-	RX_NOT_FULL_BIT = 0x8000,
-	BOARD_JUMPER0_INSTALLED_BIT = 0x10000,
-	BOARD_JUMPER1_INSTALLED_BIT = 0x20000,
-	TX_OVERRUN_BIT = 0x200000,
-	RX_UNDERRUN_BIT = 0x400000,
-	RX_OVERRUN_BIT = 0x800000,
-};
-
-static uint32_t almost_full_bits(unsigned int num_words)
-{
-	/* XXX need to add or subtract one? */
-	return (num_words << 16) & 0xff0000;
-}
-
-static uint32_t almost_empty_bits(unsigned int num_words)
-{
-	return num_words & 0xffff;
-}
-
-enum features_bits {
-	FIFO_SIZE_PRESENT_BIT = 0x1,
-	FIFO_WORDS_PRESENT_BIT = 0x2,
-	LEVEL_EDGE_INTERRUPTS_PRESENT_BIT = 0x4,
-	GPIO_SUPPORTED_BIT = 0x8,
-	PLX_DMA_CH1_SUPPORTED_BIT = 0x10,
-	OVERRUN_UNDERRUN_SUPPORTED_BIT = 0x20,
-};
-
-enum interrupt_sources {
-	FRAME_VALID_START_INTR = 0,
-	FRAME_VALID_END_INTR = 1,
-	TX_FIFO_EMPTY_INTR = 8,
-	TX_FIFO_ALMOST_EMPTY_INTR = 9,
-	TX_FIFO_ALMOST_FULL_INTR = 10,
-	TX_FIFO_FULL_INTR = 11,
-	RX_EMPTY_INTR = 12,
-	RX_ALMOST_EMPTY_INTR = 13,
-	RX_ALMOST_FULL_INTR = 14,
-	RX_FULL_INTR = 15,
-};
-
-static uint32_t intr_bit(int interrupt_source)
-{
-	return 0x1 << interrupt_source;
-}
-
-static unsigned int fifo_size(uint32_t fifo_size_bits)
-{
-	return fifo_size_bits & 0xfffff;
-}
+/*
+ * PCI BAR2 Register map (devpriv->mmio)
+ */
+#define FIRMWARE_REV_REG			0x00
+#define FEATURES_REG_PRESENT_BIT		(1 << 15)
+#define BOARD_CONTROL_REG			0x04
+#define BOARD_RESET_BIT				(1 << 0)
+#define TX_FIFO_RESET_BIT			(1 << 1)
+#define RX_FIFO_RESET_BIT			(1 << 2)
+#define TX_ENABLE_BIT				(1 << 4)
+#define RX_ENABLE_BIT				(1 << 5)
+#define DEMAND_DMA_DIRECTION_TX_BIT		(1 << 6)  /* ch 0 only */
+#define LINE_VALID_ON_STATUS_VALID_BIT		(1 << 7)
+#define START_TX_BIT				(1 << 8)
+#define CABLE_THROTTLE_ENABLE_BIT		(1 << 9)
+#define TEST_MODE_ENABLE_BIT			(1 << 31)
+#define BOARD_STATUS_REG			0x08
+#define COMMAND_LINE_STATUS_MASK		(0x7f << 0)
+#define TX_IN_PROGRESS_BIT			(1 << 7)
+#define TX_NOT_EMPTY_BIT			(1 << 8)
+#define TX_NOT_ALMOST_EMPTY_BIT			(1 << 9)
+#define TX_NOT_ALMOST_FULL_BIT			(1 << 10)
+#define TX_NOT_FULL_BIT				(1 << 11)
+#define RX_NOT_EMPTY_BIT			(1 << 12)
+#define RX_NOT_ALMOST_EMPTY_BIT			(1 << 13)
+#define RX_NOT_ALMOST_FULL_BIT			(1 << 14)
+#define RX_NOT_FULL_BIT				(1 << 15)
+#define BOARD_JUMPER0_INSTALLED_BIT		(1 << 16)
+#define BOARD_JUMPER1_INSTALLED_BIT		(1 << 17)
+#define TX_OVERRUN_BIT				(1 << 21)
+#define RX_UNDERRUN_BIT				(1 << 22)
+#define RX_OVERRUN_BIT				(1 << 23)
+#define TX_PROG_ALMOST_REG			0x0c
+#define RX_PROG_ALMOST_REG			0x10
+#define ALMOST_EMPTY_BITS(x)			(((x) & 0xffff) << 0)
+#define ALMOST_FULL_BITS(x)			(((x) & 0xff) << 16)
+#define FEATURES_REG				0x14
+#define FIFO_SIZE_PRESENT_BIT			(1 << 0)
+#define FIFO_WORDS_PRESENT_BIT			(1 << 1)
+#define LEVEL_EDGE_INTERRUPTS_PRESENT_BIT	(1 << 2)
+#define GPIO_SUPPORTED_BIT			(1 << 3)
+#define PLX_DMA_CH1_SUPPORTED_BIT		(1 << 4)
+#define OVERRUN_UNDERRUN_SUPPORTED_BIT		(1 << 5)
+#define FIFO_REG				0x18
+#define TX_STATUS_COUNT_REG			0x1c
+#define TX_LINE_VALID_COUNT_REG			0x20,
+#define TX_LINE_INVALID_COUNT_REG		0x24
+#define RX_STATUS_COUNT_REG			0x28
+#define RX_LINE_COUNT_REG			0x2c
+#define INTERRUPT_CONTROL_REG			0x30
+#define FRAME_VALID_START_INTR			(1 << 0)
+#define FRAME_VALID_END_INTR			(1 << 1)
+#define TX_FIFO_EMPTY_INTR			(1 << 8)
+#define TX_FIFO_ALMOST_EMPTY_INTR		(1 << 9)
+#define TX_FIFO_ALMOST_FULL_INTR		(1 << 10)
+#define TX_FIFO_FULL_INTR			(1 << 11)
+#define RX_EMPTY_INTR				(1 << 12)
+#define RX_ALMOST_EMPTY_INTR			(1 << 13)
+#define RX_ALMOST_FULL_INTR			(1 << 14)
+#define RX_FULL_INTR				(1 << 15)
+#define INTERRUPT_STATUS_REG			0x34
+#define TX_CLOCK_DIVIDER_REG			0x38
+#define TX_FIFO_SIZE_REG			0x40
+#define RX_FIFO_SIZE_REG			0x44
+#define FIFO_SIZE_MASK				(0xfffff << 0)
+#define TX_FIFO_WORDS_REG			0x48
+#define RX_FIFO_WORDS_REG			0x4c
+#define INTERRUPT_EDGE_LEVEL_REG		0x50
+#define INTERRUPT_POLARITY_REG			0x54
+
+#define TIMER_BASE				50	/* 20MHz master clock */
+#define DMA_BUFFER_SIZE				0x10000
+#define NUM_DMA_BUFFERS				4
+#define NUM_DMA_DESCRIPTORS			256
 
 struct hpdi_board {
 	const char *name;	/*  board name */
@@ -390,7 +355,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	       devpriv->mmio + BOARD_STATUS_REG);
 
 	/* enable interrupts */
-	writel(intr_bit(RX_FULL_INTR), devpriv->mmio + INTERRUPT_CONTROL_REG);
+	writel(RX_FULL_INTR, devpriv->mmio + INTERRUPT_CONTROL_REG);
 
 	writel(RX_ENABLE_BIT, devpriv->mmio + BOARD_CONTROL_REG);
 
@@ -541,18 +506,19 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 	struct hpdi_private *devpriv = dev->private;
 	uint32_t plx_intcsr_bits;
 
+	/* wait 10usec after reset before accessing fifos */
 	writel(BOARD_RESET_BIT, devpriv->mmio + BOARD_CONTROL_REG);
 	udelay(10);
 
-	writel(almost_empty_bits(32) | almost_full_bits(32),
+	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
 	       devpriv->mmio + RX_PROG_ALMOST_REG);
-	writel(almost_empty_bits(32) | almost_full_bits(32),
+	writel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),
 	       devpriv->mmio + TX_PROG_ALMOST_REG);
 
-	devpriv->tx_fifo_size = fifo_size(readl(devpriv->mmio +
-						  TX_FIFO_SIZE_REG));
-	devpriv->rx_fifo_size = fifo_size(readl(devpriv->mmio +
-						  RX_FIFO_SIZE_REG));
+	devpriv->tx_fifo_size = readl(devpriv->mmio + TX_FIFO_SIZE_REG) &
+				FIFO_SIZE_MASK;
+	devpriv->rx_fifo_size = readl(devpriv->mmio + RX_FIFO_SIZE_REG) &
+				FIFO_SIZE_MASK;
 
 	writel(0, devpriv->mmio + INTERRUPT_CONTROL_REG);
 

commit 4cbbacb285d82e49c4919e678417e708e5e38451
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:29 2014 -0700

    staging: comedi: gsc_hpdi: rename 'hpdi_iobase' in private data
    
    This member in the private data holds the ioremaped PCI BAR2 address
    which is the primary base address for the boards registers.
    
    For aesthetics, rename this member simply 'mmio'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index da9a00258d77..0770ad17d135 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -185,7 +185,7 @@ static const struct hpdi_board hpdi_boards[] = {
 
 struct hpdi_private {
 	void __iomem *plx9080_mmio;
-	void __iomem *hpdi_iobase;
+	void __iomem *mmio;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
 	/* physical addresses of dma buffers */
 	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
@@ -264,13 +264,12 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
 
-	hpdi_intr_status = readl(devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
-	hpdi_board_status = readl(devpriv->hpdi_iobase + BOARD_STATUS_REG);
+	hpdi_intr_status = readl(devpriv->mmio + INTERRUPT_STATUS_REG);
+	hpdi_board_status = readl(devpriv->mmio + BOARD_STATUS_REG);
+
+	if (hpdi_intr_status)
+		writel(hpdi_intr_status, devpriv->mmio + INTERRUPT_STATUS_REG);
 
-	if (hpdi_intr_status) {
-		writel(hpdi_intr_status,
-		       devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
-	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
@@ -334,8 +333,8 @@ static int gsc_hpdi_cancel(struct comedi_device *dev,
 {
 	struct hpdi_private *devpriv = dev->private;
 
-	writel(0, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
-	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	writel(0, devpriv->mmio + BOARD_CONTROL_REG);
+	writel(0, devpriv->mmio + INTERRUPT_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 
@@ -354,7 +353,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	if (s->io_bits)
 		return -EINVAL;
 
-	writel(RX_FIFO_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
+	writel(RX_FIFO_RESET_BIT, devpriv->mmio + BOARD_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 
@@ -388,13 +387,12 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 
 	/* clear over/under run status flags */
 	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-	       devpriv->hpdi_iobase + BOARD_STATUS_REG);
+	       devpriv->mmio + BOARD_STATUS_REG);
 
 	/* enable interrupts */
-	writel(intr_bit(RX_FULL_INTR),
-	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	writel(intr_bit(RX_FULL_INTR), devpriv->mmio + INTERRUPT_CONTROL_REG);
 
-	writel(RX_ENABLE_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
+	writel(RX_ENABLE_BIT, devpriv->mmio + BOARD_CONTROL_REG);
 
 	return 0;
 }
@@ -543,20 +541,20 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 	struct hpdi_private *devpriv = dev->private;
 	uint32_t plx_intcsr_bits;
 
-	writel(BOARD_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
+	writel(BOARD_RESET_BIT, devpriv->mmio + BOARD_CONTROL_REG);
 	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       devpriv->hpdi_iobase + RX_PROG_ALMOST_REG);
+	       devpriv->mmio + RX_PROG_ALMOST_REG);
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       devpriv->hpdi_iobase + TX_PROG_ALMOST_REG);
+	       devpriv->mmio + TX_PROG_ALMOST_REG);
 
-	devpriv->tx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
+	devpriv->tx_fifo_size = fifo_size(readl(devpriv->mmio +
 						  TX_FIFO_SIZE_REG));
-	devpriv->rx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
+	devpriv->rx_fifo_size = fifo_size(readl(devpriv->mmio +
 						  RX_FIFO_SIZE_REG));
 
-	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	writel(0, devpriv->mmio + INTERRUPT_CONTROL_REG);
 
 	/*  enable interrupts */
 	plx_intcsr_bits =
@@ -647,8 +645,8 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	pci_set_master(pcidev);
 
 	devpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);
-	devpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);
-	if (!devpriv->plx9080_mmio || !devpriv->hpdi_iobase) {
+	devpriv->mmio = pci_ioremap_bar(pcidev, 2);
+	if (!devpriv->plx9080_mmio || !devpriv->mmio) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -722,8 +720,8 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 			writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
 			iounmap(devpriv->plx9080_mmio);
 		}
-		if (devpriv->hpdi_iobase)
-			iounmap(devpriv->hpdi_iobase);
+		if (devpriv->mmio)
+			iounmap(devpriv->mmio);
 		/*  free pci dma buffers */
 		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 			if (devpriv->dio_buffer[i])

commit 139740370c5c76cba33785675ef58d69a569142d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:28 2014 -0700

    staging: comedi: gsc_hpdi: rename 'plx9080_iobase' in private data
    
    Rename this member to fix two checkpatch.pl warnings about lines > 80
    characters.
    
    Also remove the unnecessary comment.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b5dd2921a164..da9a00258d77 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -184,8 +184,7 @@ static const struct hpdi_board hpdi_boards[] = {
 };
 
 struct hpdi_private {
-	/*  base addresses (ioremapped) */
-	void __iomem *plx9080_iobase;
+	void __iomem *plx9080_mmio;
 	void __iomem *hpdi_iobase;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
 	/* physical addresses of dma buffers */
@@ -219,9 +218,9 @@ static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 	unsigned int next;
 
 	if (channel)
-		next = readl(devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
+		next = readl(devpriv->plx9080_mmio + PLX_DMA1_PCI_ADDRESS_REG);
 	else
-		next = readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+		next = readl(devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);
 
 	idx = devpriv->dma_desc_index;
 	start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);
@@ -261,7 +260,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	plx_status = readl(devpriv->plx9080_mmio + PLX_INTRCS_REG);
 	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
 
@@ -274,10 +273,10 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+		       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
 
 		if (dma0_status & PLX_DMA_EN_BIT)
 			gsc_hpdi_drain_dma(dev, 0);
@@ -286,17 +285,17 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
+	dma1_status = readb(devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_mmio + PLX_DMA1_CS_REG);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
-		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
-		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
+		plx_bits = readl(devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
+		writel(plx_bits, devpriv->plx9080_mmio + PLX_DBR_OUT_REG);
 	}
 
 	if (hpdi_board_status & RX_OVERRUN_BIT) {
@@ -325,7 +324,7 @@ static void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
+	plx9080_abort_dma(devpriv->plx9080_mmio, channel);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
@@ -367,19 +366,19 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	 * occasionally cause problems with transfer of first dma
 	 * block.  Initializing them to zero seems to fix the problem.
 	 */
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_DMA0_TRANSFER_SIZE_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_DMA0_LOCAL_ADDRESS_REG);
 
 	/* give location of first dma descriptor */
 	bits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
 	       PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
-	writel(bits, devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	writel(bits, devpriv->plx9080_mmio + PLX_DMA0_DESCRIPTOR_REG);
 
 	/* enable dma transfer */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-	       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	       devpriv->plx9080_mmio + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
@@ -563,7 +562,7 @@ static int gsc_hpdi_init(struct comedi_device *dev)
 	plx_intcsr_bits =
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E;
-	writel(plx_intcsr_bits, devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	writel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_INTRCS_REG);
 
 	return 0;
 }
@@ -572,16 +571,16 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
 	uint32_t bits;
-	void __iomem *plx_iobase = devpriv->plx9080_iobase;
+	void __iomem *plx_iobase = devpriv->plx9080_mmio;
 
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
 #else
 	bits = 0;
 #endif
-	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
+	writel(bits, devpriv->plx9080_mmio + PLX_BIGEND_REG);
 
-	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
+	writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 	gsc_hpdi_abort_dma(dev, 1);
@@ -647,9 +646,9 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 		return retval;
 	pci_set_master(pcidev);
 
-	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
+	devpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);
 	devpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);
-	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
+	if (!devpriv->plx9080_mmio || !devpriv->hpdi_iobase) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
@@ -719,9 +718,9 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
-		if (devpriv->plx9080_iobase) {
-			writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
-			iounmap(devpriv->plx9080_iobase);
+		if (devpriv->plx9080_mmio) {
+			writel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);
+			iounmap(devpriv->plx9080_mmio);
 		}
 		if (devpriv->hpdi_iobase)
 			iounmap(devpriv->hpdi_iobase);

commit d213563198859e48d8f0f0db20f815ba9c6de4ce
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:27 2014 -0700

    staging: comedi: gsc_hpdi: tidy up gsc_hpdi_drain_dma()
    
    Refactor this function to clarify the loop that reads all the full
    buffers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 1686c1104f61..b5dd2921a164 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -210,42 +210,38 @@ struct hpdi_private {
 static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 {
 	struct hpdi_private *devpriv = dev->private;
-	struct comedi_async *async = dev->read_subdev->async;
-	uint32_t next_transfer_addr;
-	int j;
-	int num_samples = 0;
-	void __iomem *pci_addr_reg;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int idx;
+	unsigned int start;
+	unsigned int desc;
+	unsigned int size;
+	unsigned int next;
 
 	if (channel)
-		pci_addr_reg =
-		    devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		next = readl(devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);
 	else
-		pci_addr_reg =
-		    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
-
-	/*  loop until we have read all the full buffers */
-	j = 0;
-	for (next_transfer_addr = readl(pci_addr_reg);
-	     (next_transfer_addr <
-	      le32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].
-			  pci_start_addr)
-	      || next_transfer_addr >=
-	      le32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].
-			  pci_start_addr) + devpriv->block_size)
-	     && j < devpriv->num_dma_descriptors; j++) {
-		/*  transfer data from dma buffer to comedi buffer */
-		num_samples = devpriv->block_size / sizeof(uint32_t);
-		if (async->cmd.stop_src == TRIG_COUNT) {
-			if (num_samples > devpriv->dio_count)
-				num_samples = devpriv->dio_count;
-			devpriv->dio_count -= num_samples;
+		next = readl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+
+	idx = devpriv->dma_desc_index;
+	start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);
+	/* loop until we have read all the full buffers */
+	for (desc = 0; (next < start || next >= start + devpriv->block_size) &&
+	     desc < devpriv->num_dma_descriptors; desc++) {
+		/* transfer data from dma buffer to comedi buffer */
+		size = devpriv->block_size / sizeof(uint32_t);
+		if (cmd->stop_src == TRIG_COUNT) {
+			if (size > devpriv->dio_count)
+				size = devpriv->dio_count;
+			devpriv->dio_count -= size;
 		}
-		cfc_write_array_to_buffer(dev->read_subdev,
-					  devpriv->desc_dio_buffer[devpriv->
-								     dma_desc_index],
-					  num_samples * sizeof(uint32_t));
-		devpriv->dma_desc_index++;
-		devpriv->dma_desc_index %= devpriv->num_dma_descriptors;
+		cfc_write_array_to_buffer(s, devpriv->desc_dio_buffer[idx],
+					  size * sizeof(uint32_t));
+		idx++;
+		idx %= devpriv->num_dma_descriptors;
+		start = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);
+
+		devpriv->dma_desc_index = idx;
 	}
 	/*  XXX check for buffer overrun somehow */
 }

commit 2a5a3d0c8f4889cae30ef4e3e3041c21bec856b8
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:26 2014 -0700

    staging: comedi: gsc_hpdi: remove 'volatile' from the private data members
    
    As reported by checkpatch.pl, the private data members do not need
    the volatile tag. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index aaf6283e5aaf..1686c1104f61 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -199,12 +199,12 @@ struct hpdi_private {
 	/* pointer to start of buffers indexed by descriptor */
 	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];
 	/* index of the dma descriptor that is currently being used */
-	volatile unsigned int dma_desc_index;
+	unsigned int dma_desc_index;
 	unsigned int tx_fifo_size;
 	unsigned int rx_fifo_size;
-	volatile unsigned long dio_count;
+	unsigned long dio_count;
 	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
-	volatile unsigned int block_size;
+	unsigned int block_size;
 };
 
 static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)

commit ab5cf493170e2d7d0f4a74467009d55e63cd1a71
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:25 2014 -0700

    staging: comedi: gsc_hpdi: remove hpdi_writel()
    
    This helper function is used to OR bits with a software copy of a
    register value then writel() the new value to the register. The
    software copies are never updated in the driver so they are always
    0 due to the kzalloc.
    
    Remove the unnecessary 'bits' from the private data and replace
    the hpdi_writel() calls with writel().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 3762510933dc..aaf6283e5aaf 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -203,21 +203,10 @@ struct hpdi_private {
 	unsigned int tx_fifo_size;
 	unsigned int rx_fifo_size;
 	volatile unsigned long dio_count;
-	/* software copies of values written to hpdi registers */
-	volatile uint32_t bits[24];
 	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
 	volatile unsigned int block_size;
 };
 
-static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
-			       unsigned int offset)
-{
-	struct hpdi_private *devpriv = dev->private;
-
-	writel(bits | devpriv->bits[offset / sizeof(uint32_t)],
-	       devpriv->hpdi_iobase + offset);
-}
-
 static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -350,8 +339,7 @@ static int gsc_hpdi_cancel(struct comedi_device *dev,
 {
 	struct hpdi_private *devpriv = dev->private;
 
-	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
-
+	writel(0, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
 	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
@@ -371,7 +359,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	if (s->io_bits)
 		return -EINVAL;
 
-	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
+	writel(RX_FIFO_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 
@@ -411,7 +399,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	writel(intr_bit(RX_FULL_INTR),
 	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
-	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
+	writel(RX_ENABLE_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
 
 	return 0;
 }

commit 42ea78126c3f6c7a51fdf2c970e1d67f0a5faa19
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:24 2014 -0700

    staging: comedi: gsc_hpdi: remove disable_plx_interrupts()
    
    This helper function is just a simple writel(). Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index d9b1491b130b..3762510933dc 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -209,13 +209,6 @@ struct hpdi_private {
 	volatile unsigned int block_size;
 };
 
-static void disable_plx_interrupts(struct comedi_device *dev)
-{
-	struct hpdi_private *devpriv = dev->private;
-
-	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
-}
-
 static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 			       unsigned int offset)
 {
@@ -604,7 +597,7 @@ static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 #endif
 	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
 
-	disable_plx_interrupts(dev);
+	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 
 	gsc_hpdi_abort_dma(dev, 0);
 	gsc_hpdi_abort_dma(dev, 1);
@@ -743,7 +736,7 @@ static void gsc_hpdi_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->plx9080_iobase) {
-			disable_plx_interrupts(dev);
+			writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 			iounmap(devpriv->plx9080_iobase);
 		}
 		if (devpriv->hpdi_iobase)

commit 63da0d087c9e1d3ba785470a234ba7be6f1c78b3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:23 2014 -0700

    staging: comedi: gsc_hpdi: rename init_hpdi()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 177d7823fa91..d9b1491b130b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -562,7 +562,7 @@ static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int init_hpdi(struct comedi_device *dev)
+static int gsc_hpdi_init(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
 	uint32_t plx_intcsr_bits;
@@ -730,7 +730,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	s->do_cmdtest	= gsc_hpdi_cmd_test;
 	s->cancel	= gsc_hpdi_cancel;
 
-	return init_hpdi(dev);
+	return gsc_hpdi_init(dev);
 }
 
 static void gsc_hpdi_detach(struct comedi_device *dev)

commit 201a81437cf13a2f7bf2fc13786409ecdf1771ac
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:22 2014 -0700

    staging: comedi: gsc_hpdi: rename init_plx9080()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b0989814c4ff..177d7823fa91 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -591,7 +591,7 @@ static int init_hpdi(struct comedi_device *dev)
 	return 0;
 }
 
-static void init_plx9080(struct comedi_device *dev)
+static void gsc_hpdi_init_plx9080(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
 	uint32_t bits;
@@ -677,7 +677,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	init_plx9080(dev);
+	gsc_hpdi_init_plx9080(dev);
 
 	/*  get irq */
 	if (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,

commit 6a23558b342531947cb20af7c9802beb3fe6343e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:21 2014 -0700

    staging: comedi: gsc_hpdi: rename hpdi_find_board()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 364c91d8ee43..b0989814c4ff 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -631,7 +631,7 @@ static void init_plx9080(struct comedi_device *dev)
 	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 }
 
-static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
+static const struct hpdi_board *gsc_hpdi_find_board(struct pci_dev *pcidev)
 {
 	unsigned int i;
 
@@ -652,7 +652,7 @@ static int gsc_hpdi_auto_attach(struct comedi_device *dev,
 	int i;
 	int retval;
 
-	thisboard = hpdi_find_board(pcidev);
+	thisboard = gsc_hpdi_find_board(pcidev);
 	if (!thisboard) {
 		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
 			pci_name(pcidev));

commit 1335cee5d2b4d29f7ba0ef0fc1f112a159c184d7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:20 2014 -0700

    staging: comedi: gsc_hpdi: rename the (*auto_attach) and (*detach) functions
    
    For aesthetics, rename these functions so they have namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 400f5ec47a6c..364c91d8ee43 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -642,8 +642,8 @@ static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
 	return NULL;
 }
 
-static int hpdi_auto_attach(struct comedi_device *dev,
-			    unsigned long context_unused)
+static int gsc_hpdi_auto_attach(struct comedi_device *dev,
+				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct hpdi_board *thisboard;
@@ -733,7 +733,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	return init_hpdi(dev);
 }
 
-static void hpdi_detach(struct comedi_device *dev)
+static void gsc_hpdi_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct hpdi_private *devpriv = dev->private;
@@ -771,8 +771,8 @@ static void hpdi_detach(struct comedi_device *dev)
 static struct comedi_driver gsc_hpdi_driver = {
 	.driver_name	= "gsc_hpdi",
 	.module		= THIS_MODULE,
-	.auto_attach	= hpdi_auto_attach,
-	.detach		= hpdi_detach,
+	.auto_attach	= gsc_hpdi_auto_attach,
+	.detach		= gsc_hpdi_detach,
 };
 
 static int gsc_hpdi_pci_probe(struct pci_dev *dev,

commit 9fe635cd864fb6196e11d6e0e172e1b5504de4ac
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:19 2014 -0700

    staging: comedi: gsc_hpdi: rename drain_dma_buffers()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f1af16abf870..400f5ec47a6c 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -225,7 +225,7 @@ static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 	       devpriv->hpdi_iobase + offset);
 }
 
-static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
+static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)
 {
 	struct hpdi_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
@@ -302,7 +302,7 @@ static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 
 		if (dma0_status & PLX_DMA_EN_BIT)
-			drain_dma_buffers(dev, 0);
+			gsc_hpdi_drain_dma(dev, 0);
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 

commit 3521d454d27b1ceadefa407692fdbfa38c329a72
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:18 2014 -0700

    staging: comedi: gsc_hpdi: rename handle_interrupt()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f4cfac0e445f..f1af16abf870 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -268,7 +268,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	/*  XXX check for buffer overrun somehow */
 }
 
-static irqreturn_t handle_interrupt(int irq, void *d)
+static irqreturn_t gsc_hpdi_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct hpdi_private *devpriv = dev->private;
@@ -680,7 +680,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	init_plx9080(dev);
 
 	/*  get irq */
-	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+	if (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,
 			dev->board_name, dev)) {
 		dev_warn(dev->class_dev,
 			 "unable to allocate irq %u\n", pcidev->irq);

commit 9cbf6697379bd22f427a3fc708a00ae6a86a7577
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:17 2014 -0700

    staging: comedi: gsc_hpdi: rename abort_dma()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Also, remove the unnecessary forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 1fc65b147731..f4cfac0e445f 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,8 +52,6 @@
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-static void abort_dma(struct comedi_device *dev, unsigned int channel);
-
 #define TIMER_BASE 50		/*  20MHz master clock */
 #define DMA_BUFFER_SIZE 0x10000
 #define NUM_DMA_BUFFERS 4
@@ -341,7 +339,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void abort_dma(struct comedi_device *dev, unsigned int channel)
+static void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)
 {
 	struct hpdi_private *devpriv = dev->private;
 	unsigned long flags;
@@ -363,7 +361,7 @@ static int gsc_hpdi_cancel(struct comedi_device *dev,
 
 	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
-	abort_dma(dev, 0);
+	gsc_hpdi_abort_dma(dev, 0);
 
 	return 0;
 }
@@ -382,7 +380,7 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 
 	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
 
-	abort_dma(dev, 0);
+	gsc_hpdi_abort_dma(dev, 0);
 
 	devpriv->dma_desc_index = 0;
 
@@ -608,8 +606,8 @@ static void init_plx9080(struct comedi_device *dev)
 
 	disable_plx_interrupts(dev);
 
-	abort_dma(dev, 0);
-	abort_dma(dev, 1);
+	gsc_hpdi_abort_dma(dev, 0);
+	gsc_hpdi_abort_dma(dev, 1);
 
 	/*  configure dma0 mode */
 	bits = 0;

commit 3547473931035c29e80499afc46d037ea26b75ef
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:16 2014 -0700

    staging: comedi: gsc_hpdi: rename hpdi_cancel()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index e3bb921ed253..1fc65b147731 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -354,7 +354,8 @@ static void abort_dma(struct comedi_device *dev, unsigned int channel)
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int gsc_hpdi_cancel(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct hpdi_private *devpriv = dev->private;
 
@@ -729,7 +730,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	s->insn_config	= gsc_hpdi_dio_insn_config;
 	s->do_cmd	= gsc_hpdi_cmd;
 	s->do_cmdtest	= gsc_hpdi_cmd_test;
-	s->cancel	= hpdi_cancel;
+	s->cancel	= gsc_hpdi_cancel;
 
 	return init_hpdi(dev);
 }

commit 6b0cca01ace234fcdac8388bcb48e5abebc2992b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:15 2014 -0700

    staging: comedi: gsc_hpdi: tidy up hpdi_cmd_test()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver and move it so that it is not in the middle of the
    interrupt support code.
    
    Absorb the di_cmd_test() helper and tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index c7c20f8ef8a6..e3bb921ed253 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -218,87 +218,6 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-		       struct comedi_cmd *cmd)
-{
-	int err = 0;
-	int i;
-
-	/* Step 1 : check if triggers are trivially valid */
-
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
-
-	if (err)
-		return 1;
-
-	/* Step 2a : make sure trigger sources are unique */
-
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
-
-	/* Step 2b : and mutually compatible */
-
-	if (err)
-		return 2;
-
-	/* Step 3: check if arguments are trivially valid */
-
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 32;
-		err |= -EINVAL;
-	}
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
-		break;
-	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	if (err)
-		return 4;
-
-	if (!cmd->chanlist)
-		return 0;
-
-	for (i = 1; i < cmd->chanlist_len; i++) {
-		if (CR_CHAN(cmd->chanlist[i]) != i) {
-			/*  XXX could support 8 or 16 channels */
-			comedi_error(dev,
-				     "chanlist must be ch 0 to 31 in order");
-			err++;
-			break;
-		}
-	}
-
-	if (err)
-		return 5;
-
-	return 0;
-}
-
-static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_cmd *cmd)
-{
-	if (s->io_bits)
-		return -EINVAL;
-	else
-		return di_cmd_test(dev, s, cmd);
-}
-
 static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 			       unsigned int offset)
 {
@@ -505,6 +424,76 @@ static int gsc_hpdi_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static int gsc_hpdi_cmd_test(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd)
+{
+	int err = 0;
+	int i;
+
+	if (s->io_bits)
+		return -EINVAL;
+
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+
+	if (err)
+		return 1;
+
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	if (!cmd->chanlist_len || !cmd->chanlist) {
+		cmd->chanlist_len = 32;
+		err |= -EINVAL;
+	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (err)
+		return 4;
+
+	/* step 5: complain about special chanlist considerations */
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		if (CR_CHAN(cmd->chanlist[i]) != i) {
+			/*  XXX could support 8 or 16 channels */
+			dev_err(dev->class_dev,
+				"chanlist must be ch 0 to 31 in order");
+			err |= -EINVAL;
+			break;
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+
+}
+
 /* setup dma descriptors so a link completes every 'len' bytes */
 static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
 					  unsigned int len)
@@ -739,7 +728,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	s->range_table	= &range_digital;
 	s->insn_config	= gsc_hpdi_dio_insn_config;
 	s->do_cmd	= gsc_hpdi_cmd;
-	s->do_cmdtest	= hpdi_cmd_test;
+	s->do_cmdtest	= gsc_hpdi_cmd_test;
 	s->cancel	= hpdi_cancel;
 
 	return init_hpdi(dev);

commit 627e52f741718fed58148e87f956366f076185b6
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:14 2014 -0700

    staging: comedi: gsc_hpdi: tidy up hpdi_cmd()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver and move it so that it is not in the middle of the
    interrupt support code.
    
    Absorb the di_cmd() helper and tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b68bc9171c31..c7c20f8ef8a6 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -308,65 +308,6 @@ static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 	       devpriv->hpdi_iobase + offset);
 }
 
-static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct hpdi_private *devpriv = dev->private;
-	uint32_t bits;
-	unsigned long flags;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-
-	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
-
-	abort_dma(dev, 0);
-
-	devpriv->dma_desc_index = 0;
-
-	/* These register are supposedly unused during chained dma,
-	 * but I have found that left over values from last operation
-	 * occasionally cause problems with transfer of first dma
-	 * block.  Initializing them to zero seems to fix the problem. */
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
-	writel(0, devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
-	/*  give location of first dma descriptor */
-	bits =
-	    devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
-	    PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
-	writel(bits, devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
-
-	/*  spinlock for plx dma control/status reg */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	/*  enable dma transfer */
-	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-	       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->dio_count = cmd->stop_arg;
-	else
-		devpriv->dio_count = 1;
-
-	/*  clear over/under run status flags */
-	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-	       devpriv->hpdi_iobase + BOARD_STATUS_REG);
-	/*  enable interrupts */
-	writel(intr_bit(RX_FULL_INTR),
-	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
-
-	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
-
-	return 0;
-}
-
-static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	if (s->io_bits)
-		return -EINVAL;
-	else
-		return di_cmd(dev, s);
-}
-
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -507,6 +448,63 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int gsc_hpdi_cmd(struct comedi_device *dev,
+			struct comedi_subdevice *s)
+{
+	struct hpdi_private *devpriv = dev->private;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned long flags;
+	uint32_t bits;
+
+	if (s->io_bits)
+		return -EINVAL;
+
+	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
+
+	abort_dma(dev, 0);
+
+	devpriv->dma_desc_index = 0;
+
+	/*
+	 * These register are supposedly unused during chained dma,
+	 * but I have found that left over values from last operation
+	 * occasionally cause problems with transfer of first dma
+	 * block.  Initializing them to zero seems to fix the problem.
+	 */
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+
+	/* give location of first dma descriptor */
+	bits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
+	       PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
+	writel(bits, devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+
+	/* enable dma transfer */
+	spin_lock_irqsave(&dev->spinlock, flags);
+	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
+	       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->dio_count = cmd->stop_arg;
+	else
+		devpriv->dio_count = 1;
+
+	/* clear over/under run status flags */
+	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
+	       devpriv->hpdi_iobase + BOARD_STATUS_REG);
+
+	/* enable interrupts */
+	writel(intr_bit(RX_FULL_INTR),
+	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
+
+	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
+
+	return 0;
+}
+
 /* setup dma descriptors so a link completes every 'len' bytes */
 static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
 					  unsigned int len)
@@ -740,7 +738,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
 	s->insn_config	= gsc_hpdi_dio_insn_config;
-	s->do_cmd	= hpdi_cmd;
+	s->do_cmd	= gsc_hpdi_cmd;
 	s->do_cmdtest	= hpdi_cmd_test;
 	s->cancel	= hpdi_cancel;
 

commit 66951e05886dcaedd5efbf4fce7e29df44cca62f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:13 2014 -0700

    staging: comedi: gsc_hpdi: tidy up setup_dma_descriptors()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver and move it so that it is not in the middle of the
    async command support code.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index ed24a7b07998..b68bc9171c31 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -218,57 +218,6 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-/* setup dma descriptors so a link completes every 'transfer_size' bytes */
-static int setup_dma_descriptors(struct comedi_device *dev,
-				 unsigned int transfer_size)
-{
-	struct hpdi_private *devpriv = dev->private;
-	unsigned int buffer_index, buffer_offset;
-	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-	    PLX_XFER_LOCAL_TO_PCI;
-	unsigned int i;
-
-	if (transfer_size > DMA_BUFFER_SIZE)
-		transfer_size = DMA_BUFFER_SIZE;
-	transfer_size -= transfer_size % sizeof(uint32_t);
-	if (transfer_size == 0)
-		return -1;
-
-	buffer_offset = 0;
-	buffer_index = 0;
-	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
-	     buffer_index < NUM_DMA_BUFFERS; i++) {
-		devpriv->dma_desc[i].pci_start_addr =
-		    cpu_to_le32(devpriv->dio_buffer_phys_addr[buffer_index] +
-				buffer_offset);
-		devpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
-		devpriv->dma_desc[i].transfer_size =
-		    cpu_to_le32(transfer_size);
-		devpriv->dma_desc[i].next =
-		    cpu_to_le32((devpriv->dma_desc_phys_addr + (i +
-								  1) *
-				 sizeof(devpriv->dma_desc[0])) | next_bits);
-
-		devpriv->desc_dio_buffer[i] =
-		    devpriv->dio_buffer[buffer_index] +
-		    (buffer_offset / sizeof(uint32_t));
-
-		buffer_offset += transfer_size;
-		if (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {
-			buffer_offset = 0;
-			buffer_index++;
-		}
-	}
-	devpriv->num_dma_descriptors = i;
-	/*  fix last descriptor to point back to first */
-	devpriv->dma_desc[i - 1].next =
-	    cpu_to_le32(devpriv->dma_desc_phys_addr | next_bits);
-
-	devpriv->block_size = transfer_size;
-
-	return transfer_size;
-}
-
 static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		       struct comedi_cmd *cmd)
 {
@@ -558,6 +507,50 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+/* setup dma descriptors so a link completes every 'len' bytes */
+static int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,
+					  unsigned int len)
+{
+	struct hpdi_private *devpriv = dev->private;
+	dma_addr_t phys_addr = devpriv->dma_desc_phys_addr;
+	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+			     PLX_XFER_LOCAL_TO_PCI;
+	unsigned int offset = 0;
+	unsigned int idx = 0;
+	unsigned int i;
+
+	if (len > DMA_BUFFER_SIZE)
+		len = DMA_BUFFER_SIZE;
+	len -= len % sizeof(uint32_t);
+	if (len == 0)
+		return -EINVAL;
+
+	for (i = 0; i < NUM_DMA_DESCRIPTORS && idx < NUM_DMA_BUFFERS; i++) {
+		devpriv->dma_desc[i].pci_start_addr =
+		    cpu_to_le32(devpriv->dio_buffer_phys_addr[idx] + offset);
+		devpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
+		devpriv->dma_desc[i].transfer_size = cpu_to_le32(len);
+		devpriv->dma_desc[i].next = cpu_to_le32((phys_addr +
+			(i + 1) * sizeof(devpriv->dma_desc[0])) | next_bits);
+
+		devpriv->desc_dio_buffer[i] = devpriv->dio_buffer[idx] +
+					      (offset / sizeof(uint32_t));
+
+		offset += len;
+		if (len + offset > DMA_BUFFER_SIZE) {
+			offset = 0;
+			idx++;
+		}
+	}
+	devpriv->num_dma_descriptors = i;
+	/* fix last descriptor to point back to first */
+	devpriv->dma_desc[i - 1].next = cpu_to_le32(phys_addr | next_bits);
+
+	devpriv->block_size = len;
+
+	return len;
+}
+
 static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    struct comedi_insn *insn,
@@ -567,7 +560,7 @@ static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
 
 	switch (data[0]) {
 	case INSN_CONFIG_BLOCK_SIZE:
-		ret = setup_dma_descriptors(dev, data[1]);
+		ret = gsc_hpdi_setup_dma_descriptors(dev, data[1]);
 		if (ret)
 			return ret;
 
@@ -728,7 +721,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	retval = setup_dma_descriptors(dev, 0x1000);
+	retval = gsc_hpdi_setup_dma_descriptors(dev, 0x1000);
 	if (retval < 0)
 		return retval;
 

commit b0360a989d4385132a4d6639a2c9df9a837ac86a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:12 2014 -0700

    staging: comedi: gsc_hpdi: tidy up dio_config_insn()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver and move it so that it is not in the middle of the
    async command support code.
    
    Absorb the dio_config_block_size() helper function and remove the
    forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 7a07c1f764a1..ed24a7b07998 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -53,7 +53,6 @@
 #include "comedi_fc.h"
 
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
-static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 
 #define TIMER_BASE 50		/*  20MHz master clock */
 #define DMA_BUFFER_SIZE 0x10000
@@ -212,26 +211,6 @@ struct hpdi_private {
 	volatile unsigned int block_size;
 };
 
-static int dio_config_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	int ret;
-
-	switch (data[0]) {
-	case INSN_CONFIG_BLOCK_SIZE:
-		return dio_config_block_size(dev, data);
-	default:
-		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
-		if (ret)
-			return ret;
-		break;
-	}
-
-	return insn->n;
-}
-
 static void disable_plx_interrupts(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -290,22 +269,6 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 	return transfer_size;
 }
 
-static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)
-{
-	unsigned int requested_block_size;
-	int retval;
-
-	requested_block_size = data[1];
-
-	retval = setup_dma_descriptors(dev, requested_block_size);
-	if (retval < 0)
-		return retval;
-
-	data[1] = retval;
-
-	return 2;
-}
-
 static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		       struct comedi_cmd *cmd)
 {
@@ -595,6 +558,31 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int gsc_hpdi_dio_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
+{
+	int ret;
+
+	switch (data[0]) {
+	case INSN_CONFIG_BLOCK_SIZE:
+		ret = setup_dma_descriptors(dev, data[1]);
+		if (ret)
+			return ret;
+
+		data[1] = ret;
+		break;
+	default:
+		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
+		if (ret)
+			return ret;
+		break;
+	}
+
+	return insn->n;
+}
+
 static int init_hpdi(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -758,7 +746,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	s->len_chanlist	= 32;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_config	= dio_config_insn;
+	s->insn_config	= gsc_hpdi_dio_insn_config;
 	s->do_cmd	= hpdi_cmd;
 	s->do_cmdtest	= hpdi_cmd_test;
 	s->cancel	= hpdi_cancel;

commit d987d372eb552862eba21b066978c7c6949b6fe8
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:11 2014 -0700

    staging: comedi: gsc_hpdi: move the (*auto_attach) helper functions
    
    For aesthetics, move a couple helper functions that are only called
    by the (*auto_attach) closer to that function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 26e5bdf3f424..7a07c1f764a1 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -239,76 +239,6 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-/* initialize plx9080 chip */
-static void init_plx9080(struct comedi_device *dev)
-{
-	struct hpdi_private *devpriv = dev->private;
-	uint32_t bits;
-	void __iomem *plx_iobase = devpriv->plx9080_iobase;
-
-#ifdef __BIG_ENDIAN
-	bits = BIGEND_DMA0 | BIGEND_DMA1;
-#else
-	bits = 0;
-#endif
-	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
-
-	disable_plx_interrupts(dev);
-
-	abort_dma(dev, 0);
-	abort_dma(dev, 1);
-
-	/*  configure dma0 mode */
-	bits = 0;
-	/*  enable ready input */
-	bits |= PLX_DMA_EN_READYIN_BIT;
-	/*  enable dma chaining */
-	bits |= PLX_EN_CHAIN_BIT;
-	/*  enable interrupt on dma done
-	 *  (probably don't need this, since chain never finishes) */
-	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	/*  don't increment local address during transfers
-	 *  (we are transferring from a fixed fifo register) */
-	bits |= PLX_LOCAL_ADDR_CONST_BIT;
-	/*  route dma interrupt to pci bus */
-	bits |= PLX_DMA_INTR_PCI_BIT;
-	/*  enable demand mode */
-	bits |= PLX_DEMAND_MODE_BIT;
-	/*  enable local burst mode */
-	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
-	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
-	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
-}
-
-static int init_hpdi(struct comedi_device *dev)
-{
-	struct hpdi_private *devpriv = dev->private;
-	uint32_t plx_intcsr_bits;
-
-	writel(BOARD_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
-	udelay(10);
-
-	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       devpriv->hpdi_iobase + RX_PROG_ALMOST_REG);
-	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       devpriv->hpdi_iobase + TX_PROG_ALMOST_REG);
-
-	devpriv->tx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
-						  TX_FIFO_SIZE_REG));
-	devpriv->rx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
-						  RX_FIFO_SIZE_REG));
-
-	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
-
-	/*  enable interrupts */
-	plx_intcsr_bits =
-	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-	    ICS_DMA0_E;
-	writel(plx_intcsr_bits, devpriv->plx9080_iobase + PLX_INTRCS_REG);
-
-	return 0;
-}
-
 /* setup dma descriptors so a link completes every 'transfer_size' bytes */
 static int setup_dma_descriptors(struct comedi_device *dev,
 				 unsigned int transfer_size)
@@ -360,17 +290,6 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 	return transfer_size;
 }
 
-static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)
-		if (pcidev->device == hpdi_boards[i].device_id &&
-		    pcidev->subsystem_device == hpdi_boards[i].subdevice_id)
-			return &hpdi_boards[i];
-	return NULL;
-}
-
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
 	unsigned int requested_block_size;
@@ -676,8 +595,88 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int init_hpdi(struct comedi_device *dev)
+{
+	struct hpdi_private *devpriv = dev->private;
+	uint32_t plx_intcsr_bits;
+
+	writel(BOARD_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
+	udelay(10);
+
+	writel(almost_empty_bits(32) | almost_full_bits(32),
+	       devpriv->hpdi_iobase + RX_PROG_ALMOST_REG);
+	writel(almost_empty_bits(32) | almost_full_bits(32),
+	       devpriv->hpdi_iobase + TX_PROG_ALMOST_REG);
+
+	devpriv->tx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
+						  TX_FIFO_SIZE_REG));
+	devpriv->rx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
+						  RX_FIFO_SIZE_REG));
+
+	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
+
+	/*  enable interrupts */
+	plx_intcsr_bits =
+	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+	    ICS_DMA0_E;
+	writel(plx_intcsr_bits, devpriv->plx9080_iobase + PLX_INTRCS_REG);
+
+	return 0;
+}
+
+static void init_plx9080(struct comedi_device *dev)
+{
+	struct hpdi_private *devpriv = dev->private;
+	uint32_t bits;
+	void __iomem *plx_iobase = devpriv->plx9080_iobase;
+
+#ifdef __BIG_ENDIAN
+	bits = BIGEND_DMA0 | BIGEND_DMA1;
+#else
+	bits = 0;
+#endif
+	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
+
+	disable_plx_interrupts(dev);
+
+	abort_dma(dev, 0);
+	abort_dma(dev, 1);
+
+	/*  configure dma0 mode */
+	bits = 0;
+	/*  enable ready input */
+	bits |= PLX_DMA_EN_READYIN_BIT;
+	/*  enable dma chaining */
+	bits |= PLX_EN_CHAIN_BIT;
+	/*  enable interrupt on dma done
+	 *  (probably don't need this, since chain never finishes) */
+	bits |= PLX_EN_DMA_DONE_INTR_BIT;
+	/*  don't increment local address during transfers
+	 *  (we are transferring from a fixed fifo register) */
+	bits |= PLX_LOCAL_ADDR_CONST_BIT;
+	/*  route dma interrupt to pci bus */
+	bits |= PLX_DMA_INTR_PCI_BIT;
+	/*  enable demand mode */
+	bits |= PLX_DEMAND_MODE_BIT;
+	/*  enable local burst mode */
+	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
+	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
+	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
+}
+
+static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)
+		if (pcidev->device == hpdi_boards[i].device_id &&
+		    pcidev->subsystem_device == hpdi_boards[i].subdevice_id)
+			return &hpdi_boards[i];
+	return NULL;
+}
+
 static int hpdi_auto_attach(struct comedi_device *dev,
-				      unsigned long context_unused)
+			    unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct hpdi_board *thisboard;

commit 7de0b0dfac19ec128283884b1faa45d69097faa1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:10 2014 -0700

    staging: comedi: gsc_hpdi: absorb setup_subdevices()
    
    This function is only called by the (*auto_attach). Absorb it into that
    function to clarify the attach and remove the need for some of the forward
    declarations.
    
    For aesthetics, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 28fcda762e68..26e5bdf3f424 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -53,10 +53,6 @@
 #include "comedi_fc.h"
 
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
-static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_cmd *cmd);
-static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 
 #define TIMER_BASE 50		/*  20MHz master clock */
@@ -284,36 +280,6 @@ static void init_plx9080(struct comedi_device *dev)
 	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 }
 
-/* Allocate and initialize the subdevice structures.
- */
-static int setup_subdevices(struct comedi_device *dev)
-{
-	struct comedi_subdevice *s;
-	int ret;
-
-	ret = comedi_alloc_subdevices(dev, 1);
-	if (ret)
-		return ret;
-
-	s = &dev->subdevices[0];
-	/* analog input subdevice */
-	dev->read_subdev = s;
-/*	dev->write_subdev = s; */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags =
-	    SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
-	s->n_chan = 32;
-	s->len_chanlist = 32;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_config = dio_config_insn;
-	s->do_cmd = hpdi_cmd;
-	s->do_cmdtest = hpdi_cmd_test;
-	s->cancel = hpdi_cancel;
-
-	return 0;
-}
-
 static int init_hpdi(struct comedi_device *dev)
 {
 	struct hpdi_private *devpriv = dev->private;
@@ -716,6 +682,7 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct hpdi_board *thisboard;
 	struct hpdi_private *devpriv;
+	struct comedi_subdevice *s;
 	int i;
 	int retval;
 
@@ -778,10 +745,25 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	if (retval < 0)
 		return retval;
 
-	retval = setup_subdevices(dev);
-	if (retval < 0)
+	retval = comedi_alloc_subdevices(dev, 1);
+	if (retval)
 		return retval;
 
+	/* Digital I/O subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL |
+			  SDF_CMD_READ;
+	s->n_chan	= 32;
+	s->len_chanlist	= 32;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_config	= dio_config_insn;
+	s->do_cmd	= hpdi_cmd;
+	s->do_cmdtest	= hpdi_cmd_test;
+	s->cancel	= hpdi_cancel;
+
 	return init_hpdi(dev);
 }
 

commit 4ddc6ba41d4609c568d48e23c78907f9fec2134b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Mar 13 14:16:09 2014 -0700

    staging: comedi: gsc_hpdi: move the (*auto_attach) and (*detach) functions
    
    Move these functions closer to the comedi_driver declaration. This removes
    the need for one of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 5af0f78dab47..28fcda762e68 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -57,7 +57,6 @@ static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd);
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static irqreturn_t handle_interrupt(int irq, void *d);
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 
 #define TIMER_BASE 50		/*  20MHz master clock */
@@ -406,116 +405,6 @@ static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
 	return NULL;
 }
 
-static int hpdi_auto_attach(struct comedi_device *dev,
-				      unsigned long context_unused)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct hpdi_board *thisboard;
-	struct hpdi_private *devpriv;
-	int i;
-	int retval;
-
-	thisboard = hpdi_find_board(pcidev);
-	if (!thisboard) {
-		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
-			pci_name(pcidev));
-		return -EINVAL;
-	}
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
-
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
-	retval = comedi_pci_enable(dev);
-	if (retval)
-		return retval;
-	pci_set_master(pcidev);
-
-	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
-	devpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);
-	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
-		dev_warn(dev->class_dev, "failed to remap io memory\n");
-		return -ENOMEM;
-	}
-
-	init_plx9080(dev);
-
-	/*  get irq */
-	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
-			dev->board_name, dev)) {
-		dev_warn(dev->class_dev,
-			 "unable to allocate irq %u\n", pcidev->irq);
-		return -EINVAL;
-	}
-	dev->irq = pcidev->irq;
-
-	dev_dbg(dev->class_dev, " irq %u\n", dev->irq);
-
-	/*  allocate pci dma buffers */
-	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-		devpriv->dio_buffer[i] =
-		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
-					 &devpriv->dio_buffer_phys_addr[i]);
-	}
-	/*  allocate dma descriptors */
-	devpriv->dma_desc = pci_alloc_consistent(pcidev,
-						 sizeof(struct plx_dma_desc) *
-						 NUM_DMA_DESCRIPTORS,
-						 &devpriv->dma_desc_phys_addr);
-	if (devpriv->dma_desc_phys_addr & 0xf) {
-		dev_warn(dev->class_dev,
-			 " dma descriptors not quad-word aligned (bug)\n");
-		return -EIO;
-	}
-
-	retval = setup_dma_descriptors(dev, 0x1000);
-	if (retval < 0)
-		return retval;
-
-	retval = setup_subdevices(dev);
-	if (retval < 0)
-		return retval;
-
-	return init_hpdi(dev);
-}
-
-static void hpdi_detach(struct comedi_device *dev)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct hpdi_private *devpriv = dev->private;
-	unsigned int i;
-
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (devpriv) {
-		if (devpriv->plx9080_iobase) {
-			disable_plx_interrupts(dev);
-			iounmap(devpriv->plx9080_iobase);
-		}
-		if (devpriv->hpdi_iobase)
-			iounmap(devpriv->hpdi_iobase);
-		/*  free pci dma buffers */
-		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-			if (devpriv->dio_buffer[i])
-				pci_free_consistent(pcidev,
-						    DMA_BUFFER_SIZE,
-						    devpriv->dio_buffer[i],
-						    devpriv->
-						    dio_buffer_phys_addr[i]);
-		}
-		/*  free dma descriptors */
-		if (devpriv->dma_desc)
-			pci_free_consistent(pcidev,
-					    sizeof(struct plx_dma_desc) *
-					    NUM_DMA_DESCRIPTORS,
-					    devpriv->dma_desc,
-					    devpriv->dma_desc_phys_addr);
-	}
-	comedi_pci_disable(dev);
-}
-
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
 	unsigned int requested_block_size;
@@ -821,6 +710,116 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int hpdi_auto_attach(struct comedi_device *dev,
+				      unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct hpdi_board *thisboard;
+	struct hpdi_private *devpriv;
+	int i;
+	int retval;
+
+	thisboard = hpdi_find_board(pcidev);
+	if (!thisboard) {
+		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
+			pci_name(pcidev));
+		return -EINVAL;
+	}
+	dev->board_ptr = thisboard;
+	dev->board_name = thisboard->name;
+
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
+	retval = comedi_pci_enable(dev);
+	if (retval)
+		return retval;
+	pci_set_master(pcidev);
+
+	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
+	devpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);
+	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
+		dev_warn(dev->class_dev, "failed to remap io memory\n");
+		return -ENOMEM;
+	}
+
+	init_plx9080(dev);
+
+	/*  get irq */
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+			dev->board_name, dev)) {
+		dev_warn(dev->class_dev,
+			 "unable to allocate irq %u\n", pcidev->irq);
+		return -EINVAL;
+	}
+	dev->irq = pcidev->irq;
+
+	dev_dbg(dev->class_dev, " irq %u\n", dev->irq);
+
+	/*  allocate pci dma buffers */
+	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+		devpriv->dio_buffer[i] =
+		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
+					 &devpriv->dio_buffer_phys_addr[i]);
+	}
+	/*  allocate dma descriptors */
+	devpriv->dma_desc = pci_alloc_consistent(pcidev,
+						 sizeof(struct plx_dma_desc) *
+						 NUM_DMA_DESCRIPTORS,
+						 &devpriv->dma_desc_phys_addr);
+	if (devpriv->dma_desc_phys_addr & 0xf) {
+		dev_warn(dev->class_dev,
+			 " dma descriptors not quad-word aligned (bug)\n");
+		return -EIO;
+	}
+
+	retval = setup_dma_descriptors(dev, 0x1000);
+	if (retval < 0)
+		return retval;
+
+	retval = setup_subdevices(dev);
+	if (retval < 0)
+		return retval;
+
+	return init_hpdi(dev);
+}
+
+static void hpdi_detach(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct hpdi_private *devpriv = dev->private;
+	unsigned int i;
+
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (devpriv) {
+		if (devpriv->plx9080_iobase) {
+			disable_plx_interrupts(dev);
+			iounmap(devpriv->plx9080_iobase);
+		}
+		if (devpriv->hpdi_iobase)
+			iounmap(devpriv->hpdi_iobase);
+		/*  free pci dma buffers */
+		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+			if (devpriv->dio_buffer[i])
+				pci_free_consistent(pcidev,
+						    DMA_BUFFER_SIZE,
+						    devpriv->dio_buffer[i],
+						    devpriv->
+						    dio_buffer_phys_addr[i]);
+		}
+		/*  free dma descriptors */
+		if (devpriv->dma_desc)
+			pci_free_consistent(pcidev,
+					    sizeof(struct plx_dma_desc) *
+					    NUM_DMA_DESCRIPTORS,
+					    devpriv->dma_desc,
+					    devpriv->dma_desc_phys_addr);
+	}
+	comedi_pci_disable(dev);
+}
+
 static struct comedi_driver gsc_hpdi_driver = {
 	.driver_name	= "gsc_hpdi",
 	.module		= THIS_MODULE,

commit 52037a0d520e988e3287b28bc767b58ddc66ad94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:46 2014 -0700

    staging: comedi: drivers should not clear the async->events
    
    The comedi core resets the async->events in comedi_buf_reset() which is
    called when the subdevice is restored to an idle state and at the start
    of an async command. The async->events are also cleared after handling
    the events in comedi_event().
    
    Drivers should not clear the events manually.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index de60a2871d70..5af0f78dab47 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -746,8 +746,6 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	hpdi_intr_status = readl(devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
 	hpdi_board_status = readl(devpriv->hpdi_iobase + BOARD_STATUS_REG);
 
-	async->events = 0;
-
 	if (hpdi_intr_status) {
 		writel(hpdi_intr_status,
 		       devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 4fcf3c876ac9..de60a2871d70 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -836,7 +836,7 @@ static int gsc_hpdi_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(gsc_hpdi_pci_table) = {
+static const struct pci_device_id gsc_hpdi_pci_table[] = {
 	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
 		    0x2400, 0, 0, 0},
 	{ 0 }

commit f1bea9cf516135b40d3e9d71310a832cd7069868
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:19 2013 -0700

    staging: comedi: gsc_hpdi: remove DEBUG_PRINT
    
    The DEBUG_PRINT macro in this driver is used to output development
    debug tracing messages. These messages are just added noise. Remove
    them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 559bf5583530..4fcf3c876ac9 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -60,15 +60,6 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 
-#undef HPDI_DEBUG		/*  disable debugging messages */
-/* #define HPDI_DEBUG      enable debugging code */
-
-#ifdef HPDI_DEBUG
-#define DEBUG_PRINT(format, args...)  pr_debug(format , ## args)
-#else
-#define DEBUG_PRINT(format, args...)  no_printk(pr_fmt(format), ## args)
-#endif
-
 #define TIMER_BASE 50		/*  20MHz master clock */
 #define DMA_BUFFER_SIZE 0x10000
 #define NUM_DMA_BUFFERS 4
@@ -260,32 +251,6 @@ static void init_plx9080(struct comedi_device *dev)
 	uint32_t bits;
 	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
-	/*  plx9080 dump */
-	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		    readl(plx_iobase + PLX_INTRCS_REG));
-	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
-	DEBUG_PRINT(" plx control reg 0x%x\n",
-		    readl(devpriv->plx9080_iobase + PLX_CONTROL_REG));
-
-	DEBUG_PRINT(" plx revision 0x%x\n",
-		    readl(plx_iobase + PLX_REVISION_REG));
-	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_MODE_REG));
-	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		    readl(plx_iobase + PLX_DMA1_MODE_REG));
-	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
-	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
-	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
-	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
-	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		    readb(plx_iobase + PLX_DMA0_CS_REG));
-	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
-	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
 #else
@@ -395,10 +360,6 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 	if (transfer_size == 0)
 		return -1;
 
-	DEBUG_PRINT(" transfer_size %i\n", transfer_size);
-	DEBUG_PRINT(" descriptors at 0x%lx\n",
-		    (unsigned long)devpriv->dma_desc_phys_addr);
-
 	buffer_offset = 0;
 	buffer_index = 0;
 	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
@@ -423,21 +384,11 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 			buffer_offset = 0;
 			buffer_index++;
 		}
-
-		DEBUG_PRINT(" desc %i\n", i);
-		DEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",
-			    devpriv->desc_dio_buffer[i],
-			    (unsigned long)devpriv->dma_desc[i].
-			    pci_start_addr);
-		DEBUG_PRINT(" next 0x%lx\n",
-			    (unsigned long)devpriv->dma_desc[i].next);
 	}
 	devpriv->num_dma_descriptors = i;
 	/*  fix last descriptor to point back to first */
 	devpriv->dma_desc[i - 1].next =
 	    cpu_to_le32(devpriv->dma_desc_phys_addr | next_bits);
-	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
-		    (unsigned long)devpriv->dma_desc[i - 1].next);
 
 	devpriv->block_size = transfer_size;
 
@@ -489,9 +440,6 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
-	DEBUG_PRINT(" hpdi remapped to 0x%p\n", devpriv->hpdi_iobase);
-
 	init_plx9080(dev);
 
 	/*  get irq */
@@ -510,9 +458,6 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 		devpriv->dio_buffer[i] =
 		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					 &devpriv->dio_buffer_phys_addr[i]);
-		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
-			    devpriv->dio_buffer[i],
-			    (unsigned long)devpriv->dio_buffer_phys_addr[i]);
 	}
 	/*  allocate dma descriptors */
 	devpriv->dma_desc = pci_alloc_consistent(pcidev,
@@ -687,8 +632,6 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
 
-	DEBUG_PRINT("hpdi: in di_cmd\n");
-
 	abort_dma(dev, 0);
 
 	devpriv->dma_desc_index = 0;
@@ -725,7 +668,6 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writel(intr_bit(RX_FULL_INTR),
 	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
-	DEBUG_PRINT("hpdi: starting rx\n");
 	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
 
 	return 0;
@@ -778,11 +720,6 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 					  num_samples * sizeof(uint32_t));
 		devpriv->dma_desc_index++;
 		devpriv->dma_desc_index %= devpriv->num_dma_descriptors;
-
-		DEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)
-			    devpriv->dma_desc[devpriv->dma_desc_index].
-			    next);
-		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/*  XXX check for buffer overrun somehow */
 }
@@ -812,7 +749,6 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	async->events = 0;
 
 	if (hpdi_intr_status) {
-		DEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);
 		writel(hpdi_intr_status,
 		       devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
@@ -823,10 +759,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 
-		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT)
 			drain_dma_buffers(dev, 0);
-		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -836,9 +770,6 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
-		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
-
-		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -846,15 +777,11 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
 		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
 		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
-		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
 	}
 
 	if (hpdi_board_status & RX_OVERRUN_BIT) {
 		comedi_error(dev, "rx fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
-		DEBUG_PRINT("dma0_status 0x%x\n",
-			    (int)readb(devpriv->plx9080_iobase +
-				       PLX_DMA0_CS_REG));
 	}
 
 	if (hpdi_board_status & RX_UNDERRUN_BIT) {
@@ -865,11 +792,6 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (devpriv->dio_count == 0)
 		async->events |= COMEDI_CB_EOA;
 
-	DEBUG_PRINT("board status 0x%x, ", hpdi_board_status);
-	DEBUG_PRINT("plx status 0x%x\n", plx_status);
-	if (async->events)
-		DEBUG_PRINT(" events 0x%x\n", async->events);
-
 	cfc_handle_events(dev, s);
 
 	return IRQ_HANDLED;

commit 5dacadcca3176e2b1f8db662e503c080484d71fa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:33:05 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for complex cases
    
    Convert the drivers with complex, port programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these drivers have some sort of 'port' programmable i/o where multiple
    i/o channels are configured as a group. The 'mask' associated with the group
    is passed to comedi_dio_insn_config() so that all the channels are configured.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index cdcc8f42e209..559bf5583530 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -224,37 +224,26 @@ struct hpdi_private {
 	volatile uint32_t bits[24];
 	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
 	volatile unsigned int block_size;
-	unsigned dio_config_output:1;
 };
 
 static int dio_config_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
-	struct hpdi_private *devpriv = dev->private;
+	int ret;
 
 	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		devpriv->dio_config_output = 1;
-		return insn->n;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		devpriv->dio_config_output = 0;
-		return insn->n;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    devpriv->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-		break;
 	case INSN_CONFIG_BLOCK_SIZE:
 		return dio_config_block_size(dev, data);
-		break;
 	default:
+		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
+		if (ret)
+			return ret;
 		break;
 	}
 
-	return -EINVAL;
+	return insn->n;
 }
 
 static void disable_plx_interrupts(struct comedi_device *dev)
@@ -673,9 +662,7 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	struct hpdi_private *devpriv = dev->private;
-
-	if (devpriv->dio_config_output)
+	if (s->io_bits)
 		return -EINVAL;
 	else
 		return di_cmd_test(dev, s, cmd);
@@ -746,9 +733,7 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct hpdi_private *devpriv = dev->private;
-
-	if (devpriv->dio_config_output)
+	if (s->io_bits)
 		return -EINVAL;
 	else
 		return di_cmd(dev, s);

commit 3457bfd6dfb38f7bb66a227fe3473bad4773de06
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 15:14:18 2013 -0700

    Revert "staging: comedi: drivers: use comedi_dio_insn_config() for complex cases"
    
    This reverts commit f21c53945cb95f66faa9636af5f23cb00ba73019.
    
    I applied the wrong patch :(
    
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 559bf5583530..cdcc8f42e209 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -224,26 +224,37 @@ struct hpdi_private {
 	volatile uint32_t bits[24];
 	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
 	volatile unsigned int block_size;
+	unsigned dio_config_output:1;
 };
 
 static int dio_config_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s,
-			   struct comedi_insn *insn,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
-	int ret;
+	struct hpdi_private *devpriv = dev->private;
 
 	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		devpriv->dio_config_output = 1;
+		return insn->n;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		devpriv->dio_config_output = 0;
+		return insn->n;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+		    devpriv->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+		break;
 	case INSN_CONFIG_BLOCK_SIZE:
 		return dio_config_block_size(dev, data);
+		break;
 	default:
-		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
-		if (ret)
-			return ret;
 		break;
 	}
 
-	return insn->n;
+	return -EINVAL;
 }
 
 static void disable_plx_interrupts(struct comedi_device *dev)
@@ -662,7 +673,9 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	if (s->io_bits)
+	struct hpdi_private *devpriv = dev->private;
+
+	if (devpriv->dio_config_output)
 		return -EINVAL;
 	else
 		return di_cmd_test(dev, s, cmd);
@@ -733,7 +746,9 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (s->io_bits)
+	struct hpdi_private *devpriv = dev->private;
+
+	if (devpriv->dio_config_output)
 		return -EINVAL;
 	else
 		return di_cmd(dev, s);

commit f21c53945cb95f66faa9636af5f23cb00ba73019
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 5 15:01:25 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for complex cases
    
    Convert the drivers with complex, port programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these drivers have some sort of 'port' programmable i/o where multiple
    i/o channels are configured as a group. The 'mask' associated with the group
    is passed to comedi_dio_insn_config() so that all the channels are configured.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index cdcc8f42e209..559bf5583530 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -224,37 +224,26 @@ struct hpdi_private {
 	volatile uint32_t bits[24];
 	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
 	volatile unsigned int block_size;
-	unsigned dio_config_output:1;
 };
 
 static int dio_config_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
-	struct hpdi_private *devpriv = dev->private;
+	int ret;
 
 	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		devpriv->dio_config_output = 1;
-		return insn->n;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		devpriv->dio_config_output = 0;
-		return insn->n;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    devpriv->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-		break;
 	case INSN_CONFIG_BLOCK_SIZE:
 		return dio_config_block_size(dev, data);
-		break;
 	default:
+		ret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);
+		if (ret)
+			return ret;
 		break;
 	}
 
-	return -EINVAL;
+	return insn->n;
 }
 
 static void disable_plx_interrupts(struct comedi_device *dev)
@@ -673,9 +662,7 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	struct hpdi_private *devpriv = dev->private;
-
-	if (devpriv->dio_config_output)
+	if (s->io_bits)
 		return -EINVAL;
 	else
 		return di_cmd_test(dev, s, cmd);
@@ -746,9 +733,7 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct hpdi_private *devpriv = dev->private;
-
-	if (devpriv->dio_config_output)
+	if (s->io_bits)
 		return -EINVAL;
 	else
 		return di_cmd(dev, s);

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f130327f88d3..cdcc8f42e209 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -42,6 +42,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 2fceff93867b..f130327f88d3 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -483,10 +483,9 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	retval = comedi_pci_enable(dev);
 	if (retval)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 0c061df0978c..2fceff93867b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -18,12 +18,7 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************/
+*/
 
 /*
  * Driver: gsc_hpdi

commit 925fe5a6dca3e6a98c74e543cfb072ec63d58b73
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:27:13 2013 -0700

    staging: comedi: gsc_hpdi: use pci_ioremap_bar()
    
    Use pci_ioremap_bar() to ioremap the PCI resources. That function
    just takes the pci device and a bar number. It also has some
    additional sanity checks to make sure the bar is actually a
    memory resource.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 4221f2625059..0c061df0978c 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -498,12 +498,8 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 		return retval;
 	pci_set_master(pcidev);
 
-	devpriv->plx9080_iobase =
-		ioremap(pci_resource_start(pcidev, 0),
-			pci_resource_len(pcidev, 0));
-	devpriv->hpdi_iobase =
-		ioremap(pci_resource_start(pcidev, 2),
-			pci_resource_len(pcidev, 2));
+	devpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);
+	devpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);
 	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;

commit 5aa41d4ce4e1fd71e256f938448424b4f28871c4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 11:26:54 2013 -0700

    staging: comedi: gsc_hpdi: remove the base_address_regions enum
    
    This enum is only used in the ioremap of the PCI resources and it
    doesn't really help make the code any clearer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index ba44d0375c20..4221f2625059 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -78,12 +78,6 @@ static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 #define NUM_DMA_BUFFERS 4
 #define NUM_DMA_DESCRIPTORS 256
 
-/* indices of base address regions */
-enum base_address_regions {
-	PLX9080_BADDRINDEX = 0,
-	HPDI_BADDRINDEX = 2,
-};
-
 enum hpdi_registers {
 	FIRMWARE_REV_REG = 0x0,
 	BOARD_CONTROL_REG = 0x4,
@@ -505,11 +499,11 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	pci_set_master(pcidev);
 
 	devpriv->plx9080_iobase =
-		ioremap(pci_resource_start(pcidev, PLX9080_BADDRINDEX),
-			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
+		ioremap(pci_resource_start(pcidev, 0),
+			pci_resource_len(pcidev, 0));
 	devpriv->hpdi_iobase =
-		ioremap(pci_resource_start(pcidev, HPDI_BADDRINDEX),
-			pci_resource_len(pcidev, HPDI_BADDRINDEX));
+		ioremap(pci_resource_start(pcidev, 2),
+			pci_resource_len(pcidev, 2));
 	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;

commit 84b44d08993ffe762d9a86ee2243239350b871a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:36 2013 +0000

    staging: comedi: remove unneeded settings of `dev->iobase`
    
    Some PCI drivers use the "spare" `iobase` member of `struct
    comedi_device` as a flag to indicate that the call to
    `comedi_pci_enable()` was successful.  This is no longer necessary now
    that `comedi_pci_enable()` and `comedi_pci_disable()` use the
    `ioenabled` member of `struct comedi_device` themselves to keep track of
    what needs to be done.
    
    Remove the unnecessary assignments to the `iobase` member in the
    relevant drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 16b4cc050d35..ba44d0375c20 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -502,7 +502,6 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 	retval = comedi_pci_enable(dev);
 	if (retval)
 		return retval;
-	dev->iobase = 1;	/* the "detach" needs this */
 	pci_set_master(pcidev);
 
 	devpriv->plx9080_iobase =

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f0e92143ac89..16b4cc050d35 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -499,11 +499,9 @@ static int hpdi_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	if (comedi_pci_enable(pcidev, dev->board_name)) {
-		dev_warn(dev->class_dev,
-			 "failed enable PCI device and request regions\n");
-		return -EIO;
-	}
+	retval = comedi_pci_enable(dev);
+	if (retval)
+		return retval;
 	dev->iobase = 1;	/* the "detach" needs this */
 	pci_set_master(pcidev);
 

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index a18d897606f8..f0e92143ac89 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -596,9 +596,8 @@ static void hpdi_detach(struct comedi_device *dev)
 					    NUM_DMA_DESCRIPTORS,
 					    devpriv->dma_desc,
 					    devpriv->dma_desc_phys_addr);
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
 	}
+	comedi_pci_disable(dev);
 }
 
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b60c97562676..a18d897606f8 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -943,9 +943,9 @@ static struct comedi_driver gsc_hpdi_driver = {
 };
 
 static int gsc_hpdi_pci_probe(struct pci_dev *dev,
-					const struct pci_device_id *ent)
+			      const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &gsc_hpdi_driver);
+	return comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(gsc_hpdi_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 6d88b72fd472..b60c97562676 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -47,9 +47,11 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/pci.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
+
 #include "../comedidev.h"
-#include <linux/delay.h>
 
 #include "plx9080.h"
 #include "comedi_fc.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 154598f6d5e3..6d88b72fd472 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -946,11 +946,6 @@ static int gsc_hpdi_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &gsc_hpdi_driver);
 }
 
-static void gsc_hpdi_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(gsc_hpdi_pci_table) = {
 	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
 		    0x2400, 0, 0, 0},
@@ -962,7 +957,7 @@ static struct pci_driver gsc_hpdi_pci_driver = {
 	.name		= "gsc_hpdi",
 	.id_table	= gsc_hpdi_pci_table,
 	.probe		= gsc_hpdi_pci_probe,
-	.remove		= gsc_hpdi_pci_remove
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 25708bcefcfe..154598f6d5e3 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -946,7 +946,7 @@ static int gsc_hpdi_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &gsc_hpdi_driver);
 }
 
-static void __devexit gsc_hpdi_pci_remove(struct pci_dev *dev)
+static void gsc_hpdi_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 98926469e693..25708bcefcfe 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -474,7 +474,7 @@ static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
 	return NULL;
 }
 
-static int __devinit hpdi_auto_attach(struct comedi_device *dev,
+static int hpdi_auto_attach(struct comedi_device *dev,
 				      unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -940,7 +940,7 @@ static struct comedi_driver gsc_hpdi_driver = {
 	.detach		= hpdi_detach,
 };
 
-static int __devinit gsc_hpdi_pci_probe(struct pci_dev *dev,
+static int gsc_hpdi_pci_probe(struct pci_dev *dev,
 					const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &gsc_hpdi_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index eb3cb80ff2a5..98926469e693 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -962,7 +962,7 @@ static struct pci_driver gsc_hpdi_pci_driver = {
 	.name		= "gsc_hpdi",
 	.id_table	= gsc_hpdi_pci_table,
 	.probe		= gsc_hpdi_pci_probe,
-	.remove		= __devexit_p(gsc_hpdi_pci_remove)
+	.remove		= gsc_hpdi_pci_remove
 };
 module_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);
 

commit bf1b2022ef4052953b7f8e04ee3259c061561261
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:55:56 2012 -0700

    staging: comedi: gsc_hpdi: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of di_cmd_test().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 77b86820d7bd..eb3cb80ff2a5 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -641,29 +641,20 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (!cmd->chanlist_len) {
 		cmd->chanlist_len = 32;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
+		err |= -EINVAL;
 	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;

commit 50a24814958ff9cba0e74bfa900bfac698c2ce23
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:34 2012 +0000

    staging: comedi: gsc_hpdi: update driver description comment
    
    Reformat the comment used to describe the Comedi driver to use the usual
    block comment style.
    
    Update the information reflecting the fact that the driver no longer
    supports manual attachment of devices via the `COMEDI_DEVCONFIG` ioctl.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index c056c259ddb5..77b86820d7bd 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -26,24 +26,24 @@
 ************************************************************************/
 
 /*
-
-Driver: gsc_hpdi
-Description: General Standards Corporation High
-    Speed Parallel Digital Interface rs485 boards
-Author: Frank Mori Hess <fmhess@users.sourceforge.net>
-Status: only receive mode works, transmit not supported
-Updated: 2003-02-20
-Devices: [General Standards Corporation] PCI-HPDI32 (gsc_hpdi),
-  PMC-HPDI32
-
-Configuration options:
-   [0] - PCI bus of device (optional)
-   [1] - PCI slot of device (optional)
-
-There are some additional hpdi models available from GSC for which
-support could be added to this driver.
-
-*/
+ * Driver: gsc_hpdi
+ * Description: General Standards Corporation High
+ *    Speed Parallel Digital Interface rs485 boards
+ * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Status: only receive mode works, transmit not supported
+ * Updated: Thu, 01 Nov 2012 16:17:38 +0000
+ * Devices: [General Standards Corporation] PCI-HPDI32 (gsc_hpdi),
+ *   PMC-HPDI32
+ *
+ * Configuration options:
+ *    None.
+ *
+ * Manual configuration of supported devices is not supported; they are
+ * configured automatically.
+ *
+ * There are some additional hpdi models available from GSC for which
+ * support could be added to this driver.
+ */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit 871e1d0545436f7c21b1b103601e1fe3920a6e4c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:33 2012 +0000

    staging: comedi: gsc_hpdi: change DEBUG_PRINT()
    
    Change the `DEBUG_PRINT(format, args...)` macro used by this module to
    use either `pr_debug()` (if macro `HPDI_DEBUG` is defined) or
    `no_printk()` instead of `printk()` or nothing.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 4f829b666fe5..c056c259ddb5 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -45,6 +45,8 @@ support could be added to this driver.
 
 */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/delay.h>
@@ -64,9 +66,9 @@ static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 /* #define HPDI_DEBUG      enable debugging code */
 
 #ifdef HPDI_DEBUG
-#define DEBUG_PRINT(format, args...)  printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  pr_debug(format , ## args)
 #else
-#define DEBUG_PRINT(format, args...)
+#define DEBUG_PRINT(format, args...)  no_printk(pr_fmt(format), ## args)
 #endif
 
 #define TIMER_BASE 50		/*  20MHz master clock */

commit 3dd5ca831317a752095040d403e80cf7a6a783b5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:32 2012 +0000

    staging: comedi: gsc_hpdi: use board name to request resources
    
    When requesting PCI region resources and IRQ, use the board name as the
    resource owner string instead of the driver name.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index adcc002bba6b..4f829b666fe5 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -495,7 +495,7 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
+	if (comedi_pci_enable(pcidev, dev->board_name)) {
 		dev_warn(dev->class_dev,
 			 "failed enable PCI device and request regions\n");
 		return -EIO;
@@ -521,7 +521,7 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
-			dev->driver->driver_name, dev)) {
+			dev->board_name, dev)) {
 		dev_warn(dev->class_dev,
 			 "unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;

commit 21309dabd3eec2827c7604a0cba19f3e795c33d7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:31 2012 +0000

    staging: comedi: gsc_hpdi: make board name pointer const
    
    Change the type of the `name` member of `struct hpdi_board` from `char
    *` to `const char *` as it should not be modifiable.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 2246338611a9..adcc002bba6b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -186,8 +186,7 @@ static unsigned int fifo_size(uint32_t fifo_size_bits)
 }
 
 struct hpdi_board {
-
-	char *name;
+	const char *name;	/*  board name */
 	int device_id;		/*  pci device id */
 	int subdevice_id;	/*  pci subdevice id */
 };

commit 6526cd1ad04adc2ca54d34d1f003b8bb5318d337
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:30 2012 +0000

    staging: comedi: gsc_hpdi: remove board(dev) function
    
    The `board(dev)` function just casts `dev->board_ptr` to a pointer to
    the private data type `struct hpdi_private` and returns it.  It's only
    called from one function: `hpdi_auto_attach()`.
    
    Remove `board()` and use a local variable to point to the `struct
    hpdi_private` data structure.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 816296b04e69..2246338611a9 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -207,11 +207,6 @@ static const struct hpdi_board hpdi_boards[] = {
 #endif
 };
 
-static inline struct hpdi_board *board(const struct comedi_device *dev)
-{
-	return (struct hpdi_board *)dev->board_ptr;
-}
-
 struct hpdi_private {
 	/*  base addresses (ioremapped) */
 	void __iomem *plx9080_iobase;
@@ -482,16 +477,19 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 				      unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct hpdi_board *thisboard;
 	struct hpdi_private *devpriv;
 	int i;
 	int retval;
 
-	dev->board_ptr = hpdi_find_board(pcidev);
-	if (!dev->board_ptr) {
+	thisboard = hpdi_find_board(pcidev);
+	if (!thisboard) {
 		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
 			pci_name(pcidev));
 		return -EINVAL;
 	}
+	dev->board_ptr = thisboard;
+	dev->board_name = thisboard->name;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -506,9 +504,6 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 	dev->iobase = 1;	/* the "detach" needs this */
 	pci_set_master(pcidev);
 
-	/* Initialize dev->board_name */
-	dev->board_name = board(dev)->name;
-
 	devpriv->plx9080_iobase =
 		ioremap(pci_resource_start(pcidev, PLX9080_BADDRINDEX),
 			pci_resource_len(pcidev, PLX9080_BADDRINDEX));

commit 594985d6615cc214dbfaf18fb6325d89a3c82e84
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:29 2012 +0000

    staging: comedi: gsc_hpdi: don't store physical base addresses
    
    In `struct hpdi_private`, the `plx9080_phys_iobase` and
    `hpdi_phys_iobase` hold the physical memory addresses from the PCI
    BARs used by this driver.  The physical addresses are only really needed
    when ioremapping the resources when the device is being attached by
    `hpdi_auto_attach()`.  A non-zero value of the `hpdi_phys_iobase` is
    also used to indicate that a call to `comedi_pci_enable()` was
    successful so that `comedi_pci_disable()` should be called when the
    device is detached by `hpdi_detach()`.
    
    Remove the `plx9080_phys_iobase` and `hpdi_phys_iobase` members and use
    `dev->iobase` as a flag to indicate whether `comedi_pci_disable()` needs
    to be called by `hpdi_detach()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 7c25e7fa8c49..816296b04e69 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -213,9 +213,6 @@ static inline struct hpdi_board *board(const struct comedi_device *dev)
 }
 
 struct hpdi_private {
-	/*  base addresses (physical) */
-	resource_size_t plx9080_phys_iobase;
-	resource_size_t hpdi_phys_iobase;
 	/*  base addresses (ioremapped) */
 	void __iomem *plx9080_iobase;
 	void __iomem *hpdi_iobase;
@@ -506,23 +503,18 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 			 "failed enable PCI device and request regions\n");
 		return -EIO;
 	}
+	dev->iobase = 1;	/* the "detach" needs this */
 	pci_set_master(pcidev);
 
 	/* Initialize dev->board_name */
 	dev->board_name = board(dev)->name;
 
-	devpriv->plx9080_phys_iobase =
-	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
-	devpriv->hpdi_phys_iobase =
-	    pci_resource_start(pcidev, HPDI_BADDRINDEX);
-
-	/*  remap, won't work with 2.0 kernels but who cares */
-	devpriv->plx9080_iobase = ioremap(devpriv->plx9080_phys_iobase,
-					    pci_resource_len(pcidev,
-					    PLX9080_BADDRINDEX));
+	devpriv->plx9080_iobase =
+		ioremap(pci_resource_start(pcidev, PLX9080_BADDRINDEX),
+			pci_resource_len(pcidev, PLX9080_BADDRINDEX));
 	devpriv->hpdi_iobase =
-	    ioremap(devpriv->hpdi_phys_iobase,
-		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
+		ioremap(pci_resource_start(pcidev, HPDI_BADDRINDEX),
+			pci_resource_len(pcidev, HPDI_BADDRINDEX));
 	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
 		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
@@ -606,7 +598,7 @@ static void hpdi_detach(struct comedi_device *dev)
 					    NUM_DMA_DESCRIPTORS,
 					    devpriv->dma_desc,
 					    devpriv->dma_desc_phys_addr);
-		if (devpriv->hpdi_phys_iobase)
+		if (dev->iobase)
 			comedi_pci_disable(pcidev);
 	}
 }

commit fd67ad4433a91c6c14188d5250ebdd86d4995f79
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:28 2012 +0000

    staging: comedi: gsc_hpdi: remove devpriv->hw_dev
    
    The `hw_dev` member of `struct hpdi_private` is used to point to the
    `struct pci_dev`.  This is redundant as the `struct comedi_device`
    already has a pointer to the `struct device` within the `struct pci_dev`
    and there is a convenient inline function, `comedi_to_pci_dev(dev)` that
    returns a pointer to the `struct pci_dev`.
    
    Remove the redundant `hw_dev` member and use alternate ways to get at
    the `struct pci_dev`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index f468c1efab90..7c25e7fa8c49 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -213,8 +213,6 @@ static inline struct hpdi_board *board(const struct comedi_device *dev)
 }
 
 struct hpdi_private {
-
-	struct pci_dev *hw_dev;	/*  pointer to board's pci_dev struct */
 	/*  base addresses (physical) */
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t hpdi_phys_iobase;
@@ -502,7 +500,6 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
-	devpriv->hw_dev = pcidev;
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->class_dev,
@@ -550,18 +547,17 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 	/*  allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		devpriv->dio_buffer[i] =
-		    pci_alloc_consistent(devpriv->hw_dev, DMA_BUFFER_SIZE,
+		    pci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,
 					 &devpriv->dio_buffer_phys_addr[i]);
 		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
 			    devpriv->dio_buffer[i],
 			    (unsigned long)devpriv->dio_buffer_phys_addr[i]);
 	}
 	/*  allocate dma descriptors */
-	devpriv->dma_desc = pci_alloc_consistent(devpriv->hw_dev,
-						   sizeof(struct plx_dma_desc) *
-						   NUM_DMA_DESCRIPTORS,
-						   &devpriv->
-						   dma_desc_phys_addr);
+	devpriv->dma_desc = pci_alloc_consistent(pcidev,
+						 sizeof(struct plx_dma_desc) *
+						 NUM_DMA_DESCRIPTORS,
+						 &devpriv->dma_desc_phys_addr);
 	if (devpriv->dma_desc_phys_addr & 0xf) {
 		dev_warn(dev->class_dev,
 			 " dma descriptors not quad-word aligned (bug)\n");
@@ -581,12 +577,13 @@ static int __devinit hpdi_auto_attach(struct comedi_device *dev,
 
 static void hpdi_detach(struct comedi_device *dev)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct hpdi_private *devpriv = dev->private;
 	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (devpriv && devpriv->hw_dev) {
+	if (devpriv) {
 		if (devpriv->plx9080_iobase) {
 			disable_plx_interrupts(dev);
 			iounmap(devpriv->plx9080_iobase);
@@ -596,20 +593,21 @@ static void hpdi_detach(struct comedi_device *dev)
 		/*  free pci dma buffers */
 		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 			if (devpriv->dio_buffer[i])
-				pci_free_consistent(devpriv->hw_dev,
-					DMA_BUFFER_SIZE,
-					devpriv->dio_buffer[i],
-					devpriv->dio_buffer_phys_addr[i]);
+				pci_free_consistent(pcidev,
+						    DMA_BUFFER_SIZE,
+						    devpriv->dio_buffer[i],
+						    devpriv->
+						    dio_buffer_phys_addr[i]);
 		}
 		/*  free dma descriptors */
 		if (devpriv->dma_desc)
-			pci_free_consistent(devpriv->hw_dev,
-				sizeof(struct plx_dma_desc) *
-				NUM_DMA_DESCRIPTORS,
-				devpriv->dma_desc,
-				devpriv-> dma_desc_phys_addr);
+			pci_free_consistent(pcidev,
+					    sizeof(struct plx_dma_desc) *
+					    NUM_DMA_DESCRIPTORS,
+					    devpriv->dma_desc,
+					    devpriv->dma_desc_phys_addr);
 		if (devpriv->hpdi_phys_iobase)
-			comedi_pci_disable(devpriv->hw_dev);
+			comedi_pci_disable(pcidev);
 	}
 }
 

commit 4e95df1f482412162ef03fe3a877aa95706b36b9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 1 16:28:27 2012 +0000

    staging: comedi: gsc_hpdi: use auto_attach method
    
    This driver does not need to support manual attachment of supported PCI
    devices.  Replace the `attach()` hook (`hpdi_attach()`) with an
    `auto_attach()` hook (`hpdi_auto_attach()`).  This will be called via
    `comedi_pci_auto_config()` at PCI probe time.
    
    This driver no longer increments the PCI reference during attachment, so
    remove the call to `pci_dev_put()` when detaching the device.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 48092958d73b..f468c1efab90 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -472,51 +472,37 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 	return transfer_size;
 }
 
-static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)
 {
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)
+		if (pcidev->device == hpdi_boards[i].device_id &&
+		    pcidev->subsystem_device == hpdi_boards[i].subdevice_id)
+			return &hpdi_boards[i];
+	return NULL;
+}
+
+static int __devinit hpdi_auto_attach(struct comedi_device *dev,
+				      unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct hpdi_private *devpriv;
-	struct pci_dev *pcidev;
 	int i;
 	int retval;
 
-	dev_dbg(dev->class_dev, "gsc_hpdi\n");
+	dev->board_ptr = hpdi_find_board(pcidev);
+	if (!dev->board_ptr) {
+		dev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",
+			pci_name(pcidev));
+		return -EINVAL;
+	}
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
-
-	pcidev = NULL;
-	for (i = 0; i < ARRAY_SIZE(hpdi_boards) &&
-		    dev->board_ptr == NULL; i++) {
-		do {
-			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
-						hpdi_boards[i].device_id,
-						PCI_VENDOR_ID_PLX,
-						hpdi_boards[i].subdevice_id,
-						pcidev);
-			/*  was a particular bus/slot requested? */
-			if (it->options[0] || it->options[1]) {
-				/*  are we on the wrong bus/slot? */
-				if (pcidev->bus->number != it->options[0] ||
-				    PCI_SLOT(pcidev->devfn) != it->options[1])
-					continue;
-			}
-			if (pcidev) {
-				devpriv->hw_dev = pcidev;
-				dev->board_ptr = hpdi_boards + i;
-				break;
-			}
-		} while (pcidev != NULL);
-	}
-	if (dev->board_ptr == NULL) {
-		dev_warn(dev->class_dev, "no hpdi card found\n");
-		return -EIO;
-	}
-
-	dev_warn(dev->class_dev,
-		 "found %s on bus %i, slot %i\n", board(dev)->name,
-		 pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	devpriv->hw_dev = pcidev;
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_warn(dev->class_dev,
@@ -624,7 +610,6 @@ static void hpdi_detach(struct comedi_device *dev)
 				devpriv-> dma_desc_phys_addr);
 		if (devpriv->hpdi_phys_iobase)
 			comedi_pci_disable(devpriv->hw_dev);
-		pci_dev_put(devpriv->hw_dev);
 	}
 }
 
@@ -974,7 +959,7 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static struct comedi_driver gsc_hpdi_driver = {
 	.driver_name	= "gsc_hpdi",
 	.module		= THIS_MODULE,
-	.attach		= hpdi_attach,
+	.auto_attach	= hpdi_auto_attach,
 	.detach		= hpdi_detach,
 };
 

commit 37a836b1fd03c2bae6779b226ec5aef8bc37c146
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Fri Oct 26 09:21:45 2012 +0900

    staging/comedi: Use pr_ or dev_ printks in drivers/gsc_hpdi.c
    
    fixed below checkpatch warning.
    - WARNING: Prefer netdev_warn(netdev, ... then dev_warn(dev, ... then pr_warn(...  to printk(KERN_WARNING ...
    
    some of them have been replaced by dev_dbg.
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 17aec51343b8..48092958d73b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -479,7 +479,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i;
 	int retval;
 
-	printk(KERN_WARNING "comedi%d: gsc_hpdi\n", dev->minor);
+	dev_dbg(dev->class_dev, "gsc_hpdi\n");
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -510,17 +510,17 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		} while (pcidev != NULL);
 	}
 	if (dev->board_ptr == NULL) {
-		printk(KERN_WARNING "gsc_hpdi: no hpdi card found\n");
+		dev_warn(dev->class_dev, "no hpdi card found\n");
 		return -EIO;
 	}
 
-	printk(KERN_WARNING
-	       "gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
-	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	dev_warn(dev->class_dev,
+		 "found %s on bus %i, slot %i\n", board(dev)->name,
+		 pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
-		printk(KERN_WARNING
-		       " failed enable PCI device and request regions\n");
+		dev_warn(dev->class_dev,
+			 "failed enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -541,7 +541,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    ioremap(devpriv->hpdi_phys_iobase,
 		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
 	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
-		printk(KERN_WARNING " failed to remap io memory\n");
+		dev_warn(dev->class_dev, "failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
@@ -553,13 +553,13 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			dev->driver->driver_name, dev)) {
-		printk(KERN_WARNING
-		       " unable to allocate irq %u\n", pcidev->irq);
+		dev_warn(dev->class_dev,
+			 "unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
 	}
 	dev->irq = pcidev->irq;
 
-	printk(KERN_WARNING " irq %u\n", dev->irq);
+	dev_dbg(dev->class_dev, " irq %u\n", dev->irq);
 
 	/*  allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
@@ -577,8 +577,8 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 						   &devpriv->
 						   dma_desc_phys_addr);
 	if (devpriv->dma_desc_phys_addr & 0xf) {
-		printk(KERN_WARNING
-		       " dma descriptors not quad-word aligned (bug)\n");
+		dev_warn(dev->class_dev,
+			 " dma descriptors not quad-word aligned (bug)\n");
 		return -EIO;
 	}
 

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 550f458cb59c..17aec51343b8 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -481,10 +481,10 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	printk(KERN_WARNING "comedi%d: gsc_hpdi\n", dev->minor);
 
-	retval = alloc_private(dev, sizeof(*devpriv));
-	if (retval)
-		return retval;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	pcidev = NULL;
 	for (i = 0; i < ARRAY_SIZE(hpdi_boards) &&

commit aa3d94732f80d65a0d0a8a1eef6a0c1d291002bc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:13:50 2012 -0700

    staging: comedi: gsc_hpdi: remove inline priv() function
    
    The inline priv() function simply returns the dev->private pointer
    to the private data.
    
    Remove the inline function and just use a local variable where the
    private data is used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 517ba3a40fef..550f458cb59c 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -244,27 +244,24 @@ struct hpdi_private {
 	unsigned dio_config_output:1;
 };
 
-static inline struct hpdi_private *priv(struct comedi_device *dev)
-{
-	return dev->private;
-}
-
 static int dio_config_insn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct hpdi_private *devpriv = dev->private;
+
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		priv(dev)->dio_config_output = 1;
+		devpriv->dio_config_output = 1;
 		return insn->n;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		priv(dev)->dio_config_output = 0;
+		devpriv->dio_config_output = 0;
 		return insn->n;
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-		    priv(dev)->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    devpriv->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	case INSN_CONFIG_BLOCK_SIZE:
@@ -279,21 +276,24 @@ static int dio_config_insn(struct comedi_device *dev,
 
 static void disable_plx_interrupts(struct comedi_device *dev)
 {
-	writel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	struct hpdi_private *devpriv = dev->private;
+
+	writel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 /* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device *dev)
 {
+	struct hpdi_private *devpriv = dev->private;
 	uint32_t bits;
-	void __iomem *plx_iobase = priv(dev)->plx9080_iobase;
+	void __iomem *plx_iobase = devpriv->plx9080_iobase;
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
 		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
 	DEBUG_PRINT(" plx control reg 0x%x\n",
-		    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
+		    readl(devpriv->plx9080_iobase + PLX_CONTROL_REG));
 
 	DEBUG_PRINT(" plx revision 0x%x\n",
 		    readl(plx_iobase + PLX_REVISION_REG));
@@ -319,7 +319,7 @@ static void init_plx9080(struct comedi_device *dev)
 #else
 	bits = 0;
 #endif
-	writel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);
+	writel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);
 
 	disable_plx_interrupts(dev);
 
@@ -380,28 +380,29 @@ static int setup_subdevices(struct comedi_device *dev)
 
 static int init_hpdi(struct comedi_device *dev)
 {
+	struct hpdi_private *devpriv = dev->private;
 	uint32_t plx_intcsr_bits;
 
-	writel(BOARD_RESET_BIT, priv(dev)->hpdi_iobase + BOARD_CONTROL_REG);
+	writel(BOARD_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);
 	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
+	       devpriv->hpdi_iobase + RX_PROG_ALMOST_REG);
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-	       priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
+	       devpriv->hpdi_iobase + TX_PROG_ALMOST_REG);
 
-	priv(dev)->tx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
+	devpriv->tx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
 						  TX_FIFO_SIZE_REG));
-	priv(dev)->rx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
+	devpriv->rx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +
 						  RX_FIFO_SIZE_REG));
 
-	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	/*  enable interrupts */
 	plx_intcsr_bits =
 	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 	    ICS_DMA0_E;
-	writel(plx_intcsr_bits, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	writel(plx_intcsr_bits, devpriv->plx9080_iobase + PLX_INTRCS_REG);
 
 	return 0;
 }
@@ -410,6 +411,7 @@ static int init_hpdi(struct comedi_device *dev)
 static int setup_dma_descriptors(struct comedi_device *dev,
 				 unsigned int transfer_size)
 {
+	struct hpdi_private *devpriv = dev->private;
 	unsigned int buffer_index, buffer_offset;
 	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
 	    PLX_XFER_LOCAL_TO_PCI;
@@ -423,25 +425,25 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 
 	DEBUG_PRINT(" transfer_size %i\n", transfer_size);
 	DEBUG_PRINT(" descriptors at 0x%lx\n",
-		    (unsigned long)priv(dev)->dma_desc_phys_addr);
+		    (unsigned long)devpriv->dma_desc_phys_addr);
 
 	buffer_offset = 0;
 	buffer_index = 0;
 	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
 	     buffer_index < NUM_DMA_BUFFERS; i++) {
-		priv(dev)->dma_desc[i].pci_start_addr =
-		    cpu_to_le32(priv(dev)->dio_buffer_phys_addr[buffer_index] +
+		devpriv->dma_desc[i].pci_start_addr =
+		    cpu_to_le32(devpriv->dio_buffer_phys_addr[buffer_index] +
 				buffer_offset);
-		priv(dev)->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
-		priv(dev)->dma_desc[i].transfer_size =
+		devpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
+		devpriv->dma_desc[i].transfer_size =
 		    cpu_to_le32(transfer_size);
-		priv(dev)->dma_desc[i].next =
-		    cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
+		devpriv->dma_desc[i].next =
+		    cpu_to_le32((devpriv->dma_desc_phys_addr + (i +
 								  1) *
-				 sizeof(priv(dev)->dma_desc[0])) | next_bits);
+				 sizeof(devpriv->dma_desc[0])) | next_bits);
 
-		priv(dev)->desc_dio_buffer[i] =
-		    priv(dev)->dio_buffer[buffer_index] +
+		devpriv->desc_dio_buffer[i] =
+		    devpriv->dio_buffer[buffer_index] +
 		    (buffer_offset / sizeof(uint32_t));
 
 		buffer_offset += transfer_size;
@@ -452,34 +454,37 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 
 		DEBUG_PRINT(" desc %i\n", i);
 		DEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",
-			    priv(dev)->desc_dio_buffer[i],
-			    (unsigned long)priv(dev)->dma_desc[i].
+			    devpriv->desc_dio_buffer[i],
+			    (unsigned long)devpriv->dma_desc[i].
 			    pci_start_addr);
 		DEBUG_PRINT(" next 0x%lx\n",
-			    (unsigned long)priv(dev)->dma_desc[i].next);
+			    (unsigned long)devpriv->dma_desc[i].next);
 	}
-	priv(dev)->num_dma_descriptors = i;
+	devpriv->num_dma_descriptors = i;
 	/*  fix last descriptor to point back to first */
-	priv(dev)->dma_desc[i - 1].next =
-	    cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
+	devpriv->dma_desc[i - 1].next =
+	    cpu_to_le32(devpriv->dma_desc_phys_addr | next_bits);
 	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
-		    (unsigned long)priv(dev)->dma_desc[i - 1].next);
+		    (unsigned long)devpriv->dma_desc[i - 1].next);
 
-	priv(dev)->block_size = transfer_size;
+	devpriv->block_size = transfer_size;
 
 	return transfer_size;
 }
 
 static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	struct hpdi_private *devpriv;
 	struct pci_dev *pcidev;
 	int i;
 	int retval;
 
 	printk(KERN_WARNING "comedi%d: gsc_hpdi\n", dev->minor);
 
-	if (alloc_private(dev, sizeof(struct hpdi_private)) < 0)
-		return -ENOMEM;
+	retval = alloc_private(dev, sizeof(*devpriv));
+	if (retval)
+		return retval;
+	devpriv = dev->private;
 
 	pcidev = NULL;
 	for (i = 0; i < ARRAY_SIZE(hpdi_boards) &&
@@ -498,7 +503,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					continue;
 			}
 			if (pcidev) {
-				priv(dev)->hw_dev = pcidev;
+				devpriv->hw_dev = pcidev;
 				dev->board_ptr = hpdi_boards + i;
 				break;
 			}
@@ -523,25 +528,25 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* Initialize dev->board_name */
 	dev->board_name = board(dev)->name;
 
-	priv(dev)->plx9080_phys_iobase =
+	devpriv->plx9080_phys_iobase =
 	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
-	priv(dev)->hpdi_phys_iobase =
+	devpriv->hpdi_phys_iobase =
 	    pci_resource_start(pcidev, HPDI_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
-	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
+	devpriv->plx9080_iobase = ioremap(devpriv->plx9080_phys_iobase,
 					    pci_resource_len(pcidev,
 					    PLX9080_BADDRINDEX));
-	priv(dev)->hpdi_iobase =
-	    ioremap(priv(dev)->hpdi_phys_iobase,
+	devpriv->hpdi_iobase =
+	    ioremap(devpriv->hpdi_phys_iobase,
 		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
-	if (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {
+	if (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {
 		printk(KERN_WARNING " failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
-	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
-	DEBUG_PRINT(" hpdi remapped to 0x%p\n", priv(dev)->hpdi_iobase);
+	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);
+	DEBUG_PRINT(" hpdi remapped to 0x%p\n", devpriv->hpdi_iobase);
 
 	init_plx9080(dev);
 
@@ -558,20 +563,20 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-		priv(dev)->dio_buffer[i] =
-		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
-					 &priv(dev)->dio_buffer_phys_addr[i]);
+		devpriv->dio_buffer[i] =
+		    pci_alloc_consistent(devpriv->hw_dev, DMA_BUFFER_SIZE,
+					 &devpriv->dio_buffer_phys_addr[i]);
 		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
-			    priv(dev)->dio_buffer[i],
-			    (unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
+			    devpriv->dio_buffer[i],
+			    (unsigned long)devpriv->dio_buffer_phys_addr[i]);
 	}
 	/*  allocate dma descriptors */
-	priv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,
+	devpriv->dma_desc = pci_alloc_consistent(devpriv->hw_dev,
 						   sizeof(struct plx_dma_desc) *
 						   NUM_DMA_DESCRIPTORS,
-						   &priv(dev)->
+						   &devpriv->
 						   dma_desc_phys_addr);
-	if (priv(dev)->dma_desc_phys_addr & 0xf) {
+	if (devpriv->dma_desc_phys_addr & 0xf) {
 		printk(KERN_WARNING
 		       " dma descriptors not quad-word aligned (bug)\n");
 		return -EIO;
@@ -590,39 +595,36 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void hpdi_detach(struct comedi_device *dev)
 {
+	struct hpdi_private *devpriv = dev->private;
 	unsigned int i;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if ((priv(dev)) && (priv(dev)->hw_dev)) {
-		if (priv(dev)->plx9080_iobase) {
+	if (devpriv && devpriv->hw_dev) {
+		if (devpriv->plx9080_iobase) {
 			disable_plx_interrupts(dev);
-			iounmap(priv(dev)->plx9080_iobase);
+			iounmap(devpriv->plx9080_iobase);
 		}
-		if (priv(dev)->hpdi_iobase)
-			iounmap(priv(dev)->hpdi_iobase);
+		if (devpriv->hpdi_iobase)
+			iounmap(devpriv->hpdi_iobase);
 		/*  free pci dma buffers */
 		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-			if (priv(dev)->dio_buffer[i])
-				pci_free_consistent(priv(dev)->hw_dev,
-						    DMA_BUFFER_SIZE,
-						    priv(dev)->
-						    dio_buffer[i],
-						    priv
-						    (dev)->dio_buffer_phys_addr
-						    [i]);
+			if (devpriv->dio_buffer[i])
+				pci_free_consistent(devpriv->hw_dev,
+					DMA_BUFFER_SIZE,
+					devpriv->dio_buffer[i],
+					devpriv->dio_buffer_phys_addr[i]);
 		}
 		/*  free dma descriptors */
-		if (priv(dev)->dma_desc)
-			pci_free_consistent(priv(dev)->hw_dev,
-					    sizeof(struct plx_dma_desc)
-					    * NUM_DMA_DESCRIPTORS,
-					    priv(dev)->dma_desc,
-					    priv(dev)->
-					    dma_desc_phys_addr);
-		if (priv(dev)->hpdi_phys_iobase)
-			comedi_pci_disable(priv(dev)->hw_dev);
-		pci_dev_put(priv(dev)->hw_dev);
+		if (devpriv->dma_desc)
+			pci_free_consistent(devpriv->hw_dev,
+				sizeof(struct plx_dma_desc) *
+				NUM_DMA_DESCRIPTORS,
+				devpriv->dma_desc,
+				devpriv-> dma_desc_phys_addr);
+		if (devpriv->hpdi_phys_iobase)
+			comedi_pci_disable(devpriv->hw_dev);
+		pci_dev_put(devpriv->hw_dev);
 	}
 }
 
@@ -726,7 +728,9 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	if (priv(dev)->dio_config_output)
+	struct hpdi_private *devpriv = dev->private;
+
+	if (devpriv->dio_config_output)
 		return -EINVAL;
 	else
 		return di_cmd_test(dev, s, cmd);
@@ -735,12 +739,15 @@ static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 			       unsigned int offset)
 {
-	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
-	       priv(dev)->hpdi_iobase + offset);
+	struct hpdi_private *devpriv = dev->private;
+
+	writel(bits | devpriv->bits[offset / sizeof(uint32_t)],
+	       devpriv->hpdi_iobase + offset);
 }
 
 static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct hpdi_private *devpriv = dev->private;
 	uint32_t bits;
 	unsigned long flags;
 	struct comedi_async *async = s->async;
@@ -752,39 +759,39 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	abort_dma(dev, 0);
 
-	priv(dev)->dma_desc_index = 0;
+	devpriv->dma_desc_index = 0;
 
 	/* These register are supposedly unused during chained dma,
 	 * but I have found that left over values from last operation
 	 * occasionally cause problems with transfer of first dma
 	 * block.  Initializing them to zero seems to fix the problem. */
-	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
-	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
-	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	writel(0, devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 	/*  give location of first dma descriptor */
 	bits =
-	    priv(dev)->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
+	    devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
 	    PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
-	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+	writel(bits, devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-	       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		priv(dev)->dio_count = cmd->stop_arg;
+		devpriv->dio_count = cmd->stop_arg;
 	else
-		priv(dev)->dio_count = 1;
+		devpriv->dio_count = 1;
 
 	/*  clear over/under run status flags */
 	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-	       priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+	       devpriv->hpdi_iobase + BOARD_STATUS_REG);
 	/*  enable interrupts */
 	writel(intr_bit(RX_FULL_INTR),
-	       priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	       devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	DEBUG_PRINT("hpdi: starting rx\n");
 	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
@@ -794,7 +801,9 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (priv(dev)->dio_config_output)
+	struct hpdi_private *devpriv = dev->private;
+
+	if (devpriv->dio_config_output)
 		return -EINVAL;
 	else
 		return di_cmd(dev, s);
@@ -802,6 +811,7 @@ static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
+	struct hpdi_private *devpriv = dev->private;
 	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
 	int j;
@@ -810,37 +820,37 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 
 	if (channel)
 		pci_addr_reg =
-		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	j = 0;
 	for (next_transfer_addr = readl(pci_addr_reg);
 	     (next_transfer_addr <
-	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+	      le32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].
 			  pci_start_addr)
 	      || next_transfer_addr >=
-	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
-			  pci_start_addr) + priv(dev)->block_size)
-	     && j < priv(dev)->num_dma_descriptors; j++) {
+	      le32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].
+			  pci_start_addr) + devpriv->block_size)
+	     && j < devpriv->num_dma_descriptors; j++) {
 		/*  transfer data from dma buffer to comedi buffer */
-		num_samples = priv(dev)->block_size / sizeof(uint32_t);
+		num_samples = devpriv->block_size / sizeof(uint32_t);
 		if (async->cmd.stop_src == TRIG_COUNT) {
-			if (num_samples > priv(dev)->dio_count)
-				num_samples = priv(dev)->dio_count;
-			priv(dev)->dio_count -= num_samples;
+			if (num_samples > devpriv->dio_count)
+				num_samples = devpriv->dio_count;
+			devpriv->dio_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-					  priv(dev)->desc_dio_buffer[priv(dev)->
+					  devpriv->desc_dio_buffer[devpriv->
 								     dma_desc_index],
 					  num_samples * sizeof(uint32_t));
-		priv(dev)->dma_desc_index++;
-		priv(dev)->dma_desc_index %= priv(dev)->num_dma_descriptors;
+		devpriv->dma_desc_index++;
+		devpriv->dma_desc_index %= devpriv->num_dma_descriptors;
 
 		DEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)
-			    priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			    devpriv->dma_desc[devpriv->dma_desc_index].
 			    next);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
@@ -850,6 +860,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 static irqreturn_t handle_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct hpdi_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	uint32_t hpdi_intr_status, hpdi_board_status;
@@ -861,26 +872,26 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	plx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	plx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);
 	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
 
-	hpdi_intr_status = readl(priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
-	hpdi_board_status = readl(priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+	hpdi_intr_status = readl(devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
+	hpdi_board_status = readl(devpriv->hpdi_iobase + BOARD_STATUS_REG);
 
 	async->events = 0;
 
 	if (hpdi_intr_status) {
 		DEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);
 		writel(hpdi_intr_status,
-		       priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
+		       devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	dma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA0_CS_REG);
 
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT)
@@ -891,10 +902,10 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+	dma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       devpriv->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
@@ -903,8 +914,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
-		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
-		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		plx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
+		writel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);
 		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
 	}
 
@@ -912,7 +923,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		comedi_error(dev, "rx fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		DEBUG_PRINT("dma0_status 0x%x\n",
-			    (int)readb(priv(dev)->plx9080_iobase +
+			    (int)readb(devpriv->plx9080_iobase +
 				       PLX_DMA0_CS_REG));
 	}
 
@@ -921,7 +932,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 
-	if (priv(dev)->dio_count == 0)
+	if (devpriv->dio_count == 0)
 		async->events |= COMEDI_CB_EOA;
 
 	DEBUG_PRINT("board status 0x%x, ", hpdi_board_status);
@@ -936,21 +947,24 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 static void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
+	struct hpdi_private *devpriv = dev->private;
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 
-	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
+	plx9080_abort_dma(devpriv->plx9080_iobase, channel);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct hpdi_private *devpriv = dev->private;
+
 	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
 
-	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	writel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	abort_dma(dev, 0);
 

commit b776d05b9307972f079b56b6cbf74349a6451a53
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 15 11:58:34 2012 +0100

    staging: comedi: gsc_hpdi: make internal functions static
    
    This module does not export any symbols so declare all the functions as
    `static` and remove the unused ones.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index abff6603952a..517ba3a40fef 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -104,35 +104,11 @@ enum hpdi_registers {
 	INTERRUPT_POLARITY_REG = 0x54,
 };
 
-int command_channel_valid(unsigned int channel)
-{
-	if (channel == 0 || channel > 6) {
-		printk(KERN_WARNING
-		       "gsc_hpdi: bug! invalid cable command channel\n");
-		return 0;
-	}
-	return 1;
-}
-
 /* bit definitions */
 
 enum firmware_revision_bits {
 	FEATURES_REG_PRESENT_BIT = 0x8000,
 };
-int firmware_revision(uint32_t fwr_bits)
-{
-	return fwr_bits & 0xff;
-}
-
-int pcb_revision(uint32_t fwr_bits)
-{
-	return (fwr_bits >> 8) & 0xff;
-}
-
-int hpdi_subid(uint32_t fwr_bits)
-{
-	return (fwr_bits >> 16) & 0xff;
-}
 
 enum board_control_bits {
 	BOARD_RESET_BIT = 0x1,	/* wait 10usec before accessing fifos */
@@ -147,22 +123,6 @@ enum board_control_bits {
 	CABLE_THROTTLE_ENABLE_BIT = 0x20,
 	TEST_MODE_ENABLE_BIT = 0x80000000,
 };
-uint32_t command_discrete_output_bits(unsigned int channel, int output,
-				      int output_value)
-{
-	uint32_t bits = 0;
-
-	if (command_channel_valid(channel) == 0)
-		return 0;
-	if (output) {
-		bits |= 0x1 << (16 + channel);
-		if (output_value)
-			bits |= 0x1 << (24 + channel);
-	} else
-		bits |= 0x1 << (24 + channel);
-
-	return bits;
-}
 
 enum board_status_bits {
 	COMMAND_LINE_STATUS_MASK = 0x7f,
@@ -182,28 +142,17 @@ enum board_status_bits {
 	RX_OVERRUN_BIT = 0x800000,
 };
 
-uint32_t almost_full_bits(unsigned int num_words)
+static uint32_t almost_full_bits(unsigned int num_words)
 {
-/* XXX need to add or subtract one? */
+	/* XXX need to add or subtract one? */
 	return (num_words << 16) & 0xff0000;
 }
 
-uint32_t almost_empty_bits(unsigned int num_words)
+static uint32_t almost_empty_bits(unsigned int num_words)
 {
 	return num_words & 0xffff;
 }
 
-unsigned int almost_full_num_words(uint32_t bits)
-{
-/* XXX need to add or subtract one? */
-	return (bits >> 16) & 0xffff;
-}
-
-unsigned int almost_empty_num_words(uint32_t bits)
-{
-	return bits & 0xffff;
-}
-
 enum features_bits {
 	FIFO_SIZE_PRESENT_BIT = 0x1,
 	FIFO_WORDS_PRESENT_BIT = 0x2,
@@ -225,43 +174,17 @@ enum interrupt_sources {
 	RX_ALMOST_FULL_INTR = 14,
 	RX_FULL_INTR = 15,
 };
-int command_intr_source(unsigned int channel)
-{
-	if (command_channel_valid(channel) == 0)
-		channel = 1;
-	return channel + 1;
-}
 
-uint32_t intr_bit(int interrupt_source)
+static uint32_t intr_bit(int interrupt_source)
 {
 	return 0x1 << interrupt_source;
 }
 
-uint32_t tx_clock_divisor_bits(unsigned int divisor)
-{
-	return divisor & 0xff;
-}
-
-unsigned int fifo_size(uint32_t fifo_size_bits)
+static unsigned int fifo_size(uint32_t fifo_size_bits)
 {
 	return fifo_size_bits & 0xfffff;
 }
 
-unsigned int fifo_words(uint32_t fifo_words_bits)
-{
-	return fifo_words_bits & 0xfffff;
-}
-
-uint32_t intr_edge_bit(int interrupt_source)
-{
-	return 0x1 << interrupt_source;
-}
-
-uint32_t intr_active_high_bit(int interrupt_source)
-{
-	return 0x1 << interrupt_source;
-}
-
 struct hpdi_board {
 
 	char *name;

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 5d3fa711a515..abff6603952a 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -723,45 +723,24 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 		       struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
 	int i;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually
-	 * compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/*  uniqueness check */
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 2de13f1bac495eb354a442963dfc1eb5e7d5b134
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:43:20 2012 -0700

    staging: comedi: gsc_hpdi: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 79f580841dee..5d3fa711a515 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -436,7 +436,7 @@ static int setup_subdevices(struct comedi_device *dev)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	dev->read_subdev = s;
 /*	dev->write_subdev = s; */

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b103cfbf3274..79f580841dee 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -430,9 +430,11 @@ static void init_plx9080(struct comedi_device *dev)
 static int setup_subdevices(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
+	int ret;
 
-	if (comedi_alloc_subdevices(dev, 1) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 1);
+	if (ret)
+		return ret;
 
 	s = dev->subdevices + 0;
 	/* analog input subdevice */

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index fe1fd2f75f0d..b103cfbf3274 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -431,7 +431,7 @@ static int setup_subdevices(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
 
-	if (alloc_subdevices(dev, 1) < 0)
+	if (comedi_alloc_subdevices(dev, 1) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit bc04bec0e0c982dfc90e206ea51f19bd650ccee2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun May 27 01:45:19 2012 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typo in comments within staging/comedi.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index eeb05553e1a7..fe1fd2f75f0d 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -631,7 +631,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	printk(KERN_WARNING " irq %u\n", dev->irq);
 
-	/*  alocate pci dma buffers */
+	/*  allocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dio_buffer[i] =
 		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,

commit ff450314d5ef05843d3b3bd33fc65f7aaea3b2df
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:52:07 2012 -0700

    staging: comedi: gsc_hpdi: plx9080_iobase and hpdi_iobase are void __iomem *
    
    The plx9080_iobase and hpdi_iobase variables in struct hpdi_private
    are ioremap'ed pci resource and should be void __iomem * not void *.
    
    This quiets a lot of sparse warings for the writel and readl calls
    like:
    
    warning: incorrect type in argument 1 (different address spaces)
       expected void const volatile [noderef] <asn:2>*addr
       got void *<noident>
    
    warning: incorrect type in argument 2 (different address spaces)
       expected void volatile [noderef] <asn:2>*addr
       got void *
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 79e22b13f734..eeb05553e1a7 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -296,8 +296,8 @@ struct hpdi_private {
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t hpdi_phys_iobase;
 	/*  base addresses (ioremapped) */
-	void *plx9080_iobase;
-	void *hpdi_iobase;
+	void __iomem *plx9080_iobase;
+	void __iomem *hpdi_iobase;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
 	/* physical addresses of dma buffers */
 	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
@@ -363,7 +363,7 @@ static void disable_plx_interrupts(struct comedi_device *dev)
 static void init_plx9080(struct comedi_device *dev)
 {
 	uint32_t bits;
-	void *plx_iobase = priv(dev)->plx9080_iobase;
+	void __iomem *plx_iobase = priv(dev)->plx9080_iobase;
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
@@ -672,10 +672,10 @@ static void hpdi_detach(struct comedi_device *dev)
 	if ((priv(dev)) && (priv(dev)->hw_dev)) {
 		if (priv(dev)->plx9080_iobase) {
 			disable_plx_interrupts(dev);
-			iounmap((void *)priv(dev)->plx9080_iobase);
+			iounmap(priv(dev)->plx9080_iobase);
 		}
 		if (priv(dev)->hpdi_iobase)
-			iounmap((void *)priv(dev)->hpdi_iobase);
+			iounmap(priv(dev)->hpdi_iobase);
 		/*  free pci dma buffers */
 		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 			if (priv(dev)->dio_buffer[i])
@@ -902,7 +902,7 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
-	void *pci_addr_reg;
+	void __iomem *pci_addr_reg;
 
 	if (channel)
 		pci_addr_reg =

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 8aece08bd0dd..79e22b13f734 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -49,7 +49,6 @@ support could be added to this driver.
 #include "../comedidev.h"
 #include <linux/delay.h>
 
-#include "comedi_pci.h"
 #include "plx9080.h"
 #include "comedi_fc.h"
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 3195022fc6f5..8aece08bd0dd 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -664,12 +664,10 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return init_hpdi(dev);
 }
 
-static int hpdi_detach(struct comedi_device *dev)
+static void hpdi_detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
-	printk(KERN_WARNING "comedi%d: gsc_hpdi: remove\n", dev->minor);
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if ((priv(dev)) && (priv(dev)->hw_dev)) {
@@ -702,7 +700,6 @@ static int hpdi_detach(struct comedi_device *dev)
 			comedi_pci_disable(priv(dev)->hw_dev);
 		pci_dev_put(priv(dev)->hw_dev);
 	}
-	return 0;
 }
 
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)

commit 613e91213a0ec9e86a704070627790cc29c35e28
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 16:44:14 2012 -0700

    staging: comedi: refactor gsc_hpdi driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index a7b9f6e1e111..3195022fc6f5 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -53,8 +53,6 @@ support could be added to this driver.
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int hpdi_detach(struct comedi_device *dev);
 static void abort_dma(struct comedi_device *dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
@@ -287,15 +285,6 @@ static const struct hpdi_board hpdi_boards[] = {
 #endif
 };
 
-static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
-	{
-	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
-		    0x2400, 0, 0, 0}, {
-	0}
-};
-
-MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
-
 static inline struct hpdi_board *board(const struct comedi_device *dev)
 {
 	return (struct hpdi_board *)dev->board_ptr;
@@ -338,51 +327,6 @@ static inline struct hpdi_private *priv(struct comedi_device *dev)
 	return dev->private;
 }
 
-static struct comedi_driver driver_hpdi = {
-	.driver_name = "gsc_hpdi",
-	.module = THIS_MODULE,
-	.attach = hpdi_attach,
-	.detach = hpdi_detach,
-};
-
-static int __devinit driver_hpdi_pci_probe(struct pci_dev *dev,
-					   const struct pci_device_id *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_hpdi);
-}
-
-static void __devexit driver_hpdi_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_hpdi_pci_driver = {
-	.id_table = hpdi_pci_table,
-	.probe = &driver_hpdi_pci_probe,
-	.remove = __devexit_p(&driver_hpdi_pci_remove)
-};
-
-static int __init driver_hpdi_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_hpdi);
-	if (retval < 0)
-		return retval;
-
-	driver_hpdi_pci_driver.name = (char *)driver_hpdi.driver_name;
-	return pci_register_driver(&driver_hpdi_pci_driver);
-}
-
-static void __exit driver_hpdi_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_hpdi_pci_driver);
-	comedi_driver_unregister(&driver_hpdi);
-}
-
-module_init(driver_hpdi_init_module);
-module_exit(driver_hpdi_cleanup_module);
-
 static int dio_config_insn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
@@ -645,7 +589,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	       "gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
 	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
-	if (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {
+	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		printk(KERN_WARNING
 		       " failed enable PCI device and request regions\n");
 		return -EIO;
@@ -679,7 +623,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
-			driver_hpdi.driver_name, dev)) {
+			dev->driver->driver_name, dev)) {
 		printk(KERN_WARNING
 		       " unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
@@ -1113,6 +1057,39 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static struct comedi_driver gsc_hpdi_driver = {
+	.driver_name	= "gsc_hpdi",
+	.module		= THIS_MODULE,
+	.attach		= hpdi_attach,
+	.detach		= hpdi_detach,
+};
+
+static int __devinit gsc_hpdi_pci_probe(struct pci_dev *dev,
+					const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &gsc_hpdi_driver);
+}
+
+static void __devexit gsc_hpdi_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(gsc_hpdi_pci_table) = {
+	{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
+		    0x2400, 0, 0, 0},
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, gsc_hpdi_pci_table);
+
+static struct pci_driver gsc_hpdi_pci_driver = {
+	.name		= "gsc_hpdi",
+	.id_table	= gsc_hpdi_pci_table,
+	.probe		= gsc_hpdi_pci_probe,
+	.remove		= __devexit_p(gsc_hpdi_pci_remove)
+};
+module_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index bc020dea141b..a7b9f6e1e111 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -348,7 +348,7 @@ static struct comedi_driver driver_hpdi = {
 static int __devinit driver_hpdi_pci_probe(struct pci_dev *dev,
 					   const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_hpdi.driver_name);
+	return comedi_pci_auto_config(dev, &driver_hpdi);
 }
 
 static void __devexit driver_hpdi_pci_remove(struct pci_dev *dev)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 1661b57ca2ad..bc020dea141b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -1031,7 +1031,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		writel(hpdi_intr_status,
 		       priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
@@ -1045,7 +1045,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index a24d0994a195..1661b57ca2ad 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -345,7 +345,43 @@ static struct comedi_driver driver_hpdi = {
 	.detach = hpdi_detach,
 };
 
-COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
+static int __devinit driver_hpdi_pci_probe(struct pci_dev *dev,
+					   const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_hpdi.driver_name);
+}
+
+static void __devexit driver_hpdi_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_hpdi_pci_driver = {
+	.id_table = hpdi_pci_table,
+	.probe = &driver_hpdi_pci_probe,
+	.remove = __devexit_p(&driver_hpdi_pci_remove)
+};
+
+static int __init driver_hpdi_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_hpdi);
+	if (retval < 0)
+		return retval;
+
+	driver_hpdi_pci_driver.name = (char *)driver_hpdi.driver_name;
+	return pci_register_driver(&driver_hpdi_pci_driver);
+}
+
+static void __exit driver_hpdi_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_hpdi_pci_driver);
+	comedi_driver_unregister(&driver_hpdi);
+}
+
+module_init(driver_hpdi_init_module);
+module_exit(driver_hpdi_cleanup_module);
 
 static int dio_config_insn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 17c4f1f8117d..a24d0994a195 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -1076,3 +1076,7 @@ static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 4c67da06f0248fc0ee0fcbf65afd887b023b4591
Author: Mark Rankilor <reodge@gmail.com>
Date:   Thu May 27 17:39:15 2010 +0800

    Staging: comedi: Fixed long lines in gsc_hpdi.c
    
    This patch fixes some long line lengths in gsc_hpdi.c as found by the
    checkpatch.pl tool
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 51f12bf45cf1..17c4f1f8117d 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -311,17 +311,25 @@ struct hpdi_private {
 	void *plx9080_iobase;
 	void *hpdi_iobase;
 	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
-	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];	/*  physical addresses of dma buffers */
-	struct plx_dma_desc *dma_desc;	/*  array of dma descriptors read by plx9080, allocated to get proper alignment */
-	dma_addr_t dma_desc_phys_addr;	/*  physical address of dma descriptor array */
+	/* physical addresses of dma buffers */
+	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];
+	/* array of dma descriptors read by plx9080, allocated to get proper
+	 * alignment */
+	struct plx_dma_desc *dma_desc;
+	/* physical address of dma descriptor array */
+	dma_addr_t dma_desc_phys_addr;
 	unsigned int num_dma_descriptors;
-	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];	/*  pointer to start of buffers indexed by descriptor */
-	volatile unsigned int dma_desc_index;	/*  index of the dma descriptor that is currently being used */
+	/* pointer to start of buffers indexed by descriptor */
+	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];
+	/* index of the dma descriptor that is currently being used */
+	volatile unsigned int dma_desc_index;
 	unsigned int tx_fifo_size;
 	unsigned int rx_fifo_size;
 	volatile unsigned long dio_count;
-	volatile uint32_t bits[24];	/*  software copies of values written to hpdi registers */
-	volatile unsigned int block_size;	/*  number of bytes at which to generate COMEDI_CB_BLOCK events */
+	/* software copies of values written to hpdi registers */
+	volatile uint32_t bits[24];
+	/* number of bytes at which to generate COMEDI_CB_BLOCK events */
+	volatile unsigned int block_size;
 	unsigned dio_config_output:1;
 };
 
@@ -570,7 +578,8 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	pcidev = NULL;
-	for (i = 0; i < ARRAY_SIZE(hpdi_boards) && dev->board_ptr == NULL; i++) {
+	for (i = 0; i < ARRAY_SIZE(hpdi_boards) &&
+		    dev->board_ptr == NULL; i++) {
 		do {
 			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
 						hpdi_boards[i].device_id,
@@ -618,7 +627,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
 					    pci_resource_len(pcidev,
-							     PLX9080_BADDRINDEX));
+					    PLX9080_BADDRINDEX));
 	priv(dev)->hpdi_iobase =
 	    ioremap(priv(dev)->hpdi_phys_iobase,
 		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
@@ -769,7 +778,8 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* step 2: make sure trigger sources are unique and mutually
+	 * compatible */
 
 	/*  uniqueness check */
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)

commit 64ca6a7eb1f55a6d25443ff8918d5aae00093fe5
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Wed Oct 21 01:05:44 2009 -0700

    Staging: comedi: gsc_hdpi: style fixes static function
    
    Convert external function to static
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 346d4c7c0d11..51f12bf45cf1 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -55,7 +55,7 @@ support could be added to this driver.
 
 static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int hpdi_detach(struct comedi_device *dev);
-void abort_dma(struct comedi_device *dev, unsigned int channel);
+static void abort_dma(struct comedi_device *dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd);
@@ -1044,7 +1044,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(struct comedi_device *dev, unsigned int channel)
+static void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
 	unsigned long flags;
 

commit 95a2572f95d5f78ef9fe28c200b21ad2b4b1e0c0
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Wed Oct 21 01:05:43 2009 -0700

    Staging: comedi: gsc_hpdi: Fix style issues
    
    Style cleanup in staging based on Greg's tutorial / checkpatch
    Fix 80 char line length (where useful) - includes two changes to code
    to make it more logical / readable
    Remove {} around single line blocks
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 396fa89a5a6e..346d4c7c0d11 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -143,7 +143,8 @@ enum board_control_bits {
 	RX_FIFO_RESET_BIT = 0x4,
 	TX_ENABLE_BIT = 0x10,
 	RX_ENABLE_BIT = 0x20,
-	DEMAND_DMA_DIRECTION_TX_BIT = 0x40,	/* for channel 0, channel 1 can only transmit (when present) */
+	DEMAND_DMA_DIRECTION_TX_BIT = 0x40,
+		/* for ch 0, ch 1 can only transmit (when present) */
 	LINE_VALID_ON_STATUS_VALID_BIT = 0x80,
 	START_TX_BIT = 0x10,
 	CABLE_THROTTLE_ENABLE_BIT = 0x20,
@@ -421,9 +422,11 @@ static void init_plx9080(struct comedi_device *dev)
 	bits |= PLX_DMA_EN_READYIN_BIT;
 	/*  enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	/*  enable interrupt on dma done (probably don't need this, since chain never finishes) */
+	/*  enable interrupt on dma done
+	 *  (probably don't need this, since chain never finishes) */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	/*  don't increment local address during transfers (we are transferring from a fixed fifo register) */
+	/*  don't increment local address during transfers
+	 *  (we are transferring from a fixed fifo register) */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
 	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
@@ -680,38 +683,35 @@ static int hpdi_detach(struct comedi_device *dev)
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (priv(dev)) {
-		if (priv(dev)->hw_dev) {
-			if (priv(dev)->plx9080_iobase) {
-				disable_plx_interrupts(dev);
-				iounmap((void *)priv(dev)->plx9080_iobase);
-			}
-			if (priv(dev)->hpdi_iobase)
-				iounmap((void *)priv(dev)->hpdi_iobase);
-			/*  free pci dma buffers */
-			for (i = 0; i < NUM_DMA_BUFFERS; i++) {
-				if (priv(dev)->dio_buffer[i])
-					pci_free_consistent(priv(dev)->hw_dev,
-							    DMA_BUFFER_SIZE,
-							    priv(dev)->
-							    dio_buffer[i],
-							    priv
-							    (dev)->dio_buffer_phys_addr
-							    [i]);
-			}
-			/*  free dma descriptors */
-			if (priv(dev)->dma_desc)
+	if ((priv(dev)) && (priv(dev)->hw_dev)) {
+		if (priv(dev)->plx9080_iobase) {
+			disable_plx_interrupts(dev);
+			iounmap((void *)priv(dev)->plx9080_iobase);
+		}
+		if (priv(dev)->hpdi_iobase)
+			iounmap((void *)priv(dev)->hpdi_iobase);
+		/*  free pci dma buffers */
+		for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+			if (priv(dev)->dio_buffer[i])
 				pci_free_consistent(priv(dev)->hw_dev,
-						    sizeof(struct plx_dma_desc)
-						    * NUM_DMA_DESCRIPTORS,
-						    priv(dev)->dma_desc,
+						    DMA_BUFFER_SIZE,
 						    priv(dev)->
-						    dma_desc_phys_addr);
-			if (priv(dev)->hpdi_phys_iobase) {
-				comedi_pci_disable(priv(dev)->hw_dev);
-			}
-			pci_dev_put(priv(dev)->hw_dev);
+						    dio_buffer[i],
+						    priv
+						    (dev)->dio_buffer_phys_addr
+						    [i]);
 		}
+		/*  free dma descriptors */
+		if (priv(dev)->dma_desc)
+			pci_free_consistent(priv(dev)->hw_dev,
+					    sizeof(struct plx_dma_desc)
+					    * NUM_DMA_DESCRIPTORS,
+					    priv(dev)->dma_desc,
+					    priv(dev)->
+					    dma_desc_phys_addr);
+		if (priv(dev)->hpdi_phys_iobase)
+			comedi_pci_disable(priv(dev)->hw_dev);
+		pci_dev_put(priv(dev)->hw_dev);
 	}
 	return 0;
 }
@@ -814,15 +814,16 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 	if (err)
 		return 4;
 
-	if (cmd->chanlist) {
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) != i) {
-				/*  XXX could support 8 channels or 16 channels */
-				comedi_error(dev,
-					     "chanlist must be channels 0 to 31 in order");
-				err++;
-				break;
-			}
+	if (!cmd->chanlist)
+		return 0;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		if (CR_CHAN(cmd->chanlist[i]) != i) {
+			/*  XXX could support 8 or 16 channels */
+			comedi_error(dev,
+				     "chanlist must be ch 0 to 31 in order");
+			err++;
+			break;
 		}
 	}
 
@@ -835,9 +836,9 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_cmd *cmd)
 {
-	if (priv(dev)->dio_config_output) {
+	if (priv(dev)->dio_config_output)
 		return -EINVAL;
-	} else
+	else
 		return di_cmd_test(dev, s, cmd);
 }
 
@@ -903,9 +904,9 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	if (priv(dev)->dio_config_output) {
+	if (priv(dev)->dio_config_output)
 		return -EINVAL;
-	} else
+	else
 		return di_cmd(dev, s);
 }
 
@@ -967,14 +968,12 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	uint8_t dma0_status, dma1_status;
 	unsigned long flags;
 
-	if (!dev->attached) {
+	if (!dev->attached)
 		return IRQ_NONE;
-	}
 
 	plx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
-	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0) {
+	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)
 		return IRQ_NONE;
-	}
 
 	hpdi_intr_status = readl(priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	hpdi_board_status = readl(priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
@@ -994,9 +993,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
-		if (dma0_status & PLX_DMA_EN_BIT) {
+		if (dma0_status & PLX_DMA_EN_BIT)
 			drain_dma_buffers(dev, 0);
-		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);

commit 92e462c3a576a3fd7d7bed144d405ed1a4284ad8
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Wed Oct 21 01:05:42 2009 -0700

    Staging: comedi: gsc_hpdi: style fixes printk
    
    Style cleanup in staging based on Greg's tutorial / checkpatch
    Add printk KERN_ facility level (KERN_WARNING seemed appropriate for all)
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 0bb30162e92c..396fa89a5a6e 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -110,7 +110,8 @@ enum hpdi_registers {
 int command_channel_valid(unsigned int channel)
 {
 	if (channel == 0 || channel > 6) {
-		printk("gsc_hpdi: bug! invalid cable command channel\n");
+		printk(KERN_WARNING
+		       "gsc_hpdi: bug! invalid cable command channel\n");
 		return 0;
 	}
 	return 1;
@@ -560,7 +561,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i;
 	int retval;
 
-	printk("comedi%d: gsc_hpdi\n", dev->minor);
+	printk(KERN_WARNING "comedi%d: gsc_hpdi\n", dev->minor);
 
 	if (alloc_private(dev, sizeof(struct hpdi_private)) < 0)
 		return -ENOMEM;
@@ -588,11 +589,12 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		} while (pcidev != NULL);
 	}
 	if (dev->board_ptr == NULL) {
-		printk("gsc_hpdi: no hpdi card found\n");
+		printk(KERN_WARNING "gsc_hpdi: no hpdi card found\n");
 		return -EIO;
 	}
 
-	printk("gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
+	printk(KERN_WARNING
+	       "gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
 	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {
@@ -618,7 +620,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    ioremap(priv(dev)->hpdi_phys_iobase,
 		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {
-		printk(" failed to remap io memory\n");
+		printk(KERN_WARNING " failed to remap io memory\n");
 		return -ENOMEM;
 	}
 
@@ -630,12 +632,13 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  get irq */
 	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			driver_hpdi.driver_name, dev)) {
-		printk(" unable to allocate irq %u\n", pcidev->irq);
+		printk(KERN_WARNING
+		       " unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
 	}
 	dev->irq = pcidev->irq;
 
-	printk(" irq %u\n", dev->irq);
+	printk(KERN_WARNING " irq %u\n", dev->irq);
 
 	/*  alocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
@@ -653,7 +656,8 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 						   &priv(dev)->
 						   dma_desc_phys_addr);
 	if (priv(dev)->dma_desc_phys_addr & 0xf) {
-		printk(" dma descriptors not quad-word aligned (bug)\n");
+		printk(KERN_WARNING
+		       " dma descriptors not quad-word aligned (bug)\n");
 		return -EIO;
 	}
 
@@ -672,7 +676,7 @@ static int hpdi_detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
-	printk("comedi%d: gsc_hpdi: remove\n", dev->minor);
+	printk(KERN_WARNING "comedi%d: gsc_hpdi: remove\n", dev->minor);
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index b156ae717ae4..0bb30162e92c 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -58,7 +58,7 @@ static int hpdi_detach(struct comedi_device *dev);
 void abort_dma(struct comedi_device *dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+			 struct comedi_cmd *cmd);
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t handle_interrupt(int irq, void *d);
 static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
@@ -149,7 +149,7 @@ enum board_control_bits {
 	TEST_MODE_ENABLE_BIT = 0x80000000,
 };
 uint32_t command_discrete_output_bits(unsigned int channel, int output,
-	int output_value)
+				      int output_value)
 {
 	uint32_t bits = 0;
 
@@ -193,11 +193,13 @@ uint32_t almost_empty_bits(unsigned int num_words)
 {
 	return num_words & 0xffff;
 }
+
 unsigned int almost_full_num_words(uint32_t bits)
 {
 /* XXX need to add or subtract one? */
 	return (bits >> 16) & 0xffff;
 }
+
 unsigned int almost_empty_num_words(uint32_t bits)
 {
 	return bits & 0xffff;
@@ -268,33 +270,33 @@ struct hpdi_board {
 	int subdevice_id;	/*  pci subdevice id */
 };
 
-
 static const struct hpdi_board hpdi_boards[] = {
 	{
-	.name = "pci-hpdi32",
-	.device_id = PCI_DEVICE_ID_PLX_9080,
-	.subdevice_id = 0x2400,
-		},
+	 .name = "pci-hpdi32",
+	 .device_id = PCI_DEVICE_ID_PLX_9080,
+	 .subdevice_id = 0x2400,
+	 },
 #if 0
 	{
-	.name = "pxi-hpdi32",
-	.device_id = 0x9656,
-	.subdevice_id = 0x2705,
-		},
+	 .name = "pxi-hpdi32",
+	 .device_id = 0x9656,
+	 .subdevice_id = 0x2705,
+	 },
 #endif
 };
 
 static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
-	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX, 0x2400,
-		0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX,
+		    0x2400, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
 
-static inline struct hpdi_board *board(const struct comedi_device * dev)
+static inline struct hpdi_board *board(const struct comedi_device *dev)
 {
-	return (struct hpdi_board *) dev->board_ptr;
+	return (struct hpdi_board *)dev->board_ptr;
 }
 
 struct hpdi_private {
@@ -321,8 +323,7 @@ struct hpdi_private {
 	unsigned dio_config_output:1;
 };
 
-
-static inline struct hpdi_private *priv(struct comedi_device * dev)
+static inline struct hpdi_private *priv(struct comedi_device *dev)
 {
 	return dev->private;
 }
@@ -336,8 +337,9 @@ static struct comedi_driver driver_hpdi = {
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
-static int dio_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dio_config_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -350,8 +352,7 @@ static int dio_config_insn(struct comedi_device *dev, struct comedi_subdevice *s
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			priv(dev)->
-			dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    priv(dev)->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
 		break;
 	case INSN_CONFIG_BLOCK_SIZE:
@@ -377,29 +378,29 @@ static void init_plx9080(struct comedi_device *dev)
 
 	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
-		readl(plx_iobase + PLX_INTRCS_REG));
+		    readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
 	DEBUG_PRINT(" plx control reg 0x%x\n",
-		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
+		    readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
 
 	DEBUG_PRINT(" plx revision 0x%x\n",
-		readl(plx_iobase + PLX_REVISION_REG));
+		    readl(plx_iobase + PLX_REVISION_REG));
 	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_MODE_REG));
+		    readl(plx_iobase + PLX_DMA0_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
-		readl(plx_iobase + PLX_DMA1_MODE_REG));
+		    readl(plx_iobase + PLX_DMA1_MODE_REG));
 	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+		    readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
 	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+		    readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
 	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+		    readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
 	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
-		readb(plx_iobase + PLX_DMA0_CS_REG));
+		    readb(plx_iobase + PLX_DMA0_CS_REG));
 	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
-		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+		    readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
 	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
 #ifdef __BIG_ENDIAN
 	bits = BIGEND_DMA0 | BIGEND_DMA1;
@@ -448,7 +449,7 @@ static int setup_subdevices(struct comedi_device *dev)
 /*	dev->write_subdev = s; */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags =
-		SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
+	    SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
 	s->n_chan = 32;
 	s->len_chanlist = 32;
 	s->maxdata = 1;
@@ -469,21 +470,21 @@ static int init_hpdi(struct comedi_device *dev)
 	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-		priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
+	       priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
 	writel(almost_empty_bits(32) | almost_full_bits(32),
-		priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
+	       priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
 
 	priv(dev)->tx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
-			TX_FIFO_SIZE_REG));
+						  TX_FIFO_SIZE_REG));
 	priv(dev)->rx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
-			RX_FIFO_SIZE_REG));
+						  RX_FIFO_SIZE_REG));
 
 	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	/*  enable interrupts */
 	plx_intcsr_bits =
-		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
-		ICS_DMA0_E;
+	    ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+	    ICS_DMA0_E;
 	writel(plx_intcsr_bits, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 
 	return 0;
@@ -491,11 +492,11 @@ static int init_hpdi(struct comedi_device *dev)
 
 /* setup dma descriptors so a link completes every 'transfer_size' bytes */
 static int setup_dma_descriptors(struct comedi_device *dev,
-	unsigned int transfer_size)
+				 unsigned int transfer_size)
 {
 	unsigned int buffer_index, buffer_offset;
 	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-		PLX_XFER_LOCAL_TO_PCI;
+	    PLX_XFER_LOCAL_TO_PCI;
 	unsigned int i;
 
 	if (transfer_size > DMA_BUFFER_SIZE)
@@ -506,26 +507,26 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 
 	DEBUG_PRINT(" transfer_size %i\n", transfer_size);
 	DEBUG_PRINT(" descriptors at 0x%lx\n",
-		(unsigned long)priv(dev)->dma_desc_phys_addr);
+		    (unsigned long)priv(dev)->dma_desc_phys_addr);
 
 	buffer_offset = 0;
 	buffer_index = 0;
 	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
-		buffer_index < NUM_DMA_BUFFERS; i++) {
+	     buffer_index < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dma_desc[i].pci_start_addr =
-			cpu_to_le32(priv(dev)->
-			dio_buffer_phys_addr[buffer_index] + buffer_offset);
+		    cpu_to_le32(priv(dev)->dio_buffer_phys_addr[buffer_index] +
+				buffer_offset);
 		priv(dev)->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
 		priv(dev)->dma_desc[i].transfer_size =
-			cpu_to_le32(transfer_size);
+		    cpu_to_le32(transfer_size);
 		priv(dev)->dma_desc[i].next =
-			cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
-					1) *
-				sizeof(priv(dev)->dma_desc[0])) | next_bits);
+		    cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
+								  1) *
+				 sizeof(priv(dev)->dma_desc[0])) | next_bits);
 
 		priv(dev)->desc_dio_buffer[i] =
-			priv(dev)->dio_buffer[buffer_index] +
-			(buffer_offset / sizeof(uint32_t));
+		    priv(dev)->dio_buffer[buffer_index] +
+		    (buffer_offset / sizeof(uint32_t));
 
 		buffer_offset += transfer_size;
 		if (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {
@@ -535,17 +536,18 @@ static int setup_dma_descriptors(struct comedi_device *dev,
 
 		DEBUG_PRINT(" desc %i\n", i);
 		DEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",
-			priv(dev)->desc_dio_buffer[i],
-			(unsigned long)priv(dev)->dma_desc[i].pci_start_addr);
+			    priv(dev)->desc_dio_buffer[i],
+			    (unsigned long)priv(dev)->dma_desc[i].
+			    pci_start_addr);
 		DEBUG_PRINT(" next 0x%lx\n",
-			(unsigned long)priv(dev)->dma_desc[i].next);
+			    (unsigned long)priv(dev)->dma_desc[i].next);
 	}
 	priv(dev)->num_dma_descriptors = i;
 	/*  fix last descriptor to point back to first */
 	priv(dev)->dma_desc[i - 1].next =
-		cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
+	    cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
 	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
-		(unsigned long)priv(dev)->dma_desc[i - 1].next);
+		    (unsigned long)priv(dev)->dma_desc[i - 1].next);
 
 	priv(dev)->block_size = transfer_size;
 
@@ -567,14 +569,15 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (i = 0; i < ARRAY_SIZE(hpdi_boards) && dev->board_ptr == NULL; i++) {
 		do {
 			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
-				hpdi_boards[i].device_id, PCI_VENDOR_ID_PLX,
-				hpdi_boards[i].subdevice_id, pcidev);
+						hpdi_boards[i].device_id,
+						PCI_VENDOR_ID_PLX,
+						hpdi_boards[i].subdevice_id,
+						pcidev);
 			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1])
+				    PCI_SLOT(pcidev->devfn) != it->options[1])
 					continue;
 			}
 			if (pcidev) {
@@ -590,11 +593,11 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	printk("gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	if (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {
 		printk(KERN_WARNING
-			" failed enable PCI device and request regions\n");
+		       " failed enable PCI device and request regions\n");
 		return -EIO;
 	}
 	pci_set_master(pcidev);
@@ -603,15 +606,17 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
-		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	    pci_resource_start(pcidev, PLX9080_BADDRINDEX);
 	priv(dev)->hpdi_phys_iobase =
-		pci_resource_start(pcidev, HPDI_BADDRINDEX);
+	    pci_resource_start(pcidev, HPDI_BADDRINDEX);
 
 	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
-		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
-	priv(dev)->hpdi_iobase = ioremap(priv(dev)->hpdi_phys_iobase,
-		pci_resource_len(pcidev, HPDI_BADDRINDEX));
+					    pci_resource_len(pcidev,
+							     PLX9080_BADDRINDEX));
+	priv(dev)->hpdi_iobase =
+	    ioremap(priv(dev)->hpdi_phys_iobase,
+		    pci_resource_len(pcidev, HPDI_BADDRINDEX));
 	if (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {
 		printk(" failed to remap io memory\n");
 		return -ENOMEM;
@@ -635,16 +640,18 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/*  alocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dio_buffer[i] =
-			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
-			&priv(dev)->dio_buffer_phys_addr[i]);
+		    pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+					 &priv(dev)->dio_buffer_phys_addr[i]);
 		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
-			priv(dev)->dio_buffer[i],
-			(unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
+			    priv(dev)->dio_buffer[i],
+			    (unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
 	}
 	/*  allocate dma descriptors */
 	priv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,
-		sizeof(struct plx_dma_desc) * NUM_DMA_DESCRIPTORS,
-		&priv(dev)->dma_desc_phys_addr);
+						   sizeof(struct plx_dma_desc) *
+						   NUM_DMA_DESCRIPTORS,
+						   &priv(dev)->
+						   dma_desc_phys_addr);
 	if (priv(dev)->dma_desc_phys_addr & 0xf) {
 		printk(" dma descriptors not quad-word aligned (bug)\n");
 		return -EIO;
@@ -681,18 +688,21 @@ static int hpdi_detach(struct comedi_device *dev)
 			for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 				if (priv(dev)->dio_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
-						DMA_BUFFER_SIZE,
-						priv(dev)->dio_buffer[i],
-						priv(dev)->
-						dio_buffer_phys_addr[i]);
+							    DMA_BUFFER_SIZE,
+							    priv(dev)->
+							    dio_buffer[i],
+							    priv
+							    (dev)->dio_buffer_phys_addr
+							    [i]);
 			}
 			/*  free dma descriptors */
 			if (priv(dev)->dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
-					sizeof(struct plx_dma_desc) *
-					NUM_DMA_DESCRIPTORS,
-					priv(dev)->dma_desc,
-					priv(dev)->dma_desc_phys_addr);
+						    sizeof(struct plx_dma_desc)
+						    * NUM_DMA_DESCRIPTORS,
+						    priv(dev)->dma_desc,
+						    priv(dev)->
+						    dma_desc_phys_addr);
 			if (priv(dev)->hpdi_phys_iobase) {
 				comedi_pci_disable(priv(dev)->hw_dev);
 			}
@@ -719,7 +729,7 @@ static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)
 }
 
 static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+		       struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -805,7 +815,7 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 			if (CR_CHAN(cmd->chanlist[i]) != i) {
 				/*  XXX could support 8 channels or 16 channels */
 				comedi_error(dev,
-					"chanlist must be channels 0 to 31 in order");
+					     "chanlist must be channels 0 to 31 in order");
 				err++;
 				break;
 			}
@@ -819,7 +829,7 @@ static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+			 struct comedi_cmd *cmd)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -828,10 +838,10 @@ static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
-	unsigned int offset)
+			       unsigned int offset)
 {
 	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
-		priv(dev)->hpdi_iobase + offset);
+	       priv(dev)->hpdi_iobase + offset);
 }
 
 static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -857,16 +867,16 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
 	/*  give location of first dma descriptor */
-	bits = priv(dev)->
-		dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
-		PLX_XFER_LOCAL_TO_PCI;
+	bits =
+	    priv(dev)->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |
+	    PLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;
 	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
 	/*  spinlock for plx dma control/status reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
-		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
@@ -876,10 +886,10 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  clear over/under run status flags */
 	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
-		priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+	       priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
 	/*  enable interrupts */
 	writel(intr_bit(RX_FULL_INTR),
-		priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+	       priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
 	DEBUG_PRINT("hpdi: starting rx\n");
 	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
@@ -905,22 +915,21 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 
 	if (channel)
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
 	else
 		pci_addr_reg =
-			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+		    priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
 	/*  loop until we have read all the full buffers */
 	j = 0;
 	for (next_transfer_addr = readl(pci_addr_reg);
-		(next_transfer_addr <
-			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
-					dma_desc_index].pci_start_addr)
-			|| next_transfer_addr >=
-			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
-					dma_desc_index].pci_start_addr) +
-			priv(dev)->block_size)
-		&& j < priv(dev)->num_dma_descriptors; j++) {
+	     (next_transfer_addr <
+	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			  pci_start_addr)
+	      || next_transfer_addr >=
+	      le32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			  pci_start_addr) + priv(dev)->block_size)
+	     && j < priv(dev)->num_dma_descriptors; j++) {
 		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = priv(dev)->block_size / sizeof(uint32_t);
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -929,13 +938,15 @@ static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 			priv(dev)->dio_count -= num_samples;
 		}
 		cfc_write_array_to_buffer(dev->read_subdev,
-			priv(dev)->desc_dio_buffer[priv(dev)->dma_desc_index],
-			num_samples * sizeof(uint32_t));
+					  priv(dev)->desc_dio_buffer[priv(dev)->
+								     dma_desc_index],
+					  num_samples * sizeof(uint32_t));
 		priv(dev)->dma_desc_index++;
 		priv(dev)->dma_desc_index %= priv(dev)->num_dma_descriptors;
 
 		DEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)
-			priv(dev)->dma_desc[priv(dev)->dma_desc_index].next);
+			    priv(dev)->dma_desc[priv(dev)->dma_desc_index].
+			    next);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
 	/*  XXX check for buffer overrun somehow */
@@ -969,14 +980,14 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	if (hpdi_intr_status) {
 		DEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);
 		writel(hpdi_intr_status,
-			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
+		       priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 
 		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
 		if (dma0_status & PLX_DMA_EN_BIT) {
@@ -989,10 +1000,9 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	/*  spin lock makes sure noone else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
-	if (plx_status & ICS_DMA1_A)	/*  XXX */
-	{			/*  dma chan 1 interrupt */
+	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
-			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		       priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
 
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
@@ -1010,8 +1020,8 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		comedi_error(dev, "rx fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 		DEBUG_PRINT("dma0_status 0x%x\n",
-			(int)readb(priv(dev)->plx9080_iobase +
-				PLX_DMA0_CS_REG));
+			    (int)readb(priv(dev)->plx9080_iobase +
+				       PLX_DMA0_CS_REG));
 	}
 
 	if (hpdi_board_status & RX_UNDERRUN_BIT) {

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index dedd0df37549..b156ae717ae4 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -45,6 +45,7 @@ support could be added to this driver.
 
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/delay.h>
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index a344e2cebde1..dedd0df37549 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -66,7 +66,7 @@ static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 /* #define HPDI_DEBUG      enable debugging code */
 
 #ifdef HPDI_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
+#define DEBUG_PRINT(format, args...)  printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif
@@ -109,7 +109,7 @@ enum hpdi_registers {
 int command_channel_valid(unsigned int channel)
 {
 	if (channel == 0 || channel > 6) {
-		rt_printk("gsc_hpdi: bug! invalid cable command channel\n");
+		printk("gsc_hpdi: bug! invalid cable command channel\n");
 		return 0;
 	}
 	return 1;
@@ -465,7 +465,7 @@ static int init_hpdi(struct comedi_device *dev)
 	uint32_t plx_intcsr_bits;
 
 	writel(BOARD_RESET_BIT, priv(dev)->hpdi_iobase + BOARD_CONTROL_REG);
-	comedi_udelay(10);
+	udelay(10);
 
 	writel(almost_empty_bits(32) | almost_full_bits(32),
 		priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
@@ -622,7 +622,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	init_plx9080(dev);
 
 	/*  get irq */
-	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+	if (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			driver_hpdi.driver_name, dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
 		return -EINVAL;
@@ -667,7 +667,7 @@ static int hpdi_detach(struct comedi_device *dev)
 	printk("comedi%d: gsc_hpdi: remove\n", dev->minor);
 
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (priv(dev)) {
 		if (priv(dev)->hw_dev) {
 			if (priv(dev)->plx9080_iobase) {
@@ -862,11 +862,11 @@ static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
 		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	if (cmd->stop_src == TRIG_COUNT)
 		priv(dev)->dio_count = cmd->stop_arg;
@@ -971,7 +971,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
@@ -983,10 +983,10 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		}
 		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  spin lock makes sure noone else changes plx dma control reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A)	/*  XXX */
 	{			/*  dma chan 1 interrupt */
@@ -996,7 +996,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 
 		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear possible plx9080 interrupt sources */
 	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
@@ -1036,11 +1036,11 @@ void abort_dma(struct comedi_device *dev, unsigned int channel)
 	unsigned long flags;
 
 	/*  spinlock for plx dma control/status reg */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
 
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 098a78e9307a..a344e2cebde1 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -283,11 +283,6 @@ static const struct hpdi_board hpdi_boards[] = {
 #endif
 };
 
-static inline unsigned int num_boards(void)
-{
-	return sizeof(hpdi_boards) / sizeof(struct hpdi_board);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
 	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX, 0x2400,
 		0, 0, 0},
@@ -568,7 +563,7 @@ static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	pcidev = NULL;
-	for (i = 0; i < num_boards() && dev->board_ptr == NULL; i++) {
+	for (i = 0; i < ARRAY_SIZE(hpdi_boards) && dev->board_ptr == NULL; i++) {
 		do {
 			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
 				hpdi_boards[i].device_id, PCI_VENDOR_ID_PLX,

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 567dd5290e8f..098a78e9307a 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,15 +52,15 @@ support could be added to this driver.
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int hpdi_detach(struct comedi_device * dev);
-void abort_dma(struct comedi_device * dev, unsigned int channel);
-static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int hpdi_detach(struct comedi_device *dev);
+void abort_dma(struct comedi_device *dev, unsigned int channel);
+static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t handle_interrupt(int irq, void *d);
-static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
+static int dio_config_block_size(struct comedi_device *dev, unsigned int *data);
 
 #undef HPDI_DEBUG		/*  disable debugging messages */
 /* #define HPDI_DEBUG      enable debugging code */

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index d25b4c8aeaed..567dd5290e8f 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -270,15 +270,15 @@ struct hpdi_board {
 
 static const struct hpdi_board hpdi_boards[] = {
 	{
-	      name:	"pci-hpdi32",
-	      device_id:PCI_DEVICE_ID_PLX_9080,
-	      subdevice_id:0x2400,
+	.name = "pci-hpdi32",
+	.device_id = PCI_DEVICE_ID_PLX_9080,
+	.subdevice_id = 0x2400,
 		},
 #if 0
 	{
-	      name:	"pxi-hpdi32",
-	      device_id:0x9656,
-	      subdevice_id:0x2705,
+	.name = "pxi-hpdi32",
+	.device_id = 0x9656,
+	.subdevice_id = 0x2705,
 		},
 #endif
 };
@@ -332,10 +332,10 @@ static inline struct hpdi_private *priv(struct comedi_device * dev)
 }
 
 static struct comedi_driver driver_hpdi = {
-      driver_name:"gsc_hpdi",
-      module:THIS_MODULE,
-      attach:hpdi_attach,
-      detach:hpdi_detach,
+	.driver_name = "gsc_hpdi",
+	.module = THIS_MODULE,
+	.attach = hpdi_attach,
+	.detach = hpdi_detach,
 };
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 48491c09e7f2..d25b4c8aeaed 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -66,7 +66,7 @@ static int dio_config_block_size(struct comedi_device * dev, unsigned int * data
 /* #define HPDI_DEBUG      enable debugging code */
 
 #ifdef HPDI_DEBUG
-#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
+#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args)
 #else
 #define DEBUG_PRINT(format, args...)
 #endif

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index cd5772f90aa1..48491c09e7f2 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -340,8 +340,8 @@ static struct comedi_driver driver_hpdi = {
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
-static int dio_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dio_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -368,13 +368,13 @@ static int dio_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 	return -EINVAL;
 }
 
-static void disable_plx_interrupts(struct comedi_device * dev)
+static void disable_plx_interrupts(struct comedi_device *dev)
 {
 	writel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 /* initialize plx9080 chip */
-static void init_plx9080(struct comedi_device * dev)
+static void init_plx9080(struct comedi_device *dev)
 {
 	uint32_t bits;
 	void *plx_iobase = priv(dev)->plx9080_iobase;
@@ -439,7 +439,7 @@ static void init_plx9080(struct comedi_device * dev)
 
 /* Allocate and initialize the subdevice structures.
  */
-static int setup_subdevices(struct comedi_device * dev)
+static int setup_subdevices(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s;
 
@@ -465,7 +465,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	return 0;
 }
 
-static int init_hpdi(struct comedi_device * dev)
+static int init_hpdi(struct comedi_device *dev)
 {
 	uint32_t plx_intcsr_bits;
 
@@ -494,7 +494,7 @@ static int init_hpdi(struct comedi_device * dev)
 }
 
 /* setup dma descriptors so a link completes every 'transfer_size' bytes */
-static int setup_dma_descriptors(struct comedi_device * dev,
+static int setup_dma_descriptors(struct comedi_device *dev,
 	unsigned int transfer_size)
 {
 	unsigned int buffer_index, buffer_offset;
@@ -556,7 +556,7 @@ static int setup_dma_descriptors(struct comedi_device * dev,
 	return transfer_size;
 }
 
-static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
 	int i;
@@ -665,7 +665,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	return init_hpdi(dev);
 }
 
-static int hpdi_detach(struct comedi_device * dev)
+static int hpdi_detach(struct comedi_device *dev)
 {
 	unsigned int i;
 
@@ -706,7 +706,7 @@ static int hpdi_detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int dio_config_block_size(struct comedi_device * dev, unsigned int * data)
+static int dio_config_block_size(struct comedi_device *dev, unsigned int *data)
 {
 	unsigned int requested_block_size;
 	int retval;
@@ -722,8 +722,8 @@ static int dio_config_block_size(struct comedi_device * dev, unsigned int * data
 	return 2;
 }
 
-static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -822,8 +822,8 @@ static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	return 0;
 }
 
-static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -831,14 +831,14 @@ static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s
 		return di_cmd_test(dev, s, cmd);
 }
 
-static inline void hpdi_writel(struct comedi_device * dev, uint32_t bits,
+static inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,
 	unsigned int offset)
 {
 	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
 		priv(dev)->hpdi_iobase + offset);
 }
 
-static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -891,7 +891,7 @@ static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -899,7 +899,7 @@ static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		return di_cmd(dev, s);
 }
 
-static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
+static void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)
 {
 	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
@@ -1036,7 +1036,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(struct comedi_device * dev, unsigned int channel)
+void abort_dma(struct comedi_device *dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -1048,7 +1048,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 69359c00d2ab..cd5772f90aa1 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -59,7 +59,7 @@ static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
 static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t handle_interrupt(int irq, void *d);
 static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
 
 #undef HPDI_DEBUG		/*  disable debugging messages */
@@ -945,7 +945,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 	/*  XXX check for buffer overrun somehow */
 }
 
-static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t handle_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;

commit c52c19c33617cb76e2cec7d9555c30f2505e69e4
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:30:55 2009 -0400

    Staging: comedi: remove C99 comments in gsc_hpdi.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 49e5c86c2dd8..69359c00d2ab 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -62,8 +62,8 @@ static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
 static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
 
-#undef HPDI_DEBUG		// disable debugging messages
-//#define HPDI_DEBUG    // enable debugging code
+#undef HPDI_DEBUG		/*  disable debugging messages */
+/* #define HPDI_DEBUG      enable debugging code */
 
 #ifdef HPDI_DEBUG
 #define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
@@ -71,12 +71,12 @@ static int dio_config_block_size(struct comedi_device * dev, unsigned int * data
 #define DEBUG_PRINT(format, args...)
 #endif
 
-#define TIMER_BASE 50		// 20MHz master clock
+#define TIMER_BASE 50		/*  20MHz master clock */
 #define DMA_BUFFER_SIZE 0x10000
 #define NUM_DMA_BUFFERS 4
 #define NUM_DMA_DESCRIPTORS 256
 
-// indices of base address regions
+/* indices of base address regions */
 enum base_address_regions {
 	PLX9080_BADDRINDEX = 0,
 	HPDI_BADDRINDEX = 2,
@@ -115,7 +115,7 @@ int command_channel_valid(unsigned int channel)
 	return 1;
 }
 
-// bit definitions
+/* bit definitions */
 
 enum firmware_revision_bits {
 	FEATURES_REG_PRESENT_BIT = 0x8000,
@@ -184,7 +184,7 @@ enum board_status_bits {
 
 uint32_t almost_full_bits(unsigned int num_words)
 {
-// XXX need to add or subtract one?
+/* XXX need to add or subtract one? */
 	return (num_words << 16) & 0xff0000;
 }
 
@@ -194,7 +194,7 @@ uint32_t almost_empty_bits(unsigned int num_words)
 }
 unsigned int almost_full_num_words(uint32_t bits)
 {
-// XXX need to add or subtract one?
+/* XXX need to add or subtract one? */
 	return (bits >> 16) & 0xffff;
 }
 unsigned int almost_empty_num_words(uint32_t bits)
@@ -263,8 +263,8 @@ uint32_t intr_active_high_bit(int interrupt_source)
 struct hpdi_board {
 
 	char *name;
-	int device_id;		// pci device id
-	int subdevice_id;	// pci subdevice id
+	int device_id;		/*  pci device id */
+	int subdevice_id;	/*  pci subdevice id */
 };
 
 
@@ -303,25 +303,25 @@ static inline struct hpdi_board *board(const struct comedi_device * dev)
 
 struct hpdi_private {
 
-	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
-	// base addresses (physical)
+	struct pci_dev *hw_dev;	/*  pointer to board's pci_dev struct */
+	/*  base addresses (physical) */
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t hpdi_phys_iobase;
-	// base addresses (ioremapped)
+	/*  base addresses (ioremapped) */
 	void *plx9080_iobase;
 	void *hpdi_iobase;
-	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	// dma buffers
-	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];	// physical addresses of dma buffers
-	struct plx_dma_desc *dma_desc;	// array of dma descriptors read by plx9080, allocated to get proper alignment
-	dma_addr_t dma_desc_phys_addr;	// physical address of dma descriptor array
+	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	/*  dma buffers */
+	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];	/*  physical addresses of dma buffers */
+	struct plx_dma_desc *dma_desc;	/*  array of dma descriptors read by plx9080, allocated to get proper alignment */
+	dma_addr_t dma_desc_phys_addr;	/*  physical address of dma descriptor array */
 	unsigned int num_dma_descriptors;
-	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];	// pointer to start of buffers indexed by descriptor
-	volatile unsigned int dma_desc_index;	// index of the dma descriptor that is currently being used
+	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];	/*  pointer to start of buffers indexed by descriptor */
+	volatile unsigned int dma_desc_index;	/*  index of the dma descriptor that is currently being used */
 	unsigned int tx_fifo_size;
 	unsigned int rx_fifo_size;
 	volatile unsigned long dio_count;
-	volatile uint32_t bits[24];	// software copies of values written to hpdi registers
-	volatile unsigned int block_size;	// number of bytes at which to generate COMEDI_CB_BLOCK events
+	volatile uint32_t bits[24];	/*  software copies of values written to hpdi registers */
+	volatile unsigned int block_size;	/*  number of bytes at which to generate COMEDI_CB_BLOCK events */
 	unsigned dio_config_output:1;
 };
 
@@ -373,13 +373,13 @@ static void disable_plx_interrupts(struct comedi_device * dev)
 	writel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
-// initialize plx9080 chip
+/* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device * dev)
 {
 	uint32_t bits;
 	void *plx_iobase = priv(dev)->plx9080_iobase;
 
-	// plx9080 dump
+	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
 		readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
@@ -417,21 +417,21 @@ static void init_plx9080(struct comedi_device * dev)
 	abort_dma(dev, 0);
 	abort_dma(dev, 1);
 
-	// configure dma0 mode
+	/*  configure dma0 mode */
 	bits = 0;
-	// enable ready input
+	/*  enable ready input */
 	bits |= PLX_DMA_EN_READYIN_BIT;
-	// enable dma chaining
+	/*  enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	// enable interrupt on dma done (probably don't need this, since chain never finishes)
+	/*  enable interrupt on dma done (probably don't need this, since chain never finishes) */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	// don't increment local address during transfers (we are transferring from a fixed fifo register)
+	/*  don't increment local address during transfers (we are transferring from a fixed fifo register) */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
-	// route dma interrupt to pci bus
+	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
-	// enable demand mode
+	/*  enable demand mode */
 	bits |= PLX_DEMAND_MODE_BIT;
-	// enable local burst mode
+	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
 	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
 	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
@@ -484,7 +484,7 @@ static int init_hpdi(struct comedi_device * dev)
 
 	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
-	// enable interrupts
+	/*  enable interrupts */
 	plx_intcsr_bits =
 		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 		ICS_DMA0_E;
@@ -493,7 +493,7 @@ static int init_hpdi(struct comedi_device * dev)
 	return 0;
 }
 
-// setup dma descriptors so a link completes every 'transfer_size' bytes
+/* setup dma descriptors so a link completes every 'transfer_size' bytes */
 static int setup_dma_descriptors(struct comedi_device * dev,
 	unsigned int transfer_size)
 {
@@ -545,7 +545,7 @@ static int setup_dma_descriptors(struct comedi_device * dev,
 			(unsigned long)priv(dev)->dma_desc[i].next);
 	}
 	priv(dev)->num_dma_descriptors = i;
-	// fix last descriptor to point back to first
+	/*  fix last descriptor to point back to first */
 	priv(dev)->dma_desc[i - 1].next =
 		cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
 	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
@@ -573,9 +573,9 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
 				hpdi_boards[i].device_id, PCI_VENDOR_ID_PLX,
 				hpdi_boards[i].subdevice_id, pcidev);
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1])
@@ -603,7 +603,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	}
 	pci_set_master(pcidev);
 
-	//Initialize dev->board_name
+	/* Initialize dev->board_name */
 	dev->board_name = board(dev)->name;
 
 	priv(dev)->plx9080_phys_iobase =
@@ -611,7 +611,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	priv(dev)->hpdi_phys_iobase =
 		pci_resource_start(pcidev, HPDI_BADDRINDEX);
 
-	// remap, won't work with 2.0 kernels but who cares
+	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
 		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
 	priv(dev)->hpdi_iobase = ioremap(priv(dev)->hpdi_phys_iobase,
@@ -626,7 +626,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 
 	init_plx9080(dev);
 
-	// get irq
+	/*  get irq */
 	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
 			driver_hpdi.driver_name, dev)) {
 		printk(" unable to allocate irq %u\n", pcidev->irq);
@@ -636,7 +636,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 
 	printk(" irq %u\n", dev->irq);
 
-	// alocate pci dma buffers
+	/*  alocate pci dma buffers */
 	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 		priv(dev)->dio_buffer[i] =
 			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
@@ -645,7 +645,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 			priv(dev)->dio_buffer[i],
 			(unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
 	}
-	// allocate dma descriptors
+	/*  allocate dma descriptors */
 	priv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,
 		sizeof(struct plx_dma_desc) * NUM_DMA_DESCRIPTORS,
 		&priv(dev)->dma_desc_phys_addr);
@@ -681,7 +681,7 @@ static int hpdi_detach(struct comedi_device * dev)
 			}
 			if (priv(dev)->hpdi_iobase)
 				iounmap((void *)priv(dev)->hpdi_iobase);
-			// free pci dma buffers
+			/*  free pci dma buffers */
 			for (i = 0; i < NUM_DMA_BUFFERS; i++) {
 				if (priv(dev)->dio_buffer[i])
 					pci_free_consistent(priv(dev)->hw_dev,
@@ -690,7 +690,7 @@ static int hpdi_detach(struct comedi_device * dev)
 						priv(dev)->
 						dio_buffer_phys_addr[i]);
 			}
-			// free dma descriptors
+			/*  free dma descriptors */
 			if (priv(dev)->dma_desc)
 				pci_free_consistent(priv(dev)->hw_dev,
 					sizeof(struct plx_dma_desc) *
@@ -761,7 +761,7 @@ static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
 
@@ -807,7 +807,7 @@ static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	if (cmd->chanlist) {
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) != i) {
-				// XXX could support 8 channels or 16 channels
+				/*  XXX could support 8 channels or 16 channels */
 				comedi_error(dev,
 					"chanlist must be channels 0 to 31 in order");
 				err++;
@@ -860,15 +860,15 @@ static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
 	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
-	// give location of first dma descriptor
+	/*  give location of first dma descriptor */
 	bits = priv(dev)->
 		dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
 		PLX_XFER_LOCAL_TO_PCI;
 	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
-	// enable dma transfer
+	/*  enable dma transfer */
 	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
 		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -878,10 +878,10 @@ static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	else
 		priv(dev)->dio_count = 1;
 
-	// clear over/under run status flags
+	/*  clear over/under run status flags */
 	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
 		priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
-	// enable interrupts
+	/*  enable interrupts */
 	writel(intr_bit(RX_FULL_INTR),
 		priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
 
@@ -914,7 +914,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 		pci_addr_reg =
 			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
-	// loop until we have read all the full buffers
+	/*  loop until we have read all the full buffers */
 	j = 0;
 	for (next_transfer_addr = readl(pci_addr_reg);
 		(next_transfer_addr <
@@ -925,7 +925,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 					dma_desc_index].pci_start_addr) +
 			priv(dev)->block_size)
 		&& j < priv(dev)->num_dma_descriptors; j++) {
-		// transfer data from dma buffer to comedi buffer
+		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = priv(dev)->block_size / sizeof(uint32_t);
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			if (num_samples > priv(dev)->dio_count)
@@ -942,7 +942,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 			priv(dev)->dma_desc[priv(dev)->dma_desc_index].next);
 		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
 	}
-	// XXX check for buffer overrun somehow
+	/*  XXX check for buffer overrun somehow */
 }
 
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
@@ -975,10 +975,10 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 		writel(hpdi_intr_status,
 			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
-	if (plx_status & ICS_DMA0_A) {	// dma chan 0 interrupt
+	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 
@@ -990,11 +990,11 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
-	if (plx_status & ICS_DMA1_A)	// XXX
-	{			// dma chan 1 interrupt
+	if (plx_status & ICS_DMA1_A)	/*  XXX */
+	{			/*  dma chan 1 interrupt */
 		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
@@ -1003,8 +1003,8 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// clear possible plx9080 interrupt sources
-	if (plx_status & ICS_LDIA) {	// clear local doorbell interrupt
+	/*  clear possible plx9080 interrupt sources */
+	if (plx_status & ICS_LDIA) {	/*  clear local doorbell interrupt */
 		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
 		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
 		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
@@ -1040,7 +1040,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);

commit 352dec620aea9529180034fa461d290026ff57e9
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:18:10 2009 -0400

    Staging: comedi: Remove hpdi_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 001284f1583d..49e5c86c2dd8 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -301,7 +301,8 @@ static inline struct hpdi_board *board(const struct comedi_device * dev)
 	return (struct hpdi_board *) dev->board_ptr;
 }
 
-typedef struct {
+struct hpdi_private {
+
 	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
 	// base addresses (physical)
 	resource_size_t plx9080_phys_iobase;
@@ -322,9 +323,10 @@ typedef struct {
 	volatile uint32_t bits[24];	// software copies of values written to hpdi registers
 	volatile unsigned int block_size;	// number of bytes at which to generate COMEDI_CB_BLOCK events
 	unsigned dio_config_output:1;
-} hpdi_private;
+};
+
 
-static inline hpdi_private *priv(struct comedi_device * dev)
+static inline struct hpdi_private *priv(struct comedi_device * dev)
 {
 	return dev->private;
 }
@@ -562,7 +564,7 @@ static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 
 	printk("comedi%d: gsc_hpdi\n", dev->minor);
 
-	if (alloc_private(dev, sizeof(hpdi_private)) < 0)
+	if (alloc_private(dev, sizeof(struct hpdi_private)) < 0)
 		return -ENOMEM;
 
 	pcidev = NULL;

commit 52b3e3483d12f03ad6c1fa051a5db0b5656596c9
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:15:13 2009 -0400

    Staging: comedi: Remove hpdi_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 535aadb98dcc..001284f1583d 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -260,13 +260,15 @@ uint32_t intr_active_high_bit(int interrupt_source)
 	return 0x1 << interrupt_source;
 }
 
-typedef struct {
+struct hpdi_board {
+
 	char *name;
 	int device_id;		// pci device id
 	int subdevice_id;	// pci subdevice id
-} hpdi_board;
+};
+
 
-static const hpdi_board hpdi_boards[] = {
+static const struct hpdi_board hpdi_boards[] = {
 	{
 	      name:	"pci-hpdi32",
 	      device_id:PCI_DEVICE_ID_PLX_9080,
@@ -283,7 +285,7 @@ static const hpdi_board hpdi_boards[] = {
 
 static inline unsigned int num_boards(void)
 {
-	return sizeof(hpdi_boards) / sizeof(hpdi_board);
+	return sizeof(hpdi_boards) / sizeof(struct hpdi_board);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
@@ -294,9 +296,9 @@ static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
 
-static inline hpdi_board *board(const struct comedi_device * dev)
+static inline struct hpdi_board *board(const struct comedi_device * dev)
 {
-	return (hpdi_board *) dev->board_ptr;
+	return (struct hpdi_board *) dev->board_ptr;
 }
 
 typedef struct {

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 5227e3ee273b..535aadb98dcc 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,7 +52,7 @@ support could be added to this driver.
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-static int hpdi_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int hpdi_detach(struct comedi_device * dev);
 void abort_dma(struct comedi_device * dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -552,7 +552,7 @@ static int setup_dma_descriptors(struct comedi_device * dev,
 	return transfer_size;
 }
 
-static int hpdi_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int hpdi_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct pci_dev *pcidev;
 	int i;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 828fd315e644..5227e3ee273b 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -337,7 +337,7 @@ static struct comedi_driver driver_hpdi = {
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
 static int dio_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index ccc010f40d47..828fd315e644 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -57,7 +57,7 @@ static int hpdi_detach(struct comedi_device * dev);
 void abort_dma(struct comedi_device * dev, unsigned int channel);
 static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
 static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
@@ -719,7 +719,7 @@ static int dio_config_block_size(struct comedi_device * dev, unsigned int * data
 }
 
 static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -819,7 +819,7 @@ static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 }
 
 static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -839,7 +839,7 @@ static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	uint32_t bits;
 	unsigned long flags;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 
 	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
 

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index aefee40710c1..ccc010f40d47 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -327,7 +327,7 @@ static inline hpdi_private *priv(struct comedi_device * dev)
 	return dev->private;
 }
 
-static comedi_driver driver_hpdi = {
+static struct comedi_driver driver_hpdi = {
       driver_name:"gsc_hpdi",
       module:THIS_MODULE,
       attach:hpdi_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index fb91fa1da839..aefee40710c1 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -838,7 +838,7 @@ static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	uint32_t bits;
 	unsigned long flags;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 
 	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
@@ -897,7 +897,7 @@ static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 
 static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 {
-	comedi_async *async = dev->read_subdev->async;
+	struct comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
 	int j;
 	int num_samples = 0;
@@ -945,7 +945,7 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	uint32_t hpdi_intr_status, hpdi_board_status;
 	uint32_t plx_status;
 	uint32_t plx_bits;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 5048255b4a3f..fb91fa1da839 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -55,10 +55,10 @@ support could be added to this driver.
 static int hpdi_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int hpdi_detach(struct comedi_device * dev);
 void abort_dma(struct comedi_device * dev, unsigned int channel);
-static int hpdi_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int hpdi_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
+static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int hpdi_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
 static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
 
@@ -336,7 +336,7 @@ static comedi_driver driver_hpdi = {
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
-static int dio_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dio_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -437,7 +437,7 @@ static void init_plx9080(struct comedi_device * dev)
  */
 static int setup_subdevices(struct comedi_device * dev)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	if (alloc_subdevices(dev, 1) < 0)
 		return -ENOMEM;
@@ -718,7 +718,7 @@ static int dio_config_block_size(struct comedi_device * dev, unsigned int * data
 	return 2;
 }
 
-static int di_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
+static int di_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -818,7 +818,7 @@ static int di_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int hpdi_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
+static int hpdi_cmd_test(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	if (priv(dev)->dio_config_output) {
@@ -834,7 +834,7 @@ static inline void hpdi_writel(struct comedi_device * dev, uint32_t bits,
 		priv(dev)->hpdi_iobase + offset);
 }
 
-static int di_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int di_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -887,7 +887,7 @@ static int di_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int hpdi_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int hpdi_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -944,7 +944,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	uint32_t hpdi_intr_status, hpdi_board_status;
 	uint32_t plx_status;
@@ -1044,7 +1044,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int hpdi_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int hpdi_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
 

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 07ed2380aa9a..5048255b4a3f 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -52,15 +52,15 @@ support could be added to this driver.
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-static int hpdi_attach(comedi_device * dev, comedi_devconfig * it);
-static int hpdi_detach(comedi_device * dev);
-void abort_dma(comedi_device * dev, unsigned int channel);
-static int hpdi_cmd(comedi_device * dev, comedi_subdevice * s);
-static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
+static int hpdi_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int hpdi_detach(struct comedi_device * dev);
+void abort_dma(struct comedi_device * dev, unsigned int channel);
+static int hpdi_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int hpdi_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int hpdi_cancel(comedi_device * dev, comedi_subdevice * s);
+static int hpdi_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
-static int dio_config_block_size(comedi_device * dev, unsigned int * data);
+static int dio_config_block_size(struct comedi_device * dev, unsigned int * data);
 
 #undef HPDI_DEBUG		// disable debugging messages
 //#define HPDI_DEBUG    // enable debugging code
@@ -294,7 +294,7 @@ static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
 
-static inline hpdi_board *board(const comedi_device * dev)
+static inline hpdi_board *board(const struct comedi_device * dev)
 {
 	return (hpdi_board *) dev->board_ptr;
 }
@@ -322,7 +322,7 @@ typedef struct {
 	unsigned dio_config_output:1;
 } hpdi_private;
 
-static inline hpdi_private *priv(comedi_device * dev)
+static inline hpdi_private *priv(struct comedi_device * dev)
 {
 	return dev->private;
 }
@@ -336,7 +336,7 @@ static comedi_driver driver_hpdi = {
 
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
-static int dio_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int dio_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
@@ -364,13 +364,13 @@ static int dio_config_insn(comedi_device * dev, comedi_subdevice * s,
 	return -EINVAL;
 }
 
-static void disable_plx_interrupts(comedi_device * dev)
+static void disable_plx_interrupts(struct comedi_device * dev)
 {
 	writel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
 }
 
 // initialize plx9080 chip
-static void init_plx9080(comedi_device * dev)
+static void init_plx9080(struct comedi_device * dev)
 {
 	uint32_t bits;
 	void *plx_iobase = priv(dev)->plx9080_iobase;
@@ -435,7 +435,7 @@ static void init_plx9080(comedi_device * dev)
 
 /* Allocate and initialize the subdevice structures.
  */
-static int setup_subdevices(comedi_device * dev)
+static int setup_subdevices(struct comedi_device * dev)
 {
 	comedi_subdevice *s;
 
@@ -461,7 +461,7 @@ static int setup_subdevices(comedi_device * dev)
 	return 0;
 }
 
-static int init_hpdi(comedi_device * dev)
+static int init_hpdi(struct comedi_device * dev)
 {
 	uint32_t plx_intcsr_bits;
 
@@ -490,7 +490,7 @@ static int init_hpdi(comedi_device * dev)
 }
 
 // setup dma descriptors so a link completes every 'transfer_size' bytes
-static int setup_dma_descriptors(comedi_device * dev,
+static int setup_dma_descriptors(struct comedi_device * dev,
 	unsigned int transfer_size)
 {
 	unsigned int buffer_index, buffer_offset;
@@ -552,7 +552,7 @@ static int setup_dma_descriptors(comedi_device * dev,
 	return transfer_size;
 }
 
-static int hpdi_attach(comedi_device * dev, comedi_devconfig * it)
+static int hpdi_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	struct pci_dev *pcidev;
 	int i;
@@ -661,7 +661,7 @@ static int hpdi_attach(comedi_device * dev, comedi_devconfig * it)
 	return init_hpdi(dev);
 }
 
-static int hpdi_detach(comedi_device * dev)
+static int hpdi_detach(struct comedi_device * dev)
 {
 	unsigned int i;
 
@@ -702,7 +702,7 @@ static int hpdi_detach(comedi_device * dev)
 	return 0;
 }
 
-static int dio_config_block_size(comedi_device * dev, unsigned int * data)
+static int dio_config_block_size(struct comedi_device * dev, unsigned int * data)
 {
 	unsigned int requested_block_size;
 	int retval;
@@ -718,7 +718,7 @@ static int dio_config_block_size(comedi_device * dev, unsigned int * data)
 	return 2;
 }
 
-static int di_cmd_test(comedi_device * dev, comedi_subdevice * s,
+static int di_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -818,7 +818,7 @@ static int di_cmd_test(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
+static int hpdi_cmd_test(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	if (priv(dev)->dio_config_output) {
@@ -827,14 +827,14 @@ static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
 		return di_cmd_test(dev, s, cmd);
 }
 
-static inline void hpdi_writel(comedi_device * dev, uint32_t bits,
+static inline void hpdi_writel(struct comedi_device * dev, uint32_t bits,
 	unsigned int offset)
 {
 	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
 		priv(dev)->hpdi_iobase + offset);
 }
 
-static int di_cmd(comedi_device * dev, comedi_subdevice * s)
+static int di_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	uint32_t bits;
 	unsigned long flags;
@@ -887,7 +887,7 @@ static int di_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int hpdi_cmd(comedi_device * dev, comedi_subdevice * s)
+static int hpdi_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (priv(dev)->dio_config_output) {
 		return -EINVAL;
@@ -895,7 +895,7 @@ static int hpdi_cmd(comedi_device * dev, comedi_subdevice * s)
 		return di_cmd(dev, s);
 }
 
-static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
+static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 {
 	comedi_async *async = dev->read_subdev->async;
 	uint32_t next_transfer_addr;
@@ -943,7 +943,7 @@ static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
 
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async = s->async;
 	uint32_t hpdi_intr_status, hpdi_board_status;
@@ -1032,7 +1032,7 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-void abort_dma(comedi_device * dev, unsigned int channel)
+void abort_dma(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
@@ -1044,7 +1044,7 @@ void abort_dma(comedi_device * dev, unsigned int channel)
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
-static int hpdi_cancel(comedi_device * dev, comedi_subdevice * s)
+static int hpdi_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 8d753e4ce7b6..07ed2380aa9a 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -60,7 +60,7 @@ static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int hpdi_cancel(comedi_device * dev, comedi_subdevice * s);
 static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
-static int dio_config_block_size(comedi_device * dev, lsampl_t * data);
+static int dio_config_block_size(comedi_device * dev, unsigned int * data);
 
 #undef HPDI_DEBUG		// disable debugging messages
 //#define HPDI_DEBUG    // enable debugging code
@@ -337,7 +337,7 @@ static comedi_driver driver_hpdi = {
 COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
 
 static int dio_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
@@ -702,7 +702,7 @@ static int hpdi_detach(comedi_device * dev)
 	return 0;
 }
 
-static int dio_config_block_size(comedi_device * dev, lsampl_t * data)
+static int dio_config_block_size(comedi_device * dev, unsigned int * data)
 {
 	unsigned int requested_block_size;
 	int retval;

commit f26c569b41fcba4809bcdcc4fc365fcfe214278a
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Tue Feb 17 16:30:02 2009 -0800

    Staging: comedi: add gsc_hpdi driver
    
    Driver for the General Standards Corporation High Speed Parallel Digital
    Interface rs485 boards.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
new file mode 100644
index 000000000000..8d753e4ce7b6
--- /dev/null
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -0,0 +1,1056 @@
+/*
+    comedi/drivers/gsc_hpdi.c
+    This is a driver for the General Standards Corporation High
+    Speed Parallel Digital Interface rs485 boards.
+
+    Author:  Frank Mori Hess <fmhess@users.sourceforge.net>
+    Copyright (C) 2003 Coherent Imaging Systems
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************/
+
+/*
+
+Driver: gsc_hpdi
+Description: General Standards Corporation High
+    Speed Parallel Digital Interface rs485 boards
+Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+Status: only receive mode works, transmit not supported
+Updated: 2003-02-20
+Devices: [General Standards Corporation] PCI-HPDI32 (gsc_hpdi),
+  PMC-HPDI32
+
+Configuration options:
+   [0] - PCI bus of device (optional)
+   [1] - PCI slot of device (optional)
+
+There are some additional hpdi models available from GSC for which
+support could be added to this driver.
+
+*/
+
+#include "../comedidev.h"
+#include <linux/delay.h>
+
+#include "comedi_pci.h"
+#include "plx9080.h"
+#include "comedi_fc.h"
+
+static int hpdi_attach(comedi_device * dev, comedi_devconfig * it);
+static int hpdi_detach(comedi_device * dev);
+void abort_dma(comedi_device * dev, unsigned int channel);
+static int hpdi_cmd(comedi_device * dev, comedi_subdevice * s);
+static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int hpdi_cancel(comedi_device * dev, comedi_subdevice * s);
+static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG);
+static int dio_config_block_size(comedi_device * dev, lsampl_t * data);
+
+#undef HPDI_DEBUG		// disable debugging messages
+//#define HPDI_DEBUG    // enable debugging code
+
+#ifdef HPDI_DEBUG
+#define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
+#else
+#define DEBUG_PRINT(format, args...)
+#endif
+
+#define TIMER_BASE 50		// 20MHz master clock
+#define DMA_BUFFER_SIZE 0x10000
+#define NUM_DMA_BUFFERS 4
+#define NUM_DMA_DESCRIPTORS 256
+
+// indices of base address regions
+enum base_address_regions {
+	PLX9080_BADDRINDEX = 0,
+	HPDI_BADDRINDEX = 2,
+};
+
+enum hpdi_registers {
+	FIRMWARE_REV_REG = 0x0,
+	BOARD_CONTROL_REG = 0x4,
+	BOARD_STATUS_REG = 0x8,
+	TX_PROG_ALMOST_REG = 0xc,
+	RX_PROG_ALMOST_REG = 0x10,
+	FEATURES_REG = 0x14,
+	FIFO_REG = 0x18,
+	TX_STATUS_COUNT_REG = 0x1c,
+	TX_LINE_VALID_COUNT_REG = 0x20,
+	TX_LINE_INVALID_COUNT_REG = 0x24,
+	RX_STATUS_COUNT_REG = 0x28,
+	RX_LINE_COUNT_REG = 0x2c,
+	INTERRUPT_CONTROL_REG = 0x30,
+	INTERRUPT_STATUS_REG = 0x34,
+	TX_CLOCK_DIVIDER_REG = 0x38,
+	TX_FIFO_SIZE_REG = 0x40,
+	RX_FIFO_SIZE_REG = 0x44,
+	TX_FIFO_WORDS_REG = 0x48,
+	RX_FIFO_WORDS_REG = 0x4c,
+	INTERRUPT_EDGE_LEVEL_REG = 0x50,
+	INTERRUPT_POLARITY_REG = 0x54,
+};
+
+int command_channel_valid(unsigned int channel)
+{
+	if (channel == 0 || channel > 6) {
+		rt_printk("gsc_hpdi: bug! invalid cable command channel\n");
+		return 0;
+	}
+	return 1;
+}
+
+// bit definitions
+
+enum firmware_revision_bits {
+	FEATURES_REG_PRESENT_BIT = 0x8000,
+};
+int firmware_revision(uint32_t fwr_bits)
+{
+	return fwr_bits & 0xff;
+}
+
+int pcb_revision(uint32_t fwr_bits)
+{
+	return (fwr_bits >> 8) & 0xff;
+}
+
+int hpdi_subid(uint32_t fwr_bits)
+{
+	return (fwr_bits >> 16) & 0xff;
+}
+
+enum board_control_bits {
+	BOARD_RESET_BIT = 0x1,	/* wait 10usec before accessing fifos */
+	TX_FIFO_RESET_BIT = 0x2,
+	RX_FIFO_RESET_BIT = 0x4,
+	TX_ENABLE_BIT = 0x10,
+	RX_ENABLE_BIT = 0x20,
+	DEMAND_DMA_DIRECTION_TX_BIT = 0x40,	/* for channel 0, channel 1 can only transmit (when present) */
+	LINE_VALID_ON_STATUS_VALID_BIT = 0x80,
+	START_TX_BIT = 0x10,
+	CABLE_THROTTLE_ENABLE_BIT = 0x20,
+	TEST_MODE_ENABLE_BIT = 0x80000000,
+};
+uint32_t command_discrete_output_bits(unsigned int channel, int output,
+	int output_value)
+{
+	uint32_t bits = 0;
+
+	if (command_channel_valid(channel) == 0)
+		return 0;
+	if (output) {
+		bits |= 0x1 << (16 + channel);
+		if (output_value)
+			bits |= 0x1 << (24 + channel);
+	} else
+		bits |= 0x1 << (24 + channel);
+
+	return bits;
+}
+
+enum board_status_bits {
+	COMMAND_LINE_STATUS_MASK = 0x7f,
+	TX_IN_PROGRESS_BIT = 0x80,
+	TX_NOT_EMPTY_BIT = 0x100,
+	TX_NOT_ALMOST_EMPTY_BIT = 0x200,
+	TX_NOT_ALMOST_FULL_BIT = 0x400,
+	TX_NOT_FULL_BIT = 0x800,
+	RX_NOT_EMPTY_BIT = 0x1000,
+	RX_NOT_ALMOST_EMPTY_BIT = 0x2000,
+	RX_NOT_ALMOST_FULL_BIT = 0x4000,
+	RX_NOT_FULL_BIT = 0x8000,
+	BOARD_JUMPER0_INSTALLED_BIT = 0x10000,
+	BOARD_JUMPER1_INSTALLED_BIT = 0x20000,
+	TX_OVERRUN_BIT = 0x200000,
+	RX_UNDERRUN_BIT = 0x400000,
+	RX_OVERRUN_BIT = 0x800000,
+};
+
+uint32_t almost_full_bits(unsigned int num_words)
+{
+// XXX need to add or subtract one?
+	return (num_words << 16) & 0xff0000;
+}
+
+uint32_t almost_empty_bits(unsigned int num_words)
+{
+	return num_words & 0xffff;
+}
+unsigned int almost_full_num_words(uint32_t bits)
+{
+// XXX need to add or subtract one?
+	return (bits >> 16) & 0xffff;
+}
+unsigned int almost_empty_num_words(uint32_t bits)
+{
+	return bits & 0xffff;
+}
+
+enum features_bits {
+	FIFO_SIZE_PRESENT_BIT = 0x1,
+	FIFO_WORDS_PRESENT_BIT = 0x2,
+	LEVEL_EDGE_INTERRUPTS_PRESENT_BIT = 0x4,
+	GPIO_SUPPORTED_BIT = 0x8,
+	PLX_DMA_CH1_SUPPORTED_BIT = 0x10,
+	OVERRUN_UNDERRUN_SUPPORTED_BIT = 0x20,
+};
+
+enum interrupt_sources {
+	FRAME_VALID_START_INTR = 0,
+	FRAME_VALID_END_INTR = 1,
+	TX_FIFO_EMPTY_INTR = 8,
+	TX_FIFO_ALMOST_EMPTY_INTR = 9,
+	TX_FIFO_ALMOST_FULL_INTR = 10,
+	TX_FIFO_FULL_INTR = 11,
+	RX_EMPTY_INTR = 12,
+	RX_ALMOST_EMPTY_INTR = 13,
+	RX_ALMOST_FULL_INTR = 14,
+	RX_FULL_INTR = 15,
+};
+int command_intr_source(unsigned int channel)
+{
+	if (command_channel_valid(channel) == 0)
+		channel = 1;
+	return channel + 1;
+}
+
+uint32_t intr_bit(int interrupt_source)
+{
+	return 0x1 << interrupt_source;
+}
+
+uint32_t tx_clock_divisor_bits(unsigned int divisor)
+{
+	return divisor & 0xff;
+}
+
+unsigned int fifo_size(uint32_t fifo_size_bits)
+{
+	return fifo_size_bits & 0xfffff;
+}
+
+unsigned int fifo_words(uint32_t fifo_words_bits)
+{
+	return fifo_words_bits & 0xfffff;
+}
+
+uint32_t intr_edge_bit(int interrupt_source)
+{
+	return 0x1 << interrupt_source;
+}
+
+uint32_t intr_active_high_bit(int interrupt_source)
+{
+	return 0x1 << interrupt_source;
+}
+
+typedef struct {
+	char *name;
+	int device_id;		// pci device id
+	int subdevice_id;	// pci subdevice id
+} hpdi_board;
+
+static const hpdi_board hpdi_boards[] = {
+	{
+	      name:	"pci-hpdi32",
+	      device_id:PCI_DEVICE_ID_PLX_9080,
+	      subdevice_id:0x2400,
+		},
+#if 0
+	{
+	      name:	"pxi-hpdi32",
+	      device_id:0x9656,
+	      subdevice_id:0x2705,
+		},
+#endif
+};
+
+static inline unsigned int num_boards(void)
+{
+	return sizeof(hpdi_boards) / sizeof(hpdi_board);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(hpdi_pci_table) = {
+	{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080, PCI_VENDOR_ID_PLX, 0x2400,
+		0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, hpdi_pci_table);
+
+static inline hpdi_board *board(const comedi_device * dev)
+{
+	return (hpdi_board *) dev->board_ptr;
+}
+
+typedef struct {
+	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
+	// base addresses (physical)
+	resource_size_t plx9080_phys_iobase;
+	resource_size_t hpdi_phys_iobase;
+	// base addresses (ioremapped)
+	void *plx9080_iobase;
+	void *hpdi_iobase;
+	uint32_t *dio_buffer[NUM_DMA_BUFFERS];	// dma buffers
+	dma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];	// physical addresses of dma buffers
+	struct plx_dma_desc *dma_desc;	// array of dma descriptors read by plx9080, allocated to get proper alignment
+	dma_addr_t dma_desc_phys_addr;	// physical address of dma descriptor array
+	unsigned int num_dma_descriptors;
+	uint32_t *desc_dio_buffer[NUM_DMA_DESCRIPTORS];	// pointer to start of buffers indexed by descriptor
+	volatile unsigned int dma_desc_index;	// index of the dma descriptor that is currently being used
+	unsigned int tx_fifo_size;
+	unsigned int rx_fifo_size;
+	volatile unsigned long dio_count;
+	volatile uint32_t bits[24];	// software copies of values written to hpdi registers
+	volatile unsigned int block_size;	// number of bytes at which to generate COMEDI_CB_BLOCK events
+	unsigned dio_config_output:1;
+} hpdi_private;
+
+static inline hpdi_private *priv(comedi_device * dev)
+{
+	return dev->private;
+}
+
+static comedi_driver driver_hpdi = {
+      driver_name:"gsc_hpdi",
+      module:THIS_MODULE,
+      attach:hpdi_attach,
+      detach:hpdi_detach,
+};
+
+COMEDI_PCI_INITCLEANUP(driver_hpdi, hpdi_pci_table);
+
+static int dio_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		priv(dev)->dio_config_output = 1;
+		return insn->n;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		priv(dev)->dio_config_output = 0;
+		return insn->n;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			priv(dev)->
+			dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+		break;
+	case INSN_CONFIG_BLOCK_SIZE:
+		return dio_config_block_size(dev, data);
+		break;
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static void disable_plx_interrupts(comedi_device * dev)
+{
+	writel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+}
+
+// initialize plx9080 chip
+static void init_plx9080(comedi_device * dev)
+{
+	uint32_t bits;
+	void *plx_iobase = priv(dev)->plx9080_iobase;
+
+	// plx9080 dump
+	DEBUG_PRINT(" plx interrupt status 0x%x\n",
+		readl(plx_iobase + PLX_INTRCS_REG));
+	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
+	DEBUG_PRINT(" plx control reg 0x%x\n",
+		readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));
+
+	DEBUG_PRINT(" plx revision 0x%x\n",
+		readl(plx_iobase + PLX_REVISION_REG));
+	DEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_MODE_REG));
+	DEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",
+		readl(plx_iobase + PLX_DMA1_MODE_REG));
+	DEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));
+	DEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));
+	DEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));
+	DEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));
+	DEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",
+		readb(plx_iobase + PLX_DMA0_CS_REG));
+	DEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",
+		readl(plx_iobase + PLX_DMA0_THRESHOLD_REG));
+	DEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));
+#ifdef __BIG_ENDIAN
+	bits = BIGEND_DMA0 | BIGEND_DMA1;
+#else
+	bits = 0;
+#endif
+	writel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);
+
+	disable_plx_interrupts(dev);
+
+	abort_dma(dev, 0);
+	abort_dma(dev, 1);
+
+	// configure dma0 mode
+	bits = 0;
+	// enable ready input
+	bits |= PLX_DMA_EN_READYIN_BIT;
+	// enable dma chaining
+	bits |= PLX_EN_CHAIN_BIT;
+	// enable interrupt on dma done (probably don't need this, since chain never finishes)
+	bits |= PLX_EN_DMA_DONE_INTR_BIT;
+	// don't increment local address during transfers (we are transferring from a fixed fifo register)
+	bits |= PLX_LOCAL_ADDR_CONST_BIT;
+	// route dma interrupt to pci bus
+	bits |= PLX_DMA_INTR_PCI_BIT;
+	// enable demand mode
+	bits |= PLX_DEMAND_MODE_BIT;
+	// enable local burst mode
+	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
+	bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
+	writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
+}
+
+/* Allocate and initialize the subdevice structures.
+ */
+static int setup_subdevices(comedi_device * dev)
+{
+	comedi_subdevice *s;
+
+	if (alloc_subdevices(dev, 1) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+/*	dev->write_subdev = s; */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags =
+		SDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;
+	s->n_chan = 32;
+	s->len_chanlist = 32;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_config = dio_config_insn;
+	s->do_cmd = hpdi_cmd;
+	s->do_cmdtest = hpdi_cmd_test;
+	s->cancel = hpdi_cancel;
+
+	return 0;
+}
+
+static int init_hpdi(comedi_device * dev)
+{
+	uint32_t plx_intcsr_bits;
+
+	writel(BOARD_RESET_BIT, priv(dev)->hpdi_iobase + BOARD_CONTROL_REG);
+	comedi_udelay(10);
+
+	writel(almost_empty_bits(32) | almost_full_bits(32),
+		priv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);
+	writel(almost_empty_bits(32) | almost_full_bits(32),
+		priv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);
+
+	priv(dev)->tx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
+			TX_FIFO_SIZE_REG));
+	priv(dev)->rx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +
+			RX_FIFO_SIZE_REG));
+
+	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+
+	// enable interrupts
+	plx_intcsr_bits =
+		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
+		ICS_DMA0_E;
+	writel(plx_intcsr_bits, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+
+	return 0;
+}
+
+// setup dma descriptors so a link completes every 'transfer_size' bytes
+static int setup_dma_descriptors(comedi_device * dev,
+	unsigned int transfer_size)
+{
+	unsigned int buffer_index, buffer_offset;
+	uint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+		PLX_XFER_LOCAL_TO_PCI;
+	unsigned int i;
+
+	if (transfer_size > DMA_BUFFER_SIZE)
+		transfer_size = DMA_BUFFER_SIZE;
+	transfer_size -= transfer_size % sizeof(uint32_t);
+	if (transfer_size == 0)
+		return -1;
+
+	DEBUG_PRINT(" transfer_size %i\n", transfer_size);
+	DEBUG_PRINT(" descriptors at 0x%lx\n",
+		(unsigned long)priv(dev)->dma_desc_phys_addr);
+
+	buffer_offset = 0;
+	buffer_index = 0;
+	for (i = 0; i < NUM_DMA_DESCRIPTORS &&
+		buffer_index < NUM_DMA_BUFFERS; i++) {
+		priv(dev)->dma_desc[i].pci_start_addr =
+			cpu_to_le32(priv(dev)->
+			dio_buffer_phys_addr[buffer_index] + buffer_offset);
+		priv(dev)->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);
+		priv(dev)->dma_desc[i].transfer_size =
+			cpu_to_le32(transfer_size);
+		priv(dev)->dma_desc[i].next =
+			cpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +
+					1) *
+				sizeof(priv(dev)->dma_desc[0])) | next_bits);
+
+		priv(dev)->desc_dio_buffer[i] =
+			priv(dev)->dio_buffer[buffer_index] +
+			(buffer_offset / sizeof(uint32_t));
+
+		buffer_offset += transfer_size;
+		if (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {
+			buffer_offset = 0;
+			buffer_index++;
+		}
+
+		DEBUG_PRINT(" desc %i\n", i);
+		DEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",
+			priv(dev)->desc_dio_buffer[i],
+			(unsigned long)priv(dev)->dma_desc[i].pci_start_addr);
+		DEBUG_PRINT(" next 0x%lx\n",
+			(unsigned long)priv(dev)->dma_desc[i].next);
+	}
+	priv(dev)->num_dma_descriptors = i;
+	// fix last descriptor to point back to first
+	priv(dev)->dma_desc[i - 1].next =
+		cpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);
+	DEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,
+		(unsigned long)priv(dev)->dma_desc[i - 1].next);
+
+	priv(dev)->block_size = transfer_size;
+
+	return transfer_size;
+}
+
+static int hpdi_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	struct pci_dev *pcidev;
+	int i;
+	int retval;
+
+	printk("comedi%d: gsc_hpdi\n", dev->minor);
+
+	if (alloc_private(dev, sizeof(hpdi_private)) < 0)
+		return -ENOMEM;
+
+	pcidev = NULL;
+	for (i = 0; i < num_boards() && dev->board_ptr == NULL; i++) {
+		do {
+			pcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,
+				hpdi_boards[i].device_id, PCI_VENDOR_ID_PLX,
+				hpdi_boards[i].subdevice_id, pcidev);
+			// was a particular bus/slot requested?
+			if (it->options[0] || it->options[1]) {
+				// are we on the wrong bus/slot?
+				if (pcidev->bus->number != it->options[0] ||
+					PCI_SLOT(pcidev->devfn) !=
+					it->options[1])
+					continue;
+			}
+			if (pcidev) {
+				priv(dev)->hw_dev = pcidev;
+				dev->board_ptr = hpdi_boards + i;
+				break;
+			}
+		} while (pcidev != NULL);
+	}
+	if (dev->board_ptr == NULL) {
+		printk("gsc_hpdi: no hpdi card found\n");
+		return -EIO;
+	}
+
+	printk("gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,
+		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+
+	if (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {
+		printk(KERN_WARNING
+			" failed enable PCI device and request regions\n");
+		return -EIO;
+	}
+	pci_set_master(pcidev);
+
+	//Initialize dev->board_name
+	dev->board_name = board(dev)->name;
+
+	priv(dev)->plx9080_phys_iobase =
+		pci_resource_start(pcidev, PLX9080_BADDRINDEX);
+	priv(dev)->hpdi_phys_iobase =
+		pci_resource_start(pcidev, HPDI_BADDRINDEX);
+
+	// remap, won't work with 2.0 kernels but who cares
+	priv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,
+		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
+	priv(dev)->hpdi_iobase = ioremap(priv(dev)->hpdi_phys_iobase,
+		pci_resource_len(pcidev, HPDI_BADDRINDEX));
+	if (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {
+		printk(" failed to remap io memory\n");
+		return -ENOMEM;
+	}
+
+	DEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);
+	DEBUG_PRINT(" hpdi remapped to 0x%p\n", priv(dev)->hpdi_iobase);
+
+	init_plx9080(dev);
+
+	// get irq
+	if (comedi_request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,
+			driver_hpdi.driver_name, dev)) {
+		printk(" unable to allocate irq %u\n", pcidev->irq);
+		return -EINVAL;
+	}
+	dev->irq = pcidev->irq;
+
+	printk(" irq %u\n", dev->irq);
+
+	// alocate pci dma buffers
+	for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+		priv(dev)->dio_buffer[i] =
+			pci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,
+			&priv(dev)->dio_buffer_phys_addr[i]);
+		DEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",
+			priv(dev)->dio_buffer[i],
+			(unsigned long)priv(dev)->dio_buffer_phys_addr[i]);
+	}
+	// allocate dma descriptors
+	priv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,
+		sizeof(struct plx_dma_desc) * NUM_DMA_DESCRIPTORS,
+		&priv(dev)->dma_desc_phys_addr);
+	if (priv(dev)->dma_desc_phys_addr & 0xf) {
+		printk(" dma descriptors not quad-word aligned (bug)\n");
+		return -EIO;
+	}
+
+	retval = setup_dma_descriptors(dev, 0x1000);
+	if (retval < 0)
+		return retval;
+
+	retval = setup_subdevices(dev);
+	if (retval < 0)
+		return retval;
+
+	return init_hpdi(dev);
+}
+
+static int hpdi_detach(comedi_device * dev)
+{
+	unsigned int i;
+
+	printk("comedi%d: gsc_hpdi: remove\n", dev->minor);
+
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (priv(dev)) {
+		if (priv(dev)->hw_dev) {
+			if (priv(dev)->plx9080_iobase) {
+				disable_plx_interrupts(dev);
+				iounmap((void *)priv(dev)->plx9080_iobase);
+			}
+			if (priv(dev)->hpdi_iobase)
+				iounmap((void *)priv(dev)->hpdi_iobase);
+			// free pci dma buffers
+			for (i = 0; i < NUM_DMA_BUFFERS; i++) {
+				if (priv(dev)->dio_buffer[i])
+					pci_free_consistent(priv(dev)->hw_dev,
+						DMA_BUFFER_SIZE,
+						priv(dev)->dio_buffer[i],
+						priv(dev)->
+						dio_buffer_phys_addr[i]);
+			}
+			// free dma descriptors
+			if (priv(dev)->dma_desc)
+				pci_free_consistent(priv(dev)->hw_dev,
+					sizeof(struct plx_dma_desc) *
+					NUM_DMA_DESCRIPTORS,
+					priv(dev)->dma_desc,
+					priv(dev)->dma_desc_phys_addr);
+			if (priv(dev)->hpdi_phys_iobase) {
+				comedi_pci_disable(priv(dev)->hw_dev);
+			}
+			pci_dev_put(priv(dev)->hw_dev);
+		}
+	}
+	return 0;
+}
+
+static int dio_config_block_size(comedi_device * dev, lsampl_t * data)
+{
+	unsigned int requested_block_size;
+	int retval;
+
+	requested_block_size = data[1];
+
+	retval = setup_dma_descriptors(dev, requested_block_size);
+	if (retval < 0)
+		return retval;
+
+	data[1] = retval;
+
+	return 2;
+}
+
+static int di_cmd_test(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int i;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	// uniqueness check
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 32;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (err)
+		return 4;
+
+	if (cmd->chanlist) {
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) != i) {
+				// XXX could support 8 channels or 16 channels
+				comedi_error(dev,
+					"chanlist must be channels 0 to 31 in order");
+				err++;
+				break;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int hpdi_cmd_test(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	if (priv(dev)->dio_config_output) {
+		return -EINVAL;
+	} else
+		return di_cmd_test(dev, s, cmd);
+}
+
+static inline void hpdi_writel(comedi_device * dev, uint32_t bits,
+	unsigned int offset)
+{
+	writel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],
+		priv(dev)->hpdi_iobase + offset);
+}
+
+static int di_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	uint32_t bits;
+	unsigned long flags;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+
+	hpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);
+
+	DEBUG_PRINT("hpdi: in di_cmd\n");
+
+	abort_dma(dev, 0);
+
+	priv(dev)->dma_desc_index = 0;
+
+	/* These register are supposedly unused during chained dma,
+	 * but I have found that left over values from last operation
+	 * occasionally cause problems with transfer of first dma
+	 * block.  Initializing them to zero seems to fix the problem. */
+	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);
+	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);
+	writel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);
+	// give location of first dma descriptor
+	bits = priv(dev)->
+		dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |
+		PLX_XFER_LOCAL_TO_PCI;
+	writel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);
+
+	// spinlock for plx dma control/status reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	// enable dma transfer
+	writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,
+		priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		priv(dev)->dio_count = cmd->stop_arg;
+	else
+		priv(dev)->dio_count = 1;
+
+	// clear over/under run status flags
+	writel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,
+		priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+	// enable interrupts
+	writel(intr_bit(RX_FULL_INTR),
+		priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+
+	DEBUG_PRINT("hpdi: starting rx\n");
+	hpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);
+
+	return 0;
+}
+
+static int hpdi_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	if (priv(dev)->dio_config_output) {
+		return -EINVAL;
+	} else
+		return di_cmd(dev, s);
+}
+
+static void drain_dma_buffers(comedi_device * dev, unsigned int channel)
+{
+	comedi_async *async = dev->read_subdev->async;
+	uint32_t next_transfer_addr;
+	int j;
+	int num_samples = 0;
+	void *pci_addr_reg;
+
+	if (channel)
+		pci_addr_reg =
+			priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;
+	else
+		pci_addr_reg =
+			priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
+
+	// loop until we have read all the full buffers
+	j = 0;
+	for (next_transfer_addr = readl(pci_addr_reg);
+		(next_transfer_addr <
+			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
+					dma_desc_index].pci_start_addr)
+			|| next_transfer_addr >=
+			le32_to_cpu(priv(dev)->dma_desc[priv(dev)->
+					dma_desc_index].pci_start_addr) +
+			priv(dev)->block_size)
+		&& j < priv(dev)->num_dma_descriptors; j++) {
+		// transfer data from dma buffer to comedi buffer
+		num_samples = priv(dev)->block_size / sizeof(uint32_t);
+		if (async->cmd.stop_src == TRIG_COUNT) {
+			if (num_samples > priv(dev)->dio_count)
+				num_samples = priv(dev)->dio_count;
+			priv(dev)->dio_count -= num_samples;
+		}
+		cfc_write_array_to_buffer(dev->read_subdev,
+			priv(dev)->desc_dio_buffer[priv(dev)->dma_desc_index],
+			num_samples * sizeof(uint32_t));
+		priv(dev)->dma_desc_index++;
+		priv(dev)->dma_desc_index %= priv(dev)->num_dma_descriptors;
+
+		DEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)
+			priv(dev)->dma_desc[priv(dev)->dma_desc_index].next);
+		DEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);
+	}
+	// XXX check for buffer overrun somehow
+}
+
+static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async = s->async;
+	uint32_t hpdi_intr_status, hpdi_board_status;
+	uint32_t plx_status;
+	uint32_t plx_bits;
+	uint8_t dma0_status, dma1_status;
+	unsigned long flags;
+
+	if (!dev->attached) {
+		return IRQ_NONE;
+	}
+
+	plx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);
+	if ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0) {
+		return IRQ_NONE;
+	}
+
+	hpdi_intr_status = readl(priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
+	hpdi_board_status = readl(priv(dev)->hpdi_iobase + BOARD_STATUS_REG);
+
+	async->events = 0;
+
+	if (hpdi_intr_status) {
+		DEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);
+		writel(hpdi_intr_status,
+			priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
+	}
+	// spin lock makes sure noone else changes plx dma control reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+	if (plx_status & ICS_DMA0_A) {	// dma chan 0 interrupt
+		writeb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+			priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
+
+		DEBUG_PRINT("dma0 status 0x%x\n", dma0_status);
+		if (dma0_status & PLX_DMA_EN_BIT) {
+			drain_dma_buffers(dev, 0);
+		}
+		DEBUG_PRINT(" cleared dma ch0 interrupt\n");
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// spin lock makes sure noone else changes plx dma control reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+	if (plx_status & ICS_DMA1_A)	// XXX
+	{			// dma chan 1 interrupt
+		writeb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
+			priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
+		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
+
+		DEBUG_PRINT(" cleared dma ch1 interrupt\n");
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// clear possible plx9080 interrupt sources
+	if (plx_status & ICS_LDIA) {	// clear local doorbell interrupt
+		plx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		writel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);
+		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
+	}
+
+	if (hpdi_board_status & RX_OVERRUN_BIT) {
+		comedi_error(dev, "rx fifo overrun");
+		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		DEBUG_PRINT("dma0_status 0x%x\n",
+			(int)readb(priv(dev)->plx9080_iobase +
+				PLX_DMA0_CS_REG));
+	}
+
+	if (hpdi_board_status & RX_UNDERRUN_BIT) {
+		comedi_error(dev, "rx fifo underrun");
+		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+	}
+
+	if (priv(dev)->dio_count == 0)
+		async->events |= COMEDI_CB_EOA;
+
+	DEBUG_PRINT("board status 0x%x, ", hpdi_board_status);
+	DEBUG_PRINT("plx status 0x%x\n", plx_status);
+	if (async->events)
+		DEBUG_PRINT(" events 0x%x\n", async->events);
+
+	cfc_handle_events(dev, s);
+
+	return IRQ_HANDLED;
+}
+
+void abort_dma(comedi_device * dev, unsigned int channel)
+{
+	unsigned long flags;
+
+	// spinlock for plx dma control/status reg
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+
+	plx9080_abort_dma(priv(dev)->plx9080_iobase, channel);
+
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+}
+
+static int hpdi_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	hpdi_writel(dev, 0, BOARD_CONTROL_REG);
+
+	writel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);
+
+	abort_dma(dev, 0);
+
+	return 0;
+}
