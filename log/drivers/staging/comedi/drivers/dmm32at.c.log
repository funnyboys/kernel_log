commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1e3d83b97d1f..75693cdde313 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 771cceb71069..1e3d83b97d1f 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * dmm32at.c
  * Diamond Systems Diamond-MM-32-AT Comedi driver

commit bc9e43ad503e35016f5679884ec1e400e09d2c66
Author: Saber Rezvani <irsaber@gmail.com>
Date:   Thu Feb 9 16:29:56 2017 +0330

    staging: comedi: dmm32at: usleep_range is preferred over udelay
    
    Fix the checkpatch.pl issue:
    CHECK: usleep_range is preferred over udelay
    
    Signed-off-by: Saber Rezvani <irsaber@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index b8606ded0623..771cceb71069 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -510,7 +510,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	outb(DMM32AT_CTRL_RESETA, dev->iobase + DMM32AT_CTRL_REG);
 
 	/* allow a millisecond to reset */
-	udelay(1000);
+	usleep_range(1000, 3000);
 
 	/* zero scan and fifo control */
 	outb(0x0, dev->iobase + DMM32AT_FIFO_CTRL_REG);
@@ -526,7 +526,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	outb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AI_CFG_REG);
 
 	/* should take 10 us to settle, here's a hundred */
-	udelay(100);
+	usleep_range(100, 200);
 
 	/* read back the values */
 	ailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);

commit d9b9c9a0339fb3f5b6c6365b144f1fa717f5b147
Author: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
Date:   Tue Jun 14 11:23:22 2016 +0530

    Staging: comedi: dmm32at: fix BIT macro issue.
    
    This Replace all occurences of (1<<x) by BIT(x) and DMM32AT_CTRL_PAGE(x),
    DMM32AT_AI_CFG_SCINT(x) macros to get rid of checkpatch.pl
    "CHECK" output "Prefer using the BIT macro"
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankarkm32@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 958c0d4aae5c..b8606ded0623 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -46,73 +46,75 @@
 #define DMM32AT_AI_START_CONV_REG	0x00
 #define DMM32AT_AI_LSB_REG		0x00
 #define DMM32AT_AUX_DOUT_REG		0x01
-#define DMM32AT_AUX_DOUT2		(1 << 2)  /* J3.42 - OUT2 (OUT2EN) */
-#define DMM32AT_AUX_DOUT1		(1 << 1)  /* J3.43 */
-#define DMM32AT_AUX_DOUT0		(1 << 0)  /* J3.44 - OUT0 (OUT0EN) */
+#define DMM32AT_AUX_DOUT2		BIT(2)  /* J3.42 - OUT2 (OUT2EN) */
+#define DMM32AT_AUX_DOUT1		BIT(1)  /* J3.43 */
+#define DMM32AT_AUX_DOUT0		BIT(0)  /* J3.44 - OUT0 (OUT0EN) */
 #define DMM32AT_AI_MSB_REG		0x01
 #define DMM32AT_AI_LO_CHAN_REG		0x02
 #define DMM32AT_AI_HI_CHAN_REG		0x03
 #define DMM32AT_AUX_DI_REG		0x04
-#define DMM32AT_AUX_DI_DACBUSY		(1 << 7)
-#define DMM32AT_AUX_DI_CALBUSY		(1 << 6)
-#define DMM32AT_AUX_DI3			(1 << 3)  /* J3.45 - ADCLK (CLKSEL) */
-#define DMM32AT_AUX_DI2			(1 << 2)  /* J3.46 - GATE12 (GT12EN) */
-#define DMM32AT_AUX_DI1			(1 << 1)  /* J3.47 - GATE0 (GT0EN) */
-#define DMM32AT_AUX_DI0			(1 << 0)  /* J3.48 - CLK0 (SRC0) */
+#define DMM32AT_AUX_DI_DACBUSY		BIT(7)
+#define DMM32AT_AUX_DI_CALBUSY		BIT(6)
+#define DMM32AT_AUX_DI3			BIT(3)  /* J3.45 - ADCLK (CLKSEL) */
+#define DMM32AT_AUX_DI2			BIT(2)  /* J3.46 - GATE12 (GT12EN) */
+#define DMM32AT_AUX_DI1			BIT(1)  /* J3.47 - GATE0 (GT0EN) */
+#define DMM32AT_AUX_DI0			BIT(0)  /* J3.48 - CLK0 (SRC0) */
 #define DMM32AT_AO_LSB_REG		0x04
 #define DMM32AT_AO_MSB_REG		0x05
 #define DMM32AT_AO_MSB_DACH(x)		((x) << 6)
 #define DMM32AT_FIFO_DEPTH_REG		0x06
 #define DMM32AT_FIFO_CTRL_REG		0x07
-#define DMM32AT_FIFO_CTRL_FIFOEN	(1 << 3)
-#define DMM32AT_FIFO_CTRL_SCANEN	(1 << 2)
-#define DMM32AT_FIFO_CTRL_FIFORST	(1 << 1)
+#define DMM32AT_FIFO_CTRL_FIFOEN	BIT(3)
+#define DMM32AT_FIFO_CTRL_SCANEN	BIT(2)
+#define DMM32AT_FIFO_CTRL_FIFORST	BIT(1)
 #define DMM32AT_FIFO_STATUS_REG		0x07
-#define DMM32AT_FIFO_STATUS_EF		(1 << 7)
-#define DMM32AT_FIFO_STATUS_HF		(1 << 6)
-#define DMM32AT_FIFO_STATUS_FF		(1 << 5)
-#define DMM32AT_FIFO_STATUS_OVF		(1 << 4)
-#define DMM32AT_FIFO_STATUS_FIFOEN	(1 << 3)
-#define DMM32AT_FIFO_STATUS_SCANEN	(1 << 2)
+#define DMM32AT_FIFO_STATUS_EF		BIT(7)
+#define DMM32AT_FIFO_STATUS_HF		BIT(6)
+#define DMM32AT_FIFO_STATUS_FF		BIT(5)
+#define DMM32AT_FIFO_STATUS_OVF		BIT(4)
+#define DMM32AT_FIFO_STATUS_FIFOEN	BIT(3)
+#define DMM32AT_FIFO_STATUS_SCANEN	BIT(2)
 #define DMM32AT_FIFO_STATUS_PAGE_MASK	(3 << 0)
 #define DMM32AT_CTRL_REG		0x08
-#define DMM32AT_CTRL_RESETA		(1 << 5)
-#define DMM32AT_CTRL_RESETD		(1 << 4)
-#define DMM32AT_CTRL_INTRST		(1 << 3)
-#define DMM32AT_CTRL_PAGE_8254		(0 << 0)
-#define DMM32AT_CTRL_PAGE_8255		(1 << 0)
-#define DMM32AT_CTRL_PAGE_CALIB		(3 << 0)
+#define DMM32AT_CTRL_RESETA		BIT(5)
+#define DMM32AT_CTRL_RESETD		BIT(4)
+#define DMM32AT_CTRL_INTRST		BIT(3)
+#define DMM32AT_CTRL_PAGE(x)		((x) << 0)
+#define DMM32AT_CTRL_PAGE_8254		DMM32AT_CTRL_PAGE(0)
+#define DMM32AT_CTRL_PAGE_8255		DMM32AT_CTRL_PAGE(1)
+#define DMM32AT_CTRL_PAGE_CALIB		DMM32AT_CTRL_PAGE(3)
 #define DMM32AT_AI_STATUS_REG		0x08
-#define DMM32AT_AI_STATUS_STS		(1 << 7)
-#define DMM32AT_AI_STATUS_SD1		(1 << 6)
-#define DMM32AT_AI_STATUS_SD0		(1 << 5)
+#define DMM32AT_AI_STATUS_STS		BIT(7)
+#define DMM32AT_AI_STATUS_SD1		BIT(6)
+#define DMM32AT_AI_STATUS_SD0		BIT(5)
 #define DMM32AT_AI_STATUS_ADCH_MASK	(0x1f << 0)
 #define DMM32AT_INTCLK_REG		0x09
-#define DMM32AT_INTCLK_ADINT		(1 << 7)
-#define DMM32AT_INTCLK_DINT		(1 << 6)
-#define DMM32AT_INTCLK_TINT		(1 << 5)
-#define DMM32AT_INTCLK_CLKEN		(1 << 1)  /* 1=see below  0=software */
-#define DMM32AT_INTCLK_CLKSEL		(1 << 0)  /* 1=OUT2  0=EXTCLK */
+#define DMM32AT_INTCLK_ADINT		BIT(7)
+#define DMM32AT_INTCLK_DINT		BIT(6)
+#define DMM32AT_INTCLK_TINT		BIT(5)
+#define DMM32AT_INTCLK_CLKEN		BIT(1)  /* 1=see below  0=software */
+#define DMM32AT_INTCLK_CLKSEL		BIT(0)  /* 1=OUT2  0=EXTCLK */
 #define DMM32AT_CTRDIO_CFG_REG		0x0a
-#define DMM32AT_CTRDIO_CFG_FREQ12	(1 << 7)  /* CLK12 1=100KHz 0=10MHz */
-#define DMM32AT_CTRDIO_CFG_FREQ0	(1 << 6)  /* CLK0  1=10KHz  0=10MHz */
-#define DMM32AT_CTRDIO_CFG_OUT2EN	(1 << 5)  /* J3.42 1=OUT2 is DOUT2 */
-#define DMM32AT_CTRDIO_CFG_OUT0EN	(1 << 4)  /* J3,44 1=OUT0 is DOUT0 */
-#define DMM32AT_CTRDIO_CFG_GT0EN	(1 << 2)  /* J3.47 1=DIN1 is GATE0 */
-#define DMM32AT_CTRDIO_CFG_SRC0		(1 << 1)  /* CLK0 is 0=FREQ0 1=J3.48 */
-#define DMM32AT_CTRDIO_CFG_GT12EN	(1 << 0)  /* J3.46 1=DIN2 is GATE12 */
+#define DMM32AT_CTRDIO_CFG_FREQ12	BIT(7)  /* CLK12 1=100KHz 0=10MHz */
+#define DMM32AT_CTRDIO_CFG_FREQ0	BIT(6)  /* CLK0  1=10KHz  0=10MHz */
+#define DMM32AT_CTRDIO_CFG_OUT2EN	BIT(5)  /* J3.42 1=OUT2 is DOUT2 */
+#define DMM32AT_CTRDIO_CFG_OUT0EN	BIT(4)  /* J3,44 1=OUT0 is DOUT0 */
+#define DMM32AT_CTRDIO_CFG_GT0EN	BIT(2)  /* J3.47 1=DIN1 is GATE0 */
+#define DMM32AT_CTRDIO_CFG_SRC0		BIT(1)  /* CLK0 is 0=FREQ0 1=J3.48 */
+#define DMM32AT_CTRDIO_CFG_GT12EN	BIT(0)  /* J3.46 1=DIN2 is GATE12 */
 #define DMM32AT_AI_CFG_REG		0x0b
-#define DMM32AT_AI_CFG_SCINT_20US	(0 << 4)
-#define DMM32AT_AI_CFG_SCINT_15US	(1 << 4)
-#define DMM32AT_AI_CFG_SCINT_10US	(2 << 4)
-#define DMM32AT_AI_CFG_SCINT_5US	(3 << 4)
-#define DMM32AT_AI_CFG_RANGE		(1 << 3)  /* 0=5V  1=10V */
-#define DMM32AT_AI_CFG_ADBU		(1 << 2)  /* 0=bipolar  1=unipolar */
+#define DMM32AT_AI_CFG_SCINT(x)		((x) << 4)
+#define DMM32AT_AI_CFG_SCINT_20US	DMM32AT_AI_CFG_SCINT(0)
+#define DMM32AT_AI_CFG_SCINT_15US	DMM32AT_AI_CFG_SCINT(1)
+#define DMM32AT_AI_CFG_SCINT_10US	DMM32AT_AI_CFG_SCINT(2)
+#define DMM32AT_AI_CFG_SCINT_5US	DMM32AT_AI_CFG_SCINT(3)
+#define DMM32AT_AI_CFG_RANGE		BIT(3)  /* 0=5V  1=10V */
+#define DMM32AT_AI_CFG_ADBU		BIT(2)  /* 0=bipolar  1=unipolar */
 #define DMM32AT_AI_CFG_GAIN(x)		((x) << 0)
 #define DMM32AT_AI_READBACK_REG		0x0b
-#define DMM32AT_AI_READBACK_WAIT	(1 << 7)  /* DMM32AT_AI_STATUS_STS */
-#define DMM32AT_AI_READBACK_RANGE	(1 << 3)
-#define DMM32AT_AI_READBACK_ADBU	(1 << 2)
+#define DMM32AT_AI_READBACK_WAIT	BIT(7)  /* DMM32AT_AI_STATUS_STS */
+#define DMM32AT_AI_READBACK_RANGE	BIT(3)
+#define DMM32AT_AI_READBACK_ADBU	BIT(2)
 #define DMM32AT_AI_READBACK_GAIN_MASK	(3 << 0)
 
 #define DMM32AT_CLK1 0x0d

commit fa4c586e17dc1f5402235e4a78399ebc2026c435
Author: Abdul Hussain <habdul@visteon.com>
Date:   Mon Jun 22 06:10:56 2015 +0000

    Staging: comedi: dmm32at: Simplify a trivial if-return sequence
    
    This patch simplify a trivial if-return sequence. Possibly combine with
    a preceding function call.
    
    Signed-off-by: Abdul Hussain <habdul@visteon.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index bb2883c83afa..958c0d4aae5c 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -607,11 +607,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
-	ret = subdev_8255_init(dev, s, dmm32at_8255_io, DMM32AT_8255_IOBASE);
-	if (ret)
-		return ret;
-
-	return 0;
+	return subdev_8255_init(dev, s, dmm32at_8255_io, DMM32AT_8255_IOBASE);
 }
 
 static struct comedi_driver dmm32at_driver = {

commit b504252a768c3d939f017f2c9044e3f7309be51e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:13 2015 +0000

    staging: comedi: dmm32at: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 094422f81d4c..bb2883c83afa 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -41,7 +41,6 @@
 #include "../comedidev.h"
 
 #include "8255.h"
-#include "comedi_fc.h"
 
 /* Board register addresses */
 #define DMM32AT_AI_START_CONV_REG	0x00
@@ -274,18 +273,18 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -294,10 +293,10 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);
-	err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);
+	err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);
+	err |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);
 
 	if (cmd->convert_arg >= 17500)
 		cmd->convert_arg = 20000;
@@ -308,12 +307,13 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	else
 		cmd->convert_arg = 5000;
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else /* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -321,7 +321,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	/* Step 4: fix up any arguments */
 
 	arg = cmd->convert_arg * cmd->scan_end_arg;
-	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
+	err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 
 	if (err)
 		return 4;

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 74830f4b95f5..094422f81d4c 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -397,7 +397,6 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	return 0;
-
 }
 
 static int dmm32at_ai_cancel(struct comedi_device *dev,

commit 9949595c0da61ff2aecc90c3a8e924848e6ac03b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:15 2015 -0700

    staging: comedi: drivers/*.c: fix common misspellings
    
    Fix these common misspellings:
      s/dependancy/dependency
      s/occured/occurred
      s/informations/information
      s/intialize/initialize
      s/serveral/several
      s/interrups/interrupts
      s/acknowledgement/acknowledgment
      s/suppport/support
      s/writting/writing
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1af006609fc1..74830f4b95f5 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -30,7 +30,7 @@
  * This driver is for the Diamond Systems MM-32-AT board
  *	http://www.diamondsystems.com/products/diamondmm32at
  *
- * It is being used on serveral projects inside NASA, without
+ * It is being used on several projects inside NASA, without
  * problems so far. For analog input commands, TRIG_EXT is not
  * yet supported.
  */
@@ -391,7 +391,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* start the clock and enable the interrupts */
 		dmm32at_setaitimer(dev, cmd->scan_begin_arg);
 	} else {
-		/* start the interrups and initiate a single scan */
+		/* start the interrupts and initiate a single scan */
 		outb(DMM32AT_INTCLK_ADINT, dev->iobase + DMM32AT_INTCLK_REG);
 		outb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);
 	}

commit df4d44edbc258e4620e9fa7de2a876d81ca48dfa
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:44 2015 +0000

    staging: comedi: dmm32at: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 31919b8713fa..1af006609fc1 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -19,7 +19,7 @@
 /*
  * Driver: dmm32at
  * Description: Diamond Systems Diamond-MM-32-AT
- * Devices: (Diamond Systems) Diamond-MM-32-AT [dmm32at]
+ * Devices: [Diamond Systems] Diamond-MM-32-AT (dmm32at)
  * Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
  * Updated: Fri Jun  4 09:13:24 CDT 2004
  * Status: experimental

commit fc1964a5f44caf8c9accbc6b390d51b10ef0e718
Author: David Decotigny <ddecotig@gmail.com>
Date:   Thu Dec 25 12:28:28 2014 -0800

    staging: comedi: dmm32at: fix style issues
    
    Before:
          1 ERROR: code indent should use tabs where possible
          1 WARNING: please, no spaces at the start of a line
    
    After:
      (none)
    
    Signed-off-by: David Decotigny <ddecotig@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 6df298a99cc6..31919b8713fa 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -365,7 +365,7 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 	/* enable the ai conversion interrupt and the clock to start scans */
 	outb(DMM32AT_INTCLK_ADINT |
 	     DMM32AT_INTCLK_CLKEN | DMM32AT_INTCLK_CLKSEL,
-             dev->iobase + DMM32AT_INTCLK_REG);
+	     dev->iobase + DMM32AT_INTCLK_REG);
 }
 
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 09732262aff4..6df298a99cc6 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -601,7 +601,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->maxdata	= 0x0fff;
 	s->range_table	= &dmm32at_aoranges;
 	s->insn_write	= dmm32at_ao_insn_write;
-	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 921890b0d674cece0a9becf8f38a14deaef6d3d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:46 2014 -0700

    staging: comedi: dmm32at: update the MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something more useful than the generic
    "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 738c205365ea..09732262aff4 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -625,5 +625,5 @@ static struct comedi_driver dmm32at_driver = {
 module_comedi_driver(dmm32at_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi: Diamond Systems Diamond-MM-32-AT");
 MODULE_LICENSE("GPL");

commit a26f3d3274deacfa2f190a21f7c5de9492ecb28a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:45 2014 -0700

    staging: comedi: dmm32at: tidy up multi-line comments
    
    Reformat the multi-line comments for follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 87ed1b3e3c62..738c205365ea 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -1,36 +1,39 @@
 /*
-    comedi/drivers/dmm32at.c
-    Diamond Systems mm32at code for a Comedi driver
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
+ * dmm32at.c
+ * Diamond Systems Diamond-MM-32-AT Comedi driver
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
 /*
-Driver: dmm32at
-Description: Diamond Systems mm32at driver.
-Devices:
-Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
-Updated: Fri Jun  4 09:13:24 CDT 2004
-Status: experimental
-
-This driver is for the Diamond Systems MM-32-AT board
-http://www.diamondsystems.com/products/diamondmm32at It is being used
-on serveral projects inside NASA, without problems so far. For analog
-input commands, TRIG_EXT is not yet supported at all..
-
-Configuration Options:
-  comedi_config /dev/comedi0 dmm32at baseaddr,irq
-*/
+ * Driver: dmm32at
+ * Description: Diamond Systems Diamond-MM-32-AT
+ * Devices: (Diamond Systems) Diamond-MM-32-AT [dmm32at]
+ * Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
+ * Updated: Fri Jun  4 09:13:24 CDT 2004
+ * Status: experimental
+ *
+ * Configuration Options:
+ *	comedi_config /dev/comedi0 dmm32at baseaddr,irq
+ *
+ * This driver is for the Diamond Systems MM-32-AT board
+ *	http://www.diamondsystems.com/products/diamondmm32at
+ *
+ * It is being used on serveral projects inside NASA, without
+ * problems so far. For analog input commands, TRIG_EXT is not
+ * yet supported.
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>

commit fc7e1c08846100cbd5bbeeb0ee18349c229d27a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:44 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AIRBACK
    
    For aesthetics, rename this define used for the Analog I/O Readback register.
    Define the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ff88810c622d..87ed1b3e3c62 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -107,8 +107,11 @@ Configuration Options:
 #define DMM32AT_AI_CFG_RANGE		(1 << 3)  /* 0=5V  1=10V */
 #define DMM32AT_AI_CFG_ADBU		(1 << 2)  /* 0=bipolar  1=unipolar */
 #define DMM32AT_AI_CFG_GAIN(x)		((x) << 0)
-
-#define DMM32AT_AIRBACK 0x0b
+#define DMM32AT_AI_READBACK_REG		0x0b
+#define DMM32AT_AI_READBACK_WAIT	(1 << 7)  /* DMM32AT_AI_STATUS_STS */
+#define DMM32AT_AI_READBACK_RANGE	(1 << 3)
+#define DMM32AT_AI_READBACK_ADBU	(1 << 2)
+#define DMM32AT_AI_READBACK_GAIN_MASK	(3 << 0)
 
 #define DMM32AT_CLK1 0x0d
 #define DMM32AT_CLK2 0x0e
@@ -213,7 +216,8 @@ static int dmm32at_ai_insn_read(struct comedi_device *dev,
 	dmm32at_ai_set_chanspec(dev, s, insn->chanspec, 1);
 
 	/* wait for circuit to settle */
-	ret = comedi_timeout(dev, s, insn, dmm32at_ai_status, DMM32AT_AIRBACK);
+	ret = comedi_timeout(dev, s, insn, dmm32at_ai_status,
+			     DMM32AT_AI_READBACK_REG);
 	if (ret)
 		return ret;
 
@@ -375,7 +379,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * wait for circuit to settle
 	 * we don't have the 'insn' here but it's not needed
 	 */
-	ret = comedi_timeout(dev, s, NULL, dmm32at_ai_status, DMM32AT_AIRBACK);
+	ret = comedi_timeout(dev, s, NULL, dmm32at_ai_status,
+			     DMM32AT_AI_READBACK_REG);
 	if (ret)
 		return ret;
 
@@ -525,7 +530,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	fifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);
 	aistat = inb(dev->iobase + DMM32AT_AI_STATUS_REG);
 	intstat = inb(dev->iobase + DMM32AT_INTCLK_REG);
-	airback = inb(dev->iobase + DMM32AT_AIRBACK);
+	airback = inb(dev->iobase + DMM32AT_AI_READBACK_REG);
 
 	/*
 	 * NOTE: The (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0)

commit 06d0ac3664cb92045d48220d7eef9da6ab6c1671
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:43 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AICONF
    
    For aesthetics, rename this define used for the Analog Configuration register.
    Define the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index b2da8193a383..ff88810c622d 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -99,8 +99,15 @@ Configuration Options:
 #define DMM32AT_CTRDIO_CFG_GT0EN	(1 << 2)  /* J3.47 1=DIN1 is GATE0 */
 #define DMM32AT_CTRDIO_CFG_SRC0		(1 << 1)  /* CLK0 is 0=FREQ0 1=J3.48 */
 #define DMM32AT_CTRDIO_CFG_GT12EN	(1 << 0)  /* J3.46 1=DIN2 is GATE12 */
+#define DMM32AT_AI_CFG_REG		0x0b
+#define DMM32AT_AI_CFG_SCINT_20US	(0 << 4)
+#define DMM32AT_AI_CFG_SCINT_15US	(1 << 4)
+#define DMM32AT_AI_CFG_SCINT_10US	(2 << 4)
+#define DMM32AT_AI_CFG_SCINT_5US	(3 << 4)
+#define DMM32AT_AI_CFG_RANGE		(1 << 3)  /* 0=5V  1=10V */
+#define DMM32AT_AI_CFG_ADBU		(1 << 2)  /* 0=bipolar  1=unipolar */
+#define DMM32AT_AI_CFG_GAIN(x)		((x) << 0)
 
-#define DMM32AT_AICONF 0x0b
 #define DMM32AT_AIRBACK 0x0b
 
 #define DMM32AT_CLK1 0x0d
@@ -111,15 +118,11 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_AICONF 0x0b */
+/* DMM32AT_AI_CFG_REG 0x0b */
 #define DMM32AT_RANGE_U10 0x0c
 #define DMM32AT_RANGE_U5 0x0d
 #define DMM32AT_RANGE_B10 0x08
 #define DMM32AT_RANGE_B5 0x00
-#define DMM32AT_SCINT_20 0x00
-#define DMM32AT_SCINT_15 0x10
-#define DMM32AT_SCINT_10 0x20
-#define DMM32AT_SCINT_5 0x30
 
 /* DMM32AT_CLKCT 0x0f */
 #define DMM32AT_CLKCT1 0x56	/* mode3 counter 1 - write low byte only */
@@ -171,7 +174,7 @@ static void dmm32at_ai_set_chanspec(struct comedi_device *dev,
 
 	outb(chan, dev->iobase + DMM32AT_AI_LO_CHAN_REG);
 	outb(last_chan, dev->iobase + DMM32AT_AI_HI_CHAN_REG);
-	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
+	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AI_CFG_REG);
 }
 
 static unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,
@@ -511,7 +514,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	outb(0xff, dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 
 	/* set the range at 10v unipolar */
-	outb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AICONF);
+	outb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AI_CFG_REG);
 
 	/* should take 10 us to settle, here's a hundred */
 	udelay(100);

commit bbf0a305fe861ffc7628a12d6c0ccda8b8d0d163
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:42 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_CNTRDIO
    
    For aesthetics, rename this define used for the Counter and Digital I/O
    Configuration register. Define the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 9058e327f0a1..b2da8193a383 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -91,8 +91,14 @@ Configuration Options:
 #define DMM32AT_INTCLK_TINT		(1 << 5)
 #define DMM32AT_INTCLK_CLKEN		(1 << 1)  /* 1=see below  0=software */
 #define DMM32AT_INTCLK_CLKSEL		(1 << 0)  /* 1=OUT2  0=EXTCLK */
-
-#define DMM32AT_CNTRDIO 0x0a
+#define DMM32AT_CTRDIO_CFG_REG		0x0a
+#define DMM32AT_CTRDIO_CFG_FREQ12	(1 << 7)  /* CLK12 1=100KHz 0=10MHz */
+#define DMM32AT_CTRDIO_CFG_FREQ0	(1 << 6)  /* CLK0  1=10KHz  0=10MHz */
+#define DMM32AT_CTRDIO_CFG_OUT2EN	(1 << 5)  /* J3.42 1=OUT2 is DOUT2 */
+#define DMM32AT_CTRDIO_CFG_OUT0EN	(1 << 4)  /* J3,44 1=OUT0 is DOUT0 */
+#define DMM32AT_CTRDIO_CFG_GT0EN	(1 << 2)  /* J3.47 1=DIN1 is GATE0 */
+#define DMM32AT_CTRDIO_CFG_SRC0		(1 << 1)  /* CLK0 is 0=FREQ0 1=J3.48 */
+#define DMM32AT_CTRDIO_CFG_GT12EN	(1 << 0)  /* J3.46 1=DIN2 is GATE12 */
 
 #define DMM32AT_AICONF 0x0b
 #define DMM32AT_AIRBACK 0x0b
@@ -105,9 +111,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_CNTRDIO 0x0a */
-#define DMM32AT_FREQ12 0x80
-
 /* DMM32AT_AICONF 0x0b */
 #define DMM32AT_RANGE_U10 0x0c
 #define DMM32AT_RANGE_U5 0x0d
@@ -334,8 +337,8 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 	hi2 = (both2 & 0xff00) >> 8;
 	lo2 = both2 & 0x00ff;
 
-	/* set the counter frequency to 10mhz */
-	outb(0, dev->iobase + DMM32AT_CNTRDIO);
+	/* set counter clocks to 10MHz, disable all aux dio */
+	outb(0, dev->iobase + DMM32AT_CTRDIO_CFG_REG);
 
 	/* get access to the clock regs */
 	outb(DMM32AT_CTRL_PAGE_8254, dev->iobase + DMM32AT_CTRL_REG);

commit 990c96d15efa77585e9e47ad57702cf65362ada6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:41 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_INTCLOCK
    
    For aesthetics, rename this define used for the Interrupt and A/D Clock Control
    and Status register. Also, rename the defines for the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 3f36f0ebf3a9..9058e327f0a1 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -85,8 +85,12 @@ Configuration Options:
 #define DMM32AT_AI_STATUS_SD1		(1 << 6)
 #define DMM32AT_AI_STATUS_SD0		(1 << 5)
 #define DMM32AT_AI_STATUS_ADCH_MASK	(0x1f << 0)
-
-#define DMM32AT_INTCLOCK 0x09
+#define DMM32AT_INTCLK_REG		0x09
+#define DMM32AT_INTCLK_ADINT		(1 << 7)
+#define DMM32AT_INTCLK_DINT		(1 << 6)
+#define DMM32AT_INTCLK_TINT		(1 << 5)
+#define DMM32AT_INTCLK_CLKEN		(1 << 1)  /* 1=see below  0=software */
+#define DMM32AT_INTCLK_CLKSEL		(1 << 0)  /* 1=OUT2  0=EXTCLK */
 
 #define DMM32AT_CNTRDIO 0x0a
 
@@ -101,10 +105,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_INTCLOCK 0x09 */
-#define DMM32AT_ADINT 0x80
-#define DMM32AT_CLKSEL 0x03
-
 /* DMM32AT_CNTRDIO 0x0a */
 #define DMM32AT_FREQ12 0x80
 
@@ -350,7 +350,9 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 	outb(hi2, dev->iobase + DMM32AT_CLK2);
 
 	/* enable the ai conversion interrupt and the clock to start scans */
-	outb(DMM32AT_ADINT | DMM32AT_CLKSEL, dev->iobase + DMM32AT_INTCLOCK);
+	outb(DMM32AT_INTCLK_ADINT |
+	     DMM32AT_INTCLK_CLKEN | DMM32AT_INTCLK_CLKSEL,
+             dev->iobase + DMM32AT_INTCLK_REG);
 }
 
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -376,7 +378,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		dmm32at_setaitimer(dev, cmd->scan_begin_arg);
 	} else {
 		/* start the interrups and initiate a single scan */
-		outb(DMM32AT_ADINT, dev->iobase + DMM32AT_INTCLOCK);
+		outb(DMM32AT_INTCLK_ADINT, dev->iobase + DMM32AT_INTCLK_REG);
 		outb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);
 	}
 
@@ -388,7 +390,7 @@ static int dmm32at_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	/* disable further interrupts and clocks */
-	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
+	outb(0x0, dev->iobase + DMM32AT_INTCLK_REG);
 	return 0;
 }
 
@@ -404,9 +406,9 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
+	intstat = inb(dev->iobase + DMM32AT_INTCLK_REG);
 
-	if (intstat & DMM32AT_ADINT) {
+	if (intstat & DMM32AT_INTCLK_ADINT) {
 		struct comedi_subdevice *s = dev->read_subdev;
 		struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -499,7 +501,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	outb(0x0, dev->iobase + DMM32AT_FIFO_CTRL_REG);
 
 	/* zero interrupt and clock control */
-	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
+	outb(0x0, dev->iobase + DMM32AT_INTCLK_REG);
 
 	/* write a test channel range, the high 3 bits should drop */
 	outb(0x80, dev->iobase + DMM32AT_AI_LO_CHAN_REG);
@@ -516,7 +518,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	aihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 	fifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);
 	aistat = inb(dev->iobase + DMM32AT_AI_STATUS_REG);
-	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
+	intstat = inb(dev->iobase + DMM32AT_INTCLK_REG);
 	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
 	/*

commit 4b82531e27c017d3e1a231fa9f87c5dd1bcda6fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:40 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AISTAT
    
    For aesthetics, rename this define used for the A/D Status register. Also,
    rename the defines for the bits of the register.
    
    The probe code in dmm32at_reset() checks this register to make sure the
    S/D1 and S/D0 bits are set. This check actually verifies that the board is
    configured (with jumpers on the board) with all the Analog Input channels
    operating in single-ended mode. Add a comment about this.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 4ebbd98e333d..3f36f0ebf3a9 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -80,7 +80,11 @@ Configuration Options:
 #define DMM32AT_CTRL_PAGE_8254		(0 << 0)
 #define DMM32AT_CTRL_PAGE_8255		(1 << 0)
 #define DMM32AT_CTRL_PAGE_CALIB		(3 << 0)
-#define DMM32AT_AISTAT 0x08
+#define DMM32AT_AI_STATUS_REG		0x08
+#define DMM32AT_AI_STATUS_STS		(1 << 7)
+#define DMM32AT_AI_STATUS_SD1		(1 << 6)
+#define DMM32AT_AI_STATUS_SD0		(1 << 5)
+#define DMM32AT_AI_STATUS_ADCH_MASK	(0x1f << 0)
 
 #define DMM32AT_INTCLOCK 0x09
 
@@ -97,9 +101,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_AISTAT 0x08 */
-#define DMM32AT_STATUS 0x80
-
 /* DMM32AT_INTCLOCK 0x09 */
 #define DMM32AT_ADINT 0x80
 #define DMM32AT_CLKSEL 0x03
@@ -190,7 +191,7 @@ static int dmm32at_ai_status(struct comedi_device *dev,
 	unsigned char status;
 
 	status = inb(dev->iobase + context);
-	if ((status & DMM32AT_STATUS) == 0)
+	if ((status & DMM32AT_AI_STATUS_STS) == 0)
 		return 0;
 	return -EBUSY;
 }
@@ -214,7 +215,7 @@ static int dmm32at_ai_insn_read(struct comedi_device *dev,
 		outb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);
 
 		ret = comedi_timeout(dev, s, insn, dmm32at_ai_status,
-				     DMM32AT_AISTAT);
+				     DMM32AT_AI_STATUS_REG);
 		if (ret)
 			return ret;
 
@@ -514,13 +515,19 @@ static int dmm32at_reset(struct comedi_device *dev)
 	ailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);
 	aihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 	fifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);
-	aistat = inb(dev->iobase + DMM32AT_AISTAT);
+	aistat = inb(dev->iobase + DMM32AT_AI_STATUS_REG);
 	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
 	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
+	/*
+	 * NOTE: The (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0)
+	 * test makes this driver only work if the board is configured
+	 * with all A/D channels set for single-ended operation.
+	 */
 	if (ailo != 0x00 || aihi != 0x1f ||
 	    fifostat != DMM32AT_FIFO_STATUS_EF ||
-	    aistat != 0x60 || intstat != 0x00 || airback != 0x0c)
+	    aistat != (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0) ||
+	    intstat != 0x00 || airback != 0x0c)
 		return -EIO;
 
 	return 0;

commit d900a48841091e07d34d26a7cb7b29ce0447752c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:39 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_CNTRL
    
    For aesthetics, rename this define used for the Miscellaneous Control
    register. Also, rename the defines for the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index c7f9602ce6e3..4ebbd98e333d 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -73,8 +73,13 @@ Configuration Options:
 #define DMM32AT_FIFO_STATUS_FIFOEN	(1 << 3)
 #define DMM32AT_FIFO_STATUS_SCANEN	(1 << 2)
 #define DMM32AT_FIFO_STATUS_PAGE_MASK	(3 << 0)
-
-#define DMM32AT_CNTRL 0x08
+#define DMM32AT_CTRL_REG		0x08
+#define DMM32AT_CTRL_RESETA		(1 << 5)
+#define DMM32AT_CTRL_RESETD		(1 << 4)
+#define DMM32AT_CTRL_INTRST		(1 << 3)
+#define DMM32AT_CTRL_PAGE_8254		(0 << 0)
+#define DMM32AT_CTRL_PAGE_8255		(1 << 0)
+#define DMM32AT_CTRL_PAGE_CALIB		(3 << 0)
 #define DMM32AT_AISTAT 0x08
 
 #define DMM32AT_INTCLOCK 0x09
@@ -92,12 +97,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_CNTRL 0x08 */
-#define DMM32AT_RESET 0x20
-#define DMM32AT_INTRESET 0x08
-#define DMM32AT_CLKACC 0x00
-#define DMM32AT_DIOACC 0x01
-
 /* DMM32AT_AISTAT 0x08 */
 #define DMM32AT_STATUS 0x80
 
@@ -338,7 +337,7 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 	outb(0, dev->iobase + DMM32AT_CNTRDIO);
 
 	/* get access to the clock regs */
-	outb(DMM32AT_CLKACC, dev->iobase + DMM32AT_CNTRL);
+	outb(DMM32AT_CTRL_PAGE_8254, dev->iobase + DMM32AT_CTRL_REG);
 
 	/* write the counter 1 control word and low byte to counter */
 	outb(DMM32AT_CLKCT1, dev->iobase + DMM32AT_CLKCT);
@@ -361,7 +360,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dmm32at_ai_set_chanspec(dev, s, cmd->chanlist[0], cmd->chanlist_len);
 
 	/* reset the interrupt just in case */
-	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);
+	outb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);
 
 	/*
 	 * wait for circuit to settle
@@ -423,7 +422,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 	}
 
 	/* reset the interrupt */
-	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);
+	outb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);
 	return IRQ_HANDLED;
 }
 
@@ -475,7 +474,7 @@ static int dmm32at_8255_io(struct comedi_device *dev,
 			   int dir, int port, int data, unsigned long regbase)
 {
 	/* get access to the DIO regs */
-	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
+	outb(DMM32AT_CTRL_PAGE_8255, dev->iobase + DMM32AT_CTRL_REG);
 
 	if (dir) {
 		outb(data, dev->iobase + regbase + port);
@@ -490,7 +489,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
 
 	/* reset the board */
-	outb(DMM32AT_RESET, dev->iobase + DMM32AT_CNTRL);
+	outb(DMM32AT_CTRL_RESETA, dev->iobase + DMM32AT_CTRL_REG);
 
 	/* allow a millisecond to reset */
 	udelay(1000);

commit 7586f90784be0e7153f6ec4de8317168874c4a6e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:38 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_FIFOSTAT
    
    For aesthetics, rename this define used for the FIFO Status register.
    Define the bits of the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index a58d51d1f533..c7f9602ce6e3 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -65,7 +65,14 @@ Configuration Options:
 #define DMM32AT_FIFO_CTRL_FIFOEN	(1 << 3)
 #define DMM32AT_FIFO_CTRL_SCANEN	(1 << 2)
 #define DMM32AT_FIFO_CTRL_FIFORST	(1 << 1)
-#define DMM32AT_FIFOSTAT 0x07
+#define DMM32AT_FIFO_STATUS_REG		0x07
+#define DMM32AT_FIFO_STATUS_EF		(1 << 7)
+#define DMM32AT_FIFO_STATUS_HF		(1 << 6)
+#define DMM32AT_FIFO_STATUS_FF		(1 << 5)
+#define DMM32AT_FIFO_STATUS_OVF		(1 << 4)
+#define DMM32AT_FIFO_STATUS_FIFOEN	(1 << 3)
+#define DMM32AT_FIFO_STATUS_SCANEN	(1 << 2)
+#define DMM32AT_FIFO_STATUS_PAGE_MASK	(3 << 0)
 
 #define DMM32AT_CNTRL 0x08
 #define DMM32AT_AISTAT 0x08
@@ -507,12 +514,13 @@ static int dmm32at_reset(struct comedi_device *dev)
 	/* read back the values */
 	ailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);
 	aihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);
-	fifostat = inb(dev->iobase + DMM32AT_FIFOSTAT);
+	fifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);
 	aistat = inb(dev->iobase + DMM32AT_AISTAT);
 	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
 	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
-	if (ailo != 0x00 || aihi != 0x1f || fifostat != 0x80 ||
+	if (ailo != 0x00 || aihi != 0x1f ||
+	    fifostat != DMM32AT_FIFO_STATUS_EF ||
 	    aistat != 0x60 || intstat != 0x00 || airback != 0x0c)
 		return -EIO;
 

commit b8c17c479ae429e2e696f219781e6ad8799a04f2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:37 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_FIFOCNTRL
    
    For aesthetics, rename this define used for the FIFO Control register.
    Also, rename the defines used for the bits of this register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 463a62b843bc..a58d51d1f533 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -61,8 +61,10 @@ Configuration Options:
 #define DMM32AT_AO_MSB_REG		0x05
 #define DMM32AT_AO_MSB_DACH(x)		((x) << 6)
 #define DMM32AT_FIFO_DEPTH_REG		0x06
-
-#define DMM32AT_FIFOCNTRL 0x07
+#define DMM32AT_FIFO_CTRL_REG		0x07
+#define DMM32AT_FIFO_CTRL_FIFOEN	(1 << 3)
+#define DMM32AT_FIFO_CTRL_SCANEN	(1 << 2)
+#define DMM32AT_FIFO_CTRL_FIFORST	(1 << 1)
 #define DMM32AT_FIFOSTAT 0x07
 
 #define DMM32AT_CNTRL 0x08
@@ -83,10 +85,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_FIFOCNTRL 0x07 */
-#define DMM32AT_FIFORESET 0x02
-#define DMM32AT_SCANENABLE 0x04
-
 /* DMM32AT_CNTRL 0x08 */
 #define DMM32AT_RESET 0x20
 #define DMM32AT_INTRESET 0x08
@@ -155,10 +153,11 @@ static void dmm32at_ai_set_chanspec(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(chanspec);
 	unsigned int last_chan = (chan + nchan - 1) % s->n_chan;
 
-	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
+	outb(DMM32AT_FIFO_CTRL_FIFORST, dev->iobase + DMM32AT_FIFO_CTRL_REG);
 
 	if (nchan > 1)
-		outb(DMM32AT_SCANENABLE, dev->iobase + DMM32AT_FIFOCNTRL);
+		outb(DMM32AT_FIFO_CTRL_SCANEN,
+		     dev->iobase + DMM32AT_FIFO_CTRL_REG);
 
 	outb(chan, dev->iobase + DMM32AT_AI_LO_CHAN_REG);
 	outb(last_chan, dev->iobase + DMM32AT_AI_HI_CHAN_REG);
@@ -490,7 +489,7 @@ static int dmm32at_reset(struct comedi_device *dev)
 	udelay(1000);
 
 	/* zero scan and fifo control */
-	outb(0x0, dev->iobase + DMM32AT_FIFOCNTRL);
+	outb(0x0, dev->iobase + DMM32AT_FIFO_CTRL_REG);
 
 	/* zero interrupt and clock control */
 	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);

commit d18f166773c77a8bc4bd14652b0c915d1195f80e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:36 2014 -0700

    staging: comedi: dmm32at: define the FIFO Depth register
    
    This driver currently does not use the FIFO. For completeness, define
    the offset to the FIFO Depth register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 8585069bc8fe..463a62b843bc 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -60,6 +60,7 @@ Configuration Options:
 #define DMM32AT_AO_LSB_REG		0x04
 #define DMM32AT_AO_MSB_REG		0x05
 #define DMM32AT_AO_MSB_DACH(x)		((x) << 6)
+#define DMM32AT_FIFO_DEPTH_REG		0x06
 
 #define DMM32AT_FIFOCNTRL 0x07
 #define DMM32AT_FIFOSTAT 0x07

commit e46f7651d0e34ac4fbc208bb70c7d6d6166742f3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:35 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_DACMSB_CHAN
    
    For aesthetics, rename this define used to set the DACH[10] bits in
    the DAC MSB register to select the D/A channel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 2bfa21bb03e7..8585069bc8fe 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -59,7 +59,7 @@ Configuration Options:
 #define DMM32AT_AUX_DI0			(1 << 0)  /* J3.48 - CLK0 (SRC0) */
 #define DMM32AT_AO_LSB_REG		0x04
 #define DMM32AT_AO_MSB_REG		0x05
-#define DMM32AT_DACMSB_CHAN(x)	((x) << 6)
+#define DMM32AT_AO_MSB_DACH(x)		((x) << 6)
 
 #define DMM32AT_FIFOCNTRL 0x07
 #define DMM32AT_FIFOSTAT 0x07
@@ -447,7 +447,7 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 
 		/* write LSB then MSB + chan to load DAC */
 		outb(val & 0xff, dev->iobase + DMM32AT_AO_LSB_REG);
-		outb((val >> 8) | DMM32AT_DACMSB_CHAN(chan),
+		outb((val >> 8) | DMM32AT_AO_MSB_DACH(chan),
 		     dev->iobase + DMM32AT_AO_MSB_REG);
 
 		/* wait for circuit to settle */

commit 668a02d1c8bc6c635e6ce215f1c8c6bed3e0dc07
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:34 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_DACSTAT
    
    For aesthetics, rename this define used for the Status / Auxillary Digital
    Inputs register. Document the bits in the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 39f416c3c402..2bfa21bb03e7 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -50,7 +50,13 @@ Configuration Options:
 #define DMM32AT_AI_MSB_REG		0x01
 #define DMM32AT_AI_LO_CHAN_REG		0x02
 #define DMM32AT_AI_HI_CHAN_REG		0x03
-#define DMM32AT_DACSTAT 0x04
+#define DMM32AT_AUX_DI_REG		0x04
+#define DMM32AT_AUX_DI_DACBUSY		(1 << 7)
+#define DMM32AT_AUX_DI_CALBUSY		(1 << 6)
+#define DMM32AT_AUX_DI3			(1 << 3)  /* J3.45 - ADCLK (CLKSEL) */
+#define DMM32AT_AUX_DI2			(1 << 2)  /* J3.46 - GATE12 (GT12EN) */
+#define DMM32AT_AUX_DI1			(1 << 1)  /* J3.47 - GATE0 (GT0EN) */
+#define DMM32AT_AUX_DI0			(1 << 0)  /* J3.48 - CLK0 (SRC0) */
 #define DMM32AT_AO_LSB_REG		0x04
 #define DMM32AT_AO_MSB_REG		0x05
 #define DMM32AT_DACMSB_CHAN(x)	((x) << 6)
@@ -76,9 +82,6 @@ Configuration Options:
 
 /* Board register values. */
 
-/* DMM32AT_DACSTAT 0x04 */
-#define DMM32AT_DACBUSY 0x80
-
 /* DMM32AT_FIFOCNTRL 0x07 */
 #define DMM32AT_FIFORESET 0x02
 #define DMM32AT_SCANENABLE 0x04
@@ -424,8 +427,8 @@ static int dmm32at_ao_eoc(struct comedi_device *dev,
 {
 	unsigned char status;
 
-	status = inb(dev->iobase + DMM32AT_DACSTAT);
-	if ((status & DMM32AT_DACBUSY) == 0)
+	status = inb(dev->iobase + DMM32AT_AUX_DI_REG);
+	if ((status & DMM32AT_AUX_DI_DACBUSY) == 0)
 		return 0;
 	return -EBUSY;
 }

commit 0db01ed89ee9a5474a6bbf55bda75baddf94b623
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:33 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_DAC[LM]SB
    
    For aesthetics, rename these defines used for the D/A LSB/MSB registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index f0519bc0cd9e..39f416c3c402 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -50,10 +50,9 @@ Configuration Options:
 #define DMM32AT_AI_MSB_REG		0x01
 #define DMM32AT_AI_LO_CHAN_REG		0x02
 #define DMM32AT_AI_HI_CHAN_REG		0x03
-
 #define DMM32AT_DACSTAT 0x04
-#define DMM32AT_DACLSB_REG	0x04
-#define DMM32AT_DACMSB_REG	0x05
+#define DMM32AT_AO_LSB_REG		0x04
+#define DMM32AT_AO_MSB_REG		0x05
 #define DMM32AT_DACMSB_CHAN(x)	((x) << 6)
 
 #define DMM32AT_FIFOCNTRL 0x07
@@ -444,9 +443,9 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 		int ret;
 
 		/* write LSB then MSB + chan to load DAC */
-		outb(val & 0xff, dev->iobase + DMM32AT_DACLSB_REG);
+		outb(val & 0xff, dev->iobase + DMM32AT_AO_LSB_REG);
 		outb((val >> 8) | DMM32AT_DACMSB_CHAN(chan),
-		     dev->iobase + DMM32AT_DACMSB_REG);
+		     dev->iobase + DMM32AT_AO_MSB_REG);
 
 		/* wait for circuit to settle */
 		ret = comedi_timeout(dev, s, insn, dmm32at_ao_eoc, 0);
@@ -454,7 +453,7 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 			return ret;
 
 		/* dummy read to update DAC */
-		inb(dev->iobase + DMM32AT_DACMSB_REG);
+		inb(dev->iobase + DMM32AT_AO_MSB_REG);
 
 		s->readback[chan] = val;
 	}

commit d443fae2341abddf04676deed0b8b3112eb17636
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:32 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AI{LOW,HIGH}
    
    For aesthetics, rename these defines used for the A/D Low/High Channel
    registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 2e5d5a43b1b6..f0519bc0cd9e 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -48,8 +48,8 @@ Configuration Options:
 #define DMM32AT_AUX_DOUT1		(1 << 1)  /* J3.43 */
 #define DMM32AT_AUX_DOUT0		(1 << 0)  /* J3.44 - OUT0 (OUT0EN) */
 #define DMM32AT_AI_MSB_REG		0x01
-#define DMM32AT_AILOW 0x02
-#define DMM32AT_AIHIGH 0x03
+#define DMM32AT_AI_LO_CHAN_REG		0x02
+#define DMM32AT_AI_HI_CHAN_REG		0x03
 
 #define DMM32AT_DACSTAT 0x04
 #define DMM32AT_DACLSB_REG	0x04
@@ -157,8 +157,8 @@ static void dmm32at_ai_set_chanspec(struct comedi_device *dev,
 	if (nchan > 1)
 		outb(DMM32AT_SCANENABLE, dev->iobase + DMM32AT_FIFOCNTRL);
 
-	outb(chan, dev->iobase + DMM32AT_AILOW);
-	outb(last_chan, dev->iobase + DMM32AT_AIHIGH);
+	outb(chan, dev->iobase + DMM32AT_AI_LO_CHAN_REG);
+	outb(last_chan, dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
 }
 
@@ -493,8 +493,8 @@ static int dmm32at_reset(struct comedi_device *dev)
 	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
 
 	/* write a test channel range, the high 3 bits should drop */
-	outb(0x80, dev->iobase + DMM32AT_AILOW);
-	outb(0xff, dev->iobase + DMM32AT_AIHIGH);
+	outb(0x80, dev->iobase + DMM32AT_AI_LO_CHAN_REG);
+	outb(0xff, dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 
 	/* set the range at 10v unipolar */
 	outb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AICONF);
@@ -503,8 +503,8 @@ static int dmm32at_reset(struct comedi_device *dev)
 	udelay(100);
 
 	/* read back the values */
-	ailo = inb(dev->iobase + DMM32AT_AILOW);
-	aihi = inb(dev->iobase + DMM32AT_AIHIGH);
+	ailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);
+	aihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);
 	fifostat = inb(dev->iobase + DMM32AT_FIFOSTAT);
 	aistat = inb(dev->iobase + DMM32AT_AISTAT);
 	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);

commit 02a173eefbdc987e4729abe22399587a78828da6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:31 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AUXDOUT
    
    For aesthetics, rename this define used for the Auxillary Digital Output
    register. This register is currently not used in the driver. Document the
    bits of the register for completeness.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index e3981115c7b7..2e5d5a43b1b6 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -43,7 +43,10 @@ Configuration Options:
 /* Board register addresses */
 #define DMM32AT_AI_START_CONV_REG	0x00
 #define DMM32AT_AI_LSB_REG		0x00
-#define DMM32AT_AUXDOUT 0x01
+#define DMM32AT_AUX_DOUT_REG		0x01
+#define DMM32AT_AUX_DOUT2		(1 << 2)  /* J3.42 - OUT2 (OUT2EN) */
+#define DMM32AT_AUX_DOUT1		(1 << 1)  /* J3.43 */
+#define DMM32AT_AUX_DOUT0		(1 << 0)  /* J3.44 - OUT0 (OUT0EN) */
 #define DMM32AT_AI_MSB_REG		0x01
 #define DMM32AT_AILOW 0x02
 #define DMM32AT_AIHIGH 0x03

commit 3f4beddff34832fa38c574c55d1fc60c286cb894
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:30 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_AI[LM]SB
    
    For aesthetics, rename these defines used for the A/D LSB/MSB registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ee6e510fef97..e3981115c7b7 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -42,9 +42,9 @@ Configuration Options:
 
 /* Board register addresses */
 #define DMM32AT_AI_START_CONV_REG	0x00
-#define DMM32AT_AILSB 0x00
+#define DMM32AT_AI_LSB_REG		0x00
 #define DMM32AT_AUXDOUT 0x01
-#define DMM32AT_AIMSB 0x01
+#define DMM32AT_AI_MSB_REG		0x01
 #define DMM32AT_AILOW 0x02
 #define DMM32AT_AIHIGH 0x03
 
@@ -164,8 +164,8 @@ static unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,
 {
 	unsigned int val;
 
-	val = inb(dev->iobase + DMM32AT_AILSB);
-	val |= (inb(dev->iobase + DMM32AT_AIMSB) << 8);
+	val = inb(dev->iobase + DMM32AT_AI_LSB_REG);
+	val |= (inb(dev->iobase + DMM32AT_AI_MSB_REG) << 8);
 
 	/* munge two's complement value to offset binary */
 	return comedi_offset_munge(s, val);

commit 32b994eaeed6300ad36b94ae089021bfdf84dc7f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:29 2014 -0700

    staging: comedi: dmm32at: rename DMM32AT_CONV
    
    For aesthetics, rename this define used for the Start A/D Conversion register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index df0a47fe0d11..ee6e510fef97 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -41,7 +41,7 @@ Configuration Options:
 #include "comedi_fc.h"
 
 /* Board register addresses */
-#define DMM32AT_CONV 0x00
+#define DMM32AT_AI_START_CONV_REG	0x00
 #define DMM32AT_AILSB 0x00
 #define DMM32AT_AUXDOUT 0x01
 #define DMM32AT_AIMSB 0x01
@@ -200,7 +200,7 @@ static int dmm32at_ai_insn_read(struct comedi_device *dev,
 		return ret;
 
 	for (i = 0; i < insn->n; i++) {
-		outb(0xff, dev->iobase + DMM32AT_CONV);
+		outb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);
 
 		ret = comedi_timeout(dev, s, insn, dmm32at_ai_status,
 				     DMM32AT_AISTAT);
@@ -365,7 +365,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	} else {
 		/* start the interrups and initiate a single scan */
 		outb(DMM32AT_ADINT, dev->iobase + DMM32AT_INTCLOCK);
-		outb(0xff, dev->iobase + DMM32AT_CONV);
+		outb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);
 	}
 
 	return 0;

commit 387ca51f7c403b342a9e382ac15c6df461ea2190
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:28 2014 -0700

    staging: comedi: dmm32at: use 8255 module for Digital I/O subdevice
    
    The Dimond-MM-32-AT board uses an internal 82C55-type digital I/O circuit to
    provide the 24 digital I/O lines. The only quirk is the need to set the page
    selection bits in the control register to select page 1 addresses.
    
    Instead of duplicating the 8255 code, provide an (*io) callback and use the
    8255 module to support this subdevice.
    
    This also removes the need for the private data in this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index dc222d13e318..df0a47fe0d11 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -37,6 +37,7 @@ Configuration Options:
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 
+#include "8255.h"
 #include "comedi_fc.h"
 
 /* Board register addresses */
@@ -69,10 +70,7 @@ Configuration Options:
 #define DMM32AT_CLK2 0x0e
 #define DMM32AT_CLKCT 0x0f
 
-#define DMM32AT_DIOA 0x0c
-#define DMM32AT_DIOB 0x0d
-#define DMM32AT_DIOC 0x0e
-#define DMM32AT_DIOCONF 0x0f
+#define DMM32AT_8255_IOBASE		0x0c  /* Page 1 registers */
 
 /* Board register values. */
 
@@ -113,13 +111,6 @@ Configuration Options:
 #define DMM32AT_CLKCT1 0x56	/* mode3 counter 1 - write low byte only */
 #define DMM32AT_CLKCT2 0xb6	/*  mode3 counter 2 - write high and low byte */
 
-/* DMM32AT_DIOCONF 0x0f */
-#define DMM32AT_DIENABLE 0x80
-#define DMM32AT_DIRA 0x10
-#define DMM32AT_DIRB 0x02
-#define DMM32AT_DIRCL 0x01
-#define DMM32AT_DIRCH 0x08
-
 /* board AI ranges in comedi structure */
 static const struct comedi_lrange dmm32at_airanges = {
 	4, {
@@ -150,10 +141,6 @@ static const struct comedi_lrange dmm32at_aoranges = {
 	}
 };
 
-struct dmm32at_private {
-	unsigned char dio_config;
-};
-
 static void dmm32at_ai_set_chanspec(struct comedi_device *dev,
 				    struct comedi_subdevice *s,
 				    unsigned int chanspec, int nchan)
@@ -472,91 +459,22 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int dmm32at_dio_insn_bits(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned int *data)
-{
-	struct dmm32at_private *devpriv = dev->private;
-	unsigned int mask;
-	unsigned int val;
-
-	mask = comedi_dio_update_state(s, data);
-	if (mask) {
-		/* get access to the DIO regs */
-		outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-
-		/* if either part of dio is set for output */
-		if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
-		    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
-			val = (s->state & 0x00ff0000) >> 16;
-			outb(val, dev->iobase + DMM32AT_DIOC);
-		}
-		if ((devpriv->dio_config & DMM32AT_DIRB) == 0) {
-			val = (s->state & 0x0000ff00) >> 8;
-			outb(val, dev->iobase + DMM32AT_DIOB);
-		}
-		if ((devpriv->dio_config & DMM32AT_DIRA) == 0) {
-			val = (s->state & 0x000000ff);
-			outb(val, dev->iobase + DMM32AT_DIOA);
-		}
-	}
-
-	val = inb(dev->iobase + DMM32AT_DIOA);
-	val |= inb(dev->iobase + DMM32AT_DIOB) << 8;
-	val |= inb(dev->iobase + DMM32AT_DIOC) << 16;
-	s->state = val;
-
-	data[1] = val;
-
-	return insn->n;
-}
-
-static int dmm32at_dio_insn_config(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data)
+static int dmm32at_8255_io(struct comedi_device *dev,
+			   int dir, int port, int data, unsigned long regbase)
 {
-	struct dmm32at_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int mask;
-	unsigned char chanbit;
-	int ret;
-
-	if (chan < 8) {
-		mask = 0x0000ff;
-		chanbit = DMM32AT_DIRA;
-	} else if (chan < 16) {
-		mask = 0x00ff00;
-		chanbit = DMM32AT_DIRB;
-	} else if (chan < 20) {
-		mask = 0x0f0000;
-		chanbit = DMM32AT_DIRCL;
-	} else {
-		mask = 0xf00000;
-		chanbit = DMM32AT_DIRCH;
-	}
-
-	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
-	if (ret)
-		return ret;
-
-	if (data[0] == INSN_CONFIG_DIO_OUTPUT)
-		devpriv->dio_config &= ~chanbit;
-	else
-		devpriv->dio_config |= chanbit;
 	/* get access to the DIO regs */
 	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-	/* set the DIO's to the new configuration setting */
-	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
 
-	return insn->n;
+	if (dir) {
+		outb(data, dev->iobase + regbase + port);
+		return 0;
+	}
+	return inb(dev->iobase + regbase + port);
 }
 
 /* Make sure the board is there and put it to a known state */
 static int dmm32at_reset(struct comedi_device *dev)
 {
-	struct dmm32at_private *devpriv = dev->private;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
 
 	/* reset the board */
@@ -593,28 +511,15 @@ static int dmm32at_reset(struct comedi_device *dev)
 	    aistat != 0x60 || intstat != 0x00 || airback != 0x0c)
 		return -EIO;
 
-	/* get access to the DIO regs */
-	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-	/* set the DIO's to the defualt input setting */
-	devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-			      DMM32AT_DIRCL | DMM32AT_DIRCH |
-			      DMM32AT_DIENABLE;
-	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
-
 	return 0;
 }
 
 static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
-	struct dmm32at_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
@@ -669,13 +574,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
-	s->type		= COMEDI_SUBD_DIO;
-	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
-	s->n_chan	= 24;
-	s->maxdata	= 1;
-	s->range_table	= &range_digital;
-	s->insn_bits	= dmm32at_dio_insn_bits;
-	s->insn_config	= dmm32at_dio_insn_config;
+	ret = subdev_8255_init(dev, s, dmm32at_8255_io, DMM32AT_8255_IOBASE);
+	if (ret)
+		return ret;
 
 	return 0;
 }

commit c5f1b1e5529ef46769615ac8f4e38d0830b5a9c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:27 2014 -0700

    staging: comedi: dmm32at: introduce dmm32at_ai_set_chanspec()
    
    Introduce a helper function to set the analog input channel scan and range
    control registers. Use the new helper in the analog input (*insn_read) and
    (*do_cmd) functions.
    
    The extra sanity checks in the (*do_cmd) are not necessary. The cmd->chanlist
    will always be valid and the (*do_cmdtest) validates the channel list in
    Step 5.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 6413f60c6f6b..dc222d13e318 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -154,6 +154,24 @@ struct dmm32at_private {
 	unsigned char dio_config;
 };
 
+static void dmm32at_ai_set_chanspec(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    unsigned int chanspec, int nchan)
+{
+	unsigned int chan = CR_CHAN(chanspec);
+	unsigned int range = CR_RANGE(chanspec);
+	unsigned int last_chan = (chan + nchan - 1) % s->n_chan;
+
+	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
+
+	if (nchan > 1)
+		outb(DMM32AT_SCANENABLE, dev->iobase + DMM32AT_FIFOCNTRL);
+
+	outb(chan, dev->iobase + DMM32AT_AILOW);
+	outb(last_chan, dev->iobase + DMM32AT_AIHIGH);
+	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
+}
+
 static unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
@@ -184,18 +202,10 @@ static int dmm32at_ai_insn_read(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int range = CR_RANGE(insn->chanspec);
 	int ret;
 	int i;
 
-	/* zero scan and fifo control and reset fifo */
-	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
-
-	/* set the channel and range */
-	outb(chan, dev->iobase + DMM32AT_AILOW);
-	outb(chan, dev->iobase + DMM32AT_AIHIGH);
-	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
+	dmm32at_ai_set_chanspec(dev, s, insn->chanspec, 1);
 
 	/* wait for circuit to settle */
 	ret = comedi_timeout(dev, s, insn, dmm32at_ai_status, DMM32AT_AIRBACK);
@@ -347,32 +357,9 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int range;
-	unsigned char chanlo, chanhi;
 	int ret;
 
-	if (!cmd->chanlist)
-		return -EINVAL;
-
-	/* get the channel list and range */
-	chanlo = CR_CHAN(cmd->chanlist[0]) & (s->n_chan - 1);
-	chanhi = chanlo + cmd->chanlist_len - 1;
-	if (chanhi >= s->n_chan)
-		return -EINVAL;
-	range = CR_RANGE(cmd->chanlist[0]);
-
-	/* reset fifo */
-	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
-
-	/* set scan enable */
-	outb(DMM32AT_SCANENABLE, dev->iobase + DMM32AT_FIFOCNTRL);
-
-	/* write the ai channel range regs */
-	outb(chanlo, dev->iobase + DMM32AT_AILOW);
-	outb(chanhi, dev->iobase + DMM32AT_AIHIGH);
-
-	/* set the range bits */
-	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
+	dmm32at_ai_set_chanspec(dev, s, cmd->chanlist[0], cmd->chanlist_len);
 
 	/* reset the interrupt just in case */
 	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);

commit 2dd9681196c56a7ae48ec99522acc23843844bee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:26 2014 -0700

    staging: comedi: dmm32at: remove unused members of the private data
    
    The 'data' and 'ai_inuse' members in the private data are not used in the
    driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 297338f4f46b..6413f60c6f6b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -151,8 +151,6 @@ static const struct comedi_lrange dmm32at_aoranges = {
 };
 
 struct dmm32at_private {
-	int data;
-	int ai_inuse;
 	unsigned char dio_config;
 };
 

commit ec1b2320009bc2a9893c7a6eef32fdced0b4455d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:25 2014 -0700

    staging: comedi: dmm32at: remove dmm32at_ns_to_timer()
    
    This function is not necessary. It simply returns the 'ns' value that was
    passed to it.
    
    Remove it as well as the unnecessary Step 4 check of the cmd->convert_arg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 637b6651e559..297338f4f46b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -218,12 +218,6 @@ static int dmm32at_ai_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int dmm32at_ns_to_timer(unsigned int *ns, unsigned int flags)
-{
-	/* trivial timer */
-	return *ns;
-}
-
 static int dmm32at_ai_check_chanlist(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     struct comedi_cmd *cmd)
@@ -304,11 +298,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
-
-	arg = cmd->convert_arg;
-	dmm32at_ns_to_timer(&arg, cmd->flags);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+	/* Step 4: fix up any arguments */
 
 	arg = cmd->convert_arg * cmd->scan_end_arg;
 	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);

commit 85b0e7668a8d187c2bd59f5f60338168513e5602
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:24 2014 -0700

    staging: comedi: dmm32at: tidy up cmd->convert_{src, arg} validation
    
    This driver only supports a single convert_src, TRIG_TIMER. Tidy up
    the (*do_cmdtest) validation of the cmd->convert_{src,arg}.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 9a46a669179e..637b6651e559 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -262,8 +262,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
-					TRIG_TIMER /*| TRIG_EXT */);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
@@ -272,7 +271,6 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
 	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
@@ -287,20 +285,14 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);
 	err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg >= 17500)
-			cmd->convert_arg = 20000;
-		else if (cmd->convert_arg >= 12500)
-			cmd->convert_arg = 15000;
-		else if (cmd->convert_arg >= 7500)
-			cmd->convert_arg = 10000;
-		else
-			cmd->convert_arg = 5000;
-	} else {
-		/* external trigger */
-		/* see above */
-		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 9);
-	}
+	if (cmd->convert_arg >= 17500)
+		cmd->convert_arg = 20000;
+	else if (cmd->convert_arg >= 12500)
+		cmd->convert_arg = 15000;
+	else if (cmd->convert_arg >= 7500)
+		cmd->convert_arg = 10000;
+	else
+		cmd->convert_arg = 5000;
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
@@ -314,18 +306,12 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	arg = cmd->scan_begin_arg;
+	arg = cmd->convert_arg;
 	dmm32at_ns_to_timer(&arg, cmd->flags);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		arg = cmd->convert_arg;
-		dmm32at_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
-
-		arg = cmd->convert_arg * cmd->scan_end_arg;
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
-	}
+	arg = cmd->convert_arg * cmd->scan_end_arg;
+	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 
 	if (err)
 		return 4;

commit e5d44e8c8b0ea90627c41d1e350f6d01ee5f4a2a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:23 2014 -0700

    staging: comedi: dmm32at: tidy up cmd->scan_begin_{src, arg} validation
    
    This driver only supports a single scan_begin_src, TRIG_TIMER. Tidy up
    the (*do_cmdtest) validation of the cmd->scan_begin_{src,arg}.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 5e8a8db12972..9a46a669179e 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -261,8 +261,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
-					TRIG_TIMER /*| TRIG_EXT */);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
 	err |= cfc_check_trigger_src(&cmd->convert_src,
 					TRIG_TIMER /*| TRIG_EXT */);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
@@ -273,7 +272,6 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
 	err |= cfc_check_trigger_is_unique(cmd->convert_src);
 	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
@@ -286,20 +284,8 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-#define MAX_SCAN_SPEED	1000000	/* in nanoseconds */
-#define MIN_SCAN_SPEED	1000000000	/* in nanoseconds */
-
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 MAX_SCAN_SPEED);
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-						 MIN_SCAN_SPEED);
-	} else {
-		/* external trigger */
-		/* should be level/edge, hi/lo specification here */
-		/* should specify multiple external triggers */
-		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
-	}
+	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);
+	err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (cmd->convert_arg >= 17500)
@@ -328,21 +314,17 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		arg = cmd->scan_begin_arg;
-		dmm32at_ns_to_timer(&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
-	}
+	arg = cmd->scan_begin_arg;
+	dmm32at_ns_to_timer(&arg, cmd->flags);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
 		dmm32at_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
-		if (cmd->scan_begin_src == TRIG_TIMER) {
-			arg = cmd->convert_arg * cmd->scan_end_arg;
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 arg);
-		}
+		arg = cmd->convert_arg * cmd->scan_end_arg;
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit 646b55ee6418dd5f20eadc3cd6a4e04f4e1fa1a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:22 2014 -0700

    staging: comedi: dmm32at: tidy up subdevice initialization
    
    For aesthetics, add some whitespace to the subdevice initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 301bbb69698a..5e8a8db12972 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -693,48 +693,46 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	/* analog input subdevice */
-	s->type = COMEDI_SUBD_AI;
-	/* we support single-ended (ground) and differential */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
-	s->n_chan = 32;
-	s->maxdata = 0xffff;
-	s->range_table = &dmm32at_airanges;
-	s->insn_read = dmm32at_ai_insn_read;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF;
+	s->n_chan	= 32;
+	s->maxdata	= 0xffff;
+	s->range_table	= &dmm32at_airanges;
+	s->insn_read	= dmm32at_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->subdev_flags |= SDF_CMD_READ;
-		s->len_chanlist = 32;
-		s->do_cmd = dmm32at_ai_cmd;
-		s->do_cmdtest = dmm32at_ai_cmdtest;
-		s->cancel = dmm32at_ai_cancel;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->do_cmd	= dmm32at_ai_cmd;
+		s->do_cmdtest	= dmm32at_ai_cmdtest;
+		s->cancel	= dmm32at_ai_cancel;
 	}
 
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = 4;
-	s->maxdata = 0x0fff;
-	s->range_table = &dmm32at_aoranges;
-	s->insn_write = dmm32at_ao_insn_write;
-	s->insn_read = comedi_readback_insn_read;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 0x0fff;
+	s->range_table	= &dmm32at_aoranges;
+	s->insn_write	= dmm32at_ao_insn_write;
+	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)
 		return ret;
 
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
-	/* digital i/o subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 24;
-	s->maxdata = 1;
-	s->state = 0;
-	s->range_table = &range_digital;
-	s->insn_bits = dmm32at_dio_insn_bits;
-	s->insn_config = dmm32at_dio_insn_config;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 24;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= dmm32at_dio_insn_bits;
+	s->insn_config	= dmm32at_dio_insn_config;
 
 	return 0;
 }

commit 593ea59de723e32dd584ceb57efcdb96a5bca975
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:21 2014 -0700

    staging: comedi: dmm32at: introduce dmm32at_reset()
    
    For aesthetics, factor the board reset and detection code out of the
    (*attach) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index b21d08df4555..301bbb69698a 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -610,21 +610,12 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int dmm32at_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it)
+/* Make sure the board is there and put it to a known state */
+static int dmm32at_reset(struct comedi_device *dev)
 {
-	struct dmm32at_private *devpriv;
-	int ret;
-	struct comedi_subdevice *s;
+	struct dmm32at_private *devpriv = dev->private;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
 
-	ret = comedi_request_region(dev, it->options[0], 0x10);
-	if (ret)
-		return ret;
-
-	/* the following just makes sure the board is there and gets
-	   it to a known state */
-
 	/* reset the board */
 	outb(DMM32AT_RESET, dev->iobase + DMM32AT_CNTRL);
 
@@ -655,10 +646,40 @@ static int dmm32at_attach(struct comedi_device *dev,
 	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
 	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
-	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
-	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
-		dev_err(dev->class_dev, "board detection failed\n");
+	if (ailo != 0x00 || aihi != 0x1f || fifostat != 0x80 ||
+	    aistat != 0x60 || intstat != 0x00 || airback != 0x0c)
 		return -EIO;
+
+	/* get access to the DIO regs */
+	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
+	/* set the DIO's to the defualt input setting */
+	devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
+			      DMM32AT_DIRCL | DMM32AT_DIRCH |
+			      DMM32AT_DIENABLE;
+	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
+
+	return 0;
+}
+
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
+{
+	struct dmm32at_private *devpriv;
+	struct comedi_subdevice *s;
+	int ret;
+
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
+	ret = comedi_request_region(dev, it->options[0], 0x10);
+	if (ret)
+		return ret;
+
+	ret = dmm32at_reset(dev);
+	if (ret) {
+		dev_err(dev->class_dev, "board detection failed\n");
+		return ret;
 	}
 
 	if (it->options[1]) {
@@ -668,10 +689,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 			dev->irq = it->options[1];
 	}
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)
 		return ret;
@@ -710,15 +727,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
-
-	/* get access to the DIO regs */
-	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-	/* set the DIO's to the defualt input setting */
-	devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-		DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
-	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
-
-	/* set up the subdevice */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 	s->n_chan = 24;

commit 01b7ecdd9529fd5722b9b18424f510cc34cc8e85
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:20 2014 -0700

    staging: comedi: dmm32at: tidy up dmm32at_ai_rinsn()
    
    For aesthetics, rename this function to dmm32at_ai_insn_read().
    
    Get the 'chan' and 'range' from the chanspec when declaring the local
    variables. Remove the unecessary masking of the 'chan'.
    
    Remove some unnecessary comments.
    
    Change the final return to 'insn->n' to clarify the return value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index b90f61965396..b21d08df4555 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -181,27 +181,22 @@ static int dmm32at_ai_status(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int dmm32at_ai_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	int n;
-	unsigned char chan;
-	int range;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
 	int ret;
-
-	/* get the channel and range number */
-
-	chan = CR_CHAN(insn->chanspec) & (s->n_chan - 1);
-	range = CR_RANGE(insn->chanspec);
+	int i;
 
 	/* zero scan and fifo control and reset fifo */
 	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
 
-	/* write the ai channel range regs */
+	/* set the channel and range */
 	outb(chan, dev->iobase + DMM32AT_AILOW);
 	outb(chan, dev->iobase + DMM32AT_AIHIGH);
-	/* set the range bits */
 	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
 
 	/* wait for circuit to settle */
@@ -209,22 +204,18 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* convert n samples */
-	for (n = 0; n < insn->n; n++) {
-		/* trigger conversion */
+	for (i = 0; i < insn->n; i++) {
 		outb(0xff, dev->iobase + DMM32AT_CONV);
 
-		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, dmm32at_ai_status,
 				     DMM32AT_AISTAT);
 		if (ret)
 			return ret;
 
-		data[n] = dmm32at_ai_get_sample(dev, s);
+		data[i] = dmm32at_ai_get_sample(dev, s);
 	}
 
-	/* return the number of samples read/written */
-	return n;
+	return insn->n;
 }
 
 static int dmm32at_ns_to_timer(unsigned int *ns, unsigned int flags)
@@ -693,7 +684,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->n_chan = 32;
 	s->maxdata = 0xffff;
 	s->range_table = &dmm32at_airanges;
-	s->insn_read = dmm32at_ai_rinsn;
+	s->insn_read = dmm32at_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;

commit 0c0eadadcbe6ed9596568696f9c5b157707a7c8f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:19 2014 -0700

    staging: comedi: dmm32at: introduce dmm32_ai_get_sample()
    
    Introduce a helper function to read the two's complement analog input
    sample from the hardware and munge it to the offset binary (unsigned)
    format that comedi expects. Use the comedi_offset_munge() helper to
    munge the data.
    
    Use the new helper in the analog input (*insn_read) and in the interrupt
    handler for the async command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index fce3b855fdbd..b90f61965396 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -156,6 +156,18 @@ struct dmm32at_private {
 	unsigned char dio_config;
 };
 
+static unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,
+					  struct comedi_subdevice *s)
+{
+	unsigned int val;
+
+	val = inb(dev->iobase + DMM32AT_AILSB);
+	val |= (inb(dev->iobase + DMM32AT_AIMSB) << 8);
+
+	/* munge two's complement value to offset binary */
+	return comedi_offset_munge(s, val);
+}
+
 static int dmm32at_ai_status(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn,
@@ -174,8 +186,6 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	int n;
-	unsigned int d;
-	unsigned short msb, lsb;
 	unsigned char chan;
 	int range;
 	int ret;
@@ -210,19 +220,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		if (ret)
 			return ret;
 
-		/* read data */
-		lsb = inb(dev->iobase + DMM32AT_AILSB);
-		msb = inb(dev->iobase + DMM32AT_AIMSB);
-
-		/* invert sign bit to make range unsigned, this is an
-		   idiosyncrasy of the diamond board, it return
-		   conversions as a signed value, i.e. -32768 to
-		   32767, flipping the bit and interpreting it as
-		   signed gives you a range of 0 to 65535 which is
-		   used by comedi */
-		d = ((msb ^ 0x0080) << 8) + lsb;
-
-		data[n] = d;
+		data[n] = dmm32at_ai_get_sample(dev, s);
 	}
 
 	/* return the number of samples read/written */
@@ -465,8 +463,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned char intstat;
-	unsigned int samp;
-	unsigned short msb, lsb;
+	unsigned int val;
 	int i;
 
 	if (!dev->attached) {
@@ -481,13 +478,8 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 		struct comedi_cmd *cmd = &s->async->cmd;
 
 		for (i = 0; i < cmd->chanlist_len; i++) {
-			/* read data */
-			lsb = inb(dev->iobase + DMM32AT_AILSB);
-			msb = inb(dev->iobase + DMM32AT_AIMSB);
-
-			/* invert sign bit to make range unsigned */
-			samp = ((msb ^ 0x0080) << 8) + lsb;
-			comedi_buf_write_samples(s, &samp, 1);
+			val = dmm32at_ai_get_sample(dev, s);
+			comedi_buf_write_samples(s, &val, 1);
 		}
 
 		if (cmd->stop_src == TRIG_COUNT &&

commit 933fca13a0b81aa247e0b428f0b873f9b8a5137e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:18 2014 -0700

    staging: comedi: dmm32at: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'ai_scans_left' and use the comedi_async
    'scans_done' to detect the end-of-acquisition.
    
    This also removes the artifical max limit on the cmd->stop_arg.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index d73ba5b2f749..fce3b855fdbd 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -153,7 +153,6 @@ static const struct comedi_lrange dmm32at_aoranges = {
 struct dmm32at_private {
 	int data;
 	int ai_inuse;
-	unsigned int ai_scans_left;
 	unsigned char dio_config;
 };
 
@@ -330,13 +329,10 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0xfffffff0);
+	if (cmd->stop_src == TRIG_COUNT)
 		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
-	} else {
-		/* TRIG_NONE */
+	else /* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;
@@ -405,7 +401,6 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	struct dmm32at_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int range;
 	unsigned char chanlo, chanhi;
@@ -437,13 +432,6 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* reset the interrupt just in case */
 	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);
 
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ai_scans_left = cmd->stop_arg;
-	else {			/* TRIG_NONE */
-		devpriv->ai_scans_left = 0xffffffff; /* indicates TRIG_NONE to
-						      * isr */
-	}
-
 	/*
 	 * wait for circuit to settle
 	 * we don't have the 'insn' here but it's not needed
@@ -452,7 +440,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (ret)
 		return ret;
 
-	if (devpriv->ai_scans_left > 1) {
+	if (cmd->stop_src == TRIG_NONE || cmd->stop_arg > 1) {
 		/* start the clock and enable the interrupts */
 		dmm32at_setaitimer(dev, cmd->scan_begin_arg);
 	} else {
@@ -476,7 +464,6 @@ static int dmm32at_ai_cancel(struct comedi_device *dev,
 static irqreturn_t dmm32at_isr(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct dmm32at_private *devpriv = dev->private;
 	unsigned char intstat;
 	unsigned int samp;
 	unsigned short msb, lsb;
@@ -503,14 +490,10 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 			comedi_buf_write_samples(s, &samp, 1);
 		}
 
-		if (devpriv->ai_scans_left != 0xffffffff) {	/* TRIG_COUNT */
-			devpriv->ai_scans_left--;
-			if (devpriv->ai_scans_left == 0) {
-				/* set the buffer to be flushed with an EOF */
-				s->async->events |= COMEDI_CB_EOA;
-			}
+		if (cmd->stop_src == TRIG_COUNT &&
+		    s->async->scans_done >= cmd->stop_arg)
+			s->async->events |= COMEDI_CB_EOA;
 
-		}
 		comedi_handle_events(dev, s);
 	}
 

commit 4d9b0714a29a4d56bb7345a58737438c89fa250b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 11 16:55:17 2014 -0700

    staging: comedi: dmm32at: make AI (*cancel) actually cancel async command
    
    Currently the AI (*cancel) changes a private data member to cause the
    interrupt handler to cancel the async command after the next interrupt.
    
    Move the code that disables the interrupt and terminates the acquisition
    from the interrunt handler into dmm32at_ai_cancel() so that the async
    command is terminated instantly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index fc2c0db73999..d73ba5b2f749 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -468,9 +468,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int dmm32at_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct dmm32at_private *devpriv = dev->private;
-
-	devpriv->ai_scans_left = 1;
+	/* disable further interrupts and clocks */
+	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
 	return 0;
 }
 
@@ -507,8 +506,6 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 		if (devpriv->ai_scans_left != 0xffffffff) {	/* TRIG_COUNT */
 			devpriv->ai_scans_left--;
 			if (devpriv->ai_scans_left == 0) {
-				/* disable further interrupts and clocks */
-				outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
 				/* set the buffer to be flushed with an EOF */
 				s->async->events |= COMEDI_CB_EOA;
 			}

commit 1700529b24cc99ad5c77ab765da2f290fcd0c92c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:54 2014 -0700

    staging: comedi: dmm32at: use comedi_buf_write_samples()
    
    For aesthetics, use comedi_buf_write_samples() to add the sample to the
    async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 7e69d317b7ef..fc2c0db73999 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -501,7 +501,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 
 			/* invert sign bit to make range unsigned */
 			samp = ((msb ^ 0x0080) << 8) + lsb;
-			comedi_buf_put(s, samp);
+			comedi_buf_write_samples(s, &samp, 1);
 		}
 
 		if (devpriv->ai_scans_left != 0xffffffff) {	/* TRIG_COUNT */

commit 285d1ff1629b1a83ee7c09b23b74fd2a92854d80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:24 2014 -0700

    staging: comedi: dmm32at: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 7215e09305cf..7e69d317b7ef 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -514,8 +514,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 			}
 
 		}
-		/* flush the buffer */
-		comedi_event(dev, s);
+		comedi_handle_events(dev, s);
 	}
 
 	/* reset the interrupt */

commit b328ad30759bf3134175242cf7ea9a81b1ef02a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:43 2014 -0700

    staging: comedi: dmm32at: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index cfe32348ff61..7215e09305cf 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -151,15 +151,10 @@ static const struct comedi_lrange dmm32at_aoranges = {
 };
 
 struct dmm32at_private {
-
 	int data;
 	int ai_inuse;
 	unsigned int ai_scans_left;
-
-	/* Used for AO readback */
-	unsigned int ao_readback[4];
 	unsigned char dio_config;
-
 };
 
 static int dmm32at_ai_status(struct comedi_device *dev,
@@ -546,14 +541,12 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct dmm32at_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val;
-	int ret;
 	int i;
 
 	for (i = 0; i < insn->n; i++) {
-		val = data[i];
+		unsigned int val = data[i];
+		int ret;
 
 		/* write LSB then MSB + chan to load DAC */
 		outb(val & 0xff, dev->iobase + DMM32AT_DACLSB_REG);
@@ -568,26 +561,12 @@ static int dmm32at_ao_insn_write(struct comedi_device *dev,
 		/* dummy read to update DAC */
 		inb(dev->iobase + DMM32AT_DACMSB_REG);
 
-		devpriv->ao_readback[chan] = val;
+		s->readback[chan] = val;
 	}
 
 	return insn->n;
 }
 
-static int dmm32at_ao_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
-{
-	struct dmm32at_private *devpriv = dev->private;
-	int i;
-	int chan = CR_CHAN(insn->chanspec);
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
-
-	return i;
-}
-
 static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn,
@@ -761,7 +740,11 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->maxdata = 0x0fff;
 	s->range_table = &dmm32at_aoranges;
 	s->insn_write = dmm32at_ao_insn_write;
-	s->insn_read = dmm32at_ao_rinsn;
+	s->insn_read = comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
 
 	s = &dev->subdevices[2];
 	/* digital i/o subdevice */

commit bf8e3e3ad467f9e63069d19e56baf40644b7ec03
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:42 2014 -0700

    staging: comedi: dmm32at: cleanup dmm32at_ao_winsn()
    
    For aesthetics, rename the function and tidy it up a bit. Also rename the
    registers used by this function and add a macro to set the 'chan' bits in
    the MSB data register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index e9cd2517ad81..cfe32348ff61 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -47,9 +47,10 @@ Configuration Options:
 #define DMM32AT_AILOW 0x02
 #define DMM32AT_AIHIGH 0x03
 
-#define DMM32AT_DACLSB 0x04
 #define DMM32AT_DACSTAT 0x04
-#define DMM32AT_DACMSB 0x05
+#define DMM32AT_DACLSB_REG	0x04
+#define DMM32AT_DACMSB_REG	0x05
+#define DMM32AT_DACMSB_CHAN(x)	((x) << 6)
 
 #define DMM32AT_FIFOCNTRL 0x07
 #define DMM32AT_FIFOSTAT 0x07
@@ -540,42 +541,37 @@ static int dmm32at_ao_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int dmm32at_ao_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ao_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct dmm32at_private *devpriv = dev->private;
-	int i;
-	int chan = CR_CHAN(insn->chanspec);
-	unsigned char hi, lo, status;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val;
 	int ret;
+	int i;
 
-	/* Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined. */
 	for (i = 0; i < insn->n; i++) {
+		val = data[i];
 
-		devpriv->ao_readback[chan] = data[i];
-
-		/* get the low byte */
-		lo = data[i] & 0x00ff;
-		/* high byte also contains channel number */
-		hi = (data[i] >> 8) + chan * (1 << 6);
-		/* write the low and high values to the board */
-		outb(lo, dev->iobase + DMM32AT_DACLSB);
-		outb(hi, dev->iobase + DMM32AT_DACMSB);
+		/* write LSB then MSB + chan to load DAC */
+		outb(val & 0xff, dev->iobase + DMM32AT_DACLSB_REG);
+		outb((val >> 8) | DMM32AT_DACMSB_CHAN(chan),
+		     dev->iobase + DMM32AT_DACMSB_REG);
 
 		/* wait for circuit to settle */
 		ret = comedi_timeout(dev, s, insn, dmm32at_ao_eoc, 0);
 		if (ret)
 			return ret;
 
-		/* dummy read to update trigger the output */
-		status = inb(dev->iobase + DMM32AT_DACMSB);
+		/* dummy read to update DAC */
+		inb(dev->iobase + DMM32AT_DACMSB_REG);
 
+		devpriv->ao_readback[chan] = val;
 	}
 
-	/* return the number of samples read/written */
-	return i;
+	return insn->n;
 }
 
 static int dmm32at_ao_rinsn(struct comedi_device *dev,
@@ -764,7 +760,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->n_chan = 4;
 	s->maxdata = 0x0fff;
 	s->range_table = &dmm32at_aoranges;
-	s->insn_write = dmm32at_ao_winsn;
+	s->insn_write = dmm32at_ao_insn_write;
 	s->insn_read = dmm32at_ao_rinsn;
 
 	s = &dev->subdevices[2];

commit 88634cd820850241aafb9c1ecc822c5a4c361c0c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:23:36 2014 -0700

    staging: comedi: drivers: remove unnecessary *_{IO, MEM}SIZE defines
    
    Some of the legacy comedi drivers have a *_{IO,MEM}SIZE define that is
    only passed to comedi_request_region() to specify the size of the region.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 35a8f84867aa..e9cd2517ad81 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -40,9 +40,6 @@ Configuration Options:
 #include "comedi_fc.h"
 
 /* Board register addresses */
-
-#define DMM32AT_MEMSIZE 0x10
-
 #define DMM32AT_CONV 0x00
 #define DMM32AT_AILSB 0x00
 #define DMM32AT_AUXDOUT 0x01
@@ -684,7 +681,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
 
-	ret = comedi_request_region(dev, it->options[0], DMM32AT_MEMSIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
 

commit a207c12f62e8b53e1e1600ca384b13a39a9feed2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:16 2014 -0700

    staging: comedi: drivers: cleanup cmd->flags use
    
    Most of the comedi drivers that support async commands have some sort
    of timer to control the acquisition timing. For these drivers, Step 4
    of the (*do_cmdtest) operations calls a ns_to_timer() function that
    converts the desired ns time of the command into a value used to set
    the timer. These ns_to_timer() functions also typically pass the
    cmd->flags in order to determine the desired rounding mode.
    
    Some of the drivers mask the cmd->flags with TRIG_ROUND_MASK when
    calling the ns_to_timer() functions. Move all the masking into the
    ns_to_timer() functions and just pass the cmd->flags directly.
    
    The cmd->flags member is an unsigned int, change the parameter type
    in the the ns_to_timer() functions to match.
    
    For aesthetics, rename the parameter in all the ns_to_timer()
    functions to 'flags'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 181c34462a4d..35a8f84867aa 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -237,7 +237,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int dmm32at_ns_to_timer(unsigned int *ns, int round)
+static int dmm32at_ns_to_timer(unsigned int *ns, unsigned int flags)
 {
 	/* trivial timer */
 	return *ns;
@@ -352,12 +352,12 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		dmm32at_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		dmm32at_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		dmm32at_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		dmm32at_ns_to_timer(&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {

commit 2d60dd4a75bf1ddd60629c4d3fc5279205e701e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:41 2014 -0700

    staging: comedi: dmm32at: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ad7a5d53b97b..181c34462a4d 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -491,7 +491,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 	int i;
 
 	if (!dev->attached) {
-		comedi_error(dev, "spurious interrupt");
+		dev_err(dev->class_dev, "spurious interrupt\n");
 		return IRQ_HANDLED;
 	}
 

commit d579392a3fab9acd63123f4167abd822600777a4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:48 2014 -0700

    staging: comedi: dmm32at: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    Use cfc_check_trigger_arg_min() to vaidate the scan_begin_arg when the
    scan_begin_src and convert_src are both TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 931150150e10..ad7a5d53b97b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -275,7 +275,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -351,24 +351,19 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
-		dmm32at_ns_to_timer(&cmd->scan_begin_arg,
-				    cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+		arg = cmd->scan_begin_arg;
+		dmm32at_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
-		dmm32at_ns_to_timer(&cmd->convert_arg,
-				    cmd->flags & TRIG_ROUND_MASK);
-		if (tmp != cmd->convert_arg)
-			err++;
-		if (cmd->scan_begin_src == TRIG_TIMER &&
-		    cmd->scan_begin_arg <
-		    cmd->convert_arg * cmd->scan_end_arg) {
-			cmd->scan_begin_arg =
-			    cmd->convert_arg * cmd->scan_end_arg;
-			err++;
+		arg = cmd->convert_arg;
+		dmm32at_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			arg = cmd->convert_arg * cmd->scan_end_arg;
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 arg);
 		}
 	}
 

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 68260e6658e4..931150150e10 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -473,12 +473,6 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(0xff, dev->iobase + DMM32AT_CONV);
 	}
 
-/*	for(i=0;i<cmd->chanlist_len;i++) */
-/*		comedi_buf_put(s->async,i*100); */
-
-/*	s->async->events |= COMEDI_CB_EOA; */
-/*	comedi_event(dev, s); */
-
 	return 0;
 
 }
@@ -519,7 +513,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 
 			/* invert sign bit to make range unsigned */
 			samp = ((msb ^ 0x0080) << 8) + lsb;
-			comedi_buf_put(s->async, samp);
+			comedi_buf_put(s, samp);
 		}
 
 		if (devpriv->ai_scans_left != 0xffffffff) {	/* TRIG_COUNT */

commit 869149961951afccb103d43217282756b17f2f96
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:16 2014 -0700

    staging: comedi: dmm32at: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input async command
    support. Tidy up the factored out code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index c8a36eb5f015..68260e6658e4 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -243,13 +243,39 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 	return *ns;
 }
 
+static int dmm32at_ai_check_chanlist(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan != (chan0 + i) % s->n_chan) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must be consecutive channels, counting upwards\n");
+			return -EINVAL;
+		}
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must all have the same gain\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
-	int start_chan, gain, i;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -349,26 +375,9 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/* step 5 check the channel list, the channel list for this
-	   board must be consecutive and gains must be the same */
-
-	if (cmd->chanlist) {
-		gain = CR_RANGE(cmd->chanlist[0]);
-		start_chan = CR_CHAN(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    (start_chan + i) % s->n_chan) {
-				comedi_error(dev,
-					     "entries in chanlist must be consecutive channels, counting upwards\n");
-				err++;
-			}
-			if (CR_RANGE(cmd->chanlist[i]) != gain) {
-				comedi_error(dev,
-					     "entries in chanlist must all have the same gain\n");
-				err++;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= dmm32at_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit f7b3d79a622c97483c8d0e6e4bbd5207929259d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:44 2014 -0700

    staging: comedi: dmm32at: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input settle and end-of-
    conversion. These tests use different registers but the same bit so
    the register is passed as the 'context'. The same test is used in
    dmm32at_ai_cmd() but the 'insn' is not available. This is ok since
    the test function, and comedi_timeout() don't use it.
    
    Use comedi_timout() to wait for the analog output end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 78a19629ff56..c8a36eb5f015 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -164,16 +164,29 @@ struct dmm32at_private {
 
 };
 
+static int dmm32at_ai_status(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned long context)
+{
+	unsigned char status;
+
+	status = inb(dev->iobase + context);
+	if ((status & DMM32AT_STATUS) == 0)
+		return 0;
+	return -EBUSY;
+}
+
 static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	int n, i;
+	int n;
 	unsigned int d;
-	unsigned char status;
 	unsigned short msb, lsb;
 	unsigned char chan;
 	int range;
+	int ret;
 
 	/* get the channel and range number */
 
@@ -190,26 +203,20 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
 
 	/* wait for circuit to settle */
-	for (i = 0; i < 40000; i++) {
-		status = inb(dev->iobase + DMM32AT_AIRBACK);
-		if ((status & DMM32AT_STATUS) == 0)
-			break;
-	}
-	if (i == 40000)
-		return -ETIMEDOUT;
+	ret = comedi_timeout(dev, s, insn, dmm32at_ai_status, DMM32AT_AIRBACK);
+	if (ret)
+		return ret;
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
 		outb(0xff, dev->iobase + DMM32AT_CONV);
+
 		/* wait for conversion to end */
-		for (i = 0; i < 40000; i++) {
-			status = inb(dev->iobase + DMM32AT_AISTAT);
-			if ((status & DMM32AT_STATUS) == 0)
-				break;
-		}
-		if (i == 40000)
-			return -ETIMEDOUT;
+		ret = comedi_timeout(dev, s, insn, dmm32at_ai_status,
+				     DMM32AT_AISTAT);
+		if (ret)
+			return ret;
 
 		/* read data */
 		lsb = inb(dev->iobase + DMM32AT_AILSB);
@@ -403,8 +410,9 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dmm32at_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int i, range;
-	unsigned char chanlo, chanhi, status;
+	int range;
+	unsigned char chanlo, chanhi;
+	int ret;
 
 	if (!cmd->chanlist)
 		return -EINVAL;
@@ -439,14 +447,13 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 						      * isr */
 	}
 
-	/* wait for circuit to settle */
-	for (i = 0; i < 40000; i++) {
-		status = inb(dev->iobase + DMM32AT_AIRBACK);
-		if ((status & DMM32AT_STATUS) == 0)
-			break;
-	}
-	if (i == 40000)
-		return -ETIMEDOUT;
+	/*
+	 * wait for circuit to settle
+	 * we don't have the 'insn' here but it's not needed
+	 */
+	ret = comedi_timeout(dev, s, NULL, dmm32at_ai_status, DMM32AT_AIRBACK);
+	if (ret)
+		return ret;
 
 	if (devpriv->ai_scans_left > 1) {
 		/* start the clock and enable the interrupts */
@@ -525,6 +532,19 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+static int dmm32at_ao_eoc(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_insn *insn,
+			  unsigned long context)
+{
+	unsigned char status;
+
+	status = inb(dev->iobase + DMM32AT_DACSTAT);
+	if ((status & DMM32AT_DACBUSY) == 0)
+		return 0;
+	return -EBUSY;
+}
+
 static int dmm32at_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -533,6 +553,7 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned char hi, lo, status;
+	int ret;
 
 	/* Writing a list of values to an AO channel is probably not
 	 * very useful, but that's how the interface is defined. */
@@ -549,13 +570,9 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 		outb(hi, dev->iobase + DMM32AT_DACMSB);
 
 		/* wait for circuit to settle */
-		for (i = 0; i < 40000; i++) {
-			status = inb(dev->iobase + DMM32AT_DACSTAT);
-			if ((status & DMM32AT_DACBUSY) == 0)
-				break;
-		}
-		if (i == 40000)
-			return -ETIMEDOUT;
+		ret = comedi_timeout(dev, s, insn, dmm32at_ao_eoc, 0);
+		if (ret)
+			return ret;
 
 		/* dummy read to update trigger the output */
 		status = inb(dev->iobase + DMM32AT_DACMSB);

commit 45ddfc5a51f0ea179bcb82a4170c33ceed46c4b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:14 2013 -0700

    staging: comedi: dmm32at: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 174735d37b51..78a19629ff56 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -124,13 +124,12 @@ Configuration Options:
 
 /* board AI ranges in comedi structure */
 static const struct comedi_lrange dmm32at_airanges = {
-	4,
-	{
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 }
+	4, {
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		BIP_RANGE(10),
+		BIP_RANGE(5)
+	}
 };
 
 /* register values for above ranges */
@@ -145,13 +144,12 @@ static const unsigned char dmm32at_rangebits[] = {
  * board. The application should only use the range set by the jumper
  */
 static const struct comedi_lrange dmm32at_aoranges = {
-	4,
-	{
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 }
+	4, {
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		BIP_RANGE(10),
+		BIP_RANGE(5)
+	}
 };
 
 struct dmm32at_private {

commit 45d351031e1326a4d0a988c776f23673f7e1ffd2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:47 2013 -0700

    staging: comedi: dmm32at: convert a printk(KERN_ERR to a dev->err()
    
    Convert this printk message to a dev_err() message.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1831f3288ca8..174735d37b51 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -710,7 +710,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
 	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
-		printk(KERN_ERR "dmmat32: board detection failed\n");
+		dev_err(dev->class_dev, "board detection failed\n");
 		return -EIO;
 	}
 

commit 0c2e55324199d89aaea816ce7a76571c3f88d158
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:46 2013 -0700

    staging: comedi: dmm32at: tidy up the irq support in dmm32at_attach()
    
    An irq is only needed by this driver in order to support async commands.
    Since it is optional, modify the attach so that if the request_irq() fails
    the attach does not fail.
    
    Remove the printk noise about the irq.
    
    Only hookup the async command support if the request_irq() was successful.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 6fb8ce1d110c..1831f3288ca8 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -670,9 +670,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
-	unsigned int irq;
-
-	irq = it->options[1];
 
 	ret = comedi_request_region(dev, it->options[0], DMM32AT_MEMSIZE);
 	if (ret)
@@ -717,14 +714,11 @@ static int dmm32at_attach(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	/* board is there, register interrupt */
-	if (irq) {
-		ret = request_irq(irq, dmm32at_isr, 0, dev->board_name, dev);
-		if (ret < 0) {
-			printk(KERN_ERR "dmm32at: irq conflict\n");
-			return ret;
-		}
-		dev->irq = irq;
+	if (it->options[1]) {
+		ret = request_irq(it->options[1], dmm32at_isr, 0,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = it->options[1];
 	}
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -736,20 +730,22 @@ static int dmm32at_attach(struct comedi_device *dev,
 		return ret;
 
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	/* we support single-ended (ground) and differential */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;
 	s->n_chan = 32;
 	s->maxdata = 0xffff;
 	s->range_table = &dmm32at_airanges;
-	s->len_chanlist = 32;	/* This is the maximum chanlist length that
-				   the board can handle */
 	s->insn_read = dmm32at_ai_rinsn;
-	s->do_cmd = dmm32at_ai_cmd;
-	s->do_cmdtest = dmm32at_ai_cmdtest;
-	s->cancel = dmm32at_ai_cancel;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->len_chanlist = 32;
+		s->do_cmd = dmm32at_ai_cmd;
+		s->do_cmdtest = dmm32at_ai_cmdtest;
+		s->cancel = dmm32at_ai_cancel;
+	}
 
 	s = &dev->subdevices[1];
 	/* analog output subdevice */

commit 49220f916d9a90e468b60d9dd8fde789e239c632
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:45 2013 -0700

    staging: comedi: dmm32at: remove commented out printk debug
    
    These printk messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index f057d7995bad..6fb8ce1d110c 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -182,8 +182,6 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	chan = CR_CHAN(insn->chanspec) & (s->n_chan - 1);
 	range = CR_RANGE(insn->chanspec);
 
-	/* printk("channel=0x%02x, range=%d\n",chan,range); */
-
 	/* zero scan and fifo control and reset fifo */
 	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
 
@@ -461,8 +459,6 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		outb(0xff, dev->iobase + DMM32AT_CONV);
 	}
 
-/*	printk("dmmat32 in command\n"); */
-
 /*	for(i=0;i<cmd->chanlist_len;i++) */
 /*		comedi_buf_put(s->async,i*100); */
 
@@ -550,7 +546,6 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 		lo = data[i] & 0x00ff;
 		/* high byte also contains channel number */
 		hi = (data[i] >> 8) + chan * (1 << 6);
-		/* printk("writing 0x%02x  0x%02x\n",hi,lo); */
 		/* write the low and high values to the board */
 		outb(lo, dev->iobase + DMM32AT_DACLSB);
 		outb(hi, dev->iobase + DMM32AT_DACMSB);

commit 65e2618fd3bbe9c3776048212dc15ddc7fe61451
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:44 2013 -0700

    staging: comedi: dmm32at: remove unnecessary printk noise
    
    A timeout will return -ETIMEDOUT. The printks are just added noise.
    Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index bd192de319d3..f057d7995bad 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -199,10 +199,8 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		if ((status & DMM32AT_STATUS) == 0)
 			break;
 	}
-	if (i == 40000) {
-		printk(KERN_WARNING "dmm32at: timeout\n");
+	if (i == 40000)
 		return -ETIMEDOUT;
-	}
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
@@ -214,10 +212,8 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			if ((status & DMM32AT_STATUS) == 0)
 				break;
 		}
-		if (i == 40000) {
-			printk(KERN_WARNING "dmm32at: timeout\n");
+		if (i == 40000)
 			return -ETIMEDOUT;
-		}
 
 		/* read data */
 		lsb = inb(dev->iobase + DMM32AT_AILSB);
@@ -453,10 +449,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		if ((status & DMM32AT_STATUS) == 0)
 			break;
 	}
-	if (i == 40000) {
-		printk(KERN_WARNING "dmm32at: timeout\n");
+	if (i == 40000)
 		return -ETIMEDOUT;
-	}
 
 	if (devpriv->ai_scans_left > 1) {
 		/* start the clock and enable the interrupts */
@@ -567,10 +561,9 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 			if ((status & DMM32AT_DACBUSY) == 0)
 				break;
 		}
-		if (i == 40000) {
-			printk(KERN_WARNING "dmm32at: timeout\n");
+		if (i == 40000)
 			return -ETIMEDOUT;
-		}
+
 		/* dummy read to update trigger the output */
 		status = inb(dev->iobase + DMM32AT_DACMSB);
 

commit 9b35db028f7f5c375ab9cef095ea48250d4c15ff
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:34 2013 -0700

    staging: comedi: dmm32at: remove final attach noise and fix return value
    
    The "success" message after an attach is just added noise. Remove it.
    
    The normal return value for "success" is 0.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index cac83585ef86..bd192de319d3 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -793,11 +793,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->insn_bits = dmm32at_dio_insn_bits;
 	s->insn_config = dmm32at_dio_insn_config;
 
-	/* success */
-	printk(KERN_INFO "comedi%d: dmm32at: attached\n", dev->minor);
-
-	return 1;
-
+	return 0;
 }
 
 static struct comedi_driver dmm32at_driver = {

commit 7f95741d6f627a5af0e97b4924de9c85877ac458
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 10:21:30 2013 -0700

    staging: comedi: dmm32at: remove some unnecessary printk(KERN_DEBUG ...
    
    These debug messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index b04a5633f754..cac83585ef86 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -723,12 +723,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
 	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
-	printk(KERN_DEBUG "dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
-	       ailo, aihi, fifostat);
-	printk(KERN_DEBUG
-	       "dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
-	       aistat, intstat, airback);
-
 	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
 	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
 		printk(KERN_ERR "dmmat32: board detection failed\n");

commit b3ff824a81e8978deb56f6d163479c1a0a606037
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:06:17 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for complex cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for more complex cases where the hardware is only
    updated based on the 'mask' of the channels that are modified.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 118a4fd129f9..b04a5633f754 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -596,52 +596,40 @@ static int dmm32at_ao_rinsn(struct comedi_device *dev,
 
 static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct dmm32at_private *devpriv = dev->private;
-	unsigned char diobits;
-
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= data[0] & data[1];
-		/* Write out the new digital output lines */
-		/* outw(s->state,dev->iobase + DMM32AT_DIO); */
+	unsigned int mask;
+	unsigned int val;
+
+	mask = comedi_dio_update_state(s, data);
+	if (mask) {
+		/* get access to the DIO regs */
+		outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
+
+		/* if either part of dio is set for output */
+		if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
+		    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
+			val = (s->state & 0x00ff0000) >> 16;
+			outb(val, dev->iobase + DMM32AT_DIOC);
+		}
+		if ((devpriv->dio_config & DMM32AT_DIRB) == 0) {
+			val = (s->state & 0x0000ff00) >> 8;
+			outb(val, dev->iobase + DMM32AT_DIOB);
+		}
+		if ((devpriv->dio_config & DMM32AT_DIRA) == 0) {
+			val = (s->state & 0x000000ff);
+			outb(val, dev->iobase + DMM32AT_DIOA);
+		}
 	}
 
-	/* get access to the DIO regs */
-	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-
-	/* if either part of dio is set for output */
-	if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
-	    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
-		diobits = (s->state & 0x00ff0000) >> 16;
-		outb(diobits, dev->iobase + DMM32AT_DIOC);
-	}
-	if ((devpriv->dio_config & DMM32AT_DIRB) == 0) {
-		diobits = (s->state & 0x0000ff00) >> 8;
-		outb(diobits, dev->iobase + DMM32AT_DIOB);
-	}
-	if ((devpriv->dio_config & DMM32AT_DIRA) == 0) {
-		diobits = (s->state & 0x000000ff);
-		outb(diobits, dev->iobase + DMM32AT_DIOA);
-	}
+	val = inb(dev->iobase + DMM32AT_DIOA);
+	val |= inb(dev->iobase + DMM32AT_DIOB) << 8;
+	val |= inb(dev->iobase + DMM32AT_DIOC) << 16;
+	s->state = val;
 
-	/* now read the state back in */
-	s->state = inb(dev->iobase + DMM32AT_DIOC);
-	s->state <<= 8;
-	s->state |= inb(dev->iobase + DMM32AT_DIOB);
-	s->state <<= 8;
-	s->state |= inb(dev->iobase + DMM32AT_DIOA);
-	data[1] = s->state;
-
-	/* on return, data[1] contains the value of the digital
-	 * input and output lines. */
-	/* data[1]=inw(dev->iobase + DMM32AT_DIO); */
-	/* or we could just return the software copy of the output values if
-	 * it was a purely digital output subdevice */
-	/* data[1]=s->state; */
+	data[1] = val;
 
 	return insn->n;
 }

commit 49b71ebab2b40ffec19007e8b4dba6b8f8622f46
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 26 15:29:10 2013 -0700

    staging: comedi: dmm32at: fix dmm32at_dio_insn_config()
    
    This is the (*insn_config) function for a DIO subdevice. It should be
    using the data[0] value as the "instruction" to perform on the subdevice.
    
    Use the comedi_dio_insn_config() helper to properly handle instructions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 5237f47d39ae..118a4fd129f9 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -648,31 +648,34 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 
 static int dmm32at_dio_insn_config(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
+				   struct comedi_insn *insn,
+				   unsigned int *data)
 {
 	struct dmm32at_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int mask;
 	unsigned char chanbit;
-	int chan = CR_CHAN(insn->chanspec);
-
-	if (insn->n != 1)
-		return -EINVAL;
+	int ret;
 
-	if (chan < 8)
+	if (chan < 8) {
+		mask = 0x0000ff;
 		chanbit = DMM32AT_DIRA;
-	else if (chan < 16)
+	} else if (chan < 16) {
+		mask = 0x00ff00;
 		chanbit = DMM32AT_DIRB;
-	else if (chan < 20)
+	} else if (chan < 20) {
+		mask = 0x0f0000;
 		chanbit = DMM32AT_DIRCL;
-	else
+	} else {
+		mask = 0xf00000;
 		chanbit = DMM32AT_DIRCH;
+	}
 
-	/* The input or output configuration of each digital line is
-	 * configured by a special insn_config instruction.  chanspec
-	 * contains the channel to be changed, and data[0] contains the
-	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
+	if (ret)
+		return ret;
 
-	/* if output clear the bit, otherwise set it */
-	if (data[0] == COMEDI_OUTPUT)
+	if (data[0] == INSN_CONFIG_DIO_OUTPUT)
 		devpriv->dio_config &= ~chanbit;
 	else
 		devpriv->dio_config |= chanbit;
@@ -681,7 +684,7 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 	/* set the DIO's to the new configuration setting */
 	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
 
-	return 1;
+	return insn->n;
 }
 
 static int dmm32at_attach(struct comedi_device *dev,

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1d80d7457529..5237f47d39ae 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -36,7 +36,6 @@ Configuration Options:
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include "../comedidev.h"
-#include <linux/ioport.h>
 
 #include "comedi_fc.h"
 

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index a8b2c64cafd9..1d80d7457529 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -32,6 +32,8 @@ Configuration Options:
   comedi_config /dev/comedi0 dmm32at baseaddr,irq
 */
 
+#include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/ioport.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index e29847d73b43..a8b2c64cafd9 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -753,10 +753,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 		dev->irq = irq;
 	}
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 6c85dd2d549b..e29847d73b43 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -14,11 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 /*
 Driver: dmm32at

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 507ca8e4be60..6c85dd2d549b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -820,18 +820,11 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 }
 
-static void dmm32at_detach(struct comedi_device *dev)
-{
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	comedi_legacy_detach(dev);
-}
-
 static struct comedi_driver dmm32at_driver = {
 	.driver_name	= "dmm32at",
 	.module		= THIS_MODULE,
 	.attach		= dmm32at_attach,
-	.detach		= dmm32at_detach,
+	.detach		= comedi_legacy_detach,
 };
 module_comedi_driver(dmm32at_driver);
 

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 7621cdf27b3a..507ca8e4be60 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -824,8 +824,7 @@ static void dmm32at_detach(struct comedi_device *dev)
 {
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, DMM32AT_MEMSIZE);
+	comedi_legacy_detach(dev);
 }
 
 static struct comedi_driver dmm32at_driver = {

commit 2dd11a812aa908b3a8f2f88cce9f0c24c34c3cab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:20:27 2013 -0700

    staging: comedi: dmm32at: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ca07e54de2ee..7621cdf27b3a 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -695,23 +695,13 @@ static int dmm32at_attach(struct comedi_device *dev,
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
-	unsigned long iobase;
 	unsigned int irq;
 
-	iobase = it->options[0];
 	irq = it->options[1];
 
-	printk(KERN_INFO "comedi%d: dmm32at: attaching\n", dev->minor);
-	printk(KERN_DEBUG "dmm32at: probing at address 0x%04lx, irq %u\n",
-	       iobase, irq);
-
-	/* register address space */
-	if (!request_region(iobase, DMM32AT_MEMSIZE, dev->board_name)) {
-		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
-		       dev->minor);
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], DMM32AT_MEMSIZE);
+	if (ret)
+		return ret;
 
 	/* the following just makes sure the board is there and gets
 	   it to a known state */

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 9e2124179a0c..ca07e54de2ee 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -698,8 +698,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 	unsigned long iobase;
 	unsigned int irq;
 
-	dev->board_name = dev->driver->driver_name;
-
 	iobase = it->options[0];
 	irq = it->options[1];
 

commit e43ed5fa1435e3ae8a2a5727ea30581640f9e18d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:54:56 2012 -0700

    staging: comedi: dmm32at: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of dmm32at_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index a526c6770bbc..9e2124179a0c 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -280,33 +280,25 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
 #define MAX_SCAN_SPEED	1000000	/* in nanoseconds */
 #define MIN_SCAN_SPEED	1000000000	/* in nanoseconds */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < MAX_SCAN_SPEED) {
-			cmd->scan_begin_arg = MAX_SCAN_SPEED;
-			err++;
-		}
-		if (cmd->scan_begin_arg > MIN_SCAN_SPEED) {
-			cmd->scan_begin_arg = MIN_SCAN_SPEED;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 MAX_SCAN_SPEED);
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+						 MIN_SCAN_SPEED);
 	} else {
 		/* external trigger */
 		/* should be level/edge, hi/lo specification here */
 		/* should specify multiple external triggers */
-		if (cmd->scan_begin_arg > 9) {
-			cmd->scan_begin_arg = 9;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 9);
 	}
+
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (cmd->convert_arg >= 17500)
 			cmd->convert_arg = 20000;
@@ -316,35 +308,20 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 			cmd->convert_arg = 10000;
 		else
 			cmd->convert_arg = 5000;
-
 	} else {
 		/* external trigger */
 		/* see above */
-		if (cmd->convert_arg > 9) {
-			cmd->convert_arg = 9;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_max(&cmd->convert_arg, 9);
 	}
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
 	if (cmd->stop_src == TRIG_COUNT) {
-		if (cmd->stop_arg > 0xfffffff0) {
-			cmd->stop_arg = 0xfffffff0;
-			err++;
-		}
-		if (cmd->stop_arg == 0) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_max(&cmd->stop_arg, 0xfffffff0);
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index c8b7a031c48f..a526c6770bbc 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -793,10 +793,10 @@ static int dmm32at_attach(struct comedi_device *dev,
 		dev->irq = irq;
 	}
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 824b692db5f8..c8b7a031c48f 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -793,8 +793,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 		dev->irq = irq;
 	}
 
-	if (alloc_private(dev, sizeof(*devpriv)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
 	devpriv = dev->private;
 
 	ret = comedi_alloc_subdevices(dev, 3);

commit 4e9cd21340a11240ca4ff8a437e6442bc8fc90eb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 8 10:45:47 2012 -0700

    staging: comedi: dmm32at: remove boardinfo
    
    This driver only supports a single "boardtype". Remove the unneeded
    boardinfo struct and its use in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 4d5c33c4750f..824b692db5f8 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -158,10 +158,6 @@ static const struct comedi_lrange dmm32at_aoranges = {
 	 }
 };
 
-struct dmm32at_board {
-	const char *name;
-};
-
 struct dmm32at_private {
 
 	int data;
@@ -718,7 +714,6 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
-	const struct dmm32at_board *board = comedi_board(dev);
 	struct dmm32at_private *devpriv;
 	int ret;
 	struct comedi_subdevice *s;
@@ -726,6 +721,8 @@ static int dmm32at_attach(struct comedi_device *dev,
 	unsigned long iobase;
 	unsigned int irq;
 
+	dev->board_name = dev->driver->driver_name;
+
 	iobase = it->options[0];
 	irq = it->options[1];
 
@@ -734,7 +731,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	       iobase, irq);
 
 	/* register address space */
-	if (!request_region(iobase, DMM32AT_MEMSIZE, board->name)) {
+	if (!request_region(iobase, DMM32AT_MEMSIZE, dev->board_name)) {
 		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
 		       dev->minor);
 		return -EIO;
@@ -788,7 +785,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	/* board is there, register interrupt */
 	if (irq) {
-		ret = request_irq(irq, dmm32at_isr, 0, board->name, dev);
+		ret = request_irq(irq, dmm32at_isr, 0, dev->board_name, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "dmm32at: irq conflict\n");
 			return ret;
@@ -796,8 +793,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 		dev->irq = irq;
 	}
 
-	dev->board_name = board->name;
-
 	if (alloc_private(dev, sizeof(*devpriv)) < 0)
 		return -ENOMEM;
 	devpriv = dev->private;
@@ -867,20 +862,11 @@ static void dmm32at_detach(struct comedi_device *dev)
 		release_region(dev->iobase, DMM32AT_MEMSIZE);
 }
 
-static const struct dmm32at_board dmm32at_boards[] = {
-	{
-		.name		= "dmm32at",
-	},
-};
-
 static struct comedi_driver dmm32at_driver = {
 	.driver_name	= "dmm32at",
 	.module		= THIS_MODULE,
 	.attach		= dmm32at_attach,
 	.detach		= dmm32at_detach,
-	.board_name	= &dmm32at_boards[0].name,
-	.offset		= sizeof(struct dmm32at_board),
-	.num_names	= ARRAY_SIZE(dmm32at_boards),
 };
 module_comedi_driver(dmm32at_driver);
 

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 0703ca5d8cb7..4d5c33c4750f 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -41,6 +41,8 @@ Configuration Options:
 #include "../comedidev.h"
 #include <linux/ioport.h>
 
+#include "comedi_fc.h"
+
 /* Board register addresses */
 
 #define DMM32AT_MEMSIZE 0x10
@@ -258,47 +260,26 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	int tmp;
 	int start_chan, gain, i;
 
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER /*| TRIG_EXT */ ;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER /*| TRIG_EXT */ ;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER /*| TRIG_EXT */);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER /*| TRIG_EXT */);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually
-	 * compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 2930d0ba656d035d01a2cac37b6fe1250df16c28
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:38:49 2012 -0700

    staging: comedi: dmm32at: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 7107f590b1fe..0703ca5d8cb7 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -825,7 +825,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
@@ -841,7 +841,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->do_cmdtest = dmm32at_ai_cmdtest;
 	s->cancel = dmm32at_ai_cancel;
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE;
@@ -851,7 +851,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->insn_write = dmm32at_ao_winsn;
 	s->insn_read = dmm32at_ao_rinsn;
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/* digital i/o subdevice */
 
 	/* get access to the DIO regs */

commit f4ce61a0ca021d9226da9c3269899ae75725468a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:15:02 2012 -0700

    staging: comedi: dmm32at: remove skel driver cut-and-paste comments
    
    Remove the cut-and-paste comments from the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index f0221e9b3623..7107f590b1fe 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -160,10 +160,6 @@ struct dmm32at_board {
 	const char *name;
 };
 
-/* this structure is for data unique to this hardware driver.  If
- * several hardware drivers keep similar information in this structure,
- * feel free to suggest moving the variable to the struct comedi_device struct.
- */
 struct dmm32at_private {
 
 	int data;
@@ -176,11 +172,6 @@ struct dmm32at_private {
 
 };
 
-/*
- * "instructions" read/write data in "one-shot" or "software-triggered"
- * mode.
- */
-
 static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -253,20 +244,9 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-/* This function doesn't require a particular form, this is just
- * what happens to be used in some of the drivers.  It should
- * convert ns nanoseconds to a counter value suitable for programming
- * the device.  Also, it should adjust ns so that it cooresponds to
- * the actual time that the device will use. */
 static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 {
 	/* trivial timer */
-	/* if your timing is done through two cascaded timers, the
-	 * i8253_cascade_ns_to_timer() function in 8253.h can be
-	 * very helpful.  There are also i8254_load() and i8254_mm_load()
-	 * which can be used to load values into the ubiquitous 8254 counters
-	 */
-
 	return *ns;
 }
 
@@ -278,15 +258,6 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	int tmp;
 	int start_chan, gain, i;
 
-	/* printk("dmmat32 in command test\n"); */
-
-	/* cmdtest tests a particular command to see if it is valid.
-	 * Using the cmdtest ioctl, a user can create a valid cmd
-	 * and then have it executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
-	 * the command passes. */
-
 	/* step 1: make sure trigger sources are trivially valid */
 
 	tmp = cmd->start_src;
@@ -659,8 +630,6 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 	return i;
 }
 
-/* AO subdevices should have a read insn as well as a write insn.
- * Usually this means copying a value stored in devpriv. */
 static int dmm32at_ao_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -675,11 +644,6 @@ static int dmm32at_ao_rinsn(struct comedi_device *dev,
 	return i;
 }
 
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The
- * comedi core can convert between insn_bits and insn_read/write */
 static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
@@ -853,10 +817,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	dev->board_name = board->name;
 
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
 	if (alloc_private(dev, sizeof(*devpriv)) < 0)
 		return -ENOMEM;
 	devpriv = dev->private;

commit 3eff01744009de100f03a1dc2e3d5f98da2235e5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:14:27 2012 -0700

    staging: comedi: dmm32at: remove devpriv macro
    
    The 'devpriv' macro relies on a local variable having a specific
    name and yields a pointer derived from that local variable. Replace
    the macro with a local variable where used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1d21e2291315..f0221e9b3623 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -176,12 +176,6 @@ struct dmm32at_private {
 
 };
 
-/*
- * most drivers define the following macro to make it easy to
- * access the private structure.
- */
-#define devpriv ((struct dmm32at_private *)dev->private)
-
 /*
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
@@ -494,6 +488,7 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct dmm32at_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, range;
 	unsigned char chanlo, chanhi, status;
@@ -566,17 +561,20 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int dmm32at_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct dmm32at_private *devpriv = dev->private;
+
 	devpriv->ai_scans_left = 1;
 	return 0;
 }
 
 static irqreturn_t dmm32at_isr(int irq, void *d)
 {
+	struct comedi_device *dev = d;
+	struct dmm32at_private *devpriv = dev->private;
 	unsigned char intstat;
 	unsigned int samp;
 	unsigned short msb, lsb;
 	int i;
-	struct comedi_device *dev = d;
 
 	if (!dev->attached) {
 		comedi_error(dev, "spurious interrupt");
@@ -622,6 +620,7 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct dmm32at_private *devpriv = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned char hi, lo, status;
@@ -666,6 +665,7 @@ static int dmm32at_ao_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct dmm32at_private *devpriv = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -684,6 +684,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct dmm32at_private *devpriv = dev->private;
 	unsigned char diobits;
 
 	/* The insn data is a mask in data[0] and the new data
@@ -735,6 +736,7 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data)
 {
+	struct dmm32at_private *devpriv = dev->private;
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -772,6 +774,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
 	const struct dmm32at_board *board = comedi_board(dev);
+	struct dmm32at_private *devpriv;
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
@@ -854,8 +857,9 @@ static int dmm32at_attach(struct comedi_device *dev,
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
+	if (alloc_private(dev, sizeof(*devpriv)) < 0)
 		return -ENOMEM;
+	devpriv = dev->private;
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit 2792182816be376391c2cfc142bfd32f3ab8c5cd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:13:53 2012 -0700

    staging: comedi: dmm32at: remove unneeded boardinfo variables
    
    Like most of the comedi drivers, this one appears to have been started
    based on the skel driver. Cut-and-paste from that driver has resulted
    in an unnecessarily complex boardinfo struct.
    
    Remove everything from the boardinfo struct, except the 'name', and
    just use the open coded values in the attach function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 2ae31e8aab40..1d21e2291315 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -156,21 +156,8 @@ static const struct comedi_lrange dmm32at_aoranges = {
 	 }
 };
 
-/*
- * Board descriptions for two imaginary boards.  Describing the
- * boards in this way is optional, and completely driver-dependent.
- * Some drivers use arrays such as this, other do not.
- */
 struct dmm32at_board {
 	const char *name;
-	int ai_chans;
-	int ai_bits;
-	const struct comedi_lrange *ai_ranges;
-	int ao_chans;
-	int ao_bits;
-	const struct comedi_lrange *ao_ranges;
-	int have_dio;
-	int dio_chans;
 };
 
 /* this structure is for data unique to this hardware driver.  If
@@ -880,9 +867,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	/* we support single-ended (ground) and differential */
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = board->ai_chans;
-	s->maxdata = (1 << board->ai_bits) - 1;
-	s->range_table = board->ai_ranges;
+	s->n_chan = 32;
+	s->maxdata = 0xffff;
+	s->range_table = &dmm32at_airanges;
 	s->len_chanlist = 32;	/* This is the maximum chanlist length that
 				   the board can handle */
 	s->insn_read = dmm32at_ai_rinsn;
@@ -894,35 +881,31 @@ static int dmm32at_attach(struct comedi_device *dev,
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = board->ao_chans;
-	s->maxdata = (1 << board->ao_bits) - 1;
-	s->range_table = board->ao_ranges;
+	s->n_chan = 4;
+	s->maxdata = 0x0fff;
+	s->range_table = &dmm32at_aoranges;
 	s->insn_write = dmm32at_ao_winsn;
 	s->insn_read = dmm32at_ao_rinsn;
 
 	s = dev->subdevices + 2;
 	/* digital i/o subdevice */
-	if (board->have_dio) {
-
-		/* get access to the DIO regs */
-		outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
-		/* set the DIO's to the defualt input setting */
-		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
-		outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
-
-		/* set up the subdevice */
-		s->type = COMEDI_SUBD_DIO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = board->dio_chans;
-		s->maxdata = 1;
-		s->state = 0;
-		s->range_table = &range_digital;
-		s->insn_bits = dmm32at_dio_insn_bits;
-		s->insn_config = dmm32at_dio_insn_config;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+
+	/* get access to the DIO regs */
+	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
+	/* set the DIO's to the defualt input setting */
+	devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
+		DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
+	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
+
+	/* set up the subdevice */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 24;
+	s->maxdata = 1;
+	s->state = 0;
+	s->range_table = &range_digital;
+	s->insn_bits = dmm32at_dio_insn_bits;
+	s->insn_config = dmm32at_dio_insn_config;
 
 	/* success */
 	printk(KERN_INFO "comedi%d: dmm32at: attached\n", dev->minor);
@@ -942,14 +925,6 @@ static void dmm32at_detach(struct comedi_device *dev)
 static const struct dmm32at_board dmm32at_boards[] = {
 	{
 		.name		= "dmm32at",
-		.ai_chans	= 32,
-		.ai_bits	= 16,
-		.ai_ranges	= &dmm32at_airanges,
-		.ao_chans	= 4,
-		.ao_bits	= 12,
-		.ao_ranges	= &dmm32at_aoranges,
-		.have_dio	= 1,
-		.dio_chans	= 24,
 	},
 };
 

commit 29f747c21e4318cc41efa82dac217da9ee8d5533
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:13:11 2012 -0700

    staging: comedi: dmm32at: remove dmm_outb macro
    
    The macro is just a wrapper for outb(). Just use the outb() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ee4e8ab3485b..2ae31e8aab40 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -78,8 +78,6 @@ Configuration Options:
 #define DMM32AT_DIOC 0x0e
 #define DMM32AT_DIOCONF 0x0f
 
-#define dmm_outb(cdev, reg, valu) outb(valu, (cdev->iobase)+reg)
-
 /* Board register values. */
 
 /* DMM32AT_DACSTAT 0x04 */
@@ -221,13 +219,13 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	/* printk("channel=0x%02x, range=%d\n",chan,range); */
 
 	/* zero scan and fifo control and reset fifo */
-	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
+	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
 
 	/* write the ai channel range regs */
-	dmm_outb(dev, DMM32AT_AILOW, chan);
-	dmm_outb(dev, DMM32AT_AIHIGH, chan);
+	outb(chan, dev->iobase + DMM32AT_AILOW);
+	outb(chan, dev->iobase + DMM32AT_AIHIGH);
 	/* set the range bits */
-	dmm_outb(dev, DMM32AT_AICONF, dmm32at_rangebits[range]);
+	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
 
 	/* wait for circuit to settle */
 	for (i = 0; i < 40000; i++) {
@@ -243,7 +241,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
-		dmm_outb(dev, DMM32AT_CONV, 0xff);
+		outb(0xff, dev->iobase + DMM32AT_CONV);
 		/* wait for conversion to end */
 		for (i = 0; i < 40000; i++) {
 			status = inb(dev->iobase + DMM32AT_AISTAT);
@@ -489,23 +487,22 @@ static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 	lo2 = both2 & 0x00ff;
 
 	/* set the counter frequency to 10mhz */
-	dmm_outb(dev, DMM32AT_CNTRDIO, 0);
+	outb(0, dev->iobase + DMM32AT_CNTRDIO);
 
 	/* get access to the clock regs */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_CLKACC);
+	outb(DMM32AT_CLKACC, dev->iobase + DMM32AT_CNTRL);
 
 	/* write the counter 1 control word and low byte to counter */
-	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT1);
-	dmm_outb(dev, DMM32AT_CLK1, lo1);
+	outb(DMM32AT_CLKCT1, dev->iobase + DMM32AT_CLKCT);
+	outb(lo1, dev->iobase + DMM32AT_CLK1);
 
 	/* write the counter 2 control word and low byte then to counter */
-	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT2);
-	dmm_outb(dev, DMM32AT_CLK2, lo2);
-	dmm_outb(dev, DMM32AT_CLK2, hi2);
+	outb(DMM32AT_CLKCT2, dev->iobase + DMM32AT_CLKCT);
+	outb(lo2, dev->iobase + DMM32AT_CLK2);
+	outb(hi2, dev->iobase + DMM32AT_CLK2);
 
 	/* enable the ai conversion interrupt and the clock to start scans */
-	dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT | DMM32AT_CLKSEL);
-
+	outb(DMM32AT_ADINT | DMM32AT_CLKSEL, dev->iobase + DMM32AT_INTCLOCK);
 }
 
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -525,20 +522,20 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	range = CR_RANGE(cmd->chanlist[0]);
 
 	/* reset fifo */
-	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
+	outb(DMM32AT_FIFORESET, dev->iobase + DMM32AT_FIFOCNTRL);
 
 	/* set scan enable */
-	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_SCANENABLE);
+	outb(DMM32AT_SCANENABLE, dev->iobase + DMM32AT_FIFOCNTRL);
 
 	/* write the ai channel range regs */
-	dmm_outb(dev, DMM32AT_AILOW, chanlo);
-	dmm_outb(dev, DMM32AT_AIHIGH, chanhi);
+	outb(chanlo, dev->iobase + DMM32AT_AILOW);
+	outb(chanhi, dev->iobase + DMM32AT_AIHIGH);
 
 	/* set the range bits */
-	dmm_outb(dev, DMM32AT_AICONF, dmm32at_rangebits[range]);
+	outb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AICONF);
 
 	/* reset the interrupt just in case */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_INTRESET);
+	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);
 
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_scans_left = cmd->stop_arg;
@@ -563,8 +560,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		dmm32at_setaitimer(dev, cmd->scan_begin_arg);
 	} else {
 		/* start the interrups and initiate a single scan */
-		dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT);
-		dmm_outb(dev, DMM32AT_CONV, 0xff);
+		outb(DMM32AT_ADINT, dev->iobase + DMM32AT_INTCLOCK);
+		outb(0xff, dev->iobase + DMM32AT_CONV);
 	}
 
 /*	printk("dmmat32 in command\n"); */
@@ -619,7 +616,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 			devpriv->ai_scans_left--;
 			if (devpriv->ai_scans_left == 0) {
 				/* disable further interrupts and clocks */
-				dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
+				outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
 				/* set the buffer to be flushed with an EOF */
 				s->async->events |= COMEDI_CB_EOA;
 			}
@@ -630,7 +627,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 	}
 
 	/* reset the interrupt */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_INTRESET);
+	outb(DMM32AT_INTRESET, dev->iobase + DMM32AT_CNTRL);
 	return IRQ_HANDLED;
 }
 
@@ -654,8 +651,8 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 		hi = (data[i] >> 8) + chan * (1 << 6);
 		/* printk("writing 0x%02x  0x%02x\n",hi,lo); */
 		/* write the low and high values to the board */
-		dmm_outb(dev, DMM32AT_DACLSB, lo);
-		dmm_outb(dev, DMM32AT_DACMSB, hi);
+		outb(lo, dev->iobase + DMM32AT_DACLSB);
+		outb(hi, dev->iobase + DMM32AT_DACMSB);
 
 		/* wait for circuit to settle */
 		for (i = 0; i < 40000; i++) {
@@ -712,21 +709,21 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 	}
 
 	/* get access to the DIO regs */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
 
 	/* if either part of dio is set for output */
 	if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
 	    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
 		diobits = (s->state & 0x00ff0000) >> 16;
-		dmm_outb(dev, DMM32AT_DIOC, diobits);
+		outb(diobits, dev->iobase + DMM32AT_DIOC);
 	}
 	if ((devpriv->dio_config & DMM32AT_DIRB) == 0) {
 		diobits = (s->state & 0x0000ff00) >> 8;
-		dmm_outb(dev, DMM32AT_DIOB, diobits);
+		outb(diobits, dev->iobase + DMM32AT_DIOB);
 	}
 	if ((devpriv->dio_config & DMM32AT_DIRA) == 0) {
 		diobits = (s->state & 0x000000ff);
-		dmm_outb(dev, DMM32AT_DIOA, diobits);
+		outb(diobits, dev->iobase + DMM32AT_DIOA);
 	}
 
 	/* now read the state back in */
@@ -777,9 +774,9 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 	else
 		devpriv->dio_config |= chanbit;
 	/* get access to the DIO regs */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+	outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
 	/* set the DIO's to the new configuration setting */
-	dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
+	outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
 
 	return 1;
 }
@@ -813,23 +810,23 @@ static int dmm32at_attach(struct comedi_device *dev,
 	   it to a known state */
 
 	/* reset the board */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_RESET);
+	outb(DMM32AT_RESET, dev->iobase + DMM32AT_CNTRL);
 
 	/* allow a millisecond to reset */
 	udelay(1000);
 
 	/* zero scan and fifo control */
-	dmm_outb(dev, DMM32AT_FIFOCNTRL, 0x0);
+	outb(0x0, dev->iobase + DMM32AT_FIFOCNTRL);
 
 	/* zero interrupt and clock control */
-	dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
+	outb(0x0, dev->iobase + DMM32AT_INTCLOCK);
 
 	/* write a test channel range, the high 3 bits should drop */
-	dmm_outb(dev, DMM32AT_AILOW, 0x80);
-	dmm_outb(dev, DMM32AT_AIHIGH, 0xff);
+	outb(0x80, dev->iobase + DMM32AT_AILOW);
+	outb(0xff, dev->iobase + DMM32AT_AIHIGH);
 
 	/* set the range at 10v unipolar */
-	dmm_outb(dev, DMM32AT_AICONF, DMM32AT_RANGE_U10);
+	outb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AICONF);
 
 	/* should take 10 us to settle, here's a hundred */
 	udelay(100);
@@ -908,11 +905,11 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (board->have_dio) {
 
 		/* get access to the DIO regs */
-		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+		outb(DMM32AT_DIOACC, dev->iobase + DMM32AT_CNTRL);
 		/* set the DIO's to the defualt input setting */
 		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
 		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
-		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
+		outb(devpriv->dio_config, dev->iobase + DMM32AT_DIOCONF);
 
 		/* set up the subdevice */
 		s->type = COMEDI_SUBD_DIO;

commit 99953ea1ec780c22bacf065fc7c9750f0182c0f4
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:12:35 2012 -0700

    staging: comedi: dmm32at: remove dmm_inb macro
    
    The macro is just a wrapper for inb(). Just use the inb() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index c139eff61643..ee4e8ab3485b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -78,7 +78,6 @@ Configuration Options:
 #define DMM32AT_DIOC 0x0e
 #define DMM32AT_DIOCONF 0x0f
 
-#define dmm_inb(cdev, reg) inb((cdev->iobase)+reg)
 #define dmm_outb(cdev, reg, valu) outb(valu, (cdev->iobase)+reg)
 
 /* Board register values. */
@@ -232,7 +231,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 
 	/* wait for circuit to settle */
 	for (i = 0; i < 40000; i++) {
-		status = dmm_inb(dev, DMM32AT_AIRBACK);
+		status = inb(dev->iobase + DMM32AT_AIRBACK);
 		if ((status & DMM32AT_STATUS) == 0)
 			break;
 	}
@@ -247,7 +246,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		dmm_outb(dev, DMM32AT_CONV, 0xff);
 		/* wait for conversion to end */
 		for (i = 0; i < 40000; i++) {
-			status = dmm_inb(dev, DMM32AT_AISTAT);
+			status = inb(dev->iobase + DMM32AT_AISTAT);
 			if ((status & DMM32AT_STATUS) == 0)
 				break;
 		}
@@ -257,8 +256,8 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		}
 
 		/* read data */
-		lsb = dmm_inb(dev, DMM32AT_AILSB);
-		msb = dmm_inb(dev, DMM32AT_AIMSB);
+		lsb = inb(dev->iobase + DMM32AT_AILSB);
+		msb = inb(dev->iobase + DMM32AT_AIMSB);
 
 		/* invert sign bit to make range unsigned, this is an
 		   idiosyncrasy of the diamond board, it return
@@ -550,7 +549,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* wait for circuit to settle */
 	for (i = 0; i < 40000; i++) {
-		status = dmm_inb(dev, DMM32AT_AIRBACK);
+		status = inb(dev->iobase + DMM32AT_AIRBACK);
 		if ((status & DMM32AT_STATUS) == 0)
 			break;
 	}
@@ -600,7 +599,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
+	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
 
 	if (intstat & DMM32AT_ADINT) {
 		struct comedi_subdevice *s = dev->read_subdev;
@@ -608,8 +607,8 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			/* read data */
-			lsb = dmm_inb(dev, DMM32AT_AILSB);
-			msb = dmm_inb(dev, DMM32AT_AIMSB);
+			lsb = inb(dev->iobase + DMM32AT_AILSB);
+			msb = inb(dev->iobase + DMM32AT_AIMSB);
 
 			/* invert sign bit to make range unsigned */
 			samp = ((msb ^ 0x0080) << 8) + lsb;
@@ -660,7 +659,7 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 
 		/* wait for circuit to settle */
 		for (i = 0; i < 40000; i++) {
-			status = dmm_inb(dev, DMM32AT_DACSTAT);
+			status = inb(dev->iobase + DMM32AT_DACSTAT);
 			if ((status & DMM32AT_DACBUSY) == 0)
 				break;
 		}
@@ -669,7 +668,7 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 			return -ETIMEDOUT;
 		}
 		/* dummy read to update trigger the output */
-		status = dmm_inb(dev, DMM32AT_DACMSB);
+		status = inb(dev->iobase + DMM32AT_DACMSB);
 
 	}
 
@@ -731,11 +730,11 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 	}
 
 	/* now read the state back in */
-	s->state = dmm_inb(dev, DMM32AT_DIOC);
+	s->state = inb(dev->iobase + DMM32AT_DIOC);
 	s->state <<= 8;
-	s->state |= dmm_inb(dev, DMM32AT_DIOB);
+	s->state |= inb(dev->iobase + DMM32AT_DIOB);
 	s->state <<= 8;
-	s->state |= dmm_inb(dev, DMM32AT_DIOA);
+	s->state |= inb(dev->iobase + DMM32AT_DIOA);
 	data[1] = s->state;
 
 	/* on return, data[1] contains the value of the digital
@@ -836,12 +835,12 @@ static int dmm32at_attach(struct comedi_device *dev,
 	udelay(100);
 
 	/* read back the values */
-	ailo = dmm_inb(dev, DMM32AT_AILOW);
-	aihi = dmm_inb(dev, DMM32AT_AIHIGH);
-	fifostat = dmm_inb(dev, DMM32AT_FIFOSTAT);
-	aistat = dmm_inb(dev, DMM32AT_AISTAT);
-	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
-	airback = dmm_inb(dev, DMM32AT_AIRBACK);
+	ailo = inb(dev->iobase + DMM32AT_AILOW);
+	aihi = inb(dev->iobase + DMM32AT_AIHIGH);
+	fifostat = inb(dev->iobase + DMM32AT_FIFOSTAT);
+	aistat = inb(dev->iobase + DMM32AT_AISTAT);
+	intstat = inb(dev->iobase + DMM32AT_INTCLOCK);
+	airback = inb(dev->iobase + DMM32AT_AIRBACK);
 
 	printk(KERN_DEBUG "dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
 	       ailo, aihi, fifostat);

commit 47ae6a72597c29745fc18d693fe00bc8a537cfdf
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:11:56 2012 -0700

    staging: comedi: dmm32at: remove forward declarations 2
    
    Move the dmm32at_ns_to_timer() and dmm32at_setaitimer() functions
    to remove the need for the remaining forward declarations.
    
    Also, make dmm32at_setaitimer() static, it's only referenced in
    this file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 9c3d322d0e39..c139eff61643 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -198,10 +198,6 @@ struct dmm32at_private {
  */
 #define devpriv ((struct dmm32at_private *)dev->private)
 
-/* prototypes for driver functions below */
-static int dmm32at_ns_to_timer(unsigned int *ns, int round);
-void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
-
 /*
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
@@ -279,6 +275,23 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
+/* This function doesn't require a particular form, this is just
+ * what happens to be used in some of the drivers.  It should
+ * convert ns nanoseconds to a counter value suitable for programming
+ * the device.  Also, it should adjust ns so that it cooresponds to
+ * the actual time that the device will use. */
+static int dmm32at_ns_to_timer(unsigned int *ns, int round)
+{
+	/* trivial timer */
+	/* if your timing is done through two cascaded timers, the
+	 * i8253_cascade_ns_to_timer() function in 8253.h can be
+	 * very helpful.  There are also i8254_load() and i8254_mm_load()
+	 * which can be used to load values into the ubiquitous 8254 counters
+	 */
+
+	return *ns;
+}
+
 static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_cmd *cmd)
@@ -465,6 +478,37 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+static void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
+{
+	unsigned char lo1, lo2, hi2;
+	unsigned short both2;
+
+	/* based on 10mhz clock */
+	lo1 = 200;
+	both2 = nansec / 20000;
+	hi2 = (both2 & 0xff00) >> 8;
+	lo2 = both2 & 0x00ff;
+
+	/* set the counter frequency to 10mhz */
+	dmm_outb(dev, DMM32AT_CNTRDIO, 0);
+
+	/* get access to the clock regs */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_CLKACC);
+
+	/* write the counter 1 control word and low byte to counter */
+	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT1);
+	dmm_outb(dev, DMM32AT_CLK1, lo1);
+
+	/* write the counter 2 control word and low byte then to counter */
+	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT2);
+	dmm_outb(dev, DMM32AT_CLK2, lo2);
+	dmm_outb(dev, DMM32AT_CLK2, hi2);
+
+	/* enable the ai conversion interrupt and the clock to start scans */
+	dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT | DMM32AT_CLKSEL);
+
+}
+
 static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -591,23 +635,6 @@ static irqreturn_t dmm32at_isr(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* This function doesn't require a particular form, this is just
- * what happens to be used in some of the drivers.  It should
- * convert ns nanoseconds to a counter value suitable for programming
- * the device.  Also, it should adjust ns so that it cooresponds to
- * the actual time that the device will use. */
-static int dmm32at_ns_to_timer(unsigned int *ns, int round)
-{
-	/* trivial timer */
-	/* if your timing is done through two cascaded timers, the
-	 * i8253_cascade_ns_to_timer() function in 8253.h can be
-	 * very helpful.  There are also i8254_load() and i8254_mm_load()
-	 * which can be used to load values into the ubiquitous 8254 counters
-	 */
-
-	return *ns;
-}
-
 static int dmm32at_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -758,37 +785,6 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 	return 1;
 }
 
-void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
-{
-	unsigned char lo1, lo2, hi2;
-	unsigned short both2;
-
-	/* based on 10mhz clock */
-	lo1 = 200;
-	both2 = nansec / 20000;
-	hi2 = (both2 & 0xff00) >> 8;
-	lo2 = both2 & 0x00ff;
-
-	/* set the counter frequency to 10mhz */
-	dmm_outb(dev, DMM32AT_CNTRDIO, 0);
-
-	/* get access to the clock regs */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_CLKACC);
-
-	/* write the counter 1 control word and low byte to counter */
-	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT1);
-	dmm_outb(dev, DMM32AT_CLK1, lo1);
-
-	/* write the counter 2 control word and low byte then to counter */
-	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT2);
-	dmm_outb(dev, DMM32AT_CLK2, lo2);
-	dmm_outb(dev, DMM32AT_CLK2, hi2);
-
-	/* enable the ai conversion interrupt and the clock to start scans */
-	dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT | DMM32AT_CLKSEL);
-
-}
-
 static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {

commit 4f793db33dc3bab1b77a540386a662fbfd595e08
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:11:23 2012 -0700

    staging: comedi: dmm32at: remove forward declarations 1
    
    Move the attach/detach functions as well as the boardinfo variable
    to remove the need to most of the forward declarations.
    
    Add some whitespace to the boardinfo during the move.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ad7fef915395..9c3d322d0e39 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -175,19 +175,6 @@ struct dmm32at_board {
 	int have_dio;
 	int dio_chans;
 };
-static const struct dmm32at_board dmm32at_boards[] = {
-	{
-	 .name = "dmm32at",
-	 .ai_chans = 32,
-	 .ai_bits = 16,
-	 .ai_ranges = &dmm32at_airanges,
-	 .ao_chans = 4,
-	 .ao_bits = 12,
-	 .ao_ranges = &dmm32at_aoranges,
-	 .have_dio = 1,
-	 .dio_chans = 24,
-	 },
-};
 
 /* this structure is for data unique to this hardware driver.  If
  * several hardware drivers keep similar information in this structure,
@@ -212,197 +199,9 @@ struct dmm32at_private {
 #define devpriv ((struct dmm32at_private *)dev->private)
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_bits(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_config(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data);
-static int dmm32at_ai_cmdtest(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_cmd *cmd);
-static int dmm32at_ai_cmd(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
-static int dmm32at_ai_cancel(struct comedi_device *dev,
-			     struct comedi_subdevice *s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
-static irqreturn_t dmm32at_isr(int irq, void *d);
 void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int dmm32at_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it)
-{
-	const struct dmm32at_board *board = comedi_board(dev);
-	int ret;
-	struct comedi_subdevice *s;
-	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
-	unsigned long iobase;
-	unsigned int irq;
-
-	iobase = it->options[0];
-	irq = it->options[1];
-
-	printk(KERN_INFO "comedi%d: dmm32at: attaching\n", dev->minor);
-	printk(KERN_DEBUG "dmm32at: probing at address 0x%04lx, irq %u\n",
-	       iobase, irq);
-
-	/* register address space */
-	if (!request_region(iobase, DMM32AT_MEMSIZE, board->name)) {
-		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
-		       dev->minor);
-		return -EIO;
-	}
-	dev->iobase = iobase;
-
-	/* the following just makes sure the board is there and gets
-	   it to a known state */
-
-	/* reset the board */
-	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_RESET);
-
-	/* allow a millisecond to reset */
-	udelay(1000);
-
-	/* zero scan and fifo control */
-	dmm_outb(dev, DMM32AT_FIFOCNTRL, 0x0);
-
-	/* zero interrupt and clock control */
-	dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
-
-	/* write a test channel range, the high 3 bits should drop */
-	dmm_outb(dev, DMM32AT_AILOW, 0x80);
-	dmm_outb(dev, DMM32AT_AIHIGH, 0xff);
-
-	/* set the range at 10v unipolar */
-	dmm_outb(dev, DMM32AT_AICONF, DMM32AT_RANGE_U10);
-
-	/* should take 10 us to settle, here's a hundred */
-	udelay(100);
-
-	/* read back the values */
-	ailo = dmm_inb(dev, DMM32AT_AILOW);
-	aihi = dmm_inb(dev, DMM32AT_AIHIGH);
-	fifostat = dmm_inb(dev, DMM32AT_FIFOSTAT);
-	aistat = dmm_inb(dev, DMM32AT_AISTAT);
-	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
-	airback = dmm_inb(dev, DMM32AT_AIRBACK);
-
-	printk(KERN_DEBUG "dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
-	       ailo, aihi, fifostat);
-	printk(KERN_DEBUG
-	       "dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
-	       aistat, intstat, airback);
-
-	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
-	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
-		printk(KERN_ERR "dmmat32: board detection failed\n");
-		return -EIO;
-	}
-
-	/* board is there, register interrupt */
-	if (irq) {
-		ret = request_irq(irq, dmm32at_isr, 0, board->name, dev);
-		if (ret < 0) {
-			printk(KERN_ERR "dmm32at: irq conflict\n");
-			return ret;
-		}
-		dev->irq = irq;
-	}
-
-	dev->board_name = board->name;
-
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
-		return -ENOMEM;
-
-	ret = comedi_alloc_subdevices(dev, 3);
-	if (ret)
-		return ret;
-
-	s = dev->subdevices + 0;
-	dev->read_subdev = s;
-	/* analog input subdevice */
-	s->type = COMEDI_SUBD_AI;
-	/* we support single-ended (ground) and differential */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = board->ai_chans;
-	s->maxdata = (1 << board->ai_bits) - 1;
-	s->range_table = board->ai_ranges;
-	s->len_chanlist = 32;	/* This is the maximum chanlist length that
-				   the board can handle */
-	s->insn_read = dmm32at_ai_rinsn;
-	s->do_cmd = dmm32at_ai_cmd;
-	s->do_cmdtest = dmm32at_ai_cmdtest;
-	s->cancel = dmm32at_ai_cancel;
-
-	s = dev->subdevices + 1;
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = board->ao_chans;
-	s->maxdata = (1 << board->ao_bits) - 1;
-	s->range_table = board->ao_ranges;
-	s->insn_write = dmm32at_ao_winsn;
-	s->insn_read = dmm32at_ao_rinsn;
-
-	s = dev->subdevices + 2;
-	/* digital i/o subdevice */
-	if (board->have_dio) {
-
-		/* get access to the DIO regs */
-		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
-		/* set the DIO's to the defualt input setting */
-		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
-		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
-
-		/* set up the subdevice */
-		s->type = COMEDI_SUBD_DIO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = board->dio_chans;
-		s->maxdata = 1;
-		s->state = 0;
-		s->range_table = &range_digital;
-		s->insn_bits = dmm32at_dio_insn_bits;
-		s->insn_config = dmm32at_dio_insn_config;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	/* success */
-	printk(KERN_INFO "comedi%d: dmm32at: attached\n", dev->minor);
-
-	return 1;
-
-}
-
-static void dmm32at_detach(struct comedi_device *dev)
-{
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, DMM32AT_MEMSIZE);
-}
-
 /*
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
@@ -990,6 +789,178 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 
 }
 
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
+{
+	const struct dmm32at_board *board = comedi_board(dev);
+	int ret;
+	struct comedi_subdevice *s;
+	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
+	unsigned long iobase;
+	unsigned int irq;
+
+	iobase = it->options[0];
+	irq = it->options[1];
+
+	printk(KERN_INFO "comedi%d: dmm32at: attaching\n", dev->minor);
+	printk(KERN_DEBUG "dmm32at: probing at address 0x%04lx, irq %u\n",
+	       iobase, irq);
+
+	/* register address space */
+	if (!request_region(iobase, DMM32AT_MEMSIZE, board->name)) {
+		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
+		       dev->minor);
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	/* the following just makes sure the board is there and gets
+	   it to a known state */
+
+	/* reset the board */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_RESET);
+
+	/* allow a millisecond to reset */
+	udelay(1000);
+
+	/* zero scan and fifo control */
+	dmm_outb(dev, DMM32AT_FIFOCNTRL, 0x0);
+
+	/* zero interrupt and clock control */
+	dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
+
+	/* write a test channel range, the high 3 bits should drop */
+	dmm_outb(dev, DMM32AT_AILOW, 0x80);
+	dmm_outb(dev, DMM32AT_AIHIGH, 0xff);
+
+	/* set the range at 10v unipolar */
+	dmm_outb(dev, DMM32AT_AICONF, DMM32AT_RANGE_U10);
+
+	/* should take 10 us to settle, here's a hundred */
+	udelay(100);
+
+	/* read back the values */
+	ailo = dmm_inb(dev, DMM32AT_AILOW);
+	aihi = dmm_inb(dev, DMM32AT_AIHIGH);
+	fifostat = dmm_inb(dev, DMM32AT_FIFOSTAT);
+	aistat = dmm_inb(dev, DMM32AT_AISTAT);
+	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
+	airback = dmm_inb(dev, DMM32AT_AIRBACK);
+
+	printk(KERN_DEBUG "dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
+	       ailo, aihi, fifostat);
+	printk(KERN_DEBUG
+	       "dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
+	       aistat, intstat, airback);
+
+	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
+	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
+		printk(KERN_ERR "dmmat32: board detection failed\n");
+		return -EIO;
+	}
+
+	/* board is there, register interrupt */
+	if (irq) {
+		ret = request_irq(irq, dmm32at_isr, 0, board->name, dev);
+		if (ret < 0) {
+			printk(KERN_ERR "dmm32at: irq conflict\n");
+			return ret;
+		}
+		dev->irq = irq;
+	}
+
+	dev->board_name = board->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
+		return -ENOMEM;
+
+	ret = comedi_alloc_subdevices(dev, 3);
+	if (ret)
+		return ret;
+
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	/* we support single-ended (ground) and differential */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = board->ai_chans;
+	s->maxdata = (1 << board->ai_bits) - 1;
+	s->range_table = board->ai_ranges;
+	s->len_chanlist = 32;	/* This is the maximum chanlist length that
+				   the board can handle */
+	s->insn_read = dmm32at_ai_rinsn;
+	s->do_cmd = dmm32at_ai_cmd;
+	s->do_cmdtest = dmm32at_ai_cmdtest;
+	s->cancel = dmm32at_ai_cancel;
+
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = board->ao_chans;
+	s->maxdata = (1 << board->ao_bits) - 1;
+	s->range_table = board->ao_ranges;
+	s->insn_write = dmm32at_ao_winsn;
+	s->insn_read = dmm32at_ao_rinsn;
+
+	s = dev->subdevices + 2;
+	/* digital i/o subdevice */
+	if (board->have_dio) {
+
+		/* get access to the DIO regs */
+		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+		/* set the DIO's to the defualt input setting */
+		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
+		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
+		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
+
+		/* set up the subdevice */
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->n_chan = board->dio_chans;
+		s->maxdata = 1;
+		s->state = 0;
+		s->range_table = &range_digital;
+		s->insn_bits = dmm32at_dio_insn_bits;
+		s->insn_config = dmm32at_dio_insn_config;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* success */
+	printk(KERN_INFO "comedi%d: dmm32at: attached\n", dev->minor);
+
+	return 1;
+
+}
+
+static void dmm32at_detach(struct comedi_device *dev)
+{
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, DMM32AT_MEMSIZE);
+}
+
+static const struct dmm32at_board dmm32at_boards[] = {
+	{
+		.name		= "dmm32at",
+		.ai_chans	= 32,
+		.ai_bits	= 16,
+		.ai_ranges	= &dmm32at_airanges,
+		.ao_chans	= 4,
+		.ao_bits	= 12,
+		.ao_ranges	= &dmm32at_aoranges,
+		.have_dio	= 1,
+		.dio_chans	= 24,
+	},
+};
+
 static struct comedi_driver dmm32at_driver = {
 	.driver_name	= "dmm32at",
 	.module		= THIS_MODULE,

commit 17f49dd46c5db2912d2dd985f400f6237fd30255
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jul 2 18:10:46 2012 -0700

    staging: comedi: dmm32at: use module_comedi_driver
    
    Convert driver to use the module_comedi_driver() macro to remove
    some of the boilerplate.
    
    Move the comedi_driver variable to the end of the file to keep it
    with the module_comedi_driver() macro. This also removes the need
    for some of the forward declarations. While moving the variable:
    
    1) strip out the unnecessary cut-and-paste skel driver comments
    2) add whitespace to improve the readability
    3) rename the variable from driver* to *driver
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index af3531676e81..ad7fef915395 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -211,43 +211,6 @@ struct dmm32at_private {
  */
 #define devpriv ((struct dmm32at_private *)dev->private)
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int dmm32at_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it);
-static void dmm32at_detach(struct comedi_device *dev);
-static struct comedi_driver driver_dmm32at = {
-	.driver_name = "dmm32at",
-	.module = THIS_MODULE,
-	.attach = dmm32at_attach,
-	.detach = dmm32at_detach,
-/* It is not necessary to implement the following members if you are
- * writing a driver for a ISA PnP or PCI card */
-/* Most drivers will support multiple types of boards by
- * having an array of board structures.  These were defined
- * in dmm32at_boards[] above.  Note that the element 'name'
- * was first in the structure -- Comedi uses this fact to
- * extract the name of the board without knowing any details
- * about the structure except for its length.
- * When a device is attached (by comedi_config), the name
- * of the device is given to Comedi, and Comedi tries to
- * match it by going through the list of board names.  If
- * there is a match, the address of the pointer is put
- * into dev->board_ptr and driver->attach() is called.
- *
- * Note that these are not necessary if you can determine
- * the type of board in software.  ISA PnP, PCI, and PCMCIA
- * devices are such boards.
- */
-	.board_name = &dmm32at_boards[0].name,
-	.offset = sizeof(struct dmm32at_board),
-	.num_names = ARRAY_SIZE(dmm32at_boards),
-};
-
 /* prototypes for driver functions below */
 static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
@@ -1027,22 +990,16 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 
 }
 
-/*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
- */
-static int __init driver_dmm32at_init_module(void)
-{
-	return comedi_driver_register(&driver_dmm32at);
-}
-
-static void __exit driver_dmm32at_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_dmm32at);
-}
-
-module_init(driver_dmm32at_init_module);
-module_exit(driver_dmm32at_cleanup_module);
+static struct comedi_driver dmm32at_driver = {
+	.driver_name	= "dmm32at",
+	.module		= THIS_MODULE,
+	.attach		= dmm32at_attach,
+	.detach		= dmm32at_detach,
+	.board_name	= &dmm32at_boards[0].name,
+	.offset		= sizeof(struct dmm32at_board),
+	.num_names	= ARRAY_SIZE(dmm32at_boards),
+};
+module_comedi_driver(dmm32at_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 7cc9d20f3482..af3531676e81 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -956,7 +956,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 	 * it was a purely digital output subdevice */
 	/* data[1]=s->state; */
 
-	return 2;
+	return insn->n;
 }
 
 static int dmm32at_dio_insn_config(struct comedi_device *dev,

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 2b60cf816b6e..7cc9d20f3482 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -914,9 +914,6 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev,
 {
 	unsigned char diobits;
 
-	if (insn->n != 2)
-		return -EINVAL;
-
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 	if (data[0]) {

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 6b637a2a48c7..2b60cf816b6e 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -371,8 +371,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
 		return -ENOMEM;
 
-	if (comedi_alloc_subdevices(dev, 3) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 3);
+	if (ret)
+		return ret;
 
 	s = dev->subdevices + 0;
 	dev->read_subdev = s;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 40d7befec5ea..6b637a2a48c7 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -371,10 +371,6 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
 		return -ENOMEM;
 
-/*
- * Allocate the subdevice structures.  alloc_subdevice() is a
- * convenient macro defined in comedidev.h.
- */
 	if (comedi_alloc_subdevices(dev, 3) < 0)
 		return -ENOMEM;
 

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 5be99b5d22e4..40d7befec5ea 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -375,7 +375,7 @@ static int dmm32at_attach(struct comedi_device *dev,
  * Allocate the subdevice structures.  alloc_subdevice() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_subdevices(dev, 3) < 0)
+	if (comedi_alloc_subdevices(dev, 3) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit df9d33493474a342c866119c28204e0a790de5c0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 16:23:09 2012 -0700

    staging: comedi: remove thisboard macro in the dmm32at driver
    
    The 'thisboard' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 83828903db4b..5be99b5d22e4 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -189,11 +189,6 @@ static const struct dmm32at_board dmm32at_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct dmm32at_board *)dev->board_ptr)
-
 /* this structure is for data unique to this hardware driver.  If
  * several hardware drivers keep similar information in this structure,
  * feel free to suggest moving the variable to the struct comedi_device struct.
@@ -290,6 +285,7 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
 static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
+	const struct dmm32at_board *board = comedi_board(dev);
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
@@ -304,7 +300,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	       iobase, irq);
 
 	/* register address space */
-	if (!request_region(iobase, DMM32AT_MEMSIZE, thisboard->name)) {
+	if (!request_region(iobase, DMM32AT_MEMSIZE, board->name)) {
 		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
 		       dev->minor);
 		return -EIO;
@@ -358,7 +354,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 	/* board is there, register interrupt */
 	if (irq) {
-		ret = request_irq(irq, dmm32at_isr, 0, thisboard->name, dev);
+		ret = request_irq(irq, dmm32at_isr, 0, board->name, dev);
 		if (ret < 0) {
 			printk(KERN_ERR "dmm32at: irq conflict\n");
 			return ret;
@@ -366,18 +362,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 		dev->irq = irq;
 	}
 
-/*
- * If you can probe the device to determine what device in a series
- * it is, this is the place to do it.  Otherwise, dev->board_ptr
- * should already be initialized.
- */
-	/* dev->board_ptr = dmm32at_probe(dev); */
-
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 /*
  * Allocate the private structure area.  alloc_private() is a
@@ -399,9 +384,9 @@ static int dmm32at_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	/* we support single-ended (ground) and differential */
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	s->n_chan = thisboard->ai_chans;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ai_ranges;
+	s->n_chan = board->ai_chans;
+	s->maxdata = (1 << board->ai_bits) - 1;
+	s->range_table = board->ai_ranges;
 	s->len_chanlist = 32;	/* This is the maximum chanlist length that
 				   the board can handle */
 	s->insn_read = dmm32at_ai_rinsn;
@@ -413,15 +398,15 @@ static int dmm32at_attach(struct comedi_device *dev,
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = thisboard->ao_chans;
-	s->maxdata = (1 << thisboard->ao_bits) - 1;
-	s->range_table = thisboard->ao_ranges;
+	s->n_chan = board->ao_chans;
+	s->maxdata = (1 << board->ao_bits) - 1;
+	s->range_table = board->ao_ranges;
 	s->insn_write = dmm32at_ao_winsn;
 	s->insn_read = dmm32at_ao_rinsn;
 
 	s = dev->subdevices + 2;
 	/* digital i/o subdevice */
-	if (thisboard->have_dio) {
+	if (board->have_dio) {
 
 		/* get access to the DIO regs */
 		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
@@ -433,7 +418,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 		/* set up the subdevice */
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = thisboard->dio_chans;
+		s->n_chan = board->dio_chans;
 		s->maxdata = 1;
 		s->state = 0;
 		s->range_table = &range_digital;

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 2b4e6e6eb825..83828903db4b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -224,7 +224,7 @@ struct dmm32at_private {
  */
 static int dmm32at_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it);
-static int dmm32at_detach(struct comedi_device *dev);
+static void dmm32at_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dmm32at = {
 	.driver_name = "dmm32at",
 	.module = THIS_MODULE,
@@ -450,23 +450,12 @@ static int dmm32at_attach(struct comedi_device *dev,
 
 }
 
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int dmm32at_detach(struct comedi_device *dev)
+static void dmm32at_detach(struct comedi_device *dev)
 {
-	printk(KERN_INFO "comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, DMM32AT_MEMSIZE);
-
-	return 0;
 }
 
 /*

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 693728e14bdb..2b4e6e6eb825 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -532,7 +532,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		msb = dmm_inb(dev, DMM32AT_AIMSB);
 
 		/* invert sign bit to make range unsigned, this is an
-		   idiosyncracy of the diamond board, it return
+		   idiosyncrasy of the diamond board, it return
 		   conversions as a signed value, i.e. -32768 to
 		   32767, flipping the bit and interpreting it as
 		   signed gives you a range of 0 to 65535 which is

commit 27bf0bc906e80fdb531524dab22a7851a4c21698
Author: Mark <reodge@gmail.com>
Date:   Tue Jul 6 18:23:15 2010 +0100

    Staging: comedi: Cleanup on dmm32at.c from checkpatch.pl
    
    This patch cleans up some style issues in dmm32at.c as found by checkpatch.pl
    
    Signed-off-by: Mark Rankilor <reodge@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 957322320b73..693728e14bdb 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -299,12 +299,14 @@ static int dmm32at_attach(struct comedi_device *dev,
 	iobase = it->options[0];
 	irq = it->options[1];
 
-	printk("comedi%d: dmm32at: attaching\n", dev->minor);
-	printk("dmm32at: probing at address 0x%04lx, irq %u\n", iobase, irq);
+	printk(KERN_INFO "comedi%d: dmm32at: attaching\n", dev->minor);
+	printk(KERN_DEBUG "dmm32at: probing at address 0x%04lx, irq %u\n",
+	       iobase, irq);
 
 	/* register address space */
 	if (!request_region(iobase, DMM32AT_MEMSIZE, thisboard->name)) {
-		printk("I/O port conflict\n");
+		printk(KERN_ERR "comedi%d: dmm32at: I/O port conflict\n",
+		       dev->minor);
 		return -EIO;
 	}
 	dev->iobase = iobase;
@@ -342,14 +344,15 @@ static int dmm32at_attach(struct comedi_device *dev,
 	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
 	airback = dmm_inb(dev, DMM32AT_AIRBACK);
 
-	printk("dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
+	printk(KERN_DEBUG "dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
 	       ailo, aihi, fifostat);
-	printk("dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
+	printk(KERN_DEBUG
+	       "dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
 	       aistat, intstat, airback);
 
 	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
 	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
-		printk("dmmat32: board detection failed\n");
+		printk(KERN_ERR "dmmat32: board detection failed\n");
 		return -EIO;
 	}
 
@@ -357,7 +360,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	if (irq) {
 		ret = request_irq(irq, dmm32at_isr, 0, thisboard->name, dev);
 		if (ret < 0) {
-			printk("irq conflict\n");
+			printk(KERN_ERR "dmm32at: irq conflict\n");
 			return ret;
 		}
 		dev->irq = irq;
@@ -441,7 +444,7 @@ static int dmm32at_attach(struct comedi_device *dev,
 	}
 
 	/* success */
-	printk("comedi%d: dmm32at: attached\n", dev->minor);
+	printk(KERN_INFO "comedi%d: dmm32at: attached\n", dev->minor);
 
 	return 1;
 
@@ -457,7 +460,7 @@ static int dmm32at_attach(struct comedi_device *dev,
  */
 static int dmm32at_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: dmm32at: remove\n", dev->minor);
+	printk(KERN_INFO "comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)
@@ -505,7 +508,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 			break;
 	}
 	if (i == 40000) {
-		printk("timeout\n");
+		printk(KERN_WARNING "dmm32at: timeout\n");
 		return -ETIMEDOUT;
 	}
 
@@ -520,7 +523,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 				break;
 		}
 		if (i == 40000) {
-			printk("timeout\n");
+			printk(KERN_WARNING "dmm32at: timeout\n");
 			return -ETIMEDOUT;
 		}
 
@@ -590,7 +593,8 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* step 2: make sure trigger sources are unique and mutually
+	 * compatible */
 
 	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
@@ -763,7 +767,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_scans_left = cmd->stop_arg;
 	else {			/* TRIG_NONE */
-		devpriv->ai_scans_left = 0xffffffff;	/* indicates TRIG_NONE to isr */
+		devpriv->ai_scans_left = 0xffffffff; /* indicates TRIG_NONE to
+						      * isr */
 	}
 
 	/* wait for circuit to settle */
@@ -773,7 +778,7 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			break;
 	}
 	if (i == 40000) {
-		printk("timeout\n");
+		printk(KERN_WARNING "dmm32at: timeout\n");
 		return -ETIMEDOUT;
 	}
 
@@ -786,13 +791,13 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		dmm_outb(dev, DMM32AT_CONV, 0xff);
 	}
 
-/* 	printk("dmmat32 in command\n"); */
+/*	printk("dmmat32 in command\n"); */
 
-/* 	for(i=0;i<cmd->chanlist_len;i++) */
-/* 		comedi_buf_put(s->async,i*100); */
+/*	for(i=0;i<cmd->chanlist_len;i++) */
+/*		comedi_buf_put(s->async,i*100); */
 
-/* 	s->async->events |= COMEDI_CB_EOA; */
-/* 	comedi_event(dev, s); */
+/*	s->async->events |= COMEDI_CB_EOA; */
+/*	comedi_event(dev, s); */
 
 	return 0;
 
@@ -900,7 +905,7 @@ static int dmm32at_ao_winsn(struct comedi_device *dev,
 				break;
 		}
 		if (i == 40000) {
-			printk("timeout\n");
+			printk(KERN_WARNING "dmm32at: timeout\n");
 			return -ETIMEDOUT;
 		}
 		/* dummy read to update trigger the output */

commit 80370692f60b4d5dfa243cb0fbd0a87a42a939a8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 14 12:49:27 2010 +0100

    Staging: Comedi: drivers: Remove comment copied from skel.c
    
    The dmm32at.c and comedi_bond.c comedi driver files contain an
    instructional comment block copied over from skel.c about how to format
    a driver comment block.  This comment was modified in skel.c by a
    previous patch in this series to stop Comedi's 'dump_doc' script
    treating it as an actual driver comment block.  There isn't any need to
    repeat this comment block in the other source files, so rather than
    modify it, this patch just removes it from those files.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index dcde8d8dd406..957322320b73 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -37,43 +37,6 @@ Configuration Options:
   comedi_config /dev/comedi0 dmm32at baseaddr,irq
 */
 
-/*
- * The previous block comment is used to automatically generate
- * documentation in Comedi and Comedilib.  The fields:
- *
- * Driver: the name of the driver
- * Description: a short phrase describing the driver.  Don't list boards.
- * Devices: a full list of the boards that attempt to be supported by
- *   the driver.  Format is "(manufacturer) board name [comedi name]",
- *   where comedi_name is the name that is used to configure the board.
- *   See the comment near board_name: in the struct comedi_driver structure
- *   below.  If (manufacturer) or [comedi name] is missing, the previous
- *   value is used.
- * Author: you
- * Updated: date when the _documentation_ was last updated.  Use 'date -R'
- *   to get a value for this.
- * Status: a one-word description of the status.  Valid values are:
- *   works - driver works correctly on most boards supported, and
- *     passes comedi_test.
- *   unknown - unknown.  Usually put there by ds.
- *   experimental - may not work in any particular release.  Author
- *     probably wants assistance testing it.
- *   bitrotten - driver has not been update in a long time, probably
- *     doesn't work, and probably is missing support for significant
- *     Comedi interface features.
- *   untested - author probably wrote it "blind", and is believed to
- *     work, but no confirmation.
- *
- * These headers should be followed by a blank line, and any comments
- * you wish to say about the driver.  The comment area is the place
- * to put any known bugs, limitations, unsupported features, supported
- * command triggers, whether or not commands are supported on particular
- * subdevices, etc.
- *
- * Somewhere in the comment should be information about configuration
- * options that are used with comedi_config.
- */
-
 #include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/ioport.h>

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 572b7a9e8673..dcde8d8dd406 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -1095,7 +1095,18 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver_dmm32at);
+static int __init driver_dmm32at_init_module(void)
+{
+	return comedi_driver_register(&driver_dmm32at);
+}
+
+static void __exit driver_dmm32at_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_dmm32at);
+}
+
+module_init(driver_dmm32at_init_module);
+module_exit(driver_dmm32at_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index d5cbd515c370..572b7a9e8673 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -1096,3 +1096,7 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
  * as necessary.
  */
 COMEDI_INITCLEANUP(driver_dmm32at);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 20962c10c19862c58c03eec2434279a5d104c40e
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Fri Feb 26 10:15:09 2010 +0100

    Staging: comedi: dmm32at.c: Checkpatch cleanup
    
    WARNING: braces {} are not necessary for any arm of this statement
    +       if (data[0] == COMEDI_OUTPUT) {
    [...]
    +       } else {
    [...]
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 9db9a467c8f8..d5cbd515c370 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -1048,11 +1048,10 @@ static int dmm32at_dio_insn_config(struct comedi_device *dev,
 	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
 
 	/* if output clear the bit, otherwise set it */
-	if (data[0] == COMEDI_OUTPUT) {
+	if (data[0] == COMEDI_OUTPUT)
 		devpriv->dio_config &= ~chanbit;
-	} else {
+	else
 		devpriv->dio_config |= chanbit;
-	}
 	/* get access to the DIO regs */
 	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
 	/* set the DIO's to the new configuration setting */

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index aeec1ee9ad6b..9db9a467c8f8 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -629,7 +629,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->scan_begin_src != TRIG_EXT)
 		err++;

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 573cbe72b20b..aeec1ee9ad6b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -168,11 +168,11 @@ Configuration Options:
 static const struct comedi_lrange dmm32at_airanges = {
 	4,
 	{
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-		}
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 }
 };
 
 /* register values for above ranges */
@@ -189,11 +189,11 @@ static const unsigned char dmm32at_rangebits[] = {
 static const struct comedi_lrange dmm32at_aoranges = {
 	4,
 	{
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-		}
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 }
 };
 
 /*
@@ -214,16 +214,16 @@ struct dmm32at_board {
 };
 static const struct dmm32at_board dmm32at_boards[] = {
 	{
-	.name = "dmm32at",
-	.ai_chans = 32,
-	.ai_bits = 16,
-	.ai_ranges = &dmm32at_airanges,
-	.ao_chans = 4,
-	.ao_bits = 12,
-	.ao_ranges = &dmm32at_aoranges,
-	.have_dio = 1,
-	.dio_chans = 24,
-		},
+	 .name = "dmm32at",
+	 .ai_chans = 32,
+	 .ai_bits = 16,
+	 .ai_ranges = &dmm32at_airanges,
+	 .ao_chans = 4,
+	 .ao_bits = 12,
+	 .ao_ranges = &dmm32at_aoranges,
+	 .have_dio = 1,
+	 .dio_chans = 24,
+	 },
 };
 
 /*
@@ -259,7 +259,8 @@ struct dmm32at_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int dmm32at_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dmm32at = {
 	.driver_name = "dmm32at",
@@ -290,20 +291,29 @@ static struct comedi_driver driver_dmm32at = {
 };
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dmm32at_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int dmm32at_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd);
+static int dmm32at_ai_cmd(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
+static int dmm32at_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
 static irqreturn_t dmm32at_isr(int irq, void *d);
 void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
@@ -314,7 +324,8 @@ void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int dmm32at_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -369,12 +380,12 @@ static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	airback = dmm_inb(dev, DMM32AT_AIRBACK);
 
 	printk("dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
-		ailo, aihi, fifostat);
+	       ailo, aihi, fifostat);
 	printk("dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
-		aistat, intstat, airback);
+	       aistat, intstat, airback);
 
 	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
-		(aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
+	    (aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
 		printk("dmmat32: board detection failed\n");
 		return -EIO;
 	}
@@ -450,7 +461,7 @@ static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
 		/* set the DIO's to the defualt input setting */
 		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
-			DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
+		    DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
 		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
 
 		/* set up the subdevice */
@@ -497,8 +508,9 @@ static int dmm32at_detach(struct comedi_device *dev)
  * mode.
  */
 
-static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int d;
@@ -568,8 +580,9 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *
 	return n;
 }
 
-static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dmm32at_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -618,7 +631,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
@@ -703,21 +716,21 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		dmm32at_ns_to_timer(&cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				    cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		dmm32at_ns_to_timer(&cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+				    cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER &&
-			cmd->scan_begin_arg <
-			cmd->convert_arg * cmd->scan_end_arg) {
+		    cmd->scan_begin_arg <
+		    cmd->convert_arg * cmd->scan_end_arg) {
 			cmd->scan_begin_arg =
-				cmd->convert_arg * cmd->scan_end_arg;
+			    cmd->convert_arg * cmd->scan_end_arg;
 			err++;
 		}
 	}
@@ -733,14 +746,14 @@ static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -822,7 +835,8 @@ static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 }
 
-static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dmm32at_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	devpriv->ai_scans_left = 1;
 	return 0;
@@ -893,8 +907,9 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 	return *ns;
 }
 
-static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -936,8 +951,9 @@ static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_ao_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -953,8 +969,9 @@ static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_dio_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char diobits;
 
@@ -975,7 +992,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdev
 
 	/* if either part of dio is set for output */
 	if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
-		((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
+	    ((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
 		diobits = (s->state & 0x00ff0000) >> 16;
 		dmm_outb(dev, DMM32AT_DIOC, diobits);
 	}
@@ -1006,8 +1023,9 @@ static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdev
 	return 2;
 }
 
-static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dmm32at_dio_insn_config(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 5a53c61ddbdf..573cbe72b20b 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -74,6 +74,7 @@ Configuration Options:
  * options that are used with comedi_config.
  */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 #include <linux/ioport.h>
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 47b3ebc34a68..5a53c61ddbdf 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -380,8 +380,7 @@ static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	/* board is there, register interrupt */
 	if (irq) {
-		ret = comedi_request_irq(irq, dmm32at_isr, 0, thisboard->name,
-			dev);
+		ret = request_irq(irq, dmm32at_isr, 0, thisboard->name, dev);
 		if (ret < 0) {
 			printk("irq conflict\n");
 			return ret;
@@ -485,7 +484,7 @@ static int dmm32at_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->iobase)
 		release_region(dev->iobase, DMM32AT_MEMSIZE);
 

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index e7c5130de8d0..47b3ebc34a68 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -285,7 +285,7 @@ static struct comedi_driver driver_dmm32at = {
  */
 	.board_name = &dmm32at_boards[0].name,
 	.offset = sizeof(struct dmm32at_board),
-	.num_names = sizeof(dmm32at_boards) / sizeof(struct dmm32at_board),
+	.num_names = ARRAY_SIZE(dmm32at_boards),
 };
 
 /* prototypes for driver functions below */

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index ce53d161a690..e7c5130de8d0 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -289,23 +289,23 @@ static struct comedi_driver driver_dmm32at = {
 };
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
 static irqreturn_t dmm32at_isr(int irq, void *d);
-void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
+void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec);
 
 /*
  * Attach is called by the Comedi core to configure the driver

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index a8c0603d0d95..ce53d161a690 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -213,15 +213,15 @@ struct dmm32at_board {
 };
 static const struct dmm32at_board dmm32at_boards[] = {
 	{
-	      name:	"dmm32at",
-	      ai_chans:32,
-	      ai_bits:	16,
-	      ai_ranges:&dmm32at_airanges,
-	      ao_chans:4,
-	      ao_bits:	12,
-	      ao_ranges:&dmm32at_aoranges,
-	      have_dio:1,
-	      dio_chans:24,
+	.name = "dmm32at",
+	.ai_chans = 32,
+	.ai_bits = 16,
+	.ai_ranges = &dmm32at_airanges,
+	.ao_chans = 4,
+	.ao_bits = 12,
+	.ao_ranges = &dmm32at_aoranges,
+	.have_dio = 1,
+	.dio_chans = 24,
 		},
 };
 
@@ -261,10 +261,10 @@ struct dmm32at_private {
 static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int dmm32at_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dmm32at = {
-      driver_name:"dmm32at",
-      module:THIS_MODULE,
-      attach:dmm32at_attach,
-      detach:dmm32at_detach,
+	.driver_name = "dmm32at",
+	.module = THIS_MODULE,
+	.attach = dmm32at_attach,
+	.detach = dmm32at_detach,
 /* It is not necessary to implement the following members if you are
  * writing a driver for a ISA PnP or PCI card */
 /* Most drivers will support multiple types of boards by
@@ -283,9 +283,9 @@ static struct comedi_driver driver_dmm32at = {
  * the type of board in software.  ISA PnP, PCI, and PCMCIA
  * devices are such boards.
  */
-      board_name:&dmm32at_boards[0].name,
-      offset:sizeof(struct dmm32at_board),
-      num_names:sizeof(dmm32at_boards) / sizeof(struct dmm32at_board),
+	.board_name = &dmm32at_boards[0].name,
+	.offset = sizeof(struct dmm32at_board),
+	.num_names = sizeof(dmm32at_boards) / sizeof(struct dmm32at_board),
 };
 
 /* prototypes for driver functions below */

commit f7cbd7aad063b2a4b7aff6a743b2b00015ce3c3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:16 2009 -0400

    Staging: comedi: Add spaces after commas
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index de6a96708140..a8c0603d0d95 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -114,8 +114,8 @@ Configuration Options:
 #define DMM32AT_DIOC 0x0e
 #define DMM32AT_DIOCONF 0x0f
 
-#define dmm_inb(cdev,reg) inb((cdev->iobase)+reg)
-#define dmm_outb(cdev,reg,valu) outb(valu,(cdev->iobase)+reg)
+#define dmm_inb(cdev, reg) inb((cdev->iobase)+reg)
+#define dmm_outb(cdev, reg, valu) outb(valu, (cdev->iobase)+reg)
 
 /* Board register values. */
 

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index d627479ff71a..de6a96708140 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -258,8 +258,8 @@ struct dmm32at_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int dmm32at_detach(struct comedi_device * dev);
+static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dmm32at_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dmm32at = {
       driver_name:"dmm32at",
       module:THIS_MODULE,
@@ -313,7 +313,7 @@ void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int dmm32at_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -481,7 +481,7 @@ static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig *
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int dmm32at_detach(struct comedi_device * dev)
+static int dmm32at_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
@@ -497,8 +497,8 @@ static int dmm32at_detach(struct comedi_device * dev)
  * mode.
  */
 
-static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dmm32at_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int d;
@@ -568,8 +568,8 @@ static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice
 	return n;
 }
 
-static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int dmm32at_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -752,7 +752,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 	return 0;
 }
 
-static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, range;
@@ -822,7 +822,7 @@ static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 
 }
 
-static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dmm32at_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	devpriv->ai_scans_left = 1;
 	return 0;
@@ -893,8 +893,8 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 	return *ns;
 }
 
-static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dmm32at_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -936,8 +936,8 @@ static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dmm32at_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -953,8 +953,8 @@ static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dmm32at_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char diobits;
 
@@ -1006,8 +1006,8 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subde
 	return 2;
 }
 
-static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dmm32at_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1043,7 +1043,7 @@ static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_sub
 	return 1;
 }
 
-void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec)
+void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)
 {
 	unsigned char lo1, lo2, hi2;
 	unsigned short both2;

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 101c22f1d247..d627479ff71a 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -394,7 +394,7 @@ static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig *
  * it is, this is the place to do it.  Otherwise, dev->board_ptr
  * should already be initialized.
  */
-	//dev->board_ptr = dmm32at_probe(dev);
+	/* dev->board_ptr = dmm32at_probe(dev); */
 
 /*
  * Initialize dev->board_name.  Note that we can use the "thisboard"
@@ -512,7 +512,7 @@ static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice
 	chan = CR_CHAN(insn->chanspec) & (s->n_chan - 1);
 	range = CR_RANGE(insn->chanspec);
 
-	//printk("channel=0x%02x, range=%d\n",chan,range);
+	/* printk("channel=0x%02x, range=%d\n",chan,range); */
 
 	/* zero scan and fifo control and reset fifo */
 	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
@@ -575,7 +575,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 	int tmp;
 	int start_chan, gain, i;
 
-	//printk("dmmat32 in command test\n");
+	/* printk("dmmat32 in command test\n"); */
 
 	/* cmdtest tests a particular command to see if it is valid.
 	 * Using the cmdtest ioctl, a user can create a valid cmd
@@ -910,7 +910,7 @@ static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 		lo = data[i] & 0x00ff;
 		/* high byte also contains channel number */
 		hi = (data[i] >> 8) + chan * (1 << 6);
-		//printk("writing 0x%02x  0x%02x\n",hi,lo);
+		/* printk("writing 0x%02x  0x%02x\n",hi,lo); */
 		/* write the low and high values to the board */
 		dmm_outb(dev, DMM32AT_DACLSB, lo);
 		dmm_outb(dev, DMM32AT_DACMSB, hi);
@@ -967,7 +967,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subde
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
 		/* Write out the new digital output lines */
-		//outw(s->state,dev->iobase + DMM32AT_DIO);
+		/* outw(s->state,dev->iobase + DMM32AT_DIO); */
 	}
 
 	/* get access to the DIO regs */
@@ -998,10 +998,10 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subde
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	//data[1]=inw(dev->iobase + DMM32AT_DIO);
+	/* data[1]=inw(dev->iobase + DMM32AT_DIO); */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
-	//data[1]=s->state;
+	/* data[1]=s->state; */
 
 	return 2;
 }

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 829083651edc..101c22f1d247 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -304,7 +304,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
-static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG);
+static irqreturn_t dmm32at_isr(int irq, void *d);
 void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
 
 /*
@@ -828,7 +828,7 @@ static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG)
+static irqreturn_t dmm32at_isr(int irq, void *d)
 {
 	unsigned char intstat;
 	unsigned int samp;

commit 39d31e09a0cc299e01b8acb66b60fbcc453b9c8b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:14:14 2009 -0400

    Staging: comedi: Remove dmm32at_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 4245ad5eef99..829083651edc 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -234,7 +234,7 @@ static const struct dmm32at_board dmm32at_boards[] = {
  * several hardware drivers keep similar information in this structure,
  * feel free to suggest moving the variable to the struct comedi_device struct.
  */
-typedef struct {
+struct dmm32at_private {
 
 	int data;
 	int ai_inuse;
@@ -244,13 +244,13 @@ typedef struct {
 	unsigned int ao_readback[4];
 	unsigned char dio_config;
 
-} dmm32at_private;
+};
 
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
-#define devpriv ((dmm32at_private *)dev->private)
+#define devpriv ((struct dmm32at_private *)dev->private)
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -406,7 +406,7 @@ static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig *
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_private(dev, sizeof(dmm32at_private)) < 0)
+	if (alloc_private(dev, sizeof(struct dmm32at_private)) < 0)
 		return -ENOMEM;
 
 /*

commit 38baea3abba76b48ff599e1c5b7eccc80b2a7e3d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:14:09 2009 -0400

    Staging: comedi: Remove dmm32at_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 1b2c58f7eb3f..4245ad5eef99 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -200,7 +200,7 @@ static const struct comedi_lrange dmm32at_aoranges = {
  * boards in this way is optional, and completely driver-dependent.
  * Some drivers use arrays such as this, other do not.
  */
-typedef struct dmm32at_board_struct {
+struct dmm32at_board {
 	const char *name;
 	int ai_chans;
 	int ai_bits;
@@ -210,8 +210,8 @@ typedef struct dmm32at_board_struct {
 	const struct comedi_lrange *ao_ranges;
 	int have_dio;
 	int dio_chans;
-} dmm32at_board;
-static const dmm32at_board dmm32at_boards[] = {
+};
+static const struct dmm32at_board dmm32at_boards[] = {
 	{
 	      name:	"dmm32at",
 	      ai_chans:32,
@@ -228,7 +228,7 @@ static const dmm32at_board dmm32at_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const dmm32at_board *)dev->board_ptr)
+#define thisboard ((const struct dmm32at_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
  * several hardware drivers keep similar information in this structure,
@@ -284,8 +284,8 @@ static struct comedi_driver driver_dmm32at = {
  * devices are such boards.
  */
       board_name:&dmm32at_boards[0].name,
-      offset:sizeof(dmm32at_board),
-      num_names:sizeof(dmm32at_boards) / sizeof(dmm32at_board),
+      offset:sizeof(struct dmm32at_board),
+      num_names:sizeof(dmm32at_boards) / sizeof(struct dmm32at_board),
 };
 
 /* prototypes for driver functions below */

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 36e283ba753d..1b2c58f7eb3f 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -258,7 +258,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int dmm32at_detach(struct comedi_device * dev);
 static struct comedi_driver driver_dmm32at = {
       driver_name:"dmm32at",
@@ -313,7 +313,7 @@ void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int dmm32at_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int ret;
 	struct comedi_subdevice *s;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 42c6c0e9a857..36e283ba753d 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -290,15 +290,15 @@ static struct comedi_driver driver_dmm32at = {
 
 /* prototypes for driver functions below */
 static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
 static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -498,7 +498,7 @@ static int dmm32at_detach(struct comedi_device * dev)
  */
 
 static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	unsigned int d;
@@ -894,7 +894,7 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 }
 
 static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -937,7 +937,7 @@ static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -954,7 +954,7 @@ static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned char diobits;
 
@@ -1007,7 +1007,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subde
 }
 
 static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 17713b3934fe..42c6c0e9a857 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -300,7 +300,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subde
 static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
@@ -569,7 +569,7 @@ static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -754,7 +754,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 
 static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, range;
 	unsigned char chanlo, chanhi, status;
 
@@ -845,7 +845,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG)
 
 	if (intstat & DMM32AT_ADINT) {
 		struct comedi_subdevice *s = dev->read_subdev;
-		comedi_cmd *cmd = &s->async->cmd;
+		struct comedi_cmd *cmd = &s->async->cmd;
 
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			/* read data */

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 68c18fff5369..17713b3934fe 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -164,7 +164,7 @@ Configuration Options:
 #define DMM32AT_DIRCH 0x08
 
 /* board AI ranges in comedi structure */
-static const comedi_lrange dmm32at_airanges = {
+static const struct comedi_lrange dmm32at_airanges = {
 	4,
 	{
 			UNI_RANGE(10),
@@ -185,7 +185,7 @@ static const unsigned char dmm32at_rangebits[] = {
 /* only one of these ranges is valid, as set by a jumper on the
  * board. The application should only use the range set by the jumper
  */
-static const comedi_lrange dmm32at_aoranges = {
+static const struct comedi_lrange dmm32at_aoranges = {
 	4,
 	{
 			UNI_RANGE(10),
@@ -204,10 +204,10 @@ typedef struct dmm32at_board_struct {
 	const char *name;
 	int ai_chans;
 	int ai_bits;
-	const comedi_lrange *ai_ranges;
+	const struct comedi_lrange *ai_ranges;
 	int ao_chans;
 	int ao_bits;
-	const comedi_lrange *ao_ranges;
+	const struct comedi_lrange *ao_ranges;
 	int have_dio;
 	int dio_chans;
 } dmm32at_board;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index d710dd652053..68c18fff5369 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -46,7 +46,7 @@ Configuration Options:
  * Devices: a full list of the boards that attempt to be supported by
  *   the driver.  Format is "(manufacturer) board name [comedi name]",
  *   where comedi_name is the name that is used to configure the board.
- *   See the comment near board_name: in the comedi_driver structure
+ *   See the comment near board_name: in the struct comedi_driver structure
  *   below.  If (manufacturer) or [comedi name] is missing, the previous
  *   value is used.
  * Author: you
@@ -253,14 +253,14 @@ typedef struct {
 #define devpriv ((dmm32at_private *)dev->private)
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int dmm32at_detach(struct comedi_device * dev);
-static comedi_driver driver_dmm32at = {
+static struct comedi_driver driver_dmm32at = {
       driver_name:"dmm32at",
       module:THIS_MODULE,
       attach:dmm32at_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 678eb970a034..d710dd652053 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -289,20 +289,20 @@ static comedi_driver driver_dmm32at = {
 };
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int dmm32at_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int dmm32at_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
 static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG);
 void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
@@ -316,7 +316,7 @@ void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
 static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int ret;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
 	unsigned long iobase;
 	unsigned int irq;
@@ -497,7 +497,7 @@ static int dmm32at_detach(struct comedi_device * dev)
  * mode.
  */
 
-static int dmm32at_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -568,7 +568,7 @@ static int dmm32at_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int dmm32at_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -752,7 +752,7 @@ static int dmm32at_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int dmm32at_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int dmm32at_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int i, range;
@@ -822,7 +822,7 @@ static int dmm32at_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 
 }
 
-static int dmm32at_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int dmm32at_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	devpriv->ai_scans_left = 1;
 	return 0;
@@ -844,7 +844,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG)
 	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
 
 	if (intstat & DMM32AT_ADINT) {
-		comedi_subdevice *s = dev->read_subdev;
+		struct comedi_subdevice *s = dev->read_subdev;
 		comedi_cmd *cmd = &s->async->cmd;
 
 		for (i = 0; i < cmd->chanlist_len; i++) {
@@ -893,7 +893,7 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 	return *ns;
 }
 
-static int dmm32at_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -936,7 +936,7 @@ static int dmm32at_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int dmm32at_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -953,7 +953,7 @@ static int dmm32at_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int dmm32at_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char diobits;
@@ -1006,7 +1006,7 @@ static int dmm32at_dio_insn_bits(struct comedi_device * dev, comedi_subdevice *
 	return 2;
 }
 
-static int dmm32at_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char chanbit;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index c63af0c556b4..678eb970a034 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -232,7 +232,7 @@ static const dmm32at_board dmm32at_boards[] = {
 
 /* this structure is for data unique to this hardware driver.  If
  * several hardware drivers keep similar information in this structure,
- * feel free to suggest moving the variable to the comedi_device struct.
+ * feel free to suggest moving the variable to the struct comedi_device struct.
  */
 typedef struct {
 
@@ -258,8 +258,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dmm32at_attach(comedi_device * dev, comedi_devconfig * it);
-static int dmm32at_detach(comedi_device * dev);
+static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dmm32at_detach(struct comedi_device * dev);
 static comedi_driver driver_dmm32at = {
       driver_name:"dmm32at",
       module:THIS_MODULE,
@@ -289,23 +289,23 @@ static comedi_driver driver_dmm32at = {
 };
 
 /* prototypes for driver functions below */
-static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int dmm32at_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int dmm32at_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int dmm32at_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static int dmm32at_ns_to_timer(unsigned int *ns, int round);
 static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG);
-void dmm32at_setaitimer(comedi_device * dev, unsigned int nansec);
+void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -313,7 +313,7 @@ void dmm32at_setaitimer(comedi_device * dev, unsigned int nansec);
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dmm32at_attach(comedi_device * dev, comedi_devconfig * it)
+static int dmm32at_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int ret;
 	comedi_subdevice *s;
@@ -481,7 +481,7 @@ static int dmm32at_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int dmm32at_detach(comedi_device * dev)
+static int dmm32at_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: dmm32at: remove\n", dev->minor);
 	if (dev->irq)
@@ -497,7 +497,7 @@ static int dmm32at_detach(comedi_device * dev)
  * mode.
  */
 
-static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -568,7 +568,7 @@ static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -752,7 +752,7 @@ static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int dmm32at_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int i, range;
@@ -822,7 +822,7 @@ static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 }
 
-static int dmm32at_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int dmm32at_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	devpriv->ai_scans_left = 1;
 	return 0;
@@ -834,7 +834,7 @@ static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG)
 	unsigned int samp;
 	unsigned short msb, lsb;
 	int i;
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 
 	if (!dev->attached) {
 		comedi_error(dev, "spurious interrupt");
@@ -893,7 +893,7 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 	return *ns;
 }
 
-static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -936,7 +936,7 @@ static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -953,7 +953,7 @@ static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char diobits;
@@ -1006,7 +1006,7 @@ static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int dmm32at_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char chanbit;
@@ -1043,7 +1043,7 @@ static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-void dmm32at_setaitimer(comedi_device * dev, unsigned int nansec)
+void dmm32at_setaitimer(struct comedi_device * dev, unsigned int nansec)
 {
 	unsigned char lo1, lo2, hi2;
 	unsigned short both2;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 0605caf4e305..c63af0c556b4 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -241,7 +241,7 @@ typedef struct {
 	unsigned int ai_scans_left;
 
 	/* Used for AO readback */
-	lsampl_t ao_readback[4];
+	unsigned int ao_readback[4];
 	unsigned char dio_config;
 
 } dmm32at_private;
@@ -290,15 +290,15 @@ static comedi_driver driver_dmm32at = {
 
 /* prototypes for driver functions below */
 static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s);
@@ -498,7 +498,7 @@ static int dmm32at_detach(comedi_device * dev)
  */
 
 static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	unsigned int d;
@@ -894,7 +894,7 @@ static int dmm32at_ns_to_timer(unsigned int *ns, int round)
 }
 
 static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -937,7 +937,7 @@ static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -954,7 +954,7 @@ static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char diobits;
 
@@ -1007,7 +1007,7 @@ static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned char chanbit;
 	int chan = CR_CHAN(insn->chanspec);

commit 3c501880ac4436ad2db5feed6e7d7548e13d539f
Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
Date:   Thu Feb 19 09:11:30 2009 -0800

    Staging: comedi: add dmm32at driver
    
    Driver for Diamond Systems mm32at
    
    From: Perry J. Piplani <perry.j.piplani@nasa.gov>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
new file mode 100644
index 000000000000..0605caf4e305
--- /dev/null
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -0,0 +1,1081 @@
+/*
+    comedi/drivers/dmm32at.c
+    Diamond Systems mm32at code for a Comedi driver
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: dmm32at
+Description: Diamond Systems mm32at driver.
+Devices:
+Author: Perry J. Piplani <perry.j.piplani@nasa.gov>
+Updated: Fri Jun  4 09:13:24 CDT 2004
+Status: experimental
+
+This driver is for the Diamond Systems MM-32-AT board
+http://www.diamondsystems.com/products/diamondmm32at It is being used
+on serveral projects inside NASA, without problems so far. For analog
+input commands, TRIG_EXT is not yet supported at all..
+
+Configuration Options:
+  comedi_config /dev/comedi0 dmm32at baseaddr,irq
+*/
+
+/*
+ * The previous block comment is used to automatically generate
+ * documentation in Comedi and Comedilib.  The fields:
+ *
+ * Driver: the name of the driver
+ * Description: a short phrase describing the driver.  Don't list boards.
+ * Devices: a full list of the boards that attempt to be supported by
+ *   the driver.  Format is "(manufacturer) board name [comedi name]",
+ *   where comedi_name is the name that is used to configure the board.
+ *   See the comment near board_name: in the comedi_driver structure
+ *   below.  If (manufacturer) or [comedi name] is missing, the previous
+ *   value is used.
+ * Author: you
+ * Updated: date when the _documentation_ was last updated.  Use 'date -R'
+ *   to get a value for this.
+ * Status: a one-word description of the status.  Valid values are:
+ *   works - driver works correctly on most boards supported, and
+ *     passes comedi_test.
+ *   unknown - unknown.  Usually put there by ds.
+ *   experimental - may not work in any particular release.  Author
+ *     probably wants assistance testing it.
+ *   bitrotten - driver has not been update in a long time, probably
+ *     doesn't work, and probably is missing support for significant
+ *     Comedi interface features.
+ *   untested - author probably wrote it "blind", and is believed to
+ *     work, but no confirmation.
+ *
+ * These headers should be followed by a blank line, and any comments
+ * you wish to say about the driver.  The comment area is the place
+ * to put any known bugs, limitations, unsupported features, supported
+ * command triggers, whether or not commands are supported on particular
+ * subdevices, etc.
+ *
+ * Somewhere in the comment should be information about configuration
+ * options that are used with comedi_config.
+ */
+
+#include "../comedidev.h"
+#include <linux/ioport.h>
+
+/* Board register addresses */
+
+#define DMM32AT_MEMSIZE 0x10
+
+#define DMM32AT_CONV 0x00
+#define DMM32AT_AILSB 0x00
+#define DMM32AT_AUXDOUT 0x01
+#define DMM32AT_AIMSB 0x01
+#define DMM32AT_AILOW 0x02
+#define DMM32AT_AIHIGH 0x03
+
+#define DMM32AT_DACLSB 0x04
+#define DMM32AT_DACSTAT 0x04
+#define DMM32AT_DACMSB 0x05
+
+#define DMM32AT_FIFOCNTRL 0x07
+#define DMM32AT_FIFOSTAT 0x07
+
+#define DMM32AT_CNTRL 0x08
+#define DMM32AT_AISTAT 0x08
+
+#define DMM32AT_INTCLOCK 0x09
+
+#define DMM32AT_CNTRDIO 0x0a
+
+#define DMM32AT_AICONF 0x0b
+#define DMM32AT_AIRBACK 0x0b
+
+#define DMM32AT_CLK1 0x0d
+#define DMM32AT_CLK2 0x0e
+#define DMM32AT_CLKCT 0x0f
+
+#define DMM32AT_DIOA 0x0c
+#define DMM32AT_DIOB 0x0d
+#define DMM32AT_DIOC 0x0e
+#define DMM32AT_DIOCONF 0x0f
+
+#define dmm_inb(cdev,reg) inb((cdev->iobase)+reg)
+#define dmm_outb(cdev,reg,valu) outb(valu,(cdev->iobase)+reg)
+
+/* Board register values. */
+
+/* DMM32AT_DACSTAT 0x04 */
+#define DMM32AT_DACBUSY 0x80
+
+/* DMM32AT_FIFOCNTRL 0x07 */
+#define DMM32AT_FIFORESET 0x02
+#define DMM32AT_SCANENABLE 0x04
+
+/* DMM32AT_CNTRL 0x08 */
+#define DMM32AT_RESET 0x20
+#define DMM32AT_INTRESET 0x08
+#define DMM32AT_CLKACC 0x00
+#define DMM32AT_DIOACC 0x01
+
+/* DMM32AT_AISTAT 0x08 */
+#define DMM32AT_STATUS 0x80
+
+/* DMM32AT_INTCLOCK 0x09 */
+#define DMM32AT_ADINT 0x80
+#define DMM32AT_CLKSEL 0x03
+
+/* DMM32AT_CNTRDIO 0x0a */
+#define DMM32AT_FREQ12 0x80
+
+/* DMM32AT_AICONF 0x0b */
+#define DMM32AT_RANGE_U10 0x0c
+#define DMM32AT_RANGE_U5 0x0d
+#define DMM32AT_RANGE_B10 0x08
+#define DMM32AT_RANGE_B5 0x00
+#define DMM32AT_SCINT_20 0x00
+#define DMM32AT_SCINT_15 0x10
+#define DMM32AT_SCINT_10 0x20
+#define DMM32AT_SCINT_5 0x30
+
+/* DMM32AT_CLKCT 0x0f */
+#define DMM32AT_CLKCT1 0x56	/* mode3 counter 1 - write low byte only */
+#define DMM32AT_CLKCT2 0xb6	/*  mode3 counter 2 - write high and low byte */
+
+/* DMM32AT_DIOCONF 0x0f */
+#define DMM32AT_DIENABLE 0x80
+#define DMM32AT_DIRA 0x10
+#define DMM32AT_DIRB 0x02
+#define DMM32AT_DIRCL 0x01
+#define DMM32AT_DIRCH 0x08
+
+/* board AI ranges in comedi structure */
+static const comedi_lrange dmm32at_airanges = {
+	4,
+	{
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+		}
+};
+
+/* register values for above ranges */
+static const unsigned char dmm32at_rangebits[] = {
+	DMM32AT_RANGE_U10,
+	DMM32AT_RANGE_U5,
+	DMM32AT_RANGE_B10,
+	DMM32AT_RANGE_B5,
+};
+
+/* only one of these ranges is valid, as set by a jumper on the
+ * board. The application should only use the range set by the jumper
+ */
+static const comedi_lrange dmm32at_aoranges = {
+	4,
+	{
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+		}
+};
+
+/*
+ * Board descriptions for two imaginary boards.  Describing the
+ * boards in this way is optional, and completely driver-dependent.
+ * Some drivers use arrays such as this, other do not.
+ */
+typedef struct dmm32at_board_struct {
+	const char *name;
+	int ai_chans;
+	int ai_bits;
+	const comedi_lrange *ai_ranges;
+	int ao_chans;
+	int ao_bits;
+	const comedi_lrange *ao_ranges;
+	int have_dio;
+	int dio_chans;
+} dmm32at_board;
+static const dmm32at_board dmm32at_boards[] = {
+	{
+	      name:	"dmm32at",
+	      ai_chans:32,
+	      ai_bits:	16,
+	      ai_ranges:&dmm32at_airanges,
+	      ao_chans:4,
+	      ao_bits:	12,
+	      ao_ranges:&dmm32at_aoranges,
+	      have_dio:1,
+	      dio_chans:24,
+		},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const dmm32at_board *)dev->board_ptr)
+
+/* this structure is for data unique to this hardware driver.  If
+ * several hardware drivers keep similar information in this structure,
+ * feel free to suggest moving the variable to the comedi_device struct.
+ */
+typedef struct {
+
+	int data;
+	int ai_inuse;
+	unsigned int ai_scans_left;
+
+	/* Used for AO readback */
+	lsampl_t ao_readback[4];
+	unsigned char dio_config;
+
+} dmm32at_private;
+
+/*
+ * most drivers define the following macro to make it easy to
+ * access the private structure.
+ */
+#define devpriv ((dmm32at_private *)dev->private)
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int dmm32at_attach(comedi_device * dev, comedi_devconfig * it);
+static int dmm32at_detach(comedi_device * dev);
+static comedi_driver driver_dmm32at = {
+      driver_name:"dmm32at",
+      module:THIS_MODULE,
+      attach:dmm32at_attach,
+      detach:dmm32at_detach,
+/* It is not necessary to implement the following members if you are
+ * writing a driver for a ISA PnP or PCI card */
+/* Most drivers will support multiple types of boards by
+ * having an array of board structures.  These were defined
+ * in dmm32at_boards[] above.  Note that the element 'name'
+ * was first in the structure -- Comedi uses this fact to
+ * extract the name of the board without knowing any details
+ * about the structure except for its length.
+ * When a device is attached (by comedi_config), the name
+ * of the device is given to Comedi, and Comedi tries to
+ * match it by going through the list of board names.  If
+ * there is a match, the address of the pointer is put
+ * into dev->board_ptr and driver->attach() is called.
+ *
+ * Note that these are not necessary if you can determine
+ * the type of board in software.  ISA PnP, PCI, and PCMCIA
+ * devices are such boards.
+ */
+      board_name:&dmm32at_boards[0].name,
+      offset:sizeof(dmm32at_board),
+      num_names:sizeof(dmm32at_boards) / sizeof(dmm32at_board),
+};
+
+/* prototypes for driver functions below */
+static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int dmm32at_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int dmm32at_ns_to_timer(unsigned int *ns, int round);
+static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG);
+void dmm32at_setaitimer(comedi_device * dev, unsigned int nansec);
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int dmm32at_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	comedi_subdevice *s;
+	unsigned char aihi, ailo, fifostat, aistat, intstat, airback;
+	unsigned long iobase;
+	unsigned int irq;
+
+	iobase = it->options[0];
+	irq = it->options[1];
+
+	printk("comedi%d: dmm32at: attaching\n", dev->minor);
+	printk("dmm32at: probing at address 0x%04lx, irq %u\n", iobase, irq);
+
+	/* register address space */
+	if (!request_region(iobase, DMM32AT_MEMSIZE, thisboard->name)) {
+		printk("I/O port conflict\n");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	/* the following just makes sure the board is there and gets
+	   it to a known state */
+
+	/* reset the board */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_RESET);
+
+	/* allow a millisecond to reset */
+	udelay(1000);
+
+	/* zero scan and fifo control */
+	dmm_outb(dev, DMM32AT_FIFOCNTRL, 0x0);
+
+	/* zero interrupt and clock control */
+	dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
+
+	/* write a test channel range, the high 3 bits should drop */
+	dmm_outb(dev, DMM32AT_AILOW, 0x80);
+	dmm_outb(dev, DMM32AT_AIHIGH, 0xff);
+
+	/* set the range at 10v unipolar */
+	dmm_outb(dev, DMM32AT_AICONF, DMM32AT_RANGE_U10);
+
+	/* should take 10 us to settle, here's a hundred */
+	udelay(100);
+
+	/* read back the values */
+	ailo = dmm_inb(dev, DMM32AT_AILOW);
+	aihi = dmm_inb(dev, DMM32AT_AIHIGH);
+	fifostat = dmm_inb(dev, DMM32AT_FIFOSTAT);
+	aistat = dmm_inb(dev, DMM32AT_AISTAT);
+	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
+	airback = dmm_inb(dev, DMM32AT_AIRBACK);
+
+	printk("dmm32at: lo=0x%02x hi=0x%02x fifostat=0x%02x\n",
+		ailo, aihi, fifostat);
+	printk("dmm32at: aistat=0x%02x intstat=0x%02x airback=0x%02x\n",
+		aistat, intstat, airback);
+
+	if ((ailo != 0x00) || (aihi != 0x1f) || (fifostat != 0x80) ||
+		(aistat != 0x60 || (intstat != 0x00) || airback != 0x0c)) {
+		printk("dmmat32: board detection failed\n");
+		return -EIO;
+	}
+
+	/* board is there, register interrupt */
+	if (irq) {
+		ret = comedi_request_irq(irq, dmm32at_isr, 0, thisboard->name,
+			dev);
+		if (ret < 0) {
+			printk("irq conflict\n");
+			return ret;
+		}
+		dev->irq = irq;
+	}
+
+/*
+ * If you can probe the device to determine what device in a series
+ * it is, this is the place to do it.  Otherwise, dev->board_ptr
+ * should already be initialized.
+ */
+	//dev->board_ptr = dmm32at_probe(dev);
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(dmm32at_private)) < 0)
+		return -ENOMEM;
+
+/*
+ * Allocate the subdevice structures.  alloc_subdevice() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_subdevices(dev, 3) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	/* we support single-ended (ground) and differential */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	s->n_chan = thisboard->ai_chans;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ai_ranges;
+	s->len_chanlist = 32;	/* This is the maximum chanlist length that
+				   the board can handle */
+	s->insn_read = dmm32at_ai_rinsn;
+	s->do_cmd = dmm32at_ai_cmd;
+	s->do_cmdtest = dmm32at_ai_cmdtest;
+	s->cancel = dmm32at_ai_cancel;
+
+	s = dev->subdevices + 1;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = thisboard->ao_chans;
+	s->maxdata = (1 << thisboard->ao_bits) - 1;
+	s->range_table = thisboard->ao_ranges;
+	s->insn_write = dmm32at_ao_winsn;
+	s->insn_read = dmm32at_ao_rinsn;
+
+	s = dev->subdevices + 2;
+	/* digital i/o subdevice */
+	if (thisboard->have_dio) {
+
+		/* get access to the DIO regs */
+		dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+		/* set the DIO's to the defualt input setting */
+		devpriv->dio_config = DMM32AT_DIRA | DMM32AT_DIRB |
+			DMM32AT_DIRCL | DMM32AT_DIRCH | DMM32AT_DIENABLE;
+		dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
+
+		/* set up the subdevice */
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->n_chan = thisboard->dio_chans;
+		s->maxdata = 1;
+		s->state = 0;
+		s->range_table = &range_digital;
+		s->insn_bits = dmm32at_dio_insn_bits;
+		s->insn_config = dmm32at_dio_insn_config;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* success */
+	printk("comedi%d: dmm32at: attached\n", dev->minor);
+
+	return 1;
+
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int dmm32at_detach(comedi_device * dev)
+{
+	printk("comedi%d: dmm32at: remove\n", dev->minor);
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (dev->iobase)
+		release_region(dev->iobase, DMM32AT_MEMSIZE);
+
+	return 0;
+}
+
+/*
+ * "instructions" read/write data in "one-shot" or "software-triggered"
+ * mode.
+ */
+
+static int dmm32at_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, i;
+	unsigned int d;
+	unsigned char status;
+	unsigned short msb, lsb;
+	unsigned char chan;
+	int range;
+
+	/* get the channel and range number */
+
+	chan = CR_CHAN(insn->chanspec) & (s->n_chan - 1);
+	range = CR_RANGE(insn->chanspec);
+
+	//printk("channel=0x%02x, range=%d\n",chan,range);
+
+	/* zero scan and fifo control and reset fifo */
+	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
+
+	/* write the ai channel range regs */
+	dmm_outb(dev, DMM32AT_AILOW, chan);
+	dmm_outb(dev, DMM32AT_AIHIGH, chan);
+	/* set the range bits */
+	dmm_outb(dev, DMM32AT_AICONF, dmm32at_rangebits[range]);
+
+	/* wait for circuit to settle */
+	for (i = 0; i < 40000; i++) {
+		status = dmm_inb(dev, DMM32AT_AIRBACK);
+		if ((status & DMM32AT_STATUS) == 0)
+			break;
+	}
+	if (i == 40000) {
+		printk("timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	/* convert n samples */
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		dmm_outb(dev, DMM32AT_CONV, 0xff);
+		/* wait for conversion to end */
+		for (i = 0; i < 40000; i++) {
+			status = dmm_inb(dev, DMM32AT_AISTAT);
+			if ((status & DMM32AT_STATUS) == 0)
+				break;
+		}
+		if (i == 40000) {
+			printk("timeout\n");
+			return -ETIMEDOUT;
+		}
+
+		/* read data */
+		lsb = dmm_inb(dev, DMM32AT_AILSB);
+		msb = dmm_inb(dev, DMM32AT_AIMSB);
+
+		/* invert sign bit to make range unsigned, this is an
+		   idiosyncracy of the diamond board, it return
+		   conversions as a signed value, i.e. -32768 to
+		   32767, flipping the bit and interpreting it as
+		   signed gives you a range of 0 to 65535 which is
+		   used by comedi */
+		d = ((msb ^ 0x0080) << 8) + lsb;
+
+		data[n] = d;
+	}
+
+	/* return the number of samples read/written */
+	return n;
+}
+
+static int dmm32at_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int start_chan, gain, i;
+
+	//printk("dmmat32 in command test\n");
+
+	/* cmdtest tests a particular command to see if it is valid.
+	 * Using the cmdtest ioctl, a user can create a valid cmd
+	 * and then have it executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
+	 * the command passes. */
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER /*| TRIG_EXT */ ;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER /*| TRIG_EXT */ ;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+#define MAX_SCAN_SPEED	1000000	/* in nanoseconds */
+#define MIN_SCAN_SPEED	1000000000	/* in nanoseconds */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < MAX_SCAN_SPEED) {
+			cmd->scan_begin_arg = MAX_SCAN_SPEED;
+			err++;
+		}
+		if (cmd->scan_begin_arg > MIN_SCAN_SPEED) {
+			cmd->scan_begin_arg = MIN_SCAN_SPEED;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* should be level/edge, hi/lo specification here */
+		/* should specify multiple external triggers */
+		if (cmd->scan_begin_arg > 9) {
+			cmd->scan_begin_arg = 9;
+			err++;
+		}
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg >= 17500)
+			cmd->convert_arg = 20000;
+		else if (cmd->convert_arg >= 12500)
+			cmd->convert_arg = 15000;
+		else if (cmd->convert_arg >= 7500)
+			cmd->convert_arg = 10000;
+		else
+			cmd->convert_arg = 5000;
+
+	} else {
+		/* external trigger */
+		/* see above */
+		if (cmd->convert_arg > 9) {
+			cmd->convert_arg = 9;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (cmd->stop_arg > 0xfffffff0) {
+			cmd->stop_arg = 0xfffffff0;
+			err++;
+		}
+		if (cmd->stop_arg == 0) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		dmm32at_ns_to_timer(&cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		dmm32at_ns_to_timer(&cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+		if (cmd->scan_begin_src == TRIG_TIMER &&
+			cmd->scan_begin_arg <
+			cmd->convert_arg * cmd->scan_end_arg) {
+			cmd->scan_begin_arg =
+				cmd->convert_arg * cmd->scan_end_arg;
+			err++;
+		}
+	}
+
+	if (err)
+		return 4;
+
+	/* step 5 check the channel list, the channel list for this
+	   board must be consecutive and gains must be the same */
+
+	if (cmd->chanlist) {
+		gain = CR_RANGE(cmd->chanlist[0]);
+		start_chan = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) !=
+				(start_chan + i) % s->n_chan) {
+				comedi_error(dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
+				err++;
+			}
+			if (CR_RANGE(cmd->chanlist[i]) != gain) {
+				comedi_error(dev,
+					"entries in chanlist must all have the same gain\n");
+				err++;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int dmm32at_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int i, range;
+	unsigned char chanlo, chanhi, status;
+
+	if (!cmd->chanlist)
+		return -EINVAL;
+
+	/* get the channel list and range */
+	chanlo = CR_CHAN(cmd->chanlist[0]) & (s->n_chan - 1);
+	chanhi = chanlo + cmd->chanlist_len - 1;
+	if (chanhi >= s->n_chan)
+		return -EINVAL;
+	range = CR_RANGE(cmd->chanlist[0]);
+
+	/* reset fifo */
+	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_FIFORESET);
+
+	/* set scan enable */
+	dmm_outb(dev, DMM32AT_FIFOCNTRL, DMM32AT_SCANENABLE);
+
+	/* write the ai channel range regs */
+	dmm_outb(dev, DMM32AT_AILOW, chanlo);
+	dmm_outb(dev, DMM32AT_AIHIGH, chanhi);
+
+	/* set the range bits */
+	dmm_outb(dev, DMM32AT_AICONF, dmm32at_rangebits[range]);
+
+	/* reset the interrupt just in case */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_INTRESET);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->ai_scans_left = cmd->stop_arg;
+	else {			/* TRIG_NONE */
+		devpriv->ai_scans_left = 0xffffffff;	/* indicates TRIG_NONE to isr */
+	}
+
+	/* wait for circuit to settle */
+	for (i = 0; i < 40000; i++) {
+		status = dmm_inb(dev, DMM32AT_AIRBACK);
+		if ((status & DMM32AT_STATUS) == 0)
+			break;
+	}
+	if (i == 40000) {
+		printk("timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	if (devpriv->ai_scans_left > 1) {
+		/* start the clock and enable the interrupts */
+		dmm32at_setaitimer(dev, cmd->scan_begin_arg);
+	} else {
+		/* start the interrups and initiate a single scan */
+		dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT);
+		dmm_outb(dev, DMM32AT_CONV, 0xff);
+	}
+
+/* 	printk("dmmat32 in command\n"); */
+
+/* 	for(i=0;i<cmd->chanlist_len;i++) */
+/* 		comedi_buf_put(s->async,i*100); */
+
+/* 	s->async->events |= COMEDI_CB_EOA; */
+/* 	comedi_event(dev, s); */
+
+	return 0;
+
+}
+
+static int dmm32at_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	devpriv->ai_scans_left = 1;
+	return 0;
+}
+
+static irqreturn_t dmm32at_isr(int irq, void *d PT_REGS_ARG)
+{
+	unsigned char intstat;
+	unsigned int samp;
+	unsigned short msb, lsb;
+	int i;
+	comedi_device *dev = d;
+
+	if (!dev->attached) {
+		comedi_error(dev, "spurious interrupt");
+		return IRQ_HANDLED;
+	}
+
+	intstat = dmm_inb(dev, DMM32AT_INTCLOCK);
+
+	if (intstat & DMM32AT_ADINT) {
+		comedi_subdevice *s = dev->read_subdev;
+		comedi_cmd *cmd = &s->async->cmd;
+
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			/* read data */
+			lsb = dmm_inb(dev, DMM32AT_AILSB);
+			msb = dmm_inb(dev, DMM32AT_AIMSB);
+
+			/* invert sign bit to make range unsigned */
+			samp = ((msb ^ 0x0080) << 8) + lsb;
+			comedi_buf_put(s->async, samp);
+		}
+
+		if (devpriv->ai_scans_left != 0xffffffff) {	/* TRIG_COUNT */
+			devpriv->ai_scans_left--;
+			if (devpriv->ai_scans_left == 0) {
+				/* disable further interrupts and clocks */
+				dmm_outb(dev, DMM32AT_INTCLOCK, 0x0);
+				/* set the buffer to be flushed with an EOF */
+				s->async->events |= COMEDI_CB_EOA;
+			}
+
+		}
+		/* flush the buffer */
+		comedi_event(dev, s);
+	}
+
+	/* reset the interrupt */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_INTRESET);
+	return IRQ_HANDLED;
+}
+
+/* This function doesn't require a particular form, this is just
+ * what happens to be used in some of the drivers.  It should
+ * convert ns nanoseconds to a counter value suitable for programming
+ * the device.  Also, it should adjust ns so that it cooresponds to
+ * the actual time that the device will use. */
+static int dmm32at_ns_to_timer(unsigned int *ns, int round)
+{
+	/* trivial timer */
+	/* if your timing is done through two cascaded timers, the
+	 * i8253_cascade_ns_to_timer() function in 8253.h can be
+	 * very helpful.  There are also i8254_load() and i8254_mm_load()
+	 * which can be used to load values into the ubiquitous 8254 counters
+	 */
+
+	return *ns;
+}
+
+static int dmm32at_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+	unsigned char hi, lo, status;
+
+	/* Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined. */
+	for (i = 0; i < insn->n; i++) {
+
+		devpriv->ao_readback[chan] = data[i];
+
+		/* get the low byte */
+		lo = data[i] & 0x00ff;
+		/* high byte also contains channel number */
+		hi = (data[i] >> 8) + chan * (1 << 6);
+		//printk("writing 0x%02x  0x%02x\n",hi,lo);
+		/* write the low and high values to the board */
+		dmm_outb(dev, DMM32AT_DACLSB, lo);
+		dmm_outb(dev, DMM32AT_DACMSB, hi);
+
+		/* wait for circuit to settle */
+		for (i = 0; i < 40000; i++) {
+			status = dmm_inb(dev, DMM32AT_DACSTAT);
+			if ((status & DMM32AT_DACBUSY) == 0)
+				break;
+		}
+		if (i == 40000) {
+			printk("timeout\n");
+			return -ETIMEDOUT;
+		}
+		/* dummy read to update trigger the output */
+		status = dmm_inb(dev, DMM32AT_DACMSB);
+
+	}
+
+	/* return the number of samples read/written */
+	return i;
+}
+
+/* AO subdevices should have a read insn as well as a write insn.
+ * Usually this means copying a value stored in devpriv. */
+static int dmm32at_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
+
+	return i;
+}
+
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The
+ * comedi core can convert between insn_bits and insn_read/write */
+static int dmm32at_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned char diobits;
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= data[0] & data[1];
+		/* Write out the new digital output lines */
+		//outw(s->state,dev->iobase + DMM32AT_DIO);
+	}
+
+	/* get access to the DIO regs */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+
+	/* if either part of dio is set for output */
+	if (((devpriv->dio_config & DMM32AT_DIRCL) == 0) ||
+		((devpriv->dio_config & DMM32AT_DIRCH) == 0)) {
+		diobits = (s->state & 0x00ff0000) >> 16;
+		dmm_outb(dev, DMM32AT_DIOC, diobits);
+	}
+	if ((devpriv->dio_config & DMM32AT_DIRB) == 0) {
+		diobits = (s->state & 0x0000ff00) >> 8;
+		dmm_outb(dev, DMM32AT_DIOB, diobits);
+	}
+	if ((devpriv->dio_config & DMM32AT_DIRA) == 0) {
+		diobits = (s->state & 0x000000ff);
+		dmm_outb(dev, DMM32AT_DIOA, diobits);
+	}
+
+	/* now read the state back in */
+	s->state = dmm_inb(dev, DMM32AT_DIOC);
+	s->state <<= 8;
+	s->state |= dmm_inb(dev, DMM32AT_DIOB);
+	s->state <<= 8;
+	s->state |= dmm_inb(dev, DMM32AT_DIOA);
+	data[1] = s->state;
+
+	/* on return, data[1] contains the value of the digital
+	 * input and output lines. */
+	//data[1]=inw(dev->iobase + DMM32AT_DIO);
+	/* or we could just return the software copy of the output values if
+	 * it was a purely digital output subdevice */
+	//data[1]=s->state;
+
+	return 2;
+}
+
+static int dmm32at_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned char chanbit;
+	int chan = CR_CHAN(insn->chanspec);
+
+	if (insn->n != 1)
+		return -EINVAL;
+
+	if (chan < 8)
+		chanbit = DMM32AT_DIRA;
+	else if (chan < 16)
+		chanbit = DMM32AT_DIRB;
+	else if (chan < 20)
+		chanbit = DMM32AT_DIRCL;
+	else
+		chanbit = DMM32AT_DIRCH;
+
+	/* The input or output configuration of each digital line is
+	 * configured by a special insn_config instruction.  chanspec
+	 * contains the channel to be changed, and data[0] contains the
+	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+
+	/* if output clear the bit, otherwise set it */
+	if (data[0] == COMEDI_OUTPUT) {
+		devpriv->dio_config &= ~chanbit;
+	} else {
+		devpriv->dio_config |= chanbit;
+	}
+	/* get access to the DIO regs */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_DIOACC);
+	/* set the DIO's to the new configuration setting */
+	dmm_outb(dev, DMM32AT_DIOCONF, devpriv->dio_config);
+
+	return 1;
+}
+
+void dmm32at_setaitimer(comedi_device * dev, unsigned int nansec)
+{
+	unsigned char lo1, lo2, hi2;
+	unsigned short both2;
+
+	/* based on 10mhz clock */
+	lo1 = 200;
+	both2 = nansec / 20000;
+	hi2 = (both2 & 0xff00) >> 8;
+	lo2 = both2 & 0x00ff;
+
+	/* set the counter frequency to 10mhz */
+	dmm_outb(dev, DMM32AT_CNTRDIO, 0);
+
+	/* get access to the clock regs */
+	dmm_outb(dev, DMM32AT_CNTRL, DMM32AT_CLKACC);
+
+	/* write the counter 1 control word and low byte to counter */
+	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT1);
+	dmm_outb(dev, DMM32AT_CLK1, lo1);
+
+	/* write the counter 2 control word and low byte then to counter */
+	dmm_outb(dev, DMM32AT_CLKCT, DMM32AT_CLKCT2);
+	dmm_outb(dev, DMM32AT_CLK2, lo2);
+	dmm_outb(dev, DMM32AT_CLK2, hi2);
+
+	/* enable the ai conversion interrupt and the clock to start scans */
+	dmm_outb(dev, DMM32AT_INTCLOCK, DMM32AT_ADINT | DMM32AT_CLKSEL);
+
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver_dmm32at);
