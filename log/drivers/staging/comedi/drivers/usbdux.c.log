commit 7c23143199e3bae4f1ad8ad38370fc8cf1b3d5c9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jun 17 14:03:58 2019 +0100

    staging: comedi: usbdux: remove redundant initialization of fx2delay
    
    Variable fx2delay is being initialized to a value that is never read
    and is being re-assigned a few statements later. The initialization
    is redundant and can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index b8f54b7fb34a..0350f303d557 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1226,7 +1226,7 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 			     unsigned int period)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int fx2delay = 255;
+	int fx2delay;
 
 	if (period < MIN_PWM_PERIOD)
 		return -EAGAIN;

commit 3c03c470f476957d318ea49b7eeb9bcf3cb8b1e9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 16:44:25 2019 +0100

    staging: comedi: usbdux: Call mutex_destroy() on private mutex
    
    `usbdux_detach()` is the Comedi "detach" handler for the usbdux driver.
    When it is called, the private data for the device is about to be freed.
    The private date contains a mutex `devpriv->mut` that was initialized
    when the private data was allocated.  Call `mutex_destroy()` to mark it
    as invalid.
    
    The calls to `mutex_lock()` and `mutex_unlock()` are probably not
    required, especially as the mutex is about to be destroyed, but leave
    them alone for now.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index de177418190f..b8f54b7fb34a 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1691,6 +1691,8 @@ static void usbdux_detach(struct comedi_device *dev)
 	usbdux_free_usb_buffers(dev);
 
 	mutex_unlock(&devpriv->mut);
+
+	mutex_destroy(&devpriv->mut);
 }
 
 static struct comedi_driver usbdux_driver = {

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0640d82933c2..de177418190f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2,16 +2,6 @@
 /*
  * usbdux.c
  * Copyright (C) 2003-2014 Bernd Porr, mail@berndporr.me.uk
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
-
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ede064b47aac..0640d82933c2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * usbdux.c
  * Copyright (C) 2003-2014 Bernd Porr, mail@berndporr.me.uk

commit bc4eec76e66ec5c53b93f9ee0b0a1689f7307ce5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Nov 7 19:07:24 2017 +0000

    staging: comedi: usbdux: remove redundant initialization of val
    
    The early initialization of val is redundant as the value is never
    read and is updated inside a for-loop. Remove the initialization
    and move the declaration and initialization to the for-loop scope.
    Cleans up clang warning:
    
    drivers/staging/comedi/drivers/usbdux.c:812:15: warning: Value stored
    to 'val' during its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index f4f05d29d30d..ede064b47aac 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -809,7 +809,6 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 {
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val = s->readback[chan];
 	__le16 *p = (__le16 *)&devpriv->dux_commands[2];
 	int ret = -EBUSY;
 	int i;
@@ -825,7 +824,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	devpriv->dux_commands[4] = chan << 6;
 
 	for (i = 0; i < insn->n; i++) {
-		val = data[i];
+		unsigned int val = data[i];
 
 		/* one 16 bit value */
 		*p = cpu_to_le16(val);

commit 1e5cae2f0b3460bf68ebe948bb5caa31c0281c6c
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Oct 2 22:05:57 2015 +0200

    Staging: comedi: Use mutex instead of semaphore in usbdux.c
    
    Replace binary semaphore with mutex because mutex gives better
    performance.
    This change is safe because the thread that decrements the value of semaphore
    is also the one that increments it, and acts like a mutex where owner of the
    lock is the only one that can release the lock.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 39710f2297a6..f4f05d29d30d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -210,7 +210,7 @@ struct usbdux_private {
 	unsigned int ai_interval;
 	/* commands */
 	u8 *dux_commands;
-	struct semaphore sem;
+	struct mutex mut;
 };
 
 static void usbdux_unlink_urbs(struct urb **urbs, int num_urbs)
@@ -237,10 +237,10 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 
 	/* prevent other CPUs from submitting new commands just now */
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	/* unlink only if the urb really has been submitted */
 	usbdux_ai_stop(dev, devpriv->ai_cmd_running);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -365,10 +365,10 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 
 	/* prevent other CPUs from submitting a command just now */
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	/* unlink only if it is really running */
 	usbdux_ao_stop(dev, devpriv->ao_cmd_running);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -646,7 +646,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
@@ -662,7 +662,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 	}
 
 ai_trig_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 	return ret;
 }
 
@@ -675,7 +675,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int i;
 
 	/* block other CPUs from starting an ai_cmd */
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->ai_cmd_running)
 		goto ai_cmd_exit;
@@ -736,7 +736,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 ai_cmd_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -754,7 +754,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	int ret = -EBUSY;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->ai_cmd_running)
 		goto ai_read_exit;
@@ -782,7 +782,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	}
 
 ai_read_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret ? ret : insn->n;
 }
@@ -795,9 +795,9 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	ret = comedi_readback_insn_read(dev, s, insn, data);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -814,7 +814,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	int ret = -EBUSY;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->ao_cmd_running)
 		goto ao_write_exit;
@@ -838,7 +838,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	}
 
 ao_write_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret ? ret : insn->n;
 }
@@ -854,7 +854,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (!devpriv->ao_cmd_running) {
 		devpriv->ao_cmd_running = 1;
@@ -870,7 +870,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 	}
 
 ao_trig_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 	return ret;
 }
 
@@ -960,7 +960,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret = -EBUSY;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->ao_cmd_running)
 		goto ao_cmd_exit;
@@ -1002,7 +1002,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 ao_cmd_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -1033,7 +1033,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	comedi_dio_update_state(s, data);
 
@@ -1055,7 +1055,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	data[1] = le16_to_cpu(devpriv->insn_buf[1]);
 
 dio_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret ? ret : insn->n;
 }
@@ -1070,7 +1070,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 	int ret = 0;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	for (i = 0; i < insn->n; i++) {
 		ret = send_dux_commands(dev, USBDUX_CMD_TIMER_RD);
@@ -1084,7 +1084,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 	}
 
 counter_read_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret ? ret : insn->n;
 }
@@ -1100,7 +1100,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 	int ret = 0;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	devpriv->dux_commands[1] = chan;
 
@@ -1112,7 +1112,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 			break;
 	}
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret ? ret : insn->n;
 }
@@ -1148,11 +1148,11 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	/* unlink only if it is really running */
 	usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
 	ret = send_dux_commands(dev, USBDUX_CMD_PWM_OFF);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -1257,7 +1257,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	int ret = 0;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->pwm_cmd_running)
 		goto pwm_start_exit;
@@ -1276,7 +1276,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 		devpriv->pwm_cmd_running = 0;
 
 pwm_start_exit:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -1576,7 +1576,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	if (!devpriv)
 		return -ENOMEM;
 
-	sema_init(&devpriv->sem, 1);
+	mutex_init(&devpriv->mut);
 
 	usb_set_intfdata(intf, devpriv);
 
@@ -1691,7 +1691,7 @@ static void usbdux_detach(struct comedi_device *dev)
 	if (!devpriv)
 		return;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	/* force unlink all urbs */
 	usbdux_pwm_stop(dev, 1);
@@ -1700,7 +1700,7 @@ static void usbdux_detach(struct comedi_device *dev)
 
 	usbdux_free_usb_buffers(dev);
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 }
 
 static struct comedi_driver usbdux_driver = {

commit 6e2ebdf8720306d9aee47de4e050b41884de7e3d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:31 2015 -0700

    staging: comedi: usbdux: use comedi_offset_munge()
    
    Use the comedi_offset_munge() helper to convert the hardware two's
    complement values to the offset binary format expected by comedi.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index eea41e8ad1ac..39710f2297a6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -266,7 +266,7 @@ static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
 
 			/* bipolar data is two's-complement */
 			if (comedi_range_is_bipolar(s, range))
-				val ^= ((s->maxdata + 1) >> 1);
+				val = comedi_offset_munge(s, val);
 
 			/* transfer data */
 			if (!comedi_buf_write_samples(s, &val, 1))
@@ -776,7 +776,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 
 		/* bipolar data is two's-complement */
 		if (comedi_range_is_bipolar(s, range))
-			val ^= ((s->maxdata + 1) >> 1);
+			val = comedi_offset_munge(s, val);
 
 		data[i] = val;
 	}

commit 2779b7e51497b5d0855dc7d21d793998acd2ad5f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:30 2015 -0700

    staging: comedi: usbdux: remove impossible 'if (!devpriv)' check
    
    The comedi core can only call this subdevice function is the private
    data was successfully allocated during the (*auto_attach). Remove
    the unnecessary check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d576af734407..eea41e8ad1ac 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -877,13 +877,9 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct usbdux_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int flags;
 
-	if (!devpriv)
-		return -EFAULT;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);

commit 1e4c3a2e7da0f7e40f79ba1e219ccbe1d8a79f56
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:29 2015 -0700

    staging: comedi: usbdux: rename dev->private local variables
    
    For aesthetics, consistently use the same name. 'devpriv', for the
    local variable used to reference the private data, 'dev->private'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index be4c2db21cc8..d576af734407 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -516,7 +516,7 @@ static int usbdux_submit_urbs(struct comedi_device *dev,
 static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -552,7 +552,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 		unsigned int arg = 1000000;
 		unsigned int min_arg = arg;
 
-		if (this_usbduxsub->high_speed) {
+		if (devpriv->high_speed) {
 			/*
 			 * In high speed mode microframes are possible.
 			 * However, during one microframe we can roughly
@@ -877,18 +877,18 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int flags;
 
-	if (!this_usbduxsub)
+	if (!devpriv)
 		return -EFAULT;
 
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	if (0) {		/* (this_usbduxsub->high_speed) */
+	if (0) {		/* (devpriv->high_speed) */
 		/* the sampling rate is set by the coversion rate */
 		flags = TRIG_FOLLOW;
 	} else {
@@ -897,7 +897,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	}
 	err |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);
 
-	if (0) {		/* (this_usbduxsub->high_speed) */
+	if (0) {		/* (devpriv->high_speed) */
 		/*
 		 * in usb-2.0 only one conversion it transmitted
 		 * but with 8kHz/n

commit a0341e5deb05c18c67b786d138799b9a107cdfbf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:28 2015 -0700

    staging: comedi: usbdux: use common code path to check the cmd->scan_begin_arg
    
    There are currently separate code paths to check the scan_begin_arg based
    of the USB speed. Refactor the code to use a common code path and simplify
    the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1ba6dd93dd36..be4c2db21cc8 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -517,8 +517,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	struct usbdux_private *this_usbduxsub = dev->private;
-	int err = 0, i;
-	unsigned int tmp_timer;
+	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -549,6 +548,10 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* full speed does 1kHz scans every USB frame */
+		unsigned int arg = 1000000;
+		unsigned int min_arg = arg;
+
 		if (this_usbduxsub->high_speed) {
 			/*
 			 * In high speed mode microframes are possible.
@@ -556,33 +559,20 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			 * sample one channel. Thus, the more channels
 			 * are in the channel list the more time we need.
 			 */
-			i = 1;
+			int i = 1;
+
 			/* find a power of 2 for the number of channels */
-			while (i < (cmd->chanlist_len))
+			while (i < cmd->chanlist_len)
 				i = i * 2;
 
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    1000000 / 8 * i);
-			/* now calc the real sampling rate with all the
-			 * rounding errors */
-			tmp_timer =
-			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
-			    125000;
-		} else {
-			/* full speed */
-			/* 1kHz scans every USB frame */
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    1000000);
-			/*
-			 * calc the real sampling rate with the rounding errors
-			 */
-			tmp_timer = ((unsigned int)(cmd->scan_begin_arg /
-						   1000000)) * 1000000;
+			arg /= 8;
+			min_arg = arg * i;
 		}
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,
-						   tmp_timer);
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    min_arg);
+		/* calc the real sampling rate with the rounding errors */
+		arg = (cmd->scan_begin_arg / arg) * arg;
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,

commit 0725b16ece9fe68887144fc2a86b6f297bafa1e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:27 2015 -0700

    staging: comedi: usbdux: add missing spaces
    
    Add some missing space to quiet the checkpatch.pl issues about:
    
    CHECK: spaces preferred around that '/' (ctx:VxV)
    CHECK: spaces preferred around that '*' (ctx:VxV)
    CHECK: spaces preferred around that '+' (ctx:VxV)
    
    For aesthetics, use tabs instead of spaces in all the defines and
    
    ensure they have common alignment.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bb100e9bdbcb..1ba6dd93dd36 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -108,55 +108,55 @@
 #define BULK_TIMEOUT		1000
 
 /* 300Hz max frequ under PWM */
-#define MIN_PWM_PERIOD  ((long)(1E9/300))
+#define MIN_PWM_PERIOD		((long)(1E9 / 300))
 
 /* Default PWM frequency */
-#define PWM_DEFAULT_PERIOD ((long)(1E9/100))
+#define PWM_DEFAULT_PERIOD	((long)(1E9 / 100))
 
 /* Size of one A/D value */
-#define SIZEADIN          ((sizeof(u16)))
+#define SIZEADIN		((sizeof(u16)))
 
 /*
  * Size of the input-buffer IN BYTES
  * Always multiple of 8 for 8 microframes which is needed in the highspeed mode
  */
-#define SIZEINBUF         ((8*SIZEADIN))
+#define SIZEINBUF		(8 * SIZEADIN)
 
 /* 16 bytes. */
-#define SIZEINSNBUF       16
+#define SIZEINSNBUF		16
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(u8) + sizeof(u16)))
+#define SIZEDAOUT		((sizeof(u8) + sizeof(u16)))
 
 /*
  * Size of the output-buffer in bytes
  * Actually only the first 4 triplets are used but for the
  * high speed mode we need to pad it to 8 (microframes).
  */
-#define SIZEOUTBUF         ((8*SIZEDAOUT))
+#define SIZEOUTBUF		(8 * SIZEDAOUT)
 
 /*
  * Size of the buffer for the dux commands: just now max size is determined
  * by the analogue out + command byte + panic bytes...
  */
-#define SIZEOFDUXBUFFER    ((8*SIZEDAOUT+2))
+#define SIZEOFDUXBUFFER		(8 * SIZEDAOUT + 2)
 
 /* Number of in-URBs which receive the data: min=2 */
-#define NUMOFINBUFFERSFULL     5
+#define NUMOFINBUFFERSFULL	5
 
 /* Number of out-URBs which send the data: min=2 */
-#define NUMOFOUTBUFFERSFULL    5
+#define NUMOFOUTBUFFERSFULL	5
 
 /* Number of in-URBs which receive the data: min=5 */
 /* must have more buffers due to buggy USB ctr */
-#define NUMOFINBUFFERSHIGH     10
+#define NUMOFINBUFFERSHIGH	10
 
 /* Number of out-URBs which send the data: min=5 */
 /* must have more buffers due to buggy USB ctr */
-#define NUMOFOUTBUFFERSHIGH    10
+#define NUMOFOUTBUFFERSHIGH	10
 
 /* number of retries to get the right dux command */
-#define RETRIES 10
+#define RETRIES			10
 
 static const struct comedi_lrange range_usbdux_ai_range = {
 	4, {

commit 3b2ea2fb4b31bd59c48bb37a21928a0205668b34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 15:23:26 2015 -0700

    staging: comedi: usbdux: use preferred kernel types
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ced05e581620..bb100e9bdbcb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -114,7 +114,7 @@
 #define PWM_DEFAULT_PERIOD ((long)(1E9/100))
 
 /* Size of one A/D value */
-#define SIZEADIN          ((sizeof(uint16_t)))
+#define SIZEADIN          ((sizeof(u16)))
 
 /*
  * Size of the input-buffer IN BYTES
@@ -126,7 +126,7 @@
 #define SIZEINSNBUF       16
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(uint16_t)))
+#define SIZEDAOUT          ((sizeof(u8) + sizeof(u16)))
 
 /*
  * Size of the output-buffer in bytes
@@ -187,7 +187,7 @@ struct usbdux_private {
 	/* PWM period */
 	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	uint8_t pwm_delay;
+	u8 pwm_delay;
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
@@ -209,7 +209,7 @@ struct usbdux_private {
 	/* interval in frames/uframes */
 	unsigned int ai_interval;
 	/* commands */
-	uint8_t *dux_commands;
+	u8 *dux_commands;
 	struct semaphore sem;
 };
 
@@ -262,7 +262,7 @@ static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
 		/* get the data from the USB bus and hand it over to comedi */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			unsigned int range = CR_RANGE(cmd->chanlist[i]);
-			uint16_t val = le16_to_cpu(devpriv->in_buf[i]);
+			u16 val = le16_to_cpu(devpriv->in_buf[i]);
 
 			/* bipolar data is two's-complement */
 			if (comedi_range_is_bipolar(s, range))
@@ -380,7 +380,7 @@ static void usbduxsub_ao_handle_urb(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint8_t *datap;
+	u8 *datap;
 	int ret;
 	int i;
 
@@ -603,10 +603,10 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
  * creates the ADC command for the MAX1271
  * range is the range value from comedi
  */
-static uint8_t create_adc_command(unsigned int chan, unsigned int range)
+static u8 create_adc_command(unsigned int chan, unsigned int range)
 {
-	uint8_t p = (range <= 1);
-	uint8_t r = ((range % 2) == 0);
+	u8 p = (range <= 1);
+	u8 r = ((range % 2) == 0);
 
 	return (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);
 }
@@ -1391,8 +1391,8 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 				  unsigned long context)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
-	uint8_t *buf;
-	uint8_t *tmp;
+	u8 *buf;
+	u8 *tmp;
 	int ret;
 
 	if (!data)

commit 2b012d948c00f1c74c7e70ab7444ff3f3944778f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:37 2015 +0000

    staging: comedi: usbdux: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a6403d2d2c08..ced05e581620 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -85,8 +85,6 @@
 
 #include "../comedi_usb.h"
 
-#include "comedi_fc.h"
-
 /* constants for firmware upload and download */
 #define USBDUX_FIRMWARE		"usbdux_firmware.bin"
 #define USBDUX_FIRMWARE_MAX_LEN	0x2000
@@ -524,19 +522,19 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -545,10 +543,10 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (this_usbduxsub->high_speed) {
@@ -563,8 +561,9 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			while (i < (cmd->chanlist_len))
 				i = i * 2;
 
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 1000000 / 8 * i);
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    1000000 / 8 * i);
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
 			tmp_timer =
@@ -573,24 +572,26 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 		} else {
 			/* full speed */
 			/* 1kHz scans every USB frame */
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 1000000);
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    1000000);
 			/*
 			 * calc the real sampling rate with the rounding errors
 			 */
 			tmp_timer = ((unsigned int)(cmd->scan_begin_arg /
 						   1000000)) * 1000000;
 		}
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
-						tmp_timer);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,
+						   tmp_timer);
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -895,7 +896,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
 	if (0) {		/* (this_usbduxsub->high_speed) */
 		/* the sampling rate is set by the coversion rate */
@@ -904,7 +905,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 		/* start a new scan (output at once) with a timer */
 		flags = TRIG_TIMER;
 	}
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);
 
 	if (0) {		/* (this_usbduxsub->high_speed) */
 		/*
@@ -919,18 +920,18 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 		 */
 		flags = TRIG_NOW;
 	}
-	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
+	err |= comedi_check_trigger_src(&cmd->convert_src, flags);
 
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -939,25 +940,27 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 1000000);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    1000000);
+	}
 
 	/* not used now, is for later use */
 	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 125000);
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 125000);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index feaa5ae53fcb..a6403d2d2c08 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1041,7 +1041,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-
 	struct usbdux_private *devpriv = dev->private;
 	int ret;
 

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1cd7403a4e9c..feaa5ae53fcb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -633,8 +633,8 @@ static int receive_dux_commands(struct comedi_device *dev, unsigned int command)
 
 	for (i = 0; i < RETRIES; i++) {
 		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),
-				      devpriv->insn_buf, SIZEINSNBUF,
-				      &nrec, BULK_TIMEOUT);
+				   devpriv->insn_buf, SIZEINSNBUF,
+				   &nrec, BULK_TIMEOUT);
 		if (ret < 0)
 			return ret;
 		if (le16_to_cpu(devpriv->insn_buf[0]) == command)

commit dd74344b0e53cab4f4f8da40900ee4fc652bab11
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 27 17:49:05 2015 +0000

    staging: comedi: usbdux: include new "comedi_usb.h" header
    
    Include the new "../comedi_usb.h" header instead of <linux/usb.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0683d6a090cc..1cd7403a4e9c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -80,11 +80,10 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/input.h>
-#include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
 
-#include "../comedidev.h"
+#include "../comedi_usb.h"
 
 #include "comedi_fc.h"
 

commit f79e1d3c43632f2d6e60f393aa3c659f7499ab58
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:10 2015 +0000

    staging: comedi: usbdux: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 4737dbf8e01d..0683d6a090cc 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -16,10 +16,11 @@
 /*
  * Driver: usbdux
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
- * Devices: (ITL) USB-DUX [usbdux]
+ * Devices: [ITL] USB-DUX (usbdux)
  * Author: Bernd Porr <mail@berndporr.me.uk>
  * Updated: 10 Oct 2014
  * Status: Stable
+ *
  * Connection scheme for the counter at the digital port:
  * 0=/CLK0, 1=UP/DOWN0, 2=RESET0, 4=/CLK1, 5=UP/DOWN1, 6=RESET1.
  * The sampling rate of the counter is approximately 500Hz.

commit 88340999de06facf5f4ae1b9f5b620ee04715a00
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:05 2014 -0700

    staging: comedi: usbdux: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'ai_sample_count' and use the comedi_async
    'scans_done' member to detect the analog input end-of-acquisition.
    
    Move the EOA check so it happens after adding the samples from the current
    urb to the async buffer. This prevents the unnecessary resubmit of the urb
    when the EOA occurs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 778201596d69..4737dbf8e01d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -202,8 +202,6 @@ struct usbdux_private {
 	unsigned int ao_cmd_running:1;
 	unsigned int pwm_cmd_running:1;
 
-	/* number of samples to acquire */
-	int ai_sample_count;
 	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
@@ -263,14 +261,6 @@ static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
 	if (devpriv->ai_counter == 0) {
 		devpriv->ai_counter = devpriv->ai_timer;
 
-		if (cmd->stop_src == TRIG_COUNT) {
-			devpriv->ai_sample_count--;
-			if (devpriv->ai_sample_count < 0) {
-				async->events |= COMEDI_CB_EOA;
-				return;
-			}
-		}
-
 		/* get the data from the USB bus and hand it over to comedi */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			unsigned int range = CR_RANGE(cmd->chanlist[i]);
@@ -284,6 +274,10 @@ static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
 			if (!comedi_buf_write_samples(s, &val, 1))
 				return;
 		}
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg)
+			async->events |= COMEDI_CB_EOA;
 	}
 
 	/* if command is still running, resubmit urb */
@@ -732,14 +726,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai_counter = devpriv->ai_timer;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* data arrives as one packet */
-		devpriv->ai_sample_count = cmd->stop_arg;
-	} else {
-		/* continous acquisition */
-		devpriv->ai_sample_count = 0;
-	}
-
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		devpriv->ai_cmd_running = 1;

commit 7c5fc7dd4780e3ff923f2117dae78517ede9290b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:04 2014 -0700

    staging: comedi: usbdux: use comedi_async 'scans_done' to detect AO EOA
    
    Remove the private data member 'ao_sample_count' and use the comedi_async
    'scans_done' member to detect the analog output end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 40f5cd03651d..778201596d69 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -204,7 +204,6 @@ struct usbdux_private {
 
 	/* number of samples to acquire */
 	int ai_sample_count;
-	int ao_sample_count;
 	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
@@ -397,12 +396,10 @@ static void usbduxsub_ao_handle_urb(struct comedi_device *dev,
 	if (devpriv->ao_counter == 0) {
 		devpriv->ao_counter = devpriv->ao_timer;
 
-		if (cmd->stop_src == TRIG_COUNT) {
-			devpriv->ao_sample_count--;
-			if (devpriv->ao_sample_count < 0) {
-				async->events |= COMEDI_CB_EOA;
-				return;
-			}
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg) {
+			async->events |= COMEDI_CB_EOA;
+			return;
 		}
 
 		/* transmit data to the USB bus */
@@ -1011,24 +1008,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ao_counter = devpriv->ao_timer;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continuous */
-		/* counter */
-		/* high speed also scans everything at once */
-		if (0) {	/* (devpriv->high_speed) */
-			devpriv->ao_sample_count = cmd->stop_arg *
-						   cmd->scan_end_arg;
-		} else {
-			/* there's no scan as the scan has been */
-			/* perf inside the FX2 */
-			/* data arrives as one packet */
-			devpriv->ao_sample_count = cmd->stop_arg;
-		}
-	} else {
-		/* continous acquisition */
-		devpriv->ao_sample_count = 0;
-	}
-
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		devpriv->ao_cmd_running = 1;

commit a7d3de75cf00574f8d360d51d0e1beb3c561cc89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:21:54 2014 -0700

    staging: comedi: drivers do not need to reset the async->cur_chan
    
    The comedi core calls comedi_buf_reset() before starting an async command
    (*do_cmd) and after returning a subdevice to an idle state (*cancel).
    
    The drivers do not need to reset the async->cur_chan in those functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 579e6bce529d..40f5cd03651d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -698,9 +698,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->ai_cmd_running)
 		goto ai_cmd_exit;
 
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
-
 	devpriv->dux_commands[1] = len;
 	for (i = 0; i < len; ++i) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
@@ -996,9 +993,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->ao_cmd_running)
 		goto ao_cmd_exit;
 
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
-
 	/* we count in steps of 1ms (125us) */
 	/* 125us mode not used yet */
 	if (0) {		/* (devpriv->high_speed) */

commit 290d028e0478c5020d69875d817a8b529439874e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:07 2014 -0700

    staging: comedi: usbdux: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the sample to the async buffer.
    
    The async events COMEDI_CB_BLOCK and COMEDI_CB_EOS will be detected and set
    by the core. Remove the unnecessary events in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 53f1e218d0d9..579e6bce529d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -282,10 +282,9 @@ static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
 				val ^= ((s->maxdata + 1) >> 1);
 
 			/* transfer data */
-			if (!comedi_buf_put(s, val))
+			if (!comedi_buf_write_samples(s, &val, 1))
 				return;
 		}
-		async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 	}
 
 	/* if command is still running, resubmit urb */

commit 664ab5d6db57c5805ed3e1bfc06f39aad80ce34e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:45 2014 -0700

    staging: comedi: usbdux: use comedi_buf_read_samples()
    
    Use comedi_buf_read_samples() to read the analog output samples from
    the async buffer. That function will set the COMEDI_CB_BLOCK event
    when samples are read from the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index eae441f3858c..53f1e218d0d9 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -413,7 +413,7 @@ static void usbduxsub_ao_handle_urb(struct comedi_device *dev,
 			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
-			if (!comedi_buf_get(s, &val)) {
+			if (!comedi_buf_read_samples(s, &val, 1)) {
 				dev_err(dev->class_dev, "buffer underflow\n");
 				async->events |= COMEDI_CB_OVERFLOW;
 				return;
@@ -425,7 +425,6 @@ static void usbduxsub_ao_handle_urb(struct comedi_device *dev,
 			*datap++ = chan << 6;
 			s->readback[chan] = val;
 		}
-		async->events |= COMEDI_CB_BLOCK;
 	}
 
 	/* if command is still running, resubmit urb for BULK transfer */

commit 41ca22a8c575b5f2e76150a30db5d1a934ed7ca9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 14 12:14:38 2014 -0700

    staging: comedi: usbdux: introduce usbduxsub_ai_handle_urb()
    
    Factor the urb handling and resubmit out of the analog input urb
    completion handler and tidy it up. This allows a common exit path
    to be used in the completion handler to stop the async command and
    handle the events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 5fdbf2644e09..eae441f3858c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -250,128 +250,112 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/* analogue IN - interrupt service routine */
+static void usbduxsub_ai_handle_urb(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct urb *urb)
+{
+	struct usbdux_private *devpriv = dev->private;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	int ret;
+	int i;
+
+	devpriv->ai_counter--;
+	if (devpriv->ai_counter == 0) {
+		devpriv->ai_counter = devpriv->ai_timer;
+
+		if (cmd->stop_src == TRIG_COUNT) {
+			devpriv->ai_sample_count--;
+			if (devpriv->ai_sample_count < 0) {
+				async->events |= COMEDI_CB_EOA;
+				return;
+			}
+		}
+
+		/* get the data from the USB bus and hand it over to comedi */
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int range = CR_RANGE(cmd->chanlist[i]);
+			uint16_t val = le16_to_cpu(devpriv->in_buf[i]);
+
+			/* bipolar data is two's-complement */
+			if (comedi_range_is_bipolar(s, range))
+				val ^= ((s->maxdata + 1) >> 1);
+
+			/* transfer data */
+			if (!comedi_buf_put(s, val))
+				return;
+		}
+		async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	}
+
+	/* if command is still running, resubmit urb */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		urb->dev = comedi_to_usb_dev(dev);
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
+			dev_err(dev->class_dev,
+				"urb resubmit failed in int-context! err=%d\n",
+				ret);
+			if (ret == -EL2NSYNC)
+				dev_err(dev->class_dev,
+					"buggy USB host controller or bug in IRQ handler!\n");
+			async->events |= COMEDI_CB_ERROR;
+		}
+	}
+}
+
 static void usbduxsub_ai_isoc_irq(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
 	struct usbdux_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	int i, err;
 
-	/* first we test if something unusual has just happened */
+	/* exit if not running a command, do not resubmit urb */
+	if (!devpriv->ai_cmd_running)
+		return;
+
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
 		memcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);
+		usbduxsub_ai_handle_urb(dev, s, urb);
 		break;
+
 	case -EILSEQ:
-		/* error in the ISOchronous data */
-		/* we don't copy the data into the transfer buffer */
-		/* and recycle the last data byte */
+		/*
+		 * error in the ISOchronous data
+		 * we don't copy the data into the transfer buffer
+		 * and recycle the last data byte
+		 */
 		dev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");
+		usbduxsub_ai_handle_urb(dev, s, urb);
 		break;
 
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		/* happens after an unlink command */
-		if (devpriv->ai_cmd_running) {
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(dev, s);
-			/* stop the transfer w/o unlink */
-			usbdux_ai_stop(dev, 0);
-		}
-		return;
+		/* after an unlink command, unplug, ... etc */
+		async->events |= COMEDI_CB_ERROR;
+		break;
 
 	default:
-		/* a real error on the bus */
-		/* pass error to comedi if we are really running a command */
-		if (devpriv->ai_cmd_running) {
-			dev_err(dev->class_dev,
-				"Non-zero urb status received in ai intr context: %d\n",
-				urb->status);
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(dev, s);
-			/* don't do an unlink here */
-			usbdux_ai_stop(dev, 0);
-		}
-		return;
+		/* a real error */
+		dev_err(dev->class_dev,
+			"Non-zero urb status received in ai intr context: %d\n",
+			urb->status);
+		async->events |= COMEDI_CB_ERROR;
+		break;
 	}
 
 	/*
-	 * at this point we are reasonably sure that nothing dodgy has happened
-	 * are we running a command?
+	 * comedi_handle_events() cannot be used in this driver. The (*cancel)
+	 * operation would unlink the urb.
 	 */
-	if (unlikely(!devpriv->ai_cmd_running)) {
-		/*
-		 * not running a command, do not continue execution if no
-		 * asynchronous command is running in particular not resubmit
-		 */
-		return;
-	}
-
-	urb->dev = comedi_to_usb_dev(dev);
-
-	/* resubmit the urb */
-	err = usb_submit_urb(urb, GFP_ATOMIC);
-	if (unlikely(err < 0)) {
-		dev_err(dev->class_dev,
-			"urb resubmit failed in int-context! err=%d\n", err);
-		if (err == -EL2NSYNC)
-			dev_err(dev->class_dev,
-				"buggy USB host controller or bug in IRQ handler!\n");
-		s->async->events |= COMEDI_CB_EOA;
-		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(dev, s);
-		/* don't do an unlink here */
+	if (async->events & COMEDI_CB_CANCEL_MASK)
 		usbdux_ai_stop(dev, 0);
-		return;
-	}
-
-	devpriv->ai_counter--;
-	if (likely(devpriv->ai_counter > 0))
-		return;
-
-	/* timer zero, transfer measurements to comedi */
-	devpriv->ai_counter = devpriv->ai_timer;
 
-	/* test, if we transmit only a fixed number of samples */
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continuous, fixed number of samples */
-		devpriv->ai_sample_count--;
-		/* all samples received? */
-		if (devpriv->ai_sample_count < 0) {
-			/* prevent a resubmit next time */
-			usbdux_ai_stop(dev, 0);
-			/* say comedi that the acquistion is over */
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
-			return;
-		}
-	}
-	/* get the data from the USB bus and hand it over to comedi */
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		unsigned int range = CR_RANGE(cmd->chanlist[i]);
-		uint16_t val = le16_to_cpu(devpriv->in_buf[i]);
-
-		/* bipolar data is two's-complement */
-		if (comedi_range_is_bipolar(s, range))
-			val ^= ((s->maxdata + 1) >> 1);
-
-		/* transfer data */
-		err = comedi_buf_put(s, val);
-		if (unlikely(err == 0)) {
-			/* buffer overflow */
-			usbdux_ai_stop(dev, 0);
-			return;
-		}
-	}
-	/* tell comedi that data is there */
-	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 	comedi_event(dev, s);
 }
 

commit 67f61f7ae9dd3e1b0ac9c2136aba2fca6740d8bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 14 12:14:37 2014 -0700

    staging: comedi: usbdux: introduce usbduxsub_ao_handle_urb()
    
    Factor the urb handling and resubmit out of the analog output urb
    completion handler and tidy it up. This allows a common exit path
    to be used in the completion handler to stop the async command and
    handle the events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 89f6ece2f0aa..5fdbf2644e09 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -399,69 +399,25 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void usbduxsub_ao_isoc_irq(struct urb *urb)
+static void usbduxsub_ao_handle_urb(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct urb *urb)
 {
-	struct comedi_device *dev = urb->context;
-	struct comedi_subdevice *s = dev->write_subdev;
 	struct usbdux_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	uint8_t *datap;
 	int ret;
 	int i;
 
-	switch (urb->status) {
-	case 0:
-		/* success */
-		break;
-
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-	case -ECONNABORTED:
-		/* after an unlink command, unplug, ... etc */
-		/* no unlink needed here. Already shutting down. */
-		if (devpriv->ao_cmd_running) {
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
-			usbdux_ao_stop(dev, 0);
-		}
-		return;
-
-	default:
-		/* a real error */
-		if (devpriv->ao_cmd_running) {
-			dev_err(dev->class_dev,
-				"Non-zero urb status received in ao intr context: %d\n",
-				urb->status);
-			s->async->events |= COMEDI_CB_ERROR;
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
-			/* we do an unlink if we are in the high speed mode */
-			usbdux_ao_stop(dev, 0);
-		}
-		return;
-	}
-
-	/* are we actually running? */
-	if (!devpriv->ao_cmd_running)
-		return;
-
-	/* normal operation: executing a command in this subdevice */
 	devpriv->ao_counter--;
-	if ((int)devpriv->ao_counter <= 0) {
-		/* timer zero */
+	if (devpriv->ao_counter == 0) {
 		devpriv->ao_counter = devpriv->ao_timer;
 
-		/* handle non continous acquisition */
 		if (cmd->stop_src == TRIG_COUNT) {
-			/* fixed number of samples */
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
-				/* all samples transmitted */
-				usbdux_ao_stop(dev, 0);
-				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(dev, s);
-				/* no resubmit of the urb */
+				async->events |= COMEDI_CB_EOA;
 				return;
 			}
 		}
@@ -473,26 +429,26 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
-			ret = comedi_buf_get(s, &val);
-			if (ret < 0) {
+			if (!comedi_buf_get(s, &val)) {
 				dev_err(dev->class_dev, "buffer underflow\n");
-				s->async->events |= (COMEDI_CB_EOA |
-						     COMEDI_CB_OVERFLOW);
+				async->events |= COMEDI_CB_OVERFLOW;
+				return;
 			}
+
 			/* pointer to the DA */
 			*datap++ = val & 0xff;
 			*datap++ = (val >> 8) & 0xff;
 			*datap++ = chan << 6;
 			s->readback[chan] = val;
-
-			s->async->events |= COMEDI_CB_BLOCK;
-			comedi_event(dev, s);
 		}
+		async->events |= COMEDI_CB_BLOCK;
 	}
-	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = comedi_to_usb_dev(dev);
-	urb->status = 0;
-	if (devpriv->ao_cmd_running) {
+
+	/* if command is still running, resubmit urb for BULK transfer */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->dev = comedi_to_usb_dev(dev);
+		urb->status = 0;
 		if (devpriv->high_speed)
 			urb->interval = 8;	/* uframes */
 		else
@@ -509,16 +465,54 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			if (ret == -EL2NSYNC)
 				dev_err(dev->class_dev,
 					"buggy USB host controller or bug in IRQ handling!\n");
-
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(dev, s);
-			/* don't do an unlink here */
-			usbdux_ao_stop(dev, 0);
+			async->events |= COMEDI_CB_ERROR;
 		}
 	}
 }
 
+static void usbduxsub_ao_isoc_irq(struct urb *urb)
+{
+	struct comedi_device *dev = urb->context;
+	struct comedi_subdevice *s = dev->write_subdev;
+	struct comedi_async *async = s->async;
+	struct usbdux_private *devpriv = dev->private;
+
+	/* exit if not running a command, do not resubmit urb */
+	if (!devpriv->ao_cmd_running)
+		return;
+
+	switch (urb->status) {
+	case 0:
+		usbduxsub_ao_handle_urb(dev, s, urb);
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		/* after an unlink command, unplug, ... etc */
+		async->events |= COMEDI_CB_ERROR;
+		break;
+
+	default:
+		/* a real error */
+		dev_err(dev->class_dev,
+			"Non-zero urb status received in ao intr context: %d\n",
+			urb->status);
+		async->events |= COMEDI_CB_ERROR;
+		break;
+	}
+
+	/*
+	 * comedi_handle_events() cannot be used in this driver. The (*cancel)
+	 * operation would unlink the urb.
+	 */
+	if (async->events & COMEDI_CB_CANCEL_MASK)
+		usbdux_ao_stop(dev, 0);
+
+	comedi_event(dev, s);
+}
+
 static int usbdux_submit_urbs(struct comedi_device *dev,
 			      struct urb **urbs, int num_urbs,
 			      int input_urb)

commit 79f54ac18be5f5cadd7d0c1439491f98ab4c3a47
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Fri Oct 10 20:34:04 2014 +0100

    staging: comedi: usbdux: updated contact details / comments
    
    I've updated my contact details and removed obsolete comments.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 5adbfedf780f..89f6ece2f0aa 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,37 +1,34 @@
 /*
-   comedi/drivers/usbdux.c
-   Copyright (C) 2003-2007 Bernd Porr, Bernd.Porr@f2s.com
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+ * usbdux.c
+ * Copyright (C) 2003-2014 Bernd Porr, mail@berndporr.me.uk
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
+
 /*
-Driver: usbdux
-Description: University of Stirling USB DAQ & INCITE Technology Limited
-Devices: [ITL] USB-DUX (usbdux.o)
-Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 8 Dec 2008
-Status: Stable
-Configuration options:
-  You have to upload firmware with the -i option. The
-  firmware is usually installed under /usr/share/usb or
-  /usr/local/share/usb or /lib/firmware.
-
-Connection scheme for the counter at the digital port:
-  0=/CLK0, 1=UP/DOWN0, 2=RESET0, 4=/CLK1, 5=UP/DOWN1, 6=RESET1.
-  The sampling rate of the counter is approximately 500Hz.
-
-Please note that under USB2.0 the length of the channel list determines
-the max sampling rate. If you sample only one channel you get 8kHz
-sampling rate. If you sample two channels you get 4kHz and so on.
-*/
+ * Driver: usbdux
+ * Description: University of Stirling USB DAQ & INCITE Technology Limited
+ * Devices: (ITL) USB-DUX [usbdux]
+ * Author: Bernd Porr <mail@berndporr.me.uk>
+ * Updated: 10 Oct 2014
+ * Status: Stable
+ * Connection scheme for the counter at the digital port:
+ * 0=/CLK0, 1=UP/DOWN0, 2=RESET0, 4=/CLK1, 5=UP/DOWN1, 6=RESET1.
+ * The sampling rate of the counter is approximately 500Hz.
+ *
+ * Note that under USB2.0 the length of the channel list determines
+ * the max sampling rate. If you sample only one channel you get 8kHz
+ * sampling rate. If you sample two channels you get 4kHz and so on.
+ */
+
 /*
  * I must give credit here to Chris Baugher who
  * wrote the driver for AT-MIO-16d. I used some parts of this

commit e98348e0cb52dbb48d505b54646180a1455d630c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:05 2014 -0700

    staging: comedi: usbdux: prevent "empty acquisition" async commands
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0 for both the analog input and output async commands. The (*do_cmd) for
    both subdevices sets up and starts the command without handling the "empty
    acquisition". This results in the interrupt functions trying to transfer 0 data
    samples.
    
    Validate that the cmd->stop_arg is >= 1 in the (*do_cmdtest) to prevent the
    "empty acquisition".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 8eb2742e6fef..5adbfedf780f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -623,12 +623,10 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;
@@ -1003,12 +1001,10 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;

commit ae689d52f778fef3026dc7f8d9349df4ca465e6d
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sun Aug 31 14:44:23 2014 -0500

    staging: comedi: usbdux: fix more sparse endianness warnings
    
    Sparse shows a couple of warnings like:
    
    drivers/staging/comedi/drivers/usbdux.c:889:20: warning: incorrect type in assignment (different base types)
    drivers/staging/comedi/drivers/usbdux.c:889:20:    expected unsigned short [unsigned] [short] [usertype] <noident>
    drivers/staging/comedi/drivers/usbdux.c:889:20:    got restricted __le16 [usertype] <noident>
    
    This is the result of a couple of calls to cpu_to_le16() being assigned to
    uint16_t typed variables.  Switch the types of these variables/pointers to
    __le16 accordingly.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Suggested-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 86c2c27fcb92..8eb2742e6fef 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -868,7 +868,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int val = s->readback[chan];
-	uint16_t *p = (uint16_t *)&devpriv->dux_commands[2];
+	__le16 *p = (__le16 *)&devpriv->dux_commands[2];
 	int ret = -EBUSY;
 	int i;
 
@@ -1180,7 +1180,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 {
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	uint16_t *p = (uint16_t *)&devpriv->dux_commands[2];
+	__le16 *p = (__le16 *)&devpriv->dux_commands[2];
 	int ret = 0;
 	int i;
 

commit 7ae596b8c1464e671f040455c7da2719491c8e43
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Fri Aug 29 20:40:32 2014 -0500

    staging: comedi: usbdux: fix sparse endianness warnings
    
    Sparse has many warnings like:
    
    drivers/staging/comedi/drivers/usbdux.c:366:32: warning: cast to
    restricted __le16
    
    on lines on which devpriv->in_buf or devpriv->insn_buf are passed to
    le16_to_cpu().  This suggests that both of these variables should actually
    be of type __le16.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 184dee222619..86c2c27fcb92 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -196,9 +196,9 @@ struct usbdux_private {
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	uint16_t *in_buf;
+	__le16 *in_buf;
 	/* input buffer for single insn */
-	uint16_t *insn_buf;
+	__le16 *insn_buf;
 
 	unsigned int high_speed:1;
 	unsigned int ai_cmd_running:1;

commit 65a847477f63c913f493d0a489549f24a776bd44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:16 2014 -0700

    staging: comedi: usbdux: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ad0faf5c2fad..184dee222619 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -109,8 +109,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define USBDUX_CMD_PWM_ON	7
 #define USBDUX_CMD_PWM_OFF	8
 
-#define USBDUX_NUM_AO_CHAN	4
-
 /* timeout for the USB-transfer in ms */
 #define BULK_TIMEOUT		1000
 
@@ -202,8 +200,6 @@ struct usbdux_private {
 	/* input buffer for single insn */
 	uint16_t *insn_buf;
 
-	unsigned int ao_readback[USBDUX_NUM_AO_CHAN];
-
 	unsigned int high_speed:1;
 	unsigned int ai_cmd_running:1;
 	unsigned int ao_cmd_running:1;
@@ -490,7 +486,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			*datap++ = val & 0xff;
 			*datap++ = (val >> 8) & 0xff;
 			*datap++ = chan << 6;
-			devpriv->ao_readback[chan] = val;
+			s->readback[chan] = val;
 
 			s->async->events |= COMEDI_CB_BLOCK;
 			comedi_event(dev, s);
@@ -855,15 +851,13 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 			       unsigned int *data)
 {
 	struct usbdux_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
+	int ret;
 
 	down(&devpriv->sem);
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
+	ret = comedi_readback_insn_read(dev, s, insn, data);
 	up(&devpriv->sem);
 
-	return insn->n;
+	return ret;
 }
 
 static int usbdux_ao_insn_write(struct comedi_device *dev,
@@ -873,7 +867,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 {
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val = devpriv->ao_readback[chan];
+	unsigned int val = s->readback[chan];
 	uint16_t *p = (uint16_t *)&devpriv->dux_commands[2];
 	int ret = -EBUSY;
 	int i;
@@ -897,8 +891,9 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		ret = send_dux_commands(dev, USBDUX_CMD_AO);
 		if (ret < 0)
 			goto ao_write_exit;
+
+		s->readback[chan] = val;
 	}
-	devpriv->ao_readback[chan] = val;
 
 ao_write_exit:
 	up(&devpriv->sem);
@@ -1720,7 +1715,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	dev->write_subdev = s;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= USBDUX_NUM_AO_CHAN;
+	s->n_chan	= 4;
 	s->maxdata	= 0x0fff;
 	s->len_chanlist	= s->n_chan;
 	s->range_table	= &range_usbdux_ao_range;
@@ -1730,6 +1725,10 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	s->insn_read	= usbdux_ao_insn_read;
 	s->insn_write	= usbdux_ao_insn_write;
 
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DIO;

commit 25e9398734ebc1ae10028d92ff001b45ce3da67f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:47 2014 -0700

    staging: comedi: usbdux: fix errno (EL2NSYNC) check
    
    These should both be checking the -errno.
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 053bc5090530..ad0faf5c2fad 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -513,7 +513,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			dev_err(dev->class_dev,
 				"ao urb resubm failed in int-cont. ret=%d",
 				ret);
-			if (ret == EL2NSYNC)
+			if (ret == -EL2NSYNC)
 				dev_err(dev->class_dev,
 					"buggy USB host controller or bug in IRQ handling!\n");
 
@@ -1294,7 +1294,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 			dev_err(dev->class_dev,
 				"pwm urb resubm failed in int-cont. ret=%d",
 				ret);
-			if (ret == EL2NSYNC)
+			if (ret == -EL2NSYNC)
 				dev_err(dev->class_dev,
 					"buggy USB host controller or bug in IRQ handling!\n");
 

commit ce1d67ac3f0ccfb7e3f740310b45871e5af38e18
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:35 2014 -0700

    staging: comedi: usbdux: checkpatch.pl cleanup (else not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 5f65e4213c6e..053bc5090530 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1327,13 +1327,13 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	int fx2delay = 255;
 
-	if (period < MIN_PWM_PERIOD) {
+	if (period < MIN_PWM_PERIOD)
 		return -EAGAIN;
-	} else {
-		fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
-		if (fx2delay > 255)
-			return -EAGAIN;
-	}
+
+	fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
+	if (fx2delay > 255)
+		return -EAGAIN;
+
 	devpriv->pwm_delay = fx2delay;
 	devpriv->pwm_period = period;
 

commit a49b45fb498be9c7fd42cccdb1d71fe424c962ca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:43 2014 -0700

    staging: comedi: usbdux: use 'cmd' pointer in usbduxsub_ai_isoc_irq()
    
    Use the 'cmd' pointer to access the chanlist instead of getting to it
    using the comedi_subdevice pointer.
    
    Remove the unneeded 'n' local variable, this is just the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index e61e4a93cc19..5f65e4213c6e 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -264,7 +264,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct usbdux_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int i, err, n;
+	int i, err;
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
@@ -361,9 +361,8 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		}
 	}
 	/* get the data from the USB bus and hand it over to comedi */
-	n = s->async->cmd.chanlist_len;
-	for (i = 0; i < n; i++) {
-		unsigned int range = CR_RANGE(s->async->cmd.chanlist[i]);
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
 		uint16_t val = le16_to_cpu(devpriv->in_buf[i]);
 
 		/* bipolar data is two's-complement */

commit 33938a9dfa67d55aee836172418e4a7705798950
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:42 2014 -0700

    staging: comedi: usbdux: remove 'ao_chanlist' from private data
    
    This member of the private data is just a copy of the channels from
    the cmd->chanlist. Remove the member and just use the cmd->chanlist
    directly.
    
    Remove the unneeded 'len' local variable in usbdux_ao_isoc_irq().
    This is just the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index dfbf6613a6f5..e61e4a93cc19 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -202,7 +202,6 @@ struct usbdux_private {
 	/* input buffer for single insn */
 	uint16_t *insn_buf;
 
-	uint8_t ao_chanlist[USBDUX_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUX_NUM_AO_CHAN];
 
 	unsigned int high_speed:1;
@@ -415,7 +414,6 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	struct usbdux_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	uint8_t *datap;
-	int len;
 	int ret;
 	int i;
 
@@ -478,10 +476,9 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 
 		/* transmit data to the USB bus */
 		datap = urb->transfer_buffer;
-		len = s->async->cmd.chanlist_len;
-		*datap++ = len;
-		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
-			unsigned int chan = devpriv->ao_chanlist[i];
+		*datap++ = cmd->chanlist_len;
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
 			ret = comedi_buf_get(s, &val);
@@ -1030,7 +1027,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct usbdux_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret = -EBUSY;
-	int i;
 
 	down(&devpriv->sem);
 
@@ -1040,9 +1036,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
-	for (i = 0; i < cmd->chanlist_len; ++i)
-		devpriv->ao_chanlist[i] = CR_CHAN(cmd->chanlist[i]);
-
 	/* we count in steps of 1ms (125us) */
 	/* 125us mode not used yet */
 	if (0) {		/* (devpriv->high_speed) */

commit c8f3174a9015a88cd59fd424d3c60b25fc9bc5e1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:38 2014 -0700

    staging: comedi: usbdux: remove 'ao_continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 5f6b1b3c0bdb..dfbf6613a6f5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -208,7 +208,6 @@ struct usbdux_private {
 	unsigned int high_speed:1;
 	unsigned int ai_cmd_running:1;
 	unsigned int ao_cmd_running:1;
-	unsigned int ao_continous:1;
 	unsigned int pwm_cmd_running:1;
 
 	/* number of samples to acquire */
@@ -414,6 +413,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct usbdux_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	uint8_t *datap;
 	int len;
 	int ret;
@@ -463,7 +463,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		devpriv->ao_counter = devpriv->ao_timer;
 
 		/* handle non continous acquisition */
-		if (!devpriv->ao_continous) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			/* fixed number of samples */
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
@@ -1074,10 +1074,8 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/* data arrives as one packet */
 			devpriv->ao_sample_count = cmd->stop_arg;
 		}
-		devpriv->ao_continous = 0;
 	} else {
 		/* continous acquisition */
-		devpriv->ao_continous = 1;
 		devpriv->ao_sample_count = 0;
 	}
 

commit 40642e95850b4425eef1eb74793d28085605ac75
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:37 2014 -0700

    staging: comedi: usbdux: remove 'ai_continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 143f63202621..5f6b1b3c0bdb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -207,7 +207,6 @@ struct usbdux_private {
 
 	unsigned int high_speed:1;
 	unsigned int ai_cmd_running:1;
-	unsigned int ai_continous:1;
 	unsigned int ao_cmd_running:1;
 	unsigned int ao_continous:1;
 	unsigned int pwm_cmd_running:1;
@@ -266,6 +265,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct usbdux_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int i, err, n;
 
 	/* first we test if something unusual has just happened */
@@ -349,7 +349,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	devpriv->ai_counter = devpriv->ai_timer;
 
 	/* test, if we transmit only a fixed number of samples */
-	if (!devpriv->ai_continous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		/* not continuous, fixed number of samples */
 		devpriv->ai_sample_count--;
 		/* all samples received? */
@@ -778,10 +778,8 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
-		devpriv->ai_continous = 0;
 	} else {
 		/* continous acquisition */
-		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 	}
 

commit 458c13e935d9f33fffb099e49ecb53c67ddd1a21
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:00 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_get()
    
    Change the parameters of `comedi_buf_get()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function gets a sample value from the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 011fede33a00..143f63202621 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -484,7 +484,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			unsigned int chan = devpriv->ao_chanlist[i];
 			unsigned short val;
 
-			ret = comedi_buf_get(s->async, &val);
+			ret = comedi_buf_get(s, &val);
 			if (ret < 0) {
 				dev_err(dev->class_dev, "buffer underflow\n");
 				s->async->events |= (COMEDI_CB_EOA |

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 4002f49f0082..011fede33a00 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -373,7 +373,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 			val ^= ((s->maxdata + 1) >> 1);
 
 		/* transfer data */
-		err = comedi_buf_put(s->async, val);
+		err = comedi_buf_put(s, val);
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
 			usbdux_ai_stop(dev, 0);

commit 37aa48368f2508defb1976be62e1ed6ca4dde683
Merge: 1da4f83c0c43 d1db0eea8524
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 27 21:38:34 2014 -0700

    Merge 3.15-rc3 into staging-next

commit 2704f807f9498054b8153002bafa3e818079e9a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 28 09:20:58 2014 -0700

    staging: comedi: usbdux: bug fix for accessing 'ao_chanlist' in private data
    
    In usbdux_ao_cmd(), the channels for the command are transfered from the
    cmd->chanlist and stored in the private data 'ao_chanlist'. The channel
    numbers are bit-shifted when stored so that they become the "command"
    that is transfered to the device. The channel to command conversion
    results in the 'ao_chanlist' having these values for the channels:
    
      channel 0 -> ao_chanlist = 0x00
      channel 1 -> ao_chanlist = 0x40
      channel 2 -> ao_chanlist = 0x80
      channel 3 -> ao_chanlist = 0xc0
    
    The problem is, the usbduxsub_ao_isoc_irq() function uses the 'chan' value
    from 'ao_chanlist' to access the 'ao_readback' array in the private data.
    So instead of accessing the array as 0, 1, 2, 3, it accesses it as 0x00,
    0x40, 0x80, 0xc0.
    
    Fix this by storing the raw channel number in 'ao_chanlist' and doing the
    bit-shift when creating the command.
    
    Fixes: a998a3db530bff80 "staging: comedi: usbdux: cleanup the private data 'outBuffer'"
    Cc: stable <stable@vger.kernel.org> # 3.12
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 71db683098d6..b59af0303581 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -493,7 +493,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			/* pointer to the DA */
 			*datap++ = val & 0xff;
 			*datap++ = (val >> 8) & 0xff;
-			*datap++ = chan;
+			*datap++ = chan << 6;
 			devpriv->ao_readback[chan] = val;
 
 			s->async->events |= COMEDI_CB_BLOCK;
@@ -1040,11 +1040,8 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
-	for (i = 0; i < cmd->chanlist_len; ++i) {
-		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
-
-		devpriv->ao_chanlist[i] = chan << 6;
-	}
+	for (i = 0; i < cmd->chanlist_len; ++i)
+		devpriv->ao_chanlist[i] = CR_CHAN(cmd->chanlist[i]);
 
 	/* we count in steps of 1ms (125us) */
 	/* 125us mode not used yet */

commit 7d8b7b4d92bc05d49966adb158b43655e687e20b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:10 2014 -0700

    staging: comedi: usbdux: fix the cmd->start_arg use
    
    For all cmd->start_src values this driver trivially validates that the
    cmd->start_arg is 0.
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid trig_num
    that is used by the async (*inttrig) callback.
    
    Refactor the (*inttrig) functions so that the cmd->start_arg is used to
    check the trig_num instead of the open coded values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 71db683098d6..ce528f847600 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -692,15 +692,16 @@ static int receive_dux_commands(struct comedi_device *dev, unsigned int command)
 
 static int usbdux_ai_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     unsigned int trignum)
+			     unsigned int trig_num)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = -EINVAL;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	int ret;
 
-	down(&devpriv->sem);
+	if (trig_num != cmd->start_arg)
+		return -EINVAL;
 
-	if (trignum != 0)
-		goto ai_trig_exit;
+	down(&devpriv->sem);
 
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
@@ -913,15 +914,16 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 
 static int usbdux_ao_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     unsigned int trignum)
+			     unsigned int trig_num)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = -EINVAL;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	int ret;
 
-	down(&devpriv->sem);
+	if (trig_num != cmd->start_arg)
+		return -EINVAL;
 
-	if (trignum != 0)
-		goto ao_trig_exit;
+	down(&devpriv->sem);
 
 	if (!devpriv->ao_cmd_running) {
 		devpriv->ao_cmd_running = 1;

commit 885a947e5b08953ebd5fce88be89a0399a7ab918
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Dec 10 15:23:48 2013 -0500

    staging: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index da1d501d9e4e..71db683098d6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -80,7 +80,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/usb.h>

commit 470180c611639bcfee9da8dd7c0a878fc558d646
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:37 2013 +0100

    staging: comedi: usbdux: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Use unsigned types consistently for handling comedi sample data and also
    for the USB data buffers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9218d7336923..da1d501d9e4e 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -122,7 +122,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define PWM_DEFAULT_PERIOD ((long)(1E9/100))
 
 /* Size of one A/D value */
-#define SIZEADIN          ((sizeof(int16_t)))
+#define SIZEADIN          ((sizeof(uint16_t)))
 
 /*
  * Size of the input-buffer IN BYTES
@@ -134,7 +134,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define SIZEINSNBUF       16
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(int8_t)+sizeof(int16_t)))
+#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(uint16_t)))
 
 /*
  * Size of the output-buffer in bytes
@@ -195,15 +195,15 @@ struct usbdux_private {
 	/* PWM period */
 	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	int8_t pwm_delay;
+	uint8_t pwm_delay;
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	int16_t *in_buf;
+	uint16_t *in_buf;
 	/* input buffer for single insn */
-	int16_t *insn_buf;
+	uint16_t *insn_buf;
 
-	int8_t ao_chanlist[USBDUX_NUM_AO_CHAN];
+	uint8_t ao_chanlist[USBDUX_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUX_NUM_AO_CHAN];
 
 	unsigned int high_speed:1;
@@ -225,7 +225,7 @@ struct usbdux_private {
 	/* interval in frames/uframes */
 	unsigned int ai_interval;
 	/* commands */
-	int8_t *dux_commands;
+	uint8_t *dux_commands;
 	struct semaphore sem;
 };
 
@@ -367,7 +367,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	n = s->async->cmd.chanlist_len;
 	for (i = 0; i < n; i++) {
 		unsigned int range = CR_RANGE(s->async->cmd.chanlist[i]);
-		int16_t val = le16_to_cpu(devpriv->in_buf[i]);
+		uint16_t val = le16_to_cpu(devpriv->in_buf[i]);
 
 		/* bipolar data is two's-complement */
 		if (comedi_range_is_bipolar(s, range))
@@ -415,7 +415,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct usbdux_private *devpriv = dev->private;
-	int8_t *datap;
+	uint8_t *datap;
 	int len;
 	int ret;
 	int i;
@@ -483,7 +483,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		*datap++ = len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 			unsigned int chan = devpriv->ao_chanlist[i];
-			short val;
+			unsigned short val;
 
 			ret = comedi_buf_get(s->async, &val);
 			if (ret < 0) {
@@ -649,14 +649,15 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
  * creates the ADC command for the MAX1271
  * range is the range value from comedi
  */
-static int8_t create_adc_command(unsigned int chan, int range)
+static uint8_t create_adc_command(unsigned int chan, unsigned int range)
 {
-	int8_t p = (range <= 1);
-	int8_t r = ((range % 2) == 0);
+	uint8_t p = (range <= 1);
+	uint8_t r = ((range % 2) == 0);
+
 	return (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);
 }
 
-static int send_dux_commands(struct comedi_device *dev, int cmd_type)
+static int send_dux_commands(struct comedi_device *dev, unsigned int cmd_type)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
@@ -669,7 +670,7 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 			    &nsent, BULK_TIMEOUT);
 }
 
-static int receive_dux_commands(struct comedi_device *dev, int command)
+static int receive_dux_commands(struct comedi_device *dev, unsigned int command)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
@@ -879,7 +880,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int val = devpriv->ao_readback[chan];
-	int16_t *p = (int16_t *)&devpriv->dux_commands[2];
+	uint16_t *p = (uint16_t *)&devpriv->dux_commands[2];
 	int ret = -EBUSY;
 	int i;
 
@@ -1198,7 +1199,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 {
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	int16_t *p = (int16_t *)&devpriv->dux_commands[2];
+	uint16_t *p = (uint16_t *)&devpriv->dux_commands[2];
 	int ret = 0;
 	int i;
 

commit 77e9487bdbb7770b359aaa09e964fda57227ad97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:38 2013 -0700

    staging: comedi: usbdux drivers: use comedi_dio_update_state()
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state.
    
    These drivers always need to update the hardware in order to update
    the i/o configuration regardless of if the state has changed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 701ad1a69394..9218d7336923 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1133,15 +1133,13 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 {
 
 	struct usbdux_private *devpriv = dev->private;
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
 	int ret;
 
 	down(&devpriv->sem);
 
-	s->state &= ~mask;
-	s->state |= (bits & mask);
+	comedi_dio_update_state(s, data);
 
+	/* Always update the hardware. See the (*insn_config). */
 	devpriv->dux_commands[1] = s->io_bits;
 	devpriv->dux_commands[2] = s->state;
 

commit ded82ef91e247692682d696462f5f7e1f528758c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Aug 20 12:06:19 2013 +0300

    staging: comedi: usbdux: allocating too much data
    
    We only need to allocate enough space for a pointer.  We allocate the
    space for the urbs themselves with the call to usb_alloc_urb() a few
    lines later.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7e91f1506a39..701ad1a69394 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1558,9 +1558,9 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
 	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
+	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(void *),
 				   GFP_KERNEL);
-	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
+	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(void *),
 				   GFP_KERNEL);
 	if (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||
 	    !devpriv->ai_urbs || !devpriv->ao_urbs)

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 689b45276e8d..7e91f1506a39 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1113,22 +1113,11 @@ static int usbdux_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
-	unsigned int mask = 1 << CR_CHAN(insn->chanspec);
+	int ret;
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= mask;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~mask;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
 	/*
 	 * We don't tell the firmware here as it would take 8 frames

commit 71500b272064410a3417ab764aec20572564d68d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:48:25 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_free_usb_buffers()
    
    For aesthetics, pass the comedi_device pointer to this function
    instead of the private data pointer.
    
    The usb_kill_urb() calls are not needed. All the urbs were unlinked
    before this function was called.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 991c425bb837..689b45276e8d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1642,15 +1642,15 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	return 0;
 }
 
-static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
+static void usbdux_free_usb_buffers(struct comedi_device *dev)
 {
+	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb;
 	int i;
 
 	urb = devpriv->pwm_urb;
 	if (urb) {
 		kfree(urb->transfer_buffer);
-		usb_kill_urb(urb);
 		usb_free_urb(urb);
 	}
 	if (devpriv->ao_urbs) {
@@ -1658,7 +1658,6 @@ static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
 			urb = devpriv->ao_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
-				usb_kill_urb(urb);
 				usb_free_urb(urb);
 			}
 		}
@@ -1669,7 +1668,6 @@ static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
 			urb = devpriv->ai_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
-				usb_kill_urb(urb);
 				usb_free_urb(urb);
 			}
 		}
@@ -1811,7 +1809,7 @@ static void usbdux_detach(struct comedi_device *dev)
 	usbdux_ao_stop(dev, 1);
 	usbdux_ai_stop(dev, 1);
 
-	usbdux_free_usb_buffers(devpriv);
+	usbdux_free_usb_buffers(dev);
 
 	up(&devpriv->sem);
 }

commit 4d9861b554bc08e72045098dbc03d8221d904490
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:48:04 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_detach()
    
    Make sure the usb intfdata is always cleared when the device is
    detached.
    
    Refactor the code to remove an indent level.
    
    Always unlink the urbs when the device is detached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 75b2de33ffd5..991c425bb837 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1799,20 +1799,21 @@ static void usbdux_detach(struct comedi_device *dev)
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usbdux_private *devpriv = dev->private;
 
-	if (devpriv) {
-		down(&devpriv->sem);
+	usb_set_intfdata(intf, NULL);
 
-		usb_set_intfdata(intf, NULL);
+	if (!devpriv)
+		return;
+
+	down(&devpriv->sem);
 
-		/* stop and unlink any submitted urbs */
-		usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
-		usbdux_ao_stop(dev, devpriv->ao_cmd_running);
-		usbdux_ai_stop(dev, devpriv->ai_cmd_running);
+	/* force unlink all urbs */
+	usbdux_pwm_stop(dev, 1);
+	usbdux_ao_stop(dev, 1);
+	usbdux_ai_stop(dev, 1);
 
-		usbdux_free_usb_buffers(devpriv);
+	usbdux_free_usb_buffers(devpriv);
 
-		up(&devpriv->sem);
-	}
+	up(&devpriv->sem);
 }
 
 static struct comedi_driver usbdux_driver = {

commit ef1e3c4a3b383c6da3979670fcb5c6e9c7de4741
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:46:27 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_alloc_usb_buffers()
    
    Tidy up the error path by doing all the basic allocations then checking
    for failures.
    
    We have the comedi device now so fill in the urb->context.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9dcb2978922f..75b2de33ffd5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1566,25 +1566,15 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	struct urb *urb;
 	int i;
 
-	/* create space for the commands going to the usb device */
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!devpriv->dux_commands)
-		return -ENOMEM;
-
-	/* create space for the in buffer and set it to zero */
 	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->in_buf)
-		return -ENOMEM;
-
-	/* create space of the instruction buffer */
 	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insn_buf)
-		return -ENOMEM;
-
-	/* in urbs */
 	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
 				   GFP_KERNEL);
-	if (!devpriv->ai_urbs)
+	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
+				   GFP_KERNEL);
+	if (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||
+	    !devpriv->ai_urbs || !devpriv->ao_urbs)
 		return -ENOMEM;
 
 	for (i = 0; i < devpriv->n_ai_urbs; i++) {
@@ -1595,9 +1585,7 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		devpriv->ai_urbs[i] = urb;
 
 		urb->dev = usb;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
+		urb->context = dev;
 		urb->pipe = usb_rcvisocpipe(usb, 6);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
@@ -1611,12 +1599,6 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		urb->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
-	/* out urbs */
-	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
-				   GFP_KERNEL);
-	if (!devpriv->ao_urbs)
-		return -ENOMEM;
-
 	for (i = 0; i < devpriv->n_ao_urbs; i++) {
 		/* one frame: 1ms */
 		urb = usb_alloc_urb(1, GFP_KERNEL);
@@ -1625,9 +1607,7 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		devpriv->ao_urbs[i] = urb;
 
 		urb->dev = usb;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
+		urb->context = dev;
 		urb->pipe = usb_sndisocpipe(usb, 2);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);

commit 89878614e24329209bf0d4efbb09fb5e431e7eb0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:45:47 2013 -0700

    staging: comedi: usbdux: return void from usbdux_pwm_pattern()
    
    This function never fails and currently returns '1' so that the
    usbdux_pwm_write() function returns to proper value (insn->n).
    
    It's also called by usbdux_pwm_config() which also returns the '1'
    value. The proper return code for this function should be '0' to
    indicate success.
    
    Change the return type of the function to void and just have the
    callers return the proper values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index b1fe32934e38..9dcb2978922f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1396,11 +1396,11 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbdux_pwm_pattern(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      unsigned int chan,
-			      unsigned int value,
-			      unsigned int sign)
+static void usbdux_pwm_pattern(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned int chan,
+			       unsigned int value,
+			       unsigned int sign)
 {
 	struct usbdux_private *devpriv = dev->private;
 	char pwm_mask = (1 << chan);	/* DIO bit for the PWM data */
@@ -1421,7 +1421,6 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 			c |= sgn_mask;
 		*buf++ = c;
 	}
-	return 1;
 }
 
 static int usbdux_pwm_write(struct comedi_device *dev,
@@ -1442,7 +1441,9 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 	 * The sign is set via a special INSN only, this gives us 8 bits
 	 * for normal operation, sign is 0 by default.
 	 */
-	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
+	usbdux_pwm_pattern(dev, s, chan, data[0], 0);
+
+	return insn->n;
 }
 
 static int usbdux_pwm_config(struct comedi_device *dev,
@@ -1477,8 +1478,8 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 		 * data[1] = value
 		 * data[2] = sign (for a relay)
 		 */
-		return usbdux_pwm_pattern(dev, s, chan,
-					  data[1], (data[2] != 0));
+		usbdux_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));
+		return 0;
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
 		/* values are not kept in this driver, nothing to return here */
 		return -EINVAL;

commit 893a27785c93ac76514cceb812eb41d059cd8f55
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:45:28 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_pwm_config()
    
    Rename the local variable used for the private data pointer to 'devpriv'.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9f97e3e1f1c6..b1fe32934e38 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1445,15 +1445,16 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
 }
 
-/* switches on/off PWM */
 static int usbdux_pwm_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
-		/* switch it on */
 		/*
 		 * if not zero the PWM is limited to a certain time which is
 		 * not supported here
@@ -1464,27 +1465,20 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	case INSN_CONFIG_DISARM:
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
-		/*
-		 * to check if the USB transmission has failed or in case PWM
-		 * was limited to n cycles to check if it has terminated
-		 */
-		data[1] = this_usbduxsub->pwm_cmd_running;
+		data[1] = devpriv->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
-		data[1] = this_usbduxsub->pwm_period;
+		data[1] = devpriv->pwm_period;
 		return 0;
 	case INSN_CONFIG_PWM_SET_H_BRIDGE:
-		/* value in the first byte and the sign in the second for a
-		   relay */
-		return usbdux_pwm_pattern(dev, s,
-					  /* the channel number */
-					  CR_CHAN(insn->chanspec),
-					  /* actual PWM data */
-					  data[1],
-					  /* just a sign */
-					  (data[2] != 0));
+		/*
+		 * data[1] = value
+		 * data[2] = sign (for a relay)
+		 */
+		return usbdux_pwm_pattern(dev, s, chan,
+					  data[1], (data[2] != 0));
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
 		/* values are not kept in this driver, nothing to return here */
 		return -EINVAL;

commit 64ffc665d7172ce9f13b6ad5fca107e8847d68d1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:45:09 2013 -0700

    staging: comedi: usbdux: remove usbdux_pwm_read()
    
    The pwm subdevice is not readable so this callback function is not
    needed. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 214a49f23ec5..9f97e3e1f1c6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1445,14 +1445,6 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
 }
 
-static int usbdux_pwm_read(struct comedi_device *x1,
-			   struct comedi_subdevice *x2, struct comedi_insn *x3,
-			   unsigned int *x4)
-{
-	/* not needed */
-	return -EINVAL;
-};
-
 /* switches on/off PWM */
 static int usbdux_pwm_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
@@ -1819,7 +1811,6 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		s->n_chan	= 8;
 		s->maxdata	= devpriv->pwm_buf_sz;
 		s->insn_write	= usbdux_pwm_write;
-		s->insn_read	= usbdux_pwm_read;
 		s->insn_config	= usbdux_pwm_config;
 
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);

commit 5c63f094a75820b85f7aecf6ee84439d610017c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:44:50 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_pwm_write()
    
    Remove the sanity check of the private data. This function can only be
    called if the private data was successfully allocated in the attach.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 72094d9abba7..214a49f23ec5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1426,27 +1426,23 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 
 static int usbdux_pwm_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn,
+			    unsigned int *data)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
-	if ((insn->n) != 1) {
-		/*
-		 * doesn't make sense to have more than one value here because
-		 * it would just overwrite the PWM buffer a couple of times
-		 */
+	/*
+	 * It doesn't make sense to support more than one value here
+	 * because it would just overwrite the PWM buffer.
+	 */
+	if (insn->n != 1)
 		return -EINVAL;
-	}
 
 	/*
-	 * the sign is set via a special INSN only, this gives us 8 bits for
-	 * normal operation
-	 * relay sign 0 by default
+	 * The sign is set via a special INSN only, this gives us 8 bits
+	 * for normal operation, sign is 0 by default.
 	 */
-	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
+	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
 }
 
 static int usbdux_pwm_read(struct comedi_device *x1,

commit 3b2dc08b72a80009887a0e0b80d63fdaa1f2a8a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:44:32 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_pwm_pattern()
    
    Rename the local variable used for the private data pointer to 'devpriv'.
    
    Remove the sanity check of the private data. This function can only be
    called if the private data was successfully allocated in the attach.
    
    Tidy up the function to make it more concise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0683c8e644bb..72094d9abba7 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1396,45 +1396,30 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	return ret;
 }
 
-/* generates the bit pattern for PWM with the optional sign bit */
 static int usbdux_pwm_pattern(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int channel,
-			      unsigned int value, unsigned int sign)
+			      struct comedi_subdevice *s,
+			      unsigned int chan,
+			      unsigned int value,
+			      unsigned int sign)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int i, szbuf;
-	char *p_buf;
-	char pwm_mask;
-	char sgn_mask;
-	char c;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	char pwm_mask = (1 << chan);	/* DIO bit for the PWM data */
+	char sgn_mask = (16 << chan);	/* DIO bit for the sign */
+	char *buf = (char *)(devpriv->pwm_urb->transfer_buffer);
+	int szbuf = devpriv->pwm_buf_sz;
+	int i;
 
-	/* this is the DIO bit which carries the PWM data */
-	pwm_mask = (1 << channel);
-	/* this is the DIO bit which carries the optional direction bit */
-	sgn_mask = (16 << channel);
-	/* this is the buffer which will be filled with the with bit */
-	/* pattern for one period */
-	szbuf = this_usbduxsub->pwm_buf_sz;
-	p_buf = (char *)(this_usbduxsub->pwm_urb->transfer_buffer);
 	for (i = 0; i < szbuf; i++) {
-		c = *p_buf;
-		/* reset bits */
-		c = c & (~pwm_mask);
-		/* set the bit as long as the index is lower than the value */
+		char c = *buf;
+
+		c &= ~pwm_mask;
 		if (i < value)
-			c = c | pwm_mask;
-		/* set the optional sign bit for a relay */
-		if (!sign) {
-			/* positive value */
-			c = c & (~sgn_mask);
-		} else {
-			/* negative value */
-			c = c | sgn_mask;
-		}
-		*(p_buf++) = c;
+			c |= pwm_mask;
+		if (!sign)
+			c &= ~sgn_mask;
+		else
+			c |= sgn_mask;
+		*buf++ = c;
 	}
 	return 1;
 }

commit 9fe4df4db1350a5075b617bfda40b423f161bb6f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:44:14 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_pwm_period()
    
    Rename the local variable used for the private data pointer to 'devpriv'.
    
    Fix the fx2delay calculation so it does not use floating point values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bf6c9ffa93ee..0683c8e644bb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1347,20 +1347,21 @@ static int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)
 }
 
 static int usbdux_pwm_period(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int period)
+			     struct comedi_subdevice *s,
+			     unsigned int period)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
 		return -EAGAIN;
 	} else {
-		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
+		fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
 		if (fx2delay > 255)
 			return -EAGAIN;
 	}
-	this_usbduxsub->pwm_delay = fx2delay;
-	this_usbduxsub->pwm_period = period;
+	devpriv->pwm_delay = fx2delay;
+	devpriv->pwm_period = period;
 
 	return 0;
 }

commit d0b31b8b92fc246bdd2b85bba38a28a8343f4909
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:43:16 2013 -0700

    staging: comedi: usbdux: generalize the usb_submit_urb functions
    
    Generalize a helper function to replace usbduxsub_submit_{in,out}urbs().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7ff731fd804a..bf6c9ffa93ee 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -531,7 +531,9 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_inurbs(struct comedi_device *dev)
+static int usbdux_submit_urbs(struct comedi_device *dev,
+			      struct urb **urbs, int num_urbs,
+			      int input_urb)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
@@ -540,35 +542,12 @@ static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 	int i;
 
 	/* Submit all URBs and start the transfer on the bus */
-	for (i = 0; i < devpriv->n_ai_urbs; i++) {
-		urb = devpriv->ai_urbs[i];
-
-		/* in case of a resubmission after an unlink... */
-		urb->interval = devpriv->ai_interval;
-		urb->context = dev;
-		urb->dev = usb;
-		urb->status = 0;
-		urb->transfer_flags = URB_ISO_ASAP;
-
-		ret = usb_submit_urb(urb, GFP_ATOMIC);
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-static int usbduxsub_submit_outurbs(struct comedi_device *dev)
-{
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	struct usbdux_private *devpriv = dev->private;
-	struct urb *urb;
-	int ret;
-	int i;
-
-	for (i = 0; i < devpriv->n_ao_urbs; i++) {
-		urb = devpriv->ao_urbs[i];
+	for (i = 0; i < num_urbs; i++) {
+		urb = urbs[i];
 
 		/* in case of a resubmission after an unlink... */
+		if (input_urb)
+			urb->interval = devpriv->ai_interval;
 		urb->context = dev;
 		urb->dev = usb;
 		urb->status = 0;
@@ -725,7 +704,8 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxsub_submit_inurbs(dev);
+		ret = usbdux_submit_urbs(dev, devpriv->ai_urbs,
+					 devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
 			goto ai_trig_exit;
@@ -807,7 +787,8 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		devpriv->ai_cmd_running = 1;
-		ret = usbduxsub_submit_inurbs(dev);
+		ret = usbdux_submit_urbs(dev, devpriv->ai_urbs,
+					 devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
@@ -944,7 +925,8 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 
 	if (!devpriv->ao_cmd_running) {
 		devpriv->ao_cmd_running = 1;
-		ret = usbduxsub_submit_outurbs(dev);
+		ret = usbdux_submit_urbs(dev, devpriv->ao_urbs,
+					 devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			devpriv->ao_cmd_running = 0;
 			goto ao_trig_exit;
@@ -1105,7 +1087,8 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		devpriv->ao_cmd_running = 1;
-		ret = usbduxsub_submit_outurbs(dev);
+		ret = usbdux_submit_urbs(dev, devpriv->ao_urbs,
+					 devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			devpriv->ao_cmd_running = 0;
 			/* fixme: unlink here?? */

commit 0c4349c91625188930f12382b061399827bf4da6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:12:30 2013 -0700

    staging: comedi: usbdux: consolidate usbduxsub_unlink_{in, out}urbs()
    
    These functions are identical other than the which and how many urbs
    are unlinked.
    
    Consolidate the functions into one usbdux_unlink_urbs() function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index b94c655e374a..7ff731fd804a 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -229,23 +229,20 @@ struct usbdux_private {
 	struct semaphore sem;
 };
 
-static void usbduxsub_unlink_inurbs(struct comedi_device *dev)
+static void usbdux_unlink_urbs(struct urb **urbs, int num_urbs)
 {
-	struct usbdux_private *devpriv = dev->private;
 	int i;
 
-	if (devpriv->ai_urbs) {
-		for (i = 0; i < devpriv->n_ai_urbs; i++)
-			usb_kill_urb(devpriv->ai_urbs[i]);
-	}
+	for (i = 0; i < num_urbs; i++)
+		usb_kill_urb(urbs[i]);
 }
 
 static void usbdux_ai_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbdux_private *devpriv = dev->private;
 
-	if (do_unlink)
-		usbduxsub_unlink_inurbs(dev);
+	if (do_unlink && devpriv->ai_urbs)
+		usbdux_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);
 
 	devpriv->ai_cmd_running = 0;
 }
@@ -389,23 +386,12 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	comedi_event(dev, s);
 }
 
-static void usbduxsub_unlink_outurbs(struct comedi_device *dev)
-{
-	struct usbdux_private *devpriv = dev->private;
-	int i;
-
-	if (devpriv->ao_urbs) {
-		for (i = 0; i < devpriv->n_ao_urbs; i++)
-			usb_kill_urb(devpriv->ao_urbs[i]);
-	}
-}
-
 static void usbdux_ao_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbdux_private *devpriv = dev->private;
 
-	if (do_unlink)
-		usbduxsub_unlink_outurbs(dev);
+	if (do_unlink && devpriv->ao_urbs)
+		usbdux_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);
 
 	devpriv->ao_cmd_running = 0;
 }

commit 757fbc2a782276086088e4e6237fb66dac1f41a3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:12:05 2013 -0700

    staging: comedi: usbdux: move and rename the bulk transfer commands
    
    For aesthetic reasons, move the defines used for the bulk transfer
    commands out of the middle of the code and rename them so they are
    a bit more readable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0558613aa2c7..b94c655e374a 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -99,6 +99,17 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define VENDOR_DIR_OUT		0x40
 #define USBDUX_CPU_CS		0xe600
 
+/* usbdux bulk transfer commands */
+#define USBDUX_CMD_MULT_AI	0
+#define USBDUX_CMD_AO		1
+#define USBDUX_CMD_DIO_CFG	2
+#define USBDUX_CMD_DIO_BITS	3
+#define USBDUX_CMD_SINGLE_AI	4
+#define USBDUX_CMD_TIMER_RD	5
+#define USBDUX_CMD_TIMER_WR	6
+#define USBDUX_CMD_PWM_ON	7
+#define USBDUX_CMD_PWM_OFF	8
+
 #define USBDUX_NUM_AO_CHAN	4
 
 /* timeout for the USB-transfer in ms */
@@ -680,18 +691,6 @@ static int8_t create_adc_command(unsigned int chan, int range)
 	return (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);
 }
 
-/* bulk transfers to usbdux */
-
-#define SENDADCOMMANDS            0
-#define SENDDACOMMANDS            1
-#define SENDDIOCONFIGCOMMAND      2
-#define SENDDIOBITSCOMMAND        3
-#define SENDSINGLEAD              4
-#define READCOUNTERCOMMAND        5
-#define WRITECOUNTERCOMMAND       6
-#define SENDPWMON                 7
-#define SENDPWMOFF                8
-
 static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
@@ -780,7 +779,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->dux_commands[i + 2] = create_adc_command(chan, range);
 	}
 
-	ret = send_dux_commands(dev, SENDADCOMMANDS);
+	ret = send_dux_commands(dev, USBDUX_CMD_MULT_AI);
 	if (ret < 0)
 		goto ai_cmd_exit;
 
@@ -864,12 +863,12 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	devpriv->dux_commands[1] = create_adc_command(chan, range);
 
 	/* adc commands */
-	ret = send_dux_commands(dev, SENDSINGLEAD);
+	ret = send_dux_commands(dev, USBDUX_CMD_SINGLE_AI);
 	if (ret < 0)
 		goto ai_read_exit;
 
 	for (i = 0; i < insn->n; i++) {
-		ret = receive_dux_commands(dev, SENDSINGLEAD);
+		ret = receive_dux_commands(dev, USBDUX_CMD_SINGLE_AI);
 		if (ret < 0)
 			goto ai_read_exit;
 
@@ -933,7 +932,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		/* one 16 bit value */
 		*p = cpu_to_le16(val);
 
-		ret = send_dux_commands(dev, SENDDACOMMANDS);
+		ret = send_dux_commands(dev, USBDUX_CMD_AO);
 		if (ret < 0)
 			goto ao_write_exit;
 	}
@@ -1192,10 +1191,10 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	 * This command also tells the firmware to return
 	 * the digital input lines.
 	 */
-	ret = send_dux_commands(dev, SENDDIOBITSCOMMAND);
+	ret = send_dux_commands(dev, USBDUX_CMD_DIO_BITS);
 	if (ret < 0)
 		goto dio_exit;
-	ret = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
+	ret = receive_dux_commands(dev, USBDUX_CMD_DIO_BITS);
 	if (ret < 0)
 		goto dio_exit;
 
@@ -1220,10 +1219,10 @@ static int usbdux_counter_read(struct comedi_device *dev,
 	down(&devpriv->sem);
 
 	for (i = 0; i < insn->n; i++) {
-		ret = send_dux_commands(dev, READCOUNTERCOMMAND);
+		ret = send_dux_commands(dev, USBDUX_CMD_TIMER_RD);
 		if (ret < 0)
 			goto counter_read_exit;
-		ret = receive_dux_commands(dev, READCOUNTERCOMMAND);
+		ret = receive_dux_commands(dev, USBDUX_CMD_TIMER_RD);
 		if (ret < 0)
 			goto counter_read_exit;
 
@@ -1254,7 +1253,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 	for (i = 0; i < insn->n; i++) {
 		*p = cpu_to_le16(data[i]);
 
-		ret = send_dux_commands(dev, WRITECOUNTERCOMMAND);
+		ret = send_dux_commands(dev, USBDUX_CMD_TIMER_WR);
 		if (ret < 0)
 			break;
 	}
@@ -1298,7 +1297,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
 	usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
-	ret = send_dux_commands(dev, SENDPWMOFF);
+	ret = send_dux_commands(dev, USBDUX_CMD_PWM_OFF);
 	up(&devpriv->sem);
 
 	return ret;
@@ -1409,7 +1408,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 		goto pwm_start_exit;
 
 	devpriv->dux_commands[1] = devpriv->pwm_delay;
-	ret = send_dux_commands(dev, SENDPWMON);
+	ret = send_dux_commands(dev, USBDUX_CMD_PWM_ON);
 	if (ret < 0)
 		goto pwm_start_exit;
 

commit c2141c5b084781063d6f94680c46abcf2b5673c8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:11:46 2013 -0700

    staging: comedi: usbdux: remove unused define
    
    This define is not used, and it's actually incorrect. The usbdux device
    only has 4 analog output channels.
    
    Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9529324fbace..0558613aa2c7 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -122,9 +122,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* 16 bytes. */
 #define SIZEINSNBUF       16
 
-/* Number of DA channels */
-#define NUMOUTCHANNELS    8
-
 /* size of one value for the D/A converter: channel and value */
 #define SIZEDAOUT          ((sizeof(int8_t)+sizeof(int16_t)))
 

commit c5bbfe500be3c8f9f45d45b1ac644271761610a1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:11:28 2013 -0700

    staging: comedi: usbdux: 'dac_commands' does not need to be kzalloc()'d
    
    The 'dac_commands' buffer is used to pass the ao channel list from
    usbdux_ao_cmd() to the urb callback, usbduxsub_ao_isoc_irq(). This
    buffer does not need to be allocated.
    
    Change it into a simple array of the correct size. Rename the variable
    to 'ao_chanlist' to clarify what it actually is.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 80cfa80ba650..9529324fbace 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -195,6 +195,7 @@ struct usbdux_private {
 	/* input buffer for single insn */
 	int16_t *insn_buf;
 
+	int8_t ao_chanlist[USBDUX_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUX_NUM_AO_CHAN];
 
 	unsigned int high_speed:1;
@@ -215,8 +216,6 @@ struct usbdux_private {
 	unsigned int ao_counter;
 	/* interval in frames/uframes */
 	unsigned int ai_interval;
-	/* D/A commands */
-	int8_t *dac_commands;
 	/* commands */
 	int8_t *dux_commands;
 	struct semaphore sem;
@@ -489,7 +488,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		len = s->async->cmd.chanlist_len;
 		*datap++ = len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
-			unsigned int chan = devpriv->dac_commands[i];
+			unsigned int chan = devpriv->ao_chanlist[i];
 			short val;
 
 			ret = comedi_buf_get(s->async, &val);
@@ -1080,7 +1079,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 
-		devpriv->dac_commands[i] = chan << 6;
+		devpriv->ao_chanlist[i] = chan << 6;
 	}
 
 	/* we count in steps of 1ms (125us) */
@@ -1633,11 +1632,6 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	struct urb *urb;
 	int i;
 
-	/* create space for the commands of the DA converter */
-	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
-	if (!devpriv->dac_commands)
-		return -ENOMEM;
-
 	/* create space for the commands going to the usb device */
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!devpriv->dux_commands)
@@ -1770,7 +1764,6 @@ static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
 	kfree(devpriv->insn_buf);
 	kfree(devpriv->in_buf);
 	kfree(devpriv->dux_commands);
-	kfree(devpriv->dac_commands);
 }
 
 static int usbdux_auto_attach(struct comedi_device *dev,

commit 66ce147c7d40b77704b44b6b2071d91f7c510b33
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:11:10 2013 -0700

    staging: comedi: usbdux: remove unnecessary check in usbdux_ao_cmd()
    
    This check is not necessary. The cmd->chanlist_len will always be
    less than or equal to the subdevice len_chanlist that was setup
    during the attach of the device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 3fc61d134acb..80cfa80ba650 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1080,9 +1080,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 
-		if (i >= NUMOUTCHANNELS)
-			break;
-
 		devpriv->dac_commands[i] = chan << 6;
 	}
 

commit b979e485b4b9ed7aff8a987f3638b3be5983268c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:10:43 2013 -0700

    staging: comedi: usbdux: remove unnecessary check in usbdux_ai_cmd()
    
    This check is not necessary. The cmd->chanlist_len will always be
    less than or equal to the subdevice len_chanlist that was setup
    during the attach of the device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cb94964cc9ba..3fc61d134acb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -110,9 +110,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* Default PWM frequency */
 #define PWM_DEFAULT_PERIOD ((long)(1E9/100))
 
-/* Number of channels */
-#define NUMCHANNELS       8
-
 /* Size of one A/D value */
 #define SIZEADIN          ((sizeof(int16_t)))
 
@@ -784,9 +781,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 		unsigned int range = CR_RANGE(cmd->chanlist[i]);
 
-		if (i >= NUMCHANNELS)
-			break;
-
 		devpriv->dux_commands[i + 2] = create_adc_command(chan, range);
 	}
 

commit c769f85e2740ebe7e4c726632fed52818640faba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:10:25 2013 -0700

    staging: comedi: usbdux: simplify initializing the ao urb transfer_buffer
    
    Remove the ugly casting of datap to the ao urb->transfer_buffer. The format
    of the data in the buffer is simply.
    
      [0] = # of channels to update (s->async->cmd.chanlist.len)
      [1] = lsb of value for 1st channel to update
      [2] = msb of value for 1st channel to update
      [3] = 1st channel to update (depvriv->dac_commands[0])
    
    If more than 1 channel is to be updated they are simply added to the buffer:
    
      [4] = lsb of value for 2st channel to update
      [5] = msb of value for 2st channel to update
      [6] = 1st channel to update (depvriv->dac_commands[1])
    
    etc.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1399305d739f..cb94964cc9ba 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -425,8 +425,10 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct usbdux_private *devpriv = dev->private;
-	int i, ret;
 	int8_t *datap;
+	int len;
+	int ret;
+	int i;
 
 	switch (urb->status) {
 	case 0:
@@ -484,9 +486,11 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 				return;
 			}
 		}
+
 		/* transmit data to the USB bus */
-		((uint8_t *) (urb->transfer_buffer))[0] =
-		    s->async->cmd.chanlist_len;
+		datap = urb->transfer_buffer;
+		len = s->async->cmd.chanlist_len;
+		*datap++ = len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 			unsigned int chan = devpriv->dac_commands[i];
 			short val;
@@ -498,12 +502,9 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 						     COMEDI_CB_OVERFLOW);
 			}
 			/* pointer to the DA */
-			datap =
-			    (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
-			/* get the data from comedi */
-			datap[0] = val;
-			datap[1] = val >> 8;
-			datap[2] = chan;
+			*datap++ = val & 0xff;
+			*datap++ = (val >> 8) & 0xff;
+			*datap++ = chan;
 			devpriv->ao_readback[chan] = val;
 
 			s->async->events |= COMEDI_CB_BLOCK;

commit a998a3db530bff8094476e82e28c801b09f7aa9e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:10:07 2013 -0700

    staging: comedi: usbdux: cleanup the private data 'outBuffer'
    
    This buffer is used to cache the values that are written to the
    analog output channels. Currently it only caches the single writes
    to the channels using the (*insn_write) callback. The async command
    writes are not cached. The buffer is also being kzalloc'ed during
    the attach of the driver to a size much larger that required.
    
    Rename the CamelCase buffer and change it to an array in the private
    data of the correct size to cache the analog output channel values.
    
    Modify the analog output urb callback so it updates the cached values
    with those used for the asynchronous command to allow readback after
    the command completes.
    
    The sanity check of the index to dac_commands[] (i.e. the 'chan' being
    written) is not needed. The chanlist_len will always be less than the
    number of channels.
    
    Also, fix the dev_err() message so it uses the proper device pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bd46bec73d7b..1399305d739f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -99,6 +99,8 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define VENDOR_DIR_OUT		0x40
 #define USBDUX_CPU_CS		0xe600
 
+#define USBDUX_NUM_AO_CHAN	4
+
 /* timeout for the USB-transfer in ms */
 #define BULK_TIMEOUT		1000
 
@@ -195,8 +197,8 @@ struct usbdux_private {
 	int16_t *in_buf;
 	/* input buffer for single insn */
 	int16_t *insn_buf;
-	/* output buffer for single DA outputs */
-	int16_t *out_buffer;
+
+	unsigned int ao_readback[USBDUX_NUM_AO_CHAN];
 
 	unsigned int high_speed:1;
 	unsigned int ai_cmd_running:1;
@@ -486,25 +488,24 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		((uint8_t *) (urb->transfer_buffer))[0] =
 		    s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
-			short temp;
-			if (i >= NUMOUTCHANNELS)
-				break;
+			unsigned int chan = devpriv->dac_commands[i];
+			short val;
 
+			ret = comedi_buf_get(s->async, &val);
+			if (ret < 0) {
+				dev_err(dev->class_dev, "buffer underflow\n");
+				s->async->events |= (COMEDI_CB_EOA |
+						     COMEDI_CB_OVERFLOW);
+			}
 			/* pointer to the DA */
 			datap =
 			    (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
 			/* get the data from comedi */
-			ret = comedi_buf_get(s->async, &temp);
-			datap[0] = temp;
-			datap[1] = temp >> 8;
-			datap[2] = devpriv->dac_commands[i];
-			if (ret < 0) {
-				dev_err(&urb->dev->dev,
-					"comedi: buffer underflow\n");
-				s->async->events |= COMEDI_CB_EOA;
-				s->async->events |= COMEDI_CB_OVERFLOW;
-			}
-			/* transmit data to comedi */
+			datap[0] = val;
+			datap[1] = val >> 8;
+			datap[2] = chan;
+			devpriv->ao_readback[chan] = val;
+
 			s->async->events |= COMEDI_CB_BLOCK;
 			comedi_event(dev, s);
 		}
@@ -907,7 +908,7 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->out_buffer[chan];
+		data[i] = devpriv->ao_readback[chan];
 	up(&devpriv->sem);
 
 	return insn->n;
@@ -920,7 +921,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 {
 	struct usbdux_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val = devpriv->out_buffer[chan];
+	unsigned int val = devpriv->ao_readback[chan];
 	int16_t *p = (int16_t *)&devpriv->dux_commands[2];
 	int ret = -EBUSY;
 	int i;
@@ -945,7 +946,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		if (ret < 0)
 			goto ao_write_exit;
 	}
-	devpriv->out_buffer[chan] = val;
+	devpriv->ao_readback[chan] = val;
 
 ao_write_exit:
 	up(&devpriv->sem);
@@ -1660,11 +1661,6 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	if (!devpriv->insn_buf)
 		return -ENOMEM;
 
-	/* create space for the outbuffer */
-	devpriv->out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!devpriv->out_buffer)
-		return -ENOMEM;
-
 	/* in urbs */
 	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
 				   GFP_KERNEL);
@@ -1779,7 +1775,6 @@ static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
 		}
 		kfree(devpriv->ai_urbs);
 	}
-	kfree(devpriv->out_buffer);
 	kfree(devpriv->insn_buf);
 	kfree(devpriv->in_buf);
 	kfree(devpriv->dux_commands);
@@ -1854,9 +1849,9 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	dev->write_subdev = s;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= 4;
+	s->n_chan	= USBDUX_NUM_AO_CHAN;
 	s->maxdata	= 0x0fff;
-	s->len_chanlist	= 4;
+	s->len_chanlist	= s->n_chan;
 	s->range_table	= &range_usbdux_ao_range;
 	s->do_cmdtest	= usbdux_ao_cmdtest;
 	s->do_cmd	= usbdux_ao_cmd;

commit c79bc875537d5d9ef396b3a4b7e2bf2b28bd9945
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:09:48 2013 -0700

    staging: comedi: usbdux: rename private data variables
    
    The usbdux and usbduxsigma drivers are _very_ similar. For aesthetic
    reasons, rename the private data variables in this driver to match
    the names in the usbduxsigma driver so we can start sharing the
    common code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 20b705e87d48..bd46bec73d7b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -177,24 +177,24 @@ static const struct comedi_lrange range_usbdux_ao_range = {
 
 struct usbdux_private {
 	/* actual number of in-buffers */
-	int num_in_buffers;
+	int n_ai_urbs;
 	/* actual number of out-buffers */
-	int num_out_buffers;
+	int n_ao_urbs;
 	/* ISO-transfer handling: buffers */
-	struct urb **urb_in;
-	struct urb **urb_out;
+	struct urb **ai_urbs;
+	struct urb **ao_urbs;
 	/* pwm-transfer handling */
-	struct urb *urb_pwm;
+	struct urb *pwm_urb;
 	/* PWM period */
 	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	int8_t pwn_delay;
+	int8_t pwm_delay;
 	/* size of the PWM buffer which holds the bit pattern */
-	int size_pwm_buf;
+	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	int16_t *in_buffer;
+	int16_t *in_buf;
 	/* input buffer for single insn */
-	int16_t *insn_buffer;
+	int16_t *insn_buf;
 	/* output buffer for single DA outputs */
 	int16_t *out_buffer;
 
@@ -228,9 +228,9 @@ static void usbduxsub_unlink_inurbs(struct comedi_device *dev)
 	struct usbdux_private *devpriv = dev->private;
 	int i;
 
-	if (devpriv->urb_in) {
-		for (i = 0; i < devpriv->num_in_buffers; i++)
-			usb_kill_urb(devpriv->urb_in[i]);
+	if (devpriv->ai_urbs) {
+		for (i = 0; i < devpriv->n_ai_urbs; i++)
+			usb_kill_urb(devpriv->ai_urbs[i]);
 	}
 }
 
@@ -270,7 +270,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
-		memcpy(devpriv->in_buffer, urb->transfer_buffer, SIZEINBUF);
+		memcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
 		/* error in the ISOchronous data */
@@ -364,7 +364,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	n = s->async->cmd.chanlist_len;
 	for (i = 0; i < n; i++) {
 		unsigned int range = CR_RANGE(s->async->cmd.chanlist[i]);
-		int16_t val = le16_to_cpu(devpriv->in_buffer[i]);
+		int16_t val = le16_to_cpu(devpriv->in_buf[i]);
 
 		/* bipolar data is two's-complement */
 		if (comedi_range_is_bipolar(s, range))
@@ -388,9 +388,9 @@ static void usbduxsub_unlink_outurbs(struct comedi_device *dev)
 	struct usbdux_private *devpriv = dev->private;
 	int i;
 
-	if (devpriv->urb_out) {
-		for (i = 0; i < devpriv->num_out_buffers; i++)
-			usb_kill_urb(devpriv->urb_out[i]);
+	if (devpriv->ao_urbs) {
+		for (i = 0; i < devpriv->n_ao_urbs; i++)
+			usb_kill_urb(devpriv->ao_urbs[i]);
 	}
 }
 
@@ -548,8 +548,8 @@ static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 	int i;
 
 	/* Submit all URBs and start the transfer on the bus */
-	for (i = 0; i < devpriv->num_in_buffers; i++) {
-		urb = devpriv->urb_in[i];
+	for (i = 0; i < devpriv->n_ai_urbs; i++) {
+		urb = devpriv->ai_urbs[i];
 
 		/* in case of a resubmission after an unlink... */
 		urb->interval = devpriv->ai_interval;
@@ -573,8 +573,8 @@ static int usbduxsub_submit_outurbs(struct comedi_device *dev)
 	int ret;
 	int i;
 
-	for (i = 0; i < devpriv->num_out_buffers; i++) {
-		urb = devpriv->urb_out[i];
+	for (i = 0; i < devpriv->n_ao_urbs; i++) {
+		urb = devpriv->ao_urbs[i];
 
 		/* in case of a resubmission after an unlink... */
 		urb->context = dev;
@@ -720,11 +720,11 @@ static int receive_dux_commands(struct comedi_device *dev, int command)
 
 	for (i = 0; i < RETRIES; i++) {
 		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),
-				      devpriv->insn_buffer, SIZEINSNBUF,
+				      devpriv->insn_buf, SIZEINSNBUF,
 				      &nrec, BULK_TIMEOUT);
 		if (ret < 0)
 			return ret;
-		if (le16_to_cpu(devpriv->insn_buffer[0]) == command)
+		if (le16_to_cpu(devpriv->insn_buf[0]) == command)
 			return ret;
 	}
 	/* command not received */
@@ -881,7 +881,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 		if (ret < 0)
 			goto ai_read_exit;
 
-		val = le16_to_cpu(devpriv->insn_buffer[1]);
+		val = le16_to_cpu(devpriv->insn_buf[1]);
 
 		/* bipolar data is two's-complement */
 		if (comedi_range_is_bipolar(s, range))
@@ -1210,7 +1210,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	if (ret < 0)
 		goto dio_exit;
 
-	data[1] = le16_to_cpu(devpriv->insn_buffer[1]);
+	data[1] = le16_to_cpu(devpriv->insn_buf[1]);
 
 dio_exit:
 	up(&devpriv->sem);
@@ -1238,7 +1238,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 		if (ret < 0)
 			goto counter_read_exit;
 
-		data[i] = le16_to_cpu(devpriv->insn_buffer[chan + 1]);
+		data[i] = le16_to_cpu(devpriv->insn_buf[chan + 1]);
 	}
 
 counter_read_exit:
@@ -1287,7 +1287,7 @@ static void usbduxsub_unlink_pwm_urbs(struct comedi_device *dev)
 {
 	struct usbdux_private *devpriv = dev->private;
 
-	usb_kill_urb(devpriv->urb_pwm);
+	usb_kill_urb(devpriv->pwm_urb);
 }
 
 static void usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)
@@ -1354,7 +1354,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	if (!devpriv->pwm_cmd_running)
 		return;
 
-	urb->transfer_buffer_length = devpriv->size_pwm_buf;
+	urb->transfer_buffer_length = devpriv->pwm_buf_sz;
 	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	if (devpriv->pwm_cmd_running) {
@@ -1377,12 +1377,12 @@ static int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
-	struct urb *urb = devpriv->urb_pwm;
+	struct urb *urb = devpriv->pwm_urb;
 
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),
 			  urb->transfer_buffer,
-			  devpriv->size_pwm_buf,
+			  devpriv->pwm_buf_sz,
 			  usbduxsub_pwm_irq,
 			  dev);
 
@@ -1402,7 +1402,7 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 		if (fx2delay > 255)
 			return -EAGAIN;
 	}
-	this_usbduxsub->pwn_delay = fx2delay;
+	this_usbduxsub->pwm_delay = fx2delay;
 	this_usbduxsub->pwm_period = period;
 
 	return 0;
@@ -1419,13 +1419,13 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	if (devpriv->pwm_cmd_running)
 		goto pwm_start_exit;
 
-	devpriv->dux_commands[1] = devpriv->pwn_delay;
+	devpriv->dux_commands[1] = devpriv->pwm_delay;
 	ret = send_dux_commands(dev, SENDPWMON);
 	if (ret < 0)
 		goto pwm_start_exit;
 
 	/* initialise the buffer */
-	memset(devpriv->urb_pwm->transfer_buffer, 0, devpriv->size_pwm_buf);
+	memset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);
 
 	devpriv->pwm_cmd_running = 1;
 	ret = usbduxsub_submit_pwm_urbs(dev);
@@ -1459,8 +1459,8 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 	sgn_mask = (16 << channel);
 	/* this is the buffer which will be filled with the with bit */
 	/* pattern for one period */
-	szbuf = this_usbduxsub->size_pwm_buf;
-	p_buf = (char *)(this_usbduxsub->urb_pwm->transfer_buffer);
+	szbuf = this_usbduxsub->pwm_buf_sz;
+	p_buf = (char *)(this_usbduxsub->pwm_urb->transfer_buffer);
 	for (i = 0; i < szbuf; i++) {
 		c = *p_buf;
 		/* reset bits */
@@ -1651,13 +1651,13 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		return -ENOMEM;
 
 	/* create space for the in buffer and set it to zero */
-	devpriv->in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->in_buffer)
+	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->in_buf)
 		return -ENOMEM;
 
 	/* create space of the instruction buffer */
-	devpriv->insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insn_buffer)
+	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insn_buf)
 		return -ENOMEM;
 
 	/* create space for the outbuffer */
@@ -1666,17 +1666,17 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		return -ENOMEM;
 
 	/* in urbs */
-	devpriv->urb_in = kcalloc(devpriv->num_in_buffers, sizeof(*urb),
-				  GFP_KERNEL);
-	if (!devpriv->urb_in)
+	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
+				   GFP_KERNEL);
+	if (!devpriv->ai_urbs)
 		return -ENOMEM;
 
-	for (i = 0; i < devpriv->num_in_buffers; i++) {
+	for (i = 0; i < devpriv->n_ai_urbs; i++) {
 		/* one frame: 1ms */
 		urb = usb_alloc_urb(1, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urb_in[i] = urb;
+		devpriv->ai_urbs[i] = urb;
 
 		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
@@ -1696,17 +1696,17 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	}
 
 	/* out urbs */
-	devpriv->urb_out = kcalloc(devpriv->num_out_buffers, sizeof(*urb),
+	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
 				   GFP_KERNEL);
-	if (!devpriv->urb_out)
+	if (!devpriv->ao_urbs)
 		return -ENOMEM;
 
-	for (i = 0; i < devpriv->num_out_buffers; i++) {
+	for (i = 0; i < devpriv->n_ao_urbs; i++) {
 		/* one frame: 1ms */
 		urb = usb_alloc_urb(1, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urb_out[i] = urb;
+		devpriv->ao_urbs[i] = urb;
 
 		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
@@ -1730,14 +1730,14 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 	}
 
 	/* pwm */
-	if (devpriv->size_pwm_buf) {
+	if (devpriv->pwm_buf_sz) {
 		urb = usb_alloc_urb(0, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urb_pwm = urb;
+		devpriv->pwm_urb = urb;
 
 		/* max bulk ep size in high speed */
-		urb->transfer_buffer = kzalloc(devpriv->size_pwm_buf,
+		urb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,
 					       GFP_KERNEL);
 		if (!urb->transfer_buffer)
 			return -ENOMEM;
@@ -1751,37 +1751,37 @@ static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
 	struct urb *urb;
 	int i;
 
-	urb = devpriv->urb_pwm;
+	urb = devpriv->pwm_urb;
 	if (urb) {
 		kfree(urb->transfer_buffer);
 		usb_kill_urb(urb);
 		usb_free_urb(urb);
 	}
-	if (devpriv->urb_out) {
-		for (i = 0; i < devpriv->num_out_buffers; i++) {
-			urb = devpriv->urb_out[i];
+	if (devpriv->ao_urbs) {
+		for (i = 0; i < devpriv->n_ao_urbs; i++) {
+			urb = devpriv->ao_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
 				usb_kill_urb(urb);
 				usb_free_urb(urb);
 			}
 		}
-		kfree(devpriv->urb_out);
+		kfree(devpriv->ao_urbs);
 	}
-	if (devpriv->urb_in) {
-		for (i = 0; i < devpriv->num_in_buffers; i++) {
-			urb = devpriv->urb_in[i];
+	if (devpriv->ai_urbs) {
+		for (i = 0; i < devpriv->n_ai_urbs; i++) {
+			urb = devpriv->ai_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
 				usb_kill_urb(urb);
 				usb_free_urb(urb);
 			}
 		}
-		kfree(devpriv->urb_in);
+		kfree(devpriv->ai_urbs);
 	}
 	kfree(devpriv->out_buffer);
-	kfree(devpriv->insn_buffer);
-	kfree(devpriv->in_buffer);
+	kfree(devpriv->insn_buf);
+	kfree(devpriv->in_buf);
 	kfree(devpriv->dux_commands);
 	kfree(devpriv->dac_commands);
 }
@@ -1805,12 +1805,12 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
 	if (devpriv->high_speed) {
-		devpriv->num_in_buffers = NUMOFINBUFFERSHIGH;
-		devpriv->num_out_buffers = NUMOFOUTBUFFERSHIGH;
-		devpriv->size_pwm_buf = 512;
+		devpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;
+		devpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;
+		devpriv->pwm_buf_sz = 512;
 	} else {
-		devpriv->num_in_buffers = NUMOFINBUFFERSFULL;
-		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
+		devpriv->n_ai_urbs = NUMOFINBUFFERSFULL;
+		devpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;
 	}
 
 	ret = usbdux_alloc_usb_buffers(dev);
@@ -1890,7 +1890,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_PWM;
 		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan	= 8;
-		s->maxdata	= devpriv->size_pwm_buf;
+		s->maxdata	= devpriv->pwm_buf_sz;
 		s->insn_write	= usbdux_pwm_write;
 		s->insn_read	= usbdux_pwm_read;
 		s->insn_config	= usbdux_pwm_config;

commit 7acf26edbcba808cb6447af893f30c63751938f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:09:30 2013 -0700

    staging: comedi: usbdux: clarify bipolar ai data in usbduxsub_ai_isoc_irq()
    
    Use the comedi_range_is_bipolar() helper instead of checking the
    'range' index against a magic number.
    
    Also, use the s->maxdata to calculate the value needed to munge the
    value for bipolar data instead of the magic number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 92d740a4c295..20b705e87d48 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -363,14 +363,15 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	/* get the data from the USB bus and hand it over to comedi */
 	n = s->async->cmd.chanlist_len;
 	for (i = 0; i < n; i++) {
+		unsigned int range = CR_RANGE(s->async->cmd.chanlist[i]);
+		int16_t val = le16_to_cpu(devpriv->in_buffer[i]);
+
+		/* bipolar data is two's-complement */
+		if (comedi_range_is_bipolar(s, range))
+			val ^= ((s->maxdata + 1) >> 1);
+
 		/* transfer data */
-		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
-			err = comedi_buf_put(s->async,
-			     le16_to_cpu(devpriv->in_buffer[i]) ^ 0x800);
-		} else {
-			err = comedi_buf_put(s->async,
-			     le16_to_cpu(devpriv->in_buffer[i]));
-		}
+		err = comedi_buf_put(s->async, val);
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
 			usbdux_ai_stop(dev, 0);

commit 1731a826cad3a71062b00c80abca4f887d57e501
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:09:13 2013 -0700

    staging: comedi: usbdux: move usbdux_firmware_upload()
    
    For aesthetics, move this function closer to the (*auto_attach).
    
    Also, rename some of the defined constants that are used by the
    firmware upload.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6991e85a6d80..92d740a4c295 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -91,17 +91,16 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #include "comedi_fc.h"
 
-/* timeout for the USB-transfer in ms*/
-#define BULK_TIMEOUT 1000
+/* constants for firmware upload and download */
+#define USBDUX_FIRMWARE		"usbdux_firmware.bin"
+#define USBDUX_FIRMWARE_MAX_LEN	0x2000
+#define USBDUX_FIRMWARE_CMD	0xa0
+#define VENDOR_DIR_IN		0xc0
+#define VENDOR_DIR_OUT		0x40
+#define USBDUX_CPU_CS		0xe600
 
-/* constants for "firmware" upload and download */
-#define FIRMWARE "usbdux_firmware.bin"
-#define USBDUXSUB_FIRMWARE 0xA0
-#define VENDOR_DIR_IN  0xC0
-#define VENDOR_DIR_OUT 0x40
-
-/* internal addresses of the 8051 processor */
-#define USBDUXSUB_CPUCS 0xE600
+/* timeout for the USB-transfer in ms */
+#define BULK_TIMEOUT		1000
 
 /* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
@@ -539,80 +538,6 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	}
 }
 
-#define FIRMWARE_MAX_LEN 0x2000
-
-static int usbdux_firmware_upload(struct comedi_device *dev,
-				  const u8 *data, size_t size,
-				  unsigned long context)
-{
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	uint8_t *buf;
-	uint8_t *tmp;
-	int ret;
-
-	if (!data)
-		return 0;
-
-	if (size > FIRMWARE_MAX_LEN) {
-		dev_err(dev->class_dev,
-			"usbdux firmware binary it too large for FX2.\n");
-		return -ENOMEM;
-	}
-
-	/* we generate a local buffer for the firmware */
-	buf = kmemdup(data, size, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	/* we need a malloc'ed buffer for usb_control_msg() */
-	tmp = kmalloc(1, GFP_KERNEL);
-	if (!tmp) {
-		kfree(buf);
-		return -ENOMEM;
-	}
-
-	/* stop the current firmware on the device */
-	*tmp = 1;	/* 7f92 to one */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      USBDUXSUB_CPUCS, 0x0000,
-			      tmp, 1,
-			      BULK_TIMEOUT);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "can not stop firmware\n");
-		goto done;
-	}
-
-	/* upload the new firmware to the device */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      0, 0x0000,
-			      buf, size,
-			      BULK_TIMEOUT);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "firmware upload failed\n");
-		goto done;
-	}
-
-	/* start the new firmware on the device */
-	*tmp = 0;	/* 7f92 to zero */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      USBDUXSUB_CPUCS, 0x0000,
-			      tmp, 1,
-			      BULK_TIMEOUT);
-	if (ret < 0)
-		dev_err(dev->class_dev, "can not start firmware\n");
-
-done:
-	kfree(tmp);
-	kfree(buf);
-	return ret;
-}
-
 static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
@@ -1635,8 +1560,77 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-/* end of PWM */
-/*****************************************************************/
+static int usbdux_firmware_upload(struct comedi_device *dev,
+				  const u8 *data, size_t size,
+				  unsigned long context)
+{
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	uint8_t *buf;
+	uint8_t *tmp;
+	int ret;
+
+	if (!data)
+		return 0;
+
+	if (size > USBDUX_FIRMWARE_MAX_LEN) {
+		dev_err(dev->class_dev,
+			"usbdux firmware binary it too large for FX2.\n");
+		return -ENOMEM;
+	}
+
+	/* we generate a local buffer for the firmware */
+	buf = kmemdup(data, size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* we need a malloc'ed buffer for usb_control_msg() */
+	tmp = kmalloc(1, GFP_KERNEL);
+	if (!tmp) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	/* stop the current firmware on the device */
+	*tmp = 1;	/* 7f92 to one */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUX_FIRMWARE_CMD,
+			      VENDOR_DIR_OUT,
+			      USBDUX_CPU_CS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0) {
+		dev_err(dev->class_dev, "can not stop firmware\n");
+		goto done;
+	}
+
+	/* upload the new firmware to the device */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUX_FIRMWARE_CMD,
+			      VENDOR_DIR_OUT,
+			      0, 0x0000,
+			      buf, size,
+			      BULK_TIMEOUT);
+	if (ret < 0) {
+		dev_err(dev->class_dev, "firmware upload failed\n");
+		goto done;
+	}
+
+	/* start the new firmware on the device */
+	*tmp = 0;	/* 7f92 to zero */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUX_FIRMWARE_CMD,
+			      VENDOR_DIR_OUT,
+			      USBDUX_CPU_CS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0)
+		dev_err(dev->class_dev, "can not start firmware\n");
+
+done:
+	kfree(tmp);
+	kfree(buf);
+	return ret;
+}
 
 static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 {
@@ -1831,7 +1825,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		return ret;
 	}
 
-	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+	ret = comedi_load_firmware(dev, &usb->dev, USBDUX_FIRMWARE,
 				   usbdux_firmware_upload, 0);
 	if (ret < 0)
 		return ret;
@@ -1958,4 +1952,4 @@ module_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);
 MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
 MODULE_DESCRIPTION("Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com");
 MODULE_LICENSE("GPL");
-MODULE_FIRMWARE(FIRMWARE);
+MODULE_FIRMWARE(USBDUX_FIRMWARE);

commit 887463bb7968455396a9c61cd3673160b3ebc58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:08:52 2013 -0700

    staging: comedi: usbdux: remove some unused defines
    
    These defines are not used by the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 644f6aba1941..6991e85a6d80 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -103,16 +103,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* internal addresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
 
-/*
- * the minor device number, major is 180 only for debugging purposes and to
- * upload special firmware (programming the eeprom etc) which is not compatible
- * with the comedi framwork
- */
-#define USBDUXSUB_MINOR 32
-
-/* max lenghth of the transfer-buffer for software upload */
-#define TB_LEN 0x2000
-
 /* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
 

commit a3ef101f119b8510cb14a1f5a6bdb8639c8eb742
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:08:35 2013 -0700

    staging: comedi: usbdux: remove the usb endpoint defines
    
    The endpoint defines are each only used in one place and don't help
    clarify the code. Remove the defines and just open code the values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index f60674344ea8..644f6aba1941 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -113,21 +113,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* max lenghth of the transfer-buffer for software upload */
 #define TB_LEN 0x2000
 
-/* Input endpoint number: ISO/IRQ */
-#define ISOINEP           6
-
-/* Output endpoint number: ISO/IRQ */
-#define ISOOUTEP          2
-
-/* This EP sends DUX commands to USBDUX */
-#define COMMAND_OUT_EP     1
-
-/* This EP receives the DUX commands from USBDUX */
-#define COMMAND_IN_EP        8
-
-/* Output endpoint for PWM */
-#define PWM_EP         4
-
 /* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
 
@@ -804,7 +789,7 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 
 	devpriv->dux_commands[0] = cmd_type;
 
-	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, COMMAND_OUT_EP),
+	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),
 			    devpriv->dux_commands, SIZEOFDUXBUFFER,
 			    &nsent, BULK_TIMEOUT);
 }
@@ -818,7 +803,7 @@ static int receive_dux_commands(struct comedi_device *dev, int command)
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, COMMAND_IN_EP),
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),
 				      devpriv->insn_buffer, SIZEINSNBUF,
 				      &nrec, BULK_TIMEOUT);
 		if (ret < 0)
@@ -1479,7 +1464,7 @@ static int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)
 	struct urb *urb = devpriv->urb_pwm;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
+	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),
 			  urb->transfer_buffer,
 			  devpriv->size_pwm_buf,
 			  usbduxsub_pwm_irq,
@@ -1712,7 +1697,7 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
+		urb->pipe = usb_rcvisocpipe(usb, 6);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
@@ -1742,7 +1727,7 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
+		urb->pipe = usb_sndisocpipe(usb, 2);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)

commit ecc2b22990bd59b2e8ea34afa0334598cbdfad71
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:08:16 2013 -0700

    staging: comedi: usbdux: use the stop helpers in the detach
    
    Use the stop helpers instead of duplicating the code in the detach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7077d268f883..f60674344ea8 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1941,12 +1941,10 @@ static void usbdux_detach(struct comedi_device *dev)
 
 		usb_set_intfdata(intf, NULL);
 
-		if (devpriv->pwm_cmd_running)
-			usbduxsub_unlink_pwm_urbs(dev);
-		if (devpriv->ao_cmd_running)
-			usbduxsub_unlink_outurbs(dev);
-		if (devpriv->ai_cmd_running)
-			usbduxsub_unlink_inurbs(dev);
+		/* stop and unlink any submitted urbs */
+		usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
+		usbdux_ao_stop(dev, devpriv->ao_cmd_running);
+		usbdux_ai_stop(dev, devpriv->ai_cmd_running);
 
 		usbdux_free_usb_buffers(devpriv);
 

commit 3c50bbb7cb0ba0d66aab4446b0554bd22e76f524
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:07:57 2013 -0700

    staging: comedi: usbdux: tidy up unlink and stop helpers
    
    For aesthetic reasons, pass the comedi_device pointer to the unlink
    helpers instead of the private data pointer.
    
    All the unlink helpers simply call usb_kill_urb() to cancel any pending
    transfer requests. The usb passed to usb_kill_urb() can be NULL so the
    extra sanity check is not required.
    
    The unlink helpers will always return success so just make them void
    functions.
    
    Since the stop helpers will also always return success, make them void
    functions as well.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0337da1f36fa..7077d268f883 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -249,53 +249,39 @@ struct usbdux_private {
 	struct semaphore sem;
 };
 
-/*
- * Stops the data acquision
- * It should be safe to call this function from any context
- */
-static int usbduxsub_unlink_inurbs(struct usbdux_private *usbduxsub_tmp)
+static void usbduxsub_unlink_inurbs(struct comedi_device *dev)
 {
-	int i = 0;
-	int err = 0;
+	struct usbdux_private *devpriv = dev->private;
+	int i;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urb_in) {
-		for (i = 0; i < usbduxsub_tmp->num_in_buffers; i++) {
-			if (usbduxsub_tmp->urb_in[i]) {
-				/* We wait here until all transfers have been
-				 * cancelled. */
-				usb_kill_urb(usbduxsub_tmp->urb_in[i]);
-			}
-		}
+	if (devpriv->urb_in) {
+		for (i = 0; i < devpriv->num_in_buffers; i++)
+			usb_kill_urb(devpriv->urb_in[i]);
 	}
-	return err;
 }
 
-static int usbdux_ai_stop(struct comedi_device *dev, int do_unlink)
+static void usbdux_ai_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = 0;
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_inurbs(devpriv);
+		usbduxsub_unlink_inurbs(dev);
 
 	devpriv->ai_cmd_running = 0;
-
-	return ret;
 }
 
 static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = 0;
 
 	/* prevent other CPUs from submitting new commands just now */
 	down(&devpriv->sem);
 	/* unlink only if the urb really has been submitted */
-	ret = usbdux_ai_stop(dev, devpriv->ai_cmd_running);
+	usbdux_ai_stop(dev, devpriv->ai_cmd_running);
 	up(&devpriv->sem);
 
-	return ret;
+	return 0;
 }
 
 /* analogue IN - interrupt service routine */
@@ -422,46 +408,39 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	comedi_event(dev, s);
 }
 
-static int usbduxsub_unlink_outurbs(struct usbdux_private *usbduxsub_tmp)
+static void usbduxsub_unlink_outurbs(struct comedi_device *dev)
 {
-	int i = 0;
-	int err = 0;
+	struct usbdux_private *devpriv = dev->private;
+	int i;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urb_out) {
-		for (i = 0; i < usbduxsub_tmp->num_out_buffers; i++) {
-			if (usbduxsub_tmp->urb_out[i])
-				usb_kill_urb(usbduxsub_tmp->urb_out[i]);
-		}
+	if (devpriv->urb_out) {
+		for (i = 0; i < devpriv->num_out_buffers; i++)
+			usb_kill_urb(devpriv->urb_out[i]);
 	}
-	return err;
 }
 
-static int usbdux_ao_stop(struct comedi_device *dev, int do_unlink)
+static void usbdux_ao_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = 0;
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_outurbs(devpriv);
+		usbduxsub_unlink_outurbs(dev);
 
 	devpriv->ao_cmd_running = 0;
-
-	return ret;
 }
 
 static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = 0;
 
 	/* prevent other CPUs from submitting a command just now */
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
-	ret = usbdux_ao_stop(dev, devpriv->ao_cmd_running);
+	usbdux_ao_stop(dev, devpriv->ao_cmd_running);
 	up(&devpriv->sem);
 
-	return ret;
+	return 0;
 }
 
 static void usbduxsub_ao_isoc_irq(struct urb *urb)
@@ -1403,31 +1382,21 @@ static int usbdux_counter_config(struct comedi_device *dev,
 	return 2;
 }
 
-/***********************************/
-/* PWM */
-
-static int usbduxsub_unlink_pwm_urbs(struct usbdux_private *usbduxsub_tmp)
+static void usbduxsub_unlink_pwm_urbs(struct comedi_device *dev)
 {
-	int err = 0;
+	struct usbdux_private *devpriv = dev->private;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urb_pwm) {
-		if (usbduxsub_tmp->urb_pwm)
-			usb_kill_urb(usbduxsub_tmp->urb_pwm);
-	}
-	return err;
+	usb_kill_urb(devpriv->urb_pwm);
 }
 
-static int usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)
+static void usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbdux_private *devpriv = dev->private;
-	int ret = 0;
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_pwm_urbs(devpriv);
+		usbduxsub_unlink_pwm_urbs(dev);
 
 	devpriv->pwm_cmd_running = 0;
-
-	return ret;
 }
 
 static int usbdux_pwm_cancel(struct comedi_device *dev,
@@ -1437,15 +1406,9 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	int ret;
 
 	down(&devpriv->sem);
-
 	/* unlink only if it is really running */
-	ret = usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
-	if (ret)
-		goto pwm_cancel_exit;
-
+	usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
 	ret = send_dux_commands(dev, SENDPWMOFF);
-
-pwm_cancel_exit:
 	up(&devpriv->sem);
 
 	return ret;
@@ -1979,11 +1942,11 @@ static void usbdux_detach(struct comedi_device *dev)
 		usb_set_intfdata(intf, NULL);
 
 		if (devpriv->pwm_cmd_running)
-			usbduxsub_unlink_pwm_urbs(devpriv);
+			usbduxsub_unlink_pwm_urbs(dev);
 		if (devpriv->ao_cmd_running)
-			usbduxsub_unlink_outurbs(devpriv);
+			usbduxsub_unlink_outurbs(dev);
 		if (devpriv->ai_cmd_running)
-			usbduxsub_unlink_inurbs(devpriv);
+			usbduxsub_unlink_inurbs(dev);
 
 		usbdux_free_usb_buffers(devpriv);
 

commit 81e8013484ae0790c7819aa9e08b265807eb6905
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:07:39 2013 -0700

    staging: comedi: usbdux: fix usbdux_pwm_start()
    
    Add the missing down/up of the semaphore to prevent other commands
    from being issued to the usb device while the pwn is being stopped.
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Use memset() to initialize the urb transfer buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 14c26e559cb7..0337da1f36fa 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1544,34 +1544,34 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	return 0;
 }
 
-/* is called from insn so there's no need to do all the sanity checks */
 static int usbdux_pwm_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	int ret, i;
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
+	int ret = 0;
 
-	if (this_usbduxsub->pwm_cmd_running) {
-		/* already running */
-		return 0;
-	}
+	down(&devpriv->sem);
+
+	if (devpriv->pwm_cmd_running)
+		goto pwm_start_exit;
 
-	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwn_delay);
+	devpriv->dux_commands[1] = devpriv->pwn_delay;
 	ret = send_dux_commands(dev, SENDPWMON);
 	if (ret < 0)
-		return ret;
+		goto pwm_start_exit;
 
 	/* initialise the buffer */
-	for (i = 0; i < this_usbduxsub->size_pwm_buf; i++)
-		((char *)(this_usbduxsub->urb_pwm->transfer_buffer))[i] = 0;
+	memset(devpriv->urb_pwm->transfer_buffer, 0, devpriv->size_pwm_buf);
 
-	this_usbduxsub->pwm_cmd_running = 1;
+	devpriv->pwm_cmd_running = 1;
 	ret = usbduxsub_submit_pwm_urbs(dev);
-	if (ret < 0) {
-		this_usbduxsub->pwm_cmd_running = 0;
-		return ret;
-	}
-	return 0;
+	if (ret < 0)
+		devpriv->pwm_cmd_running = 0;
+
+pwm_start_exit:
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 /* generates the bit pattern for PWM with the optional sign bit */

commit 96ca37047e774c48cbf5ccf4e6d18e8cf5898dcd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:07:20 2013 -0700

    staging: comedi: usbdux: fix usbdux_pwm_cancel()
    
    Add the missing down/up of the semaphore to prevent other commands
    from being issued to the usb device while the pwn is being stopped.
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Make sure to check that usbdux_pwm_stop() was successful before
    sending command to the usb device to stop the pwm.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 61e9df90e403..14c26e559cb7 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1430,17 +1430,25 @@ static int usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)
 	return ret;
 }
 
-/* force unlink - is called by comedi */
 static int usbdux_pwm_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int res = 0;
+	struct usbdux_private *devpriv = dev->private;
+	int ret;
+
+	down(&devpriv->sem);
 
 	/* unlink only if it is really running */
-	res = usbdux_pwm_stop(dev, this_usbduxsub->pwm_cmd_running);
+	ret = usbdux_pwm_stop(dev, devpriv->pwm_cmd_running);
+	if (ret)
+		goto pwm_cancel_exit;
+
+	ret = send_dux_commands(dev, SENDPWMOFF);
 
-	return send_dux_commands(dev, SENDPWMOFF);
+pwm_cancel_exit:
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)

commit 38f0683502a5c57dd39e4c65ec86cbe8e3975d5b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:07:04 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_pwm_stop()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer. Rename the local variable used
    for the private data pointer to the comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 82624a24eb3e..61e9df90e403 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1417,20 +1417,15 @@ static int usbduxsub_unlink_pwm_urbs(struct usbdux_private *usbduxsub_tmp)
 	return err;
 }
 
-/* This cancels a running acquisition operation
- * in any context.
- */
-static int usbdux_pwm_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
+static int usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbdux_private *devpriv = dev->private;
 	int ret = 0;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	if (do_unlink)
-		ret = usbduxsub_unlink_pwm_urbs(this_usbduxsub);
+		ret = usbduxsub_unlink_pwm_urbs(devpriv);
 
-	this_usbduxsub->pwm_cmd_running = 0;
+	devpriv->pwm_cmd_running = 0;
 
 	return ret;
 }
@@ -1443,7 +1438,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	int res = 0;
 
 	/* unlink only if it is really running */
-	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
+	res = usbdux_pwm_stop(dev, this_usbduxsub->pwm_cmd_running);
 
 	return send_dux_commands(dev, SENDPWMOFF);
 }
@@ -1468,7 +1463,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		 * no unlink needed here. Already shutting down.
 		 */
 		if (devpriv->pwm_cmd_running)
-			usbdux_pwm_stop(devpriv, 0);
+			usbdux_pwm_stop(dev, 0);
 
 		return;
 
@@ -1478,7 +1473,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 			dev_err(dev->class_dev,
 				"Non-zero urb status received in pwm intr context: %d\n",
 				urb->status);
-			usbdux_pwm_stop(devpriv, 0);
+			usbdux_pwm_stop(dev, 0);
 		}
 		return;
 	}
@@ -1501,7 +1496,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 					"buggy USB host controller or bug in IRQ handling!\n");
 
 			/* don't do an unlink here */
-			usbdux_pwm_stop(devpriv, 0);
+			usbdux_pwm_stop(dev, 0);
 		}
 	}
 }

commit f2929618d376075e01136326148e7028350c7c38
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:06:47 2013 -0700

    staging: comedi: usbdux: fix usbdux_counter_write()
    
    Comedi (*insn_write) operations are supposed to write insn->n values.
    Fix this function to work like the core expects.
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 05bea98444db..82624a24eb3e 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1369,27 +1369,30 @@ static int usbdux_counter_read(struct comedi_device *dev,
 
 static int usbdux_counter_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int err;
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int16_t *p = (int16_t *)&devpriv->dux_commands[2];
+	int ret = 0;
+	int i;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
-	this_usbduxsub->dux_commands[1] = insn->chanspec;
-	*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);
+	devpriv->dux_commands[1] = chan;
 
-	err = send_dux_commands(dev, WRITECOUNTERCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
+	for (i = 0; i < insn->n; i++) {
+		*p = cpu_to_le16(data[i]);
+
+		ret = send_dux_commands(dev, WRITECOUNTERCOMMAND);
+		if (ret < 0)
+			break;
 	}
 
-	up(&this_usbduxsub->sem);
+	up(&devpriv->sem);
 
-	return 1;
+	return ret ? ret : insn->n;
 }
 
 static int usbdux_counter_config(struct comedi_device *dev,

commit 48967d4f5d91acbe0e70fa821c5951059566ac84
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:06:30 2013 -0700

    staging: comedi: usbdux: fix usbdux_counter_read()
    
    Comedi (*insn_read) operations are supposed to read and return insn->n
    values. Fix this function to work like the core expects.
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a1e5cf1388f1..05bea98444db 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1338,34 +1338,33 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	return ret ? ret : insn->n;
 }
 
-/* reads the 4 counters, only two are used just now */
 static int usbdux_counter_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int chan = insn->chanspec;
-	int err;
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int ret = 0;
+	int i;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
-	err = send_dux_commands(dev, READCOUNTERCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
+	for (i = 0; i < insn->n; i++) {
+		ret = send_dux_commands(dev, READCOUNTERCOMMAND);
+		if (ret < 0)
+			goto counter_read_exit;
+		ret = receive_dux_commands(dev, READCOUNTERCOMMAND);
+		if (ret < 0)
+			goto counter_read_exit;
 
-	err = receive_dux_commands(dev, READCOUNTERCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
+		data[i] = le16_to_cpu(devpriv->insn_buffer[chan + 1]);
 	}
 
-	data[0] = le16_to_cpu(this_usbduxsub->insn_buffer[chan + 1]);
-	up(&this_usbduxsub->sem);
-	return 1;
+counter_read_exit:
+	up(&devpriv->sem);
+
+	return ret ? ret : insn->n;
 }
 
 static int usbdux_counter_write(struct comedi_device *dev,

commit 81a9bdaac428174d04df8b361c9363a5e33f533f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:06:11 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_dio_insn_bits()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cdb02876a719..a1e5cf1388f1 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1302,40 +1302,40 @@ static int usbdux_dio_insn_config(struct comedi_device *dev,
 
 static int usbdux_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int err;
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
+	int ret;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
+	s->state &= ~mask;
+	s->state |= (bits & mask);
 
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
-	s->state &= ~data[0];
-	s->state |= data[0] & data[1];
-	this_usbduxsub->dux_commands[1] = s->io_bits;
-	this_usbduxsub->dux_commands[2] = s->state;
+	devpriv->dux_commands[1] = s->io_bits;
+	devpriv->dux_commands[2] = s->state;
 
-	/* This command also tells the firmware to return */
-	/* the digital input lines */
-	err = send_dux_commands(dev, SENDDIOBITSCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
-	err = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
+	/*
+	 * This command also tells the firmware to return
+	 * the digital input lines.
+	 */
+	ret = send_dux_commands(dev, SENDDIOBITSCOMMAND);
+	if (ret < 0)
+		goto dio_exit;
+	ret = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
+	if (ret < 0)
+		goto dio_exit;
 
-	data[1] = le16_to_cpu(this_usbduxsub->insn_buffer[1]);
-	up(&this_usbduxsub->sem);
-	return insn->n;
+	data[1] = le16_to_cpu(devpriv->insn_buffer[1]);
+
+dio_exit:
+	up(&devpriv->sem);
+
+	return ret ? ret : insn->n;
 }
 
 /* reads the 4 counters, only two are used just now */

commit fc110df61f0adf060d6b2011ecaba45332a479a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:05:53 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_dio_insn_config()
    
    Tidy up this function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 40e1424ce5a0..cdb02876a719 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1273,32 +1273,30 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static int usbdux_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
-	int chan = CR_CHAN(insn->chanspec);
-
-	/* The input or output configuration of each digital line is
-	 * configured by a special insn_config instruction.  chanspec
-	 * contains the channel to be changed, and data[0] contains the
-	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+	unsigned int mask = 1 << CR_CHAN(insn->chanspec);
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= 1 << chan;	/* 1 means Out */
+		s->io_bits |= mask;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~(1 << chan);
+		s->io_bits &= ~mask;
 		break;
 	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		break;
 	default:
 		return -EINVAL;
 		break;
 	}
-	/* we don't tell the firmware here as it would take 8 frames */
-	/* to submit the information. We do it in the insn_bits. */
+
+	/*
+	 * We don't tell the firmware here as it would take 8 frames
+	 * to submit the information. We do it in the insn_bits.
+	 */
 	return insn->n;
 }
 

commit 2a226948081f6285ddc7e8fd4c592d7378c7c55d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:05:35 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_cmd()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Make sure an ao command is not already running and return -EBUSY.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9aa2e9ea53d1..40e1424ce5a0 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1188,72 +1188,74 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct usbdux_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int chan, gain;
-	int i, ret;
-	struct usbdux_private *this_usbduxsub = dev->private;
+	int ret = -EBUSY;
+	int i;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
+	if (devpriv->ao_cmd_running)
+		goto ao_cmd_exit;
 
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
+
 	for (i = 0; i < cmd->chanlist_len; ++i) {
-		chan = CR_CHAN(cmd->chanlist[i]);
-		gain = CR_RANGE(cmd->chanlist[i]);
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
 		if (i >= NUMOUTCHANNELS)
 			break;
-		this_usbduxsub->dac_commands[i] = (chan << 6);
+
+		devpriv->dac_commands[i] = chan << 6;
 	}
 
 	/* we count in steps of 1ms (125us) */
 	/* 125us mode not used yet */
-	if (0) {		/* (this_usbduxsub->high_speed) */
+	if (0) {		/* (devpriv->high_speed) */
 		/* 125us */
 		/* timing of the conversion itself: every 125 us */
-		this_usbduxsub->ao_timer = cmd->convert_arg / 125000;
+		devpriv->ao_timer = cmd->convert_arg / 125000;
 	} else {
 		/* 1ms */
 		/* timing of the scan: we get all channels at once */
-		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
-		if (this_usbduxsub->ao_timer < 1) {
-			up(&this_usbduxsub->sem);
-			return -EINVAL;
+		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
+		if (devpriv->ao_timer < 1) {
+			ret = -EINVAL;
+			goto ao_cmd_exit;
 		}
 	}
-	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+
+	devpriv->ao_counter = devpriv->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* not continuous */
 		/* counter */
 		/* high speed also scans everything at once */
-		if (0) {	/* (this_usbduxsub->high_speed) */
-			this_usbduxsub->ao_sample_count =
-			    (cmd->stop_arg) * (cmd->scan_end_arg);
+		if (0) {	/* (devpriv->high_speed) */
+			devpriv->ao_sample_count = cmd->stop_arg *
+						   cmd->scan_end_arg;
 		} else {
 			/* there's no scan as the scan has been */
 			/* perf inside the FX2 */
 			/* data arrives as one packet */
-			this_usbduxsub->ao_sample_count = cmd->stop_arg;
+			devpriv->ao_sample_count = cmd->stop_arg;
 		}
-		this_usbduxsub->ao_continous = 0;
+		devpriv->ao_continous = 0;
 	} else {
 		/* continous acquisition */
-		this_usbduxsub->ao_continous = 1;
-		this_usbduxsub->ao_sample_count = 0;
+		devpriv->ao_continous = 1;
+		devpriv->ao_sample_count = 0;
 	}
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		this_usbduxsub->ao_cmd_running = 1;
+		devpriv->ao_cmd_running = 1;
 		ret = usbduxsub_submit_outurbs(dev);
 		if (ret < 0) {
-			this_usbduxsub->ao_cmd_running = 0;
+			devpriv->ao_cmd_running = 0;
 			/* fixme: unlink here?? */
-			up(&this_usbduxsub->sem);
-			return ret;
+			goto ao_cmd_exit;
 		}
 		s->async->inttrig = NULL;
 	} else {
@@ -1263,8 +1265,10 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		s->async->inttrig = usbdux_ao_inttrig;
 	}
 
-	up(&this_usbduxsub->sem);
-	return 0;
+ao_cmd_exit:
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 static int usbdux_dio_insn_config(struct comedi_device *dev,

commit f994282df674e31574291e2f8cbd986f234d9d91
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:05:17 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_inttrig()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Return -EBUSY instead if an ao command is already running.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1e6cb0a60a07..9aa2e9ea53d1 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1074,31 +1074,32 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 }
 
 static int usbdux_ao_inttrig(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int trignum)
+			     struct comedi_subdevice *s,
+			     unsigned int trignum)
 {
-	int ret;
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
+	int ret = -EINVAL;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
-	if (trignum != 0) {
-		up(&this_usbduxsub->sem);
-		return -EINVAL;
-	}
-	if (!(this_usbduxsub->ao_cmd_running)) {
-		this_usbduxsub->ao_cmd_running = 1;
+	if (trignum != 0)
+		goto ao_trig_exit;
+
+	if (!devpriv->ao_cmd_running) {
+		devpriv->ao_cmd_running = 1;
 		ret = usbduxsub_submit_outurbs(dev);
 		if (ret < 0) {
-			this_usbduxsub->ao_cmd_running = 0;
-			up(&this_usbduxsub->sem);
-			return ret;
+			devpriv->ao_cmd_running = 0;
+			goto ao_trig_exit;
 		}
 		s->async->inttrig = NULL;
+	} else {
+		ret = -EBUSY;
 	}
-	up(&this_usbduxsub->sem);
-	return 1;
+
+ao_trig_exit:
+	up(&devpriv->sem);
+	return ret;
 }
 
 static int usbdux_ao_cmdtest(struct comedi_device *dev,

commit 37c1d1ec37144e9fe14bcc0c3ab0bba92c332312
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:05:00 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_insn_write()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Return -EBUSY instead of 0 if the (*insn_write) cannot be done because
    a command is running.
    
    Tidy up the for() loop that writes the data. The dux_commands[1] and [4]
    can be set outside the loop since they are constant. Use a local pointer
    for dux_commands[2] to load the value to write. Only the last value needs
    to be cached in the private data for read back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 4159936a6312..1e6cb0a60a07 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1035,39 +1035,42 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 
 static int usbdux_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	int i, err;
-	int chan = CR_CHAN(insn->chanspec);
-	struct usbdux_private *this_usbduxsub = dev->private;
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val = devpriv->out_buffer[chan];
+	int16_t *p = (int16_t *)&devpriv->dux_commands[2];
+	int ret = -EBUSY;
+	int i;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ao_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return 0;
-	}
+	if (devpriv->ao_cmd_running)
+		goto ao_write_exit;
+
+	/* number of channels: 1 */
+	devpriv->dux_commands[1] = 1;
+	/* channel number */
+	devpriv->dux_commands[4] = chan << 6;
 
 	for (i = 0; i < insn->n; i++) {
-		/* number of channels: 1 */
-		this_usbduxsub->dux_commands[1] = 1;
+		val = data[i];
+
 		/* one 16 bit value */
-		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
-		    cpu_to_le16(data[i]);
-		this_usbduxsub->out_buffer[chan] = data[i];
-		/* channel number */
-		this_usbduxsub->dux_commands[4] = (chan << 6);
-		err = send_dux_commands(dev, SENDDACOMMANDS);
-		if (err < 0) {
-			up(&this_usbduxsub->sem);
-			return err;
-		}
+		*p = cpu_to_le16(val);
+
+		ret = send_dux_commands(dev, SENDDACOMMANDS);
+		if (ret < 0)
+			goto ao_write_exit;
 	}
-	up(&this_usbduxsub->sem);
+	devpriv->out_buffer[chan] = val;
 
-	return i;
+ao_write_exit:
+	up(&devpriv->sem);
+
+	return ret ? ret : insn->n;
 }
 
 static int usbdux_ao_inttrig(struct comedi_device *dev,

commit 818782c8a7744f5183e5e1a411622ce0ae25a558
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:04:34 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_insn_read()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a81b4b17b297..4159936a6312 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1016,26 +1016,21 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	return ret ? ret : insn->n;
 }
 
-/************************************/
-/* analog out */
-
 static int usbdux_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
-	int chan = CR_CHAN(insn->chanspec);
-	struct usbdux_private *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 	for (i = 0; i < insn->n; i++)
-		data[i] = this_usbduxsub->out_buffer[chan];
+		data[i] = devpriv->out_buffer[chan];
+	up(&devpriv->sem);
 
-	up(&this_usbduxsub->sem);
-	return i;
+	return insn->n;
 }
 
 static int usbdux_ao_insn_write(struct comedi_device *dev,

commit 91891f7cc6453bec358a3bc2a0cf9a0b2f8223d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:04:17 2013 -0700

    staging: comedi: usbdux: clarify bipolar ai data
    
    Use the comedi_range_is_bipolar() helper instead of checking the
    'range' index against a magic number.
    
    Also, use the s->maxdata to calculate the value needed to munge the
    value for bipolar data instead of the magic number.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a536fa3b6858..a81b4b17b297 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1002,8 +1002,10 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 			goto ai_read_exit;
 
 		val = le16_to_cpu(devpriv->insn_buffer[1]);
-		if (range <= 1)
-			val ^= 0x800;
+
+		/* bipolar data is two's-complement */
+		if (comedi_range_is_bipolar(s, range))
+			val ^= ((s->maxdata + 1) >> 1);
 
 		data[i] = val;
 	}

commit a79b4cdb52151dab5c5b2a86ab7619bc457470a8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:03:53 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ai_insn_read()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Return -EBUSY instead of 0 if the (*insn_read) cannot be done because
    a command is running.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index aebc728c9be9..a536fa3b6858 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -973,50 +973,45 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 /* Mode 0 is used to get a single conversion on demand */
 static int usbdux_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
+	struct usbdux_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val;
+	int ret = -EBUSY;
 	int i;
-	unsigned int one = 0;
-	int chan, range;
-	int err;
-	struct usbdux_private *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub)
-		return 0;
+	down(&devpriv->sem);
 
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ai_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return 0;
-	}
+	if (devpriv->ai_cmd_running)
+		goto ai_read_exit;
 
-	/* sample one channel */
-	chan = CR_CHAN(insn->chanspec);
-	range = CR_RANGE(insn->chanspec);
 	/* set command for the first channel */
-	this_usbduxsub->dux_commands[1] = create_adc_command(chan, range);
+	devpriv->dux_commands[1] = create_adc_command(chan, range);
 
 	/* adc commands */
-	err = send_dux_commands(dev, SENDSINGLEAD);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
+	ret = send_dux_commands(dev, SENDSINGLEAD);
+	if (ret < 0)
+		goto ai_read_exit;
 
 	for (i = 0; i < insn->n; i++) {
-		err = receive_dux_commands(dev, SENDSINGLEAD);
-		if (err < 0) {
-			up(&this_usbduxsub->sem);
-			return 0;
-		}
-		one = le16_to_cpu(this_usbduxsub->insn_buffer[1]);
-		if (CR_RANGE(insn->chanspec) <= 1)
-			one = one ^ 0x800;
+		ret = receive_dux_commands(dev, SENDSINGLEAD);
+		if (ret < 0)
+			goto ai_read_exit;
+
+		val = le16_to_cpu(devpriv->insn_buffer[1]);
+		if (range <= 1)
+			val ^= 0x800;
 
-		data[i] = one;
+		data[i] = val;
 	}
-	up(&this_usbduxsub->sem);
-	return i;
+
+ai_read_exit:
+	up(&devpriv->sem);
+
+	return ret ? ret : insn->n;
 }
 
 /************************************/

commit 9a79dfce37416c5677512fe5cf7c5a59f8f9b73d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:03:34 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ai_cmd()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 95c11e820fd2..aebc728c9be9 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -882,85 +882,79 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 
 static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct usbdux_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int chan, range;
-	int i, ret;
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int result;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
+	int len = cmd->chanlist_len;
+	int ret = -EBUSY;
+	int i;
 
 	/* block other CPUs from starting an ai_cmd */
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ai_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return -EBUSY;
-	}
+	down(&devpriv->sem);
+
+	if (devpriv->ai_cmd_running)
+		goto ai_cmd_exit;
+
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
-	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
-	for (i = 0; i < cmd->chanlist_len; ++i) {
-		chan = CR_CHAN(cmd->chanlist[i]);
-		range = CR_RANGE(cmd->chanlist[i]);
+	devpriv->dux_commands[1] = len;
+	for (i = 0; i < len; ++i) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
 		if (i >= NUMCHANNELS)
 			break;
-		this_usbduxsub->dux_commands[i + 2] =
-		    create_adc_command(chan, range);
-	}
 
-	result = send_dux_commands(dev, SENDADCOMMANDS);
-	if (result < 0) {
-		up(&this_usbduxsub->sem);
-		return result;
+		devpriv->dux_commands[i + 2] = create_adc_command(chan, range);
 	}
 
-	if (this_usbduxsub->high_speed) {
+	ret = send_dux_commands(dev, SENDADCOMMANDS);
+	if (ret < 0)
+		goto ai_cmd_exit;
+
+	if (devpriv->high_speed) {
 		/*
 		 * every channel gets a time window of 125us. Thus, if we
 		 * sample all 8 channels we need 1ms. If we sample only one
 		 * channel we need only 125us
 		 */
-		this_usbduxsub->ai_interval = 1;
+		devpriv->ai_interval = 1;
 		/* find a power of 2 for the interval */
-		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
-			this_usbduxsub->ai_interval =
-			    (this_usbduxsub->ai_interval) * 2;
-		}
-		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
-							  (this_usbduxsub->
-							   ai_interval));
+		while (devpriv->ai_interval < len)
+			devpriv->ai_interval *= 2;
+
+		devpriv->ai_timer = cmd->scan_begin_arg /
+				    (125000 * devpriv->ai_interval);
 	} else {
 		/* interval always 1ms */
-		this_usbduxsub->ai_interval = 1;
-		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
+		devpriv->ai_interval = 1;
+		devpriv->ai_timer = cmd->scan_begin_arg / 1000000;
 	}
-	if (this_usbduxsub->ai_timer < 1) {
-		up(&this_usbduxsub->sem);
-		return -EINVAL;
+	if (devpriv->ai_timer < 1) {
+		ret = -EINVAL;
+		goto ai_cmd_exit;
 	}
-	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+
+	devpriv->ai_counter = devpriv->ai_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* data arrives as one packet */
-		this_usbduxsub->ai_sample_count = cmd->stop_arg;
-		this_usbduxsub->ai_continous = 0;
+		devpriv->ai_sample_count = cmd->stop_arg;
+		devpriv->ai_continous = 0;
 	} else {
 		/* continous acquisition */
-		this_usbduxsub->ai_continous = 1;
-		this_usbduxsub->ai_sample_count = 0;
+		devpriv->ai_continous = 1;
+		devpriv->ai_sample_count = 0;
 	}
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		this_usbduxsub->ai_cmd_running = 1;
+		devpriv->ai_cmd_running = 1;
 		ret = usbduxsub_submit_inurbs(dev);
 		if (ret < 0) {
-			this_usbduxsub->ai_cmd_running = 0;
+			devpriv->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
-			up(&this_usbduxsub->sem);
-			return ret;
+			goto ai_cmd_exit;
 		}
 		s->async->inttrig = NULL;
 	} else {
@@ -969,8 +963,11 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* wait for an internal signal */
 		s->async->inttrig = usbdux_ai_inttrig;
 	}
-	up(&this_usbduxsub->sem);
-	return 0;
+
+ai_cmd_exit:
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 /* Mode 0 is used to get a single conversion on demand */

commit e5cb2f9498e0a5b4c7f882a21dbba8f8ba351819
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:03:15 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ai_inttrig()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Tidy up the exit path using goto to ensure that the semaphore is
    released.
    
    Return -EBUSY if an ai command is already running.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d0d683bc83c2..95c11e820fd2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -852,31 +852,32 @@ static int receive_dux_commands(struct comedi_device *dev, int command)
 }
 
 static int usbdux_ai_inttrig(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int trignum)
+			     struct comedi_subdevice *s,
+			     unsigned int trignum)
 {
-	int ret;
-	struct usbdux_private *this_usbduxsub = dev->private;
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	int ret = -EINVAL;
 
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 
-	if (trignum != 0) {
-		up(&this_usbduxsub->sem);
-		return -EINVAL;
-	}
-	if (!(this_usbduxsub->ai_cmd_running)) {
-		this_usbduxsub->ai_cmd_running = 1;
+	if (trignum != 0)
+		goto ai_trig_exit;
+
+	if (!devpriv->ai_cmd_running) {
+		devpriv->ai_cmd_running = 1;
 		ret = usbduxsub_submit_inurbs(dev);
 		if (ret < 0) {
-			this_usbduxsub->ai_cmd_running = 0;
-			up(&this_usbduxsub->sem);
-			return ret;
+			devpriv->ai_cmd_running = 0;
+			goto ai_trig_exit;
 		}
 		s->async->inttrig = NULL;
+	} else {
+		ret = -EBUSY;
 	}
-	up(&this_usbduxsub->sem);
-	return 1;
+
+ai_trig_exit:
+	up(&devpriv->sem);
+	return ret;
 }
 
 static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)

commit eee7d9e9ef711abda2482af2d6b15d76e34b8db5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:18:36 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_cancel()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1f6750950a5d..d0d683bc83c2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -449,22 +449,19 @@ static int usbdux_ao_stop(struct comedi_device *dev, int do_unlink)
 	return ret;
 }
 
-/* force unlink, is called by comedi */
 static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbdux_private *this_usbduxsub = dev->private;
-	int res = 0;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	int ret = 0;
 
 	/* prevent other CPUs from submitting a command just now */
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 	/* unlink only if it is really running */
-	res = usbdux_ao_stop(dev, this_usbduxsub->ao_cmd_running);
-	up(&this_usbduxsub->sem);
-	return res;
+	ret = usbdux_ao_stop(dev, devpriv->ao_cmd_running);
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 static void usbduxsub_ao_isoc_irq(struct urb *urb)

commit 7c8ed94eb8c0bae49f900085d5221529cf20378c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:18:15 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ao_stop()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer. Rename the local variable used
    for the private data pointer to the comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index edee14851d70..1f6750950a5d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -436,20 +436,15 @@ static int usbduxsub_unlink_outurbs(struct usbdux_private *usbduxsub_tmp)
 	return err;
 }
 
-/* This will cancel a running acquisition operation
- * in any context.
- */
-static int usbdux_ao_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
+static int usbdux_ao_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbdux_private *devpriv = dev->private;
 	int ret = 0;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	if (do_unlink)
-		ret = usbduxsub_unlink_outurbs(this_usbduxsub);
+		ret = usbduxsub_unlink_outurbs(devpriv);
 
-	this_usbduxsub->ao_cmd_running = 0;
+	devpriv->ao_cmd_running = 0;
 
 	return ret;
 }
@@ -467,7 +462,7 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 	/* prevent other CPUs from submitting a command just now */
 	down(&this_usbduxsub->sem);
 	/* unlink only if it is really running */
-	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
+	res = usbdux_ao_stop(dev, this_usbduxsub->ao_cmd_running);
 	up(&this_usbduxsub->sem);
 	return res;
 }
@@ -494,7 +489,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		if (devpriv->ao_cmd_running) {
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
-			usbdux_ao_stop(devpriv, 0);
+			usbdux_ao_stop(dev, 0);
 		}
 		return;
 
@@ -508,7 +503,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
 			/* we do an unlink if we are in the high speed mode */
-			usbdux_ao_stop(devpriv, 0);
+			usbdux_ao_stop(dev, 0);
 		}
 		return;
 	}
@@ -529,7 +524,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
 				/* all samples transmitted */
-				usbdux_ao_stop(devpriv, 0);
+				usbdux_ao_stop(dev, 0);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
 				/* no resubmit of the urb */
@@ -588,7 +583,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			/* don't do an unlink here */
-			usbdux_ao_stop(devpriv, 0);
+			usbdux_ao_stop(dev, 0);
 		}
 	}
 }

commit aa6081e5e0989f4df9ca35fa412e3ba8c23e38df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:17:50 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ai_cancel()
    
    Rename the local variable used for the private data pointer to the
    comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c195ec6f8fb5..edee14851d70 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -283,27 +283,19 @@ static int usbdux_ai_stop(struct comedi_device *dev, int do_unlink)
 	return ret;
 }
 
-/*
- * This will cancel a running acquisition operation.
- * This is called by comedi but never from inside the driver.
- */
 static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbdux_private *this_usbduxsub;
-	int res = 0;
-
-	/* force unlink of all urbs */
-	this_usbduxsub = dev->private;
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	int ret = 0;
 
 	/* prevent other CPUs from submitting new commands just now */
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 	/* unlink only if the urb really has been submitted */
-	res = usbdux_ai_stop(dev, this_usbduxsub->ai_cmd_running);
-	up(&this_usbduxsub->sem);
-	return res;
+	ret = usbdux_ai_stop(dev, devpriv->ai_cmd_running);
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 /* analogue IN - interrupt service routine */

commit b3476e67c1afa634437a429673b75e735dcfbd6a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:17:23 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_ai_stop()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer. Rename the local variable used
    for the private data pointer to the comedi "norm".
    
    Remove the unnecessary sanity check of the private data pointer. This
    function can only be called is the private data was allocated during
    the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0434674121e8..c195ec6f8fb5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -270,24 +270,15 @@ static int usbduxsub_unlink_inurbs(struct usbdux_private *usbduxsub_tmp)
 	return err;
 }
 
-/*
- * This will stop a running acquisition operation
- * Is called from within this driver from both the
- * interrupt context and from comedi
- */
-static int usbdux_ai_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
+static int usbdux_ai_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbdux_private *devpriv = dev->private;
 	int ret = 0;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
-	if (do_unlink) {
-		/* stop aquistion */
-		ret = usbduxsub_unlink_inurbs(this_usbduxsub);
-	}
+	if (do_unlink)
+		ret = usbduxsub_unlink_inurbs(devpriv);
 
-	this_usbduxsub->ai_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
 
 	return ret;
 }
@@ -310,7 +301,7 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
 	/* unlink only if the urb really has been submitted */
-	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
+	res = usbdux_ai_stop(dev, this_usbduxsub->ai_cmd_running);
 	up(&this_usbduxsub->sem);
 	return res;
 }
@@ -346,7 +337,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			/* stop the transfer w/o unlink */
-			usbdux_ai_stop(devpriv, 0);
+			usbdux_ai_stop(dev, 0);
 		}
 		return;
 
@@ -361,7 +352,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			/* don't do an unlink here */
-			usbdux_ai_stop(devpriv, 0);
+			usbdux_ai_stop(dev, 0);
 		}
 		return;
 	}
@@ -392,7 +383,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(dev, s);
 		/* don't do an unlink here */
-		usbdux_ai_stop(devpriv, 0);
+		usbdux_ai_stop(dev, 0);
 		return;
 	}
 
@@ -410,7 +401,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		/* all samples received? */
 		if (devpriv->ai_sample_count < 0) {
 			/* prevent a resubmit next time */
-			usbdux_ai_stop(devpriv, 0);
+			usbdux_ai_stop(dev, 0);
 			/* say comedi that the acquistion is over */
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
@@ -430,7 +421,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		}
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
-			usbdux_ai_stop(devpriv, 0);
+			usbdux_ai_stop(dev, 0);
 			return;
 		}
 	}

commit b8c162c961c47f0fa991cc8f4b2acd32e55ae589
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:17:05 2013 -0700

    staging: comedi: usbdux: make private data flags bit-fields
    
    Change the flags in the private data to bit-fields to save a bit of
    space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c0c4a2711664..0434674121e8 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -223,16 +223,14 @@ struct usbdux_private {
 	int16_t *insn_buffer;
 	/* output buffer for single DA outputs */
 	int16_t *out_buffer;
-	/* is it USB_SPEED_HIGH or not? */
-	short int high_speed;
-	/* asynchronous command is running */
-	short int ai_cmd_running;
-	short int ao_cmd_running;
-	/* pwm is running */
-	short int pwm_cmd_running;
-	/* continous acquisition */
-	short int ai_continous;
-	short int ao_continous;
+
+	unsigned int high_speed:1;
+	unsigned int ai_cmd_running:1;
+	unsigned int ai_continous:1;
+	unsigned int ao_cmd_running:1;
+	unsigned int ao_continous:1;
+	unsigned int pwm_cmd_running:1;
+
 	/* number of samples to acquire */
 	int ai_sample_count;
 	int ao_sample_count;

commit 903f4fde801343eb95e3f30cab24c50c9fe367c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:16:44 2013 -0700

    staging: comedi: usbdux: remove 'ifnum' from the private data
    
    The 'ifnum' is only used during the attach of the device. Remove it
    from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 88419444497f..c0c4a2711664 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -223,8 +223,6 @@ struct usbdux_private {
 	int16_t *insn_buffer;
 	/* output buffer for single DA outputs */
 	int16_t *out_buffer;
-	/* interface number */
-	int ifnum;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -1896,7 +1894,6 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	sema_init(&devpriv->sem, 1);
 
-	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
 
 	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
@@ -1914,7 +1911,8 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	ret = usb_set_interface(usb, devpriv->ifnum, 3);
+	ret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,
+				3);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
 			"could not set alternate setting 3 in high speed\n");

commit 0b20d613afd0e1ba394c2b209a5f459c5f43e1ff
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:16:24 2013 -0700

    staging: comedi: usbdux: remove usb_device back pointer from private data
    
    The usb_device can be found when needed using the comedi_to_usb_dev()
    helper. Use that instead the remove the back pointer from the private
    data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c3fbfdc6fc5c..88419444497f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -202,8 +202,6 @@ static const struct comedi_lrange range_usbdux_ao_range = {
 };
 
 struct usbdux_private {
-	/* pointer to the usb-device */
-	struct usb_device *usbdev;
 	/* actual number of in-buffers */
 	int num_in_buffers;
 	/* actual number of out-buffers */
@@ -384,7 +382,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		return;
 	}
 
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 
 	/* resubmit the urb */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
@@ -587,7 +585,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 		}
 	}
 	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	if (devpriv->ao_cmd_running) {
 		if (devpriv->high_speed)
@@ -622,8 +620,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 				  const u8 *data, size_t size,
 				  unsigned long context)
 {
-	struct usbdux_private *usbduxsub = dev->private;
-	struct usb_device *usb = usbduxsub->usbdev;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	uint8_t *buf;
 	uint8_t *tmp;
 	int ret;
@@ -693,6 +690,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 
 static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb;
 	int ret;
@@ -705,7 +703,7 @@ static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 		/* in case of a resubmission after an unlink... */
 		urb->interval = devpriv->ai_interval;
 		urb->context = dev;
-		urb->dev = devpriv->usbdev;
+		urb->dev = usb;
 		urb->status = 0;
 		urb->transfer_flags = URB_ISO_ASAP;
 
@@ -718,6 +716,7 @@ static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 
 static int usbduxsub_submit_outurbs(struct comedi_device *dev)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb;
 	int ret;
@@ -728,7 +727,7 @@ static int usbduxsub_submit_outurbs(struct comedi_device *dev)
 
 		/* in case of a resubmission after an unlink... */
 		urb->context = dev;
-		urb->dev = devpriv->usbdev;
+		urb->dev = usb;
 		urb->status = 0;
 		urb->transfer_flags = URB_ISO_ASAP;
 
@@ -849,8 +848,8 @@ static int8_t create_adc_command(unsigned int chan, int range)
 
 static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
-	struct usb_device *usb = devpriv->usbdev;
 	int nsent;
 
 	devpriv->dux_commands[0] = cmd_type;
@@ -862,8 +861,8 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 
 static int receive_dux_commands(struct comedi_device *dev, int command)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
-	struct usb_device *usb = devpriv->usbdev;
 	int ret;
 	int nrec;
 	int i;
@@ -1520,7 +1519,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		return;
 
 	urb->transfer_buffer_length = devpriv->size_pwm_buf;
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	if (devpriv->pwm_cmd_running) {
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1540,12 +1539,12 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 
 static int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb = devpriv->urb_pwm;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(urb, devpriv->usbdev,
-			  usb_sndbulkpipe(devpriv->usbdev, PWM_EP),
+	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
 			  urb->transfer_buffer,
 			  devpriv->size_pwm_buf,
 			  usbduxsub_pwm_irq,
@@ -1731,6 +1730,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 
 static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb;
 	int i;
@@ -1773,11 +1773,11 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 			return -ENOMEM;
 		devpriv->urb_in[i] = urb;
 
-		urb->dev = devpriv->usbdev;
+		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(devpriv->usbdev, ISOINEP);
+		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
@@ -1803,11 +1803,11 @@ static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 			return -ENOMEM;
 		devpriv->urb_out[i] = urb;
 
-		urb->dev = devpriv->usbdev;
+		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(devpriv->usbdev, ISOOUTEP);
+		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
@@ -1896,11 +1896,10 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	sema_init(&devpriv->sem, 1);
 
-	devpriv->usbdev = usb;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
 
-	devpriv->high_speed = (devpriv->usbdev->speed == USB_SPEED_HIGH);
+	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
 	if (devpriv->high_speed) {
 		devpriv->num_in_buffers = NUMOFINBUFFERSHIGH;
 		devpriv->num_out_buffers = NUMOFOUTBUFFERSHIGH;
@@ -1915,7 +1914,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	ret = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
+	ret = usb_set_interface(usb, devpriv->ifnum, 3);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
 			"could not set alternate setting 3 in high speed\n");

commit 11642c658ff0e8bb13e68ac59593427a482e8c9a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:16:04 2013 -0700

    staging: comedi: usbdux: pass comedi_device pointer to usbdux_alloc_usb_buffers()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 5980b8e36694..c3fbfdc6fc5c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1729,8 +1729,9 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 /* end of PWM */
 /*****************************************************************/
 
-static int usbdux_alloc_usb_buffers(struct usbdux_private *devpriv)
+static int usbdux_alloc_usb_buffers(struct comedi_device *dev)
 {
+	struct usbdux_private *devpriv = dev->private;
 	struct urb *urb;
 	int i;
 
@@ -1909,7 +1910,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
 	}
 
-	ret = usbdux_alloc_usb_buffers(devpriv);
+	ret = usbdux_alloc_usb_buffers(dev);
 	if (ret)
 		return ret;
 

commit fb90856828064ee5195a2b5b0f9c1fa430a3fbb9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:15:43 2013 -0700

    staging: comedi: usbdux: tidy up receive_dux_commands()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer. Rename the local variable used
    for the private data pointer to the comedi "norm".
    
    Add a local variable for the usb_device pointer to tidy up the
    usb_bulk_msg() call.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d2a3a1accb85..5980b8e36694 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -860,25 +860,24 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 			    &nsent, BULK_TIMEOUT);
 }
 
-static int receive_dux_commands(struct usbdux_private *this_usbduxsub, int command)
+static int receive_dux_commands(struct comedi_device *dev, int command)
 {
-	int result = (-EFAULT);
+	struct usbdux_private *devpriv = dev->private;
+	struct usb_device *usb = devpriv->usbdev;
+	int ret;
 	int nrec;
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		result = usb_bulk_msg(this_usbduxsub->usbdev,
-				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
-						      COMMAND_IN_EP),
-				      this_usbduxsub->insn_buffer, SIZEINSNBUF,
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, COMMAND_IN_EP),
+				      devpriv->insn_buffer, SIZEINSNBUF,
 				      &nrec, BULK_TIMEOUT);
-		if (result < 0)
-			return result;
-		if (le16_to_cpu(this_usbduxsub->insn_buffer[0]) == command)
-			return result;
+		if (ret < 0)
+			return ret;
+		if (le16_to_cpu(devpriv->insn_buffer[0]) == command)
+			return ret;
 	}
-	/* this is only reached if the data has been requested a couple of
-	 * times */
+	/* command not received */
 	return -EFAULT;
 }
 
@@ -1037,7 +1036,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+		err = receive_dux_commands(dev, SENDSINGLEAD);
 		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return 0;
@@ -1362,7 +1361,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 		up(&this_usbduxsub->sem);
 		return err;
 	}
-	err = receive_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	err = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1392,7 +1391,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 		return err;
 	}
 
-	err = receive_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);
+	err = receive_dux_commands(dev, READCOUNTERCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;

commit 49cc49dd9e36c7154fc9da528b85db0eb7605969
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:15:22 2013 -0700

    staging: comedi: usbdux: tidy up send_dux_commands()
    
    For aesthetic reasons, pass the comedi_device pointer to this function
    instead of the private data pointer. Rename the local variable used
    for the private data pointer to the comedi "norm".
    
    Add a local variable for the usb_device pointer to tidy up the
    usb_bulk_msg() call.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6a757f754d5f..d2a3a1accb85 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -847,16 +847,16 @@ static int8_t create_adc_command(unsigned int chan, int range)
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(struct usbdux_private *this_usbduxsub, int cmd_type)
+static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
+	struct usbdux_private *devpriv = dev->private;
+	struct usb_device *usb = devpriv->usbdev;
 	int nsent;
 
-	this_usbduxsub->dux_commands[0] = cmd_type;
+	devpriv->dux_commands[0] = cmd_type;
 
-	return usb_bulk_msg(this_usbduxsub->usbdev,
-			    usb_sndbulkpipe(this_usbduxsub->usbdev,
-					    COMMAND_OUT_EP),
-			    this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
+	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, COMMAND_OUT_EP),
+			    devpriv->dux_commands, SIZEOFDUXBUFFER,
 			    &nsent, BULK_TIMEOUT);
 }
 
@@ -940,7 +940,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    create_adc_command(chan, range);
 	}
 
-	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
+	result = send_dux_commands(dev, SENDADCOMMANDS);
 	if (result < 0) {
 		up(&this_usbduxsub->sem);
 		return result;
@@ -1030,7 +1030,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	this_usbduxsub->dux_commands[1] = create_adc_command(chan, range);
 
 	/* adc commands */
-	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	err = send_dux_commands(dev, SENDSINGLEAD);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1100,7 +1100,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		this_usbduxsub->out_buffer[chan] = data[i];
 		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
-		err = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);
+		err = send_dux_commands(dev, SENDDACOMMANDS);
 		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return err;
@@ -1357,7 +1357,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 
 	/* This command also tells the firmware to return */
 	/* the digital input lines */
-	err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	err = send_dux_commands(dev, SENDDIOBITSCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1386,7 +1386,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	err = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);
+	err = send_dux_commands(dev, READCOUNTERCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1417,7 +1417,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 	this_usbduxsub->dux_commands[1] = insn->chanspec;
 	*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);
 
-	err = send_dux_commands(this_usbduxsub, WRITECOUNTERCOMMAND);
+	err = send_dux_commands(dev, WRITECOUNTERCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1478,7 +1478,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	/* unlink only if it is really running */
 	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
-	return send_dux_commands(this_usbduxsub, SENDPWMOFF);
+	return send_dux_commands(dev, SENDPWMOFF);
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)
@@ -1587,7 +1587,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	}
 
 	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwn_delay);
-	ret = send_dux_commands(this_usbduxsub, SENDPWMON);
+	ret = send_dux_commands(dev, SENDPWMON);
 	if (ret < 0)
 		return ret;
 

commit 5d293d904c944894785f6a7be85acfc85ac4cfac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:15:04 2013 -0700

    staging: comedi: usbdux: remove 'interface' from private data
    
    This back pointer is only used for a couple dev_printk() messages and
    during the detach.
    
    For the dev_printk() we can use the dev->class_dev. In the detach we
    can get the usb_interface from the comedi_device.
    
    Do that and remove the back pointer from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 8db118019a3c..6a757f754d5f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -227,8 +227,6 @@ struct usbdux_private {
 	int16_t *out_buffer;
 	/* interface number */
 	int ifnum;
-	/* interface structure in 2.6 */
-	struct usb_interface *interface;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -634,7 +632,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 		return 0;
 
 	if (size > FIRMWARE_MAX_LEN) {
-		dev_err(&usbduxsub->interface->dev,
+		dev_err(dev->class_dev,
 			"usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
@@ -660,8 +658,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 			      tmp, 1,
 			      BULK_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: can not stop firmware\n");
+		dev_err(dev->class_dev, "can not stop firmware\n");
 		goto done;
 	}
 
@@ -673,8 +670,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 			      buf, size,
 			      BULK_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: firmware upload failed\n");
+		dev_err(dev->class_dev, "firmware upload failed\n");
 		goto done;
 	}
 
@@ -687,8 +683,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 			      tmp, 1,
 			      BULK_TIMEOUT);
 	if (ret < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: can not start firmware\n");
+		dev_err(dev->class_dev, "can not start firmware\n");
 
 done:
 	kfree(tmp);
@@ -1902,7 +1897,6 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	sema_init(&devpriv->sem, 1);
 
 	devpriv->usbdev = usb;
-	devpriv->interface = intf;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
 
@@ -2005,12 +1999,13 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 static void usbdux_detach(struct comedi_device *dev)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usbdux_private *devpriv = dev->private;
 
 	if (devpriv) {
 		down(&devpriv->sem);
 
-		usb_set_intfdata(devpriv->interface, NULL);
+		usb_set_intfdata(intf, NULL);
 
 		if (devpriv->pwm_cmd_running)
 			usbduxsub_unlink_pwm_urbs(devpriv);

commit cc8cb3da9e0fdaca684089c97708210655b2f343
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:14:42 2013 -0700

    staging: comedi: usbdux: remove 'comedidev' from private data
    
    This back pointer is no longer needed by the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ad537ed5fc40..8db118019a3c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -229,8 +229,6 @@ struct usbdux_private {
 	int ifnum;
 	/* interface structure in 2.6 */
 	struct usb_interface *interface;
-	/* comedi device for the interrupt context */
-	struct comedi_device *comedidev;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -1903,7 +1901,6 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	sema_init(&devpriv->sem, 1);
 
-	devpriv->comedidev = dev;
 	devpriv->usbdev = usb;
 	devpriv->interface = intf;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
@@ -2024,8 +2021,6 @@ static void usbdux_detach(struct comedi_device *dev)
 
 		usbdux_free_usb_buffers(devpriv);
 
-		devpriv->comedidev = NULL;
-
 		up(&devpriv->sem);
 	}
 }

commit 5a80fa0429b7b6e3b32813614178d4be302f5ea0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:13:34 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_submit_pwm_urbs()
    
    Pass the comedi_device pointer (the urb context) to this function
    instead of the private data pointer.
    
    Use a local variable for the urb pointer that is setup and submitted.
    
    Remove the sanity check of the private data. This function can only
    get called if the allocation was successful during the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7304ef0e2ded..ad537ed5fc40 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1546,25 +1546,20 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_pwm_urbs(struct usbdux_private *usbduxsub)
+static int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)
 {
-	int err_flag;
-
-	if (!usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	struct urb *urb = devpriv->urb_pwm;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(usbduxsub->urb_pwm,
-			  usbduxsub->usbdev,
-			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
-			  usbduxsub->urb_pwm->transfer_buffer,
-			  usbduxsub->size_pwm_buf, usbduxsub_pwm_irq,
-			  usbduxsub->comedidev);
-
-	err_flag = usb_submit_urb(usbduxsub->urb_pwm, GFP_ATOMIC);
-	if (err_flag)
-		return err_flag;
-	return 0;
+	usb_fill_bulk_urb(urb, devpriv->usbdev,
+			  usb_sndbulkpipe(devpriv->usbdev, PWM_EP),
+			  urb->transfer_buffer,
+			  devpriv->size_pwm_buf,
+			  usbduxsub_pwm_irq,
+			  dev);
+
+	return usb_submit_urb(urb, GFP_ATOMIC);
 }
 
 static int usbdux_pwm_period(struct comedi_device *dev,
@@ -1608,7 +1603,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 		((char *)(this_usbduxsub->urb_pwm->transfer_buffer))[i] = 0;
 
 	this_usbduxsub->pwm_cmd_running = 1;
-	ret = usbduxsub_submit_pwm_urbs(this_usbduxsub);
+	ret = usbduxsub_submit_pwm_urbs(dev);
 	if (ret < 0) {
 		this_usbduxsub->pwm_cmd_running = 0;
 		return ret;

commit 6754698b6a19ad1eb9075b2a49dba85850840a3f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:13:15 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_submit_outurbs()
    
    Pass the comedi_device pointer (the urb context) to this function
    instead of the private data pointer.
    
    Use a local variable for the urb pointers that are setup and submitted.
    
    Remove the sanity check of the private data. This function can only
    get called if the allocation was successful during the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 4d4ce3f184b7..7304ef0e2ded 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -723,22 +723,25 @@ static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 	return 0;
 }
 
-static int usbduxsub_submit_outurbs(struct usbdux_private *usbduxsub)
+static int usbduxsub_submit_outurbs(struct comedi_device *dev)
 {
-	int i, err_flag;
+	struct usbdux_private *devpriv = dev->private;
+	struct urb *urb;
+	int ret;
+	int i;
 
-	if (!usbduxsub)
-		return -EFAULT;
+	for (i = 0; i < devpriv->num_out_buffers; i++) {
+		urb = devpriv->urb_out[i];
 
-	for (i = 0; i < usbduxsub->num_out_buffers; i++) {
 		/* in case of a resubmission after an unlink... */
-		usbduxsub->urb_out[i]->context = usbduxsub->comedidev;
-		usbduxsub->urb_out[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urb_out[i]->status = 0;
-		usbduxsub->urb_out[i]->transfer_flags = URB_ISO_ASAP;
-		err_flag = usb_submit_urb(usbduxsub->urb_out[i], GFP_ATOMIC);
-		if (err_flag)
-			return err_flag;
+		urb->context = dev;
+		urb->dev = devpriv->usbdev;
+		urb->status = 0;
+		urb->transfer_flags = URB_ISO_ASAP;
+
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret)
+			return ret;
 	}
 	return 0;
 }
@@ -1131,7 +1134,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 	}
 	if (!(this_usbduxsub->ao_cmd_running)) {
 		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_outurbs(this_usbduxsub);
+		ret = usbduxsub_submit_outurbs(dev);
 		if (ret < 0) {
 			this_usbduxsub->ao_cmd_running = 0;
 			up(&this_usbduxsub->sem);
@@ -1289,7 +1292,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_outurbs(this_usbduxsub);
+		ret = usbduxsub_submit_outurbs(dev);
 		if (ret < 0) {
 			this_usbduxsub->ao_cmd_running = 0;
 			/* fixme: unlink here?? */

commit 865d9eedd12570f5f296bf876edc09df78095bfc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:12:35 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_submit_inurbs()
    
    Pass the comedi_device pointer (the urb context) to this function
    instead of the private data pointer.
    
    Use a local variable for the urb pointers that are setup and submitted.
    
    Remove the sanity check of the private data. This function can only
    get called if the allocation was successful during the attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7b2e072aad1b..4d4ce3f184b7 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -698,24 +698,27 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbduxsub_submit_inurbs(struct usbdux_private *usbduxsub)
+static int usbduxsub_submit_inurbs(struct comedi_device *dev)
 {
-	int i, err_flag;
-
-	if (!usbduxsub)
-		return -EFAULT;
+	struct usbdux_private *devpriv = dev->private;
+	struct urb *urb;
+	int ret;
+	int i;
 
 	/* Submit all URBs and start the transfer on the bus */
-	for (i = 0; i < usbduxsub->num_in_buffers; i++) {
+	for (i = 0; i < devpriv->num_in_buffers; i++) {
+		urb = devpriv->urb_in[i];
+
 		/* in case of a resubmission after an unlink... */
-		usbduxsub->urb_in[i]->interval = usbduxsub->ai_interval;
-		usbduxsub->urb_in[i]->context = usbduxsub->comedidev;
-		usbduxsub->urb_in[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urb_in[i]->status = 0;
-		usbduxsub->urb_in[i]->transfer_flags = URB_ISO_ASAP;
-		err_flag = usb_submit_urb(usbduxsub->urb_in[i], GFP_ATOMIC);
-		if (err_flag)
-			return err_flag;
+		urb->interval = devpriv->ai_interval;
+		urb->context = dev;
+		urb->dev = devpriv->usbdev;
+		urb->status = 0;
+		urb->transfer_flags = URB_ISO_ASAP;
+
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret)
+			return ret;
 	}
 	return 0;
 }
@@ -899,7 +902,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 	}
 	if (!(this_usbduxsub->ai_cmd_running)) {
 		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_inurbs(this_usbduxsub);
+		ret = usbduxsub_submit_inurbs(dev);
 		if (ret < 0) {
 			this_usbduxsub->ai_cmd_running = 0;
 			up(&this_usbduxsub->sem);
@@ -986,7 +989,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_inurbs(this_usbduxsub);
+		ret = usbduxsub_submit_inurbs(dev);
 		if (ret < 0) {
 			this_usbduxsub->ai_cmd_running = 0;
 			/* fixme: unlink here?? */

commit 91aa6b2193a178dd409ac78a5b909881db8f829c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:12:14 2013 -0700

    staging: comedi: usbdux: remove dev_printk() noise
    
    Most of these are just function trace noise. The rest report errors
    that the user can't do anything about so they amount to added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6707950e8bdf..7b2e072aad1b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -275,9 +275,6 @@ static int usbduxsub_unlink_inurbs(struct usbdux_private *usbduxsub_tmp)
 				 * cancelled. */
 				usb_kill_urb(usbduxsub_tmp->urb_in[i]);
 			}
-			dev_dbg(&usbduxsub_tmp->interface->dev,
-				"comedi: usbdux: unlinked InURB %d, err=%d\n",
-				i, err);
 		}
 	}
 	return err;
@@ -292,11 +289,8 @@ static int usbdux_ai_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
-	if (!this_usbduxsub) {
-		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");
 
 	if (do_unlink) {
 		/* stop aquistion */
@@ -323,8 +317,6 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_cancel\n");
-
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
 	/* unlink only if the urb really has been submitted */
@@ -466,10 +458,6 @@ static int usbduxsub_unlink_outurbs(struct usbdux_private *usbduxsub_tmp)
 		for (i = 0; i < usbduxsub_tmp->num_out_buffers; i++) {
 			if (usbduxsub_tmp->urb_out[i])
 				usb_kill_urb(usbduxsub_tmp->urb_out[i]);
-
-			dev_dbg(&usbduxsub_tmp->interface->dev,
-				"comedi: usbdux: unlinked OutURB %d: res=%d\n",
-				i, err);
 		}
 	}
 	return err;
@@ -484,7 +472,6 @@ static int usbdux_ao_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 
 	if (!this_usbduxsub)
 		return -EFAULT;
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");
 
 	if (do_unlink)
 		ret = usbduxsub_unlink_outurbs(this_usbduxsub);
@@ -726,19 +713,9 @@ static int usbduxsub_submit_inurbs(struct usbdux_private *usbduxsub)
 		usbduxsub->urb_in[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urb_in[i]->status = 0;
 		usbduxsub->urb_in[i]->transfer_flags = URB_ISO_ASAP;
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",
-			usbduxsub->comedidev->minor, i,
-			(usbduxsub->urb_in[i]->context),
-			(usbduxsub->urb_in[i]->dev),
-			(usbduxsub->urb_in[i]->interval));
 		err_flag = usb_submit_urb(usbduxsub->urb_in[i], GFP_ATOMIC);
-		if (err_flag) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ai: usb_submit_urb(%d) error %d\n",
-				i, err_flag);
+		if (err_flag)
 			return err_flag;
-		}
 	}
 	return 0;
 }
@@ -751,20 +728,14 @@ static int usbduxsub_submit_outurbs(struct usbdux_private *usbduxsub)
 		return -EFAULT;
 
 	for (i = 0; i < usbduxsub->num_out_buffers; i++) {
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi_: submitting out-urb[%d]\n", i);
 		/* in case of a resubmission after an unlink... */
 		usbduxsub->urb_out[i]->context = usbduxsub->comedidev;
 		usbduxsub->urb_out[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urb_out[i]->status = 0;
 		usbduxsub->urb_out[i]->transfer_flags = URB_ISO_ASAP;
 		err_flag = usb_submit_urb(usbduxsub->urb_out[i], GFP_ATOMIC);
-		if (err_flag) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ao: usb_submit_urb(%d) error %d\n",
-				i, err_flag);
+		if (err_flag)
 			return err_flag;
-		}
 	}
 	return 0;
 }
@@ -879,20 +850,15 @@ static int8_t create_adc_command(unsigned int chan, int range)
 
 static int send_dux_commands(struct usbdux_private *this_usbduxsub, int cmd_type)
 {
-	int result, nsent;
+	int nsent;
 
 	this_usbduxsub->dux_commands[0] = cmd_type;
-	result = usb_bulk_msg(this_usbduxsub->usbdev,
-			      usb_sndbulkpipe(this_usbduxsub->usbdev,
-					      COMMAND_OUT_EP),
-			      this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
-			      &nsent, BULK_TIMEOUT);
-	if (result < 0)
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-			"could not transmit dux_command to the usb-device, "
-			"err=%d\n", this_usbduxsub->comedidev->minor, result);
-
-	return result;
+
+	return usb_bulk_msg(this_usbduxsub->usbdev,
+			    usb_sndbulkpipe(this_usbduxsub->usbdev,
+					    COMMAND_OUT_EP),
+			    this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
+			    &nsent, BULK_TIMEOUT);
 }
 
 static int receive_dux_commands(struct usbdux_private *this_usbduxsub, int command)
@@ -907,21 +873,13 @@ static int receive_dux_commands(struct usbdux_private *this_usbduxsub, int comma
 						      COMMAND_IN_EP),
 				      this_usbduxsub->insn_buffer, SIZEINSNBUF,
 				      &nrec, BULK_TIMEOUT);
-		if (result < 0) {
-			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-				"insn: USB error %d while receiving DUX command"
-				"\n", this_usbduxsub->comedidev->minor, result);
+		if (result < 0)
 			return result;
-		}
 		if (le16_to_cpu(this_usbduxsub->insn_buffer[0]) == command)
 			return result;
 	}
 	/* this is only reached if the data has been requested a couple of
 	 * times */
-	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
-		"wrong data returned from firmware: want cmd %d, got cmd %d.\n",
-		this_usbduxsub->comedidev->minor, command,
-		le16_to_cpu(this_usbduxsub->insn_buffer[0]));
 	return -EFAULT;
 }
 
@@ -934,13 +892,8 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_inttrig\n", dev->minor);
 
 	if (trignum != 0) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
-			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
@@ -948,18 +901,11 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		this_usbduxsub->ai_cmd_running = 1;
 		ret = usbduxsub_submit_inurbs(this_usbduxsub);
 		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux_ai_inttrig: "
-				"urbSubmit: err=%d\n", dev->minor, ret);
 			this_usbduxsub->ai_cmd_running = 0;
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
-	} else {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ai_inttrig but acqu is already running\n",
-			dev->minor);
 	}
 	up(&this_usbduxsub->sem);
 	return 1;
@@ -976,15 +922,9 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_cmd\n", dev->minor);
-
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-			"ai_cmd not possible. Another ai_cmd is running.\n",
-			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
@@ -995,20 +935,12 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
 		range = CR_RANGE(cmd->chanlist[i]);
-		if (i >= NUMCHANNELS) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: channel list too long\n",
-				dev->minor);
+		if (i >= NUMCHANNELS)
 			break;
-		}
 		this_usbduxsub->dux_commands[i + 2] =
 		    create_adc_command(chan, range);
 	}
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi %d: sending commands to the usb device: size=%u\n",
-		dev->minor, NUMCHANNELS);
-
 	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
 	if (result < 0) {
 		up(&this_usbduxsub->sem);
@@ -1036,10 +968,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
 	}
 	if (this_usbduxsub->ai_timer < 1) {
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: ai_cmd: "
-			"timer=%d, scan_begin_arg=%d. "
-			"Not properly tested by cmdtest?\n", dev->minor,
-			this_usbduxsub->ai_timer, cmd->scan_begin_arg);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
@@ -1090,15 +1018,8 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return 0;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
-		dev->minor, insn->n, insn->subdev);
-
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ai_insn_read not possible. "
-			"Async Command is running.\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
@@ -1165,23 +1086,13 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: ao_insn_write\n", dev->minor);
-
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ao_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_insn_write: "
-			"ERROR: asynchronous ao_cmd is running\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
-			dev->minor, chan, i, data[i]);
-
 		/* number of channels: 1 */
 		this_usbduxsub->dux_commands[1] = 1;
 		/* one 16 bit value */
@@ -1212,9 +1123,6 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 
 	down(&this_usbduxsub->sem);
 	if (trignum != 0) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
-			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
@@ -1222,18 +1130,11 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		this_usbduxsub->ao_cmd_running = 1;
 		ret = usbduxsub_submit_outurbs(this_usbduxsub);
 		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux_ao_inttrig: submitURB: "
-				"err=%d\n", dev->minor, ret);
 			this_usbduxsub->ao_cmd_running = 0;
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
-	} else {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_inttrig but acqu is already running.\n",
-			dev->minor);
 	}
 	up(&this_usbduxsub->sem);
 	return 1;
@@ -1334,24 +1235,15 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: %s\n", dev->minor, __func__);
 
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
 		gain = CR_RANGE(cmd->chanlist[i]);
-		if (i >= NUMOUTCHANNELS) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: %s: channel list too long\n",
-				dev->minor, __func__);
+		if (i >= NUMOUTCHANNELS)
 			break;
-		}
 		this_usbduxsub->dac_commands[i] = (chan << 6);
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: dac command for ch %d is %x\n",
-			dev->minor, i, this_usbduxsub->dac_commands[i]);
 	}
 
 	/* we count in steps of 1ms (125us) */
@@ -1364,21 +1256,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* 1ms */
 		/* timing of the scan: we get all channels at once */
 		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: scan_begin_src=%d, scan_begin_arg=%d, "
-			"convert_src=%d, convert_arg=%d\n", dev->minor,
-			cmd->scan_begin_src, cmd->scan_begin_arg,
-			cmd->convert_src, cmd->convert_arg);
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_timer=%d (ms)\n",
-			dev->minor, this_usbduxsub->ao_timer);
 		if (this_usbduxsub->ao_timer < 1) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux: ao_timer=%d, "
-				"scan_begin_arg=%d. "
-				"Not properly tested by cmdtest?\n",
-				dev->minor, this_usbduxsub->ao_timer,
-				cmd->scan_begin_arg);
 			up(&this_usbduxsub->sem);
 			return -EINVAL;
 		}
@@ -1569,8 +1447,6 @@ static int usbduxsub_unlink_pwm_urbs(struct usbdux_private *usbduxsub_tmp)
 	if (usbduxsub_tmp && usbduxsub_tmp->urb_pwm) {
 		if (usbduxsub_tmp->urb_pwm)
 			usb_kill_urb(usbduxsub_tmp->urb_pwm);
-		dev_dbg(&usbduxsub_tmp->interface->dev,
-			"comedi: unlinked PwmURB: res=%d\n", err);
 	}
 	return err;
 }
@@ -1585,7 +1461,6 @@ static int usbdux_pwm_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);
 	if (do_unlink)
 		ret = usbduxsub_unlink_pwm_urbs(this_usbduxsub);
 
@@ -1604,10 +1479,6 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	/* unlink only if it is really running */
 	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi %d: sending pwm off command to the usb device.\n",
-		dev->minor);
-
 	return send_dux_commands(this_usbduxsub, SENDPWMOFF);
 }
 
@@ -1676,8 +1547,6 @@ static int usbduxsub_submit_pwm_urbs(struct usbdux_private *usbduxsub)
 	if (!usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");
-
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(usbduxsub->urb_pwm,
 			  usbduxsub->usbdev,
@@ -1687,12 +1556,8 @@ static int usbduxsub_submit_pwm_urbs(struct usbdux_private *usbduxsub)
 			  usbduxsub->comedidev);
 
 	err_flag = usb_submit_urb(usbduxsub->urb_pwm, GFP_ATOMIC);
-	if (err_flag) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: usbdux: pwm: usb_submit_urb error %d\n",
-			err_flag);
+	if (err_flag)
 		return err_flag;
-	}
 	return 0;
 }
 
@@ -1703,23 +1568,15 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: illegal period setting for pwm.\n",
-			dev->minor);
 		return -EAGAIN;
 	} else {
 		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
-		if (fx2delay > 255) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: period %d for pwm is too low.\n",
-				dev->minor, period);
+		if (fx2delay > 255)
 			return -EAGAIN;
-		}
 	}
 	this_usbduxsub->pwn_delay = fx2delay;
 	this_usbduxsub->pwm_period = period;
-	dev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",
-		__func__, period, fx2delay);
+
 	return 0;
 }
 
@@ -1730,9 +1587,6 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	int ret, i;
 	struct usbdux_private *this_usbduxsub = dev->private;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
-		dev->minor, __func__);
-
 	if (this_usbduxsub->pwm_cmd_running) {
 		/* already running */
 		return 0;
@@ -1841,8 +1695,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 		/* switch it on */
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: pwm on\n", dev->minor, __func__);
 		/*
 		 * if not zero the PWM is limited to a certain time which is
 		 * not supported here
@@ -1851,8 +1703,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 			return -EINVAL;
 		return usbdux_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: pwm off\n", dev->minor, __func__);
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
 		/*
@@ -1862,8 +1712,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 		data[1] = this_usbduxsub->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: setting period\n", dev->minor, __func__);
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
 		data[1] = this_usbduxsub->pwm_period;

commit 38691ec1106b2c4345f271746c1fcd7174d1130d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:11:53 2013 -0700

    staging: comedi: usbdux: tidy up the comedi_lrange tables
    
    Cleanup the whitespace in the tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 226b2945cd1f..6707950e8bdf 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -185,26 +185,20 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* number of retries to get the right dux command */
 #define RETRIES 10
 
-/**************************************************/
-/* comedi constants */
-static const struct comedi_lrange range_usbdux_ai_range = { 4, {
-								BIP_RANGE
-								(4.096),
-								BIP_RANGE(4.096
-									  / 2),
-								UNI_RANGE
-								(4.096),
-								UNI_RANGE(4.096
-									  / 2)
-								}
+static const struct comedi_lrange range_usbdux_ai_range = {
+	4, {
+		BIP_RANGE(4.096),
+		BIP_RANGE(4.096 / 2),
+		UNI_RANGE(4.096),
+		UNI_RANGE(4.096 / 2)
+	}
 };
 
-static const struct comedi_lrange range_usbdux_ao_range = { 2, {
-								BIP_RANGE
-								(4.096),
-								UNI_RANGE
-								(4.096),
-								}
+static const struct comedi_lrange range_usbdux_ao_range = {
+	2, {
+		BIP_RANGE(4.096),
+		UNI_RANGE(4.096)
+	}
 };
 
 struct usbdux_private {

commit e5acdc3561b14a73f5de6bca8a703d9faa7d191c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:11:33 2013 -0700

    staging: comedi: usbdux: remove the SUBDEV_* defines
    
    These defines are only used to index the dev->subdevices array
    during the attach. It's cleaner to just open-code the values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9f1da8eb150d..226b2945cd1f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -182,21 +182,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* must have more buffers due to buggy USB ctr */
 #define NUMOFOUTBUFFERSHIGH    10
 
-/* Analogue in subdevice */
-#define SUBDEV_AD             0
-
-/* Analogue out subdevice */
-#define SUBDEV_DA             1
-
-/* Digital I/O */
-#define SUBDEV_DIO            2
-
-/* counter */
-#define SUBDEV_COUNTER        3
-
-/* timer aka pwm output */
-#define SUBDEV_PWM            4
-
 /* number of retries to get the right dux command */
 #define RETRIES 10
 
@@ -2113,7 +2098,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	/* Analog Input subdevice */
-	s = &dev->subdevices[SUBDEV_AD];
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
@@ -2127,7 +2112,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	s->cancel	= usbdux_ai_cancel;
 
 	/* Analog Output subdevice */
-	s = &dev->subdevices[SUBDEV_DA];
+	s = &dev->subdevices[1];
 	dev->write_subdev = s;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
@@ -2142,7 +2127,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	s->insn_write	= usbdux_ao_insn_write;
 
 	/* Digital I/O subdevice */
-	s = &dev->subdevices[SUBDEV_DIO];
+	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DIO;
 	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
 	s->n_chan	= 8;
@@ -2152,7 +2137,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	s->insn_config	= usbdux_dio_insn_config;
 
 	/* Counter subdevice */
-	s = &dev->subdevices[SUBDEV_COUNTER];
+	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_COUNTER;
 	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
 	s->n_chan	= 4;
@@ -2163,7 +2148,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	if (devpriv->high_speed) {
 		/* PWM subdevice */
-		s = &dev->subdevices[SUBDEV_PWM];
+		s = &dev->subdevices[4];
 		s->type		= COMEDI_SUBD_PWM;
 		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan	= 8;

commit c9f3363a301844bbb2fa2d35e4baf4d9fd025df8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:11:14 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_pwm_irq()
    
    Rename the local variables to the comedi "norm".
    
    Use dev->class_dev as the device for all dev_printk() messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 292832b2b5e9..9f1da8eb150d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1634,19 +1634,9 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
+	struct comedi_device *dev = urb->context;
+	struct usbdux_private *devpriv = dev->private;
 	int ret;
-	struct usbdux_private *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-
-	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
-
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbdux_private */
-	this_usbduxsub = this_comedidev->private;
-
-	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -1661,42 +1651,41 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		 * after an unlink command, unplug, ... etc
 		 * no unlink needed here. Already shutting down.
 		 */
-		if (this_usbduxsub->pwm_cmd_running)
-			usbdux_pwm_stop(this_usbduxsub, 0);
+		if (devpriv->pwm_cmd_running)
+			usbdux_pwm_stop(devpriv, 0);
 
 		return;
 
 	default:
 		/* a real error */
-		if (this_usbduxsub->pwm_cmd_running) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi_: Non-zero urb status received in "
-				"pwm intr context: %d\n", urb->status);
-			usbdux_pwm_stop(this_usbduxsub, 0);
+		if (devpriv->pwm_cmd_running) {
+			dev_err(dev->class_dev,
+				"Non-zero urb status received in pwm intr context: %d\n",
+				urb->status);
+			usbdux_pwm_stop(devpriv, 0);
 		}
 		return;
 	}
 
 	/* are we actually running? */
-	if (!(this_usbduxsub->pwm_cmd_running))
+	if (!devpriv->pwm_cmd_running)
 		return;
 
-	urb->transfer_buffer_length = this_usbduxsub->size_pwm_buf;
-	urb->dev = this_usbduxsub->usbdev;
+	urb->transfer_buffer_length = devpriv->size_pwm_buf;
+	urb->dev = devpriv->usbdev;
 	urb->status = 0;
-	if (this_usbduxsub->pwm_cmd_running) {
+	if (devpriv->pwm_cmd_running) {
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi_: pwm urb resubm failed in int-cont. "
-				"ret=%d", ret);
+			dev_err(dev->class_dev,
+				"pwm urb resubm failed in int-cont. ret=%d",
+				ret);
 			if (ret == EL2NSYNC)
-				dev_err(&this_usbduxsub->interface->dev,
-					"buggy USB host controller or bug in "
-					"IRQ handling!\n");
+				dev_err(dev->class_dev,
+					"buggy USB host controller or bug in IRQ handling!\n");
 
 			/* don't do an unlink here */
-			usbdux_pwm_stop(this_usbduxsub, 0);
+			usbdux_pwm_stop(devpriv, 0);
 		}
 	}
 }

commit e057288ffd62ae63536d1f37dad4a22d2b84148b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:10:54 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_ao_isoc_irq()
    
    Rename the local variables to the comedi "norm".
    
    The comedi_subdevice in this function is actually the dev->write_subdev
    that was initialized in the attach. Use that instead of accessing the
    dev->subdevices array directly.
    
    Use dev->class_dev as the device for all dev_printk() messages.
    
    Instead of using the 'comedidev' back pointer in the private data, use
    the comedi_device 'dev' that we already have.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d93d10950abd..292832b2b5e9 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -535,18 +535,11 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 
 static void usbduxsub_ao_isoc_irq(struct urb *urb)
 {
+	struct comedi_device *dev = urb->context;
+	struct comedi_subdevice *s = dev->write_subdev;
+	struct usbdux_private *devpriv = dev->private;
 	int i, ret;
 	int8_t *datap;
-	struct usbdux_private *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbdux_private */
-	this_usbduxsub = this_comedidev->private;
-
-	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -559,47 +552,47 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	case -ECONNABORTED:
 		/* after an unlink command, unplug, ... etc */
 		/* no unlink needed here. Already shutting down. */
-		if (this_usbduxsub->ao_cmd_running) {
+		if (devpriv->ao_cmd_running) {
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
-			usbdux_ao_stop(this_usbduxsub, 0);
+			comedi_event(dev, s);
+			usbdux_ao_stop(devpriv, 0);
 		}
 		return;
 
 	default:
 		/* a real error */
-		if (this_usbduxsub->ao_cmd_running) {
-			dev_err(&urb->dev->dev,
-				"comedi_: Non-zero urb status received in ao "
-				"intr context: %d\n", urb->status);
+		if (devpriv->ao_cmd_running) {
+			dev_err(dev->class_dev,
+				"Non-zero urb status received in ao intr context: %d\n",
+				urb->status);
 			s->async->events |= COMEDI_CB_ERROR;
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			/* we do an unlink if we are in the high speed mode */
-			usbdux_ao_stop(this_usbduxsub, 0);
+			usbdux_ao_stop(devpriv, 0);
 		}
 		return;
 	}
 
 	/* are we actually running? */
-	if (!(this_usbduxsub->ao_cmd_running))
+	if (!devpriv->ao_cmd_running)
 		return;
 
 	/* normal operation: executing a command in this subdevice */
-	this_usbduxsub->ao_counter--;
-	if ((int)this_usbduxsub->ao_counter <= 0) {
+	devpriv->ao_counter--;
+	if ((int)devpriv->ao_counter <= 0) {
 		/* timer zero */
-		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+		devpriv->ao_counter = devpriv->ao_timer;
 
 		/* handle non continous acquisition */
-		if (!(this_usbduxsub->ao_continous)) {
+		if (!devpriv->ao_continous) {
 			/* fixed number of samples */
-			this_usbduxsub->ao_sample_count--;
-			if (this_usbduxsub->ao_sample_count < 0) {
+			devpriv->ao_sample_count--;
+			if (devpriv->ao_sample_count < 0) {
 				/* all samples transmitted */
-				usbdux_ao_stop(this_usbduxsub, 0);
+				usbdux_ao_stop(devpriv, 0);
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(this_usbduxsub->comedidev, s);
+				comedi_event(dev, s);
 				/* no resubmit of the urb */
 				return;
 			}
@@ -619,9 +612,7 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			ret = comedi_buf_get(s->async, &temp);
 			datap[0] = temp;
 			datap[1] = temp >> 8;
-			datap[2] = this_usbduxsub->dac_commands[i];
-			/* printk("data[0]=%x, data[1]=%x, data[2]=%x\n", */
-			/* datap[0],datap[1],datap[2]); */
+			datap[2] = devpriv->dac_commands[i];
 			if (ret < 0) {
 				dev_err(&urb->dev->dev,
 					"comedi: buffer underflow\n");
@@ -630,39 +621,35 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 			}
 			/* transmit data to comedi */
 			s->async->events |= COMEDI_CB_BLOCK;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 		}
 	}
 	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = this_usbduxsub->usbdev;
+	urb->dev = devpriv->usbdev;
 	urb->status = 0;
-	if (this_usbduxsub->ao_cmd_running) {
-		if (this_usbduxsub->high_speed) {
-			/* uframes */
-			urb->interval = 8;
-		} else {
-			/* frames */
-			urb->interval = 1;
-		}
+	if (devpriv->ao_cmd_running) {
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
 		urb->number_of_packets = 1;
 		urb->iso_frame_desc[0].offset = 0;
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].status = 0;
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
-			dev_err(&urb->dev->dev,
-				"comedi_: ao urb resubm failed in int-cont. "
-				"ret=%d", ret);
+			dev_err(dev->class_dev,
+				"ao urb resubm failed in int-cont. ret=%d",
+				ret);
 			if (ret == EL2NSYNC)
-				dev_err(&urb->dev->dev,
-					"buggy USB host controller or bug in "
-					"IRQ handling!\n");
+				dev_err(dev->class_dev,
+					"buggy USB host controller or bug in IRQ handling!\n");
 
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			/* don't do an unlink here */
-			usbdux_ao_stop(this_usbduxsub, 0);
+			usbdux_ao_stop(devpriv, 0);
 		}
 	}
 }

commit 0a9502f2c36539b6ad7fc5b9230ee2d9d34b6777
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:10:32 2013 -0700

    staging: comedi: usbdux: tidy up usbduxsub_ai_isoc_irq()
    
    Rename the local variables to the comedi "norm".
    
    The comedi_subdevice in this function is actually the dev->read_subdev
    that was initialized in the attach. Use that instead of accessing the
    dev->subdevices array directly.
    
    Use dev->class_dev as the device for all dev_printk() messages.
    
    Instead of using the 'comedidev' back pointer in the private data, use
    the comedi_device 'dev' that we already have.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 32021f03bda2..d93d10950abd 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -357,33 +357,22 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 /* analogue IN - interrupt service routine */
 static void usbduxsub_ai_isoc_irq(struct urb *urb)
 {
+	struct comedi_device *dev = urb->context;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct usbdux_private *devpriv = dev->private;
 	int i, err, n;
-	struct usbdux_private *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbdux_private */
-	this_usbduxsub = this_comedidev->private;
-	/* subdevice which is the AD converter */
-	s = &this_comedidev->subdevices[SUBDEV_AD];
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
-		memcpy(this_usbduxsub->in_buffer,
-		       urb->transfer_buffer, SIZEINBUF);
+		memcpy(devpriv->in_buffer, urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
 		/* error in the ISOchronous data */
 		/* we don't copy the data into the transfer buffer */
 		/* and recycle the last data byte */
-		dev_dbg(&urb->dev->dev,
-			"comedi%d: usbdux: CRC error in ISO IN stream.\n",
-			this_usbduxsub->comedidev->minor);
-
+		dev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");
 		break;
 
 	case -ECONNRESET:
@@ -391,29 +380,27 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
 		/* happens after an unlink command */
-		if (this_usbduxsub->ai_cmd_running) {
-			/* we are still running a command */
-			/* tell this comedi */
+		if (devpriv->ai_cmd_running) {
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			/* stop the transfer w/o unlink */
-			usbdux_ai_stop(this_usbduxsub, 0);
+			usbdux_ai_stop(devpriv, 0);
 		}
 		return;
 
 	default:
 		/* a real error on the bus */
 		/* pass error to comedi if we are really running a command */
-		if (this_usbduxsub->ai_cmd_running) {
-			dev_err(&urb->dev->dev,
-				"Non-zero urb status received in ai intr "
-				"context: %d\n", urb->status);
+		if (devpriv->ai_cmd_running) {
+			dev_err(dev->class_dev,
+				"Non-zero urb status received in ai intr context: %d\n",
+				urb->status);
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			/* don't do an unlink here */
-			usbdux_ai_stop(this_usbduxsub, 0);
+			usbdux_ai_stop(devpriv, 0);
 		}
 		return;
 	}
@@ -422,7 +409,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	 * at this point we are reasonably sure that nothing dodgy has happened
 	 * are we running a command?
 	 */
-	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
+	if (unlikely(!devpriv->ai_cmd_running)) {
 		/*
 		 * not running a command, do not continue execution if no
 		 * asynchronous command is running in particular not resubmit
@@ -430,44 +417,42 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 		return;
 	}
 
-	urb->dev = this_usbduxsub->usbdev;
+	urb->dev = devpriv->usbdev;
 
 	/* resubmit the urb */
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (unlikely(err < 0)) {
-		dev_err(&urb->dev->dev,
-			"comedi_: urb resubmit failed in int-context! err=%d\n",
-			err);
+		dev_err(dev->class_dev,
+			"urb resubmit failed in int-context! err=%d\n", err);
 		if (err == -EL2NSYNC)
-			dev_err(&urb->dev->dev,
-				"buggy USB host controller or bug in IRQ "
-				"handler!\n");
+			dev_err(dev->class_dev,
+				"buggy USB host controller or bug in IRQ handler!\n");
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxsub->comedidev, s);
+		comedi_event(dev, s);
 		/* don't do an unlink here */
-		usbdux_ai_stop(this_usbduxsub, 0);
+		usbdux_ai_stop(devpriv, 0);
 		return;
 	}
 
-	this_usbduxsub->ai_counter--;
-	if (likely(this_usbduxsub->ai_counter > 0))
+	devpriv->ai_counter--;
+	if (likely(devpriv->ai_counter > 0))
 		return;
 
 	/* timer zero, transfer measurements to comedi */
-	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+	devpriv->ai_counter = devpriv->ai_timer;
 
 	/* test, if we transmit only a fixed number of samples */
-	if (!(this_usbduxsub->ai_continous)) {
+	if (!devpriv->ai_continous) {
 		/* not continuous, fixed number of samples */
-		this_usbduxsub->ai_sample_count--;
+		devpriv->ai_sample_count--;
 		/* all samples received? */
-		if (this_usbduxsub->ai_sample_count < 0) {
+		if (devpriv->ai_sample_count < 0) {
 			/* prevent a resubmit next time */
-			usbdux_ai_stop(this_usbduxsub, 0);
+			usbdux_ai_stop(devpriv, 0);
 			/* say comedi that the acquistion is over */
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			return;
 		}
 	}
@@ -476,23 +461,21 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	for (i = 0; i < n; i++) {
 		/* transfer data */
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
-			err = comedi_buf_put
-			    (s->async,
-			     le16_to_cpu(this_usbduxsub->in_buffer[i]) ^ 0x800);
+			err = comedi_buf_put(s->async,
+			     le16_to_cpu(devpriv->in_buffer[i]) ^ 0x800);
 		} else {
-			err = comedi_buf_put
-			    (s->async,
-			     le16_to_cpu(this_usbduxsub->in_buffer[i]));
+			err = comedi_buf_put(s->async,
+			     le16_to_cpu(devpriv->in_buffer[i]));
 		}
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
-			usbdux_ai_stop(this_usbduxsub, 0);
+			usbdux_ai_stop(devpriv, 0);
 			return;
 		}
 	}
 	/* tell comedi that data is there */
 	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-	comedi_event(this_usbduxsub->comedidev, s);
+	comedi_event(dev, s);
 }
 
 static int usbduxsub_unlink_outurbs(struct usbdux_private *usbduxsub_tmp)

commit cc84f4f980449d5274ec38e33718f0cc76f66888
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:10:11 2013 -0700

    staging: comedi: usbdux: absorb usbdux_attach_common into caller
    
    This function is only called by usbdux_auto_attach(), absorb it.
    
    Also, there is no reason to down/up the semaphore during the attach.
    None of the subdevices are functioning yet so there are no commands
    being sent to the usb device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 460c06683435..32021f03bda2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1950,88 +1950,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 /* end of PWM */
 /*****************************************************************/
 
-static int usbdux_attach_common(struct comedi_device *dev)
-{
-	struct usbdux_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int ret;
-
-	down(&devpriv->sem);
-
-	ret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 5 : 4);
-	if (ret) {
-		up(&devpriv->sem);
-		return ret;
-	}
-
-	/* Analog Input subdevice */
-	s = &dev->subdevices[SUBDEV_AD];
-	dev->read_subdev = s;
-	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	s->n_chan	= 8;
-	s->maxdata	= 0x0fff;
-	s->len_chanlist	= 8;
-	s->range_table	= &range_usbdux_ai_range;
-	s->insn_read	= usbdux_ai_insn_read;
-	s->do_cmdtest	= usbdux_ai_cmdtest;
-	s->do_cmd	= usbdux_ai_cmd;
-	s->cancel	= usbdux_ai_cancel;
-
-	/* Analog Output subdevice */
-	s = &dev->subdevices[SUBDEV_DA];
-	dev->write_subdev = s;
-	s->type		= COMEDI_SUBD_AO;
-	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= 4;
-	s->maxdata	= 0x0fff;
-	s->len_chanlist	= 4;
-	s->range_table	= &range_usbdux_ao_range;
-	s->do_cmdtest	= usbdux_ao_cmdtest;
-	s->do_cmd	= usbdux_ao_cmd;
-	s->cancel	= usbdux_ao_cancel;
-	s->insn_read	= usbdux_ao_insn_read;
-	s->insn_write	= usbdux_ao_insn_write;
-
-	/* Digital I/O subdevice */
-	s = &dev->subdevices[SUBDEV_DIO];
-	s->type		= COMEDI_SUBD_DIO;
-	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
-	s->n_chan	= 8;
-	s->maxdata	= 1;
-	s->range_table	= &range_digital;
-	s->insn_bits	= usbdux_dio_insn_bits;
-	s->insn_config	= usbdux_dio_insn_config;
-
-	/* Counter subdevice */
-	s = &dev->subdevices[SUBDEV_COUNTER];
-	s->type		= COMEDI_SUBD_COUNTER;
-	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
-	s->n_chan	= 4;
-	s->maxdata	= 0xffff;
-	s->insn_read	= usbdux_counter_read;
-	s->insn_write	= usbdux_counter_write;
-	s->insn_config	= usbdux_counter_config;
-
-	if (devpriv->high_speed) {
-		/* PWM subdevice */
-		s = &dev->subdevices[SUBDEV_PWM];
-		s->type		= COMEDI_SUBD_PWM;
-		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan	= 8;
-		s->maxdata	= devpriv->size_pwm_buf;
-		s->insn_write	= usbdux_pwm_write;
-		s->insn_read	= usbdux_pwm_read;
-		s->insn_config	= usbdux_pwm_config;
-
-		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
-	}
-
-	up(&devpriv->sem);
-
-	return 0;
-}
-
 static int usbdux_alloc_usb_buffers(struct usbdux_private *devpriv)
 {
 	struct urb *urb;
@@ -2189,6 +2107,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbdux_private *devpriv;
+	struct comedi_subdevice *s;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -2230,7 +2149,74 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	if (ret < 0)
 		return ret;
 
-	return usbdux_attach_common(dev);
+	ret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 5 : 4);
+	if (ret)
+		return ret;
+
+	/* Analog Input subdevice */
+	s = &dev->subdevices[SUBDEV_AD];
+	dev->read_subdev = s;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan	= 8;
+	s->maxdata	= 0x0fff;
+	s->len_chanlist	= 8;
+	s->range_table	= &range_usbdux_ai_range;
+	s->insn_read	= usbdux_ai_insn_read;
+	s->do_cmdtest	= usbdux_ai_cmdtest;
+	s->do_cmd	= usbdux_ai_cmd;
+	s->cancel	= usbdux_ai_cancel;
+
+	/* Analog Output subdevice */
+	s = &dev->subdevices[SUBDEV_DA];
+	dev->write_subdev = s;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	s->n_chan	= 4;
+	s->maxdata	= 0x0fff;
+	s->len_chanlist	= 4;
+	s->range_table	= &range_usbdux_ao_range;
+	s->do_cmdtest	= usbdux_ao_cmdtest;
+	s->do_cmd	= usbdux_ao_cmd;
+	s->cancel	= usbdux_ao_cancel;
+	s->insn_read	= usbdux_ao_insn_read;
+	s->insn_write	= usbdux_ao_insn_write;
+
+	/* Digital I/O subdevice */
+	s = &dev->subdevices[SUBDEV_DIO];
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 8;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= usbdux_dio_insn_bits;
+	s->insn_config	= usbdux_dio_insn_config;
+
+	/* Counter subdevice */
+	s = &dev->subdevices[SUBDEV_COUNTER];
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 0xffff;
+	s->insn_read	= usbdux_counter_read;
+	s->insn_write	= usbdux_counter_write;
+	s->insn_config	= usbdux_counter_config;
+
+	if (devpriv->high_speed) {
+		/* PWM subdevice */
+		s = &dev->subdevices[SUBDEV_PWM];
+		s->type		= COMEDI_SUBD_PWM;
+		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan	= 8;
+		s->maxdata	= devpriv->size_pwm_buf;
+		s->insn_write	= usbdux_pwm_write;
+		s->insn_read	= usbdux_pwm_read;
+		s->insn_config	= usbdux_pwm_config;
+
+		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+
+	return 0;
 }
 
 static void usbdux_detach(struct comedi_device *dev)

commit 72db740fd9ddc5cf4fc487d42bbfbbb7dfc2e564
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:09:51 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_attach_common()
    
    Rename the local variable used for the device private data.
    
    Move the setting of the device private data 'comedidev' to the
    (*auto_attach) where the other back pointers are set.
    
    Tidy up the subdevice init by removing the unnecessary comments
    and adding some whitespace.
    
    Remove the unnecessary dev_info() after a sucessful attach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index f41b8361bee3..460c06683435 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1952,123 +1952,82 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 
 static int usbdux_attach_common(struct comedi_device *dev)
 {
-	struct usbdux_private *udev = dev->private;
+	struct usbdux_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
 	int ret;
-	struct comedi_subdevice *s = NULL;
-	int n_subdevs;
-
-	down(&udev->sem);
-	/* pointer back to the corresponding comedi device */
-	udev->comedidev = dev;
 
-	/* set number of subdevices */
-	if (udev->high_speed) {
-		/* with pwm */
-		n_subdevs = 5;
-	} else {
-		/* without pwm */
-		n_subdevs = 4;
-	}
+	down(&devpriv->sem);
 
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	ret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 5 : 4);
 	if (ret) {
-		up(&udev->sem);
+		up(&devpriv->sem);
 		return ret;
 	}
 
-	/* the first subdevice is the A/D converter */
+	/* Analog Input subdevice */
 	s = &dev->subdevices[SUBDEV_AD];
-	/* the URBs get the comedi subdevice */
-	/* which is responsible for reading */
-	/* this is the subdevice which reads data */
 	dev->read_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	/* 8 channels */
-	s->n_chan = 8;
-	/* length of the channellist */
-	s->len_chanlist = 8;
-	/* callback functions */
-	s->insn_read = usbdux_ai_insn_read;
-	s->do_cmdtest = usbdux_ai_cmdtest;
-	s->do_cmd = usbdux_ai_cmd;
-	s->cancel = usbdux_ai_cancel;
-	/* max value from the A/D converter (12bit) */
-	s->maxdata = 0xfff;
-	/* range table to convert to physical units */
-	s->range_table = (&range_usbdux_ai_range);
-
-	/* analog out */
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	s->n_chan	= 8;
+	s->maxdata	= 0x0fff;
+	s->len_chanlist	= 8;
+	s->range_table	= &range_usbdux_ai_range;
+	s->insn_read	= usbdux_ai_insn_read;
+	s->do_cmdtest	= usbdux_ai_cmdtest;
+	s->do_cmd	= usbdux_ai_cmd;
+	s->cancel	= usbdux_ai_cancel;
+
+	/* Analog Output subdevice */
 	s = &dev->subdevices[SUBDEV_DA];
-	/* analog out */
-	s->type = COMEDI_SUBD_AO;
-	/* backward pointer */
 	dev->write_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* are writable */
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	/* 4 channels */
-	s->n_chan = 4;
-	/* length of the channellist */
-	s->len_chanlist = 4;
-	/* 12 bit resolution */
-	s->maxdata = 0x0fff;
-	/* bipolar range */
-	s->range_table = (&range_usbdux_ao_range);
-	/* callback */
-	s->do_cmdtest = usbdux_ao_cmdtest;
-	s->do_cmd = usbdux_ao_cmd;
-	s->cancel = usbdux_ao_cancel;
-	s->insn_read = usbdux_ao_insn_read;
-	s->insn_write = usbdux_ao_insn_write;
-
-	/* digital I/O */
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	s->n_chan	= 4;
+	s->maxdata	= 0x0fff;
+	s->len_chanlist	= 4;
+	s->range_table	= &range_usbdux_ao_range;
+	s->do_cmdtest	= usbdux_ao_cmdtest;
+	s->do_cmd	= usbdux_ao_cmd;
+	s->cancel	= usbdux_ao_cancel;
+	s->insn_read	= usbdux_ao_insn_read;
+	s->insn_write	= usbdux_ao_insn_write;
+
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[SUBDEV_DIO];
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 8;
-	s->maxdata = 1;
-	s->range_table = (&range_digital);
-	s->insn_bits = usbdux_dio_insn_bits;
-	s->insn_config = usbdux_dio_insn_config;
-	/* we don't use it */
-	s->private = NULL;
-
-	/* counter */
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 8;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= usbdux_dio_insn_bits;
+	s->insn_config	= usbdux_dio_insn_config;
+
+	/* Counter subdevice */
 	s = &dev->subdevices[SUBDEV_COUNTER];
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 0xFFFF;
-	s->insn_read = usbdux_counter_read;
-	s->insn_write = usbdux_counter_write;
-	s->insn_config = usbdux_counter_config;
-
-	if (udev->high_speed) {
-		/* timer / pwm */
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_WRITABLE | SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 0xffff;
+	s->insn_read	= usbdux_counter_read;
+	s->insn_write	= usbdux_counter_write;
+	s->insn_config	= usbdux_counter_config;
+
+	if (devpriv->high_speed) {
+		/* PWM subdevice */
 		s = &dev->subdevices[SUBDEV_PWM];
-		s->type = COMEDI_SUBD_PWM;
-		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan = 8;
-		/* this defines the max duty cycle resolution */
-		s->maxdata = udev->size_pwm_buf;
-		s->insn_write = usbdux_pwm_write;
-		s->insn_read = usbdux_pwm_read;
-		s->insn_config = usbdux_pwm_config;
+		s->type		= COMEDI_SUBD_PWM;
+		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan	= 8;
+		s->maxdata	= devpriv->size_pwm_buf;
+		s->insn_write	= usbdux_pwm_write;
+		s->insn_read	= usbdux_pwm_read;
+		s->insn_config	= usbdux_pwm_config;
+
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
 
-	up(&udev->sem);
-
-	dev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",
-		 dev->minor);
+	up(&devpriv->sem);
 
 	return 0;
 }
@@ -2238,6 +2197,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 	sema_init(&devpriv->sem, 1);
 
+	devpriv->comedidev = dev;
 	devpriv->usbdev = usb;
 	devpriv->interface = intf;
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;

commit ee9c2dd35c368c588018c3bad591717cf6bd373a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:09:24 2013 -0700

    staging: comedi: usbdux: remove NOISY_DUX_DEBUGBUG
    
    This define enables printing of the 'dux_commands' that is sent to
    the usb device in send_dux_commands(). This type of development
    debug should not be left in the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index f7efc85e294e..f41b8361bee3 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -78,9 +78,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  *
  */
 
-/* generates loads of debug info */
-/* #define NOISY_DUX_DEBUGBUG */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -936,13 +933,6 @@ static int send_dux_commands(struct usbdux_private *this_usbduxsub, int cmd_type
 	int result, nsent;
 
 	this_usbduxsub->dux_commands[0] = cmd_type;
-#ifdef NOISY_DUX_DEBUGBUG
-	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
-	       this_usbduxsub->comedidev->minor);
-	for (result = 0; result < SIZEOFDUXBUFFER; result++)
-		printk(" %02x", this_usbduxsub->dux_commands[result]);
-	printk("\n");
-#endif
 	result = usb_bulk_msg(this_usbduxsub->usbdev,
 			      usb_sndbulkpipe(this_usbduxsub->usbdev,
 					      COMMAND_OUT_EP),

commit 8ff14ee8a6e4d9aca3098c47e876bc43f9e4cbe5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:09:04 2013 -0700

    staging: comedi: usbdux: cleanup the (*detach)
    
    The tidy_up() function is only called by the (*detach). That function
    unlinks any running urbs and frees all the allocated urbs and buffers
    used by the driver.
    
    Rename tidy_up() to usbdux_free_usb_buffers() and move all the parts
    that don't deal with the freeing of the buffers directly into the
    (*detach).
    
    Also, remove all the unnecessary clearing of the pointers. The comedi
    core will kfree() the private data after calling the (*detach).
    
    Foe aesthetic reasons, do the kfree()'ing of the buffers and urbs in
    the reverse order that they were allocated.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6a7d7f4aabec..f7efc85e294e 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1960,76 +1960,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 /* end of PWM */
 /*****************************************************************/
 
-static void tidy_up(struct usbdux_private *usbduxsub_tmp)
-{
-	int i;
-
-	if (!usbduxsub_tmp)
-		return;
-	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi_: tiding up\n");
-
-	/* shows the usb subsystem that the driver is down */
-	if (usbduxsub_tmp->interface)
-		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
-
-	if (usbduxsub_tmp->urb_in) {
-		if (usbduxsub_tmp->ai_cmd_running) {
-			usbduxsub_tmp->ai_cmd_running = 0;
-			usbduxsub_unlink_inurbs(usbduxsub_tmp);
-		}
-		for (i = 0; i < usbduxsub_tmp->num_in_buffers; i++) {
-			kfree(usbduxsub_tmp->urb_in[i]->transfer_buffer);
-			usbduxsub_tmp->urb_in[i]->transfer_buffer = NULL;
-			usb_kill_urb(usbduxsub_tmp->urb_in[i]);
-			usb_free_urb(usbduxsub_tmp->urb_in[i]);
-			usbduxsub_tmp->urb_in[i] = NULL;
-		}
-		kfree(usbduxsub_tmp->urb_in);
-		usbduxsub_tmp->urb_in = NULL;
-	}
-	if (usbduxsub_tmp->urb_out) {
-		if (usbduxsub_tmp->ao_cmd_running) {
-			usbduxsub_tmp->ao_cmd_running = 0;
-			usbduxsub_unlink_outurbs(usbduxsub_tmp);
-		}
-		for (i = 0; i < usbduxsub_tmp->num_out_buffers; i++) {
-			kfree(usbduxsub_tmp->urb_out[i]->transfer_buffer);
-			usbduxsub_tmp->urb_out[i]->transfer_buffer = NULL;
-			if (usbduxsub_tmp->urb_out[i]) {
-				usb_kill_urb(usbduxsub_tmp->urb_out[i]);
-				usb_free_urb(usbduxsub_tmp->urb_out[i]);
-				usbduxsub_tmp->urb_out[i] = NULL;
-			}
-		}
-		kfree(usbduxsub_tmp->urb_out);
-		usbduxsub_tmp->urb_out = NULL;
-	}
-	if (usbduxsub_tmp->urb_pwm) {
-		if (usbduxsub_tmp->pwm_cmd_running) {
-			usbduxsub_tmp->pwm_cmd_running = 0;
-			usbduxsub_unlink_pwm_urbs(usbduxsub_tmp);
-		}
-		kfree(usbduxsub_tmp->urb_pwm->transfer_buffer);
-		usbduxsub_tmp->urb_pwm->transfer_buffer = NULL;
-		usb_kill_urb(usbduxsub_tmp->urb_pwm);
-		usb_free_urb(usbduxsub_tmp->urb_pwm);
-		usbduxsub_tmp->urb_pwm = NULL;
-	}
-	kfree(usbduxsub_tmp->in_buffer);
-	usbduxsub_tmp->in_buffer = NULL;
-	kfree(usbduxsub_tmp->insn_buffer);
-	usbduxsub_tmp->insn_buffer = NULL;
-	kfree(usbduxsub_tmp->out_buffer);
-	usbduxsub_tmp->out_buffer = NULL;
-	kfree(usbduxsub_tmp->dac_commands);
-	usbduxsub_tmp->dac_commands = NULL;
-	kfree(usbduxsub_tmp->dux_commands);
-	usbduxsub_tmp->dux_commands = NULL;
-	usbduxsub_tmp->ai_cmd_running = 0;
-	usbduxsub_tmp->ao_cmd_running = 0;
-	usbduxsub_tmp->pwm_cmd_running = 0;
-}
-
 static int usbdux_attach_common(struct comedi_device *dev)
 {
 	struct usbdux_private *udev = dev->private;
@@ -2264,6 +2194,46 @@ static int usbdux_alloc_usb_buffers(struct usbdux_private *devpriv)
 	return 0;
 }
 
+static void usbdux_free_usb_buffers(struct usbdux_private *devpriv)
+{
+	struct urb *urb;
+	int i;
+
+	urb = devpriv->urb_pwm;
+	if (urb) {
+		kfree(urb->transfer_buffer);
+		usb_kill_urb(urb);
+		usb_free_urb(urb);
+	}
+	if (devpriv->urb_out) {
+		for (i = 0; i < devpriv->num_out_buffers; i++) {
+			urb = devpriv->urb_out[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				usb_kill_urb(urb);
+				usb_free_urb(urb);
+			}
+		}
+		kfree(devpriv->urb_out);
+	}
+	if (devpriv->urb_in) {
+		for (i = 0; i < devpriv->num_in_buffers; i++) {
+			urb = devpriv->urb_in[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				usb_kill_urb(urb);
+				usb_free_urb(urb);
+			}
+		}
+		kfree(devpriv->urb_in);
+	}
+	kfree(devpriv->out_buffer);
+	kfree(devpriv->insn_buffer);
+	kfree(devpriv->in_buffer);
+	kfree(devpriv->dux_commands);
+	kfree(devpriv->dac_commands);
+}
+
 static int usbdux_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
@@ -2319,8 +2289,20 @@ static void usbdux_detach(struct comedi_device *dev)
 
 	if (devpriv) {
 		down(&devpriv->sem);
-		tidy_up(devpriv);
+
+		usb_set_intfdata(devpriv->interface, NULL);
+
+		if (devpriv->pwm_cmd_running)
+			usbduxsub_unlink_pwm_urbs(devpriv);
+		if (devpriv->ao_cmd_running)
+			usbduxsub_unlink_outurbs(devpriv);
+		if (devpriv->ai_cmd_running)
+			usbduxsub_unlink_inurbs(devpriv);
+
+		usbdux_free_usb_buffers(devpriv);
+
 		devpriv->comedidev = NULL;
+
 		up(&devpriv->sem);
 	}
 }

commit 29d0c07428d590ad93fd4721ff0e2f8f5ca8f264
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:08:43 2013 -0700

    staging: comedi: usbdux: remove unnecessary tidy_up() calls
    
    If the comedi_driver (*auto_attach) fails, the comedi core will call
    the (*detach) function to do any cleanup. It's not necessary to do
    the cleanup in the (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 8102efbced79..6a7d7f4aabec 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2294,17 +2294,14 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	}
 
 	ret = usbdux_alloc_usb_buffers(devpriv);
-	if (ret) {
-		tidy_up(devpriv);
+	if (ret)
 		return ret;
-	}
 
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
 	ret = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
 			"could not set alternate setting 3 in high speed\n");
-		tidy_up(devpriv);
 		return ret;
 	}
 

commit ef1ee8cf126a84f5049c6dbf5dc3a350fdc84262
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:08:24 2013 -0700

    staging: comedi: usbdux: push usb (*probe) into comedi (*auto_attach)
    
    The usb_driver (*probe) calls comedi_usb_auto_config() after finding a
    free slot for the static private data and doind some initial allocation
    and setup. The comedi_usb_auto_config() will then call the comedi_driver
    (*auto_attach).
    
    Move all the probe/auto_attach into the comedi_driver and just have the
    usb_driver call comedi_usb_auto_config(). This allows the comedi_driver
    to allocate the private data and removes the need for the static array
    and the semaphore that protects it.
    
    Since all the probe/auto_attach is now handled by the comedi_driver, we
    can also remove the 'attached' and 'probed' information from the private
    data. The subdevice functions will only be hooked up if the usb device
    has been probed and the comedi device is attached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 204dfbb6de19..8102efbced79 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -185,9 +185,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* must have more buffers due to buggy USB ctr */
 #define NUMOFOUTBUFFERSHIGH    10
 
-/* Total number of usbdux devices */
-#define NUMUSBDUX             16
-
 /* Analogue in subdevice */
 #define SUBDEV_AD             0
 
@@ -229,10 +226,6 @@ static const struct comedi_lrange range_usbdux_ao_range = { 2, {
 };
 
 struct usbdux_private {
-	/* attached? */
-	int attached;
-	/* is it associated with a subdevice? */
-	int probed;
 	/* pointer to the usb-device */
 	struct usb_device *usbdev;
 	/* actual number of in-buffers */
@@ -290,17 +283,6 @@ struct usbdux_private {
 	struct semaphore sem;
 };
 
-/*
- * The pointer to the private usb-data of the driver is also the private data
- * for the comedi-device.  This has to be global as the usb subsystem needs
- * global variables. The other reason is that this structure must be there
- * _before_ any comedi command is issued. The usb subsystem must be initialised
- * before comedi can access it.
- */
-static struct usbdux_private usbduxsub[NUMUSBDUX];
-
-static DEFINE_SEMAPHORE(start_stop_sem);
-
 /*
  * Stops the data acquision
  * It should be safe to call this function from any context
@@ -369,10 +351,6 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	/* unlink only if the urb really has been submitted */
 	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
 	up(&this_usbduxsub->sem);
@@ -569,10 +547,6 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 
 	/* prevent other CPUs from submitting a command just now */
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	/* unlink only if it is really running */
 	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
 	up(&this_usbduxsub->sem);
@@ -856,9 +830,6 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	int err = 0, i;
 	unsigned int tmp_timer;
 
-	if (!(this_usbduxsub->probed))
-		return -ENODEV;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1024,10 +995,6 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ai_inttrig\n", dev->minor);
 
@@ -1075,11 +1042,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
-
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 			"ai_cmd not possible. Another ai_cmd is running.\n",
@@ -1194,10 +1156,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 		dev->minor, insn->n, insn->subdev);
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: ai_insn_read not possible. "
@@ -1250,10 +1208,6 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	for (i = 0; i < insn->n; i++)
 		data[i] = this_usbduxsub->out_buffer[chan];
 
@@ -1276,10 +1230,6 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		"comedi%d: ao_insn_write\n", dev->minor);
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ao_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: ao_insn_write: "
@@ -1322,10 +1272,6 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
@@ -1364,9 +1310,6 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	if (!(this_usbduxsub->probed))
-		return -ENODEV;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1452,10 +1395,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: %s\n", dev->minor, __func__);
 
@@ -1593,11 +1532,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 
 	down(&this_usbduxsub->sem);
 
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
-
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 	s->state &= ~data[0];
@@ -1636,12 +1570,6 @@ static int usbdux_counter_read(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
-
 	err = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
@@ -1670,12 +1598,6 @@ static int usbdux_counter_write(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
-
 	this_usbduxsub->dux_commands[1] = insn->chanspec;
 	*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);
 
@@ -2050,8 +1972,6 @@ static void tidy_up(struct usbdux_private *usbduxsub_tmp)
 	if (usbduxsub_tmp->interface)
 		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
 
-	usbduxsub_tmp->probed = 0;
-
 	if (usbduxsub_tmp->urb_in) {
 		if (usbduxsub_tmp->ai_cmd_running) {
 			usbduxsub_tmp->ai_cmd_running = 0;
@@ -2110,9 +2030,9 @@ static void tidy_up(struct usbdux_private *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
-static int usbdux_attach_common(struct comedi_device *dev,
-				struct usbdux_private *udev)
+static int usbdux_attach_common(struct comedi_device *dev)
 {
+	struct usbdux_private *udev = dev->private;
 	int ret;
 	struct comedi_subdevice *s = NULL;
 	int n_subdevs;
@@ -2136,9 +2056,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 		return ret;
 	}
 
-	/* private structure is also simply the usb-structure */
-	dev->private = udev;
-
 	/* the first subdevice is the A/D converter */
 	s = &dev->subdevices[SUBDEV_AD];
 	/* the URBs get the comedi subdevice */
@@ -2227,8 +2144,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 		s->insn_config = usbdux_pwm_config;
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
-	/* finally decide that it's attached */
-	udev->attached = 1;
 
 	up(&udev->sem);
 
@@ -2352,88 +2267,21 @@ static int usbdux_alloc_usb_buffers(struct usbdux_private *devpriv)
 static int usbdux_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
-	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
-	struct usbdux_private *this_usbduxsub = usb_get_intfdata(uinterf);
-	struct usb_device *usb = usbduxsub->usbdev;
-	int ret;
-
-	dev->private = this_usbduxsub;	/* This is temporary... */
-	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
-				   usbdux_firmware_upload, 0);
-	if (ret < 0) {
-		dev->private = NULL;
-		return ret;
-	}
-
-	dev->private = NULL;
-
-	down(&start_stop_sem);
-	if (!this_usbduxsub || !this_usbduxsub->probed) {
-		dev_err(dev->class_dev,
-			"usbdux: error: auto_attach failed, not connected\n");
-		ret = -ENODEV;
-	} else if (this_usbduxsub->attached) {
-		dev_err(dev->class_dev,
-			"error: auto_attach failed, already attached\n");
-		ret = -ENODEV;
-	} else
-		ret = usbdux_attach_common(dev, this_usbduxsub);
-	up(&start_stop_sem);
-	return ret;
-}
-
-static void usbdux_detach(struct comedi_device *dev)
-{
-	struct usbdux_private *devpriv = dev->private;
-
-	down(&start_stop_sem);
-	if (devpriv) {
-		down(&devpriv->sem);
-		tidy_up(devpriv);
-		dev->private = NULL;
-		devpriv->attached = 0;
-		devpriv->comedidev = NULL;
-		up(&devpriv->sem);
-	}
-	up(&start_stop_sem);
-}
-
-static struct comedi_driver usbdux_driver = {
-	.driver_name	= "usbdux",
-	.module		= THIS_MODULE,
-	.auto_attach	= usbdux_auto_attach,
-	.detach		= usbdux_detach,
-};
-
-static int usbdux_usb_probe(struct usb_interface *uinterf,
-			    const struct usb_device_id *id)
-{
-	struct usb_device *udev = interface_to_usbdev(uinterf);
-	struct device *dev = &uinterf->dev;
-	struct usbdux_private *devpriv = NULL;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbdux_private *devpriv;
 	int ret;
-	int i;
 
-	down(&start_stop_sem);
-
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if (!usbduxsub[i].probed) {
-			devpriv = &usbduxsub[i];
-			break;
-		}
-	}
-	if (!devpriv) {
-		dev_err(dev, "Too many usbdux-devices connected.\n");
-		up(&start_stop_sem);
-		return -EMFILE;
-	}
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
 
 	sema_init(&devpriv->sem, 1);
 
-	devpriv->usbdev = udev;
-	devpriv->interface = uinterf;
-	devpriv->ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	usb_set_intfdata(uinterf, devpriv);
+	devpriv->usbdev = usb;
+	devpriv->interface = intf;
+	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
+	usb_set_intfdata(intf, devpriv);
 
 	devpriv->high_speed = (devpriv->usbdev->speed == USB_SPEED_HIGH);
 	if (devpriv->high_speed) {
@@ -2443,35 +2291,54 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	} else {
 		devpriv->num_in_buffers = NUMOFINBUFFERSFULL;
 		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
-		devpriv->size_pwm_buf = 0;
 	}
 
 	ret = usbdux_alloc_usb_buffers(devpriv);
 	if (ret) {
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return ret;
 	}
 
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
 	ret = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
 	if (ret < 0) {
-		dev_err(dev,
+		dev_err(dev->class_dev,
 			"could not set alternate setting 3 in high speed\n");
 		tidy_up(devpriv);
-		up(&start_stop_sem);
 		return ret;
 	}
 
-	devpriv->ai_cmd_running = 0;
-	devpriv->ao_cmd_running = 0;
-	devpriv->pwm_cmd_running = 0;
+	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+				   usbdux_firmware_upload, 0);
+	if (ret < 0)
+		return ret;
 
-	/* we've reached the bottom of the function */
-	devpriv->probed = 1;
-	up(&start_stop_sem);
+	return usbdux_attach_common(dev);
+}
+
+static void usbdux_detach(struct comedi_device *dev)
+{
+	struct usbdux_private *devpriv = dev->private;
 
-	return comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
+	if (devpriv) {
+		down(&devpriv->sem);
+		tidy_up(devpriv);
+		devpriv->comedidev = NULL;
+		up(&devpriv->sem);
+	}
+}
+
+static struct comedi_driver usbdux_driver = {
+	.driver_name	= "usbdux",
+	.module		= THIS_MODULE,
+	.auto_attach	= usbdux_auto_attach,
+	.detach		= usbdux_detach,
+};
+
+static int usbdux_usb_probe(struct usb_interface *intf,
+			    const struct usb_device_id *id)
+{
+	return comedi_usb_auto_config(intf, &usbdux_driver, 0);
 }
 
 static const struct usb_device_id usbdux_usb_table[] = {
@@ -2479,7 +2346,6 @@ static const struct usb_device_id usbdux_usb_table[] = {
 	{ USB_DEVICE(0x13d8, 0x0002) },
 	{ }
 };
-
 MODULE_DEVICE_TABLE(usb, usbdux_usb_table);
 
 static struct usb_driver usbdux_usb_driver = {

commit a7dd65f57cc4bf07c3bcfb798577e275186a9c6f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:08:02 2013 -0700

    staging: comedi: usbdux: push usb (*disconnect) into comedi (*detach)
    
    The usb_driver (*disconnect) calls comedi_usb_auto_unconfig() which will
    call the comedi_driver (*detach). Just move all the disconnect/detach
    into the comedi_driver and use comedi_usb_auto_unconfig() directly for
    the (*disconnect).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 892ecb53dbf5..204dfbb6de19 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2384,15 +2384,18 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 static void usbdux_detach(struct comedi_device *dev)
 {
-	struct usbdux_private *usb = dev->private;
+	struct usbdux_private *devpriv = dev->private;
 
-	if (usb) {
-		down(&usb->sem);
+	down(&start_stop_sem);
+	if (devpriv) {
+		down(&devpriv->sem);
+		tidy_up(devpriv);
 		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
-		up(&usb->sem);
+		devpriv->attached = 0;
+		devpriv->comedidev = NULL;
+		up(&devpriv->sem);
 	}
+	up(&start_stop_sem);
 }
 
 static struct comedi_driver usbdux_driver = {
@@ -2471,29 +2474,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	return comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
 }
 
-static void usbdux_usb_disconnect(struct usb_interface *intf)
-{
-	struct usbdux_private *usbduxsub_tmp = usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-	if (!usbduxsub_tmp) {
-		dev_err(&intf->dev,
-			"comedi_: disconnect called with null pointer.\n");
-		return;
-	}
-	if (usbduxsub_tmp->usbdev != udev) {
-		dev_err(&intf->dev, "comedi_: BUG! called with wrong ptr!!!\n");
-		return;
-	}
-	comedi_usb_auto_unconfig(intf);
-	down(&start_stop_sem);
-	down(&usbduxsub_tmp->sem);
-	tidy_up(usbduxsub_tmp);
-	up(&usbduxsub_tmp->sem);
-	up(&start_stop_sem);
-	dev_dbg(&intf->dev, "comedi_: disconnected from the usb\n");
-}
-
 static const struct usb_device_id usbdux_usb_table[] = {
 	{ USB_DEVICE(0x13d8, 0x0001) },
 	{ USB_DEVICE(0x13d8, 0x0002) },
@@ -2505,7 +2485,7 @@ MODULE_DEVICE_TABLE(usb, usbdux_usb_table);
 static struct usb_driver usbdux_usb_driver = {
 	.name		= "usbdux",
 	.probe		= usbdux_usb_probe,
-	.disconnect	= usbdux_usb_disconnect,
+	.disconnect	= comedi_usb_auto_unconfig,
 	.id_table	= usbdux_usb_table,
 };
 module_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);

commit 080bcc188782d733500f8315d55bd1f403106e68
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:07:39 2013 -0700

    staging: comedi: usbdux: move usb buffer allocation into new function
    
    Move all the usb buffer allocation code in the usb_driver (*probe)
    into a new function, usbdux_alloc_usb_buffers(). This allows tidying
    up the error path in the (*probe).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d1651e2cdefe..892ecb53dbf5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2238,6 +2238,117 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
+static int usbdux_alloc_usb_buffers(struct usbdux_private *devpriv)
+{
+	struct urb *urb;
+	int i;
+
+	/* create space for the commands of the DA converter */
+	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	if (!devpriv->dac_commands)
+		return -ENOMEM;
+
+	/* create space for the commands going to the usb device */
+	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!devpriv->dux_commands)
+		return -ENOMEM;
+
+	/* create space for the in buffer and set it to zero */
+	devpriv->in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->in_buffer)
+		return -ENOMEM;
+
+	/* create space of the instruction buffer */
+	devpriv->insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insn_buffer)
+		return -ENOMEM;
+
+	/* create space for the outbuffer */
+	devpriv->out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!devpriv->out_buffer)
+		return -ENOMEM;
+
+	/* in urbs */
+	devpriv->urb_in = kcalloc(devpriv->num_in_buffers, sizeof(*urb),
+				  GFP_KERNEL);
+	if (!devpriv->urb_in)
+		return -ENOMEM;
+
+	for (i = 0; i < devpriv->num_in_buffers; i++) {
+		/* one frame: 1ms */
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urb_in[i] = urb;
+
+		urb->dev = devpriv->usbdev;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		urb->context = NULL;
+		urb->pipe = usb_rcvisocpipe(devpriv->usbdev, ISOINEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+
+		urb->complete = usbduxsub_ai_isoc_irq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEINBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEINBUF;
+	}
+
+	/* out urbs */
+	devpriv->urb_out = kcalloc(devpriv->num_out_buffers, sizeof(*urb),
+				   GFP_KERNEL);
+	if (!devpriv->urb_out)
+		return -ENOMEM;
+
+	for (i = 0; i < devpriv->num_out_buffers; i++) {
+		/* one frame: 1ms */
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urb_out[i] = urb;
+
+		urb->dev = devpriv->usbdev;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		urb->context = NULL;
+		urb->pipe = usb_sndisocpipe(devpriv->usbdev, ISOOUTEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+
+		urb->complete = usbduxsub_ao_isoc_irq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
+	}
+
+	/* pwm */
+	if (devpriv->size_pwm_buf) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urb_pwm = urb;
+
+		/* max bulk ep size in high speed */
+		urb->transfer_buffer = kzalloc(devpriv->size_pwm_buf,
+					       GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static int usbdux_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
@@ -2297,7 +2408,7 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
 	struct usbdux_private *devpriv = NULL;
-	struct urb *urb;
+	int ret;
 	int i;
 
 	down(&start_stop_sem);
@@ -2322,160 +2433,31 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	usb_set_intfdata(uinterf, devpriv);
 
 	devpriv->high_speed = (devpriv->usbdev->speed == USB_SPEED_HIGH);
-
-	/* create space for the commands of the DA converter */
-	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
-	if (!devpriv->dac_commands) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the commands going to the usb device */
-	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!devpriv->dux_commands) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the in buffer and set it to zero */
-	devpriv->in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->in_buffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space of the instruction buffer */
-	devpriv->insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insn_buffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the outbuffer */
-	devpriv->out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!devpriv->out_buffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	i = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
-	if (i < 0) {
-		dev_err(dev,
-			"could not set alternate setting 3 in high speed\n");
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENODEV;
-	}
-	if (devpriv->high_speed)
+	if (devpriv->high_speed) {
 		devpriv->num_in_buffers = NUMOFINBUFFERSHIGH;
-	else
+		devpriv->num_out_buffers = NUMOFOUTBUFFERSHIGH;
+		devpriv->size_pwm_buf = 512;
+	} else {
 		devpriv->num_in_buffers = NUMOFINBUFFERSFULL;
+		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
+		devpriv->size_pwm_buf = 0;
+	}
 
-	devpriv->urb_in = kcalloc(devpriv->num_in_buffers, sizeof(*urb),
-				  GFP_KERNEL);
-	if (!devpriv->urb_in) {
+	ret = usbdux_alloc_usb_buffers(devpriv);
+	if (ret) {
 		tidy_up(devpriv);
 		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	for (i = 0; i < devpriv->num_in_buffers; i++) {
-		/* one frame: 1ms */
-		urb = usb_alloc_urb(1, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urb_in[i] = urb;
-
-		urb->dev = devpriv->usbdev;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(devpriv->usbdev, ISOINEP);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		urb->complete = usbduxsub_ai_isoc_irq;
-		urb->number_of_packets = 1;
-		urb->transfer_buffer_length = SIZEINBUF;
-		urb->iso_frame_desc[0].offset = 0;
-		urb->iso_frame_desc[0].length = SIZEINBUF;
+		return ret;
 	}
 
-	/* out */
-	if (devpriv->high_speed)
-		devpriv->num_out_buffers = NUMOFOUTBUFFERSHIGH;
-	else
-		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
-
-	devpriv->urb_out = kcalloc(devpriv->num_out_buffers, sizeof(*urb),
-				   GFP_KERNEL);
-	if (!devpriv->urb_out) {
+	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
+	ret = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
+	if (ret < 0) {
+		dev_err(dev,
+			"could not set alternate setting 3 in high speed\n");
 		tidy_up(devpriv);
 		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	for (i = 0; i < devpriv->num_out_buffers; i++) {
-		/* one frame: 1ms */
-		urb = usb_alloc_urb(1, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urb_out[i] = urb;
-
-		urb->dev = devpriv->usbdev;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(devpriv->usbdev, ISOOUTEP);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-		if (!(urb->transfer_buffer)) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		urb->complete = usbduxsub_ao_isoc_irq;
-		urb->number_of_packets = 1;
-		urb->transfer_buffer_length = SIZEOUTBUF;
-		urb->iso_frame_desc[0].offset = 0;
-		urb->iso_frame_desc[0].length = SIZEOUTBUF;
-		if (devpriv->high_speed)
-			urb->interval = 8;	/* uframes */
-		else
-			urb->interval = 1;	/* frames */
-	}
-
-	/* pwm */
-	if (devpriv->high_speed) {
-		urb = usb_alloc_urb(0, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urb_pwm = urb;
-
-		/* max bulk ep size in high speed */
-		devpriv->size_pwm_buf = 512;
-		urb->transfer_buffer = kzalloc(devpriv->size_pwm_buf,
-					       GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-	} else {
-		devpriv->urb_pwm = NULL;
-		devpriv->size_pwm_buf = 0;
+		return ret;
 	}
 
 	devpriv->ai_cmd_running = 0;

commit da9035908edc3e936a2912cf836fed3e9d965cf1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:07:18 2013 -0700

    staging: comedi: usbdux: tidy up usbdux_usb_probe()
    
    Use a pointer to the struct usbdux_private data being configured
    in the probe. Also use a pointer to the struct urb being setup in
    the buffer allocations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 63e302847def..d1651e2cdefe 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2296,209 +2296,194 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
+	struct usbdux_private *devpriv = NULL;
+	struct urb *urb;
 	int i;
-	int index;
 
 	down(&start_stop_sem);
-	/* look for a free place in the usbdux array */
-	index = -1;
+
 	for (i = 0; i < NUMUSBDUX; i++) {
-		if (!(usbduxsub[i].probed)) {
-			index = i;
+		if (!usbduxsub[i].probed) {
+			devpriv = &usbduxsub[i];
 			break;
 		}
 	}
-
-	/* no more space */
-	if (index == -1) {
+	if (!devpriv) {
 		dev_err(dev, "Too many usbdux-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
 
-	sema_init(&(usbduxsub[index].sem), 1);
-	/* save a pointer to the usb device */
-	usbduxsub[index].usbdev = udev;
+	sema_init(&devpriv->sem, 1);
 
-	/* 2.6: save the interface itself */
-	usbduxsub[index].interface = uinterf;
-	/* get the interface number from the interface */
-	usbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	/* hand the private data over to the usb subsystem */
-	/* will be needed for disconnect */
-	usb_set_intfdata(uinterf, &(usbduxsub[index]));
+	devpriv->usbdev = udev;
+	devpriv->interface = uinterf;
+	devpriv->ifnum = uinterf->altsetting->desc.bInterfaceNumber;
+	usb_set_intfdata(uinterf, devpriv);
 
-	/* test if it is high speed (USB 2.0) */
-	usbduxsub[index].high_speed =
-	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+	devpriv->high_speed = (devpriv->usbdev->speed == USB_SPEED_HIGH);
 
 	/* create space for the commands of the DA converter */
-	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
-	if (!usbduxsub[index].dac_commands) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	if (!devpriv->dac_commands) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the commands going to the usb device */
-	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!usbduxsub[index].dux_commands) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!devpriv->dux_commands) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the in buffer and set it to zero */
-	usbduxsub[index].in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].in_buffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->in_buffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space of the instruction buffer */
-	usbduxsub[index].insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].insn_buffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insn_buffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the outbuffer */
-	usbduxsub[index].out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].out_buffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!devpriv->out_buffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	i = usb_set_interface(usbduxsub[index].usbdev,
-			      usbduxsub[index].ifnum, 3);
+	i = usb_set_interface(devpriv->usbdev, devpriv->ifnum, 3);
 	if (i < 0) {
-		dev_err(dev, "comedi_: usbdux%d: "
-			"could not set alternate setting 3 in high speed.\n",
-			index);
-		tidy_up(&(usbduxsub[index]));
+		dev_err(dev,
+			"could not set alternate setting 3 in high speed\n");
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
-	if (usbduxsub[index].high_speed)
-		usbduxsub[index].num_in_buffers = NUMOFINBUFFERSHIGH;
+	if (devpriv->high_speed)
+		devpriv->num_in_buffers = NUMOFINBUFFERSHIGH;
 	else
-		usbduxsub[index].num_in_buffers = NUMOFINBUFFERSFULL;
+		devpriv->num_in_buffers = NUMOFINBUFFERSFULL;
 
-	usbduxsub[index].urb_in =
-		kcalloc(usbduxsub[index].num_in_buffers, sizeof(struct urb *),
-			GFP_KERNEL);
-	if (!(usbduxsub[index].urb_in)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->urb_in = kcalloc(devpriv->num_in_buffers, sizeof(*urb),
+				  GFP_KERNEL);
+	if (!devpriv->urb_in) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].num_in_buffers; i++) {
+	for (i = 0; i < devpriv->num_in_buffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urb_in[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urb_in[i] == NULL) {
-			tidy_up(&(usbduxsub[index]));
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urb_in[i]->dev = usbduxsub[index].usbdev;
+		devpriv->urb_in[i] = urb;
+
+		urb->dev = devpriv->usbdev;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urb_in[i]->context = NULL;
-		usbduxsub[index].urb_in[i]->pipe =
-		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
-		usbduxsub[index].urb_in[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urb_in[i]->transfer_buffer =
-		    kzalloc(SIZEINBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urb_in[i]->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		urb->context = NULL;
+		urb->pipe = usb_rcvisocpipe(devpriv->usbdev, ISOINEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urb_in[i]->complete = usbduxsub_ai_isoc_irq;
-		usbduxsub[index].urb_in[i]->number_of_packets = 1;
-		usbduxsub[index].urb_in[i]->transfer_buffer_length = SIZEINBUF;
-		usbduxsub[index].urb_in[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urb_in[i]->iso_frame_desc[0].length = SIZEINBUF;
+		urb->complete = usbduxsub_ai_isoc_irq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEINBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
 	/* out */
-	if (usbduxsub[index].high_speed)
-		usbduxsub[index].num_out_buffers = NUMOFOUTBUFFERSHIGH;
+	if (devpriv->high_speed)
+		devpriv->num_out_buffers = NUMOFOUTBUFFERSHIGH;
 	else
-		usbduxsub[index].num_out_buffers = NUMOFOUTBUFFERSFULL;
+		devpriv->num_out_buffers = NUMOFOUTBUFFERSFULL;
 
-	usbduxsub[index].urb_out =
-		kcalloc(usbduxsub[index].num_out_buffers, sizeof(struct urb *),
-			GFP_KERNEL);
-	if (!(usbduxsub[index].urb_out)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->urb_out = kcalloc(devpriv->num_out_buffers, sizeof(*urb),
+				   GFP_KERNEL);
+	if (!devpriv->urb_out) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].num_out_buffers; i++) {
+	for (i = 0; i < devpriv->num_out_buffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urb_out[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urb_out[i] == NULL) {
-			tidy_up(&(usbduxsub[index]));
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urb_out[i]->dev = usbduxsub[index].usbdev;
+		devpriv->urb_out[i] = urb;
+
+		urb->dev = devpriv->usbdev;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urb_out[i]->context = NULL;
-		usbduxsub[index].urb_out[i]->pipe =
-		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
-		usbduxsub[index].urb_out[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urb_out[i]->transfer_buffer =
-		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urb_out[i]->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		urb->context = NULL;
+		urb->pipe = usb_sndisocpipe(devpriv->usbdev, ISOOUTEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!(urb->transfer_buffer)) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urb_out[i]->complete = usbduxsub_ao_isoc_irq;
-		usbduxsub[index].urb_out[i]->number_of_packets = 1;
-		usbduxsub[index].urb_out[i]->transfer_buffer_length = SIZEOUTBUF;
-		usbduxsub[index].urb_out[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urb_out[i]->iso_frame_desc[0].length =
-		    SIZEOUTBUF;
-		if (usbduxsub[index].high_speed) {
-			/* uframes */
-			usbduxsub[index].urb_out[i]->interval = 8;
-		} else {
-			/* frames */
-			usbduxsub[index].urb_out[i]->interval = 1;
-		}
+		urb->complete = usbduxsub_ao_isoc_irq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
 	}
 
 	/* pwm */
-	if (usbduxsub[index].high_speed) {
-		/* max bulk ep size in high speed */
-		usbduxsub[index].size_pwm_buf = 512;
-		usbduxsub[index].urb_pwm = usb_alloc_urb(0, GFP_KERNEL);
-		if (usbduxsub[index].urb_pwm == NULL) {
-			tidy_up(&(usbduxsub[index]));
+	if (devpriv->high_speed) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urb_pwm->transfer_buffer =
-		    kzalloc(usbduxsub[index].size_pwm_buf, GFP_KERNEL);
-		if (!(usbduxsub[index].urb_pwm->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		devpriv->urb_pwm = urb;
+
+		/* max bulk ep size in high speed */
+		devpriv->size_pwm_buf = 512;
+		urb->transfer_buffer = kzalloc(devpriv->size_pwm_buf,
+					       GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
 	} else {
-		usbduxsub[index].urb_pwm = NULL;
-		usbduxsub[index].size_pwm_buf = 0;
+		devpriv->urb_pwm = NULL;
+		devpriv->size_pwm_buf = 0;
 	}
 
-	usbduxsub[index].ai_cmd_running = 0;
-	usbduxsub[index].ao_cmd_running = 0;
-	usbduxsub[index].pwm_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
+	devpriv->ao_cmd_running = 0;
+	devpriv->pwm_cmd_running = 0;
 
 	/* we've reached the bottom of the function */
-	usbduxsub[index].probed = 1;
+	devpriv->probed = 1;
 	up(&start_stop_sem);
 
 	return comedi_usb_auto_config(uinterf, &usbdux_driver, 0);

commit b0daed19f21f4199fb7e4ded5fc0cddd230c655f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:06:58 2013 -0700

    staging: comedi: usbdux: remove the usb_driver (*probe) noise
    
    The dev_dbg() during the usb_driver (*probe) is just added noise.
    
    The dev_err() when a usb_alloc_urb() fails is not necessary. The
    allocation failure will have already output a message.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a64967684b68..63e302847def 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2299,9 +2299,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	int i;
 	int index;
 
-	dev_dbg(dev, "comedi_: usbdux_: "
-		"finding a free structure for the usb-device\n");
-
 	down(&start_stop_sem);
 	/* look for a free place in the usbdux array */
 	index = -1;
@@ -2318,8 +2315,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
-	dev_dbg(dev, "comedi_: usbdux: "
-		"usbduxsub[%d] is ready to connect to comedi.\n", index);
 
 	sema_init(&(usbduxsub[index].sem), 1);
 	/* save a pointer to the usb device */
@@ -2333,8 +2328,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* will be needed for disconnect */
 	usb_set_intfdata(uinterf, &(usbduxsub[index]));
 
-	dev_dbg(dev, "comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
-
 	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
 	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
@@ -2402,8 +2395,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		/* one frame: 1ms */
 		usbduxsub[index].urb_in[i] = usb_alloc_urb(1, GFP_KERNEL);
 		if (usbduxsub[index].urb_in[i] == NULL) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2447,8 +2438,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		/* one frame: 1ms */
 		usbduxsub[index].urb_out[i] = usb_alloc_urb(1, GFP_KERNEL);
 		if (usbduxsub[index].urb_out[i] == NULL) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2488,8 +2477,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].size_pwm_buf = 512;
 		usbduxsub[index].urb_pwm = usb_alloc_urb(0, GFP_KERNEL);
 		if (usbduxsub[index].urb_pwm == NULL) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"Could not alloc. pwm urb\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;

commit 40f1a5ab5e82ab7f15bee23db3db6c3ae957dde4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 24 14:06:38 2013 -0700

    staging: comedi: usbdux: rename struct usbduxsub
    
    This struct is the comedi_device private data. For aesthetic reasons,
    rename it to usbdux_private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 279e5bd493fa..a64967684b68 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -228,15 +228,7 @@ static const struct comedi_lrange range_usbdux_ao_range = { 2, {
 								}
 };
 
-/*
- * private structure of one subdevice
- */
-
-/*
- * This is the structure which holds all the data of
- * this driver one sub device just now: A/D
- */
-struct usbduxsub {
+struct usbdux_private {
 	/* attached? */
 	int attached;
 	/* is it associated with a subdevice? */
@@ -305,7 +297,7 @@ struct usbduxsub {
  * _before_ any comedi command is issued. The usb subsystem must be initialised
  * before comedi can access it.
  */
-static struct usbduxsub usbduxsub[NUMUSBDUX];
+static struct usbdux_private usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
@@ -313,7 +305,7 @@ static DEFINE_SEMAPHORE(start_stop_sem);
  * Stops the data acquision
  * It should be safe to call this function from any context
  */
-static int usbduxsub_unlink_inurbs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_inurbs(struct usbdux_private *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
@@ -338,7 +330,7 @@ static int usbduxsub_unlink_inurbs(struct usbduxsub *usbduxsub_tmp)
  * Is called from within this driver from both the
  * interrupt context and from comedi
  */
-static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_ai_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -365,7 +357,7 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub;
+	struct usbdux_private *this_usbduxsub;
 	int res = 0;
 
 	/* force unlink of all urbs */
@@ -391,13 +383,13 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 static void usbduxsub_ai_isoc_irq(struct urb *urb)
 {
 	int i, err, n;
-	struct usbduxsub *this_usbduxsub;
+	struct usbdux_private *this_usbduxsub;
 	struct comedi_device *this_comedidev;
 	struct comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
+	/* the private structure of the subdevice is struct usbdux_private */
 	this_usbduxsub = this_comedidev->private;
 	/* subdevice which is the AD converter */
 	s = &this_comedidev->subdevices[SUBDEV_AD];
@@ -528,7 +520,7 @@ static void usbduxsub_ai_isoc_irq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static int usbduxsub_unlink_outurbs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_outurbs(struct usbdux_private *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
@@ -549,7 +541,7 @@ static int usbduxsub_unlink_outurbs(struct usbduxsub *usbduxsub_tmp)
 /* This will cancel a running acquisition operation
  * in any context.
  */
-static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_ao_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -569,7 +561,7 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int res = 0;
 
 	if (!this_usbduxsub)
@@ -591,13 +583,13 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 {
 	int i, ret;
 	int8_t *datap;
-	struct usbduxsub *this_usbduxsub;
+	struct usbdux_private *this_usbduxsub;
 	struct comedi_device *this_comedidev;
 	struct comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
+	/* the private structure of the subdevice is struct usbdux_private */
 	this_usbduxsub = this_comedidev->private;
 
 	s = &this_comedidev->subdevices[SUBDEV_DA];
@@ -727,7 +719,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 				  const u8 *data, size_t size,
 				  unsigned long context)
 {
-	struct usbduxsub *usbduxsub = dev->private;
+	struct usbdux_private *usbduxsub = dev->private;
 	struct usb_device *usb = usbduxsub->usbdev;
 	uint8_t *buf;
 	uint8_t *tmp;
@@ -799,7 +791,7 @@ static int usbdux_firmware_upload(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbduxsub_submit_inurbs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_inurbs(struct usbdux_private *usbduxsub)
 {
 	int i, err_flag;
 
@@ -831,7 +823,7 @@ static int usbduxsub_submit_inurbs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_submit_outurbs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_outurbs(struct usbdux_private *usbduxsub)
 {
 	int i, err_flag;
 
@@ -860,7 +852,7 @@ static int usbduxsub_submit_outurbs(struct usbduxsub *usbduxsub)
 static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int err = 0, i;
 	unsigned int tmp_timer;
 
@@ -968,7 +960,7 @@ static int8_t create_adc_command(unsigned int chan, int range)
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
+static int send_dux_commands(struct usbdux_private *this_usbduxsub, int cmd_type)
 {
 	int result, nsent;
 
@@ -993,7 +985,7 @@ static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 	return result;
 }
 
-static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
+static int receive_dux_commands(struct usbdux_private *this_usbduxsub, int command)
 {
 	int result = (-EFAULT);
 	int nrec;
@@ -1027,7 +1019,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	if (!this_usbduxsub)
 		return -EFAULT;
 
@@ -1072,7 +1064,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
 	int i, ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int result;
 
 	if (!this_usbduxsub)
@@ -1192,7 +1184,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	unsigned int one = 0;
 	int chan, range;
 	int err;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return 0;
@@ -1252,7 +1244,7 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1275,7 +1267,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 {
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1324,7 +1316,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1365,7 +1357,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int err = 0;
 	unsigned int flags;
 
@@ -1454,7 +1446,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
 	int i, ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1593,7 +1585,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int err;
 
 	if (!this_usbduxsub)
@@ -1636,7 +1628,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int chan = insn->chanspec;
 	int err;
 
@@ -1671,7 +1663,7 @@ static int usbdux_counter_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int err;
 
 	if (!this_usbduxsub)
@@ -1709,7 +1701,7 @@ static int usbdux_counter_config(struct comedi_device *dev,
 /***********************************/
 /* PWM */
 
-static int usbduxsub_unlink_pwm_urbs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_pwm_urbs(struct usbdux_private *usbduxsub_tmp)
 {
 	int err = 0;
 
@@ -1725,7 +1717,7 @@ static int usbduxsub_unlink_pwm_urbs(struct usbduxsub *usbduxsub_tmp)
 /* This cancels a running acquisition operation
  * in any context.
  */
-static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_pwm_stop(struct usbdux_private *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -1745,7 +1737,7 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 static int usbdux_pwm_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int res = 0;
 
 	/* unlink only if it is really running */
@@ -1761,7 +1753,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
 	int ret;
-	struct usbduxsub *this_usbduxsub;
+	struct usbdux_private *this_usbduxsub;
 	struct comedi_device *this_comedidev;
 	struct comedi_subdevice *s;
 
@@ -1769,7 +1761,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
+	/* the private structure of the subdevice is struct usbdux_private */
 	this_usbduxsub = this_comedidev->private;
 
 	s = &this_comedidev->subdevices[SUBDEV_DA];
@@ -1827,7 +1819,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_pwm_urbs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_pwm_urbs(struct usbdux_private *usbduxsub)
 {
 	int err_flag;
 
@@ -1857,7 +1849,7 @@ static int usbduxsub_submit_pwm_urbs(struct usbduxsub *usbduxsub)
 static int usbdux_pwm_period(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int period)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
@@ -1886,7 +1878,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	int ret, i;
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
 		dev->minor, __func__);
@@ -1919,7 +1911,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int channel,
 			      unsigned int value, unsigned int sign)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	int i, szbuf;
 	char *p_buf;
 	char pwm_mask;
@@ -1961,7 +1953,7 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1995,7 +1987,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbdux_private *this_usbduxsub = dev->private;
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 		/* switch it on */
@@ -2046,7 +2038,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 /* end of PWM */
 /*****************************************************************/
 
-static void tidy_up(struct usbduxsub *usbduxsub_tmp)
+static void tidy_up(struct usbdux_private *usbduxsub_tmp)
 {
 	int i;
 
@@ -2119,7 +2111,7 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 }
 
 static int usbdux_attach_common(struct comedi_device *dev,
-				struct usbduxsub *udev)
+				struct usbdux_private *udev)
 {
 	int ret;
 	struct comedi_subdevice *s = NULL;
@@ -2250,7 +2242,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
-	struct usbduxsub *this_usbduxsub = usb_get_intfdata(uinterf);
+	struct usbdux_private *this_usbduxsub = usb_get_intfdata(uinterf);
 	struct usb_device *usb = usbduxsub->usbdev;
 	int ret;
 
@@ -2281,7 +2273,7 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 
 static void usbdux_detach(struct comedi_device *dev)
 {
-	struct usbduxsub *usb = dev->private;
+	struct usbdux_private *usb = dev->private;
 
 	if (usb) {
 		down(&usb->sem);
@@ -2527,7 +2519,7 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 
 static void usbdux_usb_disconnect(struct usb_interface *intf)
 {
-	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
+	struct usbdux_private *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
 
 	if (!usbduxsub_tmp) {

commit 1383b9ddb8d37ff3509af562e118b6aa34927a9d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:30:41 2013 -0700

    staging: comedi: usbdux: use comedi_load_firmware()
    
    Use comedi_load_firmware() instead of duplicating the code in a
    private function.
    
    Also, rename firmware_upload() to have namespace associated with
    the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 59a2046dc86e..279e5bd493fa 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -89,7 +89,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
-#include <linux/firmware.h>
 
 #include "../comedidev.h"
 
@@ -724,9 +723,11 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 
 #define FIRMWARE_MAX_LEN 0x2000
 
-static int firmware_upload(struct usbduxsub *usbduxsub,
-			  const u8 *data, int size)
+static int usbdux_firmware_upload(struct comedi_device *dev,
+				  const u8 *data, size_t size,
+				  unsigned long context)
 {
+	struct usbduxsub *usbduxsub = dev->private;
 	struct usb_device *usb = usbduxsub->usbdev;
 	uint8_t *buf;
 	uint8_t *tmp;
@@ -2251,16 +2252,15 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
 	struct usbduxsub *this_usbduxsub = usb_get_intfdata(uinterf);
 	struct usb_device *usb = usbduxsub->usbdev;
-	const struct firmware *fw;
 	int ret;
 
-	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
-	if (ret == 0) {
-		ret = firmware_upload(this_usbduxsub, fw->data, fw->size);
-		release_firmware(fw);
-	}
-	if (ret < 0)
+	dev->private = this_usbduxsub;	/* This is temporary... */
+	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+				   usbdux_firmware_upload, 0);
+	if (ret < 0) {
+		dev->private = NULL;
 		return ret;
+	}
 
 	dev->private = NULL;
 

commit 997beda3daa6fcf1bbc5d6a92b6111c32c881345
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:30:04 2013 -0700

    staging: comedi: usbdux: move firmware request/upload into (*auto_attach)
    
    The last step the usb_driver (*probe) does before handing off to the
    comedi_driver (*auto_attach) is requesting and uploading the firmware.
    
    Move the request/upload into the (*auto_attach) so we can use the
    comedi_load_firmware() helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 405a34514903..59a2046dc86e 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2249,13 +2249,22 @@ static int usbdux_auto_attach(struct comedi_device *dev,
 			      unsigned long context_unused)
 {
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
+	struct usbduxsub *this_usbduxsub = usb_get_intfdata(uinterf);
+	struct usb_device *usb = usbduxsub->usbdev;
+	const struct firmware *fw;
 	int ret;
-	struct usbduxsub *this_usbduxsub;
+
+	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
+	if (ret == 0) {
+		ret = firmware_upload(this_usbduxsub, fw->data, fw->size);
+		release_firmware(fw);
+	}
+	if (ret < 0)
+		return ret;
 
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	this_usbduxsub = usb_get_intfdata(uinterf);
 	if (!this_usbduxsub || !this_usbduxsub->probed) {
 		dev_err(dev->class_dev,
 			"usbdux: error: auto_attach failed, not connected\n");
@@ -2295,10 +2304,8 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
-	const struct firmware *fw;
 	int i;
 	int index;
-	int ret;
 
 	dev_dbg(dev, "comedi_: usbdux_: "
 		"finding a free structure for the usb-device\n");
@@ -2515,14 +2522,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 
-	ret = request_firmware(&fw, FIRMWARE, &udev->dev);
-	if (ret == 0) {
-		ret = firmware_upload(&usbduxsub[index], fw->data, fw->size);
-		release_firmware(fw);
-	}
-	if (ret < 0)
-		return ret;
-
 	return comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
 }
 

commit 4bf6bfe3c8ae4d41c2bb3784981ba069c80ef55e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:29:39 2013 -0700

    staging: comedi: usbdux: consolidate the firmware upload
    
    Absorb the usbdux_stop(), usbdux_upload(), and usbdux_start()
    functions into firmware_upload().
    
    Each of them just do a usb_control_msg() to the device and output
    an error message if it fails. A similar message is also output by
    firmware_upload() so the extra messages are redundant.
    
    We can also share the malloc'ed local buffer needed for the
    usb_control_msg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cb63c77cc131..405a34514903 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -722,154 +722,80 @@ static void usbduxsub_ao_isoc_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_start(struct usbduxsub *usbduxsub)
-{
-	int errcode = 0;
-	uint8_t *local_transfer_buffer;
-
-	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to zero */
-	*local_transfer_buffer = 0;
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  /* create a pipe for a control transfer */
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* bRequest, "Firmware" */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* Value */
-				  USBDUXSUB_CPUCS,
-				  /* Index */
-				  0x0000,
-				  /* address of the transfer buffer */
-				  local_transfer_buffer,
-				  /* Length */
-				  1,
-				  /* Timeout */
-				  BULK_TIMEOUT);
-	if (errcode < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: control msg failed (start)\n");
-
-	kfree(local_transfer_buffer);
-	return errcode;
-}
-
-static int usbduxsub_stop(struct usbduxsub *usbduxsub)
-{
-	int errcode = 0;
-	uint8_t *local_transfer_buffer;
-
-	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to one */
-	*local_transfer_buffer = 1;
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* bRequest, "Firmware" */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* Value */
-				  USBDUXSUB_CPUCS,
-				  /* Index */
-				  0x0000, local_transfer_buffer,
-				  /* Length */
-				  1,
-				  /* Timeout */
-				  BULK_TIMEOUT);
-	if (errcode < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: control msg failed (stop)\n");
-
-	kfree(local_transfer_buffer);
-	return errcode;
-}
-
-static int usbduxsub_upload(struct usbduxsub *usbduxsub,
-			    uint8_t *local_transfer_buffer,
-			    unsigned int start_addr, unsigned int len)
-{
-	int errcode;
-
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* brequest, firmware */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* value */
-				  start_addr,
-				  /* index */
-				  0x0000,
-				  /* our local safe buffer */
-				  local_transfer_buffer,
-				  /* length */
-				  len,
-				  /* timeout */
-				  BULK_TIMEOUT);
-	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
-	if (errcode < 0) {
-		dev_err(&usbduxsub->interface->dev, "comedi_: upload failed\n");
-		return errcode;
-	}
-	return 0;
-}
-
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmware_upload(struct usbduxsub *usbduxsub,
-			  const u8 *firmware_binary, int size_firmware)
+			  const u8 *data, int size)
 {
+	struct usb_device *usb = usbduxsub->usbdev;
+	uint8_t *buf;
+	uint8_t *tmp;
 	int ret;
-	uint8_t *fw_buf;
 
-	if (!firmware_binary)
+	if (!data)
 		return 0;
 
-	if (size_firmware > FIRMWARE_MAX_LEN) {
+	if (size > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
 			"usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
-	fw_buf = kmemdup(firmware_binary, size_firmware, GFP_KERNEL);
-	if (!fw_buf) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: mem alloc for firmware failed\n");
+	buf = kmemdup(data, size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* we need a malloc'ed buffer for usb_control_msg() */
+	tmp = kmalloc(1, GFP_KERNEL);
+	if (!tmp) {
+		kfree(buf);
 		return -ENOMEM;
 	}
 
-	ret = usbduxsub_stop(usbduxsub);
+	/* stop the current firmware on the device */
+	*tmp = 1;	/* 7f92 to one */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not stop firmware\n");
-		kfree(fw_buf);
-		return ret;
+		goto done;
 	}
 
-	ret = usbduxsub_upload(usbduxsub, fw_buf, 0, size_firmware);
+	/* upload the new firmware to the device */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      0, 0x0000,
+			      buf, size,
+			      BULK_TIMEOUT);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: firmware upload failed\n");
-		kfree(fw_buf);
-		return ret;
+		goto done;
 	}
-	ret = usbduxsub_start(usbduxsub);
-	if (ret < 0) {
+
+	/* start the new firmware on the device */
+	*tmp = 0;	/* 7f92 to zero */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not start firmware\n");
-		kfree(fw_buf);
-		return ret;
-	}
-	kfree(fw_buf);
-	return 0;
+
+done:
+	kfree(tmp);
+	kfree(buf);
+	return ret;
 }
 
 static int usbduxsub_submit_inurbs(struct usbduxsub *usbduxsub)

commit 71f89d1813535efb0839248446c349da92cd527a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:29:06 2013 -0700

    staging: comedi: usbdux: request firmware synchronously
    
    Change the request_firmware_nowait() to a request_firmware() so
    that the usb_driver (*probe) can continue with the comedi_driver
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index fec0881aff16..cb63c77cc131 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2364,40 +2364,12 @@ static struct comedi_driver usbdux_driver = {
 	.detach		= usbdux_detach,
 };
 
-static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
-						     void *context)
-{
-	struct usbduxsub *usbduxsub_tmp = context;
-	struct usb_interface *uinterf = usbduxsub_tmp->interface;
-	int ret;
-
-	if (fw == NULL) {
-		dev_err(&uinterf->dev,
-			"Firmware complete handler without firmware!\n");
-		return;
-	}
-
-	/*
-	 * we need to upload the firmware here because fw will be
-	 * freed once we've left this function
-	 */
-	ret = firmware_upload(usbduxsub_tmp, fw->data, fw->size);
-
-	if (ret) {
-		dev_err(&uinterf->dev,
-			"Could not upload firmware (err=%d)\n", ret);
-		goto out;
-	}
-	comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
- out:
-	release_firmware(fw);
-}
-
 static int usbdux_usb_probe(struct usb_interface *uinterf,
 			    const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
+	const struct firmware *fw;
 	int i;
 	int index;
 	int ret;
@@ -2617,23 +2589,15 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 
-	ret = request_firmware_nowait(THIS_MODULE,
-				      FW_ACTION_HOTPLUG,
-				      FIRMWARE,
-				      &udev->dev,
-				      GFP_KERNEL,
-				      usbduxsub + index,
-				      usbdux_firmware_request_complete_handler);
-
-	if (ret) {
-		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
-		return ret;
+	ret = request_firmware(&fw, FIRMWARE, &udev->dev);
+	if (ret == 0) {
+		ret = firmware_upload(&usbduxsub[index], fw->data, fw->size);
+		release_firmware(fw);
 	}
+	if (ret < 0)
+		return ret;
 
-	dev_info(dev, "comedi_: usbdux%d "
-		 "has been successfully initialised.\n", index);
-	/* success */
-	return 0;
+	return comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
 }
 
 static void usbdux_usb_disconnect(struct usb_interface *intf)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6f5da67e26cb..fec0881aff16 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -11,11 +11,6 @@
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
  */
 /*
 Driver: usbdux

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 148ecfcc5dd5..6f5da67e26cb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2207,8 +2207,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	/* pointer back to the corresponding comedi device */
 	udev->comedidev = dev;
 
-	dev->board_name = "usbdux";
-
 	/* set number of subdevices */
 	if (udev->high_speed) {
 		/* with pwm */

commit c45bb8cb72136bf23d18926113bff04c8cc90813
Merge: a14592896023 a937536b868b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 18 09:34:14 2013 -0700

    Merge 3.9-rc3 into staging-next
    
    This resolves the merge error due to removing the ccg staging driver,
    and picks up the other staging driver fixes that went into 3.9-rc3.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b74e5f560c24929f71af5d08020edd5ec9a64904
Author: Jacob Garber <ajtgarber@gmail.com>
Date:   Wed Mar 13 12:19:20 2013 -0400

    Staging: comedi: Fixed camel case style issue in usbdux.c
    
    This is a patch to usbdux.c that fixes the camel case warnings found
    by the checkpatch.pl tool
    
    Signed-off-by: Jacob Garber <ajtgarber@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6f2e42972289..2eac8f0fe7b5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -250,26 +250,26 @@ struct usbduxsub {
 	/* pointer to the usb-device */
 	struct usb_device *usbdev;
 	/* actual number of in-buffers */
-	int numOfInBuffers;
+	int num_in_buffers;
 	/* actual number of out-buffers */
-	int numOfOutBuffers;
+	int num_out_buffers;
 	/* ISO-transfer handling: buffers */
-	struct urb **urbIn;
-	struct urb **urbOut;
+	struct urb **urb_in;
+	struct urb **urb_out;
 	/* pwm-transfer handling */
-	struct urb *urbPwm;
+	struct urb *urb_pwm;
 	/* PWM period */
-	unsigned int pwmPeriod;
+	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	int8_t pwmDelay;
+	int8_t pwn_delay;
 	/* size of the PWM buffer which holds the bit pattern */
-	int sizePwmBuf;
+	int size_pwm_buf;
 	/* input buffer for the ISO-transfer */
-	int16_t *inBuffer;
+	int16_t *in_buffer;
 	/* input buffer for single insn */
-	int16_t *insnBuffer;
+	int16_t *insn_buffer;
 	/* output buffer for single DA outputs */
-	int16_t *outBuffer;
+	int16_t *out_buffer;
 	/* interface number */
 	int ifnum;
 	/* interface structure in 2.6 */
@@ -319,17 +319,17 @@ static DEFINE_SEMAPHORE(start_stop_sem);
  * Stops the data acquision
  * It should be safe to call this function from any context
  */
-static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_inurbs(struct usbduxsub *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
-		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
-			if (usbduxsub_tmp->urbIn[i]) {
+	if (usbduxsub_tmp && usbduxsub_tmp->urb_in) {
+		for (i = 0; i < usbduxsub_tmp->num_in_buffers; i++) {
+			if (usbduxsub_tmp->urb_in[i]) {
 				/* We wait here until all transfers have been
 				 * cancelled. */
-				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+				usb_kill_urb(usbduxsub_tmp->urb_in[i]);
 			}
 			dev_dbg(&usbduxsub_tmp->interface->dev,
 				"comedi: usbdux: unlinked InURB %d, err=%d\n",
@@ -356,7 +356,7 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 
 	if (do_unlink) {
 		/* stop aquistion */
-		ret = usbduxsub_unlink_InURBs(this_usbduxsub);
+		ret = usbduxsub_unlink_inurbs(this_usbduxsub);
 	}
 
 	this_usbduxsub->ai_cmd_running = 0;
@@ -394,7 +394,7 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 }
 
 /* analogue IN - interrupt service routine */
-static void usbduxsub_ai_IsocIrq(struct urb *urb)
+static void usbduxsub_ai_isoc_irq(struct urb *urb)
 {
 	int i, err, n;
 	struct usbduxsub *this_usbduxsub;
@@ -412,7 +412,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
-		memcpy(this_usbduxsub->inBuffer,
+		memcpy(this_usbduxsub->in_buffer,
 		       urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
@@ -517,11 +517,11 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
 			err = comedi_buf_put
 			    (s->async,
-			     le16_to_cpu(this_usbduxsub->inBuffer[i]) ^ 0x800);
+			     le16_to_cpu(this_usbduxsub->in_buffer[i]) ^ 0x800);
 		} else {
 			err = comedi_buf_put
 			    (s->async,
-			     le16_to_cpu(this_usbduxsub->inBuffer[i]));
+			     le16_to_cpu(this_usbduxsub->in_buffer[i]));
 		}
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
@@ -534,15 +534,15 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_outurbs(struct usbduxsub *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
-		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			if (usbduxsub_tmp->urbOut[i])
-				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
+	if (usbduxsub_tmp && usbduxsub_tmp->urb_out) {
+		for (i = 0; i < usbduxsub_tmp->num_out_buffers; i++) {
+			if (usbduxsub_tmp->urb_out[i])
+				usb_kill_urb(usbduxsub_tmp->urb_out[i]);
 
 			dev_dbg(&usbduxsub_tmp->interface->dev,
 				"comedi: usbdux: unlinked OutURB %d: res=%d\n",
@@ -564,7 +564,7 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
+		ret = usbduxsub_unlink_outurbs(this_usbduxsub);
 
 	this_usbduxsub->ao_cmd_running = 0;
 
@@ -593,7 +593,7 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 	return res;
 }
 
-static void usbduxsub_ao_IsocIrq(struct urb *urb)
+static void usbduxsub_ao_isoc_irq(struct urb *urb)
 {
 	int i, ret;
 	int8_t *datap;
@@ -791,7 +791,7 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 			    uint8_t *local_transfer_buffer,
-			    unsigned int startAddr, unsigned int len)
+			    unsigned int start_addr, unsigned int len)
 {
 	int errcode;
 
@@ -802,7 +802,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 				  /* bmRequestType */
 				  VENDOR_DIR_OUT,
 				  /* value */
-				  startAddr,
+				  start_addr,
 				  /* index */
 				  0x0000,
 				  /* our local safe buffer */
@@ -821,24 +821,24 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 
 #define FIRMWARE_MAX_LEN 0x2000
 
-static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 *firmwareBinary, int sizeFirmware)
+static int firmware_upload(struct usbduxsub *usbduxsub,
+			  const u8 *firmware_binary, int size_firmware)
 {
 	int ret;
-	uint8_t *fwBuf;
+	uint8_t *fw_buf;
 
-	if (!firmwareBinary)
+	if (!firmware_binary)
 		return 0;
 
-	if (sizeFirmware > FIRMWARE_MAX_LEN) {
+	if (size_firmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
 			"usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
-	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
-	if (!fwBuf) {
+	fw_buf = kmemdup(firmware_binary, size_firmware, GFP_KERNEL);
+	if (!fw_buf) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
@@ -848,81 +848,81 @@ static int firmwareUpload(struct usbduxsub *usbduxsub,
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not stop firmware\n");
-		kfree(fwBuf);
+		kfree(fw_buf);
 		return ret;
 	}
 
-	ret = usbduxsub_upload(usbduxsub, fwBuf, 0, sizeFirmware);
+	ret = usbduxsub_upload(usbduxsub, fw_buf, 0, size_firmware);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: firmware upload failed\n");
-		kfree(fwBuf);
+		kfree(fw_buf);
 		return ret;
 	}
 	ret = usbduxsub_start(usbduxsub);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not start firmware\n");
-		kfree(fwBuf);
+		kfree(fw_buf);
 		return ret;
 	}
-	kfree(fwBuf);
+	kfree(fw_buf);
 	return 0;
 }
 
-static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_inurbs(struct usbduxsub *usbduxsub)
 {
-	int i, errFlag;
+	int i, err_flag;
 
 	if (!usbduxsub)
 		return -EFAULT;
 
 	/* Submit all URBs and start the transfer on the bus */
-	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
+	for (i = 0; i < usbduxsub->num_in_buffers; i++) {
 		/* in case of a resubmission after an unlink... */
-		usbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;
-		usbduxsub->urbIn[i]->context = usbduxsub->comedidev;
-		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urbIn[i]->status = 0;
-		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub->urb_in[i]->interval = usbduxsub->ai_interval;
+		usbduxsub->urb_in[i]->context = usbduxsub->comedidev;
+		usbduxsub->urb_in[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urb_in[i]->status = 0;
+		usbduxsub->urb_in[i]->transfer_flags = URB_ISO_ASAP;
 		dev_dbg(&usbduxsub->interface->dev,
 			"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",
 			usbduxsub->comedidev->minor, i,
-			(usbduxsub->urbIn[i]->context),
-			(usbduxsub->urbIn[i]->dev),
-			(usbduxsub->urbIn[i]->interval));
-		errFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);
-		if (errFlag) {
+			(usbduxsub->urb_in[i]->context),
+			(usbduxsub->urb_in[i]->dev),
+			(usbduxsub->urb_in[i]->interval));
+		err_flag = usb_submit_urb(usbduxsub->urb_in[i], GFP_ATOMIC);
+		if (err_flag) {
 			dev_err(&usbduxsub->interface->dev,
 				"comedi_: ai: usb_submit_urb(%d) error %d\n",
-				i, errFlag);
-			return errFlag;
+				i, err_flag);
+			return err_flag;
 		}
 	}
 	return 0;
 }
 
-static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_outurbs(struct usbduxsub *usbduxsub)
 {
-	int i, errFlag;
+	int i, err_flag;
 
 	if (!usbduxsub)
 		return -EFAULT;
 
-	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
+	for (i = 0; i < usbduxsub->num_out_buffers; i++) {
 		dev_dbg(&usbduxsub->interface->dev,
 			"comedi_: submitting out-urb[%d]\n", i);
 		/* in case of a resubmission after an unlink... */
-		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
-		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urbOut[i]->status = 0;
-		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
-		errFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);
-		if (errFlag) {
+		usbduxsub->urb_out[i]->context = usbduxsub->comedidev;
+		usbduxsub->urb_out[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urb_out[i]->status = 0;
+		usbduxsub->urb_out[i]->transfer_flags = URB_ISO_ASAP;
+		err_flag = usb_submit_urb(usbduxsub->urb_out[i], GFP_ATOMIC);
+		if (err_flag) {
 			dev_err(&usbduxsub->interface->dev,
 				"comedi_: ao: usb_submit_urb(%d) error %d\n",
-				i, errFlag);
-			return errFlag;
+				i, err_flag);
+			return err_flag;
 		}
 	}
 	return 0;
@@ -933,7 +933,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int err = 0, i;
-	unsigned int tmpTimer;
+	unsigned int tmp_timer;
 
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
@@ -983,7 +983,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 							 1000000 / 8 * i);
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
-			tmpTimer =
+			tmp_timer =
 			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
 			    125000;
 		} else {
@@ -994,11 +994,11 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			/*
 			 * calc the real sampling rate with the rounding errors
 			 */
-			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
+			tmp_timer = ((unsigned int)(cmd->scan_begin_arg /
 						   1000000)) * 1000000;
 		}
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
-						tmpTimer);
+						tmp_timer);
 	}
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
@@ -1074,7 +1074,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 		result = usb_bulk_msg(this_usbduxsub->usbdev,
 				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
 						      COMMAND_IN_EP),
-				      this_usbduxsub->insnBuffer, SIZEINSNBUF,
+				      this_usbduxsub->insn_buffer, SIZEINSNBUF,
 				      &nrec, BULK_TIMEOUT);
 		if (result < 0) {
 			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
@@ -1082,7 +1082,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 				"\n", this_usbduxsub->comedidev->minor, result);
 			return result;
 		}
-		if (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command)
+		if (le16_to_cpu(this_usbduxsub->insn_buffer[0]) == command)
 			return result;
 	}
 	/* this is only reached if the data has been requested a couple of
@@ -1090,7 +1090,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
 		"wrong data returned from firmware: want cmd %d, got cmd %d.\n",
 		this_usbduxsub->comedidev->minor, command,
-		le16_to_cpu(this_usbduxsub->insnBuffer[0]));
+		le16_to_cpu(this_usbduxsub->insn_buffer[0]));
 	return -EFAULT;
 }
 
@@ -1119,7 +1119,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 	}
 	if (!(this_usbduxsub->ai_cmd_running)) {
 		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		ret = usbduxsub_submit_inurbs(this_usbduxsub);
 		if (ret < 0) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi%d: usbdux_ai_inttrig: "
@@ -1236,7 +1236,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		ret = usbduxsub_submit_inurbs(this_usbduxsub);
 		if (ret < 0) {
 			this_usbduxsub->ai_cmd_running = 0;
 			/* fixme: unlink here?? */
@@ -1304,7 +1304,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 			up(&this_usbduxsub->sem);
 			return 0;
 		}
-		one = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
+		one = le16_to_cpu(this_usbduxsub->insn_buffer[1]);
 		if (CR_RANGE(insn->chanspec) <= 1)
 			one = one ^ 0x800;
 
@@ -1334,7 +1334,7 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 		return -ENODEV;
 	}
 	for (i = 0; i < insn->n; i++)
-		data[i] = this_usbduxsub->outBuffer[chan];
+		data[i] = this_usbduxsub->out_buffer[chan];
 
 	up(&this_usbduxsub->sem);
 	return i;
@@ -1377,7 +1377,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		/* one 16 bit value */
 		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
 		    cpu_to_le16(data[i]);
-		this_usbduxsub->outBuffer[chan] = data[i];
+		this_usbduxsub->out_buffer[chan] = data[i];
 		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
 		err = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);
@@ -1414,7 +1414,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 	}
 	if (!(this_usbduxsub->ao_cmd_running)) {
 		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		ret = usbduxsub_submit_outurbs(this_usbduxsub);
 		if (ret < 0) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi%d: usbdux_ao_inttrig: submitURB: "
@@ -1609,7 +1609,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
 		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		ret = usbduxsub_submit_outurbs(this_usbduxsub);
 		if (ret < 0) {
 			this_usbduxsub->ao_cmd_running = 0;
 			/* fixme: unlink here?? */
@@ -1697,7 +1697,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 		return err;
 	}
 
-	data[1] = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
+	data[1] = le16_to_cpu(this_usbduxsub->insn_buffer[1]);
 	up(&this_usbduxsub->sem);
 	return insn->n;
 }
@@ -1733,7 +1733,7 @@ static int usbdux_counter_read(struct comedi_device *dev,
 		return err;
 	}
 
-	data[0] = le16_to_cpu(this_usbduxsub->insnBuffer[chan + 1]);
+	data[0] = le16_to_cpu(this_usbduxsub->insn_buffer[chan + 1]);
 	up(&this_usbduxsub->sem);
 	return 1;
 }
@@ -1780,13 +1780,13 @@ static int usbdux_counter_config(struct comedi_device *dev,
 /***********************************/
 /* PWM */
 
-static int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)
+static int usbduxsub_unlink_pwm_urbs(struct usbduxsub *usbduxsub_tmp)
 {
 	int err = 0;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
-		if (usbduxsub_tmp->urbPwm)
-			usb_kill_urb(usbduxsub_tmp->urbPwm);
+	if (usbduxsub_tmp && usbduxsub_tmp->urb_pwm) {
+		if (usbduxsub_tmp->urb_pwm)
+			usb_kill_urb(usbduxsub_tmp->urb_pwm);
 		dev_dbg(&usbduxsub_tmp->interface->dev,
 			"comedi: unlinked PwmURB: res=%d\n", err);
 	}
@@ -1805,7 +1805,7 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 
 	dev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);
 	if (do_unlink)
-		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
+		ret = usbduxsub_unlink_pwm_urbs(this_usbduxsub);
 
 	this_usbduxsub->pwm_cmd_running = 0;
 
@@ -1878,7 +1878,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	if (!(this_usbduxsub->pwm_cmd_running))
 		return;
 
-	urb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;
+	urb->transfer_buffer_length = this_usbduxsub->size_pwm_buf;
 	urb->dev = this_usbduxsub->usbdev;
 	urb->status = 0;
 	if (this_usbduxsub->pwm_cmd_running) {
@@ -1898,9 +1898,9 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_pwm_urbs(struct usbduxsub *usbduxsub)
 {
-	int errFlag;
+	int err_flag;
 
 	if (!usbduxsub)
 		return -EFAULT;
@@ -1908,19 +1908,19 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 	dev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(usbduxsub->urbPwm,
+	usb_fill_bulk_urb(usbduxsub->urb_pwm,
 			  usbduxsub->usbdev,
 			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
-			  usbduxsub->urbPwm->transfer_buffer,
-			  usbduxsub->sizePwmBuf, usbduxsub_pwm_irq,
+			  usbduxsub->urb_pwm->transfer_buffer,
+			  usbduxsub->size_pwm_buf, usbduxsub_pwm_irq,
 			  usbduxsub->comedidev);
 
-	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
-	if (errFlag) {
+	err_flag = usb_submit_urb(usbduxsub->urb_pwm, GFP_ATOMIC);
+	if (err_flag) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: usbdux: pwm: usb_submit_urb error %d\n",
-			errFlag);
-		return errFlag;
+			err_flag);
+		return err_flag;
 	}
 	return 0;
 }
@@ -1945,8 +1945,8 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 			return -EAGAIN;
 		}
 	}
-	this_usbduxsub->pwmDelay = fx2delay;
-	this_usbduxsub->pwmPeriod = period;
+	this_usbduxsub->pwn_delay = fx2delay;
+	this_usbduxsub->pwm_period = period;
 	dev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",
 		__func__, period, fx2delay);
 	return 0;
@@ -1967,17 +1967,17 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 		return 0;
 	}
 
-	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwmDelay);
+	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwn_delay);
 	ret = send_dux_commands(this_usbduxsub, SENDPWMON);
 	if (ret < 0)
 		return ret;
 
 	/* initialise the buffer */
-	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
-		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
+	for (i = 0; i < this_usbduxsub->size_pwm_buf; i++)
+		((char *)(this_usbduxsub->urb_pwm->transfer_buffer))[i] = 0;
 
 	this_usbduxsub->pwm_cmd_running = 1;
-	ret = usbduxsub_submit_PwmURBs(this_usbduxsub);
+	ret = usbduxsub_submit_pwm_urbs(this_usbduxsub);
 	if (ret < 0) {
 		this_usbduxsub->pwm_cmd_running = 0;
 		return ret;
@@ -1992,7 +1992,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int i, szbuf;
-	char *pBuf;
+	char *p_buf;
 	char pwm_mask;
 	char sgn_mask;
 	char c;
@@ -2006,10 +2006,10 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 	sgn_mask = (16 << channel);
 	/* this is the buffer which will be filled with the with bit */
 	/* pattern for one period */
-	szbuf = this_usbduxsub->sizePwmBuf;
-	pBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);
+	szbuf = this_usbduxsub->size_pwm_buf;
+	p_buf = (char *)(this_usbduxsub->urb_pwm->transfer_buffer);
 	for (i = 0; i < szbuf; i++) {
-		c = *pBuf;
+		c = *p_buf;
 		/* reset bits */
 		c = c & (~pwm_mask);
 		/* set the bit as long as the index is lower than the value */
@@ -2023,7 +2023,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 			/* negative value */
 			c = c | sgn_mask;
 		}
-		*(pBuf++) = c;
+		*(p_buf++) = c;
 	}
 	return 1;
 }
@@ -2095,7 +2095,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 			"comedi%d: %s: setting period\n", dev->minor, __func__);
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
-		data[1] = this_usbduxsub->pwmPeriod;
+		data[1] = this_usbduxsub->pwm_period;
 		return 0;
 	case INSN_CONFIG_PWM_SET_H_BRIDGE:
 		/* value in the first byte and the sign in the second for a
@@ -2131,55 +2131,55 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 
 	usbduxsub_tmp->probed = 0;
 
-	if (usbduxsub_tmp->urbIn) {
+	if (usbduxsub_tmp->urb_in) {
 		if (usbduxsub_tmp->ai_cmd_running) {
 			usbduxsub_tmp->ai_cmd_running = 0;
-			usbduxsub_unlink_InURBs(usbduxsub_tmp);
+			usbduxsub_unlink_inurbs(usbduxsub_tmp);
 		}
-		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
-			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
-			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
-			usb_kill_urb(usbduxsub_tmp->urbIn[i]);
-			usb_free_urb(usbduxsub_tmp->urbIn[i]);
-			usbduxsub_tmp->urbIn[i] = NULL;
+		for (i = 0; i < usbduxsub_tmp->num_in_buffers; i++) {
+			kfree(usbduxsub_tmp->urb_in[i]->transfer_buffer);
+			usbduxsub_tmp->urb_in[i]->transfer_buffer = NULL;
+			usb_kill_urb(usbduxsub_tmp->urb_in[i]);
+			usb_free_urb(usbduxsub_tmp->urb_in[i]);
+			usbduxsub_tmp->urb_in[i] = NULL;
 		}
-		kfree(usbduxsub_tmp->urbIn);
-		usbduxsub_tmp->urbIn = NULL;
+		kfree(usbduxsub_tmp->urb_in);
+		usbduxsub_tmp->urb_in = NULL;
 	}
-	if (usbduxsub_tmp->urbOut) {
+	if (usbduxsub_tmp->urb_out) {
 		if (usbduxsub_tmp->ao_cmd_running) {
 			usbduxsub_tmp->ao_cmd_running = 0;
-			usbduxsub_unlink_OutURBs(usbduxsub_tmp);
+			usbduxsub_unlink_outurbs(usbduxsub_tmp);
 		}
-		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			kfree(usbduxsub_tmp->urbOut[i]->transfer_buffer);
-			usbduxsub_tmp->urbOut[i]->transfer_buffer = NULL;
-			if (usbduxsub_tmp->urbOut[i]) {
-				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-				usb_free_urb(usbduxsub_tmp->urbOut[i]);
-				usbduxsub_tmp->urbOut[i] = NULL;
+		for (i = 0; i < usbduxsub_tmp->num_out_buffers; i++) {
+			kfree(usbduxsub_tmp->urb_out[i]->transfer_buffer);
+			usbduxsub_tmp->urb_out[i]->transfer_buffer = NULL;
+			if (usbduxsub_tmp->urb_out[i]) {
+				usb_kill_urb(usbduxsub_tmp->urb_out[i]);
+				usb_free_urb(usbduxsub_tmp->urb_out[i]);
+				usbduxsub_tmp->urb_out[i] = NULL;
 			}
 		}
-		kfree(usbduxsub_tmp->urbOut);
-		usbduxsub_tmp->urbOut = NULL;
+		kfree(usbduxsub_tmp->urb_out);
+		usbduxsub_tmp->urb_out = NULL;
 	}
-	if (usbduxsub_tmp->urbPwm) {
+	if (usbduxsub_tmp->urb_pwm) {
 		if (usbduxsub_tmp->pwm_cmd_running) {
 			usbduxsub_tmp->pwm_cmd_running = 0;
-			usbduxsub_unlink_PwmURBs(usbduxsub_tmp);
+			usbduxsub_unlink_pwm_urbs(usbduxsub_tmp);
 		}
-		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
-		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
-		usb_kill_urb(usbduxsub_tmp->urbPwm);
-		usb_free_urb(usbduxsub_tmp->urbPwm);
-		usbduxsub_tmp->urbPwm = NULL;
-	}
-	kfree(usbduxsub_tmp->inBuffer);
-	usbduxsub_tmp->inBuffer = NULL;
-	kfree(usbduxsub_tmp->insnBuffer);
-	usbduxsub_tmp->insnBuffer = NULL;
-	kfree(usbduxsub_tmp->outBuffer);
-	usbduxsub_tmp->outBuffer = NULL;
+		kfree(usbduxsub_tmp->urb_pwm->transfer_buffer);
+		usbduxsub_tmp->urb_pwm->transfer_buffer = NULL;
+		usb_kill_urb(usbduxsub_tmp->urb_pwm);
+		usb_free_urb(usbduxsub_tmp->urb_pwm);
+		usbduxsub_tmp->urb_pwm = NULL;
+	}
+	kfree(usbduxsub_tmp->in_buffer);
+	usbduxsub_tmp->in_buffer = NULL;
+	kfree(usbduxsub_tmp->insn_buffer);
+	usbduxsub_tmp->insn_buffer = NULL;
+	kfree(usbduxsub_tmp->out_buffer);
+	usbduxsub_tmp->out_buffer = NULL;
 	kfree(usbduxsub_tmp->dac_commands);
 	usbduxsub_tmp->dac_commands = NULL;
 	kfree(usbduxsub_tmp->dux_commands);
@@ -2302,7 +2302,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;
 		/* this defines the max duty cycle resolution */
-		s->maxdata = udev->sizePwmBuf;
+		s->maxdata = udev->size_pwm_buf;
 		s->insn_write = usbdux_pwm_write;
 		s->insn_read = usbdux_pwm_read;
 		s->insn_config = usbdux_pwm_config;
@@ -2381,7 +2381,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	 * we need to upload the firmware here because fw will be
 	 * freed once we've left this function
 	 */
-	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
+	ret = firmware_upload(usbduxsub_tmp, fw->data, fw->size);
 
 	if (ret) {
 		dev_err(&uinterf->dev,
@@ -2457,22 +2457,22 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		return -ENOMEM;
 	}
 	/* create space for the in buffer and set it to zero */
-	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].inBuffer)) {
+	usbduxsub[index].in_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].in_buffer)) {
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space of the instruction buffer */
-	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].insnBuffer)) {
+	usbduxsub[index].insn_buffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].insn_buffer)) {
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the outbuffer */
-	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].outBuffer)) {
+	usbduxsub[index].out_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].out_buffer)) {
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2489,124 +2489,124 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		return -ENODEV;
 	}
 	if (usbduxsub[index].high_speed)
-		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
+		usbduxsub[index].num_in_buffers = NUMOFINBUFFERSHIGH;
 	else
-		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
+		usbduxsub[index].num_in_buffers = NUMOFINBUFFERSFULL;
 
-	usbduxsub[index].urbIn =
-		kcalloc(usbduxsub[index].numOfInBuffers, sizeof(struct urb *),
+	usbduxsub[index].urb_in =
+		kcalloc(usbduxsub[index].num_in_buffers, sizeof(struct urb *),
 			GFP_KERNEL);
-	if (!(usbduxsub[index].urbIn)) {
+	if (!(usbduxsub[index].urb_in)) {
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
+	for (i = 0; i < usbduxsub[index].num_in_buffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbIn[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urbIn[i] == NULL) {
+		usbduxsub[index].urb_in[i] = usb_alloc_urb(1, GFP_KERNEL);
+		if (usbduxsub[index].urb_in[i] == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
+		usbduxsub[index].urb_in[i]->dev = usbduxsub[index].usbdev;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urbIn[i]->context = NULL;
-		usbduxsub[index].urbIn[i]->pipe =
+		usbduxsub[index].urb_in[i]->context = NULL;
+		usbduxsub[index].urb_in[i]->pipe =
 		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
-		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urbIn[i]->transfer_buffer =
+		usbduxsub[index].urb_in[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urb_in[i]->transfer_buffer =
 		    kzalloc(SIZEINBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
+		if (!(usbduxsub[index].urb_in[i]->transfer_buffer)) {
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;
-		usbduxsub[index].urbIn[i]->number_of_packets = 1;
-		usbduxsub[index].urbIn[i]->transfer_buffer_length = SIZEINBUF;
-		usbduxsub[index].urbIn[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urbIn[i]->iso_frame_desc[0].length = SIZEINBUF;
+		usbduxsub[index].urb_in[i]->complete = usbduxsub_ai_isoc_irq;
+		usbduxsub[index].urb_in[i]->number_of_packets = 1;
+		usbduxsub[index].urb_in[i]->transfer_buffer_length = SIZEINBUF;
+		usbduxsub[index].urb_in[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urb_in[i]->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
 	/* out */
 	if (usbduxsub[index].high_speed)
-		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+		usbduxsub[index].num_out_buffers = NUMOFOUTBUFFERSHIGH;
 	else
-		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+		usbduxsub[index].num_out_buffers = NUMOFOUTBUFFERSFULL;
 
-	usbduxsub[index].urbOut =
-		kcalloc(usbduxsub[index].numOfOutBuffers, sizeof(struct urb *),
+	usbduxsub[index].urb_out =
+		kcalloc(usbduxsub[index].num_out_buffers, sizeof(struct urb *),
 			GFP_KERNEL);
-	if (!(usbduxsub[index].urbOut)) {
+	if (!(usbduxsub[index].urb_out)) {
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
+	for (i = 0; i < usbduxsub[index].num_out_buffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbOut[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urbOut[i] == NULL) {
+		usbduxsub[index].urb_out[i] = usb_alloc_urb(1, GFP_KERNEL);
+		if (usbduxsub[index].urb_out[i] == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
+		usbduxsub[index].urb_out[i]->dev = usbduxsub[index].usbdev;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urbOut[i]->context = NULL;
-		usbduxsub[index].urbOut[i]->pipe =
+		usbduxsub[index].urb_out[i]->context = NULL;
+		usbduxsub[index].urb_out[i]->pipe =
 		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
-		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urbOut[i]->transfer_buffer =
+		usbduxsub[index].urb_out[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urb_out[i]->transfer_buffer =
 		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
+		if (!(usbduxsub[index].urb_out[i]->transfer_buffer)) {
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;
-		usbduxsub[index].urbOut[i]->number_of_packets = 1;
-		usbduxsub[index].urbOut[i]->transfer_buffer_length = SIZEOUTBUF;
-		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
+		usbduxsub[index].urb_out[i]->complete = usbduxsub_ao_isoc_irq;
+		usbduxsub[index].urb_out[i]->number_of_packets = 1;
+		usbduxsub[index].urb_out[i]->transfer_buffer_length = SIZEOUTBUF;
+		usbduxsub[index].urb_out[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urb_out[i]->iso_frame_desc[0].length =
 		    SIZEOUTBUF;
 		if (usbduxsub[index].high_speed) {
 			/* uframes */
-			usbduxsub[index].urbOut[i]->interval = 8;
+			usbduxsub[index].urb_out[i]->interval = 8;
 		} else {
 			/* frames */
-			usbduxsub[index].urbOut[i]->interval = 1;
+			usbduxsub[index].urb_out[i]->interval = 1;
 		}
 	}
 
 	/* pwm */
 	if (usbduxsub[index].high_speed) {
 		/* max bulk ep size in high speed */
-		usbduxsub[index].sizePwmBuf = 512;
-		usbduxsub[index].urbPwm = usb_alloc_urb(0, GFP_KERNEL);
-		if (usbduxsub[index].urbPwm == NULL) {
+		usbduxsub[index].size_pwm_buf = 512;
+		usbduxsub[index].urb_pwm = usb_alloc_urb(0, GFP_KERNEL);
+		if (usbduxsub[index].urb_pwm == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. pwm urb\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbPwm->transfer_buffer =
-		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
-		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
+		usbduxsub[index].urb_pwm->transfer_buffer =
+		    kzalloc(usbduxsub[index].size_pwm_buf, GFP_KERNEL);
+		if (!(usbduxsub[index].urb_pwm->transfer_buffer)) {
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
 	} else {
-		usbduxsub[index].urbPwm = NULL;
-		usbduxsub[index].sizePwmBuf = 0;
+		usbduxsub[index].urb_pwm = NULL;
+		usbduxsub[index].size_pwm_buf = 0;
 	}
 
 	usbduxsub[index].ai_cmd_running = 0;

commit 20ce161d2f53af092fe8dabfef6fb0d7af846c43
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Mar 7 23:48:40 2013 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typos in staging/comedi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1a0062a04456..6f2e42972289 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -56,7 +56,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  *       functions firmware upload is by fxload and no longer by comedi (due to
  *       enumeration)
  * 0.97: USB IDs received, adjusted table
- * 0.98: SMP, locking, memroy alloc: moved all usb memory alloc
+ * 0.98: SMP, locking, memory alloc: moved all usb memory alloc
  *       to the usb subsystem and moved all comedi related memory
  *       alloc to comedi.
  *       | kernel | registration | usbdux-usb | usbdux-comedi | comedi |

commit d49c3d61cfdb33165d2760817ec9601d277575d4
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Fri Feb 22 10:07:03 2013 -0800

    staging: comedi: drivers: usbdux.c: fix DMA buffers on stack
    
    fix for instances of DMA buffer on stack(being passed to usb_control_msg) for
    the USB-DUX-D Board driver.
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1a0062a04456..6aac1f60bc42 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -730,10 +730,14 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 static int usbduxsub_start(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
-	uint8_t local_transfer_buffer[16];
+	uint8_t *local_transfer_buffer;
+
+	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to zero */
-	local_transfer_buffer[0] = 0;
+	*local_transfer_buffer = 0;
 	errcode = usb_control_msg(usbduxsub->usbdev,
 				  /* create a pipe for a control transfer */
 				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
@@ -751,22 +755,25 @@ static int usbduxsub_start(struct usbduxsub *usbduxsub)
 				  1,
 				  /* Timeout */
 				  BULK_TIMEOUT);
-	if (errcode < 0) {
+	if (errcode < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (start)\n");
-		return errcode;
-	}
-	return 0;
+
+	kfree(local_transfer_buffer);
+	return errcode;
 }
 
 static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
+	uint8_t *local_transfer_buffer;
 
-	uint8_t local_transfer_buffer[16];
+	local_transfer_buffer = kmalloc(1, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to one */
-	local_transfer_buffer[0] = 1;
+	*local_transfer_buffer = 1;
 	errcode = usb_control_msg(usbduxsub->usbdev,
 				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
 				  /* bRequest, "Firmware" */
@@ -781,12 +788,12 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 				  1,
 				  /* Timeout */
 				  BULK_TIMEOUT);
-	if (errcode < 0) {
+	if (errcode < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (stop)\n");
-		return errcode;
-	}
-	return 0;
+
+	kfree(local_transfer_buffer);
+	return errcode;
 }
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7c2f8568ebb3..1a0062a04456 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2445,8 +2445,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	if (!usbduxsub[index].dac_commands) {
-		dev_err(dev, "comedi_: usbdux: "
-			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2454,8 +2452,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* create space for the commands going to the usb device */
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!usbduxsub[index].dux_commands) {
-		dev_err(dev, "comedi_: usbdux: "
-			"error alloc space for dux commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2463,8 +2459,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* create space for the in buffer and set it to zero */
 	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].inBuffer)) {
-		dev_err(dev, "comedi_: usbdux: "
-			"could not alloc space for inBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2472,8 +2466,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* create space of the instruction buffer */
 	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].insnBuffer)) {
-		dev_err(dev, "comedi_: usbdux: "
-			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2481,8 +2473,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 	/* create space for the outbuffer */
 	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].outBuffer)) {
-		dev_err(dev, "comedi_: usbdux: "
-			"could not alloc space for outBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2504,10 +2494,9 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
 
 	usbduxsub[index].urbIn =
-	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
-		    GFP_KERNEL);
+		kcalloc(usbduxsub[index].numOfInBuffers, sizeof(struct urb *),
+			GFP_KERNEL);
 	if (!(usbduxsub[index].urbIn)) {
-		dev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2532,8 +2521,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbIn[i]->transfer_buffer =
 		    kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2552,11 +2539,9 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 
 	usbduxsub[index].urbOut =
-	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
-		    GFP_KERNEL);
+		kcalloc(usbduxsub[index].numOfOutBuffers, sizeof(struct urb *),
+			GFP_KERNEL);
 	if (!(usbduxsub[index].urbOut)) {
-		dev_err(dev, "comedi_: usbdux: "
-			"Could not alloc. urbOut array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2581,8 +2566,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbOut[i]->transfer_buffer =
 		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2617,8 +2600,6 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbPwm->transfer_buffer =
 		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
 		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbdux%d: "
-				"could not alloc. transb. for pwm\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;

commit 55ab4f641a3bfbdb7c59b80e194c7242234bbb1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:23:40 2013 -0700

    staging: comedi: comedi_usb: allow comedi usb drivers to pass a 'context'
    
    Allow the comedi usb drivers to pass a 'context' from their (*probe)
    functions to the comedi core's comedi_usb_auto_config(). This 'context'
    is then passed to comedi_auto_config() and then to the comedi_driver's
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 17b45ebb0553..7c2f8568ebb3 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2388,7 +2388,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(uinterf, &usbdux_driver);
+	comedi_usb_auto_config(uinterf, &usbdux_driver, 0);
  out:
 	release_firmware(fw);
 }

commit a2013a13e68354e0c8f3696b69701803e13fb737
Merge: dadfab487325 106f9d9337f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:00:02 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial branch from Jiri Kosina:
     "Usual stuff -- comment/printk typo fixes, documentation updates, dead
      code elimination."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      HOWTO: fix double words typo
      x86 mtrr: fix comment typo in mtrr_bp_init
      propagate name change to comments in kernel source
      doc: Update the name of profiling based on sysfs
      treewide: Fix typos in various drivers
      treewide: Fix typos in various Kconfig
      wireless: mwifiex: Fix typo in wireless/mwifiex driver
      messages: i2o: Fix typo in messages/i2o
      scripts/kernel-doc: check that non-void fcts describe their return value
      Kernel-doc: Convention: Use a "Return" section to describe return values
      radeon: Fix typo and copy/paste error in comments
      doc: Remove unnecessary declarations from Documentation/accounting/getdelays.c
      various: Fix spelling of "asynchronous" in comments.
      Fix misspellings of "whether" in comments.
      eisa: Fix spelling of "asynchronous".
      various: Fix spelling of "registered" in comments.
      doc: fix quite a few typos within Documentation
      target: iscsi: fix comment typos in target/iscsi drivers
      treewide: fix typo of "suport" in various comments and Kconfig
      treewide: fix typo of "suppport" in various comments
      ...

commit 02582e9bcc36ed503ffede46e104a885dea222fb
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Aug 22 19:11:26 2012 +0900

    treewide: fix typo of "suport" in various comments and Kconfig
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index b536bba74351..c484a7352940 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -73,7 +73,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  *       And loads of cleaning up, in particular streamlining the
  *       bulk transfers.
  * 1.1:  moved EP4 transfers to EP1 to make space for a PWM output on EP4
- * 1.2:  added PWM suport via EP4
+ * 1.2:  added PWM support via EP4
  * 2.0:  PWM seems to be stable and is not interfering with the other functions
  * 2.1:  changed PWM API
  * 2.2:  added firmware kernel request to fix an udev problem

commit f4d36c7a424647aa07a1bb5facd226cdf2f03151
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:59:48 2012 -0700

    staging: comedi: usbdux: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of usbdux_{ai,ao}_cmdtest().
    
    Also, remove some dev_dbg() noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9629b4f469cf..78f3a2e013c4 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -938,9 +938,6 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -962,19 +959,12 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (this_usbduxsub->high_speed) {
@@ -989,51 +979,35 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			while (i < (cmd->chanlist_len))
 				i = i * 2;
 
-			if (cmd->scan_begin_arg < (1000000 / 8 * i)) {
-				cmd->scan_begin_arg = 1000000 / 8 * i;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 1000000 / 8 * i);
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
 			tmpTimer =
 			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
 			    125000;
-			if (cmd->scan_begin_arg != tmpTimer) {
-				cmd->scan_begin_arg = tmpTimer;
-				err++;
-			}
 		} else {
 			/* full speed */
 			/* 1kHz scans every USB frame */
-			if (cmd->scan_begin_arg < 1000000) {
-				cmd->scan_begin_arg = 1000000;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 1000000);
 			/*
 			 * calc the real sampling rate with the rounding errors
 			 */
 			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
 						   1000000)) * 1000000;
-			if (cmd->scan_begin_arg != tmpTimer) {
-				cmd->scan_begin_arg = tmpTimer;
-				err++;
-			}
 		}
-	}
-	/* the same argument */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
+						tmpTimer);
 	}
 
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)
@@ -1472,9 +1446,6 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1519,57 +1490,30 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 1000000);
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		/* timer */
-		if (cmd->scan_begin_arg < 1000000) {
-			cmd->scan_begin_arg = 1000000;
-			err++;
-		}
-	}
 	/* not used now, is for later use */
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < 125000) {
-			cmd->convert_arg = 125000;
-			err++;
-		}
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 125000);
 
-	/* the same argument */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: err=%d, "
-		"scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, "
-		"convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src,
-		cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
-
 	if (err)
 		return 3;
 

commit 807e65b0a818cd9b1604144af379bcabd24d4b85
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:03 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_usb
    
    Change the usbdux, usbduxfast and usbduxsigma drivers to use the new
    `auto_attach()` method instead of the `attach_usb()` method.  I plan to
    remove the `attach_usb()` and `attach_pci()` methods from `struct
    comedi_driver` once nothing is using them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index e89f4e2927b6..9629b4f469cf 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2375,9 +2375,10 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbdux_attach_usb(struct comedi_device *dev,
-			     struct usb_interface *uinterf)
+static int usbdux_auto_attach(struct comedi_device *dev,
+			      unsigned long context_unused)
 {
+	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
 	int ret;
 	struct usbduxsub *this_usbduxsub;
 
@@ -2387,11 +2388,11 @@ static int usbdux_attach_usb(struct comedi_device *dev,
 	this_usbduxsub = usb_get_intfdata(uinterf);
 	if (!this_usbduxsub || !this_usbduxsub->probed) {
 		dev_err(dev->class_dev,
-			"usbdux: error: attach_usb failed, not connected\n");
+			"usbdux: error: auto_attach failed, not connected\n");
 		ret = -ENODEV;
 	} else if (this_usbduxsub->attached) {
 		dev_err(dev->class_dev,
-			"error: attach_usb failed, already attached\n");
+			"error: auto_attach failed, already attached\n");
 		ret = -ENODEV;
 	} else
 		ret = usbdux_attach_common(dev, this_usbduxsub);
@@ -2415,7 +2416,7 @@ static void usbdux_detach(struct comedi_device *dev)
 static struct comedi_driver usbdux_driver = {
 	.driver_name	= "usbdux",
 	.module		= THIS_MODULE,
-	.attach_usb	= usbdux_attach_usb,
+	.auto_attach	= usbdux_auto_attach,
 	.detach		= usbdux_detach,
 };
 

commit 3818a1427125c3f7fb408201eb9af826e93bdc42
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Mon Oct 8 21:25:37 2012 +0900

    staging/comedi: Use dev_ printks in drivers/usbdux.c
    
    fixed below checkpatch warning.
    - WARNING: Prefer netdev_err(netdev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index b536bba74351..e89f4e2927b6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2386,14 +2386,12 @@ static int usbdux_attach_usb(struct comedi_device *dev,
 	down(&start_stop_sem);
 	this_usbduxsub = usb_get_intfdata(uinterf);
 	if (!this_usbduxsub || !this_usbduxsub->probed) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach_usb failed, not connected\n",
-		       dev->minor);
+		dev_err(dev->class_dev,
+			"usbdux: error: attach_usb failed, not connected\n");
 		ret = -ENODEV;
 	} else if (this_usbduxsub->attached) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach_usb failed, already attached\n",
-		       dev->minor);
+		dev_err(dev->class_dev,
+			"error: attach_usb failed, already attached\n");
 		ret = -ENODEV;
 	} else
 		ret = usbdux_attach_common(dev, this_usbduxsub);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bc5fc5cc4641..b536bba74351 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -98,6 +98,8 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #include "../comedidev.h"
 
+#include "comedi_fc.h"
+
 /* timeout for the USB-transfer in ms*/
 #define BULK_TIMEOUT 1000
 
@@ -929,9 +931,9 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0, tmp, i;
-	unsigned int tmpTimer;
 	struct usbduxsub *this_usbduxsub = dev->private;
+	int err = 0, i;
+	unsigned int tmpTimer;
 
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
@@ -939,51 +941,23 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
 
-	/* make sure triggers are valid */
-	/* Only immediate triggers are allowed */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	/* trigger should happen timed */
-	tmp = cmd->scan_begin_src;
-	/* start a new _scan_ with a timer */
-	cmd->scan_begin_src &= TRIG_TIMER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	/* scanning is continuous */
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	/* issue a trigger when scan is finished and start a new scan */
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	/* trigger at the end of count events or not, stop condition or not */
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique and mutually compatible
-	 * note that mutual compatibility is not an issue here
-	 */
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_TIMER)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -1488,8 +1462,9 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0, tmp;
 	struct usbduxsub *this_usbduxsub = dev->private;
+	int err = 0;
+	unsigned int flags;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1500,69 +1475,46 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
 
-	/* make sure triggers are valid */
-	/* Only immediate triggers are allowed */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	/* trigger should happen timed */
-	tmp = cmd->scan_begin_src;
-	/* just now we scan also in the high speed mode every frame */
-	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* start immediately a new scan */
 		/* the sampling rate is set by the coversion rate */
-		cmd->scan_begin_src &= TRIG_FOLLOW;
+		flags = TRIG_FOLLOW;
 	} else {
 		/* start a new scan (output at once) with a timer */
-		cmd->scan_begin_src &= TRIG_TIMER;
+		flags = TRIG_TIMER;
 	}
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
 
-	/* scanning is continuous */
-	tmp = cmd->convert_src;
-	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
 		/*
-		 * in usb-2.0 only one conversion it transmitted but with 8kHz/n
+		 * in usb-2.0 only one conversion it transmitted
+		 * but with 8kHz/n
 		 */
-		cmd->convert_src &= TRIG_TIMER;
+		flags = TRIG_TIMER;
 	} else {
-		/* all conversion events happen simultaneously with a rate of
-		 * 1kHz/n */
-		cmd->convert_src &= TRIG_NOW;
+		/*
+		 * all conversion events happen simultaneously with
+		 * a rate of 1kHz/n
+		 */
+		flags = TRIG_NOW;
 	}
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	/* issue a trigger when scan is finished and start a new scan */
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
 
-	/* trigger at the end of count events or not, stop condition or not */
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique and mutually compatible
-	 * note that mutual compatibility is not an issue here
-	 */
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_TIMER)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 5a0f2260897621cc0118cd16801b171acd06c31c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 16:21:13 2012 -0700

    staging: comedi: usbdux: remove usbdux_attach
    
    This driver originally used the 'attach' method in order to get
    the firmware for the device from the comedi_config utility. It
    now uses request_firmware_nowait() in the usb_driver probe to
    get this firmware.
    
    Since this driver has an 'attach_usb' method in the comedi_driver,
    the 'attach' method can be removed because it is now optional.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7aac213fb6ab..bc5fc5cc4641 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2293,10 +2293,8 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
-/* common part of attach and attach_usb */
 static int usbdux_attach_common(struct comedi_device *dev,
-				struct usbduxsub *udev,
-				void *aux_data, int aux_len)
+				struct usbduxsub *udev)
 {
 	int ret;
 	struct comedi_subdevice *s = NULL;
@@ -2306,10 +2304,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	/* pointer back to the corresponding comedi device */
 	udev->comedidev = dev;
 
-	/* trying to upload the firmware into the chip */
-	if (aux_data)
-		firmwareUpload(udev, aux_data, aux_len);
-
 	dev->board_name = "usbdux";
 
 	/* set number of subdevices */
@@ -2429,48 +2423,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-/* is called when comedi-config is called */
-static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
-
-	if (index < 0) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n",
-		       dev->minor);
-		ret = -ENODEV;
-	} else
-		ret = usbdux_attach_common(dev, &usbduxsub[index],
-					   aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
 static int usbdux_attach_usb(struct comedi_device *dev,
 			     struct usb_interface *uinterf)
 {
@@ -2492,7 +2444,7 @@ static int usbdux_attach_usb(struct comedi_device *dev,
 		       dev->minor);
 		ret = -ENODEV;
 	} else
-		ret = usbdux_attach_common(dev, this_usbduxsub, NULL, 0);
+		ret = usbdux_attach_common(dev, this_usbduxsub);
 	up(&start_stop_sem);
 	return ret;
 }
@@ -2513,9 +2465,8 @@ static void usbdux_detach(struct comedi_device *dev)
 static struct comedi_driver usbdux_driver = {
 	.driver_name	= "usbdux",
 	.module		= THIS_MODULE,
-	.attach		= usbdux_attach,
-	.detach		= usbdux_detach,
 	.attach_usb	= usbdux_attach_usb,
+	.detach		= usbdux_detach,
 };
 
 static void usbdux_firmware_request_complete_handler(const struct firmware *fw,

commit 4760904fb4a2841c9ac651e36610724929122385
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:58:15 2012 -0700

    staging: comedi: usbdux: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 11ee83681da7..7aac213fb6ab 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -404,7 +404,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 	/* subdevice which is the AD converter */
-	s = this_comedidev->subdevices + SUBDEV_AD;
+	s = &this_comedidev->subdevices[SUBDEV_AD];
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
@@ -604,7 +604,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
-	s = this_comedidev->subdevices + SUBDEV_DA;
+	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -1947,7 +1947,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
-	s = this_comedidev->subdevices + SUBDEV_DA;
+	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -2331,7 +2331,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	dev->private = udev;
 
 	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
+	s = &dev->subdevices[SUBDEV_AD];
 	/* the URBs get the comedi subdevice */
 	/* which is responsible for reading */
 	/* this is the subdevice which reads data */
@@ -2358,7 +2358,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	s->range_table = (&range_usbdux_ai_range);
 
 	/* analog out */
-	s = dev->subdevices + SUBDEV_DA;
+	s = &dev->subdevices[SUBDEV_DA];
 	/* analog out */
 	s->type = COMEDI_SUBD_AO;
 	/* backward pointer */
@@ -2384,7 +2384,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	s->insn_write = usbdux_ao_insn_write;
 
 	/* digital I/O */
-	s = dev->subdevices + SUBDEV_DIO;
+	s = &dev->subdevices[SUBDEV_DIO];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 	s->n_chan = 8;
@@ -2396,7 +2396,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	s->private = NULL;
 
 	/* counter */
-	s = dev->subdevices + SUBDEV_COUNTER;
+	s = &dev->subdevices[SUBDEV_COUNTER];
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 	s->n_chan = 4;
@@ -2407,7 +2407,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 
 	if (udev->high_speed) {
 		/* timer / pwm */
-		s = dev->subdevices + SUBDEV_PWM;
+		s = &dev->subdevices[SUBDEV_PWM];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;

commit 1e1ccc3ad6ebe720e14dd9787f6b5cebaf46f573
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Thu Aug 16 11:15:37 2012 -0600

    staging: comedi: usbdux: Declare MODULE_FIRMWARE usage
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 848c7ec06976..11ee83681da7 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -102,6 +102,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define BULK_TIMEOUT 1000
 
 /* constants for "firmware" upload and download */
+#define FIRMWARE "usbdux_firmware.bin"
 #define USBDUXSUB_FIRMWARE 0xA0
 #define VENDOR_DIR_IN  0xC0
 #define VENDOR_DIR_OUT 0x40
@@ -2791,7 +2792,7 @@ static int usbdux_usb_probe(struct usb_interface *uinterf,
 
 	ret = request_firmware_nowait(THIS_MODULE,
 				      FW_ACTION_HOTPLUG,
-				      "usbdux_firmware.bin",
+				      FIRMWARE,
 				      &udev->dev,
 				      GFP_KERNEL,
 				      usbduxsub + index,
@@ -2850,3 +2851,4 @@ module_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);
 MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
 MODULE_DESCRIPTION("Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(FIRMWARE);

commit 3403cc0f701db8a3f1082e5b1027265ee1343b20
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:02:49 2012 -0700

    staging: comedi: usbdux: refactor init code
    
    Refactor the usb driver probe/disconnect and comedi driver attach/
    detach to follow the style of the other comedi driver types to
    improve maintainability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 586936bc420b..848c7ec06976 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,6 +1,3 @@
-#define DRIVER_VERSION "v2.4"
-#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
-#define DRIVER_DESC "Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com"
 /*
    comedi/drivers/usbdux.c
    Copyright (C) 2003-2007 Bernd Porr, Bernd.Porr@f2s.com
@@ -101,8 +98,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #include "../comedidev.h"
 
-#define BOARDNAME "usbdux"
-
 /* timeout for the USB-transfer in ms*/
 #define BULK_TIMEOUT 1000
 
@@ -317,8 +312,6 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver usbdux_driver;	/* see below for initializer */
-
 /*
  * Stops the data acquision
  * It should be safe to call this function from any context
@@ -2299,6 +2292,231 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
+/* common part of attach and attach_usb */
+static int usbdux_attach_common(struct comedi_device *dev,
+				struct usbduxsub *udev,
+				void *aux_data, int aux_len)
+{
+	int ret;
+	struct comedi_subdevice *s = NULL;
+	int n_subdevs;
+
+	down(&udev->sem);
+	/* pointer back to the corresponding comedi device */
+	udev->comedidev = dev;
+
+	/* trying to upload the firmware into the chip */
+	if (aux_data)
+		firmwareUpload(udev, aux_data, aux_len);
+
+	dev->board_name = "usbdux";
+
+	/* set number of subdevices */
+	if (udev->high_speed) {
+		/* with pwm */
+		n_subdevs = 5;
+	} else {
+		/* without pwm */
+		n_subdevs = 4;
+	}
+
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	if (ret) {
+		up(&udev->sem);
+		return ret;
+	}
+
+	/* private structure is also simply the usb-structure */
+	dev->private = udev;
+
+	/* the first subdevice is the A/D converter */
+	s = dev->subdevices + SUBDEV_AD;
+	/* the URBs get the comedi subdevice */
+	/* which is responsible for reading */
+	/* this is the subdevice which reads data */
+	dev->read_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* analog input */
+	s->type = COMEDI_SUBD_AI;
+	/* readable and ref is to ground */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	/* 8 channels */
+	s->n_chan = 8;
+	/* length of the channellist */
+	s->len_chanlist = 8;
+	/* callback functions */
+	s->insn_read = usbdux_ai_insn_read;
+	s->do_cmdtest = usbdux_ai_cmdtest;
+	s->do_cmd = usbdux_ai_cmd;
+	s->cancel = usbdux_ai_cancel;
+	/* max value from the A/D converter (12bit) */
+	s->maxdata = 0xfff;
+	/* range table to convert to physical units */
+	s->range_table = (&range_usbdux_ai_range);
+
+	/* analog out */
+	s = dev->subdevices + SUBDEV_DA;
+	/* analog out */
+	s->type = COMEDI_SUBD_AO;
+	/* backward pointer */
+	dev->write_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* are writable */
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	/* 4 channels */
+	s->n_chan = 4;
+	/* length of the channellist */
+	s->len_chanlist = 4;
+	/* 12 bit resolution */
+	s->maxdata = 0x0fff;
+	/* bipolar range */
+	s->range_table = (&range_usbdux_ao_range);
+	/* callback */
+	s->do_cmdtest = usbdux_ao_cmdtest;
+	s->do_cmd = usbdux_ao_cmd;
+	s->cancel = usbdux_ao_cancel;
+	s->insn_read = usbdux_ao_insn_read;
+	s->insn_write = usbdux_ao_insn_write;
+
+	/* digital I/O */
+	s = dev->subdevices + SUBDEV_DIO;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 8;
+	s->maxdata = 1;
+	s->range_table = (&range_digital);
+	s->insn_bits = usbdux_dio_insn_bits;
+	s->insn_config = usbdux_dio_insn_config;
+	/* we don't use it */
+	s->private = NULL;
+
+	/* counter */
+	s = dev->subdevices + SUBDEV_COUNTER;
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 0xFFFF;
+	s->insn_read = usbdux_counter_read;
+	s->insn_write = usbdux_counter_write;
+	s->insn_config = usbdux_counter_config;
+
+	if (udev->high_speed) {
+		/* timer / pwm */
+		s = dev->subdevices + SUBDEV_PWM;
+		s->type = COMEDI_SUBD_PWM;
+		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan = 8;
+		/* this defines the max duty cycle resolution */
+		s->maxdata = udev->sizePwmBuf;
+		s->insn_write = usbdux_pwm_write;
+		s->insn_read = usbdux_pwm_read;
+		s->insn_config = usbdux_pwm_config;
+		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+	/* finally decide that it's attached */
+	udev->attached = 1;
+
+	up(&udev->sem);
+
+	dev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",
+		 dev->minor);
+
+	return 0;
+}
+
+/* is called when comedi-config is called */
+static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
+
+	dev->private = NULL;
+
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
+
+	down(&start_stop_sem);
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index < 0) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else
+		ret = usbdux_attach_common(dev, &usbduxsub[index],
+					   aux_data, aux_len);
+	up(&start_stop_sem);
+	return ret;
+}
+
+/* is called from comedi_usb_auto_config() */
+static int usbdux_attach_usb(struct comedi_device *dev,
+			     struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxsub *this_usbduxsub;
+
+	dev->private = NULL;
+
+	down(&start_stop_sem);
+	this_usbduxsub = usb_get_intfdata(uinterf);
+	if (!this_usbduxsub || !this_usbduxsub->probed) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach_usb failed, not connected\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else if (this_usbduxsub->attached) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach_usb failed, already attached\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else
+		ret = usbdux_attach_common(dev, this_usbduxsub, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
+}
+
+static void usbdux_detach(struct comedi_device *dev)
+{
+	struct usbduxsub *usb = dev->private;
+
+	if (usb) {
+		down(&usb->sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&usb->sem);
+	}
+}
+
+static struct comedi_driver usbdux_driver = {
+	.driver_name	= "usbdux",
+	.module		= THIS_MODULE,
+	.attach		= usbdux_attach,
+	.detach		= usbdux_detach,
+	.attach_usb	= usbdux_attach_usb,
+};
+
 static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 						     void *context)
 {
@@ -2328,9 +2546,8 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	release_firmware(fw);
 }
 
-/* allocate memory for the urbs and initialise them */
-static int usbduxsub_probe(struct usb_interface *uinterf,
-			   const struct usb_device_id *id)
+static int usbdux_usb_probe(struct usb_interface *uinterf,
+			    const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
@@ -2591,7 +2808,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	return 0;
 }
 
-static void usbduxsub_disconnect(struct usb_interface *intf)
+static void usbdux_usb_disconnect(struct usb_interface *intf)
 {
 	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
@@ -2614,249 +2831,22 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 	dev_dbg(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
-/* common part of attach and attach_usb */
-static int usbdux_attach_common(struct comedi_device *dev,
-				struct usbduxsub *udev,
-				void *aux_data, int aux_len)
-{
-	int ret;
-	struct comedi_subdevice *s = NULL;
-	int n_subdevs;
-
-	down(&udev->sem);
-	/* pointer back to the corresponding comedi device */
-	udev->comedidev = dev;
-
-	/* trying to upload the firmware into the chip */
-	if (aux_data)
-		firmwareUpload(udev, aux_data, aux_len);
-
-	dev->board_name = BOARDNAME;
-
-	/* set number of subdevices */
-	if (udev->high_speed) {
-		/* with pwm */
-		n_subdevs = 5;
-	} else {
-		/* without pwm */
-		n_subdevs = 4;
-	}
-
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
-	if (ret) {
-		up(&udev->sem);
-		return ret;
-	}
-
-	/* private structure is also simply the usb-structure */
-	dev->private = udev;
-
-	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
-	/* the URBs get the comedi subdevice */
-	/* which is responsible for reading */
-	/* this is the subdevice which reads data */
-	dev->read_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	/* 8 channels */
-	s->n_chan = 8;
-	/* length of the channellist */
-	s->len_chanlist = 8;
-	/* callback functions */
-	s->insn_read = usbdux_ai_insn_read;
-	s->do_cmdtest = usbdux_ai_cmdtest;
-	s->do_cmd = usbdux_ai_cmd;
-	s->cancel = usbdux_ai_cancel;
-	/* max value from the A/D converter (12bit) */
-	s->maxdata = 0xfff;
-	/* range table to convert to physical units */
-	s->range_table = (&range_usbdux_ai_range);
-
-	/* analog out */
-	s = dev->subdevices + SUBDEV_DA;
-	/* analog out */
-	s->type = COMEDI_SUBD_AO;
-	/* backward pointer */
-	dev->write_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* are writable */
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	/* 4 channels */
-	s->n_chan = 4;
-	/* length of the channellist */
-	s->len_chanlist = 4;
-	/* 12 bit resolution */
-	s->maxdata = 0x0fff;
-	/* bipolar range */
-	s->range_table = (&range_usbdux_ao_range);
-	/* callback */
-	s->do_cmdtest = usbdux_ao_cmdtest;
-	s->do_cmd = usbdux_ao_cmd;
-	s->cancel = usbdux_ao_cancel;
-	s->insn_read = usbdux_ao_insn_read;
-	s->insn_write = usbdux_ao_insn_write;
-
-	/* digital I/O */
-	s = dev->subdevices + SUBDEV_DIO;
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 8;
-	s->maxdata = 1;
-	s->range_table = (&range_digital);
-	s->insn_bits = usbdux_dio_insn_bits;
-	s->insn_config = usbdux_dio_insn_config;
-	/* we don't use it */
-	s->private = NULL;
-
-	/* counter */
-	s = dev->subdevices + SUBDEV_COUNTER;
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 0xFFFF;
-	s->insn_read = usbdux_counter_read;
-	s->insn_write = usbdux_counter_write;
-	s->insn_config = usbdux_counter_config;
-
-	if (udev->high_speed) {
-		/* timer / pwm */
-		s = dev->subdevices + SUBDEV_PWM;
-		s->type = COMEDI_SUBD_PWM;
-		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan = 8;
-		/* this defines the max duty cycle resolution */
-		s->maxdata = udev->sizePwmBuf;
-		s->insn_write = usbdux_pwm_write;
-		s->insn_read = usbdux_pwm_read;
-		s->insn_config = usbdux_pwm_config;
-		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
-	}
-	/* finally decide that it's attached */
-	udev->attached = 1;
-
-	up(&udev->sem);
-
-	dev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",
-		 dev->minor);
-
-	return 0;
-}
-
-/* is called when comedi-config is called */
-static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
-
-	if (index < 0) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n",
-		       dev->minor);
-		ret = -ENODEV;
-	} else
-		ret = usbdux_attach_common(dev, &usbduxsub[index],
-					   aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
-static int usbdux_attach_usb(struct comedi_device *dev,
-			     struct usb_interface *uinterf)
-{
-	int ret;
-	struct usbduxsub *this_usbduxsub;
-
-	dev->private = NULL;
-
-	down(&start_stop_sem);
-	this_usbduxsub = usb_get_intfdata(uinterf);
-	if (!this_usbduxsub || !this_usbduxsub->probed) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach_usb failed, not connected\n",
-		       dev->minor);
-		ret = -ENODEV;
-	} else if (this_usbduxsub->attached) {
-		printk(KERN_ERR
-		       "comedi%d: usbdux: error: attach_usb failed, already attached\n",
-		       dev->minor);
-		ret = -ENODEV;
-	} else
-		ret = usbdux_attach_common(dev, this_usbduxsub, NULL, 0);
-	up(&start_stop_sem);
-	return ret;
-}
-
-static void usbdux_detach(struct comedi_device *dev)
-{
-	struct usbduxsub *usb = dev->private;
-
-	if (usb) {
-		down(&usb->sem);
-		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
-		up(&usb->sem);
-	}
-}
-
-/* main driver struct */
-static struct comedi_driver usbdux_driver = {
-	.driver_name	= "usbdux",
-	.module		= THIS_MODULE,
-	.attach		= usbdux_attach,
-	.detach		= usbdux_detach,
-	.attach_usb	= usbdux_attach_usb,
-};
-
-/* Table with the USB-devices: just now only testing IDs */
-static const struct usb_device_id usbduxsub_table[] = {
-	{USB_DEVICE(0x13d8, 0x0001)},
-	{USB_DEVICE(0x13d8, 0x0002)},
-	{}			/* Terminating entry */
+static const struct usb_device_id usbdux_usb_table[] = {
+	{ USB_DEVICE(0x13d8, 0x0001) },
+	{ USB_DEVICE(0x13d8, 0x0002) },
+	{ }
 };
 
-MODULE_DEVICE_TABLE(usb, usbduxsub_table);
+MODULE_DEVICE_TABLE(usb, usbdux_usb_table);
 
 static struct usb_driver usbdux_usb_driver = {
-	.name		= BOARDNAME,
-	.probe		= usbduxsub_probe,
-	.disconnect	= usbduxsub_disconnect,
-	.id_table	= usbduxsub_table,
+	.name		= "usbdux",
+	.probe		= usbdux_usb_probe,
+	.disconnect	= usbdux_usb_disconnect,
+	.id_table	= usbdux_usb_table,
 };
 module_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);
 
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
+MODULE_DESCRIPTION("Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com");
 MODULE_LICENSE("GPL");

commit 42318c32f8c968d602d151ad81e567832b72b767
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:00:57 2012 -0700

    staging: comedi: usbdux: use module_comedi_usb_driver()
    
    Use the module_comedi_usb_driver helper macro to initialize this
    module. Rename the driver structs to follow the pattern of the
    other comedi driver types and add some whitespace to improve
    readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 83ee66965427..586936bc420b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -317,7 +317,7 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver driver_usbdux;	/* see below for initializer */
+static struct comedi_driver usbdux_driver;	/* see below for initializer */
 
 /*
  * Stops the data acquision
@@ -2323,7 +2323,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(uinterf, &driver_usbdux);
+	comedi_usb_auto_config(uinterf, &usbdux_driver);
  out:
 	release_firmware(fw);
 }
@@ -2832,12 +2832,12 @@ static void usbdux_detach(struct comedi_device *dev)
 }
 
 /* main driver struct */
-static struct comedi_driver driver_usbdux = {
-	.driver_name = "usbdux",
-	.module = THIS_MODULE,
-	.attach = usbdux_attach,
-	.detach = usbdux_detach,
-	.attach_usb = usbdux_attach_usb,
+static struct comedi_driver usbdux_driver = {
+	.driver_name	= "usbdux",
+	.module		= THIS_MODULE,
+	.attach		= usbdux_attach,
+	.detach		= usbdux_detach,
+	.attach_usb	= usbdux_attach_usb,
 };
 
 /* Table with the USB-devices: just now only testing IDs */
@@ -2849,35 +2849,13 @@ static const struct usb_device_id usbduxsub_table[] = {
 
 MODULE_DEVICE_TABLE(usb, usbduxsub_table);
 
-/* The usbduxsub-driver */
-static struct usb_driver usbduxsub_driver = {
-	.name = BOARDNAME,
-	.probe = usbduxsub_probe,
-	.disconnect = usbduxsub_disconnect,
-	.id_table = usbduxsub_table,
+static struct usb_driver usbdux_usb_driver = {
+	.name		= BOARDNAME,
+	.probe		= usbduxsub_probe,
+	.disconnect	= usbduxsub_disconnect,
+	.id_table	= usbduxsub_table,
 };
-
-/* Can't use the nice macro as I have also to initialise the USB */
-/* subsystem: */
-/* registering the usb-system _and_ the comedi-driver */
-static int __init init_usbdux(void)
-{
-	printk(KERN_INFO KBUILD_MODNAME ": "
-	       DRIVER_VERSION ":" DRIVER_DESC "\n");
-	usb_register(&usbduxsub_driver);
-	comedi_driver_register(&driver_usbdux);
-	return 0;
-}
-
-/* deregistering the comedi driver and the usb-subsystem */
-static void __exit exit_usbdux(void)
-{
-	comedi_driver_unregister(&driver_usbdux);
-	usb_deregister(&usbduxsub_driver);
-}
-
-module_init(init_usbdux);
-module_exit(exit_usbdux);
+module_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 3185e1cdfb29..83ee66965427 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1809,7 +1809,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 
 	data[1] = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
 	up(&this_usbduxsub->sem);
-	return 2;
+	return insn->n;
 }
 
 /* reads the 4 counters, only two are used just now */

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0386fd4a80ba..3185e1cdfb29 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1780,9 +1780,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	if (insn->n != 2)
-		return -EINVAL;
-
 	down(&this_usbduxsub->sem);
 
 	if (!(this_usbduxsub->probed)) {

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index a6cf13459c61..0386fd4a80ba 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2646,7 +2646,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	}
 
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
-	if (ret < 0) {
+	if (ret) {
 		up(&udev->sem);
 		return ret;
 	}

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 79df200bb6ee..a6cf13459c61 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2645,7 +2645,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 		n_subdevs = 4;
 	}
 
-	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
 		up(&udev->sem);

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 3819663b1cbe..79df200bb6ee 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2648,8 +2648,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
-		dev_err(&udev->interface->dev,
-			"comedi%d: error alloc space for subdev\n", dev->minor);
 		up(&udev->sem);
 		return ret;
 	}

commit fba1d0faf726b442ab8771d5e9fbaf5f5a4c624c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:27 2012 -0700

    staging: comedi: only set dev->n_subdevices when kcalloc succeedes
    
    It's possible for the kcalloc in comedi_alloc_subdevices to fail.
    Only set the dev->n_subdevices variable if the allocation is
    successful.
    
    Since the core sets dev->n_subdevices, remove all the places in the
    drivers where this variable was getting set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ca8b3e121ff0..3819663b1cbe 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2624,6 +2624,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 {
 	int ret;
 	struct comedi_subdevice *s = NULL;
+	int n_subdevs;
 
 	down(&udev->sem);
 	/* pointer back to the corresponding comedi device */
@@ -2638,14 +2639,14 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	/* set number of subdevices */
 	if (udev->high_speed) {
 		/* with pwm */
-		dev->n_subdevices = 5;
+		n_subdevs = 5;
 	} else {
 		/* without pwm */
-		dev->n_subdevices = 4;
+		n_subdevs = 4;
 	}
 
 	/* allocate space for the subdevices */
-	ret = comedi_alloc_subdevices(dev, dev->n_subdevices);
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: error alloc space for subdev\n", dev->minor);

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 13d9fd3efcfd..ca8b3e121ff0 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2645,7 +2645,7 @@ static int usbdux_attach_common(struct comedi_device *dev,
 	}
 
 	/* allocate space for the subdevices */
-	ret = alloc_subdevices(dev, dev->n_subdevices);
+	ret = comedi_alloc_subdevices(dev, dev->n_subdevices);
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: error alloc space for subdev\n", dev->minor);

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 3d300eff493f..13d9fd3efcfd 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2823,36 +2823,17 @@ static int usbdux_attach_usb(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbdux_detach(struct comedi_device *dev)
+static void usbdux_detach(struct comedi_device *dev)
 {
-	struct usbduxsub *usbduxsub_tmp;
+	struct usbduxsub *usb = dev->private;
 
-	if (!dev) {
-		printk(KERN_ERR
-		       "comedi?: usbdux: detach without dev variable...\n");
-		return -EFAULT;
-	}
-
-	usbduxsub_tmp = dev->private;
-	if (!usbduxsub_tmp) {
-		printk(KERN_ERR
-		       "comedi?: usbdux: detach without ptr to usbduxsub[]\n");
-		return -EFAULT;
+	if (usb) {
+		down(&usb->sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&usb->sem);
 	}
-
-	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi%d: detach usb device\n",
-		dev->minor);
-
-	down(&usbduxsub_tmp->sem);
-	/* Don't allow detach to free the private structure */
-	/* It's one entry of of usbduxsub[] */
-	dev->private = NULL;
-	usbduxsub_tmp->attached = 0;
-	usbduxsub_tmp->comedidev = NULL;
-	dev_dbg(&usbduxsub_tmp->interface->dev,
-		"comedi%d: detach: successfully removed\n", dev->minor);
-	up(&usbduxsub_tmp->sem);
-	return 0;
 }
 
 /* main driver struct */

commit b3f79f980a07fabe22d553fb75010d5d0a12c943
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Apr 2 12:00:59 2012 +0100

    staging: comedi: usbdux: remove an unnecessary dev_info()
    
    usbdux_attach_common() prints two messages via dev_info() that shows a
    device has been attached.  The first of these messages includes an index
    into a static array that the function determines by pointer subtraction,
    assuming the pointer passed to the function points to an element of the
    array.  Dan Carpenter pointed out that this was kind of ugly.  Since the
    dev_info() that prints the array index doesn't add anything useful
    (since no other messages print the array index and nothing else uses
    it), let's just get rid of it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c3f928f0ac5b..3d300eff493f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2623,7 +2623,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 				void *aux_data, int aux_len)
 {
 	int ret;
-	int index = (int)(udev - usbduxsub);
 	struct comedi_subdevice *s = NULL;
 
 	down(&udev->sem);
@@ -2654,9 +2653,6 @@ static int usbdux_attach_common(struct comedi_device *dev,
 		return ret;
 	}
 
-	dev_info(&udev->interface->dev,
-		 "comedi%d: usb-device %d is attached to comedi.\n",
-		 dev->minor, index);
 	/* private structure is also simply the usb-structure */
 	dev->private = udev;
 

commit 5a613d6460cdf311a2637aa29919ccb48bb402be
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:15:05 2012 +0100

    staging: comedi: usbdux: use attach_usb() hook
    
    Change the usbdux driver to use the new attach_usb() hook in struct
    comedi_driver to auto-configure probed USB devices after the firmware is
    loaded.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 781da446f3c4..c3f928f0ac5b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2617,46 +2617,22 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 	dev_dbg(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
-/* is called when comedi-config is called */
-static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+/* common part of attach and attach_usb */
+static int usbdux_attach_common(struct comedi_device *dev,
+				struct usbduxsub *udev,
+				void *aux_data, int aux_len)
 {
 	int ret;
-	int index;
-	int i;
-	struct usbduxsub *udev;
-
+	int index = (int)(udev - usbduxsub);
 	struct comedi_subdevice *s = NULL;
-	dev->private = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
 
-	if (index < 0) {
-		printk(KERN_ERR "comedi%d: usbdux: error: attach failed, no "
-		       "usbdux devs connected to the usb bus.\n", dev->minor);
-		up(&start_stop_sem);
-		return -ENODEV;
-	}
-
-	udev = &usbduxsub[index];
 	down(&udev->sem);
 	/* pointer back to the corresponding comedi device */
 	udev->comedidev = dev;
 
 	/* trying to upload the firmware into the chip */
-	if (comedi_aux_data(it->options, 0) &&
-	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		firmwareUpload(udev, comedi_aux_data(it->options, 0),
-			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
-	}
+	if (aux_data)
+		firmwareUpload(udev, aux_data, aux_len);
 
 	dev->board_name = BOARDNAME;
 
@@ -2675,7 +2651,6 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		dev_err(&udev->interface->dev,
 			"comedi%d: error alloc space for subdev\n", dev->minor);
 		up(&udev->sem);
-		up(&start_stop_sem);
 		return ret;
 	}
 
@@ -2778,14 +2753,80 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	up(&udev->sem);
 
-	up(&start_stop_sem);
-
 	dev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",
 		 dev->minor);
 
 	return 0;
 }
 
+/* is called when comedi-config is called */
+static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
+
+	dev->private = NULL;
+
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
+
+	down(&start_stop_sem);
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index < 0) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else
+		ret = usbdux_attach_common(dev, &usbduxsub[index],
+					   aux_data, aux_len);
+	up(&start_stop_sem);
+	return ret;
+}
+
+/* is called from comedi_usb_auto_config() */
+static int usbdux_attach_usb(struct comedi_device *dev,
+			     struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxsub *this_usbduxsub;
+
+	dev->private = NULL;
+
+	down(&start_stop_sem);
+	this_usbduxsub = usb_get_intfdata(uinterf);
+	if (!this_usbduxsub || !this_usbduxsub->probed) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach_usb failed, not connected\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else if (this_usbduxsub->attached) {
+		printk(KERN_ERR
+		       "comedi%d: usbdux: error: attach_usb failed, already attached\n",
+		       dev->minor);
+		ret = -ENODEV;
+	} else
+		ret = usbdux_attach_common(dev, this_usbduxsub, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
+}
+
 static int usbdux_detach(struct comedi_device *dev)
 {
 	struct usbduxsub *usbduxsub_tmp;
@@ -2824,6 +2865,7 @@ static struct comedi_driver driver_usbdux = {
 	.module = THIS_MODULE,
 	.attach = usbdux_attach,
 	.detach = usbdux_detach,
+	.attach_usb = usbdux_attach_usb,
 };
 
 /* Table with the USB-devices: just now only testing IDs */

commit d8b6ca0850c558f21989d468801ad1414b1372c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:59 2012 +0100

    staging: comedi: pass usb interface to comedi_usb_auto_config
    
    The comedi_usb_auto_config() and comedi_usb_auto_unconfig() functions
    currently take a 'struct usb_device *'.  It makes more sense to pass a
    'struct usb_interface *' to allow for composite USB devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1420fcce79c0..781da446f3c4 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2306,11 +2306,11 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 						     void *context)
 {
 	struct usbduxsub *usbduxsub_tmp = context;
-	struct usb_device *usbdev = usbduxsub_tmp->usbdev;
+	struct usb_interface *uinterf = usbduxsub_tmp->interface;
 	int ret;
 
 	if (fw == NULL) {
-		dev_err(&usbdev->dev,
+		dev_err(&uinterf->dev,
 			"Firmware complete handler without firmware!\n");
 		return;
 	}
@@ -2322,11 +2322,11 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
 
 	if (ret) {
-		dev_err(&usbdev->dev,
+		dev_err(&uinterf->dev,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(usbdev, &driver_usbdux);
+	comedi_usb_auto_config(uinterf, &driver_usbdux);
  out:
 	release_firmware(fw);
 }
@@ -2608,7 +2608,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 		dev_err(&intf->dev, "comedi_: BUG! called with wrong ptr!!!\n");
 		return;
 	}
-	comedi_usb_auto_unconfig(udev);
+	comedi_usb_auto_unconfig(intf);
 	down(&start_stop_sem);
 	down(&usbduxsub_tmp->sem);
 	tidy_up(usbduxsub_tmp);

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bf62e0dd6f69..1420fcce79c0 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -317,6 +317,8 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
+static struct comedi_driver driver_usbdux;	/* see below for initializer */
+
 /*
  * Stops the data acquision
  * It should be safe to call this function from any context
@@ -2324,7 +2326,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(usbdev, BOARDNAME);
+	comedi_usb_auto_config(usbdev, &driver_usbdux);
  out:
 	release_firmware(fw);
 }

commit 85678d5d27cb0ea1005316f51b1b062bf4609b66
Author: Dan Carpenter <error27@gmail.com>
Date:   Thu Jun 30 12:02:05 2011 +0300

    Staging: comedi: usbdux: release locks on error paths
    
    Smatch complains about a couple error paths where the semaphores
    were not released.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6637698e119a..bf62e0dd6f69 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1465,6 +1465,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
 			dev->minor);
+		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
 	if (!(this_usbduxsub->ao_cmd_running)) {
@@ -2671,6 +2672,7 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: error alloc space for subdev\n", dev->minor);
+		up(&udev->sem);
 		up(&start_stop_sem);
 		return ret;
 	}

commit c5274ab09747d0ef829f9b8f040756758e5de55c
Author: Greg Dietsche <Gregory.Dietsche@cuw.edu>
Date:   Mon Jun 13 13:11:47 2011 -0500

    staging: remove unnecessary code
    
    Compile tested.
    remove unnecessary code that matches this coccinelle pattern
            if (...)
                    return ret;
            return ret;
    
    Signed-off-by: Greg Dietsche <Gregory.Dietsche@cuw.edu>
    Acked-by: Franky Lin <frankyl@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1d09bfa2edf5..6637698e119a 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1935,11 +1935,8 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi %d: sending pwm off command to the usb device.\n",
 		dev->minor);
-	res = send_dux_commands(this_usbduxsub, SENDPWMOFF);
-	if (res < 0)
-		return res;
 
-	return res;
+	return send_dux_commands(this_usbduxsub, SENDPWMOFF);
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)

commit 8452c3ef79f9095eef0fa2978fc97afb13507254
Author: Weiping Pan() <panweiping3@gmail.com>
Date:   Mon Apr 11 18:15:31 2011 +0800

    staging: comedi: fix a typo
    
    replace tranmitted with transmitted.
    
    Signed-off-by: Weiping Pan() <panweiping3@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index e543e6c2b1bb..1d09bfa2edf5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1530,7 +1530,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
 		/*
-		 * in usb-2.0 only one conversion it tranmitted but with 8kHz/n
+		 * in usb-2.0 only one conversion it transmitted but with 8kHz/n
 		 */
 		cmd->convert_src &= TRIG_TIMER;
 	} else {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index be93c30e4b15..e543e6c2b1bb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -285,7 +285,7 @@ struct usbduxsub {
 	short int ao_cmd_running;
 	/* pwm is running */
 	short int pwm_cmd_running;
-	/* continous aquisition */
+	/* continous acquisition */
 	short int ai_continous;
 	short int ao_continous;
 	/* number of samples to acquire */
@@ -500,7 +500,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 
 	/* test, if we transmit only a fixed number of samples */
 	if (!(this_usbduxsub->ai_continous)) {
-		/* not continous, fixed number of samples */
+		/* not continuous, fixed number of samples */
 		this_usbduxsub->ai_sample_count--;
 		/* all samples received? */
 		if (this_usbduxsub->ai_sample_count < 0) {
@@ -653,7 +653,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		/* timer zero */
 		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
-		/* handle non continous aquisition */
+		/* handle non continous acquisition */
 		if (!(this_usbduxsub->ao_continous)) {
 			/* fixed number of samples */
 			this_usbduxsub->ao_sample_count--;
@@ -957,7 +957,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 	cmd->convert_src &= TRIG_NOW;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -1222,7 +1222,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
 	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
@@ -1284,7 +1284,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		this_usbduxsub->ai_sample_count = cmd->stop_arg;
 		this_usbduxsub->ai_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		this_usbduxsub->ai_continous = 1;
 		this_usbduxsub->ai_sample_count = 0;
 	}
@@ -1515,7 +1515,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	/* just now we scan also in the high speed mode every frame */
 	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* start immidiately a new scan */
+		/* start immediately a new scan */
 		/* the sampling rate is set by the coversion rate */
 		cmd->scan_begin_src &= TRIG_FOLLOW;
 	} else {
@@ -1525,7 +1525,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
@@ -1645,7 +1645,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: %s\n", dev->minor, __func__);
 
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
@@ -1694,7 +1694,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continous */
+		/* not continuous */
 		/* counter */
 		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
@@ -1708,7 +1708,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 		this_usbduxsub->ao_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		this_usbduxsub->ao_continous = 1;
 		this_usbduxsub->ao_sample_count = 0;
 	}

commit e4e1f289be88a75dc8b63d50ade1f9a2e6168021
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:28:57 2011 -0500

    staging: comedi: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 696ee045e25f..be93c30e4b15 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2265,12 +2265,8 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 			usbduxsub_unlink_OutURBs(usbduxsub_tmp);
 		}
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
-				kfree(usbduxsub_tmp->
-				      urbOut[i]->transfer_buffer);
-				usbduxsub_tmp->urbOut[i]->transfer_buffer =
-				    NULL;
-			}
+			kfree(usbduxsub_tmp->urbOut[i]->transfer_buffer);
+			usbduxsub_tmp->urbOut[i]->transfer_buffer = NULL;
 			if (usbduxsub_tmp->urbOut[i]) {
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
 				usb_free_urb(usbduxsub_tmp->urbOut[i]);

commit ea3398a1ae54cd3403f3cc0f6aa498c7452c681a
Merge: 03fa6fc5a682 cf7d7e5a1980
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 7 10:47:56 2010 -0800

    Staging: Merge 2.6.37-rc5 into staging-next
    
    This was done to handle a number of conflicts in the batman-adv
    and winbond drivers properly.  It also now allows us to fix up the sysfs
    attributes properly that were not in the .37 release due to them being
    only in this tree at the time.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 61838261edaf621d1e8ee4ea9d7c052f7d783ca4
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Sat Nov 13 19:46:50 2010 +0100

    staging: comedi: fix memory leak
    
    Instead of freeing outBuffer, inBuffer gets freed twice.
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1f177a67ff11..de784ff08caa 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2295,8 +2295,8 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->inBuffer = NULL;
 	kfree(usbduxsub_tmp->insnBuffer);
 	usbduxsub_tmp->insnBuffer = NULL;
-	kfree(usbduxsub_tmp->inBuffer);
-	usbduxsub_tmp->inBuffer = NULL;
+	kfree(usbduxsub_tmp->outBuffer);
+	usbduxsub_tmp->outBuffer = NULL;
 	kfree(usbduxsub_tmp->dac_commands);
 	usbduxsub_tmp->dac_commands = NULL;
 	kfree(usbduxsub_tmp->dux_commands);

commit f96c377ead5ed308f0cf18b9156f86fdf207a288
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Sat Nov 13 19:43:27 2010 +0100

    staging: comedi: fix typo in error message
    
    Fix typo in error message of dux commands allocation.
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 1f177a67ff11..aca4d140193b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2398,7 +2398,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!usbduxsub[index].dux_commands) {
 		dev_err(dev, "comedi_: usbdux: "
-			"error alloc space for dac commands\n");
+			"error alloc space for dux commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;

commit 45f4d0243525b6bc747c946937ced437b135a84d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 30 11:06:57 2010 +0200

    staging: Final semaphore cleanup
    
    Fixup the last remaining users of DECLARE_MUTEX and init_MUTEX.
    
    Scripted conversion, resulting code is binary equivalent.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    LKML-Reference: <20100907125057.278833764@linutronix.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 6131e2dd0591..1f177a67ff11 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -315,7 +315,7 @@ struct usbduxsub {
  */
 static struct usbduxsub usbduxsub[NUMUSBDUX];
 
-static DECLARE_MUTEX(start_stop_sem);
+static DEFINE_SEMAPHORE(start_stop_sem);
 
 /*
  * Stops the data acquision
@@ -2367,7 +2367,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	dev_dbg(dev, "comedi_: usbdux: "
 		"usbduxsub[%d] is ready to connect to comedi.\n", index);
 
-	init_MUTEX(&(usbduxsub[index].sem));
+	sema_init(&(usbduxsub[index].sem), 1);
 	/* save a pointer to the usb device */
 	usbduxsub[index].usbdev = udev;
 

commit 2503a26554c7e73c544fc97f47c1d41faa88bd07
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Sep 12 22:56:35 2010 +0400

    staging: comedi: fix signess bug
    
    ai_count and ao_counter are unsigned, check for < 0 doesn't make sense.
    Cast them to int.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 4b320b1ff823..6131e2dd0591 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -649,7 +649,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 
 	/* normal operation: executing a command in this subdevice */
 	this_usbduxsub->ao_counter--;
-	if (this_usbduxsub->ao_counter <= 0) {
+	if ((int)this_usbduxsub->ao_counter <= 0) {
 		/* timer zero */
 		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 

commit f69b0d6451679f1466381a46ac7ab671a7b5668c
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Mon Jul 12 17:15:46 2010 +0200

    Staging: fix typos concerning "address"
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7b8a2da344b8..4b320b1ff823 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -111,7 +111,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #define VENDOR_DIR_IN  0xC0
 #define VENDOR_DIR_OUT 0x40
 
-/* internal adresses of the 8051 processor */
+/* internal addresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
 
 /*

commit 37523e84cbf1d82fcc8237ed10818d37b951144e
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 11 12:17:03 2010 +0200

    staging/trivial: fix typos concerning "initiali[zs]e"
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 27b4cb2e2ec2..7b8a2da344b8 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2085,7 +2085,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	if (ret < 0)
 		return ret;
 
-	/* initalise the buffer */
+	/* initialise the buffer */
 	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
 		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
 

commit c60e55f30a4dac15db51b398c3bd94e4cfbf743a
Author: Julia Lawall <julia@diku.dk>
Date:   Thu May 27 14:37:19 2010 +0200

    Staging: Eliminate a NULL pointer dereference
    
    Eliminate a NULL or near NULL pointer dereference.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    expression E,E1;
    identifier f;
    statement S1,S2,S3;
    @@
    
    if ((E == NULL && ...) || ...)
    {
      ... when != if (...) S1 else S2
          when != E = E1
    * E->f
      ... when any
      return ...;
    }
    else S3
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 86f035d00675..27b4cb2e2ec2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -351,8 +351,7 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 	int ret = 0;
 
 	if (!this_usbduxsub) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
 		return -EFAULT;
 	}
 	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");

commit 94002c07ff0e207a883519ccc35c0b5390b29331
Author: Julia Lawall <julia@diku.dk>
Date:   Sat May 15 23:21:43 2010 +0200

    Staging: Use kmemdup
    
    Use kmemdup when some other buffer is immediately copied into the
    allocated region.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression from,to,size,flag;
    statement S;
    @@
    
    -  to = \(kmalloc\|kzalloc\)(size,flag);
    +  to = kmemdup(from,size,flag);
       if (to==NULL || ...) S
    -  memcpy(to, from, size);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index df71515c7a30..86f035d00675 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -840,13 +840,12 @@ static int firmwareUpload(struct usbduxsub *usbduxsub,
 	}
 
 	/* we generate a local buffer for the firmware */
-	fwBuf = kzalloc(sizeFirmware, GFP_KERNEL);
+	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
 	if (!fwBuf) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {

commit 94c1f90bb0bac8c2b75569a247b89145022c4c24
Author: Morgan Gatti <morgan.gatti@gmail.com>
Date:   Tue May 11 23:55:53 2010 +0200

    Staging: comedi: Fix bug and coding style issue in usbdux.c
    
    This is a patch to the usbdux.c file that resolve 2 errors in coding and
    fix the warning about lengt of code lines
    
    Signed-off-by: Morgan Gatti <morgan.gatti@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 8942ae45708d..df71515c7a30 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -793,7 +793,7 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 }
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,
-			    uint8_t * local_transfer_buffer,
+			    uint8_t *local_transfer_buffer,
 			    unsigned int startAddr, unsigned int len)
 {
 	int errcode;
@@ -825,7 +825,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 * firmwareBinary, int sizeFirmware)
+			  const u8 *firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;
@@ -835,7 +835,7 @@ static int firmwareUpload(struct usbduxsub *usbduxsub,
 
 	if (sizeFirmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
-			"comedi_: usbdux firmware binary it too large for FX2.\n");
+			"usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
 
@@ -1264,8 +1264,8 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			    (this_usbduxsub->ai_interval) * 2;
 		}
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
-								  (this_usbduxsub->
-								   ai_interval));
+							  (this_usbduxsub->
+							   ai_interval));
 	} else {
 		/* interval always 1ms */
 		this_usbduxsub->ai_interval = 1;

commit 02c7b237f6a01f580319187d4bdbf712b27a5460
Author: Alessio Igor Bogani <abogani@texware.it>
Date:   Fri Feb 26 08:44:27 2010 +0100

    Staging: Cleanup useless headers
    
    BKL isn't anymore present into these files thus it is no necessary still include smp_lock.h.
    
    Signed-off-by: Alessio Igor Bogani <abogani@texware.it>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index bcf46dab2052..8942ae45708d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -95,7 +95,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/usb.h>
-#include <linux/smp_lock.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
 #include <linux/firmware.h>

commit 9d220c6b54f3d0b141846321814ec1c4e4fbdc67
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 12 15:57:58 2010 +0100

    staging: fix typos "aquire" -> "acquire"
    
    This patch was generated by
    
        git grep -E -i -l '[Aa]quire' drivers/staging | xargs -r perl -p -i -e 's/([Aa])quire/$1cquire/'
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0c854a6f1ca6..bcf46dab2052 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -289,7 +289,7 @@ struct usbduxsub {
 	/* continous aquisition */
 	short int ai_continous;
 	short int ao_continous;
-	/* number of samples to aquire */
+	/* number of samples to acquire */
 	int ai_sample_count;
 	int ao_sample_count;
 	/* time between samples in units of the timer */

commit a457732b836b970c82c7ba35b4cfc938c9c543f9
Author: Nmeth Mrton <nm127@freemail.hu>
Date:   Sun Jan 10 00:18:34 2010 +0100

    staging: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Nmeth Mrton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 9a1b559c4b0d..0c854a6f1ca6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2833,7 +2833,7 @@ static struct comedi_driver driver_usbdux = {
 };
 
 /* Table with the USB-devices: just now only testing IDs */
-static struct usb_device_id usbduxsub_table[] = {
+static const struct usb_device_id usbduxsub_table[] = {
 	{USB_DEVICE(0x13d8, 0x0001)},
 	{USB_DEVICE(0x13d8, 0x0002)},
 	{}			/* Terminating entry */

commit d4c3a56587af3edbe5f618b20e800e9f9fde13cb
Author: Bernd Porr <berndporr@f2s.com>
Date:   Fri Nov 27 12:00:53 2009 +0000

    Staging: comedi: usbdux.c: fix locking up of the driver when the comedi ringbuffer runs empty
    
    Jan-Matthias Braun spotted a bug which locks up the driver when the
    comedi ring buffer runs empty and provided a patch. The driver would
    still send the data to comedi but the reader won't wake up any more.
    What's required is setting the flag COMEDI_CB_BLOCK after new data has
    arrived which wakes up the reader and therefore the read() command.
    
    Signed-off-by: Bernd Porr <berndporr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 06c020466298..9a1b559c4b0d 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,4 +1,4 @@
-#define DRIVER_VERSION "v2.3"
+#define DRIVER_VERSION "v2.4"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com"
 /*
@@ -81,6 +81,8 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  * 2.1:  changed PWM API
  * 2.2:  added firmware kernel request to fix an udev problem
  * 2.3:  corrected a bug in bulk timeouts which were far too short
+ * 2.4:  fixed a bug which causes the driver to hang when it ran out of data.
+ *       Thanks to Jan-Matthias Braun and Ian to spot the bug and fix it.
  *
  */
 
@@ -532,6 +534,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		}
 	}
 	/* tell comedi that data is there */
+	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 

commit 0e2f7b837600979d5b6f174a6ff695b85942e985
Merge: f58df54a5445 032fec3169b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 11 15:25:56 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging-2.6: (235 commits)
      Staging: IIO: add selection of IIO_SW_RING to LIS3L02DQ as needed
      Staging: IIO: Add tsl2560-2 support to tsl2563 driver.
      Staging: IIO: Remove tsl2561 driver. Support merged with tsl2563.
      Staging: wlags49_h2: fix up signal levels
      + drivers-staging-wlags49_h2-remove-cvs-metadata.patch added to -mm tree
      Staging: samsung-laptop: add TODO file
      Staging: samsung-laptop: remove old kernel code
      Staging: add Samsung Laptop driver
      staging: batman-adv meshing protocol
      Staging: rtl8192u: depends on USB
      Staging: rtl8192u: remove dead code
      Staging: rtl8192u: remove bad whitespaces
      Staging: rtl8192u: make it compile
      Staging: Added Realtek rtl8192u driver to staging
      Staging: dream: add gpio and pmem support
      Staging: dream: add TODO file
      Staging: android: delete android drivers
      Staging: et131x: clean up the avail fields in the rx registers
      Staging: et131x: Clean up number fields
      Staging: et131x: kill RX_DMA_MAX_PKT_TIME
      ...

commit ea25371a78c33e276527361d3ab19393d558b2fd
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Mon Nov 16 01:12:02 2009 +0000

    Staging: comedi: fix usbdux timeout bug
    
    I've fixed a bug in the USBDUX driver which caused timeouts while
    sending commands to the boards. This was mainly because of one bulk
    transfer which had a timeout of 1ms (!). I've now set all timeouts to
    1000ms.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cec028e0db13..f2dab1a4d41b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,4 +1,4 @@
-#define DRIVER_VERSION "v2.2"
+#define DRIVER_VERSION "v2.3"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com"
 /*
@@ -80,6 +80,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  * 2.0:  PWM seems to be stable and is not interfering with the other functions
  * 2.1:  changed PWM API
  * 2.2:  added firmware kernel request to fix an udev problem
+ * 2.3:  corrected a bug in bulk timeouts which were far too short
  *
  */
 
@@ -101,8 +102,8 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #define BOARDNAME "usbdux"
 
-/* timeout for the USB-transfer */
-#define EZTIMEOUT 30
+/* timeout for the USB-transfer in ms*/
+#define BULK_TIMEOUT 1000
 
 /* constants for "firmware" upload and download */
 #define USBDUXSUB_FIRMWARE 0xA0
@@ -750,7 +751,7 @@ static int usbduxsub_start(struct usbduxsub *usbduxsub)
 				  /* Length */
 				  1,
 				  /* Timeout */
-				  EZTIMEOUT);
+				  BULK_TIMEOUT);
 	if (errcode < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (start)\n");
@@ -780,7 +781,7 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 				  /* Length */
 				  1,
 				  /* Timeout */
-				  EZTIMEOUT);
+				  BULK_TIMEOUT);
 	if (errcode < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (stop)\n");
@@ -810,7 +811,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 				  /* length */
 				  len,
 				  /* timeout */
-				  EZTIMEOUT);
+				  BULK_TIMEOUT);
 	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
 	if (errcode < 0) {
 		dev_err(&usbduxsub->interface->dev, "comedi_: upload failed\n");
@@ -1110,7 +1111,7 @@ static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 			      usb_sndbulkpipe(this_usbduxsub->usbdev,
 					      COMMAND_OUT_EP),
 			      this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
-			      &nsent, 10);
+			      &nsent, BULK_TIMEOUT);
 	if (result < 0)
 		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 			"could not transmit dux_command to the usb-device, "
@@ -1130,7 +1131,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
 						      COMMAND_IN_EP),
 				      this_usbduxsub->insnBuffer, SIZEINSNBUF,
-				      &nrec, 1);
+				      &nrec, BULK_TIMEOUT);
 		if (result < 0) {
 			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 				"insn: USB error %d while receiving DUX command"

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cca4e869f0ec..cec028e0db13 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -979,7 +979,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 
 	/*
 	 * step 2: make sure trigger sources are unique and mutually compatible
-	 * note that mutual compatiblity is not an issue here
+	 * note that mutual compatibility is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 	    cmd->scan_begin_src != TRIG_EXT &&
@@ -1557,7 +1557,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 	/*
 	 * step 2: make sure trigger sources are unique and mutually compatible
-	 * note that mutual compatiblity is not an issue here
+	 * note that mutual compatibility is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 	    cmd->scan_begin_src != TRIG_EXT &&

commit 9ebfbd45f9d4ee9cd72529cf99e5f300eb398e67
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 29 12:36:02 2009 +0100

    firmware_class: make request_firmware_nowait more useful
    
    Unfortunately, one cannot hold on to the struct firmware
    that request_firmware_nowait() hands off, which is needed
    in some cases. Allow this by requiring the callback to
    free it (via release_firmware).
    
    Additionally, give it a gfp_t parameter -- all the current
    users call it from a GFP_KERNEL context so the GFP_ATOMIC
    isn't necessary. This also marks an API break which is
    useful in a sense, although that is obviously not the
    primary purpose of this change.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: David Woodhouse <David.Woodhouse@intel.com>
    Cc: Pavel Roskin <proski@gnu.org>
    Cc: Abhay Salunke <abhay_salunke@dell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index cca4e869f0ec..dfcd12bec86b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2327,9 +2327,11 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	if (ret) {
 		dev_err(&usbdev->dev,
 			"Could not upload firmware (err=%d)\n", ret);
-		return;
+		goto out;
 	}
 	comedi_usb_auto_config(usbdev, BOARDNAME);
+ out:
+	release_firmware(fw);
 }
 
 /* allocate memory for the urbs and initialise them */
@@ -2580,6 +2582,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 				      FW_ACTION_HOTPLUG,
 				      "usbdux_firmware.bin",
 				      &udev->dev,
+				      GFP_KERNEL,
 				      usbduxsub + index,
 				      usbdux_firmware_request_complete_handler);
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 171a6f2ff74f..cca4e869f0ec 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -215,17 +215,23 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /**************************************************/
 /* comedi constants */
 static const struct comedi_lrange range_usbdux_ai_range = { 4, {
-			BIP_RANGE(4.096),
-			BIP_RANGE(4.096 / 2),
-			UNI_RANGE(4.096),
-			UNI_RANGE(4.096 / 2)
-	}
+								BIP_RANGE
+								(4.096),
+								BIP_RANGE(4.096
+									  / 2),
+								UNI_RANGE
+								(4.096),
+								UNI_RANGE(4.096
+									  / 2)
+								}
 };
 
 static const struct comedi_lrange range_usbdux_ao_range = { 2, {
-			BIP_RANGE(4.096),
-			UNI_RANGE(4.096),
-	}
+								BIP_RANGE
+								(4.096),
+								UNI_RANGE
+								(4.096),
+								}
 };
 
 /*
@@ -363,7 +369,8 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbdux_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub;
 	int res = 0;
@@ -407,7 +414,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	case 0:
 		/* copy the result in the transfer buffer */
 		memcpy(this_usbduxsub->inBuffer,
-			urb->transfer_buffer, SIZEINBUF);
+		       urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
 		/* error in the ISOchronous data */
@@ -510,13 +517,12 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		/* transfer data */
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
 			err = comedi_buf_put
-				(s->async,
-				 le16_to_cpu(this_usbduxsub->
-					     inBuffer[i]) ^ 0x800);
+			    (s->async,
+			     le16_to_cpu(this_usbduxsub->inBuffer[i]) ^ 0x800);
 		} else {
 			err = comedi_buf_put
-				(s->async,
-				 le16_to_cpu(this_usbduxsub->inBuffer[i]));
+			    (s->async,
+			     le16_to_cpu(this_usbduxsub->inBuffer[i]));
 		}
 		if (unlikely(err == 0)) {
 			/* buffer overflow */
@@ -566,7 +572,8 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 }
 
 /* force unlink, is called by comedi */
-static int usbdux_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -659,7 +666,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		}
 		/* transmit data to the USB bus */
 		((uint8_t *) (urb->transfer_buffer))[0] =
-			s->async->cmd.chanlist_len;
+		    s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 			short temp;
 			if (i >= NUMOUTCHANNELS)
@@ -667,7 +674,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 
 			/* pointer to the DA */
 			datap =
-			       (&(((int8_t *)urb->transfer_buffer)[i * 3 + 1]));
+			    (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
 			/* get the data from comedi */
 			ret = comedi_buf_get(s->async, &temp);
 			datap[0] = temp;
@@ -783,32 +790,30 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 }
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,
-			    uint8_t *local_transfer_buffer,
+			    uint8_t * local_transfer_buffer,
 			    unsigned int startAddr, unsigned int len)
 {
 	int errcode;
 
 	errcode = usb_control_msg(usbduxsub->usbdev,
-			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			/* brequest, firmware */
-			USBDUXSUB_FIRMWARE,
-			/* bmRequestType */
-			VENDOR_DIR_OUT,
-			/* value */
-			startAddr,
-			/* index */
-			0x0000,
-			/* our local safe buffer */
-			local_transfer_buffer,
-			/* length */
-			len,
-			/* timeout */
-			EZTIMEOUT);
-	dev_dbg(&usbduxsub->interface->dev,
-		"comedi_: result=%d\n", errcode);
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* brequest, firmware */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* value */
+				  startAddr,
+				  /* index */
+				  0x0000,
+				  /* our local safe buffer */
+				  local_transfer_buffer,
+				  /* length */
+				  len,
+				  /* timeout */
+				  EZTIMEOUT);
+	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
 	if (errcode < 0) {
-		dev_err(&usbduxsub->interface->dev,
-		"comedi_: upload failed\n");
+		dev_err(&usbduxsub->interface->dev, "comedi_: upload failed\n");
 		return errcode;
 	}
 	return 0;
@@ -817,8 +822,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 #define FIRMWARE_MAX_LEN 0x2000
 
 static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 *firmwareBinary,
-			  int sizeFirmware)
+			  const u8 * firmwareBinary, int sizeFirmware)
 {
 	int ret;
 	uint8_t *fwBuf;
@@ -826,7 +830,7 @@ static int firmwareUpload(struct usbduxsub *usbduxsub,
 	if (!firmwareBinary)
 		return 0;
 
-	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+	if (sizeFirmware > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: usbdux firmware binary it too large for FX2.\n");
 		return -ENOMEM;
@@ -839,7 +843,7 @@ static int firmwareUpload(struct usbduxsub *usbduxsub,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
-	memcpy(fwBuf,firmwareBinary,sizeFirmware);
+	memcpy(fwBuf, firmwareBinary, sizeFirmware);
 
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {
@@ -925,8 +929,8 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbdux_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
@@ -978,8 +982,8 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	 * note that mutual compatiblity is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_TIMER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1021,8 +1025,8 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
 			tmpTimer =
-				((unsigned int)(cmd->scan_begin_arg / 125000)) *
-				125000;
+			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
+			    125000;
 			if (cmd->scan_begin_arg != tmpTimer) {
 				cmd->scan_begin_arg = tmpTimer;
 				err++;
@@ -1038,7 +1042,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 			 * calc the real sampling rate with the rounding errors
 			 */
 			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
-					1000000)) * 1000000;
+						   1000000)) * 1000000;
 			if (cmd->scan_begin_arg != tmpTimer) {
 				cmd->scan_begin_arg = tmpTimer;
 				err++;
@@ -1097,7 +1101,7 @@ static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 	this_usbduxsub->dux_commands[0] = cmd_type;
 #ifdef NOISY_DUX_DEBUGBUG
 	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
-		this_usbduxsub->comedidev->minor);
+	       this_usbduxsub->comedidev->minor);
 	for (result = 0; result < SIZEOFDUXBUFFER; result++)
 		printk(" %02x", this_usbduxsub->dux_commands[result]);
 	printk("\n");
@@ -1145,8 +1149,8 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int trignum)
+static int usbdux_ai_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1231,7 +1235,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			break;
 		}
 		this_usbduxsub->dux_commands[i + 2] =
-			create_adc_command(chan, range);
+		    create_adc_command(chan, range);
 	}
 
 	dev_dbg(&this_usbduxsub->interface->dev,
@@ -1254,10 +1258,11 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* find a power of 2 for the interval */
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
-				(this_usbduxsub->ai_interval) * 2;
+			    (this_usbduxsub->ai_interval) * 2;
 		}
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
-			(this_usbduxsub->ai_interval));
+								  (this_usbduxsub->
+								   ai_interval));
 	} else {
 		/* interval always 1ms */
 		this_usbduxsub->ai_interval = 1;
@@ -1305,7 +1310,8 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1366,7 +1372,8 @@ static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 /************************************/
 /* analog out */
 
-static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1388,7 +1395,8 @@ static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevic
 	return i;
 }
 
-static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
@@ -1423,7 +1431,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 		this_usbduxsub->dux_commands[1] = 1;
 		/* one 16 bit value */
 		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
-			cpu_to_le16(data[i]);
+		    cpu_to_le16(data[i]);
 		this_usbduxsub->outBuffer[chan] = data[i];
 		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
@@ -1438,8 +1446,8 @@ static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 	return i;
 }
 
-static int usbdux_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int trignum)
+static int usbdux_ao_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1479,8 +1487,8 @@ static int usbdux_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbdux_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1552,8 +1560,8 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	 * note that mutual compatiblity is not an issue here
 	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_TIMER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1690,7 +1698,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
 			this_usbduxsub->ao_sample_count =
-				(cmd->stop_arg) * (cmd->scan_end_arg);
+			    (cmd->stop_arg) * (cmd->scan_end_arg);
 		} else {
 			/* there's no scan as the scan has been */
 			/* perf inside the FX2 */
@@ -1726,7 +1734,8 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1745,8 +1754,7 @@ static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subde
 		break;
 	case INSN_CONFIG_DIO_QUERY:
 		data[1] =
-			(s->
-			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		break;
 	default:
 		return -EINVAL;
@@ -1757,7 +1765,8 @@ static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subde
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 
@@ -1767,7 +1776,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-
 	if (insn->n != 2)
 		return -EINVAL;
 
@@ -1804,7 +1812,8 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 }
 
 /* reads the 4 counters, only two are used just now */
-static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1838,7 +1847,8 @@ static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevic
 	return 1;
 }
 
-static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1868,7 +1878,8 @@ static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevi
 	return 1;
 }
 
-static int usbdux_counter_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_counter_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
@@ -1905,14 +1916,14 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 	if (do_unlink)
 		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
 
-
 	this_usbduxsub->pwm_cmd_running = 0;
 
 	return ret;
 }
 
 /* force unlink - is called by comedi */
-static int usbdux_pwm_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_pwm_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -2010,10 +2021,11 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(usbduxsub->urbPwm,
-		usbduxsub->usbdev,
-		usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
-		usbduxsub->urbPwm->transfer_buffer,
-		usbduxsub->sizePwmBuf, usbduxsub_pwm_irq, usbduxsub->comedidev);
+			  usbduxsub->usbdev,
+			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
+			  usbduxsub->urbPwm->transfer_buffer,
+			  usbduxsub->sizePwmBuf, usbduxsub_pwm_irq,
+			  usbduxsub->comedidev);
 
 	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
 	if (errFlag) {
@@ -2025,8 +2037,8 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_pwm_period(struct comedi_device *dev, struct comedi_subdevice *s,
-			     unsigned int period)
+static int usbdux_pwm_period(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int period)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int fx2delay = 255;
@@ -2037,11 +2049,11 @@ static int usbdux_pwm_period(struct comedi_device *dev, struct comedi_subdevice
 			dev->minor);
 		return -EAGAIN;
 	} else {
-		fx2delay = period / ((int)(6*512*(1.0/0.033))) - 6;
+		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
 		if (fx2delay > 255) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi%d: period %d for pwm is too low.\n",
-			       dev->minor, period);
+				dev->minor, period);
 			return -EAGAIN;
 		}
 	}
@@ -2053,7 +2065,8 @@ static int usbdux_pwm_period(struct comedi_device *dev, struct comedi_subdevice
 }
 
 /* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbdux_pwm_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	int ret, i;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2085,8 +2098,9 @@ static int usbdux_pwm_start(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 /* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(struct comedi_device *dev, struct comedi_subdevice *s,
-			      int channel, unsigned int value, unsigned int sign)
+static int usbdux_pwm_pattern(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int channel,
+			      unsigned int value, unsigned int sign)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int i, szbuf;
@@ -2126,7 +2140,8 @@ static int usbdux_pwm_pattern(struct comedi_device *dev, struct comedi_subdevice
 	return 1;
 }
 
-static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_pwm_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2147,19 +2162,20 @@ static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *
 	 * normal operation
 	 * relay sign 0 by default
 	 */
-	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
-				  data[0], 0);
+	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
 }
 
-static int usbdux_pwm_read(struct comedi_device *x1, struct comedi_subdevice *x2,
-			   struct comedi_insn *x3, unsigned int *x4)
+static int usbdux_pwm_read(struct comedi_device *x1,
+			   struct comedi_subdevice *x2, struct comedi_insn *x3,
+			   unsigned int *x4)
 {
 	/* not needed */
 	return -EINVAL;
 };
 
 /* switches on/off PWM */
-static int usbdux_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
+static int usbdux_pwm_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2249,10 +2265,10 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 		}
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
-				kfree(usbduxsub_tmp->urbOut[i]->
-					transfer_buffer);
+				kfree(usbduxsub_tmp->
+				      urbOut[i]->transfer_buffer);
 				usbduxsub_tmp->urbOut[i]->transfer_buffer =
-					NULL;
+				    NULL;
 			}
 			if (usbduxsub_tmp->urbOut[i]) {
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
@@ -2310,8 +2326,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 
 	if (ret) {
 		dev_err(&usbdev->dev,
-			"Could not upload firmware (err=%d)\n",
-			ret);
+			"Could not upload firmware (err=%d)\n", ret);
 		return;
 	}
 	comedi_usb_auto_config(usbdev, BOARDNAME);
@@ -2365,7 +2380,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 
 	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
-		(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
 
 	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
@@ -2429,8 +2444,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
 
 	usbduxsub[index].urbIn =
-		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
-		GFP_KERNEL);
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
+		    GFP_KERNEL);
 	if (!(usbduxsub[index].urbIn)) {
 		dev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
@@ -2452,10 +2467,10 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbIn[i]->context = NULL;
 		usbduxsub[index].urbIn[i]->pipe =
-			usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
+		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
 		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
 		usbduxsub[index].urbIn[i]->transfer_buffer =
-			kzalloc(SIZEINBUF, GFP_KERNEL);
+		    kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb.\n", index);
@@ -2477,8 +2492,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 
 	usbduxsub[index].urbOut =
-		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
-		GFP_KERNEL);
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
+		    GFP_KERNEL);
 	if (!(usbduxsub[index].urbOut)) {
 		dev_err(dev, "comedi_: usbdux: "
 			"Could not alloc. urbOut array\n");
@@ -2501,10 +2516,10 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbOut[i]->context = NULL;
 		usbduxsub[index].urbOut[i]->pipe =
-			usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
+		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
 		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
 		usbduxsub[index].urbOut[i]->transfer_buffer =
-			kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb.\n", index);
@@ -2517,7 +2532,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbOut[i]->transfer_buffer_length = SIZEOUTBUF;
 		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
 		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
-			SIZEOUTBUF;
+		    SIZEOUTBUF;
 		if (usbduxsub[index].high_speed) {
 			/* uframes */
 			usbduxsub[index].urbOut[i]->interval = 8;
@@ -2540,7 +2555,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			return -ENOMEM;
 		}
 		usbduxsub[index].urbPwm->transfer_buffer =
-			kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
+		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
 		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"could not alloc. transb. for pwm\n", index);
@@ -2568,8 +2583,6 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 				      usbduxsub + index,
 				      usbdux_firmware_request_complete_handler);
 
-
-
 	if (ret) {
 		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
 		return ret;
@@ -2592,8 +2605,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 		return;
 	}
 	if (usbduxsub_tmp->usbdev != udev) {
-		dev_err(&intf->dev,
-			"comedi_: BUG! called with wrong ptr!!!\n");
+		dev_err(&intf->dev, "comedi_: BUG! called with wrong ptr!!!\n");
 		return;
 	}
 	comedi_usb_auto_unconfig(udev);
@@ -2641,7 +2653,7 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
-		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		firmwareUpload(udev, comedi_aux_data(it->options, 0),
 			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
@@ -2667,8 +2679,8 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	dev_info(&udev->interface->dev,
-		"comedi%d: usb-device %d is attached to comedi.\n",
-		dev->minor, index);
+		 "comedi%d: usb-device %d is attached to comedi.\n",
+		 dev->minor, index);
 	/* private structure is also simply the usb-structure */
 	dev->private = udev;
 
@@ -2779,14 +2791,14 @@ static int usbdux_detach(struct comedi_device *dev)
 
 	if (!dev) {
 		printk(KERN_ERR
-			"comedi?: usbdux: detach without dev variable...\n");
+		       "comedi?: usbdux: detach without dev variable...\n");
 		return -EFAULT;
 	}
 
 	usbduxsub_tmp = dev->private;
 	if (!usbduxsub_tmp) {
 		printk(KERN_ERR
-			"comedi?: usbdux: detach without ptr to usbduxsub[]\n");
+		       "comedi?: usbdux: detach without ptr to usbduxsub[]\n");
 		return -EFAULT;
 	}
 
@@ -2807,16 +2819,16 @@ static int usbdux_detach(struct comedi_device *dev)
 
 /* main driver struct */
 static struct comedi_driver driver_usbdux = {
-      .driver_name =	"usbdux",
-      .module =		THIS_MODULE,
-      .attach =		usbdux_attach,
-      .detach =		usbdux_detach,
+	.driver_name = "usbdux",
+	.module = THIS_MODULE,
+	.attach = usbdux_attach,
+	.detach = usbdux_detach,
 };
 
 /* Table with the USB-devices: just now only testing IDs */
 static struct usb_device_id usbduxsub_table[] = {
-	{USB_DEVICE(0x13d8, 0x0001) },
-	{USB_DEVICE(0x13d8, 0x0002) },
+	{USB_DEVICE(0x13d8, 0x0001)},
+	{USB_DEVICE(0x13d8, 0x0002)},
 	{}			/* Terminating entry */
 };
 
@@ -2824,10 +2836,10 @@ MODULE_DEVICE_TABLE(usb, usbduxsub_table);
 
 /* The usbduxsub-driver */
 static struct usb_driver usbduxsub_driver = {
-      .name =		BOARDNAME,
-      .probe =		usbduxsub_probe,
-      .disconnect =	usbduxsub_disconnect,
-      .id_table =	usbduxsub_table,
+	.name = BOARDNAME,
+	.probe = usbduxsub_probe,
+	.disconnect = usbduxsub_disconnect,
+	.id_table = usbduxsub_table,
 };
 
 /* Can't use the nice macro as I have also to initialise the USB */

commit efe8d60a923ddd00de394381cb30aab5114b71a4
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Sun May 24 20:36:09 2009 +0100

    Staging: comedi: usbdux: buffer overflow error handling
    
    These changes guarantee that the URBs are not resubmitted in case of a
    comedi buffer overflow.  Otherwise this runs in the background even when
    the userspace program has terminated.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index eea7dbdde0be..171a6f2ff74f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -509,14 +509,19 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	for (i = 0; i < n; i++) {
 		/* transfer data */
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
-			comedi_buf_put
+			err = comedi_buf_put
 				(s->async,
-				le16_to_cpu(this_usbduxsub->
-					inBuffer[i]) ^ 0x800);
+				 le16_to_cpu(this_usbduxsub->
+					     inBuffer[i]) ^ 0x800);
 		} else {
-			comedi_buf_put
+			err = comedi_buf_put
 				(s->async,
-				le16_to_cpu(this_usbduxsub->inBuffer[i]));
+				 le16_to_cpu(this_usbduxsub->inBuffer[i]));
+		}
+		if (unlikely(err == 0)) {
+			/* buffer overflow */
+			usbdux_ai_stop(this_usbduxsub, 0);
+			return;
 		}
 	}
 	/* tell comedi that data is there */

commit 81874ff7895f332920621104308e803434a17183
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Fri Apr 17 21:21:46 2009 +0100

    Staging: comedi: convert usbdux* to use firmware_request
    
    The firmware is now in the linux-firmware tree, so we can move these two
    drivers to use the proper request_firmware infrastructure.
    
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index d0b59e98314b..eea7dbdde0be 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -809,32 +809,56 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 	return 0;
 }
 
-static int firmwareUpload(struct usbduxsub *usbduxsub, uint8_t *firmwareBinary,
+#define FIRMWARE_MAX_LEN 0x2000
+
+static int firmwareUpload(struct usbduxsub *usbduxsub,
+			  const u8 *firmwareBinary,
 			  int sizeFirmware)
 {
 	int ret;
+	uint8_t *fwBuf;
 
 	if (!firmwareBinary)
 		return 0;
 
+	if (sizeFirmware>FIRMWARE_MAX_LEN) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: usbdux firmware binary it too large for FX2.\n");
+		return -ENOMEM;
+	}
+
+	/* we generate a local buffer for the firmware */
+	fwBuf = kzalloc(sizeFirmware, GFP_KERNEL);
+	if (!fwBuf) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: mem alloc for firmware failed\n");
+		return -ENOMEM;
+	}
+	memcpy(fwBuf,firmwareBinary,sizeFirmware);
+
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not stop firmware\n");
+		kfree(fwBuf);
 		return ret;
 	}
-	ret = usbduxsub_upload(usbduxsub, firmwareBinary, 0, sizeFirmware);
+
+	ret = usbduxsub_upload(usbduxsub, fwBuf, 0, sizeFirmware);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: firmware upload failed\n");
+		kfree(fwBuf);
 		return ret;
 	}
 	ret = usbduxsub_start(usbduxsub);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not start firmware\n");
+		kfree(fwBuf);
 		return ret;
 	}
+	kfree(fwBuf);
 	return 0;
 }
 
@@ -2260,134 +2284,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
-static unsigned hex2unsigned(char *h)
-{
-	unsigned hi, lo;
-
-	if (h[0] > '9')
-		hi = h[0] - 'A' + 0x0a;
-	else
-		hi = h[0] - '0';
-
-	if (h[1] > '9')
-		lo = h[1] - 'A' + 0x0a;
-	else
-		lo = h[1] - '0';
-
-	return hi * 0x10 + lo;
-}
-
-/* for FX2 */
-#define FIRMWARE_MAX_LEN 0x2000
-
-/* taken from David Brownell's fxload and adjusted for this driver */
-static int read_firmware(struct usbduxsub *usbduxsub, const void *firmwarePtr,
-			 long size)
-{
-	struct device *dev = &usbduxsub->interface->dev;
-	int i = 0;
-	unsigned char *fp = (char *)firmwarePtr;
-	unsigned char *firmwareBinary;
-	int res = 0;
-	int maxAddr = 0;
-
-	firmwareBinary = kzalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
-	if (!firmwareBinary) {
-		dev_err(dev, "comedi_: mem alloc for firmware failed\n");
-		return -ENOMEM;
-	}
-
-	for (;;) {
-		char buf[256], *cp;
-		char type;
-		int len;
-		int idx, off;
-		int j = 0;
-
-		/* get one line */
-		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
-			buf[j] = fp[i];
-			i++;
-			j++;
-			if (j >= sizeof(buf)) {
-				dev_err(dev, "comedi_: bogus firmware file!\n");
-				kfree(firmwareBinary);
-				return -1;
-			}
-		}
-		/* get rid of LF/CR/... */
-		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
-				|| (fp[i] == 0))) {
-			i++;
-		}
-
-		buf[j] = 0;
-		/* dev_dbg(dev, "comedi_: buf=%s\n", buf); */
-
-		/*
-		 * EXTENSION:
-		 * "# comment-till-end-of-line", for copyrights etc
-		 */
-		if (buf[0] == '#')
-			continue;
-
-		if (buf[0] != ':') {
-			dev_err(dev, "comedi_: upload: not an ihex record: %s",
-				buf);
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
-
-		/* Read the length field (up to 16 bytes) */
-		len = hex2unsigned(buf + 1);
-
-		/* Read the target offset */
-		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
-
-		if ((off + len) > maxAddr)
-			maxAddr = off + len;
-
-
-		if (maxAddr >= FIRMWARE_MAX_LEN) {
-			dev_err(dev, "comedi_: firmware upload goes "
-				"beyond FX2 RAM boundaries.\n");
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
-		/* dev_dbg(dev, "comedi_: off=%x, len=%x:\n", off, len); */
-
-		/* Read the record type */
-		type = hex2unsigned(buf + 7);
-
-		/* If this is an EOF record, then make it so. */
-		if (type == 1)
-			break;
-
-
-		if (type != 0) {
-			dev_err(dev, "comedi_: unsupported record type: %u\n",
-				type);
-			kfree(firmwareBinary);
-			return -EFAULT;
-		}
-
-		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
-			firmwareBinary[idx + off] = hex2unsigned(cp);
-			/*printk("%02x ",firmwareBinary[idx+off]); */
-		}
-		/*printk("\n"); */
-
-		if (i >= size) {
-			dev_err(dev, "comedi_: unexpected end of hex file\n");
-			break;
-		}
-
-	}
-	res = firmwareUpload(usbduxsub, firmwareBinary, maxAddr + 1);
-	kfree(firmwareBinary);
-	return res;
-}
-
 static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 						     void *context)
 {
@@ -2405,7 +2301,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	 * we need to upload the firmware here because fw will be
 	 * freed once we've left this function
 	 */
-	ret = read_firmware(usbduxsub_tmp, fw->data, fw->size);
+	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
 
 	if (ret) {
 		dev_err(&usbdev->dev,
@@ -2662,11 +2558,13 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 
 	ret = request_firmware_nowait(THIS_MODULE,
 				      FW_ACTION_HOTPLUG,
-				      "usbdux_firmware.hex",
+				      "usbdux_firmware.bin",
 				      &udev->dev,
 				      usbduxsub + index,
 				      usbdux_firmware_request_complete_handler);
 
+
+
 	if (ret) {
 		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
 		return ret;
@@ -2739,8 +2637,8 @@ static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		read_firmware(udev, comedi_aux_data(it->options, 0),
-			      it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+		firmwareUpload(udev, comedi_aux_data(it->options, 0),
+			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
 
 	dev->board_name = BOARDNAME;

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 692df7a0e5eb..d0b59e98314b 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2703,7 +2703,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 }
 
 /* is called when comedi-config is called */
-static int usbdux_attach(struct comedi_device *dev, comedi_devconfig *it)
+static int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int ret;
 	int index;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7ec175aadbef..692df7a0e5eb 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1277,7 +1277,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 /* Mode 0 is used to get a single conversion on demand */
 static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-			       comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	unsigned int one = 0;
@@ -1338,7 +1338,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 /* analog out */
 
 static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-			       comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1360,7 +1360,7 @@ static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevic
 }
 
 static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-				comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1698,7 +1698,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-				  comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1729,7 +1729,7 @@ static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subde
 }
 
 static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-				comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1776,7 +1776,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 
 /* reads the 4 counters, only two are used just now */
 static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
-			       comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int chan = insn->chanspec;
@@ -1810,7 +1810,7 @@ static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevic
 }
 
 static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
-				comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int err;
@@ -1840,7 +1840,7 @@ static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevi
 }
 
 static int usbdux_counter_config(struct comedi_device *dev, struct comedi_subdevice *s,
-				 comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
 	return 2;
@@ -2098,7 +2098,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *s,
-			    comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 
@@ -2123,7 +2123,7 @@ static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 static int usbdux_pwm_read(struct comedi_device *x1, struct comedi_subdevice *x2,
-			   comedi_insn *x3, unsigned int *x4)
+			   struct comedi_insn *x3, unsigned int *x4)
 {
 	/* not needed */
 	return -EINVAL;
@@ -2131,7 +2131,7 @@ static int usbdux_pwm_read(struct comedi_device *x1, struct comedi_subdevice *x2
 
 /* switches on/off PWM */
 static int usbdux_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
-			     comedi_insn *insn, unsigned int *data)
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	switch (data[0]) {

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 108f2d71cd83..7ec175aadbef 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -897,7 +897,7 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 }
 
 static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     comedi_cmd *cmd)
+			     struct comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
@@ -1162,7 +1162,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice
 
 static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
 	int i, ret;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1451,7 +1451,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-			     comedi_cmd *cmd)
+			     struct comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1591,7 +1591,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
 	int i, ret;
 	struct usbduxsub *this_usbduxsub = dev->private;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index e3462c4a5a65..108f2d71cd83 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -214,7 +214,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 /**************************************************/
 /* comedi constants */
-static const comedi_lrange range_usbdux_ai_range = { 4, {
+static const struct comedi_lrange range_usbdux_ai_range = { 4, {
 			BIP_RANGE(4.096),
 			BIP_RANGE(4.096 / 2),
 			UNI_RANGE(4.096),
@@ -222,7 +222,7 @@ static const comedi_lrange range_usbdux_ai_range = { 4, {
 	}
 };
 
-static const comedi_lrange range_usbdux_ao_range = { 2, {
+static const struct comedi_lrange range_usbdux_ao_range = { 2, {
 			BIP_RANGE(4.096),
 			UNI_RANGE(4.096),
 	}

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 41872a3a68b2..e3462c4a5a65 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2903,7 +2903,7 @@ static int usbdux_detach(struct comedi_device *dev)
 }
 
 /* main driver struct */
-static comedi_driver driver_usbdux = {
+static struct comedi_driver driver_usbdux = {
       .driver_name =	"usbdux",
       .module =		THIS_MODULE,
       .attach =		usbdux_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c433076c0e47..41872a3a68b2 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -363,7 +363,7 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbdux_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub;
 	int res = 0;
@@ -393,7 +393,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	int i, err, n;
 	struct usbduxsub *this_usbduxsub;
 	struct comedi_device *this_comedidev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
@@ -561,7 +561,7 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 }
 
 /* force unlink, is called by comedi */
-static int usbdux_ao_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -587,7 +587,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	int8_t *datap;
 	struct usbduxsub *this_usbduxsub;
 	struct comedi_device *this_comedidev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
@@ -896,7 +896,7 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			     comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
@@ -1116,7 +1116,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
@@ -1160,7 +1160,7 @@ static int usbdux_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
@@ -1276,7 +1276,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1337,7 +1337,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 /************************************/
 /* analog out */
 
-static int usbdux_ao_insn_read(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1359,7 +1359,7 @@ static int usbdux_ao_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int usbdux_ao_insn_write(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
@@ -1409,7 +1409,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int usbdux_ao_inttrig(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
@@ -1450,7 +1450,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
 			     comedi_cmd *cmd)
 {
 	int err = 0, tmp;
@@ -1589,7 +1589,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-static int usbdux_ao_cmd(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
@@ -1697,7 +1697,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, comedi_subdevice *s)
 	return 0;
 }
 
-static int usbdux_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
 				  comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1728,7 +1728,7 @@ static int usbdux_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 
@@ -1775,7 +1775,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
 }
 
 /* reads the 4 counters, only two are used just now */
-static int usbdux_counter_read(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_read(struct comedi_device *dev, struct comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1809,7 +1809,7 @@ static int usbdux_counter_read(struct comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_counter_write(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_write(struct comedi_device *dev, struct comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1839,7 +1839,7 @@ static int usbdux_counter_write(struct comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_counter_config(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_config(struct comedi_device *dev, struct comedi_subdevice *s,
 				 comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
@@ -1883,7 +1883,7 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 }
 
 /* force unlink - is called by comedi */
-static int usbdux_pwm_cancel(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_pwm_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -1906,7 +1906,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	int ret;
 	struct usbduxsub *this_usbduxsub;
 	struct comedi_device *this_comedidev;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 
 	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
 
@@ -1996,7 +1996,7 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_pwm_period(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_period(struct comedi_device *dev, struct comedi_subdevice *s,
 			     unsigned int period)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2024,7 +2024,7 @@ static int usbdux_pwm_period(struct comedi_device *dev, comedi_subdevice *s,
 }
 
 /* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(struct comedi_device *dev, comedi_subdevice *s)
+static int usbdux_pwm_start(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret, i;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2056,7 +2056,7 @@ static int usbdux_pwm_start(struct comedi_device *dev, comedi_subdevice *s)
 }
 
 /* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_pattern(struct comedi_device *dev, struct comedi_subdevice *s,
 			      int channel, unsigned int value, unsigned int sign)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2097,7 +2097,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_pwm_write(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_write(struct comedi_device *dev, struct comedi_subdevice *s,
 			    comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2122,7 +2122,7 @@ static int usbdux_pwm_write(struct comedi_device *dev, comedi_subdevice *s,
 				  data[0], 0);
 }
 
-static int usbdux_pwm_read(struct comedi_device *x1, comedi_subdevice *x2,
+static int usbdux_pwm_read(struct comedi_device *x1, struct comedi_subdevice *x2,
 			   comedi_insn *x3, unsigned int *x4)
 {
 	/* not needed */
@@ -2130,7 +2130,7 @@ static int usbdux_pwm_read(struct comedi_device *x1, comedi_subdevice *x2,
 };
 
 /* switches on/off PWM */
-static int usbdux_pwm_config(struct comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_config(struct comedi_device *dev, struct comedi_subdevice *s,
 			     comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2710,7 +2710,7 @@ static int usbdux_attach(struct comedi_device *dev, comedi_devconfig *it)
 	int i;
 	struct usbduxsub *udev;
 
-	comedi_subdevice *s = NULL;
+	struct comedi_subdevice *s = NULL;
 	dev->private = NULL;
 
 	down(&start_stop_sem);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 68566295443a..c433076c0e47 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -269,7 +269,7 @@ struct usbduxsub {
 	/* interface structure in 2.6 */
 	struct usb_interface *interface;
 	/* comedi device for the interrupt context */
-	comedi_device *comedidev;
+	struct comedi_device *comedidev;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -363,7 +363,7 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbdux_ai_cancel(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ai_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub;
 	int res = 0;
@@ -392,7 +392,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 {
 	int i, err, n;
 	struct usbduxsub *this_usbduxsub;
-	comedi_device *this_comedidev;
+	struct comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
@@ -561,7 +561,7 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 }
 
 /* force unlink, is called by comedi */
-static int usbdux_ao_cancel(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ao_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -586,7 +586,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	int i, ret;
 	int8_t *datap;
 	struct usbduxsub *this_usbduxsub;
-	comedi_device *this_comedidev;
+	struct comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
@@ -896,7 +896,7 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 			     comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
@@ -1116,7 +1116,7 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
@@ -1160,7 +1160,7 @@ static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ai_cmd(struct comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
@@ -1276,7 +1276,7 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ai_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1337,7 +1337,7 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 /************************************/
 /* analog out */
 
-static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_insn_read(struct comedi_device *dev, comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
@@ -1359,7 +1359,7 @@ static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_insn_write(struct comedi_device *dev, comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
@@ -1409,7 +1409,7 @@ static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_inttrig(struct comedi_device *dev, comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
@@ -1450,7 +1450,7 @@ static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_ao_cmdtest(struct comedi_device *dev, comedi_subdevice *s,
 			     comedi_cmd *cmd)
 {
 	int err = 0, tmp;
@@ -1589,7 +1589,7 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_ao_cmd(struct comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
@@ -1697,7 +1697,7 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 	return 0;
 }
 
-static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_dio_insn_config(struct comedi_device *dev, comedi_subdevice *s,
 				  comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1728,7 +1728,7 @@ static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_dio_insn_bits(struct comedi_device *dev, comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 
@@ -1775,7 +1775,7 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 }
 
 /* reads the 4 counters, only two are used just now */
-static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_read(struct comedi_device *dev, comedi_subdevice *s,
 			       comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1809,7 +1809,7 @@ static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_write(struct comedi_device *dev, comedi_subdevice *s,
 				comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1839,7 +1839,7 @@ static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_counter_config(struct comedi_device *dev, comedi_subdevice *s,
 				 comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
@@ -1883,7 +1883,7 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 }
 
 /* force unlink - is called by comedi */
-static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_pwm_cancel(struct comedi_device *dev, comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
@@ -1905,7 +1905,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 {
 	int ret;
 	struct usbduxsub *this_usbduxsub;
-	comedi_device *this_comedidev;
+	struct comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
 	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
@@ -1996,7 +1996,7 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 	return 0;
 }
 
-static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_period(struct comedi_device *dev, comedi_subdevice *s,
 			     unsigned int period)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2024,7 +2024,7 @@ static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 }
 
 /* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
+static int usbdux_pwm_start(struct comedi_device *dev, comedi_subdevice *s)
 {
 	int ret, i;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2056,7 +2056,7 @@ static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
 }
 
 /* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_pattern(struct comedi_device *dev, comedi_subdevice *s,
 			      int channel, unsigned int value, unsigned int sign)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2097,7 +2097,7 @@ static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
 	return 1;
 }
 
-static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_write(struct comedi_device *dev, comedi_subdevice *s,
 			    comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2122,7 +2122,7 @@ static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
 				  data[0], 0);
 }
 
-static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
+static int usbdux_pwm_read(struct comedi_device *x1, comedi_subdevice *x2,
 			   comedi_insn *x3, unsigned int *x4)
 {
 	/* not needed */
@@ -2130,7 +2130,7 @@ static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
 };
 
 /* switches on/off PWM */
-static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
+static int usbdux_pwm_config(struct comedi_device *dev, comedi_subdevice *s,
 			     comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -2703,7 +2703,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 }
 
 /* is called when comedi-config is called */
-static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
+static int usbdux_attach(struct comedi_device *dev, comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -2870,7 +2870,7 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	return 0;
 }
 
-static int usbdux_detach(comedi_device *dev)
+static int usbdux_detach(struct comedi_device *dev)
 {
 	struct usbduxsub *usbduxsub_tmp;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 0e02e646dad6..68566295443a 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -253,7 +253,7 @@ struct usbduxsub {
 	/* pwm-transfer handling */
 	struct urb *urbPwm;
 	/* PWM period */
-	lsampl_t pwmPeriod;
+	unsigned int pwmPeriod;
 	/* PWM internal delay for the GPIF in the FX2 */
 	int8_t pwmDelay;
 	/* size of the PWM buffer which holds the bit pattern */
@@ -656,7 +656,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		((uint8_t *) (urb->transfer_buffer))[0] =
 			s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
-			sampl_t temp;
+			short temp;
 			if (i >= NUMOUTCHANNELS)
 				break;
 
@@ -1277,10 +1277,10 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 
 /* Mode 0 is used to get a single conversion on demand */
 static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
-			       comedi_insn *insn, lsampl_t *data)
+			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
-	lsampl_t one = 0;
+	unsigned int one = 0;
 	int chan, range;
 	int err;
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1338,7 +1338,7 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 /* analog out */
 
 static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
-			       comedi_insn *insn, lsampl_t *data)
+			       comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1360,7 +1360,7 @@ static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
-				comedi_insn *insn, lsampl_t *data)
+				comedi_insn *insn, unsigned int *data)
 {
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1698,7 +1698,7 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 }
 
 static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
-				  comedi_insn *insn, lsampl_t *data)
+				  comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1729,7 +1729,7 @@ static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
-				comedi_insn *insn, lsampl_t *data)
+				comedi_insn *insn, unsigned int *data)
 {
 
 	struct usbduxsub *this_usbduxsub = dev->private;
@@ -1776,7 +1776,7 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 
 /* reads the 4 counters, only two are used just now */
 static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
-			       comedi_insn *insn, lsampl_t *data)
+			       comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int chan = insn->chanspec;
@@ -1810,7 +1810,7 @@ static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
-				comedi_insn *insn, lsampl_t *data)
+				comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int err;
@@ -1840,7 +1840,7 @@ static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
-				 comedi_insn *insn, lsampl_t *data)
+				 comedi_insn *insn, unsigned int *data)
 {
 	/* nothing to do so far */
 	return 2;
@@ -1997,7 +1997,7 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 }
 
 static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
-			     lsampl_t period)
+			     unsigned int period)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int fx2delay = 255;
@@ -2057,7 +2057,7 @@ static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
 
 /* generates the bit pattern for PWM with the optional sign bit */
 static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
-			      int channel, lsampl_t value, lsampl_t sign)
+			      int channel, unsigned int value, unsigned int sign)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	int i, szbuf;
@@ -2098,7 +2098,7 @@ static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
-			    comedi_insn *insn, lsampl_t *data)
+			    comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 
@@ -2123,7 +2123,7 @@ static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
 }
 
 static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
-			   comedi_insn *x3, lsampl_t *x4)
+			   comedi_insn *x3, unsigned int *x4)
 {
 	/* not needed */
 	return -EINVAL;
@@ -2131,7 +2131,7 @@ static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
 
 /* switches on/off PWM */
 static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
-			     comedi_insn *insn, lsampl_t *data)
+			     comedi_insn *insn, unsigned int *data)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
 	switch (data[0]) {

commit 1b9fb14eb21f86519ce35a2e770a29cd768386a2
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:36 2009 +0100

    Staging: comedi: usbdux: annotate __init and __exit functions
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 785e8b709938..0e02e646dad6 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2930,7 +2930,7 @@ static struct usb_driver usbduxsub_driver = {
 /* Can't use the nice macro as I have also to initialise the USB */
 /* subsystem: */
 /* registering the usb-system _and_ the comedi-driver */
-static int init_usbdux(void)
+static int __init init_usbdux(void)
 {
 	printk(KERN_INFO KBUILD_MODNAME ": "
 	       DRIVER_VERSION ":" DRIVER_DESC "\n");
@@ -2940,7 +2940,7 @@ static int init_usbdux(void)
 }
 
 /* deregistering the comedi driver and the usb-subsystem */
-static void exit_usbdux(void)
+static void __exit exit_usbdux(void)
 {
 	comedi_driver_unregister(&driver_usbdux);
 	usb_deregister(&usbduxsub_driver);

commit ab3795270d3a7985be40ae325d3366cf018fc9dd
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:35 2009 +0100

    Staging: comedi: usbdux: don't initialize semaphores on init
    
    This patch removes usbdux semaphores initialization
    from init function as they are initialized later on in
    probe function. Also remove init_usb_devices() as it is
    not needed anymore.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c215a9264216..785e8b709938 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2910,17 +2910,6 @@ static comedi_driver driver_usbdux = {
       .detach =		usbdux_detach,
 };
 
-static void init_usb_devices(void)
-{
-	int index;
-
-	/* all devices entries are invalid to begin with */
-	/* they will become valid by the probe function */
-	/* and then finally by the attach-function */
-	for (index = 0; index < NUMUSBDUX; index++)
-		init_MUTEX(&(usbduxsub[index].sem));
-}
-
 /* Table with the USB-devices: just now only testing IDs */
 static struct usb_device_id usbduxsub_table[] = {
 	{USB_DEVICE(0x13d8, 0x0001) },
@@ -2945,7 +2934,6 @@ static int init_usbdux(void)
 {
 	printk(KERN_INFO KBUILD_MODNAME ": "
 	       DRIVER_VERSION ":" DRIVER_DESC "\n");
-	init_usb_devices();
 	usb_register(&usbduxsub_driver);
 	comedi_driver_register(&driver_usbdux);
 	return 0;

commit 84cdbf0afe4f391480087dec613c7f8aff5d0496
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Mar 3 19:38:34 2009 +0100

    Staging: comedi: usbdux: remove .bss variable initialization
    
    This patch removes explicit zeroing of usbduxsub
    variable on init because it is in .bss section.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index dc6059b6ca43..c215a9264216 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2917,10 +2917,8 @@ static void init_usb_devices(void)
 	/* all devices entries are invalid to begin with */
 	/* they will become valid by the probe function */
 	/* and then finally by the attach-function */
-	for (index = 0; index < NUMUSBDUX; index++) {
-		memset(&(usbduxsub[index]), 0x00, sizeof(usbduxsub[index]));
+	for (index = 0; index < NUMUSBDUX; index++)
 		init_MUTEX(&(usbduxsub[index].sem));
-	}
 }
 
 /* Table with the USB-devices: just now only testing IDs */

commit 6742c0af2ef2d8ff70e379ebf8a8541190ff44e6
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Mon Dec 8 23:30:13 2008 +0000

    Staging: comedi: usbdux[fast] firmware upload changes
    
    usbdux and usbduxfast upload now their firmware via the firmware kernel
    meachanism. No udev rules are needed for that except the default ones.
    The firmware will usually be loaded from /lib/firmware. Upload via
    comedi_config is still possible for static comedi devices
    (comedi_num_legacy_minors>0).
    
    Frank, thanks for the example code which sped up rewriting of the code
    substantially.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 8aa10c8df678..dc6059b6ca43 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -1,4 +1,4 @@
-#define DRIVER_VERSION "v2.1"
+#define DRIVER_VERSION "v2.2"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com"
 /*
@@ -25,8 +25,8 @@ Driver: usbdux
 Description: University of Stirling USB DAQ & INCITE Technology Limited
 Devices: [ITL] USB-DUX (usbdux.o)
 Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 25 Nov 2007
-Status: Testing
+Updated: 8 Dec 2008
+Status: Stable
 Configuration options:
   You have to upload firmware with the -i option. The
   firmware is usually installed under /usr/share/usb or
@@ -79,6 +79,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  * 1.2:  added PWM suport via EP4
  * 2.0:  PWM seems to be stable and is not interfering with the other functions
  * 2.1:  changed PWM API
+ * 2.2:  added firmware kernel request to fix an udev problem
  *
  */
 
@@ -94,6 +95,7 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #include <linux/smp_lock.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
+#include <linux/firmware.h>
 
 #include "../comedidev.h"
 
@@ -718,31 +720,29 @@ static int usbduxsub_start(struct usbduxsub *usbduxsub)
 	int errcode = 0;
 	uint8_t local_transfer_buffer[16];
 
-	if (usbduxsub->probed) {
-		/* 7f92 to zero */
-		local_transfer_buffer[0] = 0;
-		errcode = usb_control_msg(usbduxsub->usbdev,
-			/* create a pipe for a control transfer */
-			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			/* bRequest, "Firmware" */
-			USBDUXSUB_FIRMWARE,
-			/* bmRequestType */
-			VENDOR_DIR_OUT,
-			/* Value */
-			USBDUXSUB_CPUCS,
-			/* Index */
-			0x0000,
-			/* address of the transfer buffer */
-			local_transfer_buffer,
-			/* Length */
-			1,
-			/* Timeout */
-			EZTIMEOUT);
-		if (errcode < 0) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: control msg failed (start)\n");
-			return errcode;
-		}
+	/* 7f92 to zero */
+	local_transfer_buffer[0] = 0;
+	errcode = usb_control_msg(usbduxsub->usbdev,
+				  /* create a pipe for a control transfer */
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* bRequest, "Firmware" */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* Value */
+				  USBDUXSUB_CPUCS,
+				  /* Index */
+				  0x0000,
+				  /* address of the transfer buffer */
+				  local_transfer_buffer,
+				  /* Length */
+				  1,
+				  /* Timeout */
+				  EZTIMEOUT);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: control msg failed (start)\n");
+		return errcode;
 	}
 	return 0;
 }
@@ -752,28 +752,27 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 	int errcode = 0;
 
 	uint8_t local_transfer_buffer[16];
-	if (usbduxsub->probed) {
-		/* 7f92 to one */
-		local_transfer_buffer[0] = 1;
-		errcode = usb_control_msg(usbduxsub->usbdev,
-			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			/* bRequest, "Firmware" */
-			USBDUXSUB_FIRMWARE,
-			/* bmRequestType */
-			VENDOR_DIR_OUT,
-			/* Value */
-			USBDUXSUB_CPUCS,
-			/* Index */
-			0x0000, local_transfer_buffer,
-			/* Length */
-			1,
-			/* Timeout */
-			EZTIMEOUT);
-		if (errcode < 0) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: control msg failed (stop)\n");
-			return errcode;
-		}
+
+	/* 7f92 to one */
+	local_transfer_buffer[0] = 1;
+	errcode = usb_control_msg(usbduxsub->usbdev,
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* bRequest, "Firmware" */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* Value */
+				  USBDUXSUB_CPUCS,
+				  /* Index */
+				  0x0000, local_transfer_buffer,
+				  /* Length */
+				  1,
+				  /* Timeout */
+				  EZTIMEOUT);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: control msg failed (stop)\n");
+		return errcode;
 	}
 	return 0;
 }
@@ -784,13 +783,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 {
 	int errcode;
 
-	if (usbduxsub->probed) {
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi%d: usbdux: uploading %d bytes"
-			" to addr %d, first byte=%d.\n",
-			usbduxsub->comedidev->minor, len,
-			startAddr, local_transfer_buffer[0]);
-		errcode = usb_control_msg(usbduxsub->usbdev,
+	errcode = usb_control_msg(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
 			/* brequest, firmware */
 			USBDUXSUB_FIRMWARE,
@@ -806,16 +799,12 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 			len,
 			/* timeout */
 			EZTIMEOUT);
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi_: result=%d\n", errcode);
-		if (errcode < 0) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: upload failed\n");
-			return errcode;
-		}
-	} else {
-		/* no device on the bus for this index */
-		return -EFAULT;
+	dev_dbg(&usbduxsub->interface->dev,
+		"comedi_: result=%d\n", errcode);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+		"comedi_: upload failed\n");
+		return errcode;
 	}
 	return 0;
 }
@@ -2292,7 +2281,7 @@ static unsigned hex2unsigned(char *h)
 #define FIRMWARE_MAX_LEN 0x2000
 
 /* taken from David Brownell's fxload and adjusted for this driver */
-static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
+static int read_firmware(struct usbduxsub *usbduxsub, const void *firmwarePtr,
 			 long size)
 {
 	struct device *dev = &usbduxsub->interface->dev;
@@ -2399,6 +2388,34 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 	return res;
 }
 
+static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
+						     void *context)
+{
+	struct usbduxsub *usbduxsub_tmp = context;
+	struct usb_device *usbdev = usbduxsub_tmp->usbdev;
+	int ret;
+
+	if (fw == NULL) {
+		dev_err(&usbdev->dev,
+			"Firmware complete handler without firmware!\n");
+		return;
+	}
+
+	/*
+	 * we need to upload the firmware here because fw will be
+	 * freed once we've left this function
+	 */
+	ret = read_firmware(usbduxsub_tmp, fw->data, fw->size);
+
+	if (ret) {
+		dev_err(&usbdev->dev,
+			"Could not upload firmware (err=%d)\n",
+			ret);
+		return;
+	}
+	comedi_usb_auto_config(usbdev, BOARDNAME);
+}
+
 /* allocate memory for the urbs and initialise them */
 static int usbduxsub_probe(struct usb_interface *uinterf,
 			   const struct usb_device_id *id)
@@ -2407,6 +2424,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	struct device *dev = &uinterf->dev;
 	int i;
 	int index;
+	int ret;
 
 	dev_dbg(dev, "comedi_: usbdux_: "
 		"finding a free structure for the usb-device\n");
@@ -2641,6 +2659,19 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* we've reached the bottom of the function */
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
+
+	ret = request_firmware_nowait(THIS_MODULE,
+				      FW_ACTION_HOTPLUG,
+				      "usbdux_firmware.hex",
+				      &udev->dev,
+				      usbduxsub + index,
+				      usbdux_firmware_request_complete_handler);
+
+	if (ret) {
+		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
+		return ret;
+	}
+
 	dev_info(dev, "comedi_: usbdux%d "
 		 "has been successfully initialised.\n", index);
 	/* success */
@@ -2662,6 +2693,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 			"comedi_: BUG! called with wrong ptr!!!\n");
 		return;
 	}
+	comedi_usb_auto_unconfig(udev);
 	down(&start_stop_sem);
 	down(&usbduxsub_tmp->sem);
 	tidy_up(usbduxsub_tmp);

commit b171041be02f171cd06712746b97a996f883ec10
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Dec 25 21:10:30 2008 +0100

    Staging: comedi: introduce missing kfree
    
    Error handling code following a kmalloc should free the allocated data.
    
    The semantic match that finds the problem is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r exists@
    local idexpression x;
    statement S;
    expression E;
    identifier f,l;
    position p1,p2;
    expression *ptr != NULL;
    @@
    
    (
    if ((x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...)) == NULL) S
    |
    x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
    ...
    if (x == NULL) S
    )
    <... when != x
         when != if (...) { <+...x...+> }
    x->f = E
    ...>
    (
     return \(0\|<+...x...+>\|ptr\);
    |
     return@p2 ...;
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    print "* file: %s kmalloc %s return %s" % (p1[0].file,p1[0].line,p2[0].line)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 35138257be7f..8aa10c8df678 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -2298,7 +2298,7 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 	struct device *dev = &usbduxsub->interface->dev;
 	int i = 0;
 	unsigned char *fp = (char *)firmwarePtr;
-	unsigned char *firmwareBinary = NULL;
+	unsigned char *firmwareBinary;
 	int res = 0;
 	int maxAddr = 0;
 
@@ -2322,6 +2322,7 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 			j++;
 			if (j >= sizeof(buf)) {
 				dev_err(dev, "comedi_: bogus firmware file!\n");
+				kfree(firmwareBinary);
 				return -1;
 			}
 		}
@@ -2344,6 +2345,7 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 		if (buf[0] != ':') {
 			dev_err(dev, "comedi_: upload: not an ihex record: %s",
 				buf);
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 
@@ -2360,6 +2362,7 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
 			dev_err(dev, "comedi_: firmware upload goes "
 				"beyond FX2 RAM boundaries.\n");
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 		/* dev_dbg(dev, "comedi_: off=%x, len=%x:\n", off, len); */
@@ -2375,6 +2378,7 @@ static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
 		if (type != 0) {
 			dev_err(dev, "comedi_: unsupported record type: %u\n",
 				type);
+			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 

commit 4aa3a8232158abeea939ec12770fdfcf2987b3c4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 17:02:39 2008 -0800

    Staging: comedi: usbdux: remove comedi usb wrappers
    
    Remove the comedi usb wrapper function usage in the usbdux driver as
    they are no longer needed.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index c3f2d9f12cfe..35138257be7f 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -96,7 +96,6 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 #include <linux/compiler.h>
 
 #include "../comedidev.h"
-#include "../usb.h"
 
 #define BOARDNAME "usbdux"
 
@@ -465,7 +464,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	urb->dev = this_usbduxsub->usbdev;
 
 	/* resubmit the urb */
-	err = USB_SUBMIT_URB(urb);
+	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (unlikely(err < 0)) {
 		dev_err(&urb->dev->dev,
 			"comedi_: urb resubmit failed in int-context! err=%d\n",
@@ -695,7 +694,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		urb->iso_frame_desc[0].offset = 0;
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].status = 0;
-		ret = USB_SUBMIT_URB(urb);
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
 			dev_err(&urb->dev->dev,
 				"comedi_: ao urb resubm failed in int-cont. "
@@ -722,7 +721,7 @@ static int usbduxsub_start(struct usbduxsub *usbduxsub)
 	if (usbduxsub->probed) {
 		/* 7f92 to zero */
 		local_transfer_buffer[0] = 0;
-		errcode = USB_CONTROL_MSG(usbduxsub->usbdev,
+		errcode = usb_control_msg(usbduxsub->usbdev,
 			/* create a pipe for a control transfer */
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
 			/* bRequest, "Firmware" */
@@ -756,8 +755,7 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 	if (usbduxsub->probed) {
 		/* 7f92 to one */
 		local_transfer_buffer[0] = 1;
-		errcode = USB_CONTROL_MSG
-			(usbduxsub->usbdev,
+		errcode = usb_control_msg(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
 			/* bRequest, "Firmware" */
 			USBDUXSUB_FIRMWARE,
@@ -792,8 +790,7 @@ static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 			" to addr %d, first byte=%d.\n",
 			usbduxsub->comedidev->minor, len,
 			startAddr, local_transfer_buffer[0]);
-		errcode = USB_CONTROL_MSG
-			(usbduxsub->usbdev,
+		errcode = usb_control_msg(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
 			/* brequest, firmware */
 			USBDUXSUB_FIRMWARE,
@@ -873,10 +870,10 @@ static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
 			(usbduxsub->urbIn[i]->context),
 			(usbduxsub->urbIn[i]->dev),
 			(usbduxsub->urbIn[i]->interval));
-		errFlag = USB_SUBMIT_URB(usbduxsub->urbIn[i]);
+		errFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);
 		if (errFlag) {
 			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ai: USB_SUBMIT_URB(%d) error %d\n",
+				"comedi_: ai: usb_submit_urb(%d) error %d\n",
 				i, errFlag);
 			return errFlag;
 		}
@@ -899,10 +896,10 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urbOut[i]->status = 0;
 		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
-		errFlag = USB_SUBMIT_URB(usbduxsub->urbOut[i]);
+		errFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);
 		if (errFlag) {
 			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ao: USB_SUBMIT_URB(%d) error %d\n",
+				"comedi_: ao: usb_submit_urb(%d) error %d\n",
 				i, errFlag);
 			return errFlag;
 		}
@@ -1087,10 +1084,11 @@ static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 		printk(" %02x", this_usbduxsub->dux_commands[result]);
 	printk("\n");
 #endif
-	result = USB_BULK_MSG(this_usbduxsub->usbdev,
-		usb_sndbulkpipe(this_usbduxsub->usbdev,
-			COMMAND_OUT_EP),
-		this_usbduxsub->dux_commands, SIZEOFDUXBUFFER, &nsent, 10 * HZ);
+	result = usb_bulk_msg(this_usbduxsub->usbdev,
+			      usb_sndbulkpipe(this_usbduxsub->usbdev,
+					      COMMAND_OUT_EP),
+			      this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
+			      &nsent, 10);
 	if (result < 0)
 		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 			"could not transmit dux_command to the usb-device, "
@@ -1106,10 +1104,11 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		result = USB_BULK_MSG(this_usbduxsub->usbdev,
-			usb_rcvbulkpipe(this_usbduxsub->usbdev,
-				COMMAND_IN_EP),
-			this_usbduxsub->insnBuffer, SIZEINSNBUF, &nrec, 1 * HZ);
+		result = usb_bulk_msg(this_usbduxsub->usbdev,
+				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
+						      COMMAND_IN_EP),
+				      this_usbduxsub->insnBuffer, SIZEINSNBUF,
+				      &nrec, 1);
 		if (result < 0) {
 			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 				"insn: USB error %d while receiving DUX command"
@@ -1966,7 +1965,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	urb->dev = this_usbduxsub->usbdev;
 	urb->status = 0;
 	if (this_usbduxsub->pwm_cmd_running) {
-		ret = USB_SUBMIT_URB(urb);
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi_: pwm urb resubm failed in int-cont. "
@@ -1998,10 +1997,10 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 		usbduxsub->urbPwm->transfer_buffer,
 		usbduxsub->sizePwmBuf, usbduxsub_pwm_irq, usbduxsub->comedidev);
 
-	errFlag = USB_SUBMIT_URB(usbduxsub->urbPwm);
+	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
 	if (errFlag) {
 		dev_err(&usbduxsub->interface->dev,
-			"comedi_: usbdux: pwm: USB_SUBMIT_URB error %d\n",
+			"comedi_: usbdux: pwm: usb_submit_urb error %d\n",
 			errFlag);
 		return errFlag;
 	}
@@ -2422,7 +2421,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	if (index == -1) {
 		dev_err(dev, "Too many usbdux-devices connected.\n");
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-EMFILE);
+		return -EMFILE;
 	}
 	dev_dbg(dev, "comedi_: usbdux: "
 		"usbduxsub[%d] is ready to connect to comedi.\n", index);
@@ -2452,7 +2451,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	/* create space for the commands going to the usb device */
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
@@ -2461,7 +2460,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	/* create space for the in buffer and set it to zero */
 	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
@@ -2470,7 +2469,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"could not alloc space for inBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	/* create space of the instruction buffer */
 	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
@@ -2479,7 +2478,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	/* create space for the outbuffer */
 	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
@@ -2488,7 +2487,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"could not alloc space for outBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
 	i = usb_set_interface(usbduxsub[index].usbdev,
@@ -2499,7 +2498,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			index);
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENODEV);
+		return -ENODEV;
 	}
 	if (usbduxsub[index].high_speed)
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
@@ -2513,17 +2512,17 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		dev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbIn[i] = USB_ALLOC_URB(1);
+		usbduxsub[index].urbIn[i] = usb_alloc_urb(1, GFP_KERNEL);
 		if (usbduxsub[index].urbIn[i] == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
 		/* will be filled later with a pointer to the comedi-device */
@@ -2539,7 +2538,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 		usbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;
 		usbduxsub[index].urbIn[i]->number_of_packets = 1;
@@ -2562,17 +2561,17 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			"Could not alloc. urbOut array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
-		return PROBE_ERR_RETURN(-ENOMEM);
+		return -ENOMEM;
 	}
 	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbOut[i] = USB_ALLOC_URB(1);
+		usbduxsub[index].urbOut[i] = usb_alloc_urb(1, GFP_KERNEL);
 		if (usbduxsub[index].urbOut[i] == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
 		/* will be filled later with a pointer to the comedi-device */
@@ -2588,7 +2587,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 		usbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;
 		usbduxsub[index].urbOut[i]->number_of_packets = 1;
@@ -2609,13 +2608,13 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	if (usbduxsub[index].high_speed) {
 		/* max bulk ep size in high speed */
 		usbduxsub[index].sizePwmBuf = 512;
-		usbduxsub[index].urbPwm = USB_ALLOC_URB(0);
+		usbduxsub[index].urbPwm = usb_alloc_urb(0, GFP_KERNEL);
 		if (usbduxsub[index].urbPwm == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
 				"Could not alloc. pwm urb\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 		usbduxsub[index].urbPwm->transfer_buffer =
 			kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
@@ -2624,7 +2623,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 				"could not alloc. transb. for pwm\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
-			return PROBE_ERR_RETURN(-ENOMEM);
+			return -ENOMEM;
 		}
 	} else {
 		usbduxsub[index].urbPwm = NULL;

commit cc92fca7bad65adee79c241a72082bacbfec6c3e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 16:53:44 2008 -0800

    Staging: comedi: usbdux: remove typedef
    
    Remove the typedef in the usbdux driver.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ac9f34d45de1..c3f2d9f12cfe 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -235,7 +235,7 @@ static const comedi_lrange range_usbdux_ao_range = { 2, {
  * This is the structure which holds all the data of
  * this driver one sub device just now: A/D
  */
-typedef struct {
+struct usbduxsub {
 	/* attached? */
 	int attached;
 	/* is it associated with a subdevice? */
@@ -295,7 +295,7 @@ typedef struct {
 	/* commands */
 	int8_t *dux_commands;
 	struct semaphore sem;
-} usbduxsub_t;
+};
 
 /*
  * The pointer to the private usb-data of the driver is also the private data
@@ -304,7 +304,7 @@ typedef struct {
  * _before_ any comedi command is issued. The usb subsystem must be initialised
  * before comedi can access it.
  */
-static usbduxsub_t usbduxsub[NUMUSBDUX];
+static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DECLARE_MUTEX(start_stop_sem);
 
@@ -312,7 +312,7 @@ static DECLARE_MUTEX(start_stop_sem);
  * Stops the data acquision
  * It should be safe to call this function from any context
  */
-static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
+static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
@@ -337,7 +337,7 @@ static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
  * Is called from within this driver from both the
  * interrupt context and from comedi
  */
-static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
+static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -364,7 +364,7 @@ static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
  */
 static int usbdux_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
-	usbduxsub_t *this_usbduxsub;
+	struct usbduxsub *this_usbduxsub;
 	int res = 0;
 
 	/* force unlink of all urbs */
@@ -390,13 +390,13 @@ static int usbdux_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 static void usbduxsub_ai_IsocIrq(struct urb *urb)
 {
 	int i, err, n;
-	usbduxsub_t *this_usbduxsub;
+	struct usbduxsub *this_usbduxsub;
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is usbduxsub_t */
+	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 	/* subdevice which is the AD converter */
 	s = this_comedidev->subdevices + SUBDEV_AD;
@@ -522,7 +522,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static int usbduxsub_unlink_OutURBs(usbduxsub_t *usbduxsub_tmp)
+static int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
@@ -543,7 +543,7 @@ static int usbduxsub_unlink_OutURBs(usbduxsub_t *usbduxsub_tmp)
 /* This will cancel a running acquisition operation
  * in any context.
  */
-static int usbdux_ao_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
+static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -562,7 +562,7 @@ static int usbdux_ao_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 /* force unlink, is called by comedi */
 static int usbdux_ao_cancel(comedi_device *dev, comedi_subdevice *s)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
 
 	if (!this_usbduxsub)
@@ -584,13 +584,13 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 {
 	int i, ret;
 	int8_t *datap;
-	usbduxsub_t *this_usbduxsub;
+	struct usbduxsub *this_usbduxsub;
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is usbduxsub_t */
+	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
 	s = this_comedidev->subdevices + SUBDEV_DA;
@@ -714,7 +714,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_start(usbduxsub_t *usbduxsub)
+static int usbduxsub_start(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
 	uint8_t local_transfer_buffer[16];
@@ -748,7 +748,7 @@ static int usbduxsub_start(usbduxsub_t *usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_stop(usbduxsub_t *usbduxsub)
+static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
 
@@ -780,7 +780,7 @@ static int usbduxsub_stop(usbduxsub_t *usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_upload(usbduxsub_t *usbduxsub,
+static int usbduxsub_upload(struct usbduxsub *usbduxsub,
 			    uint8_t *local_transfer_buffer,
 			    unsigned int startAddr, unsigned int len)
 {
@@ -823,7 +823,7 @@ static int usbduxsub_upload(usbduxsub_t *usbduxsub,
 	return 0;
 }
 
-static int firmwareUpload(usbduxsub_t *usbduxsub, uint8_t *firmwareBinary,
+static int firmwareUpload(struct usbduxsub *usbduxsub, uint8_t *firmwareBinary,
 			  int sizeFirmware)
 {
 	int ret;
@@ -852,7 +852,7 @@ static int firmwareUpload(usbduxsub_t *usbduxsub, uint8_t *firmwareBinary,
 	return 0;
 }
 
-static int usbduxsub_submit_InURBs(usbduxsub_t *usbduxsub)
+static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
 {
 	int i, errFlag;
 
@@ -884,7 +884,7 @@ static int usbduxsub_submit_InURBs(usbduxsub_t *usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
+static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 {
 	int i, errFlag;
 
@@ -915,7 +915,7 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 {
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
@@ -1075,7 +1075,7 @@ static int8_t create_adc_command(unsigned int chan, int range)
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
+static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 {
 	int result, nsent;
 
@@ -1099,7 +1099,7 @@ static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
 	return result;
 }
 
-static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
+static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 {
 	int result = (-EFAULT);
 	int nrec;
@@ -1132,7 +1132,7 @@ static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	if (!this_usbduxsub)
 		return -EFAULT;
 
@@ -1177,7 +1177,7 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
 	int i, ret;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int result;
 
 	if (!this_usbduxsub)
@@ -1295,7 +1295,7 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 	lsampl_t one = 0;
 	int chan, range;
 	int err;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return 0;
@@ -1354,7 +1354,7 @@ static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1376,7 +1376,7 @@ static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
 {
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1425,7 +1425,7 @@ static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
 			     unsigned int trignum)
 {
 	int ret;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1466,7 +1466,7 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 			     comedi_cmd *cmd)
 {
 	int err = 0, tmp;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1606,7 +1606,7 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
 	int i, ret;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1744,7 +1744,7 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 				comedi_insn *insn, lsampl_t *data)
 {
 
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int err;
 
 	if (!this_usbduxsub)
@@ -1790,7 +1790,7 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
 			       comedi_insn *insn, lsampl_t *data)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int chan = insn->chanspec;
 	int err;
 
@@ -1824,7 +1824,7 @@ static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
 static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
 				comedi_insn *insn, lsampl_t *data)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int err;
 
 	if (!this_usbduxsub)
@@ -1861,7 +1861,7 @@ static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
 /***********************************/
 /* PWM */
 
-static int usbduxsub_unlink_PwmURBs(usbduxsub_t *usbduxsub_tmp)
+static int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)
 {
 	int err = 0;
 
@@ -1877,7 +1877,7 @@ static int usbduxsub_unlink_PwmURBs(usbduxsub_t *usbduxsub_tmp)
 /* This cancels a running acquisition operation
  * in any context.
  */
-static int usbdux_pwm_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
+static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -1897,7 +1897,7 @@ static int usbdux_pwm_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 /* force unlink - is called by comedi */
 static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int res = 0;
 
 	/* unlink only if it is really running */
@@ -1916,7 +1916,7 @@ static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
 	int ret;
-	usbduxsub_t *this_usbduxsub;
+	struct usbduxsub *this_usbduxsub;
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
@@ -1924,7 +1924,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	/* the private structure of the subdevice is usbduxsub_t */
+	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
 	s = this_comedidev->subdevices + SUBDEV_DA;
@@ -1982,7 +1982,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
+static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 {
 	int errFlag;
 
@@ -2011,7 +2011,7 @@ static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
 static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 			     lsampl_t period)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
@@ -2039,7 +2039,7 @@ static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
 {
 	int ret, i;
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
 		dev->minor, __func__);
@@ -2071,7 +2071,7 @@ static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
 static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
 			      int channel, lsampl_t value, lsampl_t sign)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	int i, szbuf;
 	char *pBuf;
 	char pwm_mask;
@@ -2112,7 +2112,7 @@ static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
 static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
 			    comedi_insn *insn, lsampl_t *data)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -2145,7 +2145,7 @@ static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
 static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
 			     comedi_insn *insn, lsampl_t *data)
 {
-	usbduxsub_t *this_usbduxsub = dev->private;
+	struct usbduxsub *this_usbduxsub = dev->private;
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 		/* switch it on */
@@ -2196,7 +2196,7 @@ static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
 /* end of PWM */
 /*****************************************************************/
 
-static void tidy_up(usbduxsub_t *usbduxsub_tmp)
+static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 {
 	int i;
 
@@ -2293,7 +2293,8 @@ static unsigned hex2unsigned(char *h)
 #define FIRMWARE_MAX_LEN 0x2000
 
 /* taken from David Brownell's fxload and adjusted for this driver */
-static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
+static int read_firmware(struct usbduxsub *usbduxsub, void *firmwarePtr,
+			 long size)
 {
 	struct device *dev = &usbduxsub->interface->dev;
 	int i = 0;
@@ -2645,7 +2646,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 
 static void usbduxsub_disconnect(struct usb_interface *intf)
 {
-	usbduxsub_t *usbduxsub_tmp = usb_get_intfdata(intf);
+	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
 
 	if (!usbduxsub_tmp) {
@@ -2672,7 +2673,7 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	int ret;
 	int index;
 	int i;
-	usbduxsub_t *udev;
+	struct usbduxsub *udev;
 
 	comedi_subdevice *s = NULL;
 	dev->private = NULL;
@@ -2836,7 +2837,7 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 
 static int usbdux_detach(comedi_device *dev)
 {
-	usbduxsub_t *usbduxsub_tmp;
+	struct usbduxsub *usbduxsub_tmp;
 
 	if (!dev) {
 		printk(KERN_ERR

commit 4274ea02d728f3732433782919b32895555df3ca
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 16:50:36 2008 -0800

    Staging: comedi: usbdux: remove checkpatch.pl warnings
    
    Fix up and remove almost all of the remaining checkpatch.pl errors
    and warnings in the usbdux driver.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 7172f36ecc9c..ac9f34d45de1 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -53,9 +53,11 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  * 0.94: D/A output should work now with any channel list combinations
  * 0.95: .owner commented out for kernel vers below 2.4.19
  *       sanity checks in ai/ao_cmd
- * 0.96: trying to get it working with 2.6, moved all memory alloc to comedi's attach final USB IDs
- *       moved memory allocation completely to the corresponding comedi functions
- *       firmware upload is by fxload and no longer by comedi (due to enumeration)
+ * 0.96: trying to get it working with 2.6, moved all memory alloc to comedi's
+ *       attach final USB IDs
+ *       moved memory allocation completely to the corresponding comedi
+ *       functions firmware upload is by fxload and no longer by comedi (due to
+ *       enumeration)
  * 0.97: USB IDs received, adjusted table
  * 0.98: SMP, locking, memroy alloc: moved all usb memory alloc
  *       to the usb subsystem and moved all comedi related memory
@@ -63,10 +65,12 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  *       | kernel | registration | usbdux-usb | usbdux-comedi | comedi |
  * 0.99: USB 2.0: changed protocol to isochronous transfer
  *                IRQ transfer is too buggy and too risky in 2.0
- *                for the high speed ISO transfer is now a working version available
+ *                for the high speed ISO transfer is now a working version
+ *                available
  * 0.99b: Increased the iso transfer buffer for high sp.to 10 buffers. Some VIA
  *        chipsets miss out IRQs. Deeper buffering is needed.
- * 1.00: full USB 2.0 support for the A/D converter. Now: max 8kHz sampling rate.
+ * 1.00: full USB 2.0 support for the A/D converter. Now: max 8kHz sampling
+ *       rate.
  *       Firmware vers 1.00 is needed for this.
  *       Two 16 bit up/down/reset counter with a sampling rate of 1kHz
  *       And loads of cleaning up, in particular streamlining the
@@ -144,8 +148,10 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 /* Size of one A/D value */
 #define SIZEADIN          ((sizeof(int16_t)))
 
-/* Size of the input-buffer IN BYTES */
-/* Always multiple of 8 for 8 microframes which is needed in the highspeed mode */
+/*
+ * Size of the input-buffer IN BYTES
+ * Always multiple of 8 for 8 microframes which is needed in the highspeed mode
+ */
 #define SIZEINBUF         ((8*SIZEADIN))
 
 /* 16 bytes. */
@@ -356,7 +362,7 @@ static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
  * This will cancel a running acquisition operation.
  * This is called by comedi but never from inside the driver.
  */
-static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int usbdux_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	usbduxsub_t *this_usbduxsub;
 	int res = 0;
@@ -444,8 +450,10 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		return;
 	}
 
-	/* at this point we are reasonably sure that nothing dodgy has happened */
-	/* are we running a command? */
+	/*
+	 * at this point we are reasonably sure that nothing dodgy has happened
+	 * are we running a command?
+	 */
 	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
 		/*
 		 * not running a command, do not continue execution if no
@@ -652,7 +660,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 				break;
 
 			/* pointer to the DA */
-			datap = (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
+			datap =
+			       (&(((int8_t *)urb->transfer_buffer)[i * 3 + 1]));
 			/* get the data from comedi */
 			ret = comedi_buf_get(s->async, &temp);
 			datap[0] = temp;
@@ -686,7 +695,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		urb->iso_frame_desc[0].offset = 0;
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].status = 0;
-		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
+		ret = USB_SUBMIT_URB(urb);
+		if (ret < 0) {
 			dev_err(&urb->dev->dev,
 				"comedi_: ao urb resubm failed in int-cont. "
 				"ret=%d", ret);
@@ -818,9 +828,9 @@ static int firmwareUpload(usbduxsub_t *usbduxsub, uint8_t *firmwareBinary,
 {
 	int ret;
 
-	if (!firmwareBinary) {
+	if (!firmwareBinary)
 		return 0;
-	}
+
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
@@ -878,9 +888,9 @@ static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
 {
 	int i, errFlag;
 
-	if (!usbduxsub) {
+	if (!usbduxsub)
 		return -EFAULT;
-	}
+
 	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
 		dev_dbg(&usbduxsub->interface->dev,
 			"comedi_: submitting out-urb[%d]\n", i);
@@ -906,9 +916,10 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
 	usbduxsub_t *this_usbduxsub = dev->private;
-	if (!(this_usbduxsub->probed)) {
+
+	if (!(this_usbduxsub->probed))
 		return -ENODEV;
-	}
+
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
 
@@ -947,8 +958,10 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-	/* note that mutual compatiblity is not an issue here */
+	/*
+	 * step 2: make sure trigger sources are unique and mutually compatible
+	 * note that mutual compatiblity is not an issue here
+	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 		cmd->scan_begin_src != TRIG_EXT &&
 		cmd->scan_begin_src != TRIG_TIMER)
@@ -960,7 +973,6 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 		return 2;
 
 	/* step 3: make sure arguments are trivially compatible */
-
 	if (cmd->start_arg != 0) {
 		cmd->start_arg = 0;
 		err++;
@@ -984,9 +996,9 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 			 */
 			i = 1;
 			/* find a power of 2 for the number of channels */
-			while (i < (cmd->chanlist_len)) {
+			while (i < (cmd->chanlist_len))
 				i = i * 2;
-			}
+
 			if (cmd->scan_begin_arg < (1000000 / 8 * i)) {
 				cmd->scan_begin_arg = 1000000 / 8 * i;
 				err++;
@@ -1007,9 +1019,10 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 				cmd->scan_begin_arg = 1000000;
 				err++;
 			}
-			/* calc the real sampling rate with the rounding errors */
-			tmpTimer =
-				((unsigned int)(cmd->scan_begin_arg /
+			/*
+			 * calc the real sampling rate with the rounding errors
+			 */
+			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
 					1000000)) * 1000000;
 			if (cmd->scan_begin_arg != tmpTimer) {
 				cmd->scan_begin_arg = tmpTimer;
@@ -1070,9 +1083,8 @@ static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
 #ifdef NOISY_DUX_DEBUGBUG
 	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
 		this_usbduxsub->comedidev->minor);
-	for (result = 0; result < SIZEOFDUXBUFFER; result++) {
+	for (result = 0; result < SIZEOFDUXBUFFER; result++)
 		printk(" %02x", this_usbduxsub->dux_commands[result]);
-	}
 	printk("\n");
 #endif
 	result = USB_BULK_MSG(this_usbduxsub->usbdev,
@@ -1104,11 +1116,11 @@ static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
 				"\n", this_usbduxsub->comedidev->minor, result);
 			return result;
 		}
-		if (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command) {
+		if (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command)
 			return result;
-		}
 	}
-	/* this is only reached if the data has been requested a couple of times */
+	/* this is only reached if the data has been requested a couple of
+	 * times */
 	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
 		"wrong data returned from firmware: want cmd %d, got cmd %d.\n",
 		this_usbduxsub->comedidev->minor, command,
@@ -1121,9 +1133,9 @@ static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 {
 	int ret;
 	usbduxsub_t *this_usbduxsub = dev->private;
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1209,7 +1221,8 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 		"comedi %d: sending commands to the usb device: size=%u\n",
 		dev->minor, NUMCHANNELS);
 
-	if ((result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS)) < 0) {
+	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
+	if (result < 0) {
 		up(&this_usbduxsub->sem);
 		return result;
 	}
@@ -1311,14 +1324,15 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 	this_usbduxsub->dux_commands[1] = create_adc_command(chan, range);
 
 	/* adc commands */
-	if ((err = send_dux_commands(this_usbduxsub, SENDSINGLEAD)) < 0) {
+	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		if ((err = receive_dux_commands(this_usbduxsub,
-					SENDSINGLEAD)) < 0) {
+		err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return 0;
 		}
@@ -1396,8 +1410,8 @@ static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
 		this_usbduxsub->outBuffer[chan] = data[i];
 		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
-		if ((err = send_dux_commands(this_usbduxsub,
-					SENDDACOMMANDS)) < 0) {
+		err = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);
+		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return err;
 		}
@@ -1489,10 +1503,13 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	tmp = cmd->convert_src;
 	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* in usb-2.0 only one conversion it tranmitted but with 8kHz/n */
+		/*
+		 * in usb-2.0 only one conversion it tranmitted but with 8kHz/n
+		 */
 		cmd->convert_src &= TRIG_TIMER;
 	} else {
-		/* all conversion events happen simultaneously with a rate of 1kHz/n */
+		/* all conversion events happen simultaneously with a rate of
+		 * 1kHz/n */
 		cmd->convert_src &= TRIG_NOW;
 	}
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -1513,8 +1530,10 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-	/* note that mutual compatiblity is not an issue here */
+	/*
+	 * step 2: make sure trigger sources are unique and mutually compatible
+	 * note that mutual compatiblity is not an issue here
+	 */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 		cmd->scan_begin_src != TRIG_EXT &&
 		cmd->scan_begin_src != TRIG_TIMER)
@@ -1751,12 +1770,13 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 
 	/* This command also tells the firmware to return */
 	/* the digital input lines */
-	if ((err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND)) < 0) {
+	err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
-	if ((err = receive_dux_commands(this_usbduxsub,
-				SENDDIOBITSCOMMAND)) < 0) {
+	err = receive_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
@@ -1784,13 +1804,14 @@ static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
 		return -ENODEV;
 	}
 
-	if ((err = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND)) < 0) {
+	err = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
 
-	if ((err = receive_dux_commands(this_usbduxsub,
-				READCOUNTERCOMMAND)) < 0) {
+	err = receive_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
@@ -1819,7 +1840,8 @@ static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
 	this_usbduxsub->dux_commands[1] = insn->chanspec;
 	*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);
 
-	if ((err = send_dux_commands(this_usbduxsub, WRITECOUNTERCOMMAND)) < 0) {
+	err = send_dux_commands(this_usbduxsub, WRITECOUNTERCOMMAND);
+	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
@@ -1884,7 +1906,8 @@ static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi %d: sending pwm off command to the usb device.\n",
 		dev->minor);
-	if ((res = send_dux_commands(this_usbduxsub, SENDPWMOFF)) < 0)
+	res = send_dux_commands(this_usbduxsub, SENDPWMOFF);
+	if (res < 0)
 		return res;
 
 	return res;
@@ -1943,7 +1966,8 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	urb->dev = this_usbduxsub->usbdev;
 	urb->status = 0;
 	if (this_usbduxsub->pwm_cmd_running) {
-		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
+		ret = USB_SUBMIT_URB(urb);
+		if (ret < 0) {
 			dev_err(&this_usbduxsub->interface->dev,
 				"comedi_: pwm urb resubm failed in int-cont. "
 				"ret=%d", ret);
@@ -2011,9 +2035,8 @@ static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-
 /* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
+static int usbdux_pwm_start(comedi_device *dev, comedi_subdevice *s)
 {
 	int ret, i;
 	usbduxsub_t *this_usbduxsub = dev->private;
@@ -2027,13 +2050,13 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 	}
 
 	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwmDelay);
-	if ((ret = send_dux_commands(this_usbduxsub, SENDPWMON)) < 0) {
+	ret = send_dux_commands(this_usbduxsub, SENDPWMON);
+	if (ret < 0)
 		return ret;
-	}
+
 	/* initalise the buffer */
-	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++) {
+	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
 		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
-	}
 
 	this_usbduxsub->pwm_cmd_running = 1;
 	ret = usbduxsub_submit_PwmURBs(this_usbduxsub);
@@ -2044,19 +2067,20 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-
 /* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(comedi_device * dev, comedi_subdevice * s,
+static int usbdux_pwm_pattern(comedi_device *dev, comedi_subdevice *s,
 			      int channel, lsampl_t value, lsampl_t sign)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int i, szbuf;
 	char *pBuf;
-	char pwm_mask,sgn_mask,c;
+	char pwm_mask;
+	char sgn_mask;
+	char c;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	/* this is the DIO bit which carries the PWM data */
 	pwm_mask = (1 << channel);
 	/* this is the DIO bit which carries the optional direction bit */
@@ -2085,24 +2109,27 @@ static int usbdux_pwm_pattern(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int usbdux_pwm_write(comedi_device * dev, comedi_subdevice * s,
-			    comedi_insn * insn, lsampl_t * data)
+static int usbdux_pwm_write(comedi_device *dev, comedi_subdevice *s,
+			    comedi_insn *insn, lsampl_t *data)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
 
-	if ((insn->n)!=1) {
-		/* doesn't make sense to have more than one value here */
-		/* because it would just overwrite the PWM buffer a couple of times */
+	if ((insn->n) != 1) {
+		/*
+		 * doesn't make sense to have more than one value here because
+		 * it would just overwrite the PWM buffer a couple of times
+		 */
 		return -EINVAL;
 	}
 
-	/* the sign is set via a special INSN only, this gives us 8 bits for */
-	/* normal operation */
-	/* relay sign 0 by default */
+	/*
+	 * the sign is set via a special INSN only, this gives us 8 bits for
+	 * normal operation
+	 * relay sign 0 by default
+	 */
 	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
 				  data[0], 0);
 }
@@ -2189,15 +2216,11 @@ static void tidy_up(usbduxsub_t *usbduxsub_tmp)
 			usbduxsub_unlink_InURBs(usbduxsub_tmp);
 		}
 		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
-			if (usbduxsub_tmp->urbIn[i]->transfer_buffer) {
-				kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
-				usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
-			}
-			if (usbduxsub_tmp->urbIn[i]) {
-				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
-				usb_free_urb(usbduxsub_tmp->urbIn[i]);
-				usbduxsub_tmp->urbIn[i] = NULL;
-			}
+			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
+			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
+			usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+			usb_free_urb(usbduxsub_tmp->urbIn[i]);
+			usbduxsub_tmp->urbIn[i] = NULL;
 		}
 		kfree(usbduxsub_tmp->urbIn);
 		usbduxsub_tmp->urbIn = NULL;
@@ -2311,7 +2334,10 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 		buf[j] = 0;
 		/* dev_dbg(dev, "comedi_: buf=%s\n", buf); */
 
-		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
+		/*
+		 * EXTENSION:
+		 * "# comment-till-end-of-line", for copyrights etc
+		 */
 		if (buf[0] == '#')
 			continue;
 
@@ -2580,7 +2606,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 
 	/* pwm */
 	if (usbduxsub[index].high_speed) {
-		usbduxsub[index].sizePwmBuf = 512;	/* max bulk ep size in high speed */
+		/* max bulk ep size in high speed */
+		usbduxsub[index].sizePwmBuf = 512;
 		usbduxsub[index].urbPwm = USB_ALLOC_URB(0);
 		if (usbduxsub[index].urbPwm == NULL) {
 			dev_err(dev, "comedi_: usbdux%d: "
@@ -2651,7 +2678,8 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of the usb */
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
 	index = -1;
 	for (i = 0; i < NUMUSBDUX; i++) {
 		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
@@ -2691,7 +2719,8 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	}
 
 	/* allocate space for the subdevices */
-	if ((ret = alloc_subdevices(dev, dev->n_subdevices)) < 0) {
+	ret = alloc_subdevices(dev, dev->n_subdevices);
+	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: error alloc space for subdev\n", dev->minor);
 		up(&start_stop_sem);

commit c0e0c26e6b877d91af0477cd965ddad4835d2905
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 16:18:40 2008 -0800

    Staging: comedi: usbdux: fix up printk calls
    
    printk() needs a KERN_ level.  But it's usually better to just
    use the dev_* functions instead, as they provide much better
    information to the user and developer.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index ba4e3fdc9bf1..7172f36ecc9c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -318,10 +318,9 @@ static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
 				 * cancelled. */
 				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
 			}
-#ifdef NOISY_DUX_DEBUGBUG
-			printk("comedi: usbdux: unlinked InURB %d, err=%d\n",
+			dev_dbg(&usbduxsub_tmp->interface->dev,
+				"comedi: usbdux: unlinked InURB %d, err=%d\n",
 				i, err);
-#endif
 		}
 	}
 	return err;
@@ -337,12 +336,11 @@ static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 	int ret = 0;
 
 	if (!this_usbduxsub) {
-		printk("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
 		return -EFAULT;
 	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi: usbdux_ai_stop\n");
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");
 
 	if (do_unlink) {
 		/* stop aquistion */
@@ -364,14 +362,12 @@ static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 	int res = 0;
 
 	/* force unlink of all urbs */
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi: usbdux_ai_cancel\n");
-#endif
 	this_usbduxsub = dev->private;
-	if (!this_usbduxsub) {
-		printk("comedi: usbdux_ai_cancel: this_usbduxsub=NULL\n");
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_cancel\n");
+
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
@@ -392,24 +388,10 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
-	/* sanity checks */
-	/* is the urb there? */
-	if (!urb) {
-		printk("comedi_: usbdux_: ao int-handler called with urb=NULL!\n");
-		return;
-	}
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	if (unlikely(!this_comedidev)) {
-		printk("comedi_: usbdux_: BUG! urb context is a NULL pointer!\n");
-		return;
-	}
 	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
-	if (unlikely(!this_usbduxsub)) {
-		printk("comedi_: usbdux_: BUG! private of comedi subdev is a NULL pointer!\n");
-		return;
-	}
 	/* subdevice which is the AD converter */
 	s = this_comedidev->subdevices + SUBDEV_AD;
 
@@ -424,10 +406,9 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		/* error in the ISOchronous data */
 		/* we don't copy the data into the transfer buffer */
 		/* and recycle the last data byte */
-#ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi%d: usbdux: CRC error in ISO IN stream.\n",
+		dev_dbg(&urb->dev->dev,
+			"comedi%d: usbdux: CRC error in ISO IN stream.\n",
 			this_usbduxsub->comedidev->minor);
-#endif
 
 		break;
 
@@ -451,7 +432,9 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 		/* a real error on the bus */
 		/* pass error to comedi if we are really running a command */
 		if (this_usbduxsub->ai_cmd_running) {
-			printk("Non-zero urb status received in ai intr context: %d\n", urb->status);
+			dev_err(&urb->dev->dev,
+				"Non-zero urb status received in ai intr "
+				"context: %d\n", urb->status);
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(this_usbduxsub->comedidev, s);
@@ -476,11 +459,13 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	/* resubmit the urb */
 	err = USB_SUBMIT_URB(urb);
 	if (unlikely(err < 0)) {
-		printk("comedi_: usbdux_: urb resubmit failed in int-context! err=%d ", err);
+		dev_err(&urb->dev->dev,
+			"comedi_: urb resubmit failed in int-context! err=%d\n",
+			err);
 		if (err == -EL2NSYNC)
-			printk("--> buggy USB host controller or bug in IRQ handler!\n");
-		else
-			printk("\n");
+			dev_err(&urb->dev->dev,
+				"buggy USB host controller or bug in IRQ "
+				"handler!\n");
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(this_usbduxsub->comedidev, s);
@@ -539,10 +524,9 @@ static int usbduxsub_unlink_OutURBs(usbduxsub_t *usbduxsub_tmp)
 			if (usbduxsub_tmp->urbOut[i])
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
 
-#ifdef NOISY_DUX_DEBUGBUG
-			printk("comedi: usbdux: unlinked OutURB %d: res=%d\n",
+			dev_dbg(&usbduxsub_tmp->interface->dev,
+				"comedi: usbdux: unlinked OutURB %d: res=%d\n",
 				i, err);
-#endif
 		}
 	}
 	return err;
@@ -555,15 +539,10 @@ static int usbdux_ao_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
-	if (!this_usbduxsub) {
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi?: usbdux_ao_stop: this_usbduxsub=NULL!\n");
-#endif
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi: usbdux_ao_cancel\n");
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");
+
 	if (do_unlink)
 		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
 
@@ -578,10 +557,9 @@ static int usbdux_ao_cancel(comedi_device *dev, comedi_subdevice *s)
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int res = 0;
 
-	if (!this_usbduxsub) {
-		printk("comedi: usbdux_ao_cancel: this_usbduxsub=NULL\n");
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	/* prevent other CPUs from submitting a command just now */
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
@@ -602,22 +580,10 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
-	if (!urb) {
-		printk("comedi_: usbdux_: ao urb handler called with NULL ptr.\n");
-		return;
-	}
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	if (!this_comedidev) {
-		printk("comedi_: usbdux_: ao urb int-context is a NULL pointer.\n");
-		return;
-	}
 	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
-	if (!this_usbduxsub) {
-		printk("comedi_: usbdux_: private data structure of ao subdev is NULL p.\n");
-		return;
-	}
 
 	s = this_comedidev->subdevices + SUBDEV_DA;
 
@@ -642,7 +608,9 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	default:
 		/* a real error */
 		if (this_usbduxsub->ao_cmd_running) {
-			printk("comedi_: usbdux_: Non-zero urb status received in ao intr context: %d\n", urb->status);
+			dev_err(&urb->dev->dev,
+				"comedi_: Non-zero urb status received in ao "
+				"intr context: %d\n", urb->status);
 			s->async->events |= COMEDI_CB_ERROR;
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(this_usbduxsub->comedidev, s);
@@ -693,7 +661,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 			/* printk("data[0]=%x, data[1]=%x, data[2]=%x\n", */
 			/* datap[0],datap[1],datap[2]); */
 			if (ret < 0) {
-				printk("comedi: usbdux: buffer underflow\n");
+				dev_err(&urb->dev->dev,
+					"comedi: buffer underflow\n");
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_OVERFLOW;
 			}
@@ -718,12 +687,13 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].status = 0;
 		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
-			printk("comedi_: usbdux_: ao urb resubm failed in int-cont.");
-			printk("ret=%d", ret);
+			dev_err(&urb->dev->dev,
+				"comedi_: ao urb resubm failed in int-cont. "
+				"ret=%d", ret);
 			if (ret == EL2NSYNC)
-				printk("--> buggy USB host controller or bug in IRQ handling!\n");
-			else
-				printk("\n");
+				dev_err(&urb->dev->dev,
+					"buggy USB host controller or bug in "
+					"IRQ handling!\n");
 
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
@@ -760,7 +730,8 @@ static int usbduxsub_start(usbduxsub_t *usbduxsub)
 			/* Timeout */
 			EZTIMEOUT);
 		if (errcode < 0) {
-			printk("comedi_: usbdux_: control msg failed (start)\n");
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: control msg failed (start)\n");
 			return errcode;
 		}
 	}
@@ -791,7 +762,8 @@ static int usbduxsub_stop(usbduxsub_t *usbduxsub)
 			/* Timeout */
 			EZTIMEOUT);
 		if (errcode < 0) {
-			printk("comedi_: usbdux: control msg failed (stop)\n");
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: control msg failed (stop)\n");
 			return errcode;
 		}
 	}
@@ -805,12 +777,11 @@ static int usbduxsub_upload(usbduxsub_t *usbduxsub,
 	int errcode;
 
 	if (usbduxsub->probed) {
-#ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi%d: usbdux: uploading %d bytes",
-			usbduxsub->comedidev->minor, len);
-		printk(" to addr %d, first byte=%d.\n",
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi%d: usbdux: uploading %d bytes"
+			" to addr %d, first byte=%d.\n",
+			usbduxsub->comedidev->minor, len,
 			startAddr, local_transfer_buffer[0]);
-#endif
 		errcode = USB_CONTROL_MSG
 			(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
@@ -828,11 +799,11 @@ static int usbduxsub_upload(usbduxsub_t *usbduxsub,
 			len,
 			/* timeout */
 			EZTIMEOUT);
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi_: usbdux: result=%d\n", errcode);
-#endif
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi_: result=%d\n", errcode);
 		if (errcode < 0) {
-			printk("comedi_: usbdux: uppload failed\n");
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: upload failed\n");
 			return errcode;
 		}
 	} else {
@@ -852,17 +823,20 @@ static int firmwareUpload(usbduxsub_t *usbduxsub, uint8_t *firmwareBinary,
 	}
 	ret = usbduxsub_stop(usbduxsub);
 	if (ret < 0) {
-		printk("comedi_: usbdux: can not stop firmware\n");
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: can not stop firmware\n");
 		return ret;
 	}
 	ret = usbduxsub_upload(usbduxsub, firmwareBinary, 0, sizeFirmware);
 	if (ret < 0) {
-		printk("comedi_: usbdux: firmware upload failed\n");
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: firmware upload failed\n");
 		return ret;
 	}
 	ret = usbduxsub_start(usbduxsub);
 	if (ret < 0) {
-		printk("comedi_: usbdux: can not start firmware\n");
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: can not start firmware\n");
 		return ret;
 	}
 	return 0;
@@ -883,14 +857,17 @@ static int usbduxsub_submit_InURBs(usbduxsub_t *usbduxsub)
 		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urbIn[i]->status = 0;
 		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: usbdux: submitting in-urb[%d]: %p,%p intv=%d\n", usbduxsub->comedidev->minor, i, (usbduxsub->urbIn[i]->context), (usbduxsub->urbIn[i]->dev), (usbduxsub->urbIn[i]->interval));
-#endif
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",
+			usbduxsub->comedidev->minor, i,
+			(usbduxsub->urbIn[i]->context),
+			(usbduxsub->urbIn[i]->dev),
+			(usbduxsub->urbIn[i]->interval));
 		errFlag = USB_SUBMIT_URB(usbduxsub->urbIn[i]);
 		if (errFlag) {
-			printk("comedi_: usbdux: ai: ");
-			printk("USB_SUBMIT_URB(%d)", i);
-			printk(" error %d\n", errFlag);
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: ai: USB_SUBMIT_URB(%d) error %d\n",
+				i, errFlag);
 			return errFlag;
 		}
 	}
@@ -905,9 +882,8 @@ static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
 		return -EFAULT;
 	}
 	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi_: usbdux: submitting out-urb[%d]\n", i);
-#endif
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi_: submitting out-urb[%d]\n", i);
 		/* in case of a resubmission after an unlink... */
 		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
 		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
@@ -915,9 +891,9 @@ static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
 		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
 		errFlag = USB_SUBMIT_URB(usbduxsub->urbOut[i]);
 		if (errFlag) {
-			printk("comedi_: usbdux: ao: ");
-			printk("USB_SUBMIT_URB(%d)", i);
-			printk(" error %d\n", errFlag);
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: ao: USB_SUBMIT_URB(%d) error %d\n",
+				i, errFlag);
 			return errFlag;
 		}
 	}
@@ -933,9 +909,9 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	if (!(this_usbduxsub->probed)) {
 		return -ENODEV;
 	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_ai_cmdtest\n", dev->minor);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
+
 	/* make sure triggers are valid */
 	/* Only immediate triggers are allowed */
 	tmp = cmd->start_src;
@@ -1092,7 +1068,7 @@ static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
 
 	this_usbduxsub->dux_commands[0] = cmd_type;
 #ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux: dux_commands: ",
+	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
 		this_usbduxsub->comedidev->minor);
 	for (result = 0; result < SIZEOFDUXBUFFER; result++) {
 		printk(" %02x", this_usbduxsub->dux_commands[result]);
@@ -1104,7 +1080,9 @@ static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
 			COMMAND_OUT_EP),
 		this_usbduxsub->dux_commands, SIZEOFDUXBUFFER, &nsent, 10 * HZ);
 	if (result < 0)
-		printk("comedi%d: could not transmit dux_command to the usb-device, err=%d\n", this_usbduxsub->comedidev->minor, result);
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+			"could not transmit dux_command to the usb-device, "
+			"err=%d\n", this_usbduxsub->comedidev->minor, result);
 
 	return result;
 }
@@ -1121,7 +1099,9 @@ static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
 				COMMAND_IN_EP),
 			this_usbduxsub->insnBuffer, SIZEINSNBUF, &nrec, 1 * HZ);
 		if (result < 0) {
-			printk("comedi%d: insn: USB error %d while receiving DUX command\n", this_usbduxsub->comedidev->minor, result);
+			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+				"insn: USB error %d while receiving DUX command"
+				"\n", this_usbduxsub->comedidev->minor, result);
 			return result;
 		}
 		if (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command) {
@@ -1129,7 +1109,10 @@ static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
 		}
 	}
 	/* this is only reached if the data has been requested a couple of times */
-	printk("comedi%d: insn: wrong data returned from firmware: want cmd %d, got cmd %d.\n", this_usbduxsub->comedidev->minor, command, le16_to_cpu(this_usbduxsub->insnBuffer[0]));
+	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
+		"wrong data returned from firmware: want cmd %d, got cmd %d.\n",
+		this_usbduxsub->comedidev->minor, command,
+		le16_to_cpu(this_usbduxsub->insnBuffer[0]));
 	return -EFAULT;
 }
 
@@ -1146,12 +1129,12 @@ static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_ai_inttrig\n", dev->minor);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_inttrig\n", dev->minor);
 
 	if (trignum != 0) {
-		printk("comedi%d: usbdux_ai_inttrig: invalid trignum\n",
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
 			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
@@ -1160,14 +1143,17 @@ static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 		this_usbduxsub->ai_cmd_running = 1;
 		ret = usbduxsub_submit_InURBs(this_usbduxsub);
 		if (ret < 0) {
-			printk("comedi%d: usbdux_ai_inttrig: urbSubmit: err=%d\n", dev->minor, ret);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux_ai_inttrig: "
+				"urbSubmit: err=%d\n", dev->minor, ret);
 			this_usbduxsub->ai_cmd_running = 0;
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		printk("comedi%d: ai_inttrig but acqu is already running\n",
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ai_inttrig but acqu is already running\n",
 			dev->minor);
 	}
 	up(&this_usbduxsub->sem);
@@ -1182,12 +1168,12 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int result;
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_ai_cmd\n", dev->minor);
-#endif
 	if (!this_usbduxsub)
 		return -EFAULT;
 
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_cmd\n", dev->minor);
+
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 
@@ -1196,7 +1182,9 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 		return -ENODEV;
 	}
 	if (this_usbduxsub->ai_cmd_running) {
-		printk("comedi%d: ai_cmd not possible. Another ai_cmd is running.\n", dev->minor);
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+			"ai_cmd not possible. Another ai_cmd is running.\n",
+			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
@@ -1208,17 +1196,19 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 		chan = CR_CHAN(cmd->chanlist[i]);
 		range = CR_RANGE(cmd->chanlist[i]);
 		if (i >= NUMCHANNELS) {
-			printk("comedi%d: channel list too long\n", dev->minor);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: channel list too long\n",
+				dev->minor);
 			break;
 		}
 		this_usbduxsub->dux_commands[i + 2] =
 			create_adc_command(chan, range);
 	}
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi %d: sending commands to the usb device: ", dev->minor);
-	printk("size=%u\n", NUMCHANNELS);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi %d: sending commands to the usb device: size=%u\n",
+		dev->minor, NUMCHANNELS);
+
 	if ((result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS)) < 0) {
 		up(&this_usbduxsub->sem);
 		return result;
@@ -1244,7 +1234,10 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
 	}
 	if (this_usbduxsub->ai_timer < 1) {
-		printk("comedi%d: usbdux: ai_cmd: timer=%d, scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, this_usbduxsub->ai_timer, cmd->scan_begin_arg);
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: ai_cmd: "
+			"timer=%d, scan_begin_arg=%d. "
+			"Not properly tested by cmdtest?\n", dev->minor,
+			this_usbduxsub->ai_timer, cmd->scan_begin_arg);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
@@ -1291,21 +1284,22 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 	int err;
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
-		printk("comedi%d: ai_insn_read: no usb dev.\n", dev->minor);
+	if (!this_usbduxsub)
 		return 0;
-	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
 		dev->minor, insn->n, insn->subdev);
-#endif
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
 	if (this_usbduxsub->ai_cmd_running) {
-		printk("comedi%d: ai_insn_read not possible. Async Command is running.\n", dev->minor);
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ai_insn_read not possible. "
+			"Async Command is running.\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
@@ -1370,28 +1364,30 @@ static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
 	int chan = CR_CHAN(insn->chanspec);
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: ao_insn_write\n", dev->minor);
-#endif
 	if (!this_usbduxsub)
 		return -EFAULT;
 
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: ao_insn_write\n", dev->minor);
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
 	if (this_usbduxsub->ao_cmd_running) {
-		printk("comedi%d: ao_insn_write: ERROR: asynchronous ao_cmd is running\n", dev->minor);
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_insn_write: "
+			"ERROR: asynchronous ao_cmd is running\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
 			dev->minor, chan, i, data[i]);
-#endif
+
 		/* number of channels: 1 */
 		this_usbduxsub->dux_commands[1] = 1;
 		/* one 16 bit value */
@@ -1426,7 +1422,8 @@ static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
 		return -ENODEV;
 	}
 	if (trignum != 0) {
-		printk("comedi%d: usbdux_ao_inttrig: invalid trignum\n",
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
 			dev->minor);
 		return -EINVAL;
 	}
@@ -1434,14 +1431,17 @@ static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
 		this_usbduxsub->ao_cmd_running = 1;
 		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
 		if (ret < 0) {
-			printk("comedi%d: usbdux_ao_inttrig: submitURB: err=%d\n", dev->minor, ret);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux_ao_inttrig: submitURB: "
+				"err=%d\n", dev->minor, ret);
 			this_usbduxsub->ao_cmd_running = 0;
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		printk("comedi%d: ao_inttrig but acqu is already running.\n",
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_inttrig but acqu is already running.\n",
 			dev->minor);
 	}
 	up(&this_usbduxsub->sem);
@@ -1460,9 +1460,9 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_ao_cmdtest\n", dev->minor);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
+
 	/* make sure triggers are valid */
 	/* Only immediate triggers are allowed */
 	tmp = cmd->start_src;
@@ -1571,9 +1571,10 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 		}
 	}
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: err=%d, scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src, cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: err=%d, "
+		"scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, "
+		"convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src,
+		cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
 
 	if (err)
 		return 3;
@@ -1596,9 +1597,8 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_ao_cmd\n", dev->minor);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: %s\n", dev->minor, __func__);
 
 	/* set current channel of the running aquisition to zero */
 	s->async->cur_chan = 0;
@@ -1606,14 +1606,15 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 		chan = CR_CHAN(cmd->chanlist[i]);
 		gain = CR_RANGE(cmd->chanlist[i]);
 		if (i >= NUMOUTCHANNELS) {
-			printk("comedi%d: usbdux_ao_cmd: channel list too long\n", dev->minor);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: %s: channel list too long\n",
+				dev->minor, __func__);
 			break;
 		}
 		this_usbduxsub->dac_commands[i] = (chan << 6);
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: dac command for ch %d is %x\n",
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: dac command for ch %d is %x\n",
 			dev->minor, i, this_usbduxsub->dac_commands[i]);
-#endif
 	}
 
 	/* we count in steps of 1ms (125us) */
@@ -1626,13 +1627,21 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 		/* 1ms */
 		/* timing of the scan: we get all channels at once */
 		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: usbdux: scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, convert_arg=%d\n", dev->minor, cmd->scan_begin_src, cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
-		printk("comedi%d: usbdux: ao_timer=%d (ms)\n",
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: scan_begin_src=%d, scan_begin_arg=%d, "
+			"convert_src=%d, convert_arg=%d\n", dev->minor,
+			cmd->scan_begin_src, cmd->scan_begin_arg,
+			cmd->convert_src, cmd->convert_arg);
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_timer=%d (ms)\n",
 			dev->minor, this_usbduxsub->ao_timer);
-#endif
 		if (this_usbduxsub->ao_timer < 1) {
-			printk("comedi%d: usbdux: ao_timer=%d,  scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, this_usbduxsub->ao_timer, cmd->scan_begin_arg);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux: ao_timer=%d, "
+				"scan_begin_arg=%d. "
+				"Not properly tested by cmdtest?\n",
+				dev->minor, this_usbduxsub->ao_timer,
+				cmd->scan_begin_arg);
 			up(&this_usbduxsub->sem);
 			return -EINVAL;
 		}
@@ -1837,9 +1846,8 @@ static int usbduxsub_unlink_PwmURBs(usbduxsub_t *usbduxsub_tmp)
 	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
 		if (usbduxsub_tmp->urbPwm)
 			usb_kill_urb(usbduxsub_tmp->urbPwm);
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi: usbdux: unlinked PwmURB: res=%d\n", err);
-#endif
+		dev_dbg(&usbduxsub_tmp->interface->dev,
+			"comedi: unlinked PwmURB: res=%d\n", err);
 	}
 	return err;
 }
@@ -1851,15 +1859,10 @@ static int usbdux_pwm_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
-	if (!this_usbduxsub) {
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi?: usbdux_pwm_stop: this_usbduxsub=NULL!\n");
-#endif
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi: usbdux_pwm_cancel\n");
-#endif
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);
 	if (do_unlink)
 		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
 
@@ -1878,10 +1881,9 @@ static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
 	/* unlink only if it is really running */
 	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi %d: sending pwm off command to the usb device.\n",
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi %d: sending pwm off command to the usb device.\n",
 		dev->minor);
-#endif
 	if ((res = send_dux_commands(this_usbduxsub, SENDPWMOFF)) < 0)
 		return res;
 
@@ -1895,24 +1897,12 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
-	/* printk("PWM: IRQ\n"); */
+	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
 
-	if (!urb) {
-		printk("comedi_: usbdux_: pwm urb handler called with NULL ptr.\n");
-		return;
-	}
 	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
-	if (!this_comedidev) {
-		printk("comedi_: usbdux_: pwm urb int-context is a NULL pointer.\n");
-		return;
-	}
 	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
-	if (!this_usbduxsub) {
-		printk("comedi_: usbdux_: private data structure of pwm subdev is NULL p.\n");
-		return;
-	}
 
 	s = this_comedidev->subdevices + SUBDEV_DA;
 
@@ -1937,7 +1927,9 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	default:
 		/* a real error */
 		if (this_usbduxsub->pwm_cmd_running) {
-			printk("comedi_: usbdux_: Non-zero urb status received in pwm intr context: %d\n", urb->status);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi_: Non-zero urb status received in "
+				"pwm intr context: %d\n", urb->status);
 			usbdux_pwm_stop(this_usbduxsub, 0);
 		}
 		return;
@@ -1952,12 +1944,13 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	urb->status = 0;
 	if (this_usbduxsub->pwm_cmd_running) {
 		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
-			printk("comedi_: usbdux_: pwm urb resubm failed in int-cont.");
-			printk("ret=%d", ret);
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi_: pwm urb resubm failed in int-cont. "
+				"ret=%d", ret);
 			if (ret == EL2NSYNC)
-				printk("--> buggy USB host controller or bug in IRQ handling!\n");
-			else
-				printk("\n");
+				dev_err(&this_usbduxsub->interface->dev,
+					"buggy USB host controller or bug in "
+					"IRQ handling!\n");
 
 			/* don't do an unlink here */
 			usbdux_pwm_stop(this_usbduxsub, 0);
@@ -1972,11 +1965,9 @@ static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
 	if (!usbduxsub)
 		return -EFAULT;
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi_: usbdux: submitting pwm-urb\n");
-#endif
-	/* in case of a resubmission after an unlink... */
+	dev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");
 
+	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(usbduxsub->urbPwm,
 		usbduxsub->usbdev,
 		usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
@@ -1985,9 +1976,9 @@ static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
 
 	errFlag = USB_SUBMIT_URB(usbduxsub->urbPwm);
 	if (errFlag) {
-		printk("comedi_: usbdux: pwm: ");
-		printk("USB_SUBMIT_URB");
-		printk(" error %d\n", errFlag);
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: usbdux: pwm: USB_SUBMIT_URB error %d\n",
+			errFlag);
 		return errFlag;
 	}
 	return 0;
@@ -2000,21 +1991,23 @@ static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
-		printk("comedi%d: illegal period setting for pwm.\n", dev->minor);
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: illegal period setting for pwm.\n",
+			dev->minor);
 		return -EAGAIN;
 	} else {
 		fx2delay = period / ((int)(6*512*(1.0/0.033))) - 6;
 		if (fx2delay > 255) {
-			printk("comedi%d: period %d for pwm is too low.\n",
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: period %d for pwm is too low.\n",
 			       dev->minor, period);
 			return -EAGAIN;
 		}
 	}
 	this_usbduxsub->pwmDelay = fx2delay;
 	this_usbduxsub->pwmPeriod = period;
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("usbdux_pwm_period: frequ=%d, period=%d\n", period, fx2delay);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",
+		__func__, period, fx2delay);
 	return 0;
 }
 
@@ -2025,9 +2018,9 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 	int ret, i;
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-#ifdef NOISY_DUX_DEBUGBUG
-	printk("comedi%d: usbdux_pwm_start\n", dev->minor);
-#endif
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
+		dev->minor, __func__);
+
 	if (this_usbduxsub->pwm_cmd_running) {
 		/* already running */
 		return 0;
@@ -2128,11 +2121,9 @@ static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
 	usbduxsub_t *this_usbduxsub = dev->private;
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
-#ifdef NOISY_DUX_DEBUGBUG
 		/* switch it on */
-		printk("comedi%d: pwm_insn_config: pwm on\n",
-		       dev->minor);
-#endif
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: pwm on\n", dev->minor, __func__);
 		/*
 		 * if not zero the PWM is limited to a certain time which is
 		 * not supported here
@@ -2141,10 +2132,8 @@ static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
 			return -EINVAL;
 		return usbdux_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: pwm_insn_config: pwm off\n",
-		       dev->minor);
-#endif
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: pwm off\n", dev->minor, __func__);
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
 		/*
@@ -2154,10 +2143,8 @@ static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
 		data[1] = this_usbduxsub->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
-#ifdef NOISY_DUX_DEBUGBUG
-		printk("comedi%d: pwm_insn_config: setting period\n",
-		       dev->minor);
-#endif
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: setting period\n", dev->minor, __func__);
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
 		data[1] = this_usbduxsub->pwmPeriod;
@@ -2186,11 +2173,9 @@ static void tidy_up(usbduxsub_t *usbduxsub_tmp)
 {
 	int i;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux: tiding up\n");
-#endif
 	if (!usbduxsub_tmp)
 		return;
+	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi_: tiding up\n");
 
 	/* shows the usb subsystem that the driver is down */
 	if (usbduxsub_tmp->interface)
@@ -2287,6 +2272,7 @@ static unsigned hex2unsigned(char *h)
 /* taken from David Brownell's fxload and adjusted for this driver */
 static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 {
+	struct device *dev = &usbduxsub->interface->dev;
 	int i = 0;
 	unsigned char *fp = (char *)firmwarePtr;
 	unsigned char *firmwareBinary = NULL;
@@ -2295,7 +2281,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 
 	firmwareBinary = kzalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
 	if (!firmwareBinary) {
-		printk("comedi_: usbdux: mem alloc for firmware failed\n");
+		dev_err(dev, "comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
 
@@ -2312,7 +2298,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 			i++;
 			j++;
 			if (j >= sizeof(buf)) {
-				printk("comedi_: usbdux: bogus firmware file!\n");
+				dev_err(dev, "comedi_: bogus firmware file!\n");
 				return -1;
 			}
 		}
@@ -2323,14 +2309,15 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 		}
 
 		buf[j] = 0;
-		/*printk("comedi_: buf=%s\n",buf); */
+		/* dev_dbg(dev, "comedi_: buf=%s\n", buf); */
 
 		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
 		if (buf[0] == '#')
 			continue;
 
 		if (buf[0] != ':') {
-			printk("comedi_: usbdux: upload: not an ihex record: %s", buf);
+			dev_err(dev, "comedi_: upload: not an ihex record: %s",
+				buf);
 			return -EFAULT;
 		}
 
@@ -2345,10 +2332,11 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 
 
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
-			printk("comedi_: usbdux: firmware upload goes beyond FX2 RAM boundaries.");
+			dev_err(dev, "comedi_: firmware upload goes "
+				"beyond FX2 RAM boundaries.\n");
 			return -EFAULT;
 		}
-		/*printk("comedi_: usbdux: off=%x, len=%x:",off,len); */
+		/* dev_dbg(dev, "comedi_: off=%x, len=%x:\n", off, len); */
 
 		/* Read the record type */
 		type = hex2unsigned(buf + 7);
@@ -2359,7 +2347,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 
 
 		if (type != 0) {
-			printk("comedi_: usbdux: unsupported record type: %u\n",
+			dev_err(dev, "comedi_: unsupported record type: %u\n",
 				type);
 			return -EFAULT;
 		}
@@ -2371,7 +2359,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 		/*printk("\n"); */
 
 		if (i >= size) {
-			printk("comedi_: usbdux: unexpected end of hex file\n");
+			dev_err(dev, "comedi_: unexpected end of hex file\n");
 			break;
 		}
 
@@ -2383,15 +2371,16 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 
 /* allocate memory for the urbs and initialise them */
 static int usbduxsub_probe(struct usb_interface *uinterf,
-	const struct usb_device_id *id)
+			   const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
+	struct device *dev = &uinterf->dev;
 	int i;
 	int index;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux_: finding a free structure for the usb-device\n");
-#endif
+	dev_dbg(dev, "comedi_: usbdux_: "
+		"finding a free structure for the usb-device\n");
+
 	down(&start_stop_sem);
 	/* look for a free place in the usbdux array */
 	index = -1;
@@ -2404,13 +2393,12 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 
 	/* no more space */
 	if (index == -1) {
-		printk("Too many usbdux-devices connected.\n");
+		dev_err(dev, "Too many usbdux-devices connected.\n");
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-EMFILE);
 	}
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux: usbduxsub[%d] is ready to connect to comedi.\n", index);
-#endif
+	dev_dbg(dev, "comedi_: usbdux: "
+		"usbduxsub[%d] is ready to connect to comedi.\n", index);
 
 	init_MUTEX(&(usbduxsub[index].sem));
 	/* save a pointer to the usb device */
@@ -2424,9 +2412,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* will be needed for disconnect */
 	usb_set_intfdata(uinterf, &(usbduxsub[index]));
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
-#endif
+	dev_dbg(dev, "comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
+
 	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
 		(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
@@ -2434,7 +2421,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	if (!usbduxsub[index].dac_commands) {
-		printk("comedi_: usbdux: error alloc space for dac commands\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2442,7 +2430,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* create space for the commands going to the usb device */
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!usbduxsub[index].dux_commands) {
-		printk("comedi_: usbdux: error alloc space for dac commands\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2450,7 +2439,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* create space for the in buffer and set it to zero */
 	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].inBuffer)) {
-		printk("comedi_: usbdux: could not alloc space for inBuffer\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"could not alloc space for inBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2458,7 +2448,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* create space of the instruction buffer */
 	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].insnBuffer)) {
-		printk("comedi_: usbdux: could not alloc space for insnBuffer\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2466,7 +2457,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* create space for the outbuffer */
 	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].outBuffer)) {
-		printk("comedi_: usbdux: could not alloc space for outBuffer\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"could not alloc space for outBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2475,7 +2467,9 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	i = usb_set_interface(usbduxsub[index].usbdev,
 			      usbduxsub[index].ifnum, 3);
 	if (i < 0) {
-		printk("comedi_: usbdux%d: could not set alternate setting 3 in high speed.\n", index);
+		dev_err(dev, "comedi_: usbdux%d: "
+			"could not set alternate setting 3 in high speed.\n",
+			index);
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENODEV);
@@ -2489,7 +2483,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
 		GFP_KERNEL);
 	if (!(usbduxsub[index].urbIn)) {
-		printk("comedi_: usbdux: Could not alloc. urbIn array\n");
+		dev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2498,8 +2492,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		/* one frame: 1ms */
 		usbduxsub[index].urbIn[i] = USB_ALLOC_URB(1);
 		if (usbduxsub[index].urbIn[i] == NULL) {
-			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
-				index, i);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2514,8 +2508,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbIn[i]->transfer_buffer =
 			kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
-			printk("comedi_: usbdux%d: could not alloc. transb.\n",
-				index);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2537,7 +2531,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
 		GFP_KERNEL);
 	if (!(usbduxsub[index].urbOut)) {
-		printk("comedi_: usbdux: Could not alloc. urbOut array\n");
+		dev_err(dev, "comedi_: usbdux: "
+			"Could not alloc. urbOut array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
@@ -2546,8 +2541,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		/* one frame: 1ms */
 		usbduxsub[index].urbOut[i] = USB_ALLOC_URB(1);
 		if (usbduxsub[index].urbOut[i] == NULL) {
-			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
-				index, i);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"Could not alloc. urb(%d)\n", index, i);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2562,8 +2557,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbOut[i]->transfer_buffer =
 			kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
-			printk("comedi_: usbdux%d: could not alloc. transb.\n",
-				index);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2588,8 +2583,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].sizePwmBuf = 512;	/* max bulk ep size in high speed */
 		usbduxsub[index].urbPwm = USB_ALLOC_URB(0);
 		if (usbduxsub[index].urbPwm == NULL) {
-			printk("comedi_: usbdux%d: Could not alloc. pwm urb\n",
-				index);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"Could not alloc. pwm urb\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2597,7 +2592,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbPwm->transfer_buffer =
 			kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
 		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
-			printk("comedi_: usbdux%d: could not alloc. transb. for pwm\n", index);
+			dev_err(dev, "comedi_: usbdux%d: "
+				"could not alloc. transb. for pwm\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return PROBE_ERR_RETURN(-ENOMEM);
@@ -2614,7 +2610,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	/* we've reached the bottom of the function */
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
-	printk("comedi_: usbdux%d has been successfully initialised.\n", index);
+	dev_info(dev, "comedi_: usbdux%d "
+		 "has been successfully initialised.\n", index);
 	/* success */
 	return 0;
 }
@@ -2625,11 +2622,13 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 	struct usb_device *udev = interface_to_usbdev(intf);
 
 	if (!usbduxsub_tmp) {
-		printk("comedi_: usbdux: disconnect called with null pointer.\n");
+		dev_err(&intf->dev,
+			"comedi_: disconnect called with null pointer.\n");
 		return;
 	}
 	if (usbduxsub_tmp->usbdev != udev) {
-		printk("comedi_: usbdux: BUG! called with wrong ptr!!!\n");
+		dev_err(&intf->dev,
+			"comedi_: BUG! called with wrong ptr!!!\n");
 		return;
 	}
 	down(&start_stop_sem);
@@ -2637,9 +2636,7 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 	tidy_up(usbduxsub_tmp);
 	up(&usbduxsub_tmp->sem);
 	up(&start_stop_sem);
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux: disconnected from the usb\n");
-#endif
+	dev_dbg(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
 /* is called when comedi-config is called */
@@ -2648,6 +2645,8 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	int ret;
 	int index;
 	int i;
+	usbduxsub_t *udev;
+
 	comedi_subdevice *s = NULL;
 	dev->private = NULL;
 
@@ -2662,27 +2661,28 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	}
 
 	if (index < 0) {
-		printk("comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n", dev->minor);
+		printk(KERN_ERR "comedi%d: usbdux: error: attach failed, no "
+		       "usbdux devs connected to the usb bus.\n", dev->minor);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 
-	down(&(usbduxsub[index].sem));
+	udev = &usbduxsub[index];
+	down(&udev->sem);
 	/* pointer back to the corresponding comedi device */
-	usbduxsub[index].comedidev = dev;
+	udev->comedidev = dev;
 
 	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		read_firmware(usbduxsub + index,
-			comedi_aux_data(it->options, 0),
-			it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+		read_firmware(udev, comedi_aux_data(it->options, 0),
+			      it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
 	}
 
 	dev->board_name = BOARDNAME;
 
 	/* set number of subdevices */
-	if (usbduxsub[index].high_speed) {
+	if (udev->high_speed) {
 		/* with pwm */
 		dev->n_subdevices = 5;
 	} else {
@@ -2692,16 +2692,17 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 
 	/* allocate space for the subdevices */
 	if ((ret = alloc_subdevices(dev, dev->n_subdevices)) < 0) {
-		printk("comedi%d: usbdux: error alloc space for subdev\n",
-			dev->minor);
+		dev_err(&udev->interface->dev,
+			"comedi%d: error alloc space for subdev\n", dev->minor);
 		up(&start_stop_sem);
 		return ret;
 	}
 
-	printk("comedi%d: usbdux: usb-device %d is attached to comedi.\n",
+	dev_info(&udev->interface->dev,
+		"comedi%d: usb-device %d is attached to comedi.\n",
 		dev->minor, index);
 	/* private structure is also simply the usb-structure */
-	dev->private = usbduxsub + index;
+	dev->private = udev;
 
 	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
@@ -2778,27 +2779,28 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	s->insn_write = usbdux_counter_write;
 	s->insn_config = usbdux_counter_config;
 
-	if (usbduxsub[index].high_speed) {
+	if (udev->high_speed) {
 		/* timer / pwm */
 		s = dev->subdevices + SUBDEV_PWM;
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;
 		/* this defines the max duty cycle resolution */
-		s->maxdata = usbduxsub[index].sizePwmBuf;
+		s->maxdata = udev->sizePwmBuf;
 		s->insn_write = usbdux_pwm_write;
 		s->insn_read = usbdux_pwm_read;
 		s->insn_config = usbdux_pwm_config;
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
 	/* finally decide that it's attached */
-	usbduxsub[index].attached = 1;
+	udev->attached = 1;
 
-	up(&(usbduxsub[index].sem));
+	up(&udev->sem);
 
 	up(&start_stop_sem);
 
-	printk("comedi%d: attached to usbdux.\n", dev->minor);
+	dev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",
+		 dev->minor);
 
 	return 0;
 }
@@ -2807,30 +2809,30 @@ static int usbdux_detach(comedi_device *dev)
 {
 	usbduxsub_t *usbduxsub_tmp;
 
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbdux: detach usb device\n", dev->minor);
-#endif
-
 	if (!dev) {
-		printk("comedi?: usbdux: detach without dev variable...\n");
+		printk(KERN_ERR
+			"comedi?: usbdux: detach without dev variable...\n");
 		return -EFAULT;
 	}
 
 	usbduxsub_tmp = dev->private;
 	if (!usbduxsub_tmp) {
-		printk("comedi?: usbdux: detach without ptr to usbduxsub[]\n");
+		printk(KERN_ERR
+			"comedi?: usbdux: detach without ptr to usbduxsub[]\n");
 		return -EFAULT;
 	}
 
+	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi%d: detach usb device\n",
+		dev->minor);
+
 	down(&usbduxsub_tmp->sem);
 	/* Don't allow detach to free the private structure */
 	/* It's one entry of of usbduxsub[] */
 	dev->private = NULL;
 	usbduxsub_tmp->attached = 0;
 	usbduxsub_tmp->comedidev = NULL;
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbdux: detach: successfully removed\n", dev->minor);
-#endif
+	dev_dbg(&usbduxsub_tmp->interface->dev,
+		"comedi%d: detach: successfully removed\n", dev->minor);
 	up(&usbduxsub_tmp->sem);
 	return 0;
 }
@@ -2846,9 +2848,7 @@ static comedi_driver driver_usbdux = {
 static void init_usb_devices(void)
 {
 	int index;
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbdux: setting all possible devs to invalid\n");
-#endif
+
 	/* all devices entries are invalid to begin with */
 	/* they will become valid by the probe function */
 	/* and then finally by the attach-function */

commit e54fb9c184a250fc80c48110ae42068bb0237a13
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 14:23:41 2008 -0800

    Staging: comedi: usbdux: remove // comments
    
    This converts all // comments to be /* */
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 3c51607a2e02..ba4e3fdc9bf1 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -78,8 +78,8 @@ sampling rate. If you sample two channels you get 4kHz and so on.
  *
  */
 
-// generates loads of debug info
-// #define NOISY_DUX_DEBUGBUG
+/* generates loads of debug info */
+/* #define NOISY_DUX_DEBUGBUG */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -96,111 +96,117 @@ sampling rate. If you sample two channels you get 4kHz and so on.
 
 #define BOARDNAME "usbdux"
 
-// timeout for the USB-transfer
+/* timeout for the USB-transfer */
 #define EZTIMEOUT 30
 
-// constants for "firmware" upload and download
+/* constants for "firmware" upload and download */
 #define USBDUXSUB_FIRMWARE 0xA0
 #define VENDOR_DIR_IN  0xC0
 #define VENDOR_DIR_OUT 0x40
 
-// internal adresses of the 8051 processor
+/* internal adresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
 
-// the minor device number, major is 180
-// only for debugging purposes and to
-// upload special firmware (programming the
-// eeprom etc) which is not compatible with
-// the comedi framwork
+/*
+ * the minor device number, major is 180 only for debugging purposes and to
+ * upload special firmware (programming the eeprom etc) which is not compatible
+ * with the comedi framwork
+ */
 #define USBDUXSUB_MINOR 32
 
-// max lenghth of the transfer-buffer for software upload
+/* max lenghth of the transfer-buffer for software upload */
 #define TB_LEN 0x2000
 
-// Input endpoint number: ISO/IRQ
+/* Input endpoint number: ISO/IRQ */
 #define ISOINEP           6
 
-// Output endpoint number: ISO/IRQ
+/* Output endpoint number: ISO/IRQ */
 #define ISOOUTEP          2
 
-// This EP sends DUX commands to USBDUX
+/* This EP sends DUX commands to USBDUX */
 #define COMMAND_OUT_EP     1
 
-// This EP receives the DUX commands from USBDUX
+/* This EP receives the DUX commands from USBDUX */
 #define COMMAND_IN_EP        8
 
-// Output endpoint for PWM
+/* Output endpoint for PWM */
 #define PWM_EP         4
 
-// 300Hz max frequ under PWM
+/* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
 
-// Default PWM frequency
+/* Default PWM frequency */
 #define PWM_DEFAULT_PERIOD ((long)(1E9/100))
 
-// Number of channels
+/* Number of channels */
 #define NUMCHANNELS       8
 
-// Size of one A/D value
+/* Size of one A/D value */
 #define SIZEADIN          ((sizeof(int16_t)))
 
-// Size of the input-buffer IN BYTES
-// Always multiple of 8 for 8 microframes which is needed in the highspeed mode
+/* Size of the input-buffer IN BYTES */
+/* Always multiple of 8 for 8 microframes which is needed in the highspeed mode */
 #define SIZEINBUF         ((8*SIZEADIN))
 
-// 16 bytes.
+/* 16 bytes. */
 #define SIZEINSNBUF       16
 
-// Number of DA channels
+/* Number of DA channels */
 #define NUMOUTCHANNELS    8
 
-// size of one value for the D/A converter: channel and value
+/* size of one value for the D/A converter: channel and value */
 #define SIZEDAOUT          ((sizeof(int8_t)+sizeof(int16_t)))
 
-// Size of the output-buffer in bytes
-// Actually only the first 4 triplets are used but for the
-// high speed mode we need to pad it to 8 (microframes).
+/*
+ * Size of the output-buffer in bytes
+ * Actually only the first 4 triplets are used but for the
+ * high speed mode we need to pad it to 8 (microframes).
+ */
 #define SIZEOUTBUF         ((8*SIZEDAOUT))
 
-// Size of the buffer for the dux commands: just now max size is determined
-// by the analogue out + command byte + panic bytes...
+/*
+ * Size of the buffer for the dux commands: just now max size is determined
+ * by the analogue out + command byte + panic bytes...
+ */
 #define SIZEOFDUXBUFFER    ((8*SIZEDAOUT+2))
 
-// Number of in-URBs which receive the data: min=2
+/* Number of in-URBs which receive the data: min=2 */
 #define NUMOFINBUFFERSFULL     5
 
-// Number of out-URBs which send the data: min=2
+/* Number of out-URBs which send the data: min=2 */
 #define NUMOFOUTBUFFERSFULL    5
 
-// Number of in-URBs which receive the data: min=5
-#define NUMOFINBUFFERSHIGH     10	// must have more buffers due to buggy USB ctr
+/* Number of in-URBs which receive the data: min=5 */
+/* must have more buffers due to buggy USB ctr */
+#define NUMOFINBUFFERSHIGH     10
 
-// Number of out-URBs which send the data: min=5
-#define NUMOFOUTBUFFERSHIGH    10	// must have more buffers due to buggy USB ctr
+/* Number of out-URBs which send the data: min=5 */
+/* must have more buffers due to buggy USB ctr */
+#define NUMOFOUTBUFFERSHIGH    10
 
-// Total number of usbdux devices
+/* Total number of usbdux devices */
 #define NUMUSBDUX             16
 
-// Analogue in subdevice
+/* Analogue in subdevice */
 #define SUBDEV_AD             0
 
-// Analogue out subdevice
+/* Analogue out subdevice */
 #define SUBDEV_DA             1
 
-// Digital I/O
+/* Digital I/O */
 #define SUBDEV_DIO            2
 
-// counter
+/* counter */
 #define SUBDEV_COUNTER        3
 
-// timer aka pwm output
+/* timer aka pwm output */
 #define SUBDEV_PWM            4
 
-// number of retries to get the right dux command
+/* number of retries to get the right dux command */
 #define RETRIES 10
 
-/////////////////////////////////////////////
-// comedi constants
+/**************************************************/
+/* comedi constants */
 static const comedi_lrange range_usbdux_ai_range = { 4, {
 			BIP_RANGE(4.096),
 			BIP_RANGE(4.096 / 2),
@@ -219,83 +225,87 @@ static const comedi_lrange range_usbdux_ao_range = { 2, {
  * private structure of one subdevice
  */
 
-// This is the structure which holds all the data of this driver
-// one sub device just now: A/D
+/*
+ * This is the structure which holds all the data of
+ * this driver one sub device just now: A/D
+ */
 typedef struct {
-	// attached?
+	/* attached? */
 	int attached;
-	// is it associated with a subdevice?
+	/* is it associated with a subdevice? */
 	int probed;
-	// pointer to the usb-device
+	/* pointer to the usb-device */
 	struct usb_device *usbdev;
-	// actual number of in-buffers
+	/* actual number of in-buffers */
 	int numOfInBuffers;
-	// actual number of out-buffers
+	/* actual number of out-buffers */
 	int numOfOutBuffers;
-	// ISO-transfer handling: buffers
+	/* ISO-transfer handling: buffers */
 	struct urb **urbIn;
 	struct urb **urbOut;
-	// pwm-transfer handling
+	/* pwm-transfer handling */
 	struct urb *urbPwm;
-	// PWM period
+	/* PWM period */
 	lsampl_t pwmPeriod;
-	// PWM internal delay for the GPIF in the FX2
+	/* PWM internal delay for the GPIF in the FX2 */
 	int8_t pwmDelay;
-	// size of the PWM buffer which holds the bit pattern
+	/* size of the PWM buffer which holds the bit pattern */
 	int sizePwmBuf;
-	// input buffer for the ISO-transfer
+	/* input buffer for the ISO-transfer */
 	int16_t *inBuffer;
-	// input buffer for single insn
+	/* input buffer for single insn */
 	int16_t *insnBuffer;
-	// output buffer for single DA outputs
+	/* output buffer for single DA outputs */
 	int16_t *outBuffer;
-	// interface number
+	/* interface number */
 	int ifnum;
-	// interface structure in 2.6
+	/* interface structure in 2.6 */
 	struct usb_interface *interface;
-	// comedi device for the interrupt context
+	/* comedi device for the interrupt context */
 	comedi_device *comedidev;
-	// is it USB_SPEED_HIGH or not?
+	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
-	// asynchronous command is running
+	/* asynchronous command is running */
 	short int ai_cmd_running;
 	short int ao_cmd_running;
-	// pwm is running
+	/* pwm is running */
 	short int pwm_cmd_running;
-	// continous aquisition
+	/* continous aquisition */
 	short int ai_continous;
 	short int ao_continous;
-	// number of samples to aquire
+	/* number of samples to aquire */
 	int ai_sample_count;
 	int ao_sample_count;
-	// time between samples in units of the timer
+	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
-	// counter between aquisitions
+	/* counter between aquisitions */
 	unsigned int ai_counter;
 	unsigned int ao_counter;
-	// interval in frames/uframes
+	/* interval in frames/uframes */
 	unsigned int ai_interval;
-	// D/A commands
+	/* D/A commands */
 	int8_t *dac_commands;
-	// commands
+	/* commands */
 	int8_t *dux_commands;
 	struct semaphore sem;
 } usbduxsub_t;
 
-// The pointer to the private usb-data of the driver
-// is also the private data for the comedi-device.
-// This has to be global as the usb subsystem needs
-// global variables. The other reason is that this
-// structure must be there _before_ any comedi
-// command is issued. The usb subsystem must be
-// initialised before comedi can access it.
+/*
+ * The pointer to the private usb-data of the driver is also the private data
+ * for the comedi-device.  This has to be global as the usb subsystem needs
+ * global variables. The other reason is that this structure must be there
+ * _before_ any comedi command is issued. The usb subsystem must be initialised
+ * before comedi can access it.
+ */
 static usbduxsub_t usbduxsub[NUMUSBDUX];
 
 static DECLARE_MUTEX(start_stop_sem);
 
-// Stops the data acquision
-// It should be safe to call this function from any context
+/*
+ * Stops the data acquision
+ * It should be safe to call this function from any context
+ */
 static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
 {
 	int i = 0;
@@ -304,8 +314,8 @@ static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
 	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
 		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
 			if (usbduxsub_tmp->urbIn[i]) {
-				// We wait here until all transfers
-				// have been cancelled.
+				/* We wait here until all transfers have been
+				 * cancelled. */
 				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
 			}
 #ifdef NOISY_DUX_DEBUGBUG
@@ -335,7 +345,7 @@ static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 #endif
 
 	if (do_unlink) {
-		// stop aquistion
+		/* stop aquistion */
 		ret = usbduxsub_unlink_InURBs(this_usbduxsub);
 	}
 
@@ -344,15 +354,16 @@ static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 	return ret;
 }
 
-// This will cancel a running acquisition operation.
-// This is called by comedi but never from inside the
-// driver.
+/*
+ * This will cancel a running acquisition operation.
+ * This is called by comedi but never from inside the driver.
+ */
 static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 {
 	usbduxsub_t *this_usbduxsub;
 	int res = 0;
 
-	// force unlink of all urbs
+	/* force unlink of all urbs */
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi: usbdux_ai_cancel\n");
 #endif
@@ -361,20 +372,19 @@ static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 		printk("comedi: usbdux_ai_cancel: this_usbduxsub=NULL\n");
 		return -EFAULT;
 	}
-	// prevent other CPUs from submitting new commands just now
+	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-	// unlink only if the urb really has been submitted
+	/* unlink only if the urb really has been submitted */
 	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
 	up(&this_usbduxsub->sem);
 	return res;
 }
 
-// analogue IN
-// interrupt service routine
+/* analogue IN - interrupt service routine */
 static void usbduxsub_ai_IsocIrq(struct urb *urb)
 {
 	int i, err, n;
@@ -382,38 +392,38 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
-	// sanity checks
-	// is the urb there?
+	/* sanity checks */
+	/* is the urb there? */
 	if (!urb) {
 		printk("comedi_: usbdux_: ao int-handler called with urb=NULL!\n");
 		return;
 	}
-	// the context variable points to the subdevice
+	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (unlikely(!this_comedidev)) {
 		printk("comedi_: usbdux_: BUG! urb context is a NULL pointer!\n");
 		return;
 	}
-	// the private structure of the subdevice is usbduxsub_t
+	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
 	if (unlikely(!this_usbduxsub)) {
 		printk("comedi_: usbdux_: BUG! private of comedi subdev is a NULL pointer!\n");
 		return;
 	}
-	// subdevice which is the AD converter
+	/* subdevice which is the AD converter */
 	s = this_comedidev->subdevices + SUBDEV_AD;
 
-	// first we test if something unusual has just happened
+	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
-		// copy the result in the transfer buffer
+		/* copy the result in the transfer buffer */
 		memcpy(this_usbduxsub->inBuffer,
 			urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
-		// error in the ISOchronous data
-		// we don't copy the data into the transfer buffer
-		// and recycle the last data byte
+		/* error in the ISOchronous data */
+		/* we don't copy the data into the transfer buffer */
+		/* and recycle the last data byte */
 #ifdef CONFIG_COMEDI_DEBUG
 		printk("comedi%d: usbdux: CRC error in ISO IN stream.\n",
 			this_usbduxsub->comedidev->minor);
@@ -421,42 +431,43 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 
 		break;
 
-		// happens after an unlink command
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
+		/* happens after an unlink command */
 		if (this_usbduxsub->ai_cmd_running) {
-			// we are still running a command
-			// tell this comedi
+			/* we are still running a command */
+			/* tell this comedi */
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(this_usbduxsub->comedidev, s);
-			// stop the transfer w/o unlink
+			/* stop the transfer w/o unlink */
 			usbdux_ai_stop(this_usbduxsub, 0);
 		}
 		return;
 
-		// a real error on the bus
 	default:
-		// pass error to comedi if we are really running a command
+		/* a real error on the bus */
+		/* pass error to comedi if we are really running a command */
 		if (this_usbduxsub->ai_cmd_running) {
 			printk("Non-zero urb status received in ai intr context: %d\n", urb->status);
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(this_usbduxsub->comedidev, s);
-			// don't do an unlink here
+			/* don't do an unlink here */
 			usbdux_ai_stop(this_usbduxsub, 0);
 		}
 		return;
 	}
 
-	// at this point we are reasonably sure that nothing dodgy has happened
-	// are we running a command?
+	/* at this point we are reasonably sure that nothing dodgy has happened */
+	/* are we running a command? */
 	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
-		// not running a command
-		// do not continue execution if no asynchronous command is running
-		// in particular not resubmit
+		/*
+		 * not running a command, do not continue execution if no
+		 * asynchronous command is running in particular not resubmit
+		 */
 		return;
 	}
 
@@ -482,28 +493,27 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	if (likely(this_usbduxsub->ai_counter > 0))
 		return;
 
-	// timer zero, transfer measurements to comedi
+	/* timer zero, transfer measurements to comedi */
 	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
 
-	// test, if we transmit only a fixed number of samples
+	/* test, if we transmit only a fixed number of samples */
 	if (!(this_usbduxsub->ai_continous)) {
-		// not continous, fixed number of samples
+		/* not continous, fixed number of samples */
 		this_usbduxsub->ai_sample_count--;
-		// all samples received?
+		/* all samples received? */
 		if (this_usbduxsub->ai_sample_count < 0) {
-			// prevent a resubmit next time
+			/* prevent a resubmit next time */
 			usbdux_ai_stop(this_usbduxsub, 0);
-			// say comedi that the acquistion is over
+			/* say comedi that the acquistion is over */
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(this_usbduxsub->comedidev, s);
 			return;
 		}
 	}
-	// get the data from the USB bus and hand it over
-	// to comedi
+	/* get the data from the USB bus and hand it over to comedi */
 	n = s->async->cmd.chanlist_len;
 	for (i = 0; i < n; i++) {
-		// transfer data
+		/* transfer data */
 		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
 			comedi_buf_put
 				(s->async,
@@ -515,7 +525,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 				le16_to_cpu(this_usbduxsub->inBuffer[i]));
 		}
 	}
-	// tell comedi that data is there
+	/* tell comedi that data is there */
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
@@ -572,13 +582,13 @@ static int usbdux_ao_cancel(comedi_device *dev, comedi_subdevice *s)
 		printk("comedi: usbdux_ao_cancel: this_usbduxsub=NULL\n");
 		return -EFAULT;
 	}
-	// prevent other CPUs from submitting a command just now
+	/* prevent other CPUs from submitting a command just now */
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-	// unlink only if it is really running
+	/* unlink only if it is really running */
 	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
 	up(&this_usbduxsub->sem);
 	return res;
@@ -596,13 +606,13 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		printk("comedi_: usbdux_: ao urb handler called with NULL ptr.\n");
 		return;
 	}
-	// the context variable points to the subdevice
+	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (!this_comedidev) {
 		printk("comedi_: usbdux_: ao urb int-context is a NULL pointer.\n");
 		return;
 	}
-	// the private structure of the subdevice is usbduxsub_t
+	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
 	if (!this_usbduxsub) {
 		printk("comedi_: usbdux_: private data structure of ao subdev is NULL p.\n");
@@ -620,8 +630,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		// after an unlink command, unplug, ... etc
-		// no unlink needed here. Already shutting down.
+		/* after an unlink command, unplug, ... etc */
+		/* no unlink needed here. Already shutting down. */
 		if (this_usbduxsub->ao_cmd_running) {
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(this_usbduxsub->comedidev, s);
@@ -630,42 +640,42 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		return;
 
 	default:
-		// a real error
+		/* a real error */
 		if (this_usbduxsub->ao_cmd_running) {
 			printk("comedi_: usbdux_: Non-zero urb status received in ao intr context: %d\n", urb->status);
 			s->async->events |= COMEDI_CB_ERROR;
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(this_usbduxsub->comedidev, s);
-			// we do an unlink if we are in the high speed mode
+			/* we do an unlink if we are in the high speed mode */
 			usbdux_ao_stop(this_usbduxsub, 0);
 		}
 		return;
 	}
 
-	// are we actually running?
+	/* are we actually running? */
 	if (!(this_usbduxsub->ao_cmd_running))
 		return;
 
-	// normal operation: executing a command in this subdevice
+	/* normal operation: executing a command in this subdevice */
 	this_usbduxsub->ao_counter--;
 	if (this_usbduxsub->ao_counter <= 0) {
-		// timer zero
+		/* timer zero */
 		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
-		// handle non continous aquisition
+		/* handle non continous aquisition */
 		if (!(this_usbduxsub->ao_continous)) {
-			// fixed number of samples
+			/* fixed number of samples */
 			this_usbduxsub->ao_sample_count--;
 			if (this_usbduxsub->ao_sample_count < 0) {
-				// all samples transmitted
+				/* all samples transmitted */
 				usbdux_ao_stop(this_usbduxsub, 0);
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(this_usbduxsub->comedidev, s);
-				// no resubmit of the urb
+				/* no resubmit of the urb */
 				return;
 			}
 		}
-		// transmit data to the USB bus
+		/* transmit data to the USB bus */
 		((uint8_t *) (urb->transfer_buffer))[0] =
 			s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
@@ -673,21 +683,21 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 			if (i >= NUMOUTCHANNELS)
 				break;
 
-			// pointer to the DA
+			/* pointer to the DA */
 			datap = (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
-			// get the data from comedi
+			/* get the data from comedi */
 			ret = comedi_buf_get(s->async, &temp);
 			datap[0] = temp;
 			datap[1] = temp >> 8;
 			datap[2] = this_usbduxsub->dac_commands[i];
-			// printk("data[0]=%x, data[1]=%x, data[2]=%x\n",
-			// datap[0],datap[1],datap[2]);
+			/* printk("data[0]=%x, data[1]=%x, data[2]=%x\n", */
+			/* datap[0],datap[1],datap[2]); */
 			if (ret < 0) {
 				printk("comedi: usbdux: buffer underflow\n");
 				s->async->events |= COMEDI_CB_EOA;
 				s->async->events |= COMEDI_CB_OVERFLOW;
 			}
-			// transmit data to comedi
+			/* transmit data to comedi */
 			s->async->events |= COMEDI_CB_BLOCK;
 			comedi_event(this_usbduxsub->comedidev, s);
 		}
@@ -697,10 +707,10 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	urb->status = 0;
 	if (this_usbduxsub->ao_cmd_running) {
 		if (this_usbduxsub->high_speed) {
-			// uframes
+			/* uframes */
 			urb->interval = 8;
 		} else {
-			// frames
+			/* frames */
 			urb->interval = 1;
 		}
 		urb->number_of_packets = 1;
@@ -718,7 +728,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(this_usbduxsub->comedidev, s);
-			// don't do an unlink here
+			/* don't do an unlink here */
 			usbdux_ao_stop(this_usbduxsub, 0);
 		}
 	}
@@ -730,24 +740,24 @@ static int usbduxsub_start(usbduxsub_t *usbduxsub)
 	uint8_t local_transfer_buffer[16];
 
 	if (usbduxsub->probed) {
-		// 7f92 to zero
+		/* 7f92 to zero */
 		local_transfer_buffer[0] = 0;
 		errcode = USB_CONTROL_MSG(usbduxsub->usbdev,
-			// create a pipe for a control transfer
+			/* create a pipe for a control transfer */
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			// bRequest, "Firmware"
+			/* bRequest, "Firmware" */
 			USBDUXSUB_FIRMWARE,
-			// bmRequestType
+			/* bmRequestType */
 			VENDOR_DIR_OUT,
-			// Value
+			/* Value */
 			USBDUXSUB_CPUCS,
-			// Index
+			/* Index */
 			0x0000,
-			// address of the transfer buffer
+			/* address of the transfer buffer */
 			local_transfer_buffer,
-			// Length
+			/* Length */
 			1,
-			// Timeout
+			/* Timeout */
 			EZTIMEOUT);
 		if (errcode < 0) {
 			printk("comedi_: usbdux_: control msg failed (start)\n");
@@ -763,22 +773,22 @@ static int usbduxsub_stop(usbduxsub_t *usbduxsub)
 
 	uint8_t local_transfer_buffer[16];
 	if (usbduxsub->probed) {
-		// 7f92 to one
+		/* 7f92 to one */
 		local_transfer_buffer[0] = 1;
 		errcode = USB_CONTROL_MSG
 			(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			// bRequest, "Firmware"
+			/* bRequest, "Firmware" */
 			USBDUXSUB_FIRMWARE,
-			// bmRequestType
+			/* bmRequestType */
 			VENDOR_DIR_OUT,
-			// Value
+			/* Value */
 			USBDUXSUB_CPUCS,
-			// Index
+			/* Index */
 			0x0000, local_transfer_buffer,
-			// Length
+			/* Length */
 			1,
-			// Timeout
+			/* Timeout */
 			EZTIMEOUT);
 		if (errcode < 0) {
 			printk("comedi_: usbdux: control msg failed (stop)\n");
@@ -804,19 +814,19 @@ static int usbduxsub_upload(usbduxsub_t *usbduxsub,
 		errcode = USB_CONTROL_MSG
 			(usbduxsub->usbdev,
 			usb_sndctrlpipe(usbduxsub->usbdev, 0),
-			// brequest, firmware
+			/* brequest, firmware */
 			USBDUXSUB_FIRMWARE,
-			// bmRequestType
+			/* bmRequestType */
 			VENDOR_DIR_OUT,
-			// value
+			/* value */
 			startAddr,
-			// index
+			/* index */
 			0x0000,
-			// our local safe buffer
+			/* our local safe buffer */
 			local_transfer_buffer,
-			// length
+			/* length */
 			len,
-			// timeout
+			/* timeout */
 			EZTIMEOUT);
 #ifdef NOISY_DUX_DEBUGBUG
 		printk("comedi_: usbdux: result=%d\n", errcode);
@@ -826,7 +836,7 @@ static int usbduxsub_upload(usbduxsub_t *usbduxsub,
 			return errcode;
 		}
 	} else {
-		// no device on the bus for this index
+		/* no device on the bus for this index */
 		return -EFAULT;
 	}
 	return 0;
@@ -898,7 +908,7 @@ static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
 #ifdef NOISY_DUX_DEBUGBUG
 		printk("comedi_: usbdux: submitting out-urb[%d]\n", i);
 #endif
-		// in case of a resubmission after an unlink...
+		/* in case of a resubmission after an unlink... */
 		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
 		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urbOut[i]->status = 0;
@@ -927,32 +937,32 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	printk("comedi%d: usbdux_ai_cmdtest\n", dev->minor);
 #endif
 	/* make sure triggers are valid */
-	// Only immediate triggers are allowed
+	/* Only immediate triggers are allowed */
 	tmp = cmd->start_src;
 	cmd->start_src &= TRIG_NOW | TRIG_INT;
 	if (!cmd->start_src || tmp != cmd->start_src)
 		err++;
 
-	// trigger should happen timed
+	/* trigger should happen timed */
 	tmp = cmd->scan_begin_src;
-	// start a new _scan_ with a timer
+	/* start a new _scan_ with a timer */
 	cmd->scan_begin_src &= TRIG_TIMER;
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	// scanning is continous
+	/* scanning is continous */
 	tmp = cmd->convert_src;
 	cmd->convert_src &= TRIG_NOW;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
 		err++;
 
-	// issue a trigger when scan is finished and start a new scan
+	/* issue a trigger when scan is finished and start a new scan */
 	tmp = cmd->scan_end_src;
 	cmd->scan_end_src &= TRIG_COUNT;
 	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
 		err++;
 
-	// trigger at the end of count events or not, stop condition or not
+	/* trigger at the end of count events or not, stop condition or not */
 	tmp = cmd->stop_src;
 	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
 	if (!cmd->stop_src || tmp != cmd->stop_src)
@@ -990,12 +1000,14 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (this_usbduxsub->high_speed) {
-			// In high speed mode microframes are possible.
-			// However, during one microframe we can roughly
-			// sample one channel. Thus, the more channels
-			// are in the channel list the more time we need.
+			/*
+			 * In high speed mode microframes are possible.
+			 * However, during one microframe we can roughly
+			 * sample one channel. Thus, the more channels
+			 * are in the channel list the more time we need.
+			 */
 			i = 1;
-			// find a power of 2 for the number of channels
+			/* find a power of 2 for the number of channels */
 			while (i < (cmd->chanlist_len)) {
 				i = i * 2;
 			}
@@ -1003,7 +1015,8 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 				cmd->scan_begin_arg = 1000000 / 8 * i;
 				err++;
 			}
-			// now calc the real sampling rate with all the rounding errors
+			/* now calc the real sampling rate with all the
+			 * rounding errors */
 			tmpTimer =
 				((unsigned int)(cmd->scan_begin_arg / 125000)) *
 				125000;
@@ -1011,13 +1024,14 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 				cmd->scan_begin_arg = tmpTimer;
 				err++;
 			}
-		} else {	// full speed
-			// 1kHz scans every USB frame
+		} else {
+			/* full speed */
+			/* 1kHz scans every USB frame */
 			if (cmd->scan_begin_arg < 1000000) {
 				cmd->scan_begin_arg = 1000000;
 				err++;
 			}
-			// calc the real sampling rate with the rounding errors
+			/* calc the real sampling rate with the rounding errors */
 			tmpTimer =
 				((unsigned int)(cmd->scan_begin_arg /
 					1000000)) * 1000000;
@@ -1027,7 +1041,7 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 			}
 		}
 	}
-	// the same argument
+	/* the same argument */
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
@@ -1049,8 +1063,10 @@ static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	return 0;
 }
 
-// creates the ADC command for the MAX1271
-// range is the range value from comedi
+/*
+ * creates the ADC command for the MAX1271
+ * range is the range value from comedi
+ */
 static int8_t create_adc_command(unsigned int chan, int range)
 {
 	int8_t p = (range <= 1);
@@ -1058,7 +1074,7 @@ static int8_t create_adc_command(unsigned int chan, int range)
 	return (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);
 }
 
-// bulk transfers to usbdux
+/* bulk transfers to usbdux */
 
 #define SENDADCOMMANDS            0
 #define SENDDACOMMANDS            1
@@ -1112,7 +1128,7 @@ static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
 			return result;
 		}
 	}
-	// this is only reached if the data has been requested a couple of times
+	/* this is only reached if the data has been requested a couple of times */
 	printk("comedi%d: insn: wrong data returned from firmware: want cmd %d, got cmd %d.\n", this_usbduxsub->comedidev->minor, command, le16_to_cpu(this_usbduxsub->insnBuffer[0]));
 	return -EFAULT;
 }
@@ -1235,30 +1251,30 @@ static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		// data arrives as one packet
+		/* data arrives as one packet */
 		this_usbduxsub->ai_sample_count = cmd->stop_arg;
 		this_usbduxsub->ai_continous = 0;
 	} else {
-		// continous aquisition
+		/* continous aquisition */
 		this_usbduxsub->ai_continous = 1;
 		this_usbduxsub->ai_sample_count = 0;
 	}
 
 	if (cmd->start_src == TRIG_NOW) {
-		// enable this acquisition operation
+		/* enable this acquisition operation */
 		this_usbduxsub->ai_cmd_running = 1;
 		ret = usbduxsub_submit_InURBs(this_usbduxsub);
 		if (ret < 0) {
 			this_usbduxsub->ai_cmd_running = 0;
-			// fixme: unlink here??
+			/* fixme: unlink here?? */
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
 		/* TRIG_INT */
-		// don't enable the acquision operation
-		// wait for an internal signal
+		/* don't enable the acquision operation */
+		/* wait for an internal signal */
 		s->async->inttrig = usbdux_ai_inttrig;
 	}
 	up(&this_usbduxsub->sem);
@@ -1294,13 +1310,13 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 		return 0;
 	}
 
-	// sample one channel
+	/* sample one channel */
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
-	// set command for the first channel
+	/* set command for the first channel */
 	this_usbduxsub->dux_commands[1] = create_adc_command(chan, range);
 
-	// adc commands
+	/* adc commands */
 	if ((err = send_dux_commands(this_usbduxsub, SENDSINGLEAD)) < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1322,8 +1338,8 @@ static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
 	return i;
 }
 
-//////////////////
-// analog out
+/************************************/
+/* analog out */
 
 static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
 			       comedi_insn *insn, lsampl_t *data)
@@ -1376,13 +1392,13 @@ static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
 		printk("comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
 			dev->minor, chan, i, data[i]);
 #endif
-		// number of channels: 1
+		/* number of channels: 1 */
 		this_usbduxsub->dux_commands[1] = 1;
-		// one 16 bit value
+		/* one 16 bit value */
 		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
 			cpu_to_le16(data[i]);
 		this_usbduxsub->outBuffer[chan] = data[i];
-		// channel number
+		/* channel number */
 		this_usbduxsub->dux_commands[4] = (chan << 6);
 		if ((err = send_dux_commands(this_usbduxsub,
 					SENDDACOMMANDS)) < 0) {
@@ -1448,47 +1464,47 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 	printk("comedi%d: usbdux_ao_cmdtest\n", dev->minor);
 #endif
 	/* make sure triggers are valid */
-	// Only immediate triggers are allowed
+	/* Only immediate triggers are allowed */
 	tmp = cmd->start_src;
 	cmd->start_src &= TRIG_NOW | TRIG_INT;
 	if (!cmd->start_src || tmp != cmd->start_src)
 		err++;
 
-	// trigger should happen timed
+	/* trigger should happen timed */
 	tmp = cmd->scan_begin_src;
-	// just now we scan also in the high speed mode every frame
-	// this is due to ehci driver limitations
+	/* just now we scan also in the high speed mode every frame */
+	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		// start immidiately a new scan
-		// the sampling rate is set by the coversion rate
+		/* start immidiately a new scan */
+		/* the sampling rate is set by the coversion rate */
 		cmd->scan_begin_src &= TRIG_FOLLOW;
 	} else {
-		// start a new scan (output at once) with a timer
+		/* start a new scan (output at once) with a timer */
 		cmd->scan_begin_src &= TRIG_TIMER;
 	}
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	// scanning is continous
+	/* scanning is continous */
 	tmp = cmd->convert_src;
-	// we always output at 1kHz just now all channels at once
+	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		// in usb-2.0 only one conversion it tranmitted but with 8kHz/n
+		/* in usb-2.0 only one conversion it tranmitted but with 8kHz/n */
 		cmd->convert_src &= TRIG_TIMER;
 	} else {
-		// all conversion events happen simultaneously with a rate of 1kHz/n
+		/* all conversion events happen simultaneously with a rate of 1kHz/n */
 		cmd->convert_src &= TRIG_NOW;
 	}
 	if (!cmd->convert_src || tmp != cmd->convert_src)
 		err++;
 
-	// issue a trigger when scan is finished and start a new scan
+	/* issue a trigger when scan is finished and start a new scan */
 	tmp = cmd->scan_end_src;
 	cmd->scan_end_src &= TRIG_COUNT;
 	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
 		err++;
 
-	// trigger at the end of count events or not, stop condition or not
+	/* trigger at the end of count events or not, stop condition or not */
 	tmp = cmd->stop_src;
 	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
 	if (!cmd->stop_src || tmp != cmd->stop_src)
@@ -1531,7 +1547,7 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 			err++;
 		}
 	}
-	// not used now, is for later use
+	/* not used now, is for later use */
 	if (cmd->convert_src == TRIG_TIMER) {
 		if (cmd->convert_arg < 125000) {
 			cmd->convert_arg = 125000;
@@ -1539,7 +1555,7 @@ static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
 		}
 	}
 
-	// the same argument
+	/* the same argument */
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
@@ -1584,7 +1600,7 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 	printk("comedi%d: usbdux_ao_cmd\n", dev->minor);
 #endif
 
-	// set current channel of the running aquisition to zero
+	/* set current channel of the running aquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
@@ -1600,15 +1616,15 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 #endif
 	}
 
-	// we count in steps of 1ms (125us)
-	// 125us mode not used yet
+	/* we count in steps of 1ms (125us) */
+	/* 125us mode not used yet */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		// 125us
-		// timing of the conversion itself: every 125 us
+		/* 125us */
+		/* timing of the conversion itself: every 125 us */
 		this_usbduxsub->ao_timer = cmd->convert_arg / 125000;
 	} else {
-		// 1ms
-		// timing of the scan: we get all channels at once
+		/* 1ms */
+		/* timing of the scan: we get all channels at once */
 		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
 #ifdef NOISY_DUX_DEBUGBUG
 		printk("comedi%d: usbdux: scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, convert_arg=%d\n", dev->minor, cmd->scan_begin_src, cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
@@ -1624,40 +1640,40 @@ static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		// not continous
-		// counter
-		// high speed also scans everything at once
+		/* not continous */
+		/* counter */
+		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
 			this_usbduxsub->ao_sample_count =
 				(cmd->stop_arg) * (cmd->scan_end_arg);
 		} else {
-			// there's no scan as the scan has been
-			// perf inside the FX2
-			// data arrives as one packet
+			/* there's no scan as the scan has been */
+			/* perf inside the FX2 */
+			/* data arrives as one packet */
 			this_usbduxsub->ao_sample_count = cmd->stop_arg;
 		}
 		this_usbduxsub->ao_continous = 0;
 	} else {
-		// continous aquisition
+		/* continous aquisition */
 		this_usbduxsub->ao_continous = 1;
 		this_usbduxsub->ao_sample_count = 0;
 	}
 
 	if (cmd->start_src == TRIG_NOW) {
-		// enable this acquisition operation
+		/* enable this acquisition operation */
 		this_usbduxsub->ao_cmd_running = 1;
 		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
 		if (ret < 0) {
 			this_usbduxsub->ao_cmd_running = 0;
-			// fixme: unlink here??
+			/* fixme: unlink here?? */
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
 		/* TRIG_INT */
-		// submit the urbs later
-		// wait for an internal signal
+		/* submit the urbs later */
+		/* wait for an internal signal */
 		s->async->inttrig = usbdux_ao_inttrig;
 	}
 
@@ -1691,8 +1707,8 @@ static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
 		return -EINVAL;
 		break;
 	}
-	// we don't tell the firmware here as it would take 8 frames
-	// to submit the information. We do it in the insn_bits.
+	/* we don't tell the firmware here as it would take 8 frames */
+	/* to submit the information. We do it in the insn_bits. */
 	return insn->n;
 }
 
@@ -1724,8 +1740,8 @@ static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
 	this_usbduxsub->dux_commands[1] = s->io_bits;
 	this_usbduxsub->dux_commands[2] = s->state;
 
-	// This command also tells the firmware to return
-	// the digital input lines
+	/* This command also tells the firmware to return */
+	/* the digital input lines */
 	if ((err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND)) < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1807,12 +1823,12 @@ static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
 static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
 				 comedi_insn *insn, lsampl_t *data)
 {
-	// nothing to do so far
+	/* nothing to do so far */
 	return 2;
 }
 
-/////////////////////////////
-// PWM
+/***********************************/
+/* PWM */
 
 static int usbduxsub_unlink_PwmURBs(usbduxsub_t *usbduxsub_tmp)
 {
@@ -1879,19 +1895,19 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 
-	// printk("PWM: IRQ\n");
+	/* printk("PWM: IRQ\n"); */
 
 	if (!urb) {
 		printk("comedi_: usbdux_: pwm urb handler called with NULL ptr.\n");
 		return;
 	}
-	// the context variable points to the subdevice
+	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (!this_comedidev) {
 		printk("comedi_: usbdux_: pwm urb int-context is a NULL pointer.\n");
 		return;
 	}
-	// the private structure of the subdevice is usbduxsub_t
+	/* the private structure of the subdevice is usbduxsub_t */
 	this_usbduxsub = this_comedidev->private;
 	if (!this_usbduxsub) {
 		printk("comedi_: usbdux_: private data structure of pwm subdev is NULL p.\n");
@@ -1959,7 +1975,7 @@ static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi_: usbdux: submitting pwm-urb\n");
 #endif
-	// in case of a resubmission after an unlink...
+	/* in case of a resubmission after an unlink... */
 
 	usb_fill_bulk_urb(usbduxsub->urbPwm,
 		usbduxsub->usbdev,
@@ -2003,7 +2019,7 @@ static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 }
 
 
-// is called from insn so there's no need to do all the sanity checks
+/* is called from insn so there's no need to do all the sanity checks */
 static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 {
 	int ret, i;
@@ -2013,7 +2029,7 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 	printk("comedi%d: usbdux_pwm_start\n", dev->minor);
 #endif
 	if (this_usbduxsub->pwm_cmd_running) {
-		// already running
+		/* already running */
 		return 0;
 	}
 
@@ -2021,7 +2037,7 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 	if ((ret = send_dux_commands(this_usbduxsub, SENDPWMON)) < 0) {
 		return ret;
 	}
-	// initalise the buffer
+	/* initalise the buffer */
 	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++) {
 		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
 	}
@@ -2036,7 +2052,7 @@ static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
 }
 
 
-// generates the bit pattern for PWM with the optional sign bit
+/* generates the bit pattern for PWM with the optional sign bit */
 static int usbdux_pwm_pattern(comedi_device * dev, comedi_subdevice * s,
 			      int channel, lsampl_t value, lsampl_t sign)
 {
@@ -2048,27 +2064,27 @@ static int usbdux_pwm_pattern(comedi_device * dev, comedi_subdevice * s,
 	if (!this_usbduxsub) {
 		return -EFAULT;
 	}
-	// this is the DIO bit which carries the PWM data
+	/* this is the DIO bit which carries the PWM data */
 	pwm_mask = (1 << channel);
-	// this is the DIO bit which carries the optional direction bit
+	/* this is the DIO bit which carries the optional direction bit */
 	sgn_mask = (16 << channel);
-	// this is the buffer which will be filled with the with bit
-	// pattern for one period
+	/* this is the buffer which will be filled with the with bit */
+	/* pattern for one period */
 	szbuf = this_usbduxsub->sizePwmBuf;
 	pBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);
 	for (i = 0; i < szbuf; i++) {
 		c = *pBuf;
-		// reset bits
+		/* reset bits */
 		c = c & (~pwm_mask);
-		// set the bit as long as the index is lower than the value
+		/* set the bit as long as the index is lower than the value */
 		if (i < value)
 			c = c | pwm_mask;
-		// set the optional sign bit for a relay
+		/* set the optional sign bit for a relay */
 		if (!sign) {
-			// positive value
+			/* positive value */
 			c = c & (~sgn_mask);
 		} else {
-			// negative value
+			/* negative value */
 			c = c | sgn_mask;
 		}
 		*(pBuf++) = c;
@@ -2086,14 +2102,14 @@ static int usbdux_pwm_write(comedi_device * dev, comedi_subdevice * s,
 	}
 
 	if ((insn->n)!=1) {
-		// doesn't make sense to have more than one value here
-		// because it would just overwrite the PWM buffer a couple of times
+		/* doesn't make sense to have more than one value here */
+		/* because it would just overwrite the PWM buffer a couple of times */
 		return -EINVAL;
 	}
 
-	// the sign is set via a special INSN only, this gives us 8 bits for
-	// normal operation
-	// relay sign 0 by default
+	/* the sign is set via a special INSN only, this gives us 8 bits for */
+	/* normal operation */
+	/* relay sign 0 by default */
 	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
 				  data[0], 0);
 }
@@ -2290,7 +2306,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 		int idx, off;
 		int j = 0;
 
-		// get one line
+		/* get one line */
 		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
 			buf[j] = fp[i];
 			i++;
@@ -2300,14 +2316,14 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 				return -1;
 			}
 		}
-		// get rid of LF/CR/...
+		/* get rid of LF/CR/... */
 		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
 				|| (fp[i] == 0))) {
 			i++;
 		}
 
 		buf[j] = 0;
-		//printk("comedi_: buf=%s\n",buf);
+		/*printk("comedi_: buf=%s\n",buf); */
 
 		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
 		if (buf[0] == '#')
@@ -2332,7 +2348,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 			printk("comedi_: usbdux: firmware upload goes beyond FX2 RAM boundaries.");
 			return -EFAULT;
 		}
-		//printk("comedi_: usbdux: off=%x, len=%x:",off,len);
+		/*printk("comedi_: usbdux: off=%x, len=%x:",off,len); */
 
 		/* Read the record type */
 		type = hex2unsigned(buf + 7);
@@ -2350,9 +2366,9 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 
 		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
 			firmwareBinary[idx + off] = hex2unsigned(cp);
-			//printk("%02x ",firmwareBinary[idx+off]);
+			/*printk("%02x ",firmwareBinary[idx+off]); */
 		}
-		//printk("\n");
+		/*printk("\n"); */
 
 		if (i >= size) {
 			printk("comedi_: usbdux: unexpected end of hex file\n");
@@ -2365,7 +2381,7 @@ static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 	return res;
 }
 
-// allocate memory for the urbs and initialise them
+/* allocate memory for the urbs and initialise them */
 static int usbduxsub_probe(struct usb_interface *uinterf,
 	const struct usb_device_id *id)
 {
@@ -2377,7 +2393,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	printk("comedi_: usbdux_: finding a free structure for the usb-device\n");
 #endif
 	down(&start_stop_sem);
-	// look for a free place in the usbdux array
+	/* look for a free place in the usbdux array */
 	index = -1;
 	for (i = 0; i < NUMUSBDUX; i++) {
 		if (!(usbduxsub[i].probed)) {
@@ -2386,7 +2402,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		}
 	}
 
-	// no more space
+	/* no more space */
 	if (index == -1) {
 		printk("Too many usbdux-devices connected.\n");
 		up(&start_stop_sem);
@@ -2397,25 +2413,25 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 #endif
 
 	init_MUTEX(&(usbduxsub[index].sem));
-	// save a pointer to the usb device
+	/* save a pointer to the usb device */
 	usbduxsub[index].usbdev = udev;
 
-	// 2.6: save the interface itself
+	/* 2.6: save the interface itself */
 	usbduxsub[index].interface = uinterf;
-	// get the interface number from the interface
+	/* get the interface number from the interface */
 	usbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	// hand the private data over to the usb subsystem
-	// will be needed for disconnect
+	/* hand the private data over to the usb subsystem */
+	/* will be needed for disconnect */
 	usb_set_intfdata(uinterf, &(usbduxsub[index]));
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
 #endif
-	// test if it is high speed (USB 2.0)
+	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
 		(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
 
-	// create space for the commands of the DA converter
+	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	if (!usbduxsub[index].dac_commands) {
 		printk("comedi_: usbdux: error alloc space for dac commands\n");
@@ -2423,7 +2439,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
-	// create space for the commands going to the usb device
+	/* create space for the commands going to the usb device */
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!usbduxsub[index].dux_commands) {
 		printk("comedi_: usbdux: error alloc space for dac commands\n");
@@ -2431,7 +2447,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
-	// create space for the in buffer and set it to zero
+	/* create space for the in buffer and set it to zero */
 	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].inBuffer)) {
 		printk("comedi_: usbdux: could not alloc space for inBuffer\n");
@@ -2439,7 +2455,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
-	// create space of the instruction buffer
+	/* create space of the instruction buffer */
 	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].insnBuffer)) {
 		printk("comedi_: usbdux: could not alloc space for insnBuffer\n");
@@ -2447,7 +2463,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
-	// create space for the outbuffer
+	/* create space for the outbuffer */
 	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].outBuffer)) {
 		printk("comedi_: usbdux: could not alloc space for outBuffer\n");
@@ -2479,7 +2495,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
 	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
-		// one frame: 1ms
+		/* one frame: 1ms */
 		usbduxsub[index].urbIn[i] = USB_ALLOC_URB(1);
 		if (usbduxsub[index].urbIn[i] == NULL) {
 			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
@@ -2489,8 +2505,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			return PROBE_ERR_RETURN(-ENOMEM);
 		}
 		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
-		// will be filled later with a pointer to the comedi-device
-		// and ONLY then the urb should be submitted
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbIn[i]->context = NULL;
 		usbduxsub[index].urbIn[i]->pipe =
 			usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
@@ -2527,7 +2543,7 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
 	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
-		// one frame: 1ms
+		/* one frame: 1ms */
 		usbduxsub[index].urbOut[i] = USB_ALLOC_URB(1);
 		if (usbduxsub[index].urbOut[i] == NULL) {
 			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
@@ -2537,8 +2553,8 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 			return PROBE_ERR_RETURN(-ENOMEM);
 		}
 		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
-		// will be filled later with a pointer to the comedi-device
-		// and ONLY then the urb should be submitted
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
 		usbduxsub[index].urbOut[i]->context = NULL;
 		usbduxsub[index].urbOut[i]->pipe =
 			usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
@@ -2559,17 +2575,17 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
 			SIZEOUTBUF;
 		if (usbduxsub[index].high_speed) {
-			// uframes
+			/* uframes */
 			usbduxsub[index].urbOut[i]->interval = 8;
 		} else {
-			// frames
+			/* frames */
 			usbduxsub[index].urbOut[i]->interval = 1;
 		}
 	}
 
-	// pwm
+	/* pwm */
 	if (usbduxsub[index].high_speed) {
-		usbduxsub[index].sizePwmBuf = 512;	// max bulk ep size in high speed
+		usbduxsub[index].sizePwmBuf = 512;	/* max bulk ep size in high speed */
 		usbduxsub[index].urbPwm = USB_ALLOC_URB(0);
 		if (usbduxsub[index].urbPwm == NULL) {
 			printk("comedi_: usbdux%d: Could not alloc. pwm urb\n",
@@ -2595,11 +2611,11 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	usbduxsub[index].ao_cmd_running = 0;
 	usbduxsub[index].pwm_cmd_running = 0;
 
-	// we've reached the bottom of the function
+	/* we've reached the bottom of the function */
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 	printk("comedi_: usbdux%d has been successfully initialised.\n", index);
-	// success
+	/* success */
 	return 0;
 }
 
@@ -2636,7 +2652,7 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	// find a valid device which has been detected by the probe function of the usb
+	/* find a valid device which has been detected by the probe function of the usb */
 	index = -1;
 	for (i = 0; i < NUMUSBDUX; i++) {
 		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
@@ -2652,10 +2668,10 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	}
 
 	down(&(usbduxsub[index].sem));
-	// pointer back to the corresponding comedi device
+	/* pointer back to the corresponding comedi device */
 	usbduxsub[index].comedidev = dev;
 
-	// trying to upload the firmware into the chip
+	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		read_firmware(usbduxsub + index,
@@ -2667,14 +2683,14 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 
 	/* set number of subdevices */
 	if (usbduxsub[index].high_speed) {
-		// with pwm
+		/* with pwm */
 		dev->n_subdevices = 5;
 	} else {
-		// without pwm
+		/* without pwm */
 		dev->n_subdevices = 4;
 	}
 
-	// allocate space for the subdevices
+	/* allocate space for the subdevices */
 	if ((ret = alloc_subdevices(dev, dev->n_subdevices)) < 0) {
 		printk("comedi%d: usbdux: error alloc space for subdev\n",
 			dev->minor);
@@ -2684,64 +2700,63 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 
 	printk("comedi%d: usbdux: usb-device %d is attached to comedi.\n",
 		dev->minor, index);
-	// private structure is also simply the usb-structure
+	/* private structure is also simply the usb-structure */
 	dev->private = usbduxsub + index;
 
-	// the first subdevice is the A/D converter
+	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
-	// the URBs get the comedi subdevice
-	// which is responsible for reading
-	// this is the subdevice which reads data
+	/* the URBs get the comedi subdevice */
+	/* which is responsible for reading */
+	/* this is the subdevice which reads data */
 	dev->read_subdev = s;
-	// the subdevice receives as private structure the
-	// usb-structure
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
 	s->private = NULL;
-	// analog input
+	/* analog input */
 	s->type = COMEDI_SUBD_AI;
-	// readable and ref is to ground
+	/* readable and ref is to ground */
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	// 8 channels
+	/* 8 channels */
 	s->n_chan = 8;
-	// length of the channellist
+	/* length of the channellist */
 	s->len_chanlist = 8;
-	// callback functions
+	/* callback functions */
 	s->insn_read = usbdux_ai_insn_read;
 	s->do_cmdtest = usbdux_ai_cmdtest;
 	s->do_cmd = usbdux_ai_cmd;
 	s->cancel = usbdux_ai_cancel;
-	// max value from the A/D converter (12bit)
+	/* max value from the A/D converter (12bit) */
 	s->maxdata = 0xfff;
-	// range table to convert to physical units
+	/* range table to convert to physical units */
 	s->range_table = (&range_usbdux_ai_range);
-	//
 
-	// analog out
+	/* analog out */
 	s = dev->subdevices + SUBDEV_DA;
-	// analog out
+	/* analog out */
 	s->type = COMEDI_SUBD_AO;
-	// backward pointer
+	/* backward pointer */
 	dev->write_subdev = s;
-	// the subdevice receives as private structure the
-	// usb-structure
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
 	s->private = NULL;
-	// are writable
+	/* are writable */
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	// 4 channels
+	/* 4 channels */
 	s->n_chan = 4;
-	// length of the channellist
+	/* length of the channellist */
 	s->len_chanlist = 4;
-	// 12 bit resolution
+	/* 12 bit resolution */
 	s->maxdata = 0x0fff;
-	// bipolar range
+	/* bipolar range */
 	s->range_table = (&range_usbdux_ao_range);
-	// callback
+	/* callback */
 	s->do_cmdtest = usbdux_ao_cmdtest;
 	s->do_cmd = usbdux_ao_cmd;
 	s->cancel = usbdux_ao_cancel;
 	s->insn_read = usbdux_ao_insn_read;
 	s->insn_write = usbdux_ao_insn_write;
 
-	// digital I/O
+	/* digital I/O */
 	s = dev->subdevices + SUBDEV_DIO;
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
@@ -2750,10 +2765,10 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	s->range_table = (&range_digital);
 	s->insn_bits = usbdux_dio_insn_bits;
 	s->insn_config = usbdux_dio_insn_config;
-	// we don't use it
+	/* we don't use it */
 	s->private = NULL;
 
-	//counter
+	/* counter */
 	s = dev->subdevices + SUBDEV_COUNTER;
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
@@ -2764,19 +2779,19 @@ static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 	s->insn_config = usbdux_counter_config;
 
 	if (usbduxsub[index].high_speed) {
-		//timer / pwm
+		/* timer / pwm */
 		s = dev->subdevices + SUBDEV_PWM;
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;
-		// this defines the max duty cycle resolution
+		/* this defines the max duty cycle resolution */
 		s->maxdata = usbduxsub[index].sizePwmBuf;
 		s->insn_write = usbdux_pwm_write;
 		s->insn_read = usbdux_pwm_read;
 		s->insn_config = usbdux_pwm_config;
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
-	// finally decide that it's attached
+	/* finally decide that it's attached */
 	usbduxsub[index].attached = 1;
 
 	up(&(usbduxsub[index].sem));
@@ -2808,8 +2823,8 @@ static int usbdux_detach(comedi_device *dev)
 	}
 
 	down(&usbduxsub_tmp->sem);
-	// Don't allow detach to free the private structure
-	// It's one entry of of usbduxsub[]
+	/* Don't allow detach to free the private structure */
+	/* It's one entry of of usbduxsub[] */
 	dev->private = NULL;
 	usbduxsub_tmp->attached = 0;
 	usbduxsub_tmp->comedidev = NULL;
@@ -2834,9 +2849,9 @@ static void init_usb_devices(void)
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbdux: setting all possible devs to invalid\n");
 #endif
-	// all devices entries are invalid to begin with
-	// they will become valid by the probe function
-	// and then finally by the attach-function
+	/* all devices entries are invalid to begin with */
+	/* they will become valid by the probe function */
+	/* and then finally by the attach-function */
 	for (index = 0; index < NUMUSBDUX; index++) {
 		memset(&(usbduxsub[index]), 0x00, sizeof(usbduxsub[index]));
 		init_MUTEX(&(usbduxsub[index].sem));
@@ -2860,9 +2875,9 @@ static struct usb_driver usbduxsub_driver = {
       .id_table =	usbduxsub_table,
 };
 
-// Can't use the nice macro as I have also to initialise the USB
-// subsystem:
-// registering the usb-system _and_ the comedi-driver
+/* Can't use the nice macro as I have also to initialise the USB */
+/* subsystem: */
+/* registering the usb-system _and_ the comedi-driver */
 static int init_usbdux(void)
 {
 	printk(KERN_INFO KBUILD_MODNAME ": "
@@ -2873,7 +2888,7 @@ static int init_usbdux(void)
 	return 0;
 }
 
-// deregistering the comedi driver and the usb-subsystem
+/* deregistering the comedi driver and the usb-subsystem */
 static void exit_usbdux(void)
 {
 	comedi_driver_unregister(&driver_usbdux);

commit 8fa07567bf5d824537839e6984a571daeed2c7fc
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 14:04:52 2008 -0800

    Staging: comedi: usbdux: code style cleanups
    
    Fix a lot of checkpatch.pl warnings and errors in the usbdux driver.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 331dc59c8ff5..3c51607a2e02 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -296,7 +296,7 @@ static DECLARE_MUTEX(start_stop_sem);
 
 // Stops the data acquision
 // It should be safe to call this function from any context
-static int usbduxsub_unlink_InURBs(usbduxsub_t * usbduxsub_tmp)
+static int usbduxsub_unlink_InURBs(usbduxsub_t *usbduxsub_tmp)
 {
 	int i = 0;
 	int err = 0;
@@ -317,10 +317,12 @@ static int usbduxsub_unlink_InURBs(usbduxsub_t * usbduxsub_tmp)
 	return err;
 }
 
-/* This will stop a running acquisition operation */
-// Is called from within this driver from both the
-// interrupt context and from comedi
-static int usbdux_ai_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+/*
+ * This will stop a running acquisition operation
+ * Is called from within this driver from both the
+ * interrupt context and from comedi
+ */
+static int usbdux_ai_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -460,27 +462,26 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 
 	urb->dev = this_usbduxsub->usbdev;
 
-	// resubmit the urb
+	/* resubmit the urb */
 	err = USB_SUBMIT_URB(urb);
 	if (unlikely(err < 0)) {
 		printk("comedi_: usbdux_: urb resubmit failed in int-context! err=%d ", err);
-		if (err == -EL2NSYNC) {
+		if (err == -EL2NSYNC)
 			printk("--> buggy USB host controller or bug in IRQ handler!\n");
-		} else {
+		else
 			printk("\n");
-		}
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
 		comedi_event(this_usbduxsub->comedidev, s);
-		// don't do an unlink here
+		/* don't do an unlink here */
 		usbdux_ai_stop(this_usbduxsub, 0);
 		return;
 	}
 
 	this_usbduxsub->ai_counter--;
-	if (likely(this_usbduxsub->ai_counter > 0)) {
+	if (likely(this_usbduxsub->ai_counter > 0))
 		return;
-	}
+
 	// timer zero, transfer measurements to comedi
 	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
 
@@ -518,17 +519,16 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static int usbduxsub_unlink_OutURBs(usbduxsub_t * usbduxsub_tmp)
+static int usbduxsub_unlink_OutURBs(usbduxsub_t *usbduxsub_tmp)
 {
 	int i = 0;
-
 	int err = 0;
 
 	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			if (usbduxsub_tmp->urbOut[i]) {
+			if (usbduxsub_tmp->urbOut[i])
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-			}
+
 #ifdef NOISY_DUX_DEBUGBUG
 			printk("comedi: usbdux: unlinked OutURB %d: res=%d\n",
 				i, err);
@@ -541,7 +541,7 @@ static int usbduxsub_unlink_OutURBs(usbduxsub_t * usbduxsub_tmp)
 /* This will cancel a running acquisition operation
  * in any context.
  */
-static int usbdux_ao_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+static int usbdux_ao_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -554,18 +554,16 @@ static int usbdux_ao_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi: usbdux_ao_cancel\n");
 #endif
-	if (do_unlink) {
+	if (do_unlink)
 		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
-	}
 
 	this_usbduxsub->ao_cmd_running = 0;
 
 	return ret;
 }
 
-// force unlink
-// is called by comedi
-static int usbdux_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+/* force unlink, is called by comedi */
+static int usbdux_ao_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int res = 0;
@@ -618,12 +616,12 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		/* success */
 		break;
 
-		// after an unlink command, unplug, ... etc
-		// no unlink needed here. Already shutting down.
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
+		// after an unlink command, unplug, ... etc
+		// no unlink needed here. Already shutting down.
 		if (this_usbduxsub->ao_cmd_running) {
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(this_usbduxsub->comedidev, s);
@@ -631,8 +629,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		}
 		return;
 
-		// a real error
 	default:
+		// a real error
 		if (this_usbduxsub->ao_cmd_running) {
 			printk("comedi_: usbdux_: Non-zero urb status received in ao intr context: %d\n", urb->status);
 			s->async->events |= COMEDI_CB_ERROR;
@@ -645,9 +643,9 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 
 	// are we actually running?
-	if (!(this_usbduxsub->ao_cmd_running)) {
+	if (!(this_usbduxsub->ao_cmd_running))
 		return;
-	}
+
 	// normal operation: executing a command in this subdevice
 	this_usbduxsub->ao_counter--;
 	if (this_usbduxsub->ao_counter <= 0) {
@@ -672,9 +670,9 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 			s->async->cmd.chanlist_len;
 		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 			sampl_t temp;
-			if (i >= NUMOUTCHANNELS) {
+			if (i >= NUMOUTCHANNELS)
 				break;
-			}
+
 			// pointer to the DA
 			datap = (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
 			// get the data from comedi
@@ -712,11 +710,11 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
 			printk("comedi_: usbdux_: ao urb resubm failed in int-cont.");
 			printk("ret=%d", ret);
-			if (ret == EL2NSYNC) {
+			if (ret == EL2NSYNC)
 				printk("--> buggy USB host controller or bug in IRQ handling!\n");
-			} else {
+			else
 				printk("\n");
-			}
+
 			s->async->events |= COMEDI_CB_EOA;
 			s->async->events |= COMEDI_CB_ERROR;
 			comedi_event(this_usbduxsub->comedidev, s);
@@ -726,7 +724,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_start(usbduxsub_t * usbduxsub)
+static int usbduxsub_start(usbduxsub_t *usbduxsub)
 {
 	int errcode = 0;
 	uint8_t local_transfer_buffer[16];
@@ -759,7 +757,7 @@ static int usbduxsub_start(usbduxsub_t * usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_stop(usbduxsub_t * usbduxsub)
+static int usbduxsub_stop(usbduxsub_t *usbduxsub)
 {
 	int errcode = 0;
 
@@ -790,9 +788,9 @@ static int usbduxsub_stop(usbduxsub_t * usbduxsub)
 	return 0;
 }
 
-static int usbduxsub_upload(usbduxsub_t * usbduxsub,
-	uint8_t * local_transfer_buffer,
-	unsigned int startAddr, unsigned int len)
+static int usbduxsub_upload(usbduxsub_t *usbduxsub,
+			    uint8_t *local_transfer_buffer,
+			    unsigned int startAddr, unsigned int len)
 {
 	int errcode;
 
@@ -834,8 +832,8 @@ static int usbduxsub_upload(usbduxsub_t * usbduxsub,
 	return 0;
 }
 
-int firmwareUpload(usbduxsub_t * usbduxsub,
-	uint8_t * firmwareBinary, int sizeFirmware)
+static int firmwareUpload(usbduxsub_t *usbduxsub, uint8_t *firmwareBinary,
+			  int sizeFirmware)
 {
 	int ret;
 
@@ -860,16 +858,16 @@ int firmwareUpload(usbduxsub_t * usbduxsub,
 	return 0;
 }
 
-int usbduxsub_submit_InURBs(usbduxsub_t * usbduxsub)
+static int usbduxsub_submit_InURBs(usbduxsub_t *usbduxsub)
 {
 	int i, errFlag;
 
-	if (!usbduxsub) {
+	if (!usbduxsub)
 		return -EFAULT;
-	}
+
 	/* Submit all URBs and start the transfer on the bus */
 	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
-		// in case of a resubmission after an unlink...
+		/* in case of a resubmission after an unlink... */
 		usbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;
 		usbduxsub->urbIn[i]->context = usbduxsub->comedidev;
 		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
@@ -889,7 +887,7 @@ int usbduxsub_submit_InURBs(usbduxsub_t * usbduxsub)
 	return 0;
 }
 
-int usbduxsub_submit_OutURBs(usbduxsub_t * usbduxsub)
+static int usbduxsub_submit_OutURBs(usbduxsub_t *usbduxsub)
 {
 	int i, errFlag;
 
@@ -916,8 +914,8 @@ int usbduxsub_submit_OutURBs(usbduxsub_t * usbduxsub)
 	return 0;
 }
 
-static int usbdux_ai_cmdtest(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int usbdux_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+			     comedi_cmd *cmd)
 {
 	int err = 0, tmp, i;
 	unsigned int tmpTimer;
@@ -1072,7 +1070,7 @@ static int8_t create_adc_command(unsigned int chan, int range)
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(usbduxsub_t * this_usbduxsub, int cmd_type)
+static int send_dux_commands(usbduxsub_t *this_usbduxsub, int cmd_type)
 {
 	int result, nsent;
 
@@ -1089,13 +1087,13 @@ static int send_dux_commands(usbduxsub_t * this_usbduxsub, int cmd_type)
 		usb_sndbulkpipe(this_usbduxsub->usbdev,
 			COMMAND_OUT_EP),
 		this_usbduxsub->dux_commands, SIZEOFDUXBUFFER, &nsent, 10 * HZ);
-	if (result < 0) {
+	if (result < 0)
 		printk("comedi%d: could not transmit dux_command to the usb-device, err=%d\n", this_usbduxsub->comedidev->minor, result);
-	}
+
 	return result;
 }
 
-static int receive_dux_commands(usbduxsub_t * this_usbduxsub, int command)
+static int receive_dux_commands(usbduxsub_t *this_usbduxsub, int command)
 {
 	int result = (-EFAULT);
 	int nrec;
@@ -1119,8 +1117,8 @@ static int receive_dux_commands(usbduxsub_t * this_usbduxsub, int command)
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(comedi_device * dev,
-	comedi_subdevice * s, unsigned int trignum)
+static int usbdux_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
+			     unsigned int trignum)
 {
 	int ret;
 	usbduxsub_t *this_usbduxsub = dev->private;
@@ -1160,7 +1158,7 @@ static int usbdux_ai_inttrig(comedi_device * dev,
 	return 1;
 }
 
-static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int usbdux_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, range;
@@ -1171,10 +1169,10 @@ static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi%d: usbdux_ai_cmd\n", dev->minor);
 #endif
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
-	// block other CPUs from starting an ai_cmd
+
+	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 
 	if (!(this_usbduxsub->probed)) {
@@ -1186,7 +1184,7 @@ static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
-	// set current channel of the running aquisition to zero
+	/* set current channel of the running aquisition to zero */
 	s->async->cur_chan = 0;
 
 	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
@@ -1211,20 +1209,21 @@ static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	}
 
 	if (this_usbduxsub->high_speed) {
-		// every channel gets a time window of 125us. Thus, if we
-		// sample all 8 channels we need 1ms. If we sample only
-		// one channel we need only 125us
+		/*
+		 * every channel gets a time window of 125us. Thus, if we
+		 * sample all 8 channels we need 1ms. If we sample only one
+		 * channel we need only 125us
+		 */
 		this_usbduxsub->ai_interval = 1;
-		// find a power of 2 for the interval
+		/* find a power of 2 for the interval */
 		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
 			this_usbduxsub->ai_interval =
 				(this_usbduxsub->ai_interval) * 2;
 		}
-		this_usbduxsub->ai_timer =
-			cmd->scan_begin_arg / (125000 *
+		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
 			(this_usbduxsub->ai_interval));
 	} else {
-		// interval always 1ms
+		/* interval always 1ms */
 		this_usbduxsub->ai_interval = 1;
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
 	}
@@ -1267,8 +1266,8 @@ static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 }
 
 /* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int usbdux_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+			       comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 	lsampl_t one = 0;
@@ -1314,9 +1313,9 @@ static int usbdux_ai_insn_read(comedi_device * dev,
 			return 0;
 		}
 		one = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
-		if (CR_RANGE(insn->chanspec) <= 1) {
+		if (CR_RANGE(insn->chanspec) <= 1)
 			one = one ^ 0x800;
-		}
+
 		data[i] = one;
 	}
 	up(&this_usbduxsub->sem);
@@ -1326,30 +1325,30 @@ static int usbdux_ai_insn_read(comedi_device * dev,
 //////////////////
 // analog out
 
-static int usbdux_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int usbdux_ao_insn_read(comedi_device *dev, comedi_subdevice *s,
+			       comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-	for (i = 0; i < insn->n; i++) {
+	for (i = 0; i < insn->n; i++)
 		data[i] = this_usbduxsub->outBuffer[chan];
-	}
+
 	up(&this_usbduxsub->sem);
 	return i;
 }
 
-static int usbdux_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int usbdux_ao_insn_write(comedi_device *dev, comedi_subdevice *s,
+				comedi_insn *insn, lsampl_t *data)
 {
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1358,9 +1357,9 @@ static int usbdux_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi%d: ao_insn_write\n", dev->minor);
 #endif
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1396,15 +1395,15 @@ static int usbdux_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int usbdux_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
-	unsigned int trignum)
+static int usbdux_ao_inttrig(comedi_device *dev, comedi_subdevice *s,
+			     unsigned int trignum)
 {
 	int ret;
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1433,18 +1432,18 @@ static int usbdux_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int usbdux_ao_cmdtest(comedi_device *dev, comedi_subdevice *s,
+			     comedi_cmd *cmd)
 {
 	int err = 0, tmp;
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
-	if (!(this_usbduxsub->probed)) {
+
+	if (!(this_usbduxsub->probed))
 		return -ENODEV;
-	}
+
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi%d: usbdux_ao_cmdtest\n", dev->minor);
 #endif
@@ -1566,16 +1565,16 @@ static int usbdux_ao_cmdtest(comedi_device * dev,
 	return 0;
 }
 
-static int usbdux_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int usbdux_ao_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
 	int i, ret;
 	usbduxsub_t *this_usbduxsub = dev->private;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1666,8 +1665,8 @@ static int usbdux_ao_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int usbdux_dio_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int usbdux_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+				  comedi_insn *insn, lsampl_t *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1697,16 +1696,16 @@ static int usbdux_dio_insn_config(comedi_device * dev,
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int usbdux_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+				comedi_insn *insn, lsampl_t *data)
 {
 
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int err;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
+
 
 	if (insn->n != 2)
 		return -EINVAL;
@@ -1742,18 +1741,16 @@ static int usbdux_dio_insn_bits(comedi_device * dev,
 	return 2;
 }
 
-// reads the 4 counters
-// only two are used just now
-static int usbdux_counter_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+/* reads the 4 counters, only two are used just now */
+static int usbdux_counter_read(comedi_device *dev, comedi_subdevice *s,
+			       comedi_insn *insn, lsampl_t *data)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int chan = insn->chanspec;
 	int err;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
 
 	down(&this_usbduxsub->sem);
 
@@ -1778,15 +1775,14 @@ static int usbdux_counter_read(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int usbdux_counter_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int usbdux_counter_write(comedi_device *dev, comedi_subdevice *s,
+				comedi_insn *insn, lsampl_t *data)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int err;
 
-	if (!this_usbduxsub) {
+	if (!this_usbduxsub)
 		return -EFAULT;
-	}
 
 	down(&this_usbduxsub->sem);
 
@@ -1808,8 +1804,8 @@ static int usbdux_counter_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int usbdux_counter_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
+				 comedi_insn *insn, lsampl_t *data)
 {
 	// nothing to do so far
 	return 2;
@@ -1818,7 +1814,7 @@ static int usbdux_counter_config(comedi_device * dev, comedi_subdevice * s,
 /////////////////////////////
 // PWM
 
-static int usbduxsub_unlink_PwmURBs(usbduxsub_t * usbduxsub_tmp)
+static int usbduxsub_unlink_PwmURBs(usbduxsub_t *usbduxsub_tmp)
 {
 	int err = 0;
 
@@ -1835,7 +1831,7 @@ static int usbduxsub_unlink_PwmURBs(usbduxsub_t * usbduxsub_tmp)
 /* This cancels a running acquisition operation
  * in any context.
  */
-static int usbdux_pwm_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+static int usbdux_pwm_stop(usbduxsub_t *this_usbduxsub, int do_unlink)
 {
 	int ret = 0;
 
@@ -1848,32 +1844,30 @@ static int usbdux_pwm_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi: usbdux_pwm_cancel\n");
 #endif
-	if (do_unlink) {
+	if (do_unlink)
 		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
-	}
+
 
 	this_usbduxsub->pwm_cmd_running = 0;
 
 	return ret;
 }
 
-// force unlink
-// is called by comedi
-static int usbdux_pwm_cancel(comedi_device * dev, comedi_subdevice * s)
+/* force unlink - is called by comedi */
+static int usbdux_pwm_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	int res = 0;
 
-	// unlink only if it is really running
+	/* unlink only if it is really running */
 	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi %d: sending pwm off command to the usb device.\n",
 		dev->minor);
 #endif
-	if ((res = send_dux_commands(this_usbduxsub, SENDPWMOFF)) < 0) {
+	if ((res = send_dux_commands(this_usbduxsub, SENDPWMOFF)) < 0)
 		return res;
-	}
 
 	return res;
 }
@@ -1911,19 +1905,21 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		/* success */
 		break;
 
-		// after an unlink command, unplug, ... etc
-		// no unlink needed here. Already shutting down.
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		if (this_usbduxsub->pwm_cmd_running) {
+		/*
+		 * after an unlink command, unplug, ... etc
+		 * no unlink needed here. Already shutting down.
+		 */
+		if (this_usbduxsub->pwm_cmd_running)
 			usbdux_pwm_stop(this_usbduxsub, 0);
-		}
+
 		return;
 
-		// a real error
 	default:
+		/* a real error */
 		if (this_usbduxsub->pwm_cmd_running) {
 			printk("comedi_: usbdux_: Non-zero urb status received in pwm intr context: %d\n", urb->status);
 			usbdux_pwm_stop(this_usbduxsub, 0);
@@ -1931,10 +1927,9 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		return;
 	}
 
-	// are we actually running?
-	if (!(this_usbduxsub->pwm_cmd_running)) {
+	/* are we actually running? */
+	if (!(this_usbduxsub->pwm_cmd_running))
 		return;
-	}
 
 	urb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;
 	urb->dev = this_usbduxsub->usbdev;
@@ -1943,24 +1938,24 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
 			printk("comedi_: usbdux_: pwm urb resubm failed in int-cont.");
 			printk("ret=%d", ret);
-			if (ret == EL2NSYNC) {
+			if (ret == EL2NSYNC)
 				printk("--> buggy USB host controller or bug in IRQ handling!\n");
-			} else {
+			else
 				printk("\n");
-			}
-			// don't do an unlink here
+
+			/* don't do an unlink here */
 			usbdux_pwm_stop(this_usbduxsub, 0);
 		}
 	}
 }
 
-int usbduxsub_submit_PwmURBs(usbduxsub_t * usbduxsub)
+static int usbduxsub_submit_PwmURBs(usbduxsub_t *usbduxsub)
 {
 	int errFlag;
 
-	if (!usbduxsub) {
+	if (!usbduxsub)
 		return -EFAULT;
-	}
+
 #ifdef NOISY_DUX_DEBUGBUG
 	printk("comedi_: usbdux: submitting pwm-urb\n");
 #endif
@@ -1982,13 +1977,13 @@ int usbduxsub_submit_PwmURBs(usbduxsub_t * usbduxsub)
 	return 0;
 }
 
-static int usbdux_pwm_period(comedi_device * dev, comedi_subdevice * s,
+static int usbdux_pwm_period(comedi_device *dev, comedi_subdevice *s,
 			     lsampl_t period)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
-	int fx2delay=255;
-	if (period < MIN_PWM_PERIOD)
-	{
+	int fx2delay = 255;
+
+	if (period < MIN_PWM_PERIOD) {
 		printk("comedi%d: illegal period setting for pwm.\n", dev->minor);
 		return -EAGAIN;
 	} else {
@@ -1999,10 +1994,10 @@ static int usbdux_pwm_period(comedi_device * dev, comedi_subdevice * s,
 			return -EAGAIN;
 		}
 	}
-	this_usbduxsub->pwmDelay=fx2delay;
-	this_usbduxsub->pwmPeriod=period;
+	this_usbduxsub->pwmDelay = fx2delay;
+	this_usbduxsub->pwmPeriod = period;
 #ifdef NOISY_DUX_DEBUGBUG
-	printk("usbdux_pwm_period: frequ=%d, period=%d\n",period,fx2delay);
+	printk("usbdux_pwm_period: frequ=%d, period=%d\n", period, fx2delay);
 #endif
 	return 0;
 }
@@ -2098,37 +2093,36 @@ static int usbdux_pwm_write(comedi_device * dev, comedi_subdevice * s,
 
 	// the sign is set via a special INSN only, this gives us 8 bits for
 	// normal operation
-	return usbdux_pwm_pattern(dev,s,
-				  CR_CHAN(insn->chanspec),
-				  data[0],
-				  0); // relay sign 0 by default
+	// relay sign 0 by default
+	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
+				  data[0], 0);
 }
 
-
-static int usbdux_pwm_read(comedi_device * x1, comedi_subdevice * x2,
-	comedi_insn * x3, lsampl_t * x4)
+static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
+			   comedi_insn *x3, lsampl_t *x4)
 {
-	// not needed
+	/* not needed */
 	return -EINVAL;
 };
 
-// switches on/off PWM
-static int usbdux_pwm_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+/* switches on/off PWM */
+static int usbdux_pwm_config(comedi_device *dev, comedi_subdevice *s,
+			     comedi_insn *insn, lsampl_t *data)
 {
 	usbduxsub_t *this_usbduxsub = dev->private;
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 #ifdef NOISY_DUX_DEBUGBUG
-		// switch it on
+		/* switch it on */
 		printk("comedi%d: pwm_insn_config: pwm on\n",
 		       dev->minor);
 #endif
-		// if not zero the PWM is limited to a certain time which is
-		// not supported here
-		if (data[1]!=0) {
+		/*
+		 * if not zero the PWM is limited to a certain time which is
+		 * not supported here
+		 */
+		if (data[1] != 0)
 			return -EINVAL;
-		}
 		return usbdux_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
 #ifdef NOISY_DUX_DEBUGBUG
@@ -2137,8 +2131,10 @@ static int usbdux_pwm_config(comedi_device * dev, comedi_subdevice * s,
 #endif
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
-		// to check if the USB transmission has failed or in case
-		// PWM was limited to n cycles to check if it has terminated
+		/*
+		 * to check if the USB transmission has failed or in case PWM
+		 * was limited to n cycles to check if it has terminated
+		 */
 		data[1] = this_usbduxsub->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
@@ -2146,37 +2142,41 @@ static int usbdux_pwm_config(comedi_device * dev, comedi_subdevice * s,
 		printk("comedi%d: pwm_insn_config: setting period\n",
 		       dev->minor);
 #endif
-		return usbdux_pwm_period(dev,s,data[1]);
+		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
 		data[1] = this_usbduxsub->pwmPeriod;
 		return 0;
 	case INSN_CONFIG_PWM_SET_H_BRIDGE:
-		// value in the first byte and the sign in the second for a relay
+		/* value in the first byte and the sign in the second for a
+		   relay */
 		return usbdux_pwm_pattern(dev, s,
-					  CR_CHAN(insn->chanspec), // the channel number
-					  data[1], // actual PWM data
-					  (data[2]!=0)); // just a sign
+					  /* the channel number */
+					  CR_CHAN(insn->chanspec),
+					  /* actual PWM data */
+					  data[1],
+					  /* just a sign */
+					  (data[2] != 0));
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
-		// values are not kept in this driver, nothing to return here
+		/* values are not kept in this driver, nothing to return here */
 		return -EINVAL;
 	}
 	return -EINVAL;
 }
 
-// end of PWM
-///////////////////////////////////////////////////////////////////
+/* end of PWM */
+/*****************************************************************/
 
-static void tidy_up(usbduxsub_t * usbduxsub_tmp)
+static void tidy_up(usbduxsub_t *usbduxsub_tmp)
 {
 	int i;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbdux: tiding up\n");
 #endif
-	if (!usbduxsub_tmp) {
+	if (!usbduxsub_tmp)
 		return;
-	}
-	// shows the usb subsystem that the driver is down
+
+	/* shows the usb subsystem that the driver is down */
 	if (usbduxsub_tmp->interface)
 		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
 
@@ -2227,34 +2227,22 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 			usbduxsub_tmp->pwm_cmd_running = 0;
 			usbduxsub_unlink_PwmURBs(usbduxsub_tmp);
 		}
-		if (usbduxsub_tmp->urbPwm->transfer_buffer) {
-			kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
-			usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
-		}
+		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
+		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
 		usb_kill_urb(usbduxsub_tmp->urbPwm);
 		usb_free_urb(usbduxsub_tmp->urbPwm);
 		usbduxsub_tmp->urbPwm = NULL;
 	}
-	if (usbduxsub_tmp->inBuffer) {
-		kfree(usbduxsub_tmp->inBuffer);
-		usbduxsub_tmp->inBuffer = NULL;
-	}
-	if (usbduxsub_tmp->insnBuffer) {
-		kfree(usbduxsub_tmp->insnBuffer);
-		usbduxsub_tmp->insnBuffer = NULL;
-	}
-	if (usbduxsub_tmp->inBuffer) {
-		kfree(usbduxsub_tmp->inBuffer);
-		usbduxsub_tmp->inBuffer = NULL;
-	}
-	if (usbduxsub_tmp->dac_commands) {
-		kfree(usbduxsub_tmp->dac_commands);
-		usbduxsub_tmp->dac_commands = NULL;
-	}
-	if (usbduxsub_tmp->dux_commands) {
-		kfree(usbduxsub_tmp->dux_commands);
-		usbduxsub_tmp->dux_commands = NULL;
-	}
+	kfree(usbduxsub_tmp->inBuffer);
+	usbduxsub_tmp->inBuffer = NULL;
+	kfree(usbduxsub_tmp->insnBuffer);
+	usbduxsub_tmp->insnBuffer = NULL;
+	kfree(usbduxsub_tmp->inBuffer);
+	usbduxsub_tmp->inBuffer = NULL;
+	kfree(usbduxsub_tmp->dac_commands);
+	usbduxsub_tmp->dac_commands = NULL;
+	kfree(usbduxsub_tmp->dux_commands);
+	usbduxsub_tmp->dux_commands = NULL;
 	usbduxsub_tmp->ai_cmd_running = 0;
 	usbduxsub_tmp->ao_cmd_running = 0;
 	usbduxsub_tmp->pwm_cmd_running = 0;
@@ -2263,24 +2251,25 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 static unsigned hex2unsigned(char *h)
 {
 	unsigned hi, lo;
-	if (h[0] > '9') {
+
+	if (h[0] > '9')
 		hi = h[0] - 'A' + 0x0a;
-	} else {
+	else
 		hi = h[0] - '0';
-	}
-	if (h[1] > '9') {
+
+	if (h[1] > '9')
 		lo = h[1] - 'A' + 0x0a;
-	} else {
+	else
 		lo = h[1] - '0';
-	}
+
 	return hi * 0x10 + lo;
 }
 
-// for FX2
+/* for FX2 */
 #define FIRMWARE_MAX_LEN 0x2000
 
-// taken from David Brownell's fxload and adjusted for this driver
-static int read_firmware(usbduxsub_t * usbduxsub, void *firmwarePtr, long size)
+/* taken from David Brownell's fxload and adjusted for this driver */
+static int read_firmware(usbduxsub_t *usbduxsub, void *firmwarePtr, long size)
 {
 	int i = 0;
 	unsigned char *fp = (char *)firmwarePtr;
@@ -2335,9 +2324,9 @@ static int read_firmware(usbduxsub_t * usbduxsub, void *firmwarePtr, long size)
 		/* Read the target offset */
 		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
 
-		if ((off + len) > maxAddr) {
+		if ((off + len) > maxAddr)
 			maxAddr = off + len;
-		}
+
 
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
 			printk("comedi_: usbdux: firmware upload goes beyond FX2 RAM boundaries.");
@@ -2349,9 +2338,9 @@ static int read_firmware(usbduxsub_t * usbduxsub, void *firmwarePtr, long size)
 		type = hex2unsigned(buf + 7);
 
 		/* If this is an EOF record, then make it so. */
-		if (type == 1) {
+		if (type == 1)
 			break;
-		}
+
 
 		if (type != 0) {
 			printk("comedi_: usbdux: unsupported record type: %u\n",
@@ -2466,20 +2455,20 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENOMEM);
 	}
-	// setting to alternate setting 3: enabling iso ep and bulk ep.
+	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
 	i = usb_set_interface(usbduxsub[index].usbdev,
-		usbduxsub[index].ifnum, 3);
+			      usbduxsub[index].ifnum, 3);
 	if (i < 0) {
 		printk("comedi_: usbdux%d: could not set alternate setting 3 in high speed.\n", index);
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return PROBE_ERR_RETURN(-ENODEV);
 	}
-	if (usbduxsub[index].high_speed) {
+	if (usbduxsub[index].high_speed)
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
-	} else {
+	else
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
-	}
+
 	usbduxsub[index].urbIn =
 		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
 		GFP_KERNEL);
@@ -2522,12 +2511,12 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbIn[i]->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
-	// out
-	if (usbduxsub[index].high_speed) {
+	/* out */
+	if (usbduxsub[index].high_speed)
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
-	} else {
+	else
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
-	}
+
 	usbduxsub[index].urbOut =
 		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
 		GFP_KERNEL);
@@ -2637,8 +2626,8 @@ static void usbduxsub_disconnect(struct usb_interface *intf)
 #endif
 }
 
-// is called when comedi-config is called
-static int usbdux_attach(comedi_device * dev, comedi_devconfig * it)
+/* is called when comedi-config is called */
+static int usbdux_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -2799,7 +2788,7 @@ static int usbdux_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static int usbdux_detach(comedi_device * dev)
+static int usbdux_detach(comedi_device *dev)
 {
 	usbduxsub_t *usbduxsub_tmp;
 
@@ -2833,10 +2822,10 @@ static int usbdux_detach(comedi_device * dev)
 
 /* main driver struct */
 static comedi_driver driver_usbdux = {
-      driver_name:"usbdux",
-      module:THIS_MODULE,
-      attach:usbdux_attach,
-      detach:usbdux_detach,
+      .driver_name =	"usbdux",
+      .module =		THIS_MODULE,
+      .attach =		usbdux_attach,
+      .detach =		usbdux_detach,
 };
 
 static void init_usb_devices(void)
@@ -2854,26 +2843,21 @@ static void init_usb_devices(void)
 	}
 }
 
-// Table with the USB-devices: just now only testing IDs
+/* Table with the USB-devices: just now only testing IDs */
 static struct usb_device_id usbduxsub_table[] = {
-	{USB_DEVICE(0x13d8, 0x0001),
-		},
-	{USB_DEVICE(0x13d8, 0x0002)
-		},
+	{USB_DEVICE(0x13d8, 0x0001) },
+	{USB_DEVICE(0x13d8, 0x0002) },
 	{}			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, usbduxsub_table);
 
-// The usbduxsub-driver
+/* The usbduxsub-driver */
 static struct usb_driver usbduxsub_driver = {
-#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-      owner:THIS_MODULE,
-#endif
-      name:BOARDNAME,
-      probe:usbduxsub_probe,
-      disconnect:usbduxsub_disconnect,
-      id_table:usbduxsub_table,
+      .name =		BOARDNAME,
+      .probe =		usbduxsub_probe,
+      .disconnect =	usbduxsub_disconnect,
+      .id_table =	usbduxsub_table,
 };
 
 // Can't use the nice macro as I have also to initialise the USB

commit 4398ecfac1cfe26ee63d0d4151cf9c3fa89e81d1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Nov 18 11:59:49 2008 -0800

    Staging: comedi: usbdux: remove kernel version checks
    
    Now that we are in the kernel tree, these ifdefs are not needed.
    
    Cc: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index 33205530b0d3..331dc59c8ff5 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -251,10 +251,8 @@ typedef struct {
 	int16_t *outBuffer;
 	// interface number
 	int ifnum;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	// interface structure in 2.6
 	struct usb_interface *interface;
-#endif
 	// comedi device for the interrupt context
 	comedi_device *comedidev;
 	// is it USB_SPEED_HIGH or not?
@@ -301,24 +299,14 @@ static DECLARE_MUTEX(start_stop_sem);
 static int usbduxsub_unlink_InURBs(usbduxsub_t * usbduxsub_tmp)
 {
 	int i = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-	int j = 0;
-#endif
 	int err = 0;
 
 	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
 		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
 			if (usbduxsub_tmp->urbIn[i]) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-				j = usb_unlink_urb(usbduxsub_tmp->urbIn[i]);
-				if (j < 0) {
-					err = j;
-				}
-#else
 				// We wait here until all transfers
 				// have been cancelled.
 				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
-#endif
 			}
 #ifdef NOISY_DUX_DEBUGBUG
 			printk("comedi: usbdux: unlinked InURB %d, err=%d\n",
@@ -385,11 +373,7 @@ static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 
 // analogue IN
 // interrupt service routine
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 static void usbduxsub_ai_IsocIrq(struct urb *urb)
-#else
-static void usbduxsub_ai_IsocIrq(struct urb *urb PT_REGS_ARG)
-#endif
 {
 	int i, err, n;
 	usbduxsub_t *this_usbduxsub;
@@ -537,23 +521,13 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb PT_REGS_ARG)
 static int usbduxsub_unlink_OutURBs(usbduxsub_t * usbduxsub_tmp)
 {
 	int i = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-	int j = 0;
-#endif
 
 	int err = 0;
 
 	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i]) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-				j = usb_unlink_urb(usbduxsub_tmp->urbOut[i]);
-				if (j < err) {
-					err = j;
-				}
-#else
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-#endif
 			}
 #ifdef NOISY_DUX_DEBUGBUG
 			printk("comedi: usbdux: unlinked OutURB %d: res=%d\n",
@@ -612,13 +586,8 @@ static int usbdux_ao_cancel(comedi_device * dev, comedi_subdevice * s)
 	return res;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 static void usbduxsub_ao_IsocIrq(struct urb *urb)
 {
-#else
-static void usbduxsub_ao_IsocIrq(struct urb *urb PT_REGS_ARG)
-{
-#endif
 	int i, ret;
 	int8_t *datap;
 	usbduxsub_t *this_usbduxsub;
@@ -1851,23 +1820,11 @@ static int usbdux_counter_config(comedi_device * dev, comedi_subdevice * s,
 
 static int usbduxsub_unlink_PwmURBs(usbduxsub_t * usbduxsub_tmp)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-	int j = 0;
-#endif
-
 	int err = 0;
 
 	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
-		if (usbduxsub_tmp->urbPwm) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
-			j = usb_unlink_urb(usbduxsub_tmp->urbPwm);
-			if (j < err) {
-				err = j;
-			}
-#else
+		if (usbduxsub_tmp->urbPwm)
 			usb_kill_urb(usbduxsub_tmp->urbPwm);
-#endif
-		}
 #ifdef NOISY_DUX_DEBUGBUG
 		printk("comedi: usbdux: unlinked PwmURB: res=%d\n", err);
 #endif
@@ -1921,13 +1878,8 @@ static int usbdux_pwm_cancel(comedi_device * dev, comedi_subdevice * s)
 	return res;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
-#else
-static void usbduxsub_pwm_irq(struct urb *urb, struct pt_regs *regs)
-{
-#endif
 	int ret;
 	usbduxsub_t *this_usbduxsub;
 	comedi_device *this_comedidev;
@@ -2224,12 +2176,9 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 	if (!usbduxsub_tmp) {
 		return;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	// shows the usb subsystem that the driver is down
-	if (usbduxsub_tmp->interface) {
+	if (usbduxsub_tmp->interface)
 		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
-	}
-#endif
 
 	usbduxsub_tmp->probed = 0;
 
@@ -2244,9 +2193,7 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 				usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
 			}
 			if (usbduxsub_tmp->urbIn[i]) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
 				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
-#endif
 				usb_free_urb(usbduxsub_tmp->urbIn[i]);
 				usbduxsub_tmp->urbIn[i] = NULL;
 			}
@@ -2267,9 +2214,7 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 					NULL;
 			}
 			if (usbduxsub_tmp->urbOut[i]) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-#endif
 				usb_free_urb(usbduxsub_tmp->urbOut[i]);
 				usbduxsub_tmp->urbOut[i] = NULL;
 			}
@@ -2286,9 +2231,7 @@ static void tidy_up(usbduxsub_t * usbduxsub_tmp)
 			kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
 			usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
 		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
 		usb_kill_urb(usbduxsub_tmp->urbPwm);
-#endif
 		usb_free_urb(usbduxsub_tmp->urbPwm);
 		usbduxsub_tmp->urbPwm = NULL;
 	}
@@ -2434,16 +2377,10 @@ static int read_firmware(usbduxsub_t * usbduxsub, void *firmwarePtr, long size)
 }
 
 // allocate memory for the urbs and initialise them
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static void *usbduxsub_probe(struct usb_device *udev,
-	unsigned int interfnum, const struct usb_device_id *id)
-{
-#else
 static int usbduxsub_probe(struct usb_interface *uinterf,
 	const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
-#endif
 	int i;
 	int index;
 
@@ -2474,10 +2411,6 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	// save a pointer to the usb device
 	usbduxsub[index].usbdev = udev;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	// save the interface number
-	usbduxsub[index].ifnum = interfnum;
-#else
 	// 2.6: save the interface itself
 	usbduxsub[index].interface = uinterf;
 	// get the interface number from the interface
@@ -2485,7 +2418,6 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	// hand the private data over to the usb subsystem
 	// will be needed for disconnect
 	usb_set_intfdata(uinterf, &(usbduxsub[index]));
-#endif
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk("comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
@@ -2678,24 +2610,15 @@ static int usbduxsub_probe(struct usb_interface *uinterf,
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 	printk("comedi_: usbdux%d has been successfully initialised.\n", index);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-	return (void *)(&usbduxsub[index]);
-#else
 	// success
 	return 0;
-#endif
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
-static void usbduxsub_disconnect(struct usb_device *udev, void *ptr)
-{
-	usbduxsub_t *usbduxsub_tmp = (usbduxsub_t *) ptr;
-#else
 static void usbduxsub_disconnect(struct usb_interface *intf)
 {
 	usbduxsub_t *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
-#endif
+
 	if (!usbduxsub_tmp) {
 		printk("comedi_: usbdux: disconnect called with null pointer.\n");
 		return;

commit 4bf21fa4dabaa8803906c6548496fcf12b15b10f
Author: Bernd Porr <BerndPorr@f2s.com>
Date:   Fri Nov 14 14:46:04 2008 -0800

    Staging: comedi: add usb usbdux driver
    
    University of Stirling USB DAQ & INCITE Technology Limited driver.
    
    From: Bernd Porr <BerndPorr@f2s.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
new file mode 100644
index 000000000000..33205530b0d3
--- /dev/null
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -0,0 +1,2981 @@
+#define DRIVER_VERSION "v2.1"
+#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
+#define DRIVER_DESC "Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com"
+/*
+   comedi/drivers/usbdux.c
+   Copyright (C) 2003-2007 Bernd Porr, Bernd.Porr@f2s.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+ */
+/*
+Driver: usbdux
+Description: University of Stirling USB DAQ & INCITE Technology Limited
+Devices: [ITL] USB-DUX (usbdux.o)
+Author: Bernd Porr <BerndPorr@f2s.com>
+Updated: 25 Nov 2007
+Status: Testing
+Configuration options:
+  You have to upload firmware with the -i option. The
+  firmware is usually installed under /usr/share/usb or
+  /usr/local/share/usb or /lib/firmware.
+
+Connection scheme for the counter at the digital port:
+  0=/CLK0, 1=UP/DOWN0, 2=RESET0, 4=/CLK1, 5=UP/DOWN1, 6=RESET1.
+  The sampling rate of the counter is approximately 500Hz.
+
+Please note that under USB2.0 the length of the channel list determines
+the max sampling rate. If you sample only one channel you get 8kHz
+sampling rate. If you sample two channels you get 4kHz and so on.
+*/
+/*
+ * I must give credit here to Chris Baugher who
+ * wrote the driver for AT-MIO-16d. I used some parts of this
+ * driver. I also must give credits to David Brownell
+ * who supported me with the USB development.
+ *
+ * Bernd Porr
+ *
+ *
+ * Revision history:
+ * 0.94: D/A output should work now with any channel list combinations
+ * 0.95: .owner commented out for kernel vers below 2.4.19
+ *       sanity checks in ai/ao_cmd
+ * 0.96: trying to get it working with 2.6, moved all memory alloc to comedi's attach final USB IDs
+ *       moved memory allocation completely to the corresponding comedi functions
+ *       firmware upload is by fxload and no longer by comedi (due to enumeration)
+ * 0.97: USB IDs received, adjusted table
+ * 0.98: SMP, locking, memroy alloc: moved all usb memory alloc
+ *       to the usb subsystem and moved all comedi related memory
+ *       alloc to comedi.
+ *       | kernel | registration | usbdux-usb | usbdux-comedi | comedi |
+ * 0.99: USB 2.0: changed protocol to isochronous transfer
+ *                IRQ transfer is too buggy and too risky in 2.0
+ *                for the high speed ISO transfer is now a working version available
+ * 0.99b: Increased the iso transfer buffer for high sp.to 10 buffers. Some VIA
+ *        chipsets miss out IRQs. Deeper buffering is needed.
+ * 1.00: full USB 2.0 support for the A/D converter. Now: max 8kHz sampling rate.
+ *       Firmware vers 1.00 is needed for this.
+ *       Two 16 bit up/down/reset counter with a sampling rate of 1kHz
+ *       And loads of cleaning up, in particular streamlining the
+ *       bulk transfers.
+ * 1.1:  moved EP4 transfers to EP1 to make space for a PWM output on EP4
+ * 1.2:  added PWM suport via EP4
+ * 2.0:  PWM seems to be stable and is not interfering with the other functions
+ * 2.1:  changed PWM API
+ *
+ */
+
+// generates loads of debug info
+// #define NOISY_DUX_DEBUGBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/smp_lock.h>
+#include <linux/fcntl.h>
+#include <linux/compiler.h>
+
+#include "../comedidev.h"
+#include "../usb.h"
+
+#define BOARDNAME "usbdux"
+
+// timeout for the USB-transfer
+#define EZTIMEOUT 30
+
+// constants for "firmware" upload and download
+#define USBDUXSUB_FIRMWARE 0xA0
+#define VENDOR_DIR_IN  0xC0
+#define VENDOR_DIR_OUT 0x40
+
+// internal adresses of the 8051 processor
+#define USBDUXSUB_CPUCS 0xE600
+
+// the minor device number, major is 180
+// only for debugging purposes and to
+// upload special firmware (programming the
+// eeprom etc) which is not compatible with
+// the comedi framwork
+#define USBDUXSUB_MINOR 32
+
+// max lenghth of the transfer-buffer for software upload
+#define TB_LEN 0x2000
+
+// Input endpoint number: ISO/IRQ
+#define ISOINEP           6
+
+// Output endpoint number: ISO/IRQ
+#define ISOOUTEP          2
+
+// This EP sends DUX commands to USBDUX
+#define COMMAND_OUT_EP     1
+
+// This EP receives the DUX commands from USBDUX
+#define COMMAND_IN_EP        8
+
+// Output endpoint for PWM
+#define PWM_EP         4
+
+// 300Hz max frequ under PWM
+#define MIN_PWM_PERIOD  ((long)(1E9/300))
+
+// Default PWM frequency
+#define PWM_DEFAULT_PERIOD ((long)(1E9/100))
+
+// Number of channels
+#define NUMCHANNELS       8
+
+// Size of one A/D value
+#define SIZEADIN          ((sizeof(int16_t)))
+
+// Size of the input-buffer IN BYTES
+// Always multiple of 8 for 8 microframes which is needed in the highspeed mode
+#define SIZEINBUF         ((8*SIZEADIN))
+
+// 16 bytes.
+#define SIZEINSNBUF       16
+
+// Number of DA channels
+#define NUMOUTCHANNELS    8
+
+// size of one value for the D/A converter: channel and value
+#define SIZEDAOUT          ((sizeof(int8_t)+sizeof(int16_t)))
+
+// Size of the output-buffer in bytes
+// Actually only the first 4 triplets are used but for the
+// high speed mode we need to pad it to 8 (microframes).
+#define SIZEOUTBUF         ((8*SIZEDAOUT))
+
+// Size of the buffer for the dux commands: just now max size is determined
+// by the analogue out + command byte + panic bytes...
+#define SIZEOFDUXBUFFER    ((8*SIZEDAOUT+2))
+
+// Number of in-URBs which receive the data: min=2
+#define NUMOFINBUFFERSFULL     5
+
+// Number of out-URBs which send the data: min=2
+#define NUMOFOUTBUFFERSFULL    5
+
+// Number of in-URBs which receive the data: min=5
+#define NUMOFINBUFFERSHIGH     10	// must have more buffers due to buggy USB ctr
+
+// Number of out-URBs which send the data: min=5
+#define NUMOFOUTBUFFERSHIGH    10	// must have more buffers due to buggy USB ctr
+
+// Total number of usbdux devices
+#define NUMUSBDUX             16
+
+// Analogue in subdevice
+#define SUBDEV_AD             0
+
+// Analogue out subdevice
+#define SUBDEV_DA             1
+
+// Digital I/O
+#define SUBDEV_DIO            2
+
+// counter
+#define SUBDEV_COUNTER        3
+
+// timer aka pwm output
+#define SUBDEV_PWM            4
+
+// number of retries to get the right dux command
+#define RETRIES 10
+
+/////////////////////////////////////////////
+// comedi constants
+static const comedi_lrange range_usbdux_ai_range = { 4, {
+			BIP_RANGE(4.096),
+			BIP_RANGE(4.096 / 2),
+			UNI_RANGE(4.096),
+			UNI_RANGE(4.096 / 2)
+	}
+};
+
+static const comedi_lrange range_usbdux_ao_range = { 2, {
+			BIP_RANGE(4.096),
+			UNI_RANGE(4.096),
+	}
+};
+
+/*
+ * private structure of one subdevice
+ */
+
+// This is the structure which holds all the data of this driver
+// one sub device just now: A/D
+typedef struct {
+	// attached?
+	int attached;
+	// is it associated with a subdevice?
+	int probed;
+	// pointer to the usb-device
+	struct usb_device *usbdev;
+	// actual number of in-buffers
+	int numOfInBuffers;
+	// actual number of out-buffers
+	int numOfOutBuffers;
+	// ISO-transfer handling: buffers
+	struct urb **urbIn;
+	struct urb **urbOut;
+	// pwm-transfer handling
+	struct urb *urbPwm;
+	// PWM period
+	lsampl_t pwmPeriod;
+	// PWM internal delay for the GPIF in the FX2
+	int8_t pwmDelay;
+	// size of the PWM buffer which holds the bit pattern
+	int sizePwmBuf;
+	// input buffer for the ISO-transfer
+	int16_t *inBuffer;
+	// input buffer for single insn
+	int16_t *insnBuffer;
+	// output buffer for single DA outputs
+	int16_t *outBuffer;
+	// interface number
+	int ifnum;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	// interface structure in 2.6
+	struct usb_interface *interface;
+#endif
+	// comedi device for the interrupt context
+	comedi_device *comedidev;
+	// is it USB_SPEED_HIGH or not?
+	short int high_speed;
+	// asynchronous command is running
+	short int ai_cmd_running;
+	short int ao_cmd_running;
+	// pwm is running
+	short int pwm_cmd_running;
+	// continous aquisition
+	short int ai_continous;
+	short int ao_continous;
+	// number of samples to aquire
+	int ai_sample_count;
+	int ao_sample_count;
+	// time between samples in units of the timer
+	unsigned int ai_timer;
+	unsigned int ao_timer;
+	// counter between aquisitions
+	unsigned int ai_counter;
+	unsigned int ao_counter;
+	// interval in frames/uframes
+	unsigned int ai_interval;
+	// D/A commands
+	int8_t *dac_commands;
+	// commands
+	int8_t *dux_commands;
+	struct semaphore sem;
+} usbduxsub_t;
+
+// The pointer to the private usb-data of the driver
+// is also the private data for the comedi-device.
+// This has to be global as the usb subsystem needs
+// global variables. The other reason is that this
+// structure must be there _before_ any comedi
+// command is issued. The usb subsystem must be
+// initialised before comedi can access it.
+static usbduxsub_t usbduxsub[NUMUSBDUX];
+
+static DECLARE_MUTEX(start_stop_sem);
+
+// Stops the data acquision
+// It should be safe to call this function from any context
+static int usbduxsub_unlink_InURBs(usbduxsub_t * usbduxsub_tmp)
+{
+	int i = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+	int j = 0;
+#endif
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
+		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
+			if (usbduxsub_tmp->urbIn[i]) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+				j = usb_unlink_urb(usbduxsub_tmp->urbIn[i]);
+				if (j < 0) {
+					err = j;
+				}
+#else
+				// We wait here until all transfers
+				// have been cancelled.
+				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+#endif
+			}
+#ifdef NOISY_DUX_DEBUGBUG
+			printk("comedi: usbdux: unlinked InURB %d, err=%d\n",
+				i, err);
+#endif
+		}
+	}
+	return err;
+}
+
+/* This will stop a running acquisition operation */
+// Is called from within this driver from both the
+// interrupt context and from comedi
+static int usbdux_ai_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub) {
+		printk("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+		return -EFAULT;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi: usbdux_ai_stop\n");
+#endif
+
+	if (do_unlink) {
+		// stop aquistion
+		ret = usbduxsub_unlink_InURBs(this_usbduxsub);
+	}
+
+	this_usbduxsub->ai_cmd_running = 0;
+
+	return ret;
+}
+
+// This will cancel a running acquisition operation.
+// This is called by comedi but never from inside the
+// driver.
+static int usbdux_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	usbduxsub_t *this_usbduxsub;
+	int res = 0;
+
+	// force unlink of all urbs
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi: usbdux_ai_cancel\n");
+#endif
+	this_usbduxsub = dev->private;
+	if (!this_usbduxsub) {
+		printk("comedi: usbdux_ai_cancel: this_usbduxsub=NULL\n");
+		return -EFAULT;
+	}
+	// prevent other CPUs from submitting new commands just now
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	// unlink only if the urb really has been submitted
+	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
+	up(&this_usbduxsub->sem);
+	return res;
+}
+
+// analogue IN
+// interrupt service routine
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbduxsub_ai_IsocIrq(struct urb *urb)
+#else
+static void usbduxsub_ai_IsocIrq(struct urb *urb PT_REGS_ARG)
+#endif
+{
+	int i, err, n;
+	usbduxsub_t *this_usbduxsub;
+	comedi_device *this_comedidev;
+	comedi_subdevice *s;
+
+	// sanity checks
+	// is the urb there?
+	if (!urb) {
+		printk("comedi_: usbdux_: ao int-handler called with urb=NULL!\n");
+		return;
+	}
+	// the context variable points to the subdevice
+	this_comedidev = urb->context;
+	if (unlikely(!this_comedidev)) {
+		printk("comedi_: usbdux_: BUG! urb context is a NULL pointer!\n");
+		return;
+	}
+	// the private structure of the subdevice is usbduxsub_t
+	this_usbduxsub = this_comedidev->private;
+	if (unlikely(!this_usbduxsub)) {
+		printk("comedi_: usbdux_: BUG! private of comedi subdev is a NULL pointer!\n");
+		return;
+	}
+	// subdevice which is the AD converter
+	s = this_comedidev->subdevices + SUBDEV_AD;
+
+	// first we test if something unusual has just happened
+	switch (urb->status) {
+	case 0:
+		// copy the result in the transfer buffer
+		memcpy(this_usbduxsub->inBuffer,
+			urb->transfer_buffer, SIZEINBUF);
+		break;
+	case -EILSEQ:
+		// error in the ISOchronous data
+		// we don't copy the data into the transfer buffer
+		// and recycle the last data byte
+#ifdef CONFIG_COMEDI_DEBUG
+		printk("comedi%d: usbdux: CRC error in ISO IN stream.\n",
+			this_usbduxsub->comedidev->minor);
+#endif
+
+		break;
+
+		// happens after an unlink command
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		if (this_usbduxsub->ai_cmd_running) {
+			// we are still running a command
+			// tell this comedi
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			// stop the transfer w/o unlink
+			usbdux_ai_stop(this_usbduxsub, 0);
+		}
+		return;
+
+		// a real error on the bus
+	default:
+		// pass error to comedi if we are really running a command
+		if (this_usbduxsub->ai_cmd_running) {
+			printk("Non-zero urb status received in ai intr context: %d\n", urb->status);
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			// don't do an unlink here
+			usbdux_ai_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	// at this point we are reasonably sure that nothing dodgy has happened
+	// are we running a command?
+	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
+		// not running a command
+		// do not continue execution if no asynchronous command is running
+		// in particular not resubmit
+		return;
+	}
+
+	urb->dev = this_usbduxsub->usbdev;
+
+	// resubmit the urb
+	err = USB_SUBMIT_URB(urb);
+	if (unlikely(err < 0)) {
+		printk("comedi_: usbdux_: urb resubmit failed in int-context! err=%d ", err);
+		if (err == -EL2NSYNC) {
+			printk("--> buggy USB host controller or bug in IRQ handler!\n");
+		} else {
+			printk("\n");
+		}
+		s->async->events |= COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
+		comedi_event(this_usbduxsub->comedidev, s);
+		// don't do an unlink here
+		usbdux_ai_stop(this_usbduxsub, 0);
+		return;
+	}
+
+	this_usbduxsub->ai_counter--;
+	if (likely(this_usbduxsub->ai_counter > 0)) {
+		return;
+	}
+	// timer zero, transfer measurements to comedi
+	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+
+	// test, if we transmit only a fixed number of samples
+	if (!(this_usbduxsub->ai_continous)) {
+		// not continous, fixed number of samples
+		this_usbduxsub->ai_sample_count--;
+		// all samples received?
+		if (this_usbduxsub->ai_sample_count < 0) {
+			// prevent a resubmit next time
+			usbdux_ai_stop(this_usbduxsub, 0);
+			// say comedi that the acquistion is over
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			return;
+		}
+	}
+	// get the data from the USB bus and hand it over
+	// to comedi
+	n = s->async->cmd.chanlist_len;
+	for (i = 0; i < n; i++) {
+		// transfer data
+		if (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {
+			comedi_buf_put
+				(s->async,
+				le16_to_cpu(this_usbduxsub->
+					inBuffer[i]) ^ 0x800);
+		} else {
+			comedi_buf_put
+				(s->async,
+				le16_to_cpu(this_usbduxsub->inBuffer[i]));
+		}
+	}
+	// tell comedi that data is there
+	comedi_event(this_usbduxsub->comedidev, s);
+}
+
+static int usbduxsub_unlink_OutURBs(usbduxsub_t * usbduxsub_tmp)
+{
+	int i = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+	int j = 0;
+#endif
+
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
+		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
+			if (usbduxsub_tmp->urbOut[i]) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+				j = usb_unlink_urb(usbduxsub_tmp->urbOut[i]);
+				if (j < err) {
+					err = j;
+				}
+#else
+				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
+#endif
+			}
+#ifdef NOISY_DUX_DEBUGBUG
+			printk("comedi: usbdux: unlinked OutURB %d: res=%d\n",
+				i, err);
+#endif
+		}
+	}
+	return err;
+}
+
+/* This will cancel a running acquisition operation
+ * in any context.
+ */
+static int usbdux_ao_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub) {
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi?: usbdux_ao_stop: this_usbduxsub=NULL!\n");
+#endif
+		return -EFAULT;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi: usbdux_ao_cancel\n");
+#endif
+	if (do_unlink) {
+		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
+	}
+
+	this_usbduxsub->ao_cmd_running = 0;
+
+	return ret;
+}
+
+// force unlink
+// is called by comedi
+static int usbdux_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int res = 0;
+
+	if (!this_usbduxsub) {
+		printk("comedi: usbdux_ao_cancel: this_usbduxsub=NULL\n");
+		return -EFAULT;
+	}
+	// prevent other CPUs from submitting a command just now
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	// unlink only if it is really running
+	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
+	up(&this_usbduxsub->sem);
+	return res;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbduxsub_ao_IsocIrq(struct urb *urb)
+{
+#else
+static void usbduxsub_ao_IsocIrq(struct urb *urb PT_REGS_ARG)
+{
+#endif
+	int i, ret;
+	int8_t *datap;
+	usbduxsub_t *this_usbduxsub;
+	comedi_device *this_comedidev;
+	comedi_subdevice *s;
+
+	if (!urb) {
+		printk("comedi_: usbdux_: ao urb handler called with NULL ptr.\n");
+		return;
+	}
+	// the context variable points to the subdevice
+	this_comedidev = urb->context;
+	if (!this_comedidev) {
+		printk("comedi_: usbdux_: ao urb int-context is a NULL pointer.\n");
+		return;
+	}
+	// the private structure of the subdevice is usbduxsub_t
+	this_usbduxsub = this_comedidev->private;
+	if (!this_usbduxsub) {
+		printk("comedi_: usbdux_: private data structure of ao subdev is NULL p.\n");
+		return;
+	}
+
+	s = this_comedidev->subdevices + SUBDEV_DA;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+
+		// after an unlink command, unplug, ... etc
+		// no unlink needed here. Already shutting down.
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		if (this_usbduxsub->ao_cmd_running) {
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+		return;
+
+		// a real error
+	default:
+		if (this_usbduxsub->ao_cmd_running) {
+			printk("comedi_: usbdux_: Non-zero urb status received in ao intr context: %d\n", urb->status);
+			s->async->events |= COMEDI_CB_ERROR;
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			// we do an unlink if we are in the high speed mode
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	// are we actually running?
+	if (!(this_usbduxsub->ao_cmd_running)) {
+		return;
+	}
+	// normal operation: executing a command in this subdevice
+	this_usbduxsub->ao_counter--;
+	if (this_usbduxsub->ao_counter <= 0) {
+		// timer zero
+		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+
+		// handle non continous aquisition
+		if (!(this_usbduxsub->ao_continous)) {
+			// fixed number of samples
+			this_usbduxsub->ao_sample_count--;
+			if (this_usbduxsub->ao_sample_count < 0) {
+				// all samples transmitted
+				usbdux_ao_stop(this_usbduxsub, 0);
+				s->async->events |= COMEDI_CB_EOA;
+				comedi_event(this_usbduxsub->comedidev, s);
+				// no resubmit of the urb
+				return;
+			}
+		}
+		// transmit data to the USB bus
+		((uint8_t *) (urb->transfer_buffer))[0] =
+			s->async->cmd.chanlist_len;
+		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
+			sampl_t temp;
+			if (i >= NUMOUTCHANNELS) {
+				break;
+			}
+			// pointer to the DA
+			datap = (&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));
+			// get the data from comedi
+			ret = comedi_buf_get(s->async, &temp);
+			datap[0] = temp;
+			datap[1] = temp >> 8;
+			datap[2] = this_usbduxsub->dac_commands[i];
+			// printk("data[0]=%x, data[1]=%x, data[2]=%x\n",
+			// datap[0],datap[1],datap[2]);
+			if (ret < 0) {
+				printk("comedi: usbdux: buffer underflow\n");
+				s->async->events |= COMEDI_CB_EOA;
+				s->async->events |= COMEDI_CB_OVERFLOW;
+			}
+			// transmit data to comedi
+			s->async->events |= COMEDI_CB_BLOCK;
+			comedi_event(this_usbduxsub->comedidev, s);
+		}
+	}
+	urb->transfer_buffer_length = SIZEOUTBUF;
+	urb->dev = this_usbduxsub->usbdev;
+	urb->status = 0;
+	if (this_usbduxsub->ao_cmd_running) {
+		if (this_usbduxsub->high_speed) {
+			// uframes
+			urb->interval = 8;
+		} else {
+			// frames
+			urb->interval = 1;
+		}
+		urb->number_of_packets = 1;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].status = 0;
+		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
+			printk("comedi_: usbdux_: ao urb resubm failed in int-cont.");
+			printk("ret=%d", ret);
+			if (ret == EL2NSYNC) {
+				printk("--> buggy USB host controller or bug in IRQ handling!\n");
+			} else {
+				printk("\n");
+			}
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			// don't do an unlink here
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+	}
+}
+
+static int usbduxsub_start(usbduxsub_t * usbduxsub)
+{
+	int errcode = 0;
+	uint8_t local_transfer_buffer[16];
+
+	if (usbduxsub->probed) {
+		// 7f92 to zero
+		local_transfer_buffer[0] = 0;
+		errcode = USB_CONTROL_MSG(usbduxsub->usbdev,
+			// create a pipe for a control transfer
+			usb_sndctrlpipe(usbduxsub->usbdev, 0),
+			// bRequest, "Firmware"
+			USBDUXSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// Value
+			USBDUXSUB_CPUCS,
+			// Index
+			0x0000,
+			// address of the transfer buffer
+			local_transfer_buffer,
+			// Length
+			1,
+			// Timeout
+			EZTIMEOUT);
+		if (errcode < 0) {
+			printk("comedi_: usbdux_: control msg failed (start)\n");
+			return errcode;
+		}
+	}
+	return 0;
+}
+
+static int usbduxsub_stop(usbduxsub_t * usbduxsub)
+{
+	int errcode = 0;
+
+	uint8_t local_transfer_buffer[16];
+	if (usbduxsub->probed) {
+		// 7f92 to one
+		local_transfer_buffer[0] = 1;
+		errcode = USB_CONTROL_MSG
+			(usbduxsub->usbdev,
+			usb_sndctrlpipe(usbduxsub->usbdev, 0),
+			// bRequest, "Firmware"
+			USBDUXSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// Value
+			USBDUXSUB_CPUCS,
+			// Index
+			0x0000, local_transfer_buffer,
+			// Length
+			1,
+			// Timeout
+			EZTIMEOUT);
+		if (errcode < 0) {
+			printk("comedi_: usbdux: control msg failed (stop)\n");
+			return errcode;
+		}
+	}
+	return 0;
+}
+
+static int usbduxsub_upload(usbduxsub_t * usbduxsub,
+	uint8_t * local_transfer_buffer,
+	unsigned int startAddr, unsigned int len)
+{
+	int errcode;
+
+	if (usbduxsub->probed) {
+#ifdef CONFIG_COMEDI_DEBUG
+		printk("comedi%d: usbdux: uploading %d bytes",
+			usbduxsub->comedidev->minor, len);
+		printk(" to addr %d, first byte=%d.\n",
+			startAddr, local_transfer_buffer[0]);
+#endif
+		errcode = USB_CONTROL_MSG
+			(usbduxsub->usbdev,
+			usb_sndctrlpipe(usbduxsub->usbdev, 0),
+			// brequest, firmware
+			USBDUXSUB_FIRMWARE,
+			// bmRequestType
+			VENDOR_DIR_OUT,
+			// value
+			startAddr,
+			// index
+			0x0000,
+			// our local safe buffer
+			local_transfer_buffer,
+			// length
+			len,
+			// timeout
+			EZTIMEOUT);
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi_: usbdux: result=%d\n", errcode);
+#endif
+		if (errcode < 0) {
+			printk("comedi_: usbdux: uppload failed\n");
+			return errcode;
+		}
+	} else {
+		// no device on the bus for this index
+		return -EFAULT;
+	}
+	return 0;
+}
+
+int firmwareUpload(usbduxsub_t * usbduxsub,
+	uint8_t * firmwareBinary, int sizeFirmware)
+{
+	int ret;
+
+	if (!firmwareBinary) {
+		return 0;
+	}
+	ret = usbduxsub_stop(usbduxsub);
+	if (ret < 0) {
+		printk("comedi_: usbdux: can not stop firmware\n");
+		return ret;
+	}
+	ret = usbduxsub_upload(usbduxsub, firmwareBinary, 0, sizeFirmware);
+	if (ret < 0) {
+		printk("comedi_: usbdux: firmware upload failed\n");
+		return ret;
+	}
+	ret = usbduxsub_start(usbduxsub);
+	if (ret < 0) {
+		printk("comedi_: usbdux: can not start firmware\n");
+		return ret;
+	}
+	return 0;
+}
+
+int usbduxsub_submit_InURBs(usbduxsub_t * usbduxsub)
+{
+	int i, errFlag;
+
+	if (!usbduxsub) {
+		return -EFAULT;
+	}
+	/* Submit all URBs and start the transfer on the bus */
+	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
+		// in case of a resubmission after an unlink...
+		usbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;
+		usbduxsub->urbIn[i]->context = usbduxsub->comedidev;
+		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urbIn[i]->status = 0;
+		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: usbdux: submitting in-urb[%d]: %p,%p intv=%d\n", usbduxsub->comedidev->minor, i, (usbduxsub->urbIn[i]->context), (usbduxsub->urbIn[i]->dev), (usbduxsub->urbIn[i]->interval));
+#endif
+		errFlag = USB_SUBMIT_URB(usbduxsub->urbIn[i]);
+		if (errFlag) {
+			printk("comedi_: usbdux: ai: ");
+			printk("USB_SUBMIT_URB(%d)", i);
+			printk(" error %d\n", errFlag);
+			return errFlag;
+		}
+	}
+	return 0;
+}
+
+int usbduxsub_submit_OutURBs(usbduxsub_t * usbduxsub)
+{
+	int i, errFlag;
+
+	if (!usbduxsub) {
+		return -EFAULT;
+	}
+	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi_: usbdux: submitting out-urb[%d]\n", i);
+#endif
+		// in case of a resubmission after an unlink...
+		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
+		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urbOut[i]->status = 0;
+		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
+		errFlag = USB_SUBMIT_URB(usbduxsub->urbOut[i]);
+		if (errFlag) {
+			printk("comedi_: usbdux: ao: ");
+			printk("USB_SUBMIT_URB(%d)", i);
+			printk(" error %d\n", errFlag);
+			return errFlag;
+		}
+	}
+	return 0;
+}
+
+static int usbdux_ai_cmdtest(comedi_device * dev,
+	comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0, tmp, i;
+	unsigned int tmpTimer;
+	usbduxsub_t *this_usbduxsub = dev->private;
+	if (!(this_usbduxsub->probed)) {
+		return -ENODEV;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_ai_cmdtest\n", dev->minor);
+#endif
+	/* make sure triggers are valid */
+	// Only immediate triggers are allowed
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	// trigger should happen timed
+	tmp = cmd->scan_begin_src;
+	// start a new _scan_ with a timer
+	cmd->scan_begin_src &= TRIG_TIMER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	// scanning is continous
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	// issue a trigger when scan is finished and start a new scan
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	// trigger at the end of count events or not, stop condition or not
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (this_usbduxsub->high_speed) {
+			// In high speed mode microframes are possible.
+			// However, during one microframe we can roughly
+			// sample one channel. Thus, the more channels
+			// are in the channel list the more time we need.
+			i = 1;
+			// find a power of 2 for the number of channels
+			while (i < (cmd->chanlist_len)) {
+				i = i * 2;
+			}
+			if (cmd->scan_begin_arg < (1000000 / 8 * i)) {
+				cmd->scan_begin_arg = 1000000 / 8 * i;
+				err++;
+			}
+			// now calc the real sampling rate with all the rounding errors
+			tmpTimer =
+				((unsigned int)(cmd->scan_begin_arg / 125000)) *
+				125000;
+			if (cmd->scan_begin_arg != tmpTimer) {
+				cmd->scan_begin_arg = tmpTimer;
+				err++;
+			}
+		} else {	// full speed
+			// 1kHz scans every USB frame
+			if (cmd->scan_begin_arg < 1000000) {
+				cmd->scan_begin_arg = 1000000;
+				err++;
+			}
+			// calc the real sampling rate with the rounding errors
+			tmpTimer =
+				((unsigned int)(cmd->scan_begin_arg /
+					1000000)) * 1000000;
+			if (cmd->scan_begin_arg != tmpTimer) {
+				cmd->scan_begin_arg = tmpTimer;
+				err++;
+			}
+		}
+	}
+	// the same argument
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	return 0;
+}
+
+// creates the ADC command for the MAX1271
+// range is the range value from comedi
+static int8_t create_adc_command(unsigned int chan, int range)
+{
+	int8_t p = (range <= 1);
+	int8_t r = ((range % 2) == 0);
+	return (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);
+}
+
+// bulk transfers to usbdux
+
+#define SENDADCOMMANDS            0
+#define SENDDACOMMANDS            1
+#define SENDDIOCONFIGCOMMAND      2
+#define SENDDIOBITSCOMMAND        3
+#define SENDSINGLEAD              4
+#define READCOUNTERCOMMAND        5
+#define WRITECOUNTERCOMMAND       6
+#define SENDPWMON                 7
+#define SENDPWMOFF                8
+
+static int send_dux_commands(usbduxsub_t * this_usbduxsub, int cmd_type)
+{
+	int result, nsent;
+
+	this_usbduxsub->dux_commands[0] = cmd_type;
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux: dux_commands: ",
+		this_usbduxsub->comedidev->minor);
+	for (result = 0; result < SIZEOFDUXBUFFER; result++) {
+		printk(" %02x", this_usbduxsub->dux_commands[result]);
+	}
+	printk("\n");
+#endif
+	result = USB_BULK_MSG(this_usbduxsub->usbdev,
+		usb_sndbulkpipe(this_usbduxsub->usbdev,
+			COMMAND_OUT_EP),
+		this_usbduxsub->dux_commands, SIZEOFDUXBUFFER, &nsent, 10 * HZ);
+	if (result < 0) {
+		printk("comedi%d: could not transmit dux_command to the usb-device, err=%d\n", this_usbduxsub->comedidev->minor, result);
+	}
+	return result;
+}
+
+static int receive_dux_commands(usbduxsub_t * this_usbduxsub, int command)
+{
+	int result = (-EFAULT);
+	int nrec;
+	int i;
+
+	for (i = 0; i < RETRIES; i++) {
+		result = USB_BULK_MSG(this_usbduxsub->usbdev,
+			usb_rcvbulkpipe(this_usbduxsub->usbdev,
+				COMMAND_IN_EP),
+			this_usbduxsub->insnBuffer, SIZEINSNBUF, &nrec, 1 * HZ);
+		if (result < 0) {
+			printk("comedi%d: insn: USB error %d while receiving DUX command\n", this_usbduxsub->comedidev->minor, result);
+			return result;
+		}
+		if (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command) {
+			return result;
+		}
+	}
+	// this is only reached if the data has been requested a couple of times
+	printk("comedi%d: insn: wrong data returned from firmware: want cmd %d, got cmd %d.\n", this_usbduxsub->comedidev->minor, command, le16_to_cpu(this_usbduxsub->insnBuffer[0]));
+	return -EFAULT;
+}
+
+static int usbdux_ai_inttrig(comedi_device * dev,
+	comedi_subdevice * s, unsigned int trignum)
+{
+	int ret;
+	usbduxsub_t *this_usbduxsub = dev->private;
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_ai_inttrig\n", dev->minor);
+#endif
+
+	if (trignum != 0) {
+		printk("comedi%d: usbdux_ai_inttrig: invalid trignum\n",
+			dev->minor);
+		up(&this_usbduxsub->sem);
+		return -EINVAL;
+	}
+	if (!(this_usbduxsub->ai_cmd_running)) {
+		this_usbduxsub->ai_cmd_running = 1;
+		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		if (ret < 0) {
+			printk("comedi%d: usbdux_ai_inttrig: urbSubmit: err=%d\n", dev->minor, ret);
+			this_usbduxsub->ai_cmd_running = 0;
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		printk("comedi%d: ai_inttrig but acqu is already running\n",
+			dev->minor);
+	}
+	up(&this_usbduxsub->sem);
+	return 1;
+}
+
+static int usbdux_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int chan, range;
+	int i, ret;
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int result;
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_ai_cmd\n", dev->minor);
+#endif
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	// block other CPUs from starting an ai_cmd
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ai_cmd_running) {
+		printk("comedi%d: ai_cmd not possible. Another ai_cmd is running.\n", dev->minor);
+		up(&this_usbduxsub->sem);
+		return -EBUSY;
+	}
+	// set current channel of the running aquisition to zero
+	s->async->cur_chan = 0;
+
+	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		chan = CR_CHAN(cmd->chanlist[i]);
+		range = CR_RANGE(cmd->chanlist[i]);
+		if (i >= NUMCHANNELS) {
+			printk("comedi%d: channel list too long\n", dev->minor);
+			break;
+		}
+		this_usbduxsub->dux_commands[i + 2] =
+			create_adc_command(chan, range);
+	}
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi %d: sending commands to the usb device: ", dev->minor);
+	printk("size=%u\n", NUMCHANNELS);
+#endif
+	if ((result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS)) < 0) {
+		up(&this_usbduxsub->sem);
+		return result;
+	}
+
+	if (this_usbduxsub->high_speed) {
+		// every channel gets a time window of 125us. Thus, if we
+		// sample all 8 channels we need 1ms. If we sample only
+		// one channel we need only 125us
+		this_usbduxsub->ai_interval = 1;
+		// find a power of 2 for the interval
+		while ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {
+			this_usbduxsub->ai_interval =
+				(this_usbduxsub->ai_interval) * 2;
+		}
+		this_usbduxsub->ai_timer =
+			cmd->scan_begin_arg / (125000 *
+			(this_usbduxsub->ai_interval));
+	} else {
+		// interval always 1ms
+		this_usbduxsub->ai_interval = 1;
+		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
+	}
+	if (this_usbduxsub->ai_timer < 1) {
+		printk("comedi%d: usbdux: ai_cmd: timer=%d, scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, this_usbduxsub->ai_timer, cmd->scan_begin_arg);
+		up(&this_usbduxsub->sem);
+		return -EINVAL;
+	}
+	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		// data arrives as one packet
+		this_usbduxsub->ai_sample_count = cmd->stop_arg;
+		this_usbduxsub->ai_continous = 0;
+	} else {
+		// continous aquisition
+		this_usbduxsub->ai_continous = 1;
+		this_usbduxsub->ai_sample_count = 0;
+	}
+
+	if (cmd->start_src == TRIG_NOW) {
+		// enable this acquisition operation
+		this_usbduxsub->ai_cmd_running = 1;
+		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		if (ret < 0) {
+			this_usbduxsub->ai_cmd_running = 0;
+			// fixme: unlink here??
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		/* TRIG_INT */
+		// don't enable the acquision operation
+		// wait for an internal signal
+		s->async->inttrig = usbdux_ai_inttrig;
+	}
+	up(&this_usbduxsub->sem);
+	return 0;
+}
+
+/* Mode 0 is used to get a single conversion on demand */
+static int usbdux_ai_insn_read(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	lsampl_t one = 0;
+	int chan, range;
+	int err;
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		printk("comedi%d: ai_insn_read: no usb dev.\n", dev->minor);
+		return 0;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
+		dev->minor, insn->n, insn->subdev);
+#endif
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ai_cmd_running) {
+		printk("comedi%d: ai_insn_read not possible. Async Command is running.\n", dev->minor);
+		up(&this_usbduxsub->sem);
+		return 0;
+	}
+
+	// sample one channel
+	chan = CR_CHAN(insn->chanspec);
+	range = CR_RANGE(insn->chanspec);
+	// set command for the first channel
+	this_usbduxsub->dux_commands[1] = create_adc_command(chan, range);
+
+	// adc commands
+	if ((err = send_dux_commands(this_usbduxsub, SENDSINGLEAD)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	for (i = 0; i < insn->n; i++) {
+		if ((err = receive_dux_commands(this_usbduxsub,
+					SENDSINGLEAD)) < 0) {
+			up(&this_usbduxsub->sem);
+			return 0;
+		}
+		one = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
+		if (CR_RANGE(insn->chanspec) <= 1) {
+			one = one ^ 0x800;
+		}
+		data[i] = one;
+	}
+	up(&this_usbduxsub->sem);
+	return i;
+}
+
+//////////////////
+// analog out
+
+static int usbdux_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	for (i = 0; i < insn->n; i++) {
+		data[i] = this_usbduxsub->outBuffer[chan];
+	}
+	up(&this_usbduxsub->sem);
+	return i;
+}
+
+static int usbdux_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, err;
+	int chan = CR_CHAN(insn->chanspec);
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: ao_insn_write\n", dev->minor);
+#endif
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ao_cmd_running) {
+		printk("comedi%d: ao_insn_write: ERROR: asynchronous ao_cmd is running\n", dev->minor);
+		up(&this_usbduxsub->sem);
+		return 0;
+	}
+
+	for (i = 0; i < insn->n; i++) {
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
+			dev->minor, chan, i, data[i]);
+#endif
+		// number of channels: 1
+		this_usbduxsub->dux_commands[1] = 1;
+		// one 16 bit value
+		*((int16_t *) (this_usbduxsub->dux_commands + 2)) =
+			cpu_to_le16(data[i]);
+		this_usbduxsub->outBuffer[chan] = data[i];
+		// channel number
+		this_usbduxsub->dux_commands[4] = (chan << 6);
+		if ((err = send_dux_commands(this_usbduxsub,
+					SENDDACOMMANDS)) < 0) {
+			up(&this_usbduxsub->sem);
+			return err;
+		}
+	}
+	up(&this_usbduxsub->sem);
+
+	return i;
+}
+
+static int usbdux_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	int ret;
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (trignum != 0) {
+		printk("comedi%d: usbdux_ao_inttrig: invalid trignum\n",
+			dev->minor);
+		return -EINVAL;
+	}
+	if (!(this_usbduxsub->ao_cmd_running)) {
+		this_usbduxsub->ao_cmd_running = 1;
+		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		if (ret < 0) {
+			printk("comedi%d: usbdux_ao_inttrig: submitURB: err=%d\n", dev->minor, ret);
+			this_usbduxsub->ao_cmd_running = 0;
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		printk("comedi%d: ao_inttrig but acqu is already running.\n",
+			dev->minor);
+	}
+	up(&this_usbduxsub->sem);
+	return 1;
+}
+
+static int usbdux_ao_cmdtest(comedi_device * dev,
+	comedi_subdevice * s, comedi_cmd * cmd)
+{
+	int err = 0, tmp;
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	if (!(this_usbduxsub->probed)) {
+		return -ENODEV;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_ao_cmdtest\n", dev->minor);
+#endif
+	/* make sure triggers are valid */
+	// Only immediate triggers are allowed
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	// trigger should happen timed
+	tmp = cmd->scan_begin_src;
+	// just now we scan also in the high speed mode every frame
+	// this is due to ehci driver limitations
+	if (0) {		/* (this_usbduxsub->high_speed) */
+		// start immidiately a new scan
+		// the sampling rate is set by the coversion rate
+		cmd->scan_begin_src &= TRIG_FOLLOW;
+	} else {
+		// start a new scan (output at once) with a timer
+		cmd->scan_begin_src &= TRIG_TIMER;
+	}
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	// scanning is continous
+	tmp = cmd->convert_src;
+	// we always output at 1kHz just now all channels at once
+	if (0) {		/* (this_usbduxsub->high_speed) */
+		// in usb-2.0 only one conversion it tranmitted but with 8kHz/n
+		cmd->convert_src &= TRIG_TIMER;
+	} else {
+		// all conversion events happen simultaneously with a rate of 1kHz/n
+		cmd->convert_src &= TRIG_NOW;
+	}
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	// issue a trigger when scan is finished and start a new scan
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	// trigger at the end of count events or not, stop condition or not
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* timer */
+		if (cmd->scan_begin_arg < 1000000) {
+			cmd->scan_begin_arg = 1000000;
+			err++;
+		}
+	}
+	// not used now, is for later use
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < 125000) {
+			cmd->convert_arg = 125000;
+			err++;
+		}
+	}
+
+	// the same argument
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: err=%d, scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src, cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
+#endif
+
+	if (err)
+		return 3;
+
+	return 0;
+}
+
+static int usbdux_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int chan, gain;
+	int i, ret;
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_ao_cmd\n", dev->minor);
+#endif
+
+	// set current channel of the running aquisition to zero
+	s->async->cur_chan = 0;
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		chan = CR_CHAN(cmd->chanlist[i]);
+		gain = CR_RANGE(cmd->chanlist[i]);
+		if (i >= NUMOUTCHANNELS) {
+			printk("comedi%d: usbdux_ao_cmd: channel list too long\n", dev->minor);
+			break;
+		}
+		this_usbduxsub->dac_commands[i] = (chan << 6);
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: dac command for ch %d is %x\n",
+			dev->minor, i, this_usbduxsub->dac_commands[i]);
+#endif
+	}
+
+	// we count in steps of 1ms (125us)
+	// 125us mode not used yet
+	if (0) {		/* (this_usbduxsub->high_speed) */
+		// 125us
+		// timing of the conversion itself: every 125 us
+		this_usbduxsub->ao_timer = cmd->convert_arg / 125000;
+	} else {
+		// 1ms
+		// timing of the scan: we get all channels at once
+		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: usbdux: scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, convert_arg=%d\n", dev->minor, cmd->scan_begin_src, cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
+		printk("comedi%d: usbdux: ao_timer=%d (ms)\n",
+			dev->minor, this_usbduxsub->ao_timer);
+#endif
+		if (this_usbduxsub->ao_timer < 1) {
+			printk("comedi%d: usbdux: ao_timer=%d,  scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, this_usbduxsub->ao_timer, cmd->scan_begin_arg);
+			up(&this_usbduxsub->sem);
+			return -EINVAL;
+		}
+	}
+	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		// not continous
+		// counter
+		// high speed also scans everything at once
+		if (0) {	/* (this_usbduxsub->high_speed) */
+			this_usbduxsub->ao_sample_count =
+				(cmd->stop_arg) * (cmd->scan_end_arg);
+		} else {
+			// there's no scan as the scan has been
+			// perf inside the FX2
+			// data arrives as one packet
+			this_usbduxsub->ao_sample_count = cmd->stop_arg;
+		}
+		this_usbduxsub->ao_continous = 0;
+	} else {
+		// continous aquisition
+		this_usbduxsub->ao_continous = 1;
+		this_usbduxsub->ao_sample_count = 0;
+	}
+
+	if (cmd->start_src == TRIG_NOW) {
+		// enable this acquisition operation
+		this_usbduxsub->ao_cmd_running = 1;
+		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		if (ret < 0) {
+			this_usbduxsub->ao_cmd_running = 0;
+			// fixme: unlink here??
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		/* TRIG_INT */
+		// submit the urbs later
+		// wait for an internal signal
+		s->async->inttrig = usbdux_ao_inttrig;
+	}
+
+	up(&this_usbduxsub->sem);
+	return 0;
+}
+
+static int usbdux_dio_insn_config(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec);
+
+	/* The input or output configuration of each digital line is
+	 * configured by a special insn_config instruction.  chanspec
+	 * contains the channel to be changed, and data[0] contains the
+	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= 1 << chan;	/* 1 means Out */
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~(1 << chan);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+			(s->
+			io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	// we don't tell the firmware here as it would take 8 frames
+	// to submit the information. We do it in the insn_bits.
+	return insn->n;
+}
+
+static int usbdux_dio_insn_bits(comedi_device * dev,
+	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+{
+
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int err;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+	s->state &= ~data[0];
+	s->state |= data[0] & data[1];
+	this_usbduxsub->dux_commands[1] = s->io_bits;
+	this_usbduxsub->dux_commands[2] = s->state;
+
+	// This command also tells the firmware to return
+	// the digital input lines
+	if ((err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+	if ((err = receive_dux_commands(this_usbduxsub,
+				SENDDIOBITSCOMMAND)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	data[1] = le16_to_cpu(this_usbduxsub->insnBuffer[1]);
+	up(&this_usbduxsub->sem);
+	return 2;
+}
+
+// reads the 4 counters
+// only two are used just now
+static int usbdux_counter_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int chan = insn->chanspec;
+	int err;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+
+	if ((err = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	if ((err = receive_dux_commands(this_usbduxsub,
+				READCOUNTERCOMMAND)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	data[0] = le16_to_cpu(this_usbduxsub->insnBuffer[chan + 1]);
+	up(&this_usbduxsub->sem);
+	return 1;
+}
+
+static int usbdux_counter_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int err;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+
+	this_usbduxsub->dux_commands[1] = insn->chanspec;
+	*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);
+
+	if ((err = send_dux_commands(this_usbduxsub, WRITECOUNTERCOMMAND)) < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	up(&this_usbduxsub->sem);
+
+	return 1;
+}
+
+static int usbdux_counter_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	// nothing to do so far
+	return 2;
+}
+
+/////////////////////////////
+// PWM
+
+static int usbduxsub_unlink_PwmURBs(usbduxsub_t * usbduxsub_tmp)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+	int j = 0;
+#endif
+
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
+		if (usbduxsub_tmp->urbPwm) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+			j = usb_unlink_urb(usbduxsub_tmp->urbPwm);
+			if (j < err) {
+				err = j;
+			}
+#else
+			usb_kill_urb(usbduxsub_tmp->urbPwm);
+#endif
+		}
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi: usbdux: unlinked PwmURB: res=%d\n", err);
+#endif
+	}
+	return err;
+}
+
+/* This cancels a running acquisition operation
+ * in any context.
+ */
+static int usbdux_pwm_stop(usbduxsub_t * this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub) {
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi?: usbdux_pwm_stop: this_usbduxsub=NULL!\n");
+#endif
+		return -EFAULT;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi: usbdux_pwm_cancel\n");
+#endif
+	if (do_unlink) {
+		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
+	}
+
+	this_usbduxsub->pwm_cmd_running = 0;
+
+	return ret;
+}
+
+// force unlink
+// is called by comedi
+static int usbdux_pwm_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int res = 0;
+
+	// unlink only if it is really running
+	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi %d: sending pwm off command to the usb device.\n",
+		dev->minor);
+#endif
+	if ((res = send_dux_commands(this_usbduxsub, SENDPWMOFF)) < 0) {
+		return res;
+	}
+
+	return res;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+static void usbduxsub_pwm_irq(struct urb *urb)
+{
+#else
+static void usbduxsub_pwm_irq(struct urb *urb, struct pt_regs *regs)
+{
+#endif
+	int ret;
+	usbduxsub_t *this_usbduxsub;
+	comedi_device *this_comedidev;
+	comedi_subdevice *s;
+
+	// printk("PWM: IRQ\n");
+
+	if (!urb) {
+		printk("comedi_: usbdux_: pwm urb handler called with NULL ptr.\n");
+		return;
+	}
+	// the context variable points to the subdevice
+	this_comedidev = urb->context;
+	if (!this_comedidev) {
+		printk("comedi_: usbdux_: pwm urb int-context is a NULL pointer.\n");
+		return;
+	}
+	// the private structure of the subdevice is usbduxsub_t
+	this_usbduxsub = this_comedidev->private;
+	if (!this_usbduxsub) {
+		printk("comedi_: usbdux_: private data structure of pwm subdev is NULL p.\n");
+		return;
+	}
+
+	s = this_comedidev->subdevices + SUBDEV_DA;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+
+		// after an unlink command, unplug, ... etc
+		// no unlink needed here. Already shutting down.
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		if (this_usbduxsub->pwm_cmd_running) {
+			usbdux_pwm_stop(this_usbduxsub, 0);
+		}
+		return;
+
+		// a real error
+	default:
+		if (this_usbduxsub->pwm_cmd_running) {
+			printk("comedi_: usbdux_: Non-zero urb status received in pwm intr context: %d\n", urb->status);
+			usbdux_pwm_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	// are we actually running?
+	if (!(this_usbduxsub->pwm_cmd_running)) {
+		return;
+	}
+
+	urb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;
+	urb->dev = this_usbduxsub->usbdev;
+	urb->status = 0;
+	if (this_usbduxsub->pwm_cmd_running) {
+		if ((ret = USB_SUBMIT_URB(urb)) < 0) {
+			printk("comedi_: usbdux_: pwm urb resubm failed in int-cont.");
+			printk("ret=%d", ret);
+			if (ret == EL2NSYNC) {
+				printk("--> buggy USB host controller or bug in IRQ handling!\n");
+			} else {
+				printk("\n");
+			}
+			// don't do an unlink here
+			usbdux_pwm_stop(this_usbduxsub, 0);
+		}
+	}
+}
+
+int usbduxsub_submit_PwmURBs(usbduxsub_t * usbduxsub)
+{
+	int errFlag;
+
+	if (!usbduxsub) {
+		return -EFAULT;
+	}
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi_: usbdux: submitting pwm-urb\n");
+#endif
+	// in case of a resubmission after an unlink...
+
+	usb_fill_bulk_urb(usbduxsub->urbPwm,
+		usbduxsub->usbdev,
+		usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
+		usbduxsub->urbPwm->transfer_buffer,
+		usbduxsub->sizePwmBuf, usbduxsub_pwm_irq, usbduxsub->comedidev);
+
+	errFlag = USB_SUBMIT_URB(usbduxsub->urbPwm);
+	if (errFlag) {
+		printk("comedi_: usbdux: pwm: ");
+		printk("USB_SUBMIT_URB");
+		printk(" error %d\n", errFlag);
+		return errFlag;
+	}
+	return 0;
+}
+
+static int usbdux_pwm_period(comedi_device * dev, comedi_subdevice * s,
+			     lsampl_t period)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int fx2delay=255;
+	if (period < MIN_PWM_PERIOD)
+	{
+		printk("comedi%d: illegal period setting for pwm.\n", dev->minor);
+		return -EAGAIN;
+	} else {
+		fx2delay = period / ((int)(6*512*(1.0/0.033))) - 6;
+		if (fx2delay > 255) {
+			printk("comedi%d: period %d for pwm is too low.\n",
+			       dev->minor, period);
+			return -EAGAIN;
+		}
+	}
+	this_usbduxsub->pwmDelay=fx2delay;
+	this_usbduxsub->pwmPeriod=period;
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("usbdux_pwm_period: frequ=%d, period=%d\n",period,fx2delay);
+#endif
+	return 0;
+}
+
+
+// is called from insn so there's no need to do all the sanity checks
+static int usbdux_pwm_start(comedi_device * dev, comedi_subdevice * s)
+{
+	int ret, i;
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+#ifdef NOISY_DUX_DEBUGBUG
+	printk("comedi%d: usbdux_pwm_start\n", dev->minor);
+#endif
+	if (this_usbduxsub->pwm_cmd_running) {
+		// already running
+		return 0;
+	}
+
+	this_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwmDelay);
+	if ((ret = send_dux_commands(this_usbduxsub, SENDPWMON)) < 0) {
+		return ret;
+	}
+	// initalise the buffer
+	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++) {
+		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
+	}
+
+	this_usbduxsub->pwm_cmd_running = 1;
+	ret = usbduxsub_submit_PwmURBs(this_usbduxsub);
+	if (ret < 0) {
+		this_usbduxsub->pwm_cmd_running = 0;
+		return ret;
+	}
+	return 0;
+}
+
+
+// generates the bit pattern for PWM with the optional sign bit
+static int usbdux_pwm_pattern(comedi_device * dev, comedi_subdevice * s,
+			      int channel, lsampl_t value, lsampl_t sign)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	int i, szbuf;
+	char *pBuf;
+	char pwm_mask,sgn_mask,c;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+	// this is the DIO bit which carries the PWM data
+	pwm_mask = (1 << channel);
+	// this is the DIO bit which carries the optional direction bit
+	sgn_mask = (16 << channel);
+	// this is the buffer which will be filled with the with bit
+	// pattern for one period
+	szbuf = this_usbduxsub->sizePwmBuf;
+	pBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);
+	for (i = 0; i < szbuf; i++) {
+		c = *pBuf;
+		// reset bits
+		c = c & (~pwm_mask);
+		// set the bit as long as the index is lower than the value
+		if (i < value)
+			c = c | pwm_mask;
+		// set the optional sign bit for a relay
+		if (!sign) {
+			// positive value
+			c = c & (~sgn_mask);
+		} else {
+			// negative value
+			c = c | sgn_mask;
+		}
+		*(pBuf++) = c;
+	}
+	return 1;
+}
+
+static int usbdux_pwm_write(comedi_device * dev, comedi_subdevice * s,
+			    comedi_insn * insn, lsampl_t * data)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub) {
+		return -EFAULT;
+	}
+
+	if ((insn->n)!=1) {
+		// doesn't make sense to have more than one value here
+		// because it would just overwrite the PWM buffer a couple of times
+		return -EINVAL;
+	}
+
+	// the sign is set via a special INSN only, this gives us 8 bits for
+	// normal operation
+	return usbdux_pwm_pattern(dev,s,
+				  CR_CHAN(insn->chanspec),
+				  data[0],
+				  0); // relay sign 0 by default
+}
+
+
+static int usbdux_pwm_read(comedi_device * x1, comedi_subdevice * x2,
+	comedi_insn * x3, lsampl_t * x4)
+{
+	// not needed
+	return -EINVAL;
+};
+
+// switches on/off PWM
+static int usbdux_pwm_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	usbduxsub_t *this_usbduxsub = dev->private;
+	switch (data[0]) {
+	case INSN_CONFIG_ARM:
+#ifdef NOISY_DUX_DEBUGBUG
+		// switch it on
+		printk("comedi%d: pwm_insn_config: pwm on\n",
+		       dev->minor);
+#endif
+		// if not zero the PWM is limited to a certain time which is
+		// not supported here
+		if (data[1]!=0) {
+			return -EINVAL;
+		}
+		return usbdux_pwm_start(dev, s);
+	case INSN_CONFIG_DISARM:
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: pwm_insn_config: pwm off\n",
+		       dev->minor);
+#endif
+		return usbdux_pwm_cancel(dev, s);
+	case INSN_CONFIG_GET_PWM_STATUS:
+		// to check if the USB transmission has failed or in case
+		// PWM was limited to n cycles to check if it has terminated
+		data[1] = this_usbduxsub->pwm_cmd_running;
+		return 0;
+	case INSN_CONFIG_PWM_SET_PERIOD:
+#ifdef NOISY_DUX_DEBUGBUG
+		printk("comedi%d: pwm_insn_config: setting period\n",
+		       dev->minor);
+#endif
+		return usbdux_pwm_period(dev,s,data[1]);
+	case INSN_CONFIG_PWM_GET_PERIOD:
+		data[1] = this_usbduxsub->pwmPeriod;
+		return 0;
+	case INSN_CONFIG_PWM_SET_H_BRIDGE:
+		// value in the first byte and the sign in the second for a relay
+		return usbdux_pwm_pattern(dev, s,
+					  CR_CHAN(insn->chanspec), // the channel number
+					  data[1], // actual PWM data
+					  (data[2]!=0)); // just a sign
+	case INSN_CONFIG_PWM_GET_H_BRIDGE:
+		// values are not kept in this driver, nothing to return here
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+// end of PWM
+///////////////////////////////////////////////////////////////////
+
+static void tidy_up(usbduxsub_t * usbduxsub_tmp)
+{
+	int i;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux: tiding up\n");
+#endif
+	if (!usbduxsub_tmp) {
+		return;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	// shows the usb subsystem that the driver is down
+	if (usbduxsub_tmp->interface) {
+		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
+	}
+#endif
+
+	usbduxsub_tmp->probed = 0;
+
+	if (usbduxsub_tmp->urbIn) {
+		if (usbduxsub_tmp->ai_cmd_running) {
+			usbduxsub_tmp->ai_cmd_running = 0;
+			usbduxsub_unlink_InURBs(usbduxsub_tmp);
+		}
+		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
+			if (usbduxsub_tmp->urbIn[i]->transfer_buffer) {
+				kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
+				usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
+			}
+			if (usbduxsub_tmp->urbIn[i]) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+#endif
+				usb_free_urb(usbduxsub_tmp->urbIn[i]);
+				usbduxsub_tmp->urbIn[i] = NULL;
+			}
+		}
+		kfree(usbduxsub_tmp->urbIn);
+		usbduxsub_tmp->urbIn = NULL;
+	}
+	if (usbduxsub_tmp->urbOut) {
+		if (usbduxsub_tmp->ao_cmd_running) {
+			usbduxsub_tmp->ao_cmd_running = 0;
+			usbduxsub_unlink_OutURBs(usbduxsub_tmp);
+		}
+		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
+			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
+				kfree(usbduxsub_tmp->urbOut[i]->
+					transfer_buffer);
+				usbduxsub_tmp->urbOut[i]->transfer_buffer =
+					NULL;
+			}
+			if (usbduxsub_tmp->urbOut[i]) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
+#endif
+				usb_free_urb(usbduxsub_tmp->urbOut[i]);
+				usbduxsub_tmp->urbOut[i] = NULL;
+			}
+		}
+		kfree(usbduxsub_tmp->urbOut);
+		usbduxsub_tmp->urbOut = NULL;
+	}
+	if (usbduxsub_tmp->urbPwm) {
+		if (usbduxsub_tmp->pwm_cmd_running) {
+			usbduxsub_tmp->pwm_cmd_running = 0;
+			usbduxsub_unlink_PwmURBs(usbduxsub_tmp);
+		}
+		if (usbduxsub_tmp->urbPwm->transfer_buffer) {
+			kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
+			usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+		usb_kill_urb(usbduxsub_tmp->urbPwm);
+#endif
+		usb_free_urb(usbduxsub_tmp->urbPwm);
+		usbduxsub_tmp->urbPwm = NULL;
+	}
+	if (usbduxsub_tmp->inBuffer) {
+		kfree(usbduxsub_tmp->inBuffer);
+		usbduxsub_tmp->inBuffer = NULL;
+	}
+	if (usbduxsub_tmp->insnBuffer) {
+		kfree(usbduxsub_tmp->insnBuffer);
+		usbduxsub_tmp->insnBuffer = NULL;
+	}
+	if (usbduxsub_tmp->inBuffer) {
+		kfree(usbduxsub_tmp->inBuffer);
+		usbduxsub_tmp->inBuffer = NULL;
+	}
+	if (usbduxsub_tmp->dac_commands) {
+		kfree(usbduxsub_tmp->dac_commands);
+		usbduxsub_tmp->dac_commands = NULL;
+	}
+	if (usbduxsub_tmp->dux_commands) {
+		kfree(usbduxsub_tmp->dux_commands);
+		usbduxsub_tmp->dux_commands = NULL;
+	}
+	usbduxsub_tmp->ai_cmd_running = 0;
+	usbduxsub_tmp->ao_cmd_running = 0;
+	usbduxsub_tmp->pwm_cmd_running = 0;
+}
+
+static unsigned hex2unsigned(char *h)
+{
+	unsigned hi, lo;
+	if (h[0] > '9') {
+		hi = h[0] - 'A' + 0x0a;
+	} else {
+		hi = h[0] - '0';
+	}
+	if (h[1] > '9') {
+		lo = h[1] - 'A' + 0x0a;
+	} else {
+		lo = h[1] - '0';
+	}
+	return hi * 0x10 + lo;
+}
+
+// for FX2
+#define FIRMWARE_MAX_LEN 0x2000
+
+// taken from David Brownell's fxload and adjusted for this driver
+static int read_firmware(usbduxsub_t * usbduxsub, void *firmwarePtr, long size)
+{
+	int i = 0;
+	unsigned char *fp = (char *)firmwarePtr;
+	unsigned char *firmwareBinary = NULL;
+	int res = 0;
+	int maxAddr = 0;
+
+	firmwareBinary = kzalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
+	if (!firmwareBinary) {
+		printk("comedi_: usbdux: mem alloc for firmware failed\n");
+		return -ENOMEM;
+	}
+
+	for (;;) {
+		char buf[256], *cp;
+		char type;
+		int len;
+		int idx, off;
+		int j = 0;
+
+		// get one line
+		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
+			buf[j] = fp[i];
+			i++;
+			j++;
+			if (j >= sizeof(buf)) {
+				printk("comedi_: usbdux: bogus firmware file!\n");
+				return -1;
+			}
+		}
+		// get rid of LF/CR/...
+		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
+				|| (fp[i] == 0))) {
+			i++;
+		}
+
+		buf[j] = 0;
+		//printk("comedi_: buf=%s\n",buf);
+
+		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
+		if (buf[0] == '#')
+			continue;
+
+		if (buf[0] != ':') {
+			printk("comedi_: usbdux: upload: not an ihex record: %s", buf);
+			return -EFAULT;
+		}
+
+		/* Read the length field (up to 16 bytes) */
+		len = hex2unsigned(buf + 1);
+
+		/* Read the target offset */
+		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
+
+		if ((off + len) > maxAddr) {
+			maxAddr = off + len;
+		}
+
+		if (maxAddr >= FIRMWARE_MAX_LEN) {
+			printk("comedi_: usbdux: firmware upload goes beyond FX2 RAM boundaries.");
+			return -EFAULT;
+		}
+		//printk("comedi_: usbdux: off=%x, len=%x:",off,len);
+
+		/* Read the record type */
+		type = hex2unsigned(buf + 7);
+
+		/* If this is an EOF record, then make it so. */
+		if (type == 1) {
+			break;
+		}
+
+		if (type != 0) {
+			printk("comedi_: usbdux: unsupported record type: %u\n",
+				type);
+			return -EFAULT;
+		}
+
+		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
+			firmwareBinary[idx + off] = hex2unsigned(cp);
+			//printk("%02x ",firmwareBinary[idx+off]);
+		}
+		//printk("\n");
+
+		if (i >= size) {
+			printk("comedi_: usbdux: unexpected end of hex file\n");
+			break;
+		}
+
+	}
+	res = firmwareUpload(usbduxsub, firmwareBinary, maxAddr + 1);
+	kfree(firmwareBinary);
+	return res;
+}
+
+// allocate memory for the urbs and initialise them
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void *usbduxsub_probe(struct usb_device *udev,
+	unsigned int interfnum, const struct usb_device_id *id)
+{
+#else
+static int usbduxsub_probe(struct usb_interface *uinterf,
+	const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(uinterf);
+#endif
+	int i;
+	int index;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux_: finding a free structure for the usb-device\n");
+#endif
+	down(&start_stop_sem);
+	// look for a free place in the usbdux array
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if (!(usbduxsub[i].probed)) {
+			index = i;
+			break;
+		}
+	}
+
+	// no more space
+	if (index == -1) {
+		printk("Too many usbdux-devices connected.\n");
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-EMFILE);
+	}
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux: usbduxsub[%d] is ready to connect to comedi.\n", index);
+#endif
+
+	init_MUTEX(&(usbduxsub[index].sem));
+	// save a pointer to the usb device
+	usbduxsub[index].usbdev = udev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	// save the interface number
+	usbduxsub[index].ifnum = interfnum;
+#else
+	// 2.6: save the interface itself
+	usbduxsub[index].interface = uinterf;
+	// get the interface number from the interface
+	usbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
+	// hand the private data over to the usb subsystem
+	// will be needed for disconnect
+	usb_set_intfdata(uinterf, &(usbduxsub[index]));
+#endif
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
+#endif
+	// test if it is high speed (USB 2.0)
+	usbduxsub[index].high_speed =
+		(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+
+	// create space for the commands of the DA converter
+	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	if (!usbduxsub[index].dac_commands) {
+		printk("comedi_: usbdux: error alloc space for dac commands\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// create space for the commands going to the usb device
+	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!usbduxsub[index].dux_commands) {
+		printk("comedi_: usbdux: error alloc space for dac commands\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// create space for the in buffer and set it to zero
+	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].inBuffer)) {
+		printk("comedi_: usbdux: could not alloc space for inBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// create space of the instruction buffer
+	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].insnBuffer)) {
+		printk("comedi_: usbdux: could not alloc space for insnBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// create space for the outbuffer
+	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].outBuffer)) {
+		printk("comedi_: usbdux: could not alloc space for outBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	// setting to alternate setting 3: enabling iso ep and bulk ep.
+	i = usb_set_interface(usbduxsub[index].usbdev,
+		usbduxsub[index].ifnum, 3);
+	if (i < 0) {
+		printk("comedi_: usbdux%d: could not set alternate setting 3 in high speed.\n", index);
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENODEV);
+	}
+	if (usbduxsub[index].high_speed) {
+		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
+	} else {
+		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
+	}
+	usbduxsub[index].urbIn =
+		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
+		GFP_KERNEL);
+	if (!(usbduxsub[index].urbIn)) {
+		printk("comedi_: usbdux: Could not alloc. urbIn array\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
+		// one frame: 1ms
+		usbduxsub[index].urbIn[i] = USB_ALLOC_URB(1);
+		if (usbduxsub[index].urbIn[i] == NULL) {
+			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
+				index, i);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
+		// will be filled later with a pointer to the comedi-device
+		// and ONLY then the urb should be submitted
+		usbduxsub[index].urbIn[i]->context = NULL;
+		usbduxsub[index].urbIn[i]->pipe =
+			usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
+		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urbIn[i]->transfer_buffer =
+			kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
+			printk("comedi_: usbdux%d: could not alloc. transb.\n",
+				index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+		usbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;
+		usbduxsub[index].urbIn[i]->number_of_packets = 1;
+		usbduxsub[index].urbIn[i]->transfer_buffer_length = SIZEINBUF;
+		usbduxsub[index].urbIn[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urbIn[i]->iso_frame_desc[0].length = SIZEINBUF;
+	}
+
+	// out
+	if (usbduxsub[index].high_speed) {
+		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+	} else {
+		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+	}
+	usbduxsub[index].urbOut =
+		kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
+		GFP_KERNEL);
+	if (!(usbduxsub[index].urbOut)) {
+		printk("comedi_: usbdux: Could not alloc. urbOut array\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return PROBE_ERR_RETURN(-ENOMEM);
+	}
+	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
+		// one frame: 1ms
+		usbduxsub[index].urbOut[i] = USB_ALLOC_URB(1);
+		if (usbduxsub[index].urbOut[i] == NULL) {
+			printk("comedi_: usbdux%d: Could not alloc. urb(%d)\n",
+				index, i);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
+		// will be filled later with a pointer to the comedi-device
+		// and ONLY then the urb should be submitted
+		usbduxsub[index].urbOut[i]->context = NULL;
+		usbduxsub[index].urbOut[i]->pipe =
+			usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
+		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urbOut[i]->transfer_buffer =
+			kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
+			printk("comedi_: usbdux%d: could not alloc. transb.\n",
+				index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+		usbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;
+		usbduxsub[index].urbOut[i]->number_of_packets = 1;
+		usbduxsub[index].urbOut[i]->transfer_buffer_length = SIZEOUTBUF;
+		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
+			SIZEOUTBUF;
+		if (usbduxsub[index].high_speed) {
+			// uframes
+			usbduxsub[index].urbOut[i]->interval = 8;
+		} else {
+			// frames
+			usbduxsub[index].urbOut[i]->interval = 1;
+		}
+	}
+
+	// pwm
+	if (usbduxsub[index].high_speed) {
+		usbduxsub[index].sizePwmBuf = 512;	// max bulk ep size in high speed
+		usbduxsub[index].urbPwm = USB_ALLOC_URB(0);
+		if (usbduxsub[index].urbPwm == NULL) {
+			printk("comedi_: usbdux%d: Could not alloc. pwm urb\n",
+				index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+		usbduxsub[index].urbPwm->transfer_buffer =
+			kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
+		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
+			printk("comedi_: usbdux%d: could not alloc. transb. for pwm\n", index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return PROBE_ERR_RETURN(-ENOMEM);
+		}
+	} else {
+		usbduxsub[index].urbPwm = NULL;
+		usbduxsub[index].sizePwmBuf = 0;
+	}
+
+	usbduxsub[index].ai_cmd_running = 0;
+	usbduxsub[index].ao_cmd_running = 0;
+	usbduxsub[index].pwm_cmd_running = 0;
+
+	// we've reached the bottom of the function
+	usbduxsub[index].probed = 1;
+	up(&start_stop_sem);
+	printk("comedi_: usbdux%d has been successfully initialised.\n", index);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return (void *)(&usbduxsub[index]);
+#else
+	// success
+	return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void usbduxsub_disconnect(struct usb_device *udev, void *ptr)
+{
+	usbduxsub_t *usbduxsub_tmp = (usbduxsub_t *) ptr;
+#else
+static void usbduxsub_disconnect(struct usb_interface *intf)
+{
+	usbduxsub_t *usbduxsub_tmp = usb_get_intfdata(intf);
+	struct usb_device *udev = interface_to_usbdev(intf);
+#endif
+	if (!usbduxsub_tmp) {
+		printk("comedi_: usbdux: disconnect called with null pointer.\n");
+		return;
+	}
+	if (usbduxsub_tmp->usbdev != udev) {
+		printk("comedi_: usbdux: BUG! called with wrong ptr!!!\n");
+		return;
+	}
+	down(&start_stop_sem);
+	down(&usbduxsub_tmp->sem);
+	tidy_up(usbduxsub_tmp);
+	up(&usbduxsub_tmp->sem);
+	up(&start_stop_sem);
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux: disconnected from the usb\n");
+#endif
+}
+
+// is called when comedi-config is called
+static int usbdux_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int ret;
+	int index;
+	int i;
+	comedi_subdevice *s = NULL;
+	dev->private = NULL;
+
+	down(&start_stop_sem);
+	// find a valid device which has been detected by the probe function of the usb
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index < 0) {
+		printk("comedi%d: usbdux: error: attach failed, no usbdux devs connected to the usb bus.\n", dev->minor);
+		up(&start_stop_sem);
+		return -ENODEV;
+	}
+
+	down(&(usbduxsub[index].sem));
+	// pointer back to the corresponding comedi device
+	usbduxsub[index].comedidev = dev;
+
+	// trying to upload the firmware into the chip
+	if (comedi_aux_data(it->options, 0) &&
+		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+		read_firmware(usbduxsub + index,
+			comedi_aux_data(it->options, 0),
+			it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+	}
+
+	dev->board_name = BOARDNAME;
+
+	/* set number of subdevices */
+	if (usbduxsub[index].high_speed) {
+		// with pwm
+		dev->n_subdevices = 5;
+	} else {
+		// without pwm
+		dev->n_subdevices = 4;
+	}
+
+	// allocate space for the subdevices
+	if ((ret = alloc_subdevices(dev, dev->n_subdevices)) < 0) {
+		printk("comedi%d: usbdux: error alloc space for subdev\n",
+			dev->minor);
+		up(&start_stop_sem);
+		return ret;
+	}
+
+	printk("comedi%d: usbdux: usb-device %d is attached to comedi.\n",
+		dev->minor, index);
+	// private structure is also simply the usb-structure
+	dev->private = usbduxsub + index;
+
+	// the first subdevice is the A/D converter
+	s = dev->subdevices + SUBDEV_AD;
+	// the URBs get the comedi subdevice
+	// which is responsible for reading
+	// this is the subdevice which reads data
+	dev->read_subdev = s;
+	// the subdevice receives as private structure the
+	// usb-structure
+	s->private = NULL;
+	// analog input
+	s->type = COMEDI_SUBD_AI;
+	// readable and ref is to ground
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
+	// 8 channels
+	s->n_chan = 8;
+	// length of the channellist
+	s->len_chanlist = 8;
+	// callback functions
+	s->insn_read = usbdux_ai_insn_read;
+	s->do_cmdtest = usbdux_ai_cmdtest;
+	s->do_cmd = usbdux_ai_cmd;
+	s->cancel = usbdux_ai_cancel;
+	// max value from the A/D converter (12bit)
+	s->maxdata = 0xfff;
+	// range table to convert to physical units
+	s->range_table = (&range_usbdux_ai_range);
+	//
+
+	// analog out
+	s = dev->subdevices + SUBDEV_DA;
+	// analog out
+	s->type = COMEDI_SUBD_AO;
+	// backward pointer
+	dev->write_subdev = s;
+	// the subdevice receives as private structure the
+	// usb-structure
+	s->private = NULL;
+	// are writable
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	// 4 channels
+	s->n_chan = 4;
+	// length of the channellist
+	s->len_chanlist = 4;
+	// 12 bit resolution
+	s->maxdata = 0x0fff;
+	// bipolar range
+	s->range_table = (&range_usbdux_ao_range);
+	// callback
+	s->do_cmdtest = usbdux_ao_cmdtest;
+	s->do_cmd = usbdux_ao_cmd;
+	s->cancel = usbdux_ao_cancel;
+	s->insn_read = usbdux_ao_insn_read;
+	s->insn_write = usbdux_ao_insn_write;
+
+	// digital I/O
+	s = dev->subdevices + SUBDEV_DIO;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 8;
+	s->maxdata = 1;
+	s->range_table = (&range_digital);
+	s->insn_bits = usbdux_dio_insn_bits;
+	s->insn_config = usbdux_dio_insn_config;
+	// we don't use it
+	s->private = NULL;
+
+	//counter
+	s = dev->subdevices + SUBDEV_COUNTER;
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 0xFFFF;
+	s->insn_read = usbdux_counter_read;
+	s->insn_write = usbdux_counter_write;
+	s->insn_config = usbdux_counter_config;
+
+	if (usbduxsub[index].high_speed) {
+		//timer / pwm
+		s = dev->subdevices + SUBDEV_PWM;
+		s->type = COMEDI_SUBD_PWM;
+		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan = 8;
+		// this defines the max duty cycle resolution
+		s->maxdata = usbduxsub[index].sizePwmBuf;
+		s->insn_write = usbdux_pwm_write;
+		s->insn_read = usbdux_pwm_read;
+		s->insn_config = usbdux_pwm_config;
+		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+	// finally decide that it's attached
+	usbduxsub[index].attached = 1;
+
+	up(&(usbduxsub[index].sem));
+
+	up(&start_stop_sem);
+
+	printk("comedi%d: attached to usbdux.\n", dev->minor);
+
+	return 0;
+}
+
+static int usbdux_detach(comedi_device * dev)
+{
+	usbduxsub_t *usbduxsub_tmp;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbdux: detach usb device\n", dev->minor);
+#endif
+
+	if (!dev) {
+		printk("comedi?: usbdux: detach without dev variable...\n");
+		return -EFAULT;
+	}
+
+	usbduxsub_tmp = dev->private;
+	if (!usbduxsub_tmp) {
+		printk("comedi?: usbdux: detach without ptr to usbduxsub[]\n");
+		return -EFAULT;
+	}
+
+	down(&usbduxsub_tmp->sem);
+	// Don't allow detach to free the private structure
+	// It's one entry of of usbduxsub[]
+	dev->private = NULL;
+	usbduxsub_tmp->attached = 0;
+	usbduxsub_tmp->comedidev = NULL;
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi%d: usbdux: detach: successfully removed\n", dev->minor);
+#endif
+	up(&usbduxsub_tmp->sem);
+	return 0;
+}
+
+/* main driver struct */
+static comedi_driver driver_usbdux = {
+      driver_name:"usbdux",
+      module:THIS_MODULE,
+      attach:usbdux_attach,
+      detach:usbdux_detach,
+};
+
+static void init_usb_devices(void)
+{
+	int index;
+#ifdef CONFIG_COMEDI_DEBUG
+	printk("comedi_: usbdux: setting all possible devs to invalid\n");
+#endif
+	// all devices entries are invalid to begin with
+	// they will become valid by the probe function
+	// and then finally by the attach-function
+	for (index = 0; index < NUMUSBDUX; index++) {
+		memset(&(usbduxsub[index]), 0x00, sizeof(usbduxsub[index]));
+		init_MUTEX(&(usbduxsub[index].sem));
+	}
+}
+
+// Table with the USB-devices: just now only testing IDs
+static struct usb_device_id usbduxsub_table[] = {
+	{USB_DEVICE(0x13d8, 0x0001),
+		},
+	{USB_DEVICE(0x13d8, 0x0002)
+		},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, usbduxsub_table);
+
+// The usbduxsub-driver
+static struct usb_driver usbduxsub_driver = {
+#ifdef COMEDI_HAVE_USB_DRIVER_OWNER
+      owner:THIS_MODULE,
+#endif
+      name:BOARDNAME,
+      probe:usbduxsub_probe,
+      disconnect:usbduxsub_disconnect,
+      id_table:usbduxsub_table,
+};
+
+// Can't use the nice macro as I have also to initialise the USB
+// subsystem:
+// registering the usb-system _and_ the comedi-driver
+static int init_usbdux(void)
+{
+	printk(KERN_INFO KBUILD_MODNAME ": "
+	       DRIVER_VERSION ":" DRIVER_DESC "\n");
+	init_usb_devices();
+	usb_register(&usbduxsub_driver);
+	comedi_driver_register(&driver_usbdux);
+	return 0;
+}
+
+// deregistering the comedi driver and the usb-subsystem
+static void exit_usbdux(void)
+{
+	comedi_driver_unregister(&driver_usbdux);
+	usb_deregister(&usbduxsub_driver);
+}
+
+module_init(init_usbdux);
+module_exit(exit_usbdux);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
