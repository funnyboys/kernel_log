commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 28ff0c2aa3b8..acd4e5456ceb 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Helper types to take care of the fact that the DSP card memory
  * is 16 bits, but aligned on a 32 bit PCI boundary

commit 9d6a94291e002d3fa499ccef73fcd286cddeeb6f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 8 18:44:28 2017 +0000

    staging: comedi: jr3_pci: use struct jr3_block instead of jr3_t
    
    `struct jr3_t` contains a single array member `block` of member type
    `struct jr3_block`.  Rather than using pointers to `struct jr3_t`, just
    use pointers to `struct jr3_block` instead and treat it as an array.
    Replace the local variables `struct jr3_t __iomem *iobase` with `struct
    jr3_block __iomem *block`.  Remove the definition of `struct jr3_t` as
    it is no longer needed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index fca46eaf6f7f..28ff0c2aa3b8 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -732,7 +732,3 @@ struct jr3_block {
 	u32 reset;			/*  0x60000 - 0x60004 */
 	char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
 };
-
-struct jr3_t {
-	struct jr3_block block[4];
-};

commit 4e861f0fd828d2c058271ace21963fa2ef7e861d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 8 18:44:27 2017 +0000

    staging: comedi: jr3_pci: separate out block type
    
    `struct jr3_t` contains a single array member `block` of a tag-less
    `struct` type.  Rename the tag-less `struct` type to `struct jr3_block`
    and move its definition outside of `struct jr3_t`.  This will allow us
    to use pointers of this type.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index ab40828df6ea..fca46eaf6f7f 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -724,13 +724,15 @@ struct jr3_sensor {
 	struct intern_transform transforms[0x10];	/* offset 0x0200 */
 };
 
+struct jr3_block {
+	u32 program_lo[0x4000];		/*  0x00000 - 0x10000 */
+	struct jr3_sensor sensor;	/*  0x10000 - 0x10c00 */
+	char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
+	u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
+	u32 reset;			/*  0x60000 - 0x60004 */
+	char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
+};
+
 struct jr3_t {
-	struct {
-		u32 program_lo[0x4000];		/*  0x00000 - 0x10000 */
-		struct jr3_sensor sensor;	/*  0x10000 - 0x10c00 */
-		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
-		u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
-		u32 reset;			/*  0x60000 - 0x60004 */
-		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
-	} block[4];
+	struct jr3_block block[4];
 };

commit 6c7f58084fce3f07d4954555173171348ddff8f5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 8 18:44:26 2017 +0000

    staging: comedi: jr3_pci: rename 'channel' to 'block'
    
    The term "channel" is overloaded in this driver.  Rename the `channel`
    member of `struct jr3_t` to `block` to reduce confusion.  `block` is an
    array of an anonymous `struct` type, with each element covering the
    registers for one subdevice.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index b4d333d57185..ab40828df6ea 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -732,5 +732,5 @@ struct jr3_t {
 		u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
 		u32 reset;			/*  0x60000 - 0x60004 */
 		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
-	} channel[4];
+	} block[4];
 };

commit ef3ab9f85c9c3ed3eb2ef8c07ce969a5ce861ec6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 8 18:44:25 2017 +0000

    staging: comedi: jr3_pci: rename data to sensor
    
    Rename the `channel[x].data` member of `struct jr3_t` to
    `channel[x].sensor` to match its type `struct jr3_sensor`.  Also rename
    local variable `ch0data` in `jr3_pci_show_copyright()` to `sensor0` for
    consistency.  It points to the `struct jr3_sensor` embedded in the
    registers for "channel" 0.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index bde2047039e7..b4d333d57185 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -727,7 +727,7 @@ struct jr3_sensor {
 struct jr3_t {
 	struct {
 		u32 program_lo[0x4000];		/*  0x00000 - 0x10000 */
-		struct jr3_sensor data;		/*  0x10000 - 0x10c00 */
+		struct jr3_sensor sensor;	/*  0x10000 - 0x10c00 */
 		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
 		u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
 		u32 reset;			/*  0x60000 - 0x60004 */

commit c5ad0c7b51ae904c2d8ff7725d549e1b5cb5dcc0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Mar 8 18:44:23 2017 +0000

    staging: comedi: jr3_pci: rename struct jr3_channel to jr3_sensor
    
    The driver overloads the term "channel" a lot.  To help reduce
    confusion, rename `struct jr3_channel` to `struct jr3_sensor`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index f10a84fb6c14..bde2047039e7 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -280,7 +280,7 @@ struct intern_transform {
  * and hardware manuals.
  */
 
-struct jr3_channel {
+struct jr3_sensor {
 	/*
 	 * Raw_channels is the area used to store the raw data coming from
 	 * the sensor.
@@ -727,7 +727,7 @@ struct jr3_channel {
 struct jr3_t {
 	struct {
 		u32 program_lo[0x4000];		/*  0x00000 - 0x10000 */
-		struct jr3_channel data;	/*  0x10000 - 0x10c00 */
+		struct jr3_sensor data;		/*  0x10000 - 0x10c00 */
 		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
 		u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
 		u32 reset;			/*  0x60000 - 0x60004 */

commit f8d791f2abfee69d47a2d4596e909e83acdec2b4
Author: Anson Jacob <ansonjacob.aj@gmail.com>
Date:   Fri Aug 26 19:13:36 2016 -0400

    staging: comedi: jr3_pci.h: Fix checkpatch warning
    
    Fix checkpatch.pl warning:
    Block comments use * on subsequent lines
    Block comments use a trailing */ on a separate line
    
    Block comments starts with /* followed by comments on the next line
    
    Signed-off-by: Anson Jacob <ansonjacob.aj@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 356811defaf4..f10a84fb6c14 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -1,4 +1,5 @@
-/* Helper types to take care of the fact that the DSP card memory
+/*
+ * Helper types to take care of the fact that the DSP card memory
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
@@ -22,7 +23,8 @@ static inline void set_s16(s32 __iomem *p, s16 val)
 	writel(val, p);
 }
 
-/* The raw data is stored in a format which facilitates rapid
+/*
+ * The raw data is stored in a format which facilitates rapid
  * processing by the JR3 DSP chip. The raw_channel structure shows the
  * format for a single channel of data. Each channel takes four,
  * two-byte words.
@@ -47,7 +49,8 @@ struct raw_channel {
 	s32 reserved[2];
 };
 
-/* The force_array structure shows the layout for the decoupled and
+/*
+ * The force_array structure shows the layout for the decoupled and
  * filtered force data.
  */
 struct force_array {
@@ -61,7 +64,8 @@ struct force_array {
 	s32 v2;
 };
 
-/* The six_axis_array structure shows the layout for the offsets and
+/*
+ * The six_axis_array structure shows the layout for the offsets and
  * the full scales.
  */
 struct six_axis_array {
@@ -74,7 +78,8 @@ struct six_axis_array {
 };
 
 /* VECT_BITS */
-/* The vect_bits structure shows the layout for indicating
+/*
+ * The vect_bits structure shows the layout for indicating
  * which axes to use in computing the vectors. Each bit signifies
  * selection of a single axis. The V1x axis bit corresponds to a hex
  * value of 0x0001 and the V2z bit corresponds to a hex value of
@@ -100,12 +105,14 @@ enum {
 };
 
 /* WARNING_BITS */
-/* The warning_bits structure shows the bit pattern for the warning
+/*
+ * The warning_bits structure shows the bit pattern for the warning
  * word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).
  */
 
-/*  XX_NEAR_SET */
-/* The xx_near_sat bits signify that the indicated axis has reached or
+/* XX_NEAR_SET */
+/*
+ * The xx_near_sat bits signify that the indicated axis has reached or
  * exceeded the near saturation value.
  */
 
@@ -118,12 +125,13 @@ enum {
 	mz_near_sat = 0x0020
 };
 
-/*  ERROR_BITS */
-/*  XX_SAT */
-/*  MEMORY_ERROR */
-/*  SENSOR_CHANGE */
+/* ERROR_BITS */
+/* XX_SAT */
+/* MEMORY_ERROR */
+/* SENSOR_CHANGE */
 
-/* The error_bits structure shows the bit pattern for the error word.
+/*
+ * The error_bits structure shows the bit pattern for the error word.
  * The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The
  * xx_sat bits signify that the indicated axis has reached or exceeded
  * the saturation value. The memory_error bit indicates that a problem
@@ -134,9 +142,10 @@ enum {
  *
  */
 
-/*  SYSTEM_BUSY */
+/* SYSTEM_BUSY */
 
-/* The system_busy bit indicates that the JR3 DSP is currently busy
+/*
+ * The system_busy bit indicates that the JR3 DSP is currently busy
  * and is not calculating force data. This occurs when a new
  * coordinate transformation, or new sensor full scale is set by the
  * user. A very fast system using the force data for feedback might
@@ -146,9 +155,10 @@ enum {
  * calibration CRC.
  */
 
-/*  CAL_CRC_BAD */
+/* CAL_CRC_BAD */
 
-/* The cal_crc_bad bit indicates that the calibration CRC has not
+/*
+ * The cal_crc_bad bit indicates that the calibration CRC has not
  * calculated to zero. CRC is short for cyclic redundancy code. It is
  * a method for determining the integrity of messages in data
  * communication. The calibration data stored inside the sensor is
@@ -168,7 +178,8 @@ enum {
 /* WATCH_DOG */
 /* WATCH_DOG2 */
 
-/* The watch_dog and watch_dog2 bits are sensor, not processor, watch
+/*
+ * The watch_dog and watch_dog2 bits are sensor, not processor, watch
  * dog bits. Watch_dog indicates that the sensor data line seems to be
  * acting correctly, while watch_dog2 indicates that sensor data and
  * clock are being received. It is possible for watch_dog2 to go off
@@ -192,9 +203,10 @@ enum error_bits_t {
 	watch_dog = 0x8000
 };
 
-/*  THRESH_STRUCT */
+/* THRESH_STRUCT */
 
-/* This structure shows the layout for a single threshold packet inside of a
+/*
+ * This structure shows the layout for a single threshold packet inside of a
  * load envelope. Each load envelope can contain several threshold structures.
  * 1. data_address contains the address of the data for that threshold. This
  *    includes filtered, unfiltered, raw, rate, counters, error and warning data
@@ -210,9 +222,10 @@ struct thresh_struct {
 	s32 bit_pattern;
 };
 
-/*  LE_STRUCT */
+/* LE_STRUCT */
 
-/* Layout of a load enveloped packet. Four thresholds are showed ... for more
+/*
+ * Layout of a load enveloped packet. Four thresholds are showed ... for more
  * see manual (pag.25)
  * 1. latch_bits is a bit pattern that show which bits the user wants to latch.
  *    The latched bits will not be reset once the threshold which set them is
@@ -228,8 +241,9 @@ struct le_struct {
 	s32 reserved;
 };
 
-/*  LINK_TYPES */
-/* Link types is an enumerated value showing the different possible transform
+/* LINK_TYPES */
+/*
+ * Link types is an enumerated value showing the different possible transform
  * link types.
  * 0 - end transform packet
  * 1 - translate along X axis (TX)
@@ -252,8 +266,8 @@ enum link_types {
 	neg
 };
 
-/*  TRANSFORM */
-/*  Structure used to describe a transform. */
+/* TRANSFORM */
+/* Structure used to describe a transform. */
 struct intern_transform {
 	struct {
 		u32 link_type;
@@ -261,23 +275,29 @@ struct intern_transform {
 	} link[8];
 };
 
-/*  JR3 force/torque sensor data definition. For more information see sensor
- *  and hardware manuals.
+/*
+ * JR3 force/torque sensor data definition. For more information see sensor
+ * and hardware manuals.
  */
 
 struct jr3_channel {
-	/*  Raw_channels is the area used to store the raw data coming from */
-	/*  the sensor. */
+	/*
+	 * Raw_channels is the area used to store the raw data coming from
+	 * the sensor.
+	 */
 
 	struct raw_channel raw_channels[16];	/* offset 0x0000 */
 
-	/*  Copyright is a null terminated ASCII string containing the JR3 */
-	/*  copyright notice. */
+	/*
+	 * Copyright is a null terminated ASCII string containing the JR3
+	 * copyright notice.
+	 */
 
 	u32 copyright[0x0018];	/* offset 0x0040 */
 	s32 reserved1[0x0008];	/* offset 0x0058 */
 
-	/* Shunts contains the sensor shunt readings. Some JR3 sensors have
+	/*
+	 * Shunts contains the sensor shunt readings. Some JR3 sensors have
 	 * the ability to have their gains adjusted. This allows the
 	 * hardware full scales to be adjusted to potentially allow
 	 * better resolution or dynamic range. For sensors that have
@@ -298,25 +318,29 @@ struct jr3_channel {
 	 * command (10) set new full scales (pg. 38).
 	 */
 
-	struct six_axis_array shunts;	/* offset 0x0060 */
-	s32 reserved2[2];	/* offset 0x0066 */
+	struct six_axis_array shunts;		/* offset 0x0060 */
+	s32 reserved2[2];			/* offset 0x0066 */
 
-	/* Default_FS contains the full scale that is used if the user does */
-	/* not set a full scale. */
+	/*
+	 * Default_FS contains the full scale that is used if the user does
+	 * not set a full scale.
+	 */
 
 	struct six_axis_array default_FS;	/* offset 0x0068 */
-	s32 reserved3;		/* offset 0x006e */
+	s32 reserved3;				/* offset 0x006e */
 
-	/* Load_envelope_num is the load envelope number that is currently
+	/*
+	 * Load_envelope_num is the load envelope number that is currently
 	 * in use. This value is set by the user after one of the load
 	 * envelopes has been initialized.
 	 */
 
-	s32 load_envelope_num;	/* offset 0x006f */
+	s32 load_envelope_num;			/* offset 0x006f */
 
 	/* Min_full_scale is the recommend minimum full scale. */
 
-	/* These values in conjunction with max_full_scale (pg. 9) helps
+	/*
+	 * These values in conjunction with max_full_scale (pg. 9) helps
 	 * determine the appropriate value for setting the full scales. The
 	 * software allows the user to set the sensor full scale to an
 	 * arbitrary value. But setting the full scales has some hazards. If
@@ -342,30 +366,35 @@ struct jr3_channel {
 	 */
 
 	struct six_axis_array min_full_scale;	/* offset 0x0070 */
-	s32 reserved4;		/* offset 0x0076 */
+	s32 reserved4;				/* offset 0x0076 */
 
-	/* Transform_num is the transform number that is currently in use.
+	/*
+	 * Transform_num is the transform number that is currently in use.
 	 * This value is set by the JR3 DSP after the user has used command
 	 * (5) use transform # (pg. 33).
 	 */
 
-	s32 transform_num;	/* offset 0x0077 */
+	s32 transform_num;			/* offset 0x0077 */
 
-	/*  Max_full_scale is the recommended maximum full scale. See */
-	/*  min_full_scale (pg. 9) for more details. */
+	/*
+	 * Max_full_scale is the recommended maximum full scale.
+	 * See min_full_scale (pg. 9) for more details.
+	 */
 
 	struct six_axis_array max_full_scale;	/* offset 0x0078 */
-	s32 reserved5;		/* offset 0x007e */
+	s32 reserved5;				/* offset 0x007e */
 
-	/* Peak_address is the address of the data which will be monitored
+	/*
+	 * Peak_address is the address of the data which will be monitored
 	 * by the peak routine. This value is set by the user. The peak
 	 * routine will monitor any 8 contiguous addresses for peak values.
 	 * (ex. to watch filter3 data for peaks, set this value to 0x00a8).
 	 */
 
-	s32 peak_address;	/* offset 0x007f */
+	s32 peak_address;			/* offset 0x007f */
 
-	/* Full_scale is the sensor full scales which are currently in use.
+	/*
+	 * Full_scale is the sensor full scales which are currently in use.
 	 * Decoupled and filtered data is scaled so that +/- 16384 is equal
 	 * to the full scales. The engineering units used are indicated by
 	 * the units value discussed on page 16. The full scales for Fx, Fy,
@@ -377,9 +406,10 @@ struct jr3_channel {
 	 * axes used for each vector respectively.
 	 */
 
-	struct force_array full_scale;	/* offset 0x0080 */
+	struct force_array full_scale;		/* offset 0x0080 */
 
-	/* Offsets contains the sensor offsets. These values are subtracted from
+	/*
+	 * Offsets contains the sensor offsets. These values are subtracted from
 	 * the sensor data to obtain the decoupled data. The offsets are set a
 	 * few seconds (< 10) after the calibration data has been received.
 	 * They are set so that the output data will be zero. These values
@@ -392,23 +422,26 @@ struct jr3_channel {
 	 * about Z by 90 degrees, FY would be 5 and all others would be zero.
 	 */
 
-	struct six_axis_array offsets;	/* offset 0x0088 */
+	struct six_axis_array offsets;		/* offset 0x0088 */
 
-	/* Offset_num is the number of the offset currently in use. This
+	/*
+	 * Offset_num is the number of the offset currently in use. This
 	 * value is set by the JR3 DSP after the user has executed the use
 	 * offset # command (pg. 34). It can vary between 0 and 15.
 	 */
 
-	s32 offset_num;		/* offset 0x008e */
+	s32 offset_num;				/* offset 0x008e */
 
-	/* Vect_axes is a bit map showing which of the axes are being used
+	/*
+	 * Vect_axes is a bit map showing which of the axes are being used
 	 * in the vector calculations. This value is set by the JR3 DSP
 	 * after the user has executed the set vector axes command (pg. 37).
 	 */
 
-	u32 vect_axes;		/* offset 0x008f */
+	u32 vect_axes;				/* offset 0x008f */
 
-	/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.
+	/*
+	 * Filter0 is the decoupled, unfiltered data from the JR3 sensor.
 	 * This data has had the offsets removed.
 	 *
 	 * These force_arrays hold the filtered data. The decoupled data is
@@ -420,23 +453,27 @@ struct jr3_channel {
 	 * cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.
 	 */
 
-	struct force_array filter[7];	/* offset 0x0090,
-					   offset 0x0098,
-					   offset 0x00a0,
-					   offset 0x00a8,
-					   offset 0x00b0,
-					   offset 0x00b8 ,
-					   offset 0x00c0 */
-
-	/* Rate_data is the calculated rate data. It is a first derivative
+	struct force_array filter[7];		/*
+						 * offset 0x0090,
+						 * offset 0x0098,
+						 * offset 0x00a0,
+						 * offset 0x00a8,
+						 * offset 0x00b0,
+						 * offset 0x00b8,
+						 * offset 0x00c0
+						 */
+
+	/*
+	 * Rate_data is the calculated rate data. It is a first derivative
 	 * calculation. It is calculated at a frequency specified by the
 	 * variable rate_divisor (pg. 12). The data on which the rate is
 	 * calculated is specified by the variable rate_address (pg. 12).
 	 */
 
-	struct force_array rate_data;	/* offset 0x00c8 */
+	struct force_array rate_data;		/* offset 0x00c8 */
 
-	/* Minimum_data & maximum_data are the minimum and maximum (peak)
+	/*
+	 * Minimum_data & maximum_data are the minimum and maximum (peak)
 	 * data values. The JR3 DSP can monitor any 8 contiguous data items
 	 * for minimums and maximums at full sensor bandwidth. This area is
 	 * only updated at user request. This is done so that the user does
@@ -451,7 +488,8 @@ struct jr3_channel {
 	struct force_array minimum_data;	/* offset 0x00d0 */
 	struct force_array maximum_data;	/* offset 0x00d8 */
 
-	/* Near_sat_value & sat_value contain the value used to determine if
+	/*
+	 * Near_sat_value & sat_value contain the value used to determine if
 	 * the raw sensor is saturated. Because of decoupling and offset
 	 * removal, it is difficult to tell from the processed data if the
 	 * sensor is saturated. These values, in conjunction with the error
@@ -465,10 +503,11 @@ struct jr3_channel {
 	 *   sat_value = 32768 - 2^(16 - ADC bits)
 	 */
 
-	s32 near_sat_value;	/* offset 0x00e0 */
-	s32 sat_value;		/* offset 0x00e1 */
+	s32 near_sat_value;			/* offset 0x00e0 */
+	s32 sat_value;				/* offset 0x00e1 */
 
-	/* Rate_address, rate_divisor & rate_count contain the data used to
+	/*
+	 * Rate_address, rate_divisor & rate_count contain the data used to
 	 * control the calculations of the rates. Rate_address is the
 	 * address of the data used for the rate calculation. The JR3 DSP
 	 * will calculate rates for any 8 contiguous values (ex. to
@@ -485,11 +524,12 @@ struct jr3_channel {
 	 * will minimize the time necessary to start the rate calculations.
 	 */
 
-	s32 rate_address;	/* offset 0x00e2 */
-	u32 rate_divisor;	/* offset 0x00e3 */
-	u32 rate_count;		/* offset 0x00e4 */
+	s32 rate_address;			/* offset 0x00e2 */
+	u32 rate_divisor;			/* offset 0x00e3 */
+	u32 rate_count;				/* offset 0x00e4 */
 
-	/* Command_word2 through command_word0 are the locations used to
+	/*
+	 * Command_word2 through command_word0 are the locations used to
 	 * send commands to the JR3 DSP. Their usage varies with the command
 	 * and is detailed later in the Command Definitions section (pg.
 	 * 29). In general the user places values into various memory
@@ -502,11 +542,12 @@ struct jr3_channel {
 	 * command_word1).
 	 */
 
-	s32 command_word2;	/* offset 0x00e5 */
-	s32 command_word1;	/* offset 0x00e6 */
-	s32 command_word0;	/* offset 0x00e7 */
+	s32 command_word2;			/* offset 0x00e5 */
+	s32 command_word1;			/* offset 0x00e6 */
+	s32 command_word0;			/* offset 0x00e7 */
 
-	/* Count1 through count6 are unsigned counters which are incremented
+	/*
+	 * Count1 through count6 are unsigned counters which are incremented
 	 * every time the matching filters are calculated. Filter1 is
 	 * calculated at the sensor data bandwidth. So this counter would
 	 * increment at 8 kHz for a typical sensor. The rest of the counters
@@ -518,14 +559,15 @@ struct jr3_channel {
 	 * once.
 	 */
 
-	u32 count1;		/* offset 0x00e8 */
-	u32 count2;		/* offset 0x00e9 */
-	u32 count3;		/* offset 0x00ea */
-	u32 count4;		/* offset 0x00eb */
-	u32 count5;		/* offset 0x00ec */
-	u32 count6;		/* offset 0x00ed */
+	u32 count1;				/* offset 0x00e8 */
+	u32 count2;				/* offset 0x00e9 */
+	u32 count3;				/* offset 0x00ea */
+	u32 count4;				/* offset 0x00eb */
+	u32 count5;				/* offset 0x00ec */
+	u32 count6;				/* offset 0x00ed */
 
-	/* Error_count is a running count of data reception errors. If this
+	/*
+	 * Error_count is a running count of data reception errors. If this
 	 * counter is changing rapidly, it probably indicates a bad sensor
 	 * cable connection or other hardware problem. In most installations
 	 * error_count should not change at all. But it is possible in an
@@ -535,75 +577,84 @@ struct jr3_channel {
 	 * where this counter counts a bad sample, that sample is ignored.
 	 */
 
-	u32 error_count;	/* offset 0x00ee */
+	u32 error_count;			/* offset 0x00ee */
 
-	/* Count_x is a counter which is incremented every time the JR3 DSP
+	/*
+	 * Count_x is a counter which is incremented every time the JR3 DSP
 	 * searches its job queues and finds nothing to do. It indicates the
 	 * amount of idle time the JR3 DSP has available. It can also be
 	 * used to determine if the JR3 DSP is alive. See the Performance
 	 * Issues section on pg. 49 for more details.
 	 */
 
-	u32 count_x;		/* offset 0x00ef */
+	u32 count_x;				/* offset 0x00ef */
 
-	/* Warnings & errors contain the warning and error bits
+	/*
+	 * Warnings & errors contain the warning and error bits
 	 * respectively. The format of these two words is discussed on page
 	 * 21 under the headings warnings_bits and error_bits.
 	 */
 
-	u32 warnings;		/* offset 0x00f0 */
-	u32 errors;		/* offset 0x00f1 */
+	u32 warnings;				/* offset 0x00f0 */
+	u32 errors;				/* offset 0x00f1 */
 
-	/* Threshold_bits is a word containing the bits that are set by the
+	/*
+	 * Threshold_bits is a word containing the bits that are set by the
 	 * load envelopes. See load_envelopes (pg. 17) and thresh_struct
 	 * (pg. 23) for more details.
 	 */
 
-	s32 threshold_bits;	/* offset 0x00f2 */
+	s32 threshold_bits;			/* offset 0x00f2 */
 
-	/* Last_crc is the value that shows the actual calculated CRC. CRC
+	/*
+	 * Last_crc is the value that shows the actual calculated CRC. CRC
 	 * is short for cyclic redundancy code. It should be zero. See the
 	 * description for cal_crc_bad (pg. 21) for more information.
 	 */
 
-	s32 last_CRC;		/* offset 0x00f3 */
+	s32 last_CRC;				/* offset 0x00f3 */
 
-	/* EEProm_ver_no contains the version number of the sensor EEProm.
+	/*
+	 * EEProm_ver_no contains the version number of the sensor EEProm.
 	 * EEProm version numbers can vary between 0 and 255.
 	 * Software_ver_no contains the software version number. Version
 	 * 3.02 would be stored as 302.
 	 */
 
-	s32 eeprom_ver_no;	/* offset 0x00f4 */
-	s32 software_ver_no;	/* offset 0x00f5 */
+	s32 eeprom_ver_no;			/* offset 0x00f4 */
+	s32 software_ver_no;			/* offset 0x00f5 */
 
-	/* Software_day & software_year are the release date of the software
+	/*
+	 * Software_day & software_year are the release date of the software
 	 * the JR3 DSP is currently running. Day is the day of the year,
 	 * with January 1 being 1, and December 31, being 365 for non leap
 	 * years.
 	 */
 
-	s32 software_day;	/* offset 0x00f6 */
-	s32 software_year;	/* offset 0x00f7 */
+	s32 software_day;			/* offset 0x00f6 */
+	s32 software_year;			/* offset 0x00f7 */
 
-	/* Serial_no & model_no are the two values which uniquely identify a
+	/*
+	 * Serial_no & model_no are the two values which uniquely identify a
 	 * sensor. This model number does not directly correspond to the JR3
 	 * model number, but it will provide a unique identifier for
 	 * different sensor configurations.
 	 */
 
-	u32 serial_no;		/* offset 0x00f8 */
-	u32 model_no;		/* offset 0x00f9 */
+	u32 serial_no;				/* offset 0x00f8 */
+	u32 model_no;				/* offset 0x00f9 */
 
-	/* Cal_day & cal_year are the sensor calibration date. Day is the
+	/*
+	 * Cal_day & cal_year are the sensor calibration date. Day is the
 	 * day of the year, with January 1 being 1, and December 31, being
 	 * 366 for leap years.
 	 */
 
-	s32 cal_day;		/* offset 0x00fa */
-	s32 cal_year;		/* offset 0x00fb */
+	s32 cal_day;				/* offset 0x00fa */
+	s32 cal_year;				/* offset 0x00fb */
 
-	/* Units is an enumerated read only value defining the engineering
+	/*
+	 * Units is an enumerated read only value defining the engineering
 	 * units used in the sensor full scale. The meanings of particular
 	 * values are discussed in the section detailing the force_units
 	 * structure on page 22. The engineering units are setto customer
@@ -626,20 +677,22 @@ struct jr3_channel {
 	 * received.
 	 */
 
-	u32 units;		/* offset 0x00fc */
-	s32 bits;		/* offset 0x00fd */
-	s32 channels;		/* offset 0x00fe */
+	u32 units;				/* offset 0x00fc */
+	s32 bits;				/* offset 0x00fd */
+	s32 channels;				/* offset 0x00fe */
 
-	/* Thickness specifies the overall thickness of the sensor from
+	/*
+	 * Thickness specifies the overall thickness of the sensor from
 	 * flange to flange. The engineering units for this value are
 	 * contained in units (pg. 16). The sensor calibration is relative
 	 * to the center of the sensor. This value allows easy coordinate
 	 * transformation from the center of the sensor to either flange.
 	 */
 
-	s32 thickness;		/* offset 0x00ff */
+	s32 thickness;				/* offset 0x00ff */
 
-	/* Load_envelopes is a table containing the load envelope
+	/*
+	 * Load_envelopes is a table containing the load envelope
 	 * descriptions. There are 16 possible load envelope slots in the
 	 * table. The slots are on 16 word boundaries and are numbered 0-15.
 	 * Each load envelope needs to start at the beginning of a slot but
@@ -655,7 +708,8 @@ struct jr3_channel {
 
 	struct le_struct load_envelopes[0x10];	/* offset 0x0100 */
 
-	/* Transforms is a table containing the transform descriptions.
+	/*
+	 * Transforms is a table containing the transform descriptions.
 	 * There are 16 possible transform slots in the table. The slots are
 	 * on 16 word boundaries and are numbered 0-15. Each transform needs
 	 * to start at the beginning of a slot but need not be fully

commit 9ef6a8331219b0242ac423cf9629d4f6377d4993
Author: jitendra kumar khasdev <jkhasdev@gmail.com>
Date:   Sat Jan 24 00:41:19 2015 +0530

    Staging: comedi: fix line over 80 characters warning
    
    This is patch to file jr3_pci.h that fix up warning line
    over 80 character which is found by checkpatch tool.
    
    Signed-off-by: Jitendra Kumar Khasdev <jkhasdev@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 20478ae8fad6..356811defaf4 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -261,8 +261,9 @@ struct intern_transform {
 	} link[8];
 };
 
-/*  JR3 force/torque sensor data definition. For more information see sensor and */
-/*  hardware manuals. */
+/*  JR3 force/torque sensor data definition. For more information see sensor
+ *  and hardware manuals.
+ */
 
 struct jr3_channel {
 	/*  Raw_channels is the area used to store the raw data coming from */

commit 127301cb5dc094ea449173a5f24c8326b2369ead
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 13:41:01 2014 -0700

    staging: comedi: jr3_pci: tidy up jr3_download_firmware()
    
    This callback function for comedi_load_firmware() first validates that
    the firmware data is the correct format then it writes the data to each
    subdevice.
    
    Split the two operations out as separate functions to clarify the code.
    Tidy up the new functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 3317f7a04c48..20478ae8fad6 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -671,11 +671,11 @@ struct jr3_channel {
 
 struct jr3_t {
 	struct {
-		u32 program_low[0x4000];	/*  0x00000 - 0x10000 */
+		u32 program_lo[0x4000];		/*  0x00000 - 0x10000 */
 		struct jr3_channel data;	/*  0x10000 - 0x10c00 */
 		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
-		u32 program_high[0x8000];	/*  0x40000 - 0x60000 */
-		u32 reset;	/*  0x60000 - 0x60004 */
+		u32 program_hi[0x8000];		/*  0x40000 - 0x60000 */
+		u32 reset;			/*  0x60000 - 0x60004 */
 		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
 	} channel[4];
 };

commit 95b24682d6a7e584f69615e36ee304caba20e38f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 15 12:20:00 2012 +0100

    staging: comedi: jr3_pci: add __iomem tags
    
    Tag pointers to remapped I/O memory with `__iomem` and remove the
    `volatile` qualifiers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 9c42653d8f18..3317f7a04c48 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,22 +2,22 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-static inline u16 get_u16(volatile const u32 * p)
+static inline u16 get_u16(const u32 __iomem *p)
 {
-	return (u16) readl(p);
+	return (u16)readl(p);
 }
 
-static inline void set_u16(volatile u32 * p, u16 val)
+static inline void set_u16(u32 __iomem *p, u16 val)
 {
 	writel(val, p);
 }
 
-static inline s16 get_s16(volatile const s32 * p)
+static inline s16 get_s16(const s32 __iomem *p)
 {
-	return (s16) readl(p);
+	return (s16)readl(p);
 }
 
-static inline void set_s16(volatile s32 * p, s16 val)
+static inline void set_s16(s32 __iomem *p, s16 val)
 {
 	writel(val, p);
 }

commit 135f8a5e031db8ef4031fb3c815ef7ace876f9b1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 17 13:13:48 2012 -0700

    staging: comedi: jr3_pci.h: remove vect_bits_t and warning_bits_t
    
    Leave the enum's but remove their names. The names are not used
    anywhere in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index a1469611d84e..9c42653d8f18 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -97,7 +97,7 @@ enum {
 	mz = 0x0020,
 	changeV2 = 0x0040,
 	changeV1 = 0x0080
-} vect_bits_t;
+};
 
 /* WARNING_BITS */
 /* The warning_bits structure shows the bit pattern for the warning
@@ -116,7 +116,7 @@ enum {
 	mx_near_sat = 0x0008,
 	my_near_sat = 0x0010,
 	mz_near_sat = 0x0020
-} warning_bits_t;
+};
 
 /*  ERROR_BITS */
 /*  XX_SAT */

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 4f4bfb24c6d6..a1469611d84e 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,22 +2,22 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-static inline u16 get_u16(volatile const u32 *p)
+static inline u16 get_u16(volatile const u32 * p)
 {
 	return (u16) readl(p);
 }
 
-static inline void set_u16(volatile u32 *p, u16 val)
+static inline void set_u16(volatile u32 * p, u16 val)
 {
 	writel(val, p);
 }
 
-static inline s16 get_s16(volatile const s32 *p)
+static inline s16 get_s16(volatile const s32 * p)
 {
 	return (s16) readl(p);
 }
 
-static inline void set_s16(volatile s32 *p, s16 val)
+static inline void set_s16(volatile s32 * p, s16 val)
 {
 	writel(val, p);
 }
@@ -304,7 +304,7 @@ struct jr3_channel {
 	/* not set a full scale. */
 
 	struct six_axis_array default_FS;	/* offset 0x0068 */
-	s32 reserved3;	/* offset 0x006e */
+	s32 reserved3;		/* offset 0x006e */
 
 	/* Load_envelope_num is the load envelope number that is currently
 	 * in use. This value is set by the user after one of the load
@@ -341,7 +341,7 @@ struct jr3_channel {
 	 */
 
 	struct six_axis_array min_full_scale;	/* offset 0x0070 */
-	s32 reserved4;	/* offset 0x0076 */
+	s32 reserved4;		/* offset 0x0076 */
 
 	/* Transform_num is the transform number that is currently in use.
 	 * This value is set by the JR3 DSP after the user has used command
@@ -354,7 +354,7 @@ struct jr3_channel {
 	/*  min_full_scale (pg. 9) for more details. */
 
 	struct six_axis_array max_full_scale;	/* offset 0x0078 */
-	s32 reserved5;	/* offset 0x007e */
+	s32 reserved5;		/* offset 0x007e */
 
 	/* Peak_address is the address of the data which will be monitored
 	 * by the peak routine. This value is set by the user. The peak
@@ -398,14 +398,14 @@ struct jr3_channel {
 	 * offset # command (pg. 34). It can vary between 0 and 15.
 	 */
 
-	s32 offset_num;	/* offset 0x008e */
+	s32 offset_num;		/* offset 0x008e */
 
 	/* Vect_axes is a bit map showing which of the axes are being used
 	 * in the vector calculations. This value is set by the JR3 DSP
 	 * after the user has executed the set vector axes command (pg. 37).
 	 */
 
-	u32 vect_axes;	/* offset 0x008f */
+	u32 vect_axes;		/* offset 0x008f */
 
 	/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.
 	 * This data has had the offsets removed.
@@ -465,7 +465,7 @@ struct jr3_channel {
 	 */
 
 	s32 near_sat_value;	/* offset 0x00e0 */
-	s32 sat_value;	/* offset 0x00e1 */
+	s32 sat_value;		/* offset 0x00e1 */
 
 	/* Rate_address, rate_divisor & rate_count contain the data used to
 	 * control the calculations of the rates. Rate_address is the
@@ -486,7 +486,7 @@ struct jr3_channel {
 
 	s32 rate_address;	/* offset 0x00e2 */
 	u32 rate_divisor;	/* offset 0x00e3 */
-	u32 rate_count;	/* offset 0x00e4 */
+	u32 rate_count;		/* offset 0x00e4 */
 
 	/* Command_word2 through command_word0 are the locations used to
 	 * send commands to the JR3 DSP. Their usage varies with the command
@@ -543,14 +543,14 @@ struct jr3_channel {
 	 * Issues section on pg. 49 for more details.
 	 */
 
-	u32 count_x;	/* offset 0x00ef */
+	u32 count_x;		/* offset 0x00ef */
 
 	/* Warnings & errors contain the warning and error bits
 	 * respectively. The format of these two words is discussed on page
 	 * 21 under the headings warnings_bits and error_bits.
 	 */
 
-	u32 warnings;	/* offset 0x00f0 */
+	u32 warnings;		/* offset 0x00f0 */
 	u32 errors;		/* offset 0x00f1 */
 
 	/* Threshold_bits is a word containing the bits that are set by the
@@ -565,7 +565,7 @@ struct jr3_channel {
 	 * description for cal_crc_bad (pg. 21) for more information.
 	 */
 
-	s32 last_CRC;	/* offset 0x00f3 */
+	s32 last_CRC;		/* offset 0x00f3 */
 
 	/* EEProm_ver_no contains the version number of the sensor EEProm.
 	 * EEProm version numbers can vary between 0 and 255.
@@ -591,16 +591,16 @@ struct jr3_channel {
 	 * different sensor configurations.
 	 */
 
-	u32 serial_no;	/* offset 0x00f8 */
-	u32 model_no;	/* offset 0x00f9 */
+	u32 serial_no;		/* offset 0x00f8 */
+	u32 model_no;		/* offset 0x00f9 */
 
 	/* Cal_day & cal_year are the sensor calibration date. Day is the
 	 * day of the year, with January 1 being 1, and December 31, being
 	 * 366 for leap years.
 	 */
 
-	s32 cal_day;	/* offset 0x00fa */
-	s32 cal_year;	/* offset 0x00fb */
+	s32 cal_day;		/* offset 0x00fa */
+	s32 cal_year;		/* offset 0x00fb */
 
 	/* Units is an enumerated read only value defining the engineering
 	 * units used in the sensor full scale. The meanings of particular
@@ -627,7 +627,7 @@ struct jr3_channel {
 
 	u32 units;		/* offset 0x00fc */
 	s32 bits;		/* offset 0x00fd */
-	s32 channels;	/* offset 0x00fe */
+	s32 channels;		/* offset 0x00fe */
 
 	/* Thickness specifies the overall thickness of the sensor from
 	 * flange to flange. The engineering units for this value are
@@ -636,7 +636,7 @@ struct jr3_channel {
 	 * transformation from the center of the sensor to either flange.
 	 */
 
-	s32 thickness;	/* offset 0x00ff */
+	s32 thickness;		/* offset 0x00ff */
 
 	/* Load_envelopes is a table containing the load envelope
 	 * descriptions. There are 16 possible load envelope slots in the

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 3585f2941bca..4f4bfb24c6d6 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,22 +2,22 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-static inline u16 get_u16(volatile const u32 * p)
+static inline u16 get_u16(volatile const u32 *p)
 {
 	return (u16) readl(p);
 }
 
-static inline void set_u16(volatile u32 * p, u16 val)
+static inline void set_u16(volatile u32 *p, u16 val)
 {
 	writel(val, p);
 }
 
-static inline s16 get_s16(volatile const s32 * p)
+static inline s16 get_s16(volatile const s32 *p)
 {
 	return (s16) readl(p);
 }
 
-static inline void set_s16(volatile s32 * p, s16 val)
+static inline void set_s16(volatile s32 *p, s16 val)
 {
 	writel(val, p);
 }

commit 67080790a44f6633acc250db915a4f6481e81ba1
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:31 2009 -0400

    Staging: comedi: Remove jr3_channel_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index d98aaa7c6f5c..3585f2941bca 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -264,7 +264,7 @@ struct intern_transform {
 /*  JR3 force/torque sensor data definition. For more information see sensor and */
 /*  hardware manuals. */
 
-typedef struct force_sensor_data {
+struct jr3_channel {
 	/*  Raw_channels is the area used to store the raw data coming from */
 	/*  the sensor. */
 
@@ -667,12 +667,12 @@ typedef struct force_sensor_data {
 	 */
 
 	struct intern_transform transforms[0x10];	/* offset 0x0200 */
-} jr3_channel_t;
+};
 
 struct jr3_t {
 	struct {
 		u32 program_low[0x4000];	/*  0x00000 - 0x10000 */
-		jr3_channel_t data;	/*  0x10000 - 0x10c00 */
+		struct jr3_channel data;	/*  0x10000 - 0x10c00 */
 		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
 		u32 program_high[0x8000];	/*  0x40000 - 0x60000 */
 		u32 reset;	/*  0x60000 - 0x60004 */

commit 1c31ddaf9b46bec3df20b3a3b95049f45f43bf84
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:26 2009 -0400

    Staging: comedi: Remove intern_transform_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index dc9273239e2a..d98aaa7c6f5c 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -254,12 +254,12 @@ enum link_types {
 
 /*  TRANSFORM */
 /*  Structure used to describe a transform. */
-typedef struct {
+struct intern_transform {
 	struct {
 		u32 link_type;
 		s32 link_amount;
 	} link[8];
-} intern_transform_t;
+};
 
 /*  JR3 force/torque sensor data definition. For more information see sensor and */
 /*  hardware manuals. */
@@ -666,7 +666,7 @@ typedef struct force_sensor_data {
 	 * definition of the transform structure (pg. 26).
 	 */
 
-	intern_transform_t transforms[0x10];	/* offset 0x0200 */
+	struct intern_transform transforms[0x10];	/* offset 0x0200 */
 } jr3_channel_t;
 
 struct jr3_t {

commit 4e1ccd9717df80a6207fe89eb0761415cbe5b2e7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:20 2009 -0400

    Staging: comedi: Remove link_types typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index d8a21dea3ca2..dc9273239e2a 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -241,7 +241,7 @@ struct le_struct {
  * 7 - negate all axes (NEG)
  */
 
-typedef enum link_types {
+enum link_types {
 	end_x_form,
 	tx,
 	ty,
@@ -250,7 +250,7 @@ typedef enum link_types {
 	ry,
 	rz,
 	neg
-} link_types;
+};
 
 /*  TRANSFORM */
 /*  Structure used to describe a transform. */

commit b2e1b3c2bd6245c6d3d79f69fa94813b7db9a61e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:15 2009 -0400

    Staging: comedi: Remove jr3_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index d77f0ad62c51..d8a21dea3ca2 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -669,7 +669,7 @@ typedef struct force_sensor_data {
 	intern_transform_t transforms[0x10];	/* offset 0x0200 */
 } jr3_channel_t;
 
-typedef struct {
+struct jr3_t {
 	struct {
 		u32 program_low[0x4000];	/*  0x00000 - 0x10000 */
 		jr3_channel_t data;	/*  0x10000 - 0x10c00 */
@@ -678,4 +678,4 @@ typedef struct {
 		u32 reset;	/*  0x60000 - 0x60004 */
 		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
 	} channel[4];
-} jr3_t;
+};

commit 0306b0cb8e13d51c16adf9bc3285de80f6dc93b3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:09 2009 -0400

    Staging: comedi: Remove le_struct_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 7c5a15bb4bf1..d77f0ad62c51 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -220,13 +220,13 @@ struct thresh_struct {
  *    command.
  * 2. number_of_xx_thresholds specify how many GE/LE threshold there are.
  */
-typedef struct {
+struct le_struct {
 	s32 latch_bits;
 	s32 number_of_ge_thresholds;
 	s32 number_of_le_thresholds;
 	struct thresh_struct thresholds[4];
 	s32 reserved;
-} le_struct_t;
+};
 
 /*  LINK_TYPES */
 /* Link types is an enumerated value showing the different possible transform
@@ -652,7 +652,7 @@ typedef struct force_sensor_data {
 	 * le_struct structure (pg. 23).
 	 */
 
-	le_struct_t load_envelopes[0x10];	/* offset 0x0100 */
+	struct le_struct load_envelopes[0x10];	/* offset 0x0100 */
 
 	/* Transforms is a table containing the transform descriptions.
 	 * There are 16 possible transform slots in the table. The slots are

commit 38443673506e19ad9af9785c5e5ebead81b6be39
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:04 2009 -0400

    Staging: comedi: Remove thresh_struct typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index b385596c7755..7c5a15bb4bf1 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -204,11 +204,11 @@ enum error_bits_t {
  *    met or exceeded.
  */
 
-typedef struct thresh_struct {
+struct thresh_struct {
 	s32 data_address;
 	s32 threshold;
 	s32 bit_pattern;
-} thresh_struct;
+};
 
 /*  LE_STRUCT */
 

commit f3fd0937adacadd368126d1999d1060390497915
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:59 2009 -0400

    Staging: comedi: Remove vect_bits_t, warning_bits_t, and error_bits_t typedefs
    
    These are enums that are not used anywhere at this time.
    This removes the typedef, but leaves the enum in place.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 325ed0527519..b385596c7755 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -87,7 +87,8 @@ struct six_axis_array {
  * have two force vectors, set changeV1 to 1.
  */
 
-typedef enum {
+/* vect_bits appears to be unused at this time */
+enum {
 	fx = 0x0001,
 	fy = 0x0002,
 	fz = 0x0004,
@@ -108,7 +109,7 @@ typedef enum {
  * exceeded the near saturation value.
  */
 
-typedef enum {
+enum {
 	fx_near_sat = 0x0001,
 	fy_near_sat = 0x0002,
 	fz_near_sat = 0x0004,
@@ -176,7 +177,7 @@ typedef enum {
  * the sensor data is not being received correctly.
  */
 
-typedef enum {
+enum error_bits_t {
 	fx_sat = 0x0001,
 	fy_sat = 0x0002,
 	fz_sat = 0x0004,
@@ -189,7 +190,7 @@ typedef enum {
 	cal_crc_bad = 0x2000,
 	watch_dog2 = 0x4000,
 	watch_dog = 0x8000
-} error_bits_t;
+};
 
 /*  THRESH_STRUCT */
 

commit 5671c0c2d85203472b02100a517ce5c565e5c1e0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:53 2009 -0400

    Staging: comedi: Remove six_axis_array_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 06c32f507197..325ed0527519 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -64,14 +64,14 @@ struct force_array {
 /* The six_axis_array structure shows the layout for the offsets and
  * the full scales.
  */
-typedef struct six_axis_array {
+struct six_axis_array {
 	s32 fx;
 	s32 fy;
 	s32 fz;
 	s32 mx;
 	s32 my;
 	s32 mz;
-} six_axis_array_t;
+};
 
 /* VECT_BITS */
 /* The vect_bits structure shows the layout for indicating
@@ -296,13 +296,13 @@ typedef struct force_sensor_data {
 	 * command (10) set new full scales (pg. 38).
 	 */
 
-	six_axis_array_t shunts;	/* offset 0x0060 */
+	struct six_axis_array shunts;	/* offset 0x0060 */
 	s32 reserved2[2];	/* offset 0x0066 */
 
 	/* Default_FS contains the full scale that is used if the user does */
 	/* not set a full scale. */
 
-	six_axis_array_t default_FS;	/* offset 0x0068 */
+	struct six_axis_array default_FS;	/* offset 0x0068 */
 	s32 reserved3;	/* offset 0x006e */
 
 	/* Load_envelope_num is the load envelope number that is currently
@@ -339,7 +339,7 @@ typedef struct force_sensor_data {
 	 * cause erroneous results.
 	 */
 
-	six_axis_array_t min_full_scale;	/* offset 0x0070 */
+	struct six_axis_array min_full_scale;	/* offset 0x0070 */
 	s32 reserved4;	/* offset 0x0076 */
 
 	/* Transform_num is the transform number that is currently in use.
@@ -352,7 +352,7 @@ typedef struct force_sensor_data {
 	/*  Max_full_scale is the recommended maximum full scale. See */
 	/*  min_full_scale (pg. 9) for more details. */
 
-	six_axis_array_t max_full_scale;	/* offset 0x0078 */
+	struct six_axis_array max_full_scale;	/* offset 0x0078 */
 	s32 reserved5;	/* offset 0x007e */
 
 	/* Peak_address is the address of the data which will be monitored
@@ -390,7 +390,7 @@ typedef struct force_sensor_data {
 	 * about Z by 90 degrees, FY would be 5 and all others would be zero.
 	 */
 
-	six_axis_array_t offsets;	/* offset 0x0088 */
+	struct six_axis_array offsets;	/* offset 0x0088 */
 
 	/* Offset_num is the number of the offset currently in use. This
 	 * value is set by the JR3 DSP after the user has executed the use

commit cdc14cd0ea064b4838f63073ebf5cd2fdf13f309
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:48 2009 -0400

    Staging: comedi: Remove force_array_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 43d1411417a4..06c32f507197 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -50,7 +50,7 @@ struct raw_channel {
 /* The force_array structure shows the layout for the decoupled and
  * filtered force data.
  */
-typedef struct force_array {
+struct force_array {
 	s32 fx;
 	s32 fy;
 	s32 fz;
@@ -59,7 +59,7 @@ typedef struct force_array {
 	s32 mz;
 	s32 v1;
 	s32 v2;
-} force_array_t;
+};
 
 /* The six_axis_array structure shows the layout for the offsets and
  * the full scales.
@@ -375,7 +375,7 @@ typedef struct force_sensor_data {
 	 * axes used for each vector respectively.
 	 */
 
-	force_array_t full_scale;	/* offset 0x0080 */
+	struct force_array full_scale;	/* offset 0x0080 */
 
 	/* Offsets contains the sensor offsets. These values are subtracted from
 	 * the sensor data to obtain the decoupled data. The offsets are set a
@@ -432,7 +432,7 @@ typedef struct force_sensor_data {
 	 * calculated is specified by the variable rate_address (pg. 12).
 	 */
 
-	force_array_t rate_data;	/* offset 0x00c8 */
+	struct force_array rate_data;	/* offset 0x00c8 */
 
 	/* Minimum_data & maximum_data are the minimum and maximum (peak)
 	 * data values. The JR3 DSP can monitor any 8 contiguous data items
@@ -446,8 +446,8 @@ typedef struct force_sensor_data {
 	 * also lost when plugging in a new sensor.
 	 */
 
-	force_array_t minimum_data;	/* offset 0x00d0 */
-	force_array_t maximum_data;	/* offset 0x00d8 */
+	struct force_array minimum_data;	/* offset 0x00d0 */
+	struct force_array maximum_data;	/* offset 0x00d8 */
 
 	/* Near_sat_value & sat_value contain the value used to determine if
 	 * the raw sensor is saturated. Because of decoupling and offset

commit 2deee55e66d0de60ca28703da5aba8bdaf27b4ba
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:43 2009 -0400

    Staging: comedi: Remove raw_channel typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 4576dd28ae47..43d1411417a4 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -41,11 +41,11 @@ static inline void set_s16(volatile s32 * p, s16 val)
  * varies with different sensors.
  */
 
-typedef struct raw_channel {
+struct raw_channel {
 	u32 raw_time;
 	s32 raw_data;
 	s32 reserved[2];
-} raw_channel_t;
+};
 
 /* The force_array structure shows the layout for the decoupled and
  * filtered force data.
@@ -267,7 +267,7 @@ typedef struct force_sensor_data {
 	/*  Raw_channels is the area used to store the raw data coming from */
 	/*  the sensor. */
 
-	raw_channel_t raw_channels[16];	/* offset 0x0000 */
+	struct raw_channel raw_channels[16];	/* offset 0x0000 */
 
 	/*  Copyright is a null terminated ASCII string containing the JR3 */
 	/*  copyright notice. */

commit 0642feb3e1ffe896ff0fd67cad5fc33a51fe4651
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:37 2009 -0400

    Staging: comedi: Remove s_val_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 669521e6cb84..4576dd28ae47 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,8 +2,6 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-typedef s32 s_val_t;
-
 static inline u16 get_u16(volatile const u32 * p)
 {
 	return (u16) readl(p);
@@ -14,12 +12,12 @@ static inline void set_u16(volatile u32 * p, u16 val)
 	writel(val, p);
 }
 
-static inline s16 get_s16(volatile const s_val_t * p)
+static inline s16 get_s16(volatile const s32 * p)
 {
 	return (s16) readl(p);
 }
 
-static inline void set_s16(volatile s_val_t * p, s16 val)
+static inline void set_s16(volatile s32 * p, s16 val)
 {
 	writel(val, p);
 }
@@ -45,34 +43,34 @@ static inline void set_s16(volatile s_val_t * p, s16 val)
 
 typedef struct raw_channel {
 	u32 raw_time;
-	s_val_t raw_data;
-	s_val_t reserved[2];
+	s32 raw_data;
+	s32 reserved[2];
 } raw_channel_t;
 
 /* The force_array structure shows the layout for the decoupled and
  * filtered force data.
  */
 typedef struct force_array {
-	s_val_t fx;
-	s_val_t fy;
-	s_val_t fz;
-	s_val_t mx;
-	s_val_t my;
-	s_val_t mz;
-	s_val_t v1;
-	s_val_t v2;
+	s32 fx;
+	s32 fy;
+	s32 fz;
+	s32 mx;
+	s32 my;
+	s32 mz;
+	s32 v1;
+	s32 v2;
 } force_array_t;
 
 /* The six_axis_array structure shows the layout for the offsets and
  * the full scales.
  */
 typedef struct six_axis_array {
-	s_val_t fx;
-	s_val_t fy;
-	s_val_t fz;
-	s_val_t mx;
-	s_val_t my;
-	s_val_t mz;
+	s32 fx;
+	s32 fy;
+	s32 fz;
+	s32 mx;
+	s32 my;
+	s32 mz;
 } six_axis_array_t;
 
 /* VECT_BITS */
@@ -258,7 +256,7 @@ typedef enum link_types {
 typedef struct {
 	struct {
 		u32 link_type;
-		s_val_t link_amount;
+		s32 link_amount;
 	} link[8];
 } intern_transform_t;
 
@@ -275,7 +273,7 @@ typedef struct force_sensor_data {
 	/*  copyright notice. */
 
 	u32 copyright[0x0018];	/* offset 0x0040 */
-	s_val_t reserved1[0x0008];	/* offset 0x0058 */
+	s32 reserved1[0x0008];	/* offset 0x0058 */
 
 	/* Shunts contains the sensor shunt readings. Some JR3 sensors have
 	 * the ability to have their gains adjusted. This allows the
@@ -305,14 +303,14 @@ typedef struct force_sensor_data {
 	/* not set a full scale. */
 
 	six_axis_array_t default_FS;	/* offset 0x0068 */
-	s_val_t reserved3;	/* offset 0x006e */
+	s32 reserved3;	/* offset 0x006e */
 
 	/* Load_envelope_num is the load envelope number that is currently
 	 * in use. This value is set by the user after one of the load
 	 * envelopes has been initialized.
 	 */
 
-	s_val_t load_envelope_num;	/* offset 0x006f */
+	s32 load_envelope_num;	/* offset 0x006f */
 
 	/* Min_full_scale is the recommend minimum full scale. */
 
@@ -342,20 +340,20 @@ typedef struct force_sensor_data {
 	 */
 
 	six_axis_array_t min_full_scale;	/* offset 0x0070 */
-	s_val_t reserved4;	/* offset 0x0076 */
+	s32 reserved4;	/* offset 0x0076 */
 
 	/* Transform_num is the transform number that is currently in use.
 	 * This value is set by the JR3 DSP after the user has used command
 	 * (5) use transform # (pg. 33).
 	 */
 
-	s_val_t transform_num;	/* offset 0x0077 */
+	s32 transform_num;	/* offset 0x0077 */
 
 	/*  Max_full_scale is the recommended maximum full scale. See */
 	/*  min_full_scale (pg. 9) for more details. */
 
 	six_axis_array_t max_full_scale;	/* offset 0x0078 */
-	s_val_t reserved5;	/* offset 0x007e */
+	s32 reserved5;	/* offset 0x007e */
 
 	/* Peak_address is the address of the data which will be monitored
 	 * by the peak routine. This value is set by the user. The peak
@@ -363,7 +361,7 @@ typedef struct force_sensor_data {
 	 * (ex. to watch filter3 data for peaks, set this value to 0x00a8).
 	 */
 
-	s_val_t peak_address;	/* offset 0x007f */
+	s32 peak_address;	/* offset 0x007f */
 
 	/* Full_scale is the sensor full scales which are currently in use.
 	 * Decoupled and filtered data is scaled so that +/- 16384 is equal
@@ -399,7 +397,7 @@ typedef struct force_sensor_data {
 	 * offset # command (pg. 34). It can vary between 0 and 15.
 	 */
 
-	s_val_t offset_num;	/* offset 0x008e */
+	s32 offset_num;	/* offset 0x008e */
 
 	/* Vect_axes is a bit map showing which of the axes are being used
 	 * in the vector calculations. This value is set by the JR3 DSP
@@ -465,8 +463,8 @@ typedef struct force_sensor_data {
 	 *   sat_value = 32768 - 2^(16 - ADC bits)
 	 */
 
-	s_val_t near_sat_value;	/* offset 0x00e0 */
-	s_val_t sat_value;	/* offset 0x00e1 */
+	s32 near_sat_value;	/* offset 0x00e0 */
+	s32 sat_value;	/* offset 0x00e1 */
 
 	/* Rate_address, rate_divisor & rate_count contain the data used to
 	 * control the calculations of the rates. Rate_address is the
@@ -485,7 +483,7 @@ typedef struct force_sensor_data {
 	 * will minimize the time necessary to start the rate calculations.
 	 */
 
-	s_val_t rate_address;	/* offset 0x00e2 */
+	s32 rate_address;	/* offset 0x00e2 */
 	u32 rate_divisor;	/* offset 0x00e3 */
 	u32 rate_count;	/* offset 0x00e4 */
 
@@ -502,9 +500,9 @@ typedef struct force_sensor_data {
 	 * command_word1).
 	 */
 
-	s_val_t command_word2;	/* offset 0x00e5 */
-	s_val_t command_word1;	/* offset 0x00e6 */
-	s_val_t command_word0;	/* offset 0x00e7 */
+	s32 command_word2;	/* offset 0x00e5 */
+	s32 command_word1;	/* offset 0x00e6 */
+	s32 command_word0;	/* offset 0x00e7 */
 
 	/* Count1 through count6 are unsigned counters which are incremented
 	 * every time the matching filters are calculated. Filter1 is
@@ -559,14 +557,14 @@ typedef struct force_sensor_data {
 	 * (pg. 23) for more details.
 	 */
 
-	s_val_t threshold_bits;	/* offset 0x00f2 */
+	s32 threshold_bits;	/* offset 0x00f2 */
 
 	/* Last_crc is the value that shows the actual calculated CRC. CRC
 	 * is short for cyclic redundancy code. It should be zero. See the
 	 * description for cal_crc_bad (pg. 21) for more information.
 	 */
 
-	s_val_t last_CRC;	/* offset 0x00f3 */
+	s32 last_CRC;	/* offset 0x00f3 */
 
 	/* EEProm_ver_no contains the version number of the sensor EEProm.
 	 * EEProm version numbers can vary between 0 and 255.
@@ -574,8 +572,8 @@ typedef struct force_sensor_data {
 	 * 3.02 would be stored as 302.
 	 */
 
-	s_val_t eeprom_ver_no;	/* offset 0x00f4 */
-	s_val_t software_ver_no;	/* offset 0x00f5 */
+	s32 eeprom_ver_no;	/* offset 0x00f4 */
+	s32 software_ver_no;	/* offset 0x00f5 */
 
 	/* Software_day & software_year are the release date of the software
 	 * the JR3 DSP is currently running. Day is the day of the year,
@@ -583,8 +581,8 @@ typedef struct force_sensor_data {
 	 * years.
 	 */
 
-	s_val_t software_day;	/* offset 0x00f6 */
-	s_val_t software_year;	/* offset 0x00f7 */
+	s32 software_day;	/* offset 0x00f6 */
+	s32 software_year;	/* offset 0x00f7 */
 
 	/* Serial_no & model_no are the two values which uniquely identify a
 	 * sensor. This model number does not directly correspond to the JR3
@@ -600,8 +598,8 @@ typedef struct force_sensor_data {
 	 * 366 for leap years.
 	 */
 
-	s_val_t cal_day;	/* offset 0x00fa */
-	s_val_t cal_year;	/* offset 0x00fb */
+	s32 cal_day;	/* offset 0x00fa */
+	s32 cal_year;	/* offset 0x00fb */
 
 	/* Units is an enumerated read only value defining the engineering
 	 * units used in the sensor full scale. The meanings of particular
@@ -627,8 +625,8 @@ typedef struct force_sensor_data {
 	 */
 
 	u32 units;		/* offset 0x00fc */
-	s_val_t bits;		/* offset 0x00fd */
-	s_val_t channels;	/* offset 0x00fe */
+	s32 bits;		/* offset 0x00fd */
+	s32 channels;	/* offset 0x00fe */
 
 	/* Thickness specifies the overall thickness of the sensor from
 	 * flange to flange. The engineering units for this value are
@@ -637,7 +635,7 @@ typedef struct force_sensor_data {
 	 * transformation from the center of the sensor to either flange.
 	 */
 
-	s_val_t thickness;	/* offset 0x00ff */
+	s32 thickness;	/* offset 0x00ff */
 
 	/* Load_envelopes is a table containing the load envelope
 	 * descriptions. There are 16 possible load envelope slots in the

commit 54298a8d0696046874a644c9a2be71a1e582f688
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:32 2009 -0400

    Staging: comedi: Remove u_val_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 1b43a2ad7112..669521e6cb84 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -2,16 +2,14 @@
  * is 16 bits, but aligned on a 32 bit PCI boundary
  */
 
-typedef u32 u_val_t;
-
 typedef s32 s_val_t;
 
-static inline u16 get_u16(volatile const u_val_t * p)
+static inline u16 get_u16(volatile const u32 * p)
 {
 	return (u16) readl(p);
 }
 
-static inline void set_u16(volatile u_val_t * p, u16 val)
+static inline void set_u16(volatile u32 * p, u16 val)
 {
 	writel(val, p);
 }
@@ -46,7 +44,7 @@ static inline void set_s16(volatile s_val_t * p, s16 val)
  */
 
 typedef struct raw_channel {
-	u_val_t raw_time;
+	u32 raw_time;
 	s_val_t raw_data;
 	s_val_t reserved[2];
 } raw_channel_t;
@@ -259,7 +257,7 @@ typedef enum link_types {
 /*  Structure used to describe a transform. */
 typedef struct {
 	struct {
-		u_val_t link_type;
+		u32 link_type;
 		s_val_t link_amount;
 	} link[8];
 } intern_transform_t;
@@ -276,7 +274,7 @@ typedef struct force_sensor_data {
 	/*  Copyright is a null terminated ASCII string containing the JR3 */
 	/*  copyright notice. */
 
-	u_val_t copyright[0x0018];	/* offset 0x0040 */
+	u32 copyright[0x0018];	/* offset 0x0040 */
 	s_val_t reserved1[0x0008];	/* offset 0x0058 */
 
 	/* Shunts contains the sensor shunt readings. Some JR3 sensors have
@@ -408,7 +406,7 @@ typedef struct force_sensor_data {
 	 * after the user has executed the set vector axes command (pg. 37).
 	 */
 
-	u_val_t vect_axes;	/* offset 0x008f */
+	u32 vect_axes;	/* offset 0x008f */
 
 	/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.
 	 * This data has had the offsets removed.
@@ -488,8 +486,8 @@ typedef struct force_sensor_data {
 	 */
 
 	s_val_t rate_address;	/* offset 0x00e2 */
-	u_val_t rate_divisor;	/* offset 0x00e3 */
-	u_val_t rate_count;	/* offset 0x00e4 */
+	u32 rate_divisor;	/* offset 0x00e3 */
+	u32 rate_count;	/* offset 0x00e4 */
 
 	/* Command_word2 through command_word0 are the locations used to
 	 * send commands to the JR3 DSP. Their usage varies with the command
@@ -520,12 +518,12 @@ typedef struct force_sensor_data {
 	 * once.
 	 */
 
-	u_val_t count1;		/* offset 0x00e8 */
-	u_val_t count2;		/* offset 0x00e9 */
-	u_val_t count3;		/* offset 0x00ea */
-	u_val_t count4;		/* offset 0x00eb */
-	u_val_t count5;		/* offset 0x00ec */
-	u_val_t count6;		/* offset 0x00ed */
+	u32 count1;		/* offset 0x00e8 */
+	u32 count2;		/* offset 0x00e9 */
+	u32 count3;		/* offset 0x00ea */
+	u32 count4;		/* offset 0x00eb */
+	u32 count5;		/* offset 0x00ec */
+	u32 count6;		/* offset 0x00ed */
 
 	/* Error_count is a running count of data reception errors. If this
 	 * counter is changing rapidly, it probably indicates a bad sensor
@@ -537,7 +535,7 @@ typedef struct force_sensor_data {
 	 * where this counter counts a bad sample, that sample is ignored.
 	 */
 
-	u_val_t error_count;	/* offset 0x00ee */
+	u32 error_count;	/* offset 0x00ee */
 
 	/* Count_x is a counter which is incremented every time the JR3 DSP
 	 * searches its job queues and finds nothing to do. It indicates the
@@ -546,15 +544,15 @@ typedef struct force_sensor_data {
 	 * Issues section on pg. 49 for more details.
 	 */
 
-	u_val_t count_x;	/* offset 0x00ef */
+	u32 count_x;	/* offset 0x00ef */
 
 	/* Warnings & errors contain the warning and error bits
 	 * respectively. The format of these two words is discussed on page
 	 * 21 under the headings warnings_bits and error_bits.
 	 */
 
-	u_val_t warnings;	/* offset 0x00f0 */
-	u_val_t errors;		/* offset 0x00f1 */
+	u32 warnings;	/* offset 0x00f0 */
+	u32 errors;		/* offset 0x00f1 */
 
 	/* Threshold_bits is a word containing the bits that are set by the
 	 * load envelopes. See load_envelopes (pg. 17) and thresh_struct
@@ -594,8 +592,8 @@ typedef struct force_sensor_data {
 	 * different sensor configurations.
 	 */
 
-	u_val_t serial_no;	/* offset 0x00f8 */
-	u_val_t model_no;	/* offset 0x00f9 */
+	u32 serial_no;	/* offset 0x00f8 */
+	u32 model_no;	/* offset 0x00f9 */
 
 	/* Cal_day & cal_year are the sensor calibration date. Day is the
 	 * day of the year, with January 1 being 1, and December 31, being
@@ -628,7 +626,7 @@ typedef struct force_sensor_data {
 	 * received.
 	 */
 
-	u_val_t units;		/* offset 0x00fc */
+	u32 units;		/* offset 0x00fc */
 	s_val_t bits;		/* offset 0x00fd */
 	s_val_t channels;	/* offset 0x00fe */
 
@@ -674,10 +672,10 @@ typedef struct force_sensor_data {
 
 typedef struct {
 	struct {
-		u_val_t program_low[0x4000];	/*  0x00000 - 0x10000 */
+		u32 program_low[0x4000];	/*  0x00000 - 0x10000 */
 		jr3_channel_t data;	/*  0x10000 - 0x10c00 */
 		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
-		u_val_t program_high[0x8000];	/*  0x40000 - 0x60000 */
+		u32 program_high[0x8000];	/*  0x40000 - 0x60000 */
 		u32 reset;	/*  0x60000 - 0x60004 */
 		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
 	} channel[4];

commit b2be969bf9092cdd091e450a614798cfd42ad1f6
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:12:26 2009 -0400

    Staging: comedi: Replace C99 comments in jr3_pci.h
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
index 286cdaadfa1c..1b43a2ad7112 100644
--- a/drivers/staging/comedi/drivers/jr3_pci.h
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -1,5 +1,7 @@
-// Helper types to take care of the fact that the DSP card memory
-//   is 16 bits, but aligned on a 32 bit PCI boundary
+/* Helper types to take care of the fact that the DSP card memory
+ * is 16 bits, but aligned on a 32 bit PCI boundary
+ */
+
 typedef u32 u_val_t;
 
 typedef s32 s_val_t;
@@ -24,31 +26,34 @@ static inline void set_s16(volatile s_val_t * p, s16 val)
 	writel(val, p);
 }
 
-// The raw data is stored in a format which facilitates rapid
-// processing by the JR3 DSP chip. The raw_channel structure shows the
-// format for a single channel of data. Each channel takes four,
-// two-byte words.
-//
-// Raw_time is an unsigned integer which shows the value of the JR3
-// DSP's internal clock at the time the sample was received. The clock
-// runs at 1/10 the JR3 DSP cycle time. JR3's slowest DSP runs at 10
-// Mhz. At 10 Mhz raw_time would therefore clock at 1 Mhz.
-//
-// Raw_data is the raw data received directly from the sensor. The
-// sensor data stream is capable of representing 16 different
-// channels. Channel 0 shows the excitation voltage at the sensor. It
-// is used to regulate the voltage over various cable lengths.
-// Channels 1-6 contain the coupled force data Fx through Mz. Channel
-// 7 contains the sensor's calibration data. The use of channels 8-15
-// varies with different sensors.
+/* The raw data is stored in a format which facilitates rapid
+ * processing by the JR3 DSP chip. The raw_channel structure shows the
+ * format for a single channel of data. Each channel takes four,
+ * two-byte words.
+ *
+ * Raw_time is an unsigned integer which shows the value of the JR3
+ * DSP's internal clock at the time the sample was received. The clock
+ * runs at 1/10 the JR3 DSP cycle time. JR3's slowest DSP runs at 10
+ * Mhz. At 10 Mhz raw_time would therefore clock at 1 Mhz.
+ *
+ * Raw_data is the raw data received directly from the sensor. The
+ * sensor data stream is capable of representing 16 different
+ * channels. Channel 0 shows the excitation voltage at the sensor. It
+ * is used to regulate the voltage over various cable lengths.
+ * Channels 1-6 contain the coupled force data Fx through Mz. Channel
+ * 7 contains the sensor's calibration data. The use of channels 8-15
+ * varies with different sensors.
+ */
+
 typedef struct raw_channel {
 	u_val_t raw_time;
 	s_val_t raw_data;
 	s_val_t reserved[2];
 } raw_channel_t;
 
-// The force_array structure shows the layout for the decoupled and
-// filtered force data.
+/* The force_array structure shows the layout for the decoupled and
+ * filtered force data.
+ */
 typedef struct force_array {
 	s_val_t fx;
 	s_val_t fy;
@@ -60,8 +65,9 @@ typedef struct force_array {
 	s_val_t v2;
 } force_array_t;
 
-// The six_axis_array structure shows the layout for the offsets and
-// the full scales.
+/* The six_axis_array structure shows the layout for the offsets and
+ * the full scales.
+ */
 typedef struct six_axis_array {
 	s_val_t fx;
 	s_val_t fy;
@@ -71,18 +77,19 @@ typedef struct six_axis_array {
 	s_val_t mz;
 } six_axis_array_t;
 
-// VECT_BITS
-// The vect_bits structure shows the layout for indicating
-// which axes to use in computing the vectors. Each bit signifies
-// selection of a single axis. The V1x axis bit corresponds to a hex
-// value of 0x0001 and the V2z bit corresponds to a hex value of
-// 0x0020. Example: to specify the axes V1x, V1y, V2x, and V2z the
-// pattern would be 0x002b. Vector 1 defaults to a force vector and
-// vector 2 defaults to a moment vector. It is possible to change one
-// or the other so that two force vectors or two moment vectors are
-// calculated. Setting the changeV1 bit or the changeV2 bit will
-// change that vector to be the opposite of its default. Therefore to
-// have two force vectors, set changeV1 to 1.
+/* VECT_BITS */
+/* The vect_bits structure shows the layout for indicating
+ * which axes to use in computing the vectors. Each bit signifies
+ * selection of a single axis. The V1x axis bit corresponds to a hex
+ * value of 0x0001 and the V2z bit corresponds to a hex value of
+ * 0x0020. Example: to specify the axes V1x, V1y, V2x, and V2z the
+ * pattern would be 0x002b. Vector 1 defaults to a force vector and
+ * vector 2 defaults to a moment vector. It is possible to change one
+ * or the other so that two force vectors or two moment vectors are
+ * calculated. Setting the changeV1 bit or the changeV2 bit will
+ * change that vector to be the opposite of its default. Therefore to
+ * have two force vectors, set changeV1 to 1.
+ */
 
 typedef enum {
 	fx = 0x0001,
@@ -95,13 +102,15 @@ typedef enum {
 	changeV1 = 0x0080
 } vect_bits_t;
 
-// WARNING_BITS
-// The warning_bits structure shows the bit pattern for the warning
-// word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).
-//
-// XX_NEAR_SET
-// The xx_near_sat bits signify that the indicated axis has reached or
-// exceeded the near saturation value.
+/* WARNING_BITS */
+/* The warning_bits structure shows the bit pattern for the warning
+ * word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).
+ */
+
+/*  XX_NEAR_SET */
+/* The xx_near_sat bits signify that the indicated axis has reached or
+ * exceeded the near saturation value.
+ */
 
 typedef enum {
 	fx_near_sat = 0x0001,
@@ -112,59 +121,64 @@ typedef enum {
 	mz_near_sat = 0x0020
 } warning_bits_t;
 
-// ERROR_BITS
-// XX_SAT
-// MEMORY_ERROR
-// SENSOR_CHANGE
-//
-// The error_bits structure shows the bit pattern for the error word.
-// The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The
-// xx_sat bits signify that the indicated axis has reached or exceeded
-// the saturation value. The memory_error bit indicates that a problem
-// was detected in the on-board RAM during the power-up
-// initialization. The sensor_change bit indicates that a sensor other
-// than the one originally plugged in has passed its CRC check. This
-// bit latches, and must be reset by the user.
-//
-// SYSTEM_BUSY
-//
-// The system_busy bit indicates that the JR3 DSP is currently busy
-// and is not calculating force data. This occurs when a new
-// coordinate transformation, or new sensor full scale is set by the
-// user. A very fast system using the force data for feedback might
-// become unstable during the approximately 4 ms needed to accomplish
-// these calculations. This bit will also become active when a new
-// sensor is plugged in and the system needs to recalculate the
-// calibration CRC.
-//
-// CAL_CRC_BAD
-//
-// The cal_crc_bad bit indicates that the calibration CRC has not
-// calculated to zero. CRC is short for cyclic redundancy code. It is
-// a method for determining the integrity of messages in data
-// communication. The calibration data stored inside the sensor is
-// transmitted to the JR3 DSP along with the sensor data. The
-// calibration data has a CRC attached to the end of it, to assist in
-// determining the completeness and integrity of the calibration data
-// received from the sensor. There are two reasons the CRC may not
-// have calculated to zero. The first is that all the calibration data
-// has not yet been received, the second is that the calibration data
-// has been corrupted. A typical sensor transmits the entire contents
-// of its calibration matrix over 30 times a second. Therefore, if
-// this bit is not zero within a couple of seconds after the sensor
-// has been plugged in, there is a problem with the sensor's
-// calibration data.
-//
-// WATCH_DOG
-// WATCH_DOG2
-//
-// The watch_dog and watch_dog2 bits are sensor, not processor, watch
-// dog bits. Watch_dog indicates that the sensor data line seems to be
-// acting correctly, while watch_dog2 indicates that sensor data and
-// clock are being received. It is possible for watch_dog2 to go off
-// while watch_dog does not. This would indicate an improper clock
-// signal, while data is acting correctly. If either watch dog barks,
-// the sensor data is not being received correctly.
+/*  ERROR_BITS */
+/*  XX_SAT */
+/*  MEMORY_ERROR */
+/*  SENSOR_CHANGE */
+
+/* The error_bits structure shows the bit pattern for the error word.
+ * The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The
+ * xx_sat bits signify that the indicated axis has reached or exceeded
+ * the saturation value. The memory_error bit indicates that a problem
+ * was detected in the on-board RAM during the power-up
+ * initialization. The sensor_change bit indicates that a sensor other
+ * than the one originally plugged in has passed its CRC check. This
+ * bit latches, and must be reset by the user.
+ *
+ */
+
+/*  SYSTEM_BUSY */
+
+/* The system_busy bit indicates that the JR3 DSP is currently busy
+ * and is not calculating force data. This occurs when a new
+ * coordinate transformation, or new sensor full scale is set by the
+ * user. A very fast system using the force data for feedback might
+ * become unstable during the approximately 4 ms needed to accomplish
+ * these calculations. This bit will also become active when a new
+ * sensor is plugged in and the system needs to recalculate the
+ * calibration CRC.
+ */
+
+/*  CAL_CRC_BAD */
+
+/* The cal_crc_bad bit indicates that the calibration CRC has not
+ * calculated to zero. CRC is short for cyclic redundancy code. It is
+ * a method for determining the integrity of messages in data
+ * communication. The calibration data stored inside the sensor is
+ * transmitted to the JR3 DSP along with the sensor data. The
+ * calibration data has a CRC attached to the end of it, to assist in
+ * determining the completeness and integrity of the calibration data
+ * received from the sensor. There are two reasons the CRC may not
+ * have calculated to zero. The first is that all the calibration data
+ * has not yet been received, the second is that the calibration data
+ * has been corrupted. A typical sensor transmits the entire contents
+ * of its calibration matrix over 30 times a second. Therefore, if
+ * this bit is not zero within a couple of seconds after the sensor
+ * has been plugged in, there is a problem with the sensor's
+ * calibration data.
+ */
+
+/* WATCH_DOG */
+/* WATCH_DOG2 */
+
+/* The watch_dog and watch_dog2 bits are sensor, not processor, watch
+ * dog bits. Watch_dog indicates that the sensor data line seems to be
+ * acting correctly, while watch_dog2 indicates that sensor data and
+ * clock are being received. It is possible for watch_dog2 to go off
+ * while watch_dog does not. This would indicate an improper clock
+ * signal, while data is acting correctly. If either watch dog barks,
+ * the sensor data is not being received correctly.
+ */
 
 typedef enum {
 	fx_sat = 0x0001,
@@ -181,29 +195,34 @@ typedef enum {
 	watch_dog = 0x8000
 } error_bits_t;
 
-// THRESH_STRUCT
-// This structure shows the layout for a single threshold packet inside of a
-// load envelope. Each load envelope can contain several threshold structures.
-// 1. data_address contains the address of the data for that threshold. This
-//    includes filtered, unfiltered, raw, rate, counters, error and warning data
-// 2. threshold is the is the value at which, if data is above or below, the
-//    bits will be set ... (pag.24).
-// 3. bit_pattern contains the bits that will be set if the threshold value is
-//    met or exceeded.
+/*  THRESH_STRUCT */
+
+/* This structure shows the layout for a single threshold packet inside of a
+ * load envelope. Each load envelope can contain several threshold structures.
+ * 1. data_address contains the address of the data for that threshold. This
+ *    includes filtered, unfiltered, raw, rate, counters, error and warning data
+ * 2. threshold is the is the value at which, if data is above or below, the
+ *    bits will be set ... (pag.24).
+ * 3. bit_pattern contains the bits that will be set if the threshold value is
+ *    met or exceeded.
+ */
+
 typedef struct thresh_struct {
 	s32 data_address;
 	s32 threshold;
 	s32 bit_pattern;
 } thresh_struct;
 
-// LE_STRUCT
-// Layout of a load enveloped packet. Four thresholds are showed ... for more
-// see manual (pag.25)
-// 1. latch_bits is a bit pattern that show which bits the user wants to latch.
-//    The latched bits will not be reset once the threshold which set them is
-//    no longer true. In that case the user must reset them using the reset_bit
-//    command.
-// 2. number_of_xx_thresholds specify how many GE/LE threshold there are.
+/*  LE_STRUCT */
+
+/* Layout of a load enveloped packet. Four thresholds are showed ... for more
+ * see manual (pag.25)
+ * 1. latch_bits is a bit pattern that show which bits the user wants to latch.
+ *    The latched bits will not be reset once the threshold which set them is
+ *    no longer true. In that case the user must reset them using the reset_bit
+ *    command.
+ * 2. number_of_xx_thresholds specify how many GE/LE threshold there are.
+ */
 typedef struct {
 	s32 latch_bits;
 	s32 number_of_ge_thresholds;
@@ -212,17 +231,19 @@ typedef struct {
 	s32 reserved;
 } le_struct_t;
 
-// LINK_TYPES
-// Link types is an enumerated value showing the different possible transform
-// link types.
-// 0 - end transform packet
-// 1 - translate along X axis (TX)
-// 2 - translate along Y axis (TY)
-// 3 - translate along Z axis (TZ)
-// 4 - rotate about X axis (RX)
-// 5 - rotate about Y axis (RY)
-// 6 - rotate about Z axis (RZ)
-// 7 - negate all axes (NEG)
+/*  LINK_TYPES */
+/* Link types is an enumerated value showing the different possible transform
+ * link types.
+ * 0 - end transform packet
+ * 1 - translate along X axis (TX)
+ * 2 - translate along Y axis (TY)
+ * 3 - translate along Z axis (TZ)
+ * 4 - rotate about X axis (RX)
+ * 5 - rotate about Y axis (RY)
+ * 6 - rotate about Z axis (RZ)
+ * 7 - negate all axes (NEG)
+ */
+
 typedef enum link_types {
 	end_x_form,
 	tx,
@@ -234,8 +255,8 @@ typedef enum link_types {
 	neg
 } link_types;
 
-// TRANSFORM
-// Structure used to describe a transform.
+/*  TRANSFORM */
+/*  Structure used to describe a transform. */
 typedef struct {
 	struct {
 		u_val_t link_type;
@@ -243,153 +264,163 @@ typedef struct {
 	} link[8];
 } intern_transform_t;
 
-// JR3 force/torque sensor data definition. For more information see sensor and
-// hardware manuals.
+/*  JR3 force/torque sensor data definition. For more information see sensor and */
+/*  hardware manuals. */
 
 typedef struct force_sensor_data {
-	// Raw_channels is the area used to store the raw data coming from
-	// the sensor.
+	/*  Raw_channels is the area used to store the raw data coming from */
+	/*  the sensor. */
 
 	raw_channel_t raw_channels[16];	/* offset 0x0000 */
 
-	// Copyright is a null terminated ASCII string containing the JR3
-	// copyright notice.
+	/*  Copyright is a null terminated ASCII string containing the JR3 */
+	/*  copyright notice. */
 
 	u_val_t copyright[0x0018];	/* offset 0x0040 */
 	s_val_t reserved1[0x0008];	/* offset 0x0058 */
 
-	// Shunts contains the sensor shunt readings. Some JR3 sensors have
-	//  the ability to have their gains adjusted. This allows the
-	//  hardware full scales to be adjusted to potentially allow
-	//  better resolution or dynamic range. For sensors that have
-	//  this ability, the gain of each sensor channel is measured at
-	//  the time of calibration using a shunt resistor. The shunt
-	//  resistor is placed across one arm of the resistor bridge, and
-	//  the resulting change in the output of that channel is
-	//  measured. This measurement is called the shunt reading, and
-	//  is recorded here. If the user has changed the gain of the //
-	// sensor, and made new shunt measurements, those shunt
-	//  measurements can be placed here. The JR3 DSP will then scale
-	//  the calibration matrix such so that the gains are again
-	//  proper for the indicated shunt readings. If shunts is 0, then
-	//  the sensor cannot have its gain changed. For details on
-	//  changing the sensor gain, and making shunts readings, please
-	//  see the sensor manual. To make these values take effect the
-	//  user must call either command (5) use transform # (pg. 33) or
-	//  command (10) set new full scales (pg. 38).
+	/* Shunts contains the sensor shunt readings. Some JR3 sensors have
+	 * the ability to have their gains adjusted. This allows the
+	 * hardware full scales to be adjusted to potentially allow
+	 * better resolution or dynamic range. For sensors that have
+	 * this ability, the gain of each sensor channel is measured at
+	 * the time of calibration using a shunt resistor. The shunt
+	 * resistor is placed across one arm of the resistor bridge, and
+	 * the resulting change in the output of that channel is
+	 * measured. This measurement is called the shunt reading, and
+	 * is recorded here. If the user has changed the gain of the //
+	 * sensor, and made new shunt measurements, those shunt
+	 * measurements can be placed here. The JR3 DSP will then scale
+	 * the calibration matrix such so that the gains are again
+	 * proper for the indicated shunt readings. If shunts is 0, then
+	 * the sensor cannot have its gain changed. For details on
+	 * changing the sensor gain, and making shunts readings, please
+	 * see the sensor manual. To make these values take effect the
+	 * user must call either command (5) use transform # (pg. 33) or
+	 * command (10) set new full scales (pg. 38).
+	 */
 
 	six_axis_array_t shunts;	/* offset 0x0060 */
 	s32 reserved2[2];	/* offset 0x0066 */
 
-	// Default_FS contains the full scale that is used if the user does
-	// not set a full scale.
+	/* Default_FS contains the full scale that is used if the user does */
+	/* not set a full scale. */
 
 	six_axis_array_t default_FS;	/* offset 0x0068 */
 	s_val_t reserved3;	/* offset 0x006e */
 
-	// Load_envelope_num is the load envelope number that is currently
-	// in use. This value is set by the user after one of the load
-	// envelopes has been initialized.
+	/* Load_envelope_num is the load envelope number that is currently
+	 * in use. This value is set by the user after one of the load
+	 * envelopes has been initialized.
+	 */
 
 	s_val_t load_envelope_num;	/* offset 0x006f */
 
-	// Min_full_scale is the recommend minimum full scale.
-	//
-	// These values in conjunction with max_full_scale (pg. 9) helps
-	// determine the appropriate value for setting the full scales. The
-	// software allows the user to set the sensor full scale to an
-	// arbitrary value. But setting the full scales has some hazards. If
-	// the full scale is set too low, the data will saturate
-	// prematurely, and dynamic range will be lost. If the full scale is
-	// set too high, then resolution is lost as the data is shifted to
-	// the right and the least significant bits are lost. Therefore the
-	// maximum full scale is the maximum value at which no resolution is
-	// lost, and the minimum full scale is the value at which the data
-	// will not saturate prematurely. These values are calculated
-	// whenever a new coordinate transformation is calculated. It is
-	// possible for the recommended maximum to be less than the
-	// recommended minimum. This comes about primarily when using
-	// coordinate translations. If this is the case, it means that any
-	// full scale selection will be a compromise between dynamic range
-	// and resolution. It is usually recommended to compromise in favor
-	// of resolution which means that the recommend maximum full scale
-	// should be chosen.
-	//
-	// WARNING: Be sure that the full scale is no less than 0.4% of the
-	// recommended minimum full scale. Full scales below this value will
-	// cause erroneous results.
+	/* Min_full_scale is the recommend minimum full scale. */
+
+	/* These values in conjunction with max_full_scale (pg. 9) helps
+	 * determine the appropriate value for setting the full scales. The
+	 * software allows the user to set the sensor full scale to an
+	 * arbitrary value. But setting the full scales has some hazards. If
+	 * the full scale is set too low, the data will saturate
+	 * prematurely, and dynamic range will be lost. If the full scale is
+	 * set too high, then resolution is lost as the data is shifted to
+	 * the right and the least significant bits are lost. Therefore the
+	 * maximum full scale is the maximum value at which no resolution is
+	 * lost, and the minimum full scale is the value at which the data
+	 * will not saturate prematurely. These values are calculated
+	 * whenever a new coordinate transformation is calculated. It is
+	 * possible for the recommended maximum to be less than the
+	 * recommended minimum. This comes about primarily when using
+	 * coordinate translations. If this is the case, it means that any
+	 * full scale selection will be a compromise between dynamic range
+	 * and resolution. It is usually recommended to compromise in favor
+	 * of resolution which means that the recommend maximum full scale
+	 * should be chosen.
+	 *
+	 * WARNING: Be sure that the full scale is no less than 0.4% of the
+	 * recommended minimum full scale. Full scales below this value will
+	 * cause erroneous results.
+	 */
 
 	six_axis_array_t min_full_scale;	/* offset 0x0070 */
 	s_val_t reserved4;	/* offset 0x0076 */
 
-	// Transform_num is the transform number that is currently in use.
-	// This value is set by the JR3 DSP after the user has used command
-	// (5) use transform # (pg. 33).
+	/* Transform_num is the transform number that is currently in use.
+	 * This value is set by the JR3 DSP after the user has used command
+	 * (5) use transform # (pg. 33).
+	 */
 
 	s_val_t transform_num;	/* offset 0x0077 */
 
-	// Max_full_scale is the recommended maximum full scale. See
-	// min_full_scale (pg. 9) for more details.
+	/*  Max_full_scale is the recommended maximum full scale. See */
+	/*  min_full_scale (pg. 9) for more details. */
 
 	six_axis_array_t max_full_scale;	/* offset 0x0078 */
 	s_val_t reserved5;	/* offset 0x007e */
 
-	// Peak_address is the address of the data which will be monitored
-	// by the peak routine. This value is set by the user. The peak
-	// routine will monitor any 8 contiguous addresses for peak values.
-	// (ex. to watch filter3 data for peaks, set this value to 0x00a8).
+	/* Peak_address is the address of the data which will be monitored
+	 * by the peak routine. This value is set by the user. The peak
+	 * routine will monitor any 8 contiguous addresses for peak values.
+	 * (ex. to watch filter3 data for peaks, set this value to 0x00a8).
+	 */
 
 	s_val_t peak_address;	/* offset 0x007f */
 
-	// Full_scale is the sensor full scales which are currently in use.
-	// Decoupled and filtered data is scaled so that +/- 16384 is equal
-	// to the full scales. The engineering units used are indicated by
-	// the units value discussed on page 16. The full scales for Fx, Fy,
-	// Fz, Mx, My and Mz can be written by the user prior to calling
-	// command (10) set new full scales (pg. 38). The full scales for V1
-	// and V2 are set whenever the full scales are changed or when the
-	// axes used to calculate the vectors are changed. The full scale of
-	// V1 and V2 will always be equal to the largest full scale of the
-	// axes used for each vector respectively.
+	/* Full_scale is the sensor full scales which are currently in use.
+	 * Decoupled and filtered data is scaled so that +/- 16384 is equal
+	 * to the full scales. The engineering units used are indicated by
+	 * the units value discussed on page 16. The full scales for Fx, Fy,
+	 * Fz, Mx, My and Mz can be written by the user prior to calling
+	 * command (10) set new full scales (pg. 38). The full scales for V1
+	 * and V2 are set whenever the full scales are changed or when the
+	 * axes used to calculate the vectors are changed. The full scale of
+	 * V1 and V2 will always be equal to the largest full scale of the
+	 * axes used for each vector respectively.
+	 */
 
 	force_array_t full_scale;	/* offset 0x0080 */
 
-	// Offsets contains the sensor offsets. These values are subtracted from
-	// the sensor data to obtain the decoupled data. The offsets are set a
-	// few seconds (< 10) after the calibration data has been received.
-	// They are set so that the output data will be zero. These values
-	// can be written as well as read. The JR3 DSP will use the values
-	// written here within 2 ms of being written. To set future
-	// decoupled data to zero, add these values to the current decoupled
-	// data values and place the sum here. The JR3 DSP will change these
-	// values when a new transform is applied. So if the offsets are
-	// such that FX is 5 and all other values are zero, after rotating
-	// about Z by 90 degrees, FY would be 5 and all others would be zero.
+	/* Offsets contains the sensor offsets. These values are subtracted from
+	 * the sensor data to obtain the decoupled data. The offsets are set a
+	 * few seconds (< 10) after the calibration data has been received.
+	 * They are set so that the output data will be zero. These values
+	 * can be written as well as read. The JR3 DSP will use the values
+	 * written here within 2 ms of being written. To set future
+	 * decoupled data to zero, add these values to the current decoupled
+	 * data values and place the sum here. The JR3 DSP will change these
+	 * values when a new transform is applied. So if the offsets are
+	 * such that FX is 5 and all other values are zero, after rotating
+	 * about Z by 90 degrees, FY would be 5 and all others would be zero.
+	 */
 
 	six_axis_array_t offsets;	/* offset 0x0088 */
 
-	// Offset_num is the number of the offset currently in use. This
-	// value is set by the JR3 DSP after the user has executed the use
-	// offset # command (pg. 34). It can vary between 0 and 15.
+	/* Offset_num is the number of the offset currently in use. This
+	 * value is set by the JR3 DSP after the user has executed the use
+	 * offset # command (pg. 34). It can vary between 0 and 15.
+	 */
 
 	s_val_t offset_num;	/* offset 0x008e */
 
-	// Vect_axes is a bit map showing which of the axes are being used
-	// in the vector calculations. This value is set by the JR3 DSP
-	// after the user has executed the set vector axes command (pg. 37).
+	/* Vect_axes is a bit map showing which of the axes are being used
+	 * in the vector calculations. This value is set by the JR3 DSP
+	 * after the user has executed the set vector axes command (pg. 37).
+	 */
 
 	u_val_t vect_axes;	/* offset 0x008f */
 
-	// Filter0 is the decoupled, unfiltered data from the JR3 sensor.
-	// This data has had the offsets removed.
-	//
-	// These force_arrays hold the filtered data. The decoupled data is
-	// passed through cascaded low pass filters. Each succeeding filter
-	// has a cutoff frequency of 1/4 of the preceding filter. The cutoff
-	// frequency of filter1 is 1/16 of the sample rate from the sensor.
-	// For a typical sensor with a sample rate of 8 kHz, the cutoff
-	// frequency of filter1 would be 500 Hz. The following filters would
-	// cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.
+	/* Filter0 is the decoupled, unfiltered data from the JR3 sensor.
+	 * This data has had the offsets removed.
+	 *
+	 * These force_arrays hold the filtered data. The decoupled data is
+	 * passed through cascaded low pass filters. Each succeeding filter
+	 * has a cutoff frequency of 1/4 of the preceding filter. The cutoff
+	 * frequency of filter1 is 1/16 of the sample rate from the sensor.
+	 * For a typical sensor with a sample rate of 8 kHz, the cutoff
+	 * frequency of filter1 would be 500 Hz. The following filters would
+	 * cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.
+	 */
 
 	struct force_array filter[7];	/* offset 0x0090,
 					   offset 0x0098,
@@ -399,89 +430,95 @@ typedef struct force_sensor_data {
 					   offset 0x00b8 ,
 					   offset 0x00c0 */
 
-	// Rate_data is the calculated rate data. It is a first derivative
-	// calculation. It is calculated at a frequency specified by the
-	// variable rate_divisor (pg. 12). The data on which the rate is
-	// calculated is specified by the variable rate_address (pg. 12).
+	/* Rate_data is the calculated rate data. It is a first derivative
+	 * calculation. It is calculated at a frequency specified by the
+	 * variable rate_divisor (pg. 12). The data on which the rate is
+	 * calculated is specified by the variable rate_address (pg. 12).
+	 */
 
 	force_array_t rate_data;	/* offset 0x00c8 */
 
-	// Minimum_data & maximum_data are the minimum and maximum (peak)
-	// data values. The JR3 DSP can monitor any 8 contiguous data items
-	// for minimums and maximums at full sensor bandwidth. This area is
-	// only updated at user request. This is done so that the user does
-	// not miss any peaks. To read the data, use either the read peaks
-	// command (pg. 40), or the read and reset peaks command (pg. 39).
-	// The address of the data to watch for peaks is stored in the
-	// variable peak_address (pg. 10). Peak data is lost when executing
-	// a coordinate transformation or a full scale change. Peak data is
-	// also lost when plugging in a new sensor.
+	/* Minimum_data & maximum_data are the minimum and maximum (peak)
+	 * data values. The JR3 DSP can monitor any 8 contiguous data items
+	 * for minimums and maximums at full sensor bandwidth. This area is
+	 * only updated at user request. This is done so that the user does
+	 * not miss any peaks. To read the data, use either the read peaks
+	 * command (pg. 40), or the read and reset peaks command (pg. 39).
+	 * The address of the data to watch for peaks is stored in the
+	 * variable peak_address (pg. 10). Peak data is lost when executing
+	 * a coordinate transformation or a full scale change. Peak data is
+	 * also lost when plugging in a new sensor.
+	 */
 
 	force_array_t minimum_data;	/* offset 0x00d0 */
 	force_array_t maximum_data;	/* offset 0x00d8 */
 
-	// Near_sat_value & sat_value contain the value used to determine if
-	// the raw sensor is saturated. Because of decoupling and offset
-	// removal, it is difficult to tell from the processed data if the
-	// sensor is saturated. These values, in conjunction with the error
-	// and warning words (pg. 14), provide this critical information.
-	// These two values may be set by the host processor. These values
-	// are positive signed values, since the saturation logic uses the
-	// absolute values of the raw data. The near_sat_value defaults to
-	// approximately 80% of the ADC's full scale, which is 26214, while
-	// sat_value defaults to the ADC's full scale:
-	//
-	//   sat_value = 32768 - 2^(16 - ADC bits)
+	/* Near_sat_value & sat_value contain the value used to determine if
+	 * the raw sensor is saturated. Because of decoupling and offset
+	 * removal, it is difficult to tell from the processed data if the
+	 * sensor is saturated. These values, in conjunction with the error
+	 * and warning words (pg. 14), provide this critical information.
+	 * These two values may be set by the host processor. These values
+	 * are positive signed values, since the saturation logic uses the
+	 * absolute values of the raw data. The near_sat_value defaults to
+	 * approximately 80% of the ADC's full scale, which is 26214, while
+	 * sat_value defaults to the ADC's full scale:
+	 *
+	 *   sat_value = 32768 - 2^(16 - ADC bits)
+	 */
 
 	s_val_t near_sat_value;	/* offset 0x00e0 */
 	s_val_t sat_value;	/* offset 0x00e1 */
 
-	// Rate_address, rate_divisor & rate_count contain the data used to
-	// control the calculations of the rates. Rate_address is the
-	// address of the data used for the rate calculation. The JR3 DSP
-	// will calculate rates for any 8 contiguous values (ex. to
-	// calculate rates for filter3 data set rate_address to 0x00a8).
-	// Rate_divisor is how often the rate is calculated. If rate_divisor
-	// is 1, the rates are calculated at full sensor bandwidth. If
-	// rate_divisor is 200, rates are calculated every 200 samples.
-	// Rate_divisor can be any value between 1 and 65536. Set
-	// rate_divisor to 0 to calculate rates every 65536 samples.
-	// Rate_count starts at zero and counts until it equals
-	// rate_divisor, at which point the rates are calculated, and
-	// rate_count is reset to 0. When setting a new rate divisor, it is
-	// a good idea to set rate_count to one less than rate divisor. This
-	// will minimize the time necessary to start the rate calculations.
+	/* Rate_address, rate_divisor & rate_count contain the data used to
+	 * control the calculations of the rates. Rate_address is the
+	 * address of the data used for the rate calculation. The JR3 DSP
+	 * will calculate rates for any 8 contiguous values (ex. to
+	 * calculate rates for filter3 data set rate_address to 0x00a8).
+	 * Rate_divisor is how often the rate is calculated. If rate_divisor
+	 * is 1, the rates are calculated at full sensor bandwidth. If
+	 * rate_divisor is 200, rates are calculated every 200 samples.
+	 * Rate_divisor can be any value between 1 and 65536. Set
+	 * rate_divisor to 0 to calculate rates every 65536 samples.
+	 * Rate_count starts at zero and counts until it equals
+	 * rate_divisor, at which point the rates are calculated, and
+	 * rate_count is reset to 0. When setting a new rate divisor, it is
+	 * a good idea to set rate_count to one less than rate divisor. This
+	 * will minimize the time necessary to start the rate calculations.
+	 */
 
 	s_val_t rate_address;	/* offset 0x00e2 */
 	u_val_t rate_divisor;	/* offset 0x00e3 */
 	u_val_t rate_count;	/* offset 0x00e4 */
 
-	// Command_word2 through command_word0 are the locations used to
-	// send commands to the JR3 DSP. Their usage varies with the command
-	// and is detailed later in the Command Definitions section (pg.
-	// 29). In general the user places values into various memory
-	// locations, and then places the command word into command_word0.
-	// The JR3 DSP will process the command and place a 0 into
-	// command_word0 to indicate successful completion. Alternatively
-	// the JR3 DSP will place a negative number into command_word0 to
-	// indicate an error condition. Please note the command locations
-	// are numbered backwards. (I.E. command_word2 comes before
-	// command_word1).
+	/* Command_word2 through command_word0 are the locations used to
+	 * send commands to the JR3 DSP. Their usage varies with the command
+	 * and is detailed later in the Command Definitions section (pg.
+	 * 29). In general the user places values into various memory
+	 * locations, and then places the command word into command_word0.
+	 * The JR3 DSP will process the command and place a 0 into
+	 * command_word0 to indicate successful completion. Alternatively
+	 * the JR3 DSP will place a negative number into command_word0 to
+	 * indicate an error condition. Please note the command locations
+	 * are numbered backwards. (I.E. command_word2 comes before
+	 * command_word1).
+	 */
 
 	s_val_t command_word2;	/* offset 0x00e5 */
 	s_val_t command_word1;	/* offset 0x00e6 */
 	s_val_t command_word0;	/* offset 0x00e7 */
 
-	// Count1 through count6 are unsigned counters which are incremented
-	// every time the matching filters are calculated. Filter1 is
-	// calculated at the sensor data bandwidth. So this counter would
-	// increment at 8 kHz for a typical sensor. The rest of the counters
-	// are incremented at 1/4 the interval of the counter immediately
-	// preceding it, so they would count at 2 kHz, 500 Hz, 125 Hz etc.
-	// These counters can be used to wait for data. Each time the
-	// counter changes, the corresponding data set can be sampled, and
-	// this will insure that the user gets each sample, once, and only
-	// once.
+	/* Count1 through count6 are unsigned counters which are incremented
+	 * every time the matching filters are calculated. Filter1 is
+	 * calculated at the sensor data bandwidth. So this counter would
+	 * increment at 8 kHz for a typical sensor. The rest of the counters
+	 * are incremented at 1/4 the interval of the counter immediately
+	 * preceding it, so they would count at 2 kHz, 500 Hz, 125 Hz etc.
+	 * These counters can be used to wait for data. Each time the
+	 * counter changes, the corresponding data set can be sampled, and
+	 * this will insure that the user gets each sample, once, and only
+	 * once.
+	 */
 
 	u_val_t count1;		/* offset 0x00e8 */
 	u_val_t count2;		/* offset 0x00e9 */
@@ -490,145 +527,158 @@ typedef struct force_sensor_data {
 	u_val_t count5;		/* offset 0x00ec */
 	u_val_t count6;		/* offset 0x00ed */
 
-	// Error_count is a running count of data reception errors. If this
-	// counter is changing rapidly, it probably indicates a bad sensor
-	// cable connection or other hardware problem. In most installations
-	// error_count should not change at all. But it is possible in an
-	// extremely noisy environment to experience occasional errors even
-	// without a hardware problem. If the sensor is well grounded, this
-	// is probably unavoidable in these environments. On the occasions
-	// where this counter counts a bad sample, that sample is ignored.
+	/* Error_count is a running count of data reception errors. If this
+	 * counter is changing rapidly, it probably indicates a bad sensor
+	 * cable connection or other hardware problem. In most installations
+	 * error_count should not change at all. But it is possible in an
+	 * extremely noisy environment to experience occasional errors even
+	 * without a hardware problem. If the sensor is well grounded, this
+	 * is probably unavoidable in these environments. On the occasions
+	 * where this counter counts a bad sample, that sample is ignored.
+	 */
 
 	u_val_t error_count;	/* offset 0x00ee */
 
-	// Count_x is a counter which is incremented every time the JR3 DSP
-	// searches its job queues and finds nothing to do. It indicates the
-	// amount of idle time the JR3 DSP has available. It can also be
-	// used to determine if the JR3 DSP is alive. See the Performance
-	// Issues section on pg. 49 for more details.
+	/* Count_x is a counter which is incremented every time the JR3 DSP
+	 * searches its job queues and finds nothing to do. It indicates the
+	 * amount of idle time the JR3 DSP has available. It can also be
+	 * used to determine if the JR3 DSP is alive. See the Performance
+	 * Issues section on pg. 49 for more details.
+	 */
 
 	u_val_t count_x;	/* offset 0x00ef */
 
-	// Warnings & errors contain the warning and error bits
-	// respectively. The format of these two words is discussed on page
-	// 21 under the headings warnings_bits and error_bits.
+	/* Warnings & errors contain the warning and error bits
+	 * respectively. The format of these two words is discussed on page
+	 * 21 under the headings warnings_bits and error_bits.
+	 */
 
 	u_val_t warnings;	/* offset 0x00f0 */
 	u_val_t errors;		/* offset 0x00f1 */
 
-	// Threshold_bits is a word containing the bits that are set by the
-	// load envelopes. See load_envelopes (pg. 17) and thresh_struct
-	// (pg. 23) for more details.
+	/* Threshold_bits is a word containing the bits that are set by the
+	 * load envelopes. See load_envelopes (pg. 17) and thresh_struct
+	 * (pg. 23) for more details.
+	 */
 
 	s_val_t threshold_bits;	/* offset 0x00f2 */
 
-	// Last_crc is the value that shows the actual calculated CRC. CRC
-	// is short for cyclic redundancy code. It should be zero. See the
-	// description for cal_crc_bad (pg. 21) for more information.
+	/* Last_crc is the value that shows the actual calculated CRC. CRC
+	 * is short for cyclic redundancy code. It should be zero. See the
+	 * description for cal_crc_bad (pg. 21) for more information.
+	 */
 
 	s_val_t last_CRC;	/* offset 0x00f3 */
 
-	// EEProm_ver_no contains the version number of the sensor EEProm.
-	// EEProm version numbers can vary between 0 and 255.
-	// Software_ver_no contains the software version number. Version
-	// 3.02 would be stored as 302.
+	/* EEProm_ver_no contains the version number of the sensor EEProm.
+	 * EEProm version numbers can vary between 0 and 255.
+	 * Software_ver_no contains the software version number. Version
+	 * 3.02 would be stored as 302.
+	 */
 
 	s_val_t eeprom_ver_no;	/* offset 0x00f4 */
 	s_val_t software_ver_no;	/* offset 0x00f5 */
 
-	// Software_day & software_year are the release date of the software
-	// the JR3 DSP is currently running. Day is the day of the year,
-	// with January 1 being 1, and December 31, being 365 for non leap
-	// years.
+	/* Software_day & software_year are the release date of the software
+	 * the JR3 DSP is currently running. Day is the day of the year,
+	 * with January 1 being 1, and December 31, being 365 for non leap
+	 * years.
+	 */
 
 	s_val_t software_day;	/* offset 0x00f6 */
 	s_val_t software_year;	/* offset 0x00f7 */
 
-	// Serial_no & model_no are the two values which uniquely identify a
-	// sensor. This model number does not directly correspond to the JR3
-	// model number, but it will provide a unique identifier for
-	// different sensor configurations.
+	/* Serial_no & model_no are the two values which uniquely identify a
+	 * sensor. This model number does not directly correspond to the JR3
+	 * model number, but it will provide a unique identifier for
+	 * different sensor configurations.
+	 */
 
 	u_val_t serial_no;	/* offset 0x00f8 */
 	u_val_t model_no;	/* offset 0x00f9 */
 
-	// Cal_day & cal_year are the sensor calibration date. Day is the
-	// day of the year, with January 1 being 1, and December 31, being
-	// 366 for leap years.
+	/* Cal_day & cal_year are the sensor calibration date. Day is the
+	 * day of the year, with January 1 being 1, and December 31, being
+	 * 366 for leap years.
+	 */
 
 	s_val_t cal_day;	/* offset 0x00fa */
 	s_val_t cal_year;	/* offset 0x00fb */
 
-	// Units is an enumerated read only value defining the engineering
-	// units used in the sensor full scale. The meanings of particular
-	// values are discussed in the section detailing the force_units
-	// structure on page 22. The engineering units are setto customer
-	// specifications during sensor manufacture and cannot be changed by
-	// writing to Units.
-	//
-	// Bits contains the number of bits of resolution of the ADC
-	// currently in use.
-	//
-	// Channels is a bit field showing which channels the current sensor
-	// is capable of sending. If bit 0 is active, this sensor can send
-	// channel 0, if bit 13 is active, this sensor can send channel 13,
-	// etc. This bit can be active, even if the sensor is not currently
-	// sending this channel. Some sensors are configurable as to which
-	// channels to send, and this field only contains information on the
-	// channels available to send, not on the current configuration. To
-	// find which channels are currently being sent, monitor the
-	// Raw_time fields (pg. 19) in the raw_channels array (pg. 7). If
-	// the time is changing periodically, then that channel is being
-	// received.
+	/* Units is an enumerated read only value defining the engineering
+	 * units used in the sensor full scale. The meanings of particular
+	 * values are discussed in the section detailing the force_units
+	 * structure on page 22. The engineering units are setto customer
+	 * specifications during sensor manufacture and cannot be changed by
+	 * writing to Units.
+	 *
+	 * Bits contains the number of bits of resolution of the ADC
+	 * currently in use.
+	 *
+	 * Channels is a bit field showing which channels the current sensor
+	 * is capable of sending. If bit 0 is active, this sensor can send
+	 * channel 0, if bit 13 is active, this sensor can send channel 13,
+	 * etc. This bit can be active, even if the sensor is not currently
+	 * sending this channel. Some sensors are configurable as to which
+	 * channels to send, and this field only contains information on the
+	 * channels available to send, not on the current configuration. To
+	 * find which channels are currently being sent, monitor the
+	 * Raw_time fields (pg. 19) in the raw_channels array (pg. 7). If
+	 * the time is changing periodically, then that channel is being
+	 * received.
+	 */
 
 	u_val_t units;		/* offset 0x00fc */
 	s_val_t bits;		/* offset 0x00fd */
 	s_val_t channels;	/* offset 0x00fe */
 
-	// Thickness specifies the overall thickness of the sensor from
-	// flange to flange. The engineering units for this value are
-	// contained in units (pg. 16). The sensor calibration is relative
-	// to the center of the sensor. This value allows easy coordinate
-	// transformation from the center of the sensor to either flange.
+	/* Thickness specifies the overall thickness of the sensor from
+	 * flange to flange. The engineering units for this value are
+	 * contained in units (pg. 16). The sensor calibration is relative
+	 * to the center of the sensor. This value allows easy coordinate
+	 * transformation from the center of the sensor to either flange.
+	 */
 
 	s_val_t thickness;	/* offset 0x00ff */
 
-	// Load_envelopes is a table containing the load envelope
-	// descriptions. There are 16 possible load envelope slots in the
-	// table. The slots are on 16 word boundaries and are numbered 0-15.
-	// Each load envelope needs to start at the beginning of a slot but
-	// need not be fully contained in that slot. That is to say that a
-	// single load envelope can be larger than a single slot. The
-	// software has been tested and ran satisfactorily with 50
-	// thresholds active. A single load envelope this large would take
-	// up 5 of the 16 slots. The load envelope data is laid out in an
-	// order that is most efficient for the JR3 DSP. The structure is
-	// detailed later in the section showing the definition of the
-	// le_struct structure (pg. 23).
+	/* Load_envelopes is a table containing the load envelope
+	 * descriptions. There are 16 possible load envelope slots in the
+	 * table. The slots are on 16 word boundaries and are numbered 0-15.
+	 * Each load envelope needs to start at the beginning of a slot but
+	 * need not be fully contained in that slot. That is to say that a
+	 * single load envelope can be larger than a single slot. The
+	 * software has been tested and ran satisfactorily with 50
+	 * thresholds active. A single load envelope this large would take
+	 * up 5 of the 16 slots. The load envelope data is laid out in an
+	 * order that is most efficient for the JR3 DSP. The structure is
+	 * detailed later in the section showing the definition of the
+	 * le_struct structure (pg. 23).
+	 */
 
 	le_struct_t load_envelopes[0x10];	/* offset 0x0100 */
 
-	// Transforms is a table containing the transform descriptions.
-	// There are 16 possible transform slots in the table. The slots are
-	// on 16 word boundaries and are numbered 0-15. Each transform needs
-	// to start at the beginning of a slot but need not be fully
-	// contained in that slot. That is to say that a single transform
-	// can be larger than a single slot. A transform is 2 * no of links
-	// + 1 words in length. So a single slot can contain a transform
-	// with 7 links. Two slots can contain a transform that is 15 links.
-	// The layout is detailed later in the section showing the
-	// definition of the transform structure (pg. 26).
+	/* Transforms is a table containing the transform descriptions.
+	 * There are 16 possible transform slots in the table. The slots are
+	 * on 16 word boundaries and are numbered 0-15. Each transform needs
+	 * to start at the beginning of a slot but need not be fully
+	 * contained in that slot. That is to say that a single transform
+	 * can be larger than a single slot. A transform is 2 * no of links
+	 * + 1 words in length. So a single slot can contain a transform
+	 * with 7 links. Two slots can contain a transform that is 15 links.
+	 * The layout is detailed later in the section showing the
+	 * definition of the transform structure (pg. 26).
+	 */
 
 	intern_transform_t transforms[0x10];	/* offset 0x0200 */
 } jr3_channel_t;
 
 typedef struct {
 	struct {
-		u_val_t program_low[0x4000];	// 0x00000 - 0x10000
-		jr3_channel_t data;	// 0x10000 - 0x10c00
-		char pad2[0x30000 - 0x00c00];	// 0x10c00 - 0x40000
-		u_val_t program_high[0x8000];	// 0x40000 - 0x60000
-		u32 reset;	// 0x60000 - 0x60004
-		char pad3[0x20000 - 0x00004];	// 0x60004 - 0x80000
+		u_val_t program_low[0x4000];	/*  0x00000 - 0x10000 */
+		jr3_channel_t data;	/*  0x10000 - 0x10c00 */
+		char pad2[0x30000 - 0x00c00];	/*  0x10c00 - 0x40000 */
+		u_val_t program_high[0x8000];	/*  0x40000 - 0x60000 */
+		u32 reset;	/*  0x60000 - 0x60004 */
+		char pad3[0x20000 - 0x00004];	/*  0x60004 - 0x80000 */
 	} channel[4];
 } jr3_t;

commit 07b509e6584a55263b6bb484eca3edd5e52361d0
Author: Anders Blomdell <anders.blomdell@control.lth.se>
Date:   Thu Feb 12 16:07:16 2009 -0800

    Staging: comedi: add jr3_pci driver
    
    hardware driver for JR3/PCI force sensor board
    
    From: Anders Blomdell <anders.blomdell@control.lth.se>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/jr3_pci.h b/drivers/staging/comedi/drivers/jr3_pci.h
new file mode 100644
index 000000000000..286cdaadfa1c
--- /dev/null
+++ b/drivers/staging/comedi/drivers/jr3_pci.h
@@ -0,0 +1,634 @@
+// Helper types to take care of the fact that the DSP card memory
+//   is 16 bits, but aligned on a 32 bit PCI boundary
+typedef u32 u_val_t;
+
+typedef s32 s_val_t;
+
+static inline u16 get_u16(volatile const u_val_t * p)
+{
+	return (u16) readl(p);
+}
+
+static inline void set_u16(volatile u_val_t * p, u16 val)
+{
+	writel(val, p);
+}
+
+static inline s16 get_s16(volatile const s_val_t * p)
+{
+	return (s16) readl(p);
+}
+
+static inline void set_s16(volatile s_val_t * p, s16 val)
+{
+	writel(val, p);
+}
+
+// The raw data is stored in a format which facilitates rapid
+// processing by the JR3 DSP chip. The raw_channel structure shows the
+// format for a single channel of data. Each channel takes four,
+// two-byte words.
+//
+// Raw_time is an unsigned integer which shows the value of the JR3
+// DSP's internal clock at the time the sample was received. The clock
+// runs at 1/10 the JR3 DSP cycle time. JR3's slowest DSP runs at 10
+// Mhz. At 10 Mhz raw_time would therefore clock at 1 Mhz.
+//
+// Raw_data is the raw data received directly from the sensor. The
+// sensor data stream is capable of representing 16 different
+// channels. Channel 0 shows the excitation voltage at the sensor. It
+// is used to regulate the voltage over various cable lengths.
+// Channels 1-6 contain the coupled force data Fx through Mz. Channel
+// 7 contains the sensor's calibration data. The use of channels 8-15
+// varies with different sensors.
+typedef struct raw_channel {
+	u_val_t raw_time;
+	s_val_t raw_data;
+	s_val_t reserved[2];
+} raw_channel_t;
+
+// The force_array structure shows the layout for the decoupled and
+// filtered force data.
+typedef struct force_array {
+	s_val_t fx;
+	s_val_t fy;
+	s_val_t fz;
+	s_val_t mx;
+	s_val_t my;
+	s_val_t mz;
+	s_val_t v1;
+	s_val_t v2;
+} force_array_t;
+
+// The six_axis_array structure shows the layout for the offsets and
+// the full scales.
+typedef struct six_axis_array {
+	s_val_t fx;
+	s_val_t fy;
+	s_val_t fz;
+	s_val_t mx;
+	s_val_t my;
+	s_val_t mz;
+} six_axis_array_t;
+
+// VECT_BITS
+// The vect_bits structure shows the layout for indicating
+// which axes to use in computing the vectors. Each bit signifies
+// selection of a single axis. The V1x axis bit corresponds to a hex
+// value of 0x0001 and the V2z bit corresponds to a hex value of
+// 0x0020. Example: to specify the axes V1x, V1y, V2x, and V2z the
+// pattern would be 0x002b. Vector 1 defaults to a force vector and
+// vector 2 defaults to a moment vector. It is possible to change one
+// or the other so that two force vectors or two moment vectors are
+// calculated. Setting the changeV1 bit or the changeV2 bit will
+// change that vector to be the opposite of its default. Therefore to
+// have two force vectors, set changeV1 to 1.
+
+typedef enum {
+	fx = 0x0001,
+	fy = 0x0002,
+	fz = 0x0004,
+	mx = 0x0008,
+	my = 0x0010,
+	mz = 0x0020,
+	changeV2 = 0x0040,
+	changeV1 = 0x0080
+} vect_bits_t;
+
+// WARNING_BITS
+// The warning_bits structure shows the bit pattern for the warning
+// word. The bit fields are shown from bit 0 (lsb) to bit 15 (msb).
+//
+// XX_NEAR_SET
+// The xx_near_sat bits signify that the indicated axis has reached or
+// exceeded the near saturation value.
+
+typedef enum {
+	fx_near_sat = 0x0001,
+	fy_near_sat = 0x0002,
+	fz_near_sat = 0x0004,
+	mx_near_sat = 0x0008,
+	my_near_sat = 0x0010,
+	mz_near_sat = 0x0020
+} warning_bits_t;
+
+// ERROR_BITS
+// XX_SAT
+// MEMORY_ERROR
+// SENSOR_CHANGE
+//
+// The error_bits structure shows the bit pattern for the error word.
+// The bit fields are shown from bit 0 (lsb) to bit 15 (msb). The
+// xx_sat bits signify that the indicated axis has reached or exceeded
+// the saturation value. The memory_error bit indicates that a problem
+// was detected in the on-board RAM during the power-up
+// initialization. The sensor_change bit indicates that a sensor other
+// than the one originally plugged in has passed its CRC check. This
+// bit latches, and must be reset by the user.
+//
+// SYSTEM_BUSY
+//
+// The system_busy bit indicates that the JR3 DSP is currently busy
+// and is not calculating force data. This occurs when a new
+// coordinate transformation, or new sensor full scale is set by the
+// user. A very fast system using the force data for feedback might
+// become unstable during the approximately 4 ms needed to accomplish
+// these calculations. This bit will also become active when a new
+// sensor is plugged in and the system needs to recalculate the
+// calibration CRC.
+//
+// CAL_CRC_BAD
+//
+// The cal_crc_bad bit indicates that the calibration CRC has not
+// calculated to zero. CRC is short for cyclic redundancy code. It is
+// a method for determining the integrity of messages in data
+// communication. The calibration data stored inside the sensor is
+// transmitted to the JR3 DSP along with the sensor data. The
+// calibration data has a CRC attached to the end of it, to assist in
+// determining the completeness and integrity of the calibration data
+// received from the sensor. There are two reasons the CRC may not
+// have calculated to zero. The first is that all the calibration data
+// has not yet been received, the second is that the calibration data
+// has been corrupted. A typical sensor transmits the entire contents
+// of its calibration matrix over 30 times a second. Therefore, if
+// this bit is not zero within a couple of seconds after the sensor
+// has been plugged in, there is a problem with the sensor's
+// calibration data.
+//
+// WATCH_DOG
+// WATCH_DOG2
+//
+// The watch_dog and watch_dog2 bits are sensor, not processor, watch
+// dog bits. Watch_dog indicates that the sensor data line seems to be
+// acting correctly, while watch_dog2 indicates that sensor data and
+// clock are being received. It is possible for watch_dog2 to go off
+// while watch_dog does not. This would indicate an improper clock
+// signal, while data is acting correctly. If either watch dog barks,
+// the sensor data is not being received correctly.
+
+typedef enum {
+	fx_sat = 0x0001,
+	fy_sat = 0x0002,
+	fz_sat = 0x0004,
+	mx_sat = 0x0008,
+	my_sat = 0x0010,
+	mz_sat = 0x0020,
+	memory_error = 0x0400,
+	sensor_change = 0x0800,
+	system_busy = 0x1000,
+	cal_crc_bad = 0x2000,
+	watch_dog2 = 0x4000,
+	watch_dog = 0x8000
+} error_bits_t;
+
+// THRESH_STRUCT
+// This structure shows the layout for a single threshold packet inside of a
+// load envelope. Each load envelope can contain several threshold structures.
+// 1. data_address contains the address of the data for that threshold. This
+//    includes filtered, unfiltered, raw, rate, counters, error and warning data
+// 2. threshold is the is the value at which, if data is above or below, the
+//    bits will be set ... (pag.24).
+// 3. bit_pattern contains the bits that will be set if the threshold value is
+//    met or exceeded.
+typedef struct thresh_struct {
+	s32 data_address;
+	s32 threshold;
+	s32 bit_pattern;
+} thresh_struct;
+
+// LE_STRUCT
+// Layout of a load enveloped packet. Four thresholds are showed ... for more
+// see manual (pag.25)
+// 1. latch_bits is a bit pattern that show which bits the user wants to latch.
+//    The latched bits will not be reset once the threshold which set them is
+//    no longer true. In that case the user must reset them using the reset_bit
+//    command.
+// 2. number_of_xx_thresholds specify how many GE/LE threshold there are.
+typedef struct {
+	s32 latch_bits;
+	s32 number_of_ge_thresholds;
+	s32 number_of_le_thresholds;
+	struct thresh_struct thresholds[4];
+	s32 reserved;
+} le_struct_t;
+
+// LINK_TYPES
+// Link types is an enumerated value showing the different possible transform
+// link types.
+// 0 - end transform packet
+// 1 - translate along X axis (TX)
+// 2 - translate along Y axis (TY)
+// 3 - translate along Z axis (TZ)
+// 4 - rotate about X axis (RX)
+// 5 - rotate about Y axis (RY)
+// 6 - rotate about Z axis (RZ)
+// 7 - negate all axes (NEG)
+typedef enum link_types {
+	end_x_form,
+	tx,
+	ty,
+	tz,
+	rx,
+	ry,
+	rz,
+	neg
+} link_types;
+
+// TRANSFORM
+// Structure used to describe a transform.
+typedef struct {
+	struct {
+		u_val_t link_type;
+		s_val_t link_amount;
+	} link[8];
+} intern_transform_t;
+
+// JR3 force/torque sensor data definition. For more information see sensor and
+// hardware manuals.
+
+typedef struct force_sensor_data {
+	// Raw_channels is the area used to store the raw data coming from
+	// the sensor.
+
+	raw_channel_t raw_channels[16];	/* offset 0x0000 */
+
+	// Copyright is a null terminated ASCII string containing the JR3
+	// copyright notice.
+
+	u_val_t copyright[0x0018];	/* offset 0x0040 */
+	s_val_t reserved1[0x0008];	/* offset 0x0058 */
+
+	// Shunts contains the sensor shunt readings. Some JR3 sensors have
+	//  the ability to have their gains adjusted. This allows the
+	//  hardware full scales to be adjusted to potentially allow
+	//  better resolution or dynamic range. For sensors that have
+	//  this ability, the gain of each sensor channel is measured at
+	//  the time of calibration using a shunt resistor. The shunt
+	//  resistor is placed across one arm of the resistor bridge, and
+	//  the resulting change in the output of that channel is
+	//  measured. This measurement is called the shunt reading, and
+	//  is recorded here. If the user has changed the gain of the //
+	// sensor, and made new shunt measurements, those shunt
+	//  measurements can be placed here. The JR3 DSP will then scale
+	//  the calibration matrix such so that the gains are again
+	//  proper for the indicated shunt readings. If shunts is 0, then
+	//  the sensor cannot have its gain changed. For details on
+	//  changing the sensor gain, and making shunts readings, please
+	//  see the sensor manual. To make these values take effect the
+	//  user must call either command (5) use transform # (pg. 33) or
+	//  command (10) set new full scales (pg. 38).
+
+	six_axis_array_t shunts;	/* offset 0x0060 */
+	s32 reserved2[2];	/* offset 0x0066 */
+
+	// Default_FS contains the full scale that is used if the user does
+	// not set a full scale.
+
+	six_axis_array_t default_FS;	/* offset 0x0068 */
+	s_val_t reserved3;	/* offset 0x006e */
+
+	// Load_envelope_num is the load envelope number that is currently
+	// in use. This value is set by the user after one of the load
+	// envelopes has been initialized.
+
+	s_val_t load_envelope_num;	/* offset 0x006f */
+
+	// Min_full_scale is the recommend minimum full scale.
+	//
+	// These values in conjunction with max_full_scale (pg. 9) helps
+	// determine the appropriate value for setting the full scales. The
+	// software allows the user to set the sensor full scale to an
+	// arbitrary value. But setting the full scales has some hazards. If
+	// the full scale is set too low, the data will saturate
+	// prematurely, and dynamic range will be lost. If the full scale is
+	// set too high, then resolution is lost as the data is shifted to
+	// the right and the least significant bits are lost. Therefore the
+	// maximum full scale is the maximum value at which no resolution is
+	// lost, and the minimum full scale is the value at which the data
+	// will not saturate prematurely. These values are calculated
+	// whenever a new coordinate transformation is calculated. It is
+	// possible for the recommended maximum to be less than the
+	// recommended minimum. This comes about primarily when using
+	// coordinate translations. If this is the case, it means that any
+	// full scale selection will be a compromise between dynamic range
+	// and resolution. It is usually recommended to compromise in favor
+	// of resolution which means that the recommend maximum full scale
+	// should be chosen.
+	//
+	// WARNING: Be sure that the full scale is no less than 0.4% of the
+	// recommended minimum full scale. Full scales below this value will
+	// cause erroneous results.
+
+	six_axis_array_t min_full_scale;	/* offset 0x0070 */
+	s_val_t reserved4;	/* offset 0x0076 */
+
+	// Transform_num is the transform number that is currently in use.
+	// This value is set by the JR3 DSP after the user has used command
+	// (5) use transform # (pg. 33).
+
+	s_val_t transform_num;	/* offset 0x0077 */
+
+	// Max_full_scale is the recommended maximum full scale. See
+	// min_full_scale (pg. 9) for more details.
+
+	six_axis_array_t max_full_scale;	/* offset 0x0078 */
+	s_val_t reserved5;	/* offset 0x007e */
+
+	// Peak_address is the address of the data which will be monitored
+	// by the peak routine. This value is set by the user. The peak
+	// routine will monitor any 8 contiguous addresses for peak values.
+	// (ex. to watch filter3 data for peaks, set this value to 0x00a8).
+
+	s_val_t peak_address;	/* offset 0x007f */
+
+	// Full_scale is the sensor full scales which are currently in use.
+	// Decoupled and filtered data is scaled so that +/- 16384 is equal
+	// to the full scales. The engineering units used are indicated by
+	// the units value discussed on page 16. The full scales for Fx, Fy,
+	// Fz, Mx, My and Mz can be written by the user prior to calling
+	// command (10) set new full scales (pg. 38). The full scales for V1
+	// and V2 are set whenever the full scales are changed or when the
+	// axes used to calculate the vectors are changed. The full scale of
+	// V1 and V2 will always be equal to the largest full scale of the
+	// axes used for each vector respectively.
+
+	force_array_t full_scale;	/* offset 0x0080 */
+
+	// Offsets contains the sensor offsets. These values are subtracted from
+	// the sensor data to obtain the decoupled data. The offsets are set a
+	// few seconds (< 10) after the calibration data has been received.
+	// They are set so that the output data will be zero. These values
+	// can be written as well as read. The JR3 DSP will use the values
+	// written here within 2 ms of being written. To set future
+	// decoupled data to zero, add these values to the current decoupled
+	// data values and place the sum here. The JR3 DSP will change these
+	// values when a new transform is applied. So if the offsets are
+	// such that FX is 5 and all other values are zero, after rotating
+	// about Z by 90 degrees, FY would be 5 and all others would be zero.
+
+	six_axis_array_t offsets;	/* offset 0x0088 */
+
+	// Offset_num is the number of the offset currently in use. This
+	// value is set by the JR3 DSP after the user has executed the use
+	// offset # command (pg. 34). It can vary between 0 and 15.
+
+	s_val_t offset_num;	/* offset 0x008e */
+
+	// Vect_axes is a bit map showing which of the axes are being used
+	// in the vector calculations. This value is set by the JR3 DSP
+	// after the user has executed the set vector axes command (pg. 37).
+
+	u_val_t vect_axes;	/* offset 0x008f */
+
+	// Filter0 is the decoupled, unfiltered data from the JR3 sensor.
+	// This data has had the offsets removed.
+	//
+	// These force_arrays hold the filtered data. The decoupled data is
+	// passed through cascaded low pass filters. Each succeeding filter
+	// has a cutoff frequency of 1/4 of the preceding filter. The cutoff
+	// frequency of filter1 is 1/16 of the sample rate from the sensor.
+	// For a typical sensor with a sample rate of 8 kHz, the cutoff
+	// frequency of filter1 would be 500 Hz. The following filters would
+	// cutoff at 125 Hz, 31.25 Hz, 7.813 Hz, 1.953 Hz and 0.4883 Hz.
+
+	struct force_array filter[7];	/* offset 0x0090,
+					   offset 0x0098,
+					   offset 0x00a0,
+					   offset 0x00a8,
+					   offset 0x00b0,
+					   offset 0x00b8 ,
+					   offset 0x00c0 */
+
+	// Rate_data is the calculated rate data. It is a first derivative
+	// calculation. It is calculated at a frequency specified by the
+	// variable rate_divisor (pg. 12). The data on which the rate is
+	// calculated is specified by the variable rate_address (pg. 12).
+
+	force_array_t rate_data;	/* offset 0x00c8 */
+
+	// Minimum_data & maximum_data are the minimum and maximum (peak)
+	// data values. The JR3 DSP can monitor any 8 contiguous data items
+	// for minimums and maximums at full sensor bandwidth. This area is
+	// only updated at user request. This is done so that the user does
+	// not miss any peaks. To read the data, use either the read peaks
+	// command (pg. 40), or the read and reset peaks command (pg. 39).
+	// The address of the data to watch for peaks is stored in the
+	// variable peak_address (pg. 10). Peak data is lost when executing
+	// a coordinate transformation or a full scale change. Peak data is
+	// also lost when plugging in a new sensor.
+
+	force_array_t minimum_data;	/* offset 0x00d0 */
+	force_array_t maximum_data;	/* offset 0x00d8 */
+
+	// Near_sat_value & sat_value contain the value used to determine if
+	// the raw sensor is saturated. Because of decoupling and offset
+	// removal, it is difficult to tell from the processed data if the
+	// sensor is saturated. These values, in conjunction with the error
+	// and warning words (pg. 14), provide this critical information.
+	// These two values may be set by the host processor. These values
+	// are positive signed values, since the saturation logic uses the
+	// absolute values of the raw data. The near_sat_value defaults to
+	// approximately 80% of the ADC's full scale, which is 26214, while
+	// sat_value defaults to the ADC's full scale:
+	//
+	//   sat_value = 32768 - 2^(16 - ADC bits)
+
+	s_val_t near_sat_value;	/* offset 0x00e0 */
+	s_val_t sat_value;	/* offset 0x00e1 */
+
+	// Rate_address, rate_divisor & rate_count contain the data used to
+	// control the calculations of the rates. Rate_address is the
+	// address of the data used for the rate calculation. The JR3 DSP
+	// will calculate rates for any 8 contiguous values (ex. to
+	// calculate rates for filter3 data set rate_address to 0x00a8).
+	// Rate_divisor is how often the rate is calculated. If rate_divisor
+	// is 1, the rates are calculated at full sensor bandwidth. If
+	// rate_divisor is 200, rates are calculated every 200 samples.
+	// Rate_divisor can be any value between 1 and 65536. Set
+	// rate_divisor to 0 to calculate rates every 65536 samples.
+	// Rate_count starts at zero and counts until it equals
+	// rate_divisor, at which point the rates are calculated, and
+	// rate_count is reset to 0. When setting a new rate divisor, it is
+	// a good idea to set rate_count to one less than rate divisor. This
+	// will minimize the time necessary to start the rate calculations.
+
+	s_val_t rate_address;	/* offset 0x00e2 */
+	u_val_t rate_divisor;	/* offset 0x00e3 */
+	u_val_t rate_count;	/* offset 0x00e4 */
+
+	// Command_word2 through command_word0 are the locations used to
+	// send commands to the JR3 DSP. Their usage varies with the command
+	// and is detailed later in the Command Definitions section (pg.
+	// 29). In general the user places values into various memory
+	// locations, and then places the command word into command_word0.
+	// The JR3 DSP will process the command and place a 0 into
+	// command_word0 to indicate successful completion. Alternatively
+	// the JR3 DSP will place a negative number into command_word0 to
+	// indicate an error condition. Please note the command locations
+	// are numbered backwards. (I.E. command_word2 comes before
+	// command_word1).
+
+	s_val_t command_word2;	/* offset 0x00e5 */
+	s_val_t command_word1;	/* offset 0x00e6 */
+	s_val_t command_word0;	/* offset 0x00e7 */
+
+	// Count1 through count6 are unsigned counters which are incremented
+	// every time the matching filters are calculated. Filter1 is
+	// calculated at the sensor data bandwidth. So this counter would
+	// increment at 8 kHz for a typical sensor. The rest of the counters
+	// are incremented at 1/4 the interval of the counter immediately
+	// preceding it, so they would count at 2 kHz, 500 Hz, 125 Hz etc.
+	// These counters can be used to wait for data. Each time the
+	// counter changes, the corresponding data set can be sampled, and
+	// this will insure that the user gets each sample, once, and only
+	// once.
+
+	u_val_t count1;		/* offset 0x00e8 */
+	u_val_t count2;		/* offset 0x00e9 */
+	u_val_t count3;		/* offset 0x00ea */
+	u_val_t count4;		/* offset 0x00eb */
+	u_val_t count5;		/* offset 0x00ec */
+	u_val_t count6;		/* offset 0x00ed */
+
+	// Error_count is a running count of data reception errors. If this
+	// counter is changing rapidly, it probably indicates a bad sensor
+	// cable connection or other hardware problem. In most installations
+	// error_count should not change at all. But it is possible in an
+	// extremely noisy environment to experience occasional errors even
+	// without a hardware problem. If the sensor is well grounded, this
+	// is probably unavoidable in these environments. On the occasions
+	// where this counter counts a bad sample, that sample is ignored.
+
+	u_val_t error_count;	/* offset 0x00ee */
+
+	// Count_x is a counter which is incremented every time the JR3 DSP
+	// searches its job queues and finds nothing to do. It indicates the
+	// amount of idle time the JR3 DSP has available. It can also be
+	// used to determine if the JR3 DSP is alive. See the Performance
+	// Issues section on pg. 49 for more details.
+
+	u_val_t count_x;	/* offset 0x00ef */
+
+	// Warnings & errors contain the warning and error bits
+	// respectively. The format of these two words is discussed on page
+	// 21 under the headings warnings_bits and error_bits.
+
+	u_val_t warnings;	/* offset 0x00f0 */
+	u_val_t errors;		/* offset 0x00f1 */
+
+	// Threshold_bits is a word containing the bits that are set by the
+	// load envelopes. See load_envelopes (pg. 17) and thresh_struct
+	// (pg. 23) for more details.
+
+	s_val_t threshold_bits;	/* offset 0x00f2 */
+
+	// Last_crc is the value that shows the actual calculated CRC. CRC
+	// is short for cyclic redundancy code. It should be zero. See the
+	// description for cal_crc_bad (pg. 21) for more information.
+
+	s_val_t last_CRC;	/* offset 0x00f3 */
+
+	// EEProm_ver_no contains the version number of the sensor EEProm.
+	// EEProm version numbers can vary between 0 and 255.
+	// Software_ver_no contains the software version number. Version
+	// 3.02 would be stored as 302.
+
+	s_val_t eeprom_ver_no;	/* offset 0x00f4 */
+	s_val_t software_ver_no;	/* offset 0x00f5 */
+
+	// Software_day & software_year are the release date of the software
+	// the JR3 DSP is currently running. Day is the day of the year,
+	// with January 1 being 1, and December 31, being 365 for non leap
+	// years.
+
+	s_val_t software_day;	/* offset 0x00f6 */
+	s_val_t software_year;	/* offset 0x00f7 */
+
+	// Serial_no & model_no are the two values which uniquely identify a
+	// sensor. This model number does not directly correspond to the JR3
+	// model number, but it will provide a unique identifier for
+	// different sensor configurations.
+
+	u_val_t serial_no;	/* offset 0x00f8 */
+	u_val_t model_no;	/* offset 0x00f9 */
+
+	// Cal_day & cal_year are the sensor calibration date. Day is the
+	// day of the year, with January 1 being 1, and December 31, being
+	// 366 for leap years.
+
+	s_val_t cal_day;	/* offset 0x00fa */
+	s_val_t cal_year;	/* offset 0x00fb */
+
+	// Units is an enumerated read only value defining the engineering
+	// units used in the sensor full scale. The meanings of particular
+	// values are discussed in the section detailing the force_units
+	// structure on page 22. The engineering units are setto customer
+	// specifications during sensor manufacture and cannot be changed by
+	// writing to Units.
+	//
+	// Bits contains the number of bits of resolution of the ADC
+	// currently in use.
+	//
+	// Channels is a bit field showing which channels the current sensor
+	// is capable of sending. If bit 0 is active, this sensor can send
+	// channel 0, if bit 13 is active, this sensor can send channel 13,
+	// etc. This bit can be active, even if the sensor is not currently
+	// sending this channel. Some sensors are configurable as to which
+	// channels to send, and this field only contains information on the
+	// channels available to send, not on the current configuration. To
+	// find which channels are currently being sent, monitor the
+	// Raw_time fields (pg. 19) in the raw_channels array (pg. 7). If
+	// the time is changing periodically, then that channel is being
+	// received.
+
+	u_val_t units;		/* offset 0x00fc */
+	s_val_t bits;		/* offset 0x00fd */
+	s_val_t channels;	/* offset 0x00fe */
+
+	// Thickness specifies the overall thickness of the sensor from
+	// flange to flange. The engineering units for this value are
+	// contained in units (pg. 16). The sensor calibration is relative
+	// to the center of the sensor. This value allows easy coordinate
+	// transformation from the center of the sensor to either flange.
+
+	s_val_t thickness;	/* offset 0x00ff */
+
+	// Load_envelopes is a table containing the load envelope
+	// descriptions. There are 16 possible load envelope slots in the
+	// table. The slots are on 16 word boundaries and are numbered 0-15.
+	// Each load envelope needs to start at the beginning of a slot but
+	// need not be fully contained in that slot. That is to say that a
+	// single load envelope can be larger than a single slot. The
+	// software has been tested and ran satisfactorily with 50
+	// thresholds active. A single load envelope this large would take
+	// up 5 of the 16 slots. The load envelope data is laid out in an
+	// order that is most efficient for the JR3 DSP. The structure is
+	// detailed later in the section showing the definition of the
+	// le_struct structure (pg. 23).
+
+	le_struct_t load_envelopes[0x10];	/* offset 0x0100 */
+
+	// Transforms is a table containing the transform descriptions.
+	// There are 16 possible transform slots in the table. The slots are
+	// on 16 word boundaries and are numbered 0-15. Each transform needs
+	// to start at the beginning of a slot but need not be fully
+	// contained in that slot. That is to say that a single transform
+	// can be larger than a single slot. A transform is 2 * no of links
+	// + 1 words in length. So a single slot can contain a transform
+	// with 7 links. Two slots can contain a transform that is 15 links.
+	// The layout is detailed later in the section showing the
+	// definition of the transform structure (pg. 26).
+
+	intern_transform_t transforms[0x10];	/* offset 0x0200 */
+} jr3_channel_t;
+
+typedef struct {
+	struct {
+		u_val_t program_low[0x4000];	// 0x00000 - 0x10000
+		jr3_channel_t data;	// 0x10000 - 0x10c00
+		char pad2[0x30000 - 0x00c00];	// 0x10c00 - 0x40000
+		u_val_t program_high[0x8000];	// 0x40000 - 0x60000
+		u32 reset;	// 0x60000 - 0x60004
+		char pad3[0x20000 - 0x00004];	// 0x60004 - 0x80000
+	} channel[4];
+} jr3_t;
