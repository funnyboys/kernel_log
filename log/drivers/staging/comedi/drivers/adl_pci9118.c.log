commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 1cc9b7ef1ff9..2528ca0ede6d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  comedi/drivers/adl_pci9118.c
  *

commit e3f75db14d4bcef77908084afe1190b557d1b40f
Author: Artur Lorincz <larturus@yahoo.com>
Date:   Sat Feb 11 22:08:31 2017 +0100

    staging: comedi: fixed multiple line dereference
    
    Fixed multiple line dereference for &cmd->scan_begin_arg.
    
    Signed-off-by: Artur Lorincz <larturus@yahoo.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 86450c08f291..1cc9b7ef1ff9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1279,9 +1279,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			} else {
 				arg = cmd->convert_arg * cmd->chanlist_len;
 			}
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    arg);
+			err |= comedi_check_trigger_arg_min(
+				&cmd->scan_begin_arg, arg);
 		}
 	}
 

commit 25b80dbe3fa6d76d8f19af0623d1fd8ed0dd671e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Sep 12 23:02:47 2016 +0530

    Staging: comedi: drivers: Delete NULL check before pci_dev_put
    
    The function pci_dev_put checks whether its argument is NULL and returns
    immediately. Therefore, NULL test before the call if not needed.
    Found using coccinelle:
    @@
    expression x;
    @@
    
    - if(x)
    - pci_dev_put(x);
    + pci_dev_put(x);
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index be70bd333807..86450c08f291 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1693,8 +1693,7 @@ static void pci9118_detach(struct comedi_device *dev)
 		pci9118_reset(dev);
 	comedi_pci_detach(dev);
 	pci9118_free_dma(dev);
-	if (pcidev)
-		pci_dev_put(pcidev);
+	pci_dev_put(pcidev);
 }
 
 static struct comedi_driver adl_pci9118_driver = {

commit 6f594b82038d0f9d72f8a6dce1a72e3c88d9961a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Jun 4 06:35:20 2016 +0100

    staging: comedi: adl_pci9118: fix spelling mistake "acqusition" -> "acquisition"
    
    trivial fix to spelling mistake
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4437ea3abe8d..be70bd333807 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -570,7 +570,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-	/* reset acqusition control */
+	/* reset acquisition control */
 	devpriv->ai_ctrl = 0;
 	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
@@ -1022,12 +1022,12 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*
 	 * Configure analog input and load the chanlist.
-	 * The acqusition control bits are enabled later.
+	 * The acquisition control bits are enabled later.
 	 */
 	pci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,
 			     devpriv->ai_add_front, devpriv->ai_add_back);
 
-	/* Determine acqusition mode and calculate timing */
+	/* Determine acquisition mode and calculate timing */
 	devpriv->ai_do = 0;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->convert_src == TRIG_TIMER) {
@@ -1097,7 +1097,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->ai_do == 0) {
 		dev_err(dev->class_dev,
-			"Unable to determine acqusition mode! BUG in (*do_cmdtest)?\n");
+			"Unable to determine acquisition mode! BUG in (*do_cmdtest)?\n");
 		return -EINVAL;
 	}
 

commit 2aadecb60a33c791bfb729d65c158a22f636961a
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Sat Oct 31 06:36:44 2015 -0700

    Staging: comedi: adl_pci9118: Fix endian sparse warning
    
    Fix following sparse warning:
    warning: cast to restricted __be16
    
    data is pointer of type void and can be used to store any type of data.
    barray and array have the same 16 bit offset.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0dff1dbb53fb..4437ea3abe8d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -603,10 +603,11 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 	unsigned short *array = data;
 	unsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned int i;
+	__be16 *barray = data;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)
-			array[i] = be16_to_cpu(array[i]);
+			array[i] = be16_to_cpu(barray[i]);
 		if (s->maxdata == 0xffff)
 			array[i] ^= 0x8000;
 		else

commit eb96c7fc24fb89d7e3382260e1b391c05895cfa6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:05 2015 -0700

    staging: comedi: adl_pci9118: tidy up pci9118_ai_setup_dma()
    
    For aesthetics, init the dmalen[01] local variables when they are declared.
    
    Use a local variable, 'scan_bytes', for the (devpriv->ai_n_realscanlen << 1)
    calculation. For aesthetics and clarification, use comedi_bytes_per_sample()
    instead of the '<< 1' shift to calculate the value.
    
    The local variable 'i' is badly named. Remove it and use a local variable
    'tmp' where it is used.
    
    When checking the DMA buffer lengths for non-neverending commands the
    scan length calculation, (devpriv->ai_n_realscanlen << 1) * cmd->stop_arg,
    could overflow. Use and unsigned long long local variable to hold the
    calculation and avoid the overflow.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e2302cb5ce2c..0dff1dbb53fb 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -801,10 +801,11 @@ static int pci9118_ai_setup_dma(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pci9118_dmabuf *dmabuf0 = &devpriv->dmabuf[0];
 	struct pci9118_dmabuf *dmabuf1 = &devpriv->dmabuf[1];
-	unsigned int dmalen0, dmalen1, i;
+	unsigned int dmalen0 = dmabuf0->size;
+	unsigned int dmalen1 = dmabuf1->size;
+	unsigned int scan_bytes = devpriv->ai_n_realscanlen *
+				  comedi_bytes_per_sample(s);
 
-	dmalen0 = dmabuf0->size;
-	dmalen1 = dmabuf1->size;
 	/* isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > s->async->prealloc_bufsz) {
 		/* align to 32bit down */
@@ -817,15 +818,15 @@ static int pci9118_ai_setup_dma(struct comedi_device *dev,
 
 	/* we want wake up every scan? */
 	if (devpriv->ai_flags & CMDF_WAKE_EOS) {
-		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
+		if (dmalen0 < scan_bytes) {
 			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~CMDF_WAKE_EOS);
 			dev_info(dev->class_dev,
 				 "WAR: DMA0 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",
-				  dmalen0, devpriv->ai_n_realscanlen << 1);
+				  dmalen0, scan_bytes);
 		} else {
 			/* short first DMA buffer to one scan */
-			dmalen0 = devpriv->ai_n_realscanlen << 1;
+			dmalen0 = scan_bytes;
 			if (dmalen0 < 4) {
 				dev_info(dev->class_dev,
 					 "ERR: DMA0 buf len bug? (%d<4)\n",
@@ -835,15 +836,15 @@ static int pci9118_ai_setup_dma(struct comedi_device *dev,
 		}
 	}
 	if (devpriv->ai_flags & CMDF_WAKE_EOS) {
-		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
+		if (dmalen1 < scan_bytes) {
 			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~CMDF_WAKE_EOS);
 			dev_info(dev->class_dev,
 				 "WAR: DMA1 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",
-				 dmalen1, devpriv->ai_n_realscanlen << 1);
+				 dmalen1, scan_bytes);
 		} else {
 			/* short second DMA buffer to one scan */
-			dmalen1 = devpriv->ai_n_realscanlen << 1;
+			dmalen1 = scan_bytes;
 			if (dmalen1 < 4) {
 				dev_info(dev->class_dev,
 					 "ERR: DMA1 buf len bug? (%d<4)\n",
@@ -855,45 +856,39 @@ static int pci9118_ai_setup_dma(struct comedi_device *dev,
 
 	/* transfer without CMDF_WAKE_EOS */
 	if (!(devpriv->ai_flags & CMDF_WAKE_EOS)) {
+		unsigned int tmp;
+
 		/* if it's possible then align DMA buffers to length of scan */
-		i = dmalen0;
-		dmalen0 =
-		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
-		    (devpriv->ai_n_realscanlen << 1);
+		tmp = dmalen0;
+		dmalen0 = (dmalen0 / scan_bytes) * scan_bytes;
 		dmalen0 &= ~3L;
 		if (!dmalen0)
-			dmalen0 = i;	/* uff. very long scan? */
-		i = dmalen1;
-		dmalen1 =
-		    (dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
-		    (devpriv->ai_n_realscanlen << 1);
+			dmalen0 = tmp;	/* uff. very long scan? */
+		tmp = dmalen1;
+		dmalen1 = (dmalen1 / scan_bytes) * scan_bytes;
 		dmalen1 &= ~3L;
 		if (!dmalen1)
-			dmalen1 = i;	/* uff. very long scan? */
+			dmalen1 = tmp;	/* uff. very long scan? */
 		/*
 		 * if measure isn't neverending then test, if it fits whole
 		 * into one or two DMA buffers
 		 */
 		if (!devpriv->ai_neverending) {
+			unsigned long long scanlen;
+
+			scanlen = (unsigned long long)scan_bytes *
+				  cmd->stop_arg;
+
 			/* fits whole measure into one DMA buffer? */
-			if (dmalen0 >
-			    ((devpriv->ai_n_realscanlen << 1) *
-			     cmd->stop_arg)) {
-				dmalen0 =
-				    (devpriv->ai_n_realscanlen << 1) *
-				    cmd->stop_arg;
+			if (dmalen0 > scanlen) {
+				dmalen0 = scanlen;
 				dmalen0 &= ~3L;
-			} else {	/*
-					 * fits whole measure into
-					 * two DMA buffer?
-					 */
-				if (dmalen1 >
-				    ((devpriv->ai_n_realscanlen << 1) *
-				     cmd->stop_arg - dmalen0))
-					dmalen1 =
-					    (devpriv->ai_n_realscanlen << 1) *
-					    cmd->stop_arg - dmalen0;
-				dmalen1 &= ~3L;
+			} else {
+				/* fits whole measure into two DMA buffer? */
+				if (dmalen1 > (scanlen - dmalen0)) {
+					dmalen1 = scanlen - dmalen0;
+					dmalen1 &= ~3L;
+				}
 			}
 		}
 	}

commit 45037a9569183b49a9c9cf9faea294228c3963d2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:04 2015 -0700

    staging: comedi: adl_pci9118: rename interrupt_*() functions
    
    For aesthetics, rename these functions so it they namespace associated
    with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index be0d2a7607ef..e2302cb5ce2c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -614,8 +614,8 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 	}
 }
 
-static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
-					   struct comedi_subdevice *s)
+static void pci9118_ai_get_onesample(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -631,8 +631,8 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	}
 }
 
-static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s)
+static void pci9118_ai_get_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -757,9 +757,9 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->usedma)
-		interrupt_pci9118_ai_dma(dev, s);
+		pci9118_ai_get_dma(dev, s);
 	else
-		interrupt_pci9118_ai_onesample(dev, s);
+		pci9118_ai_get_onesample(dev, s);
 
 interrupt_exit:
 	comedi_handle_events(dev, s);

commit 5c912f1f285e91c9059f8b3cf2ff170ee42d604d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:03 2015 -0700

    staging: comedi: adl_pci9118: rename move_block_from_dma()
    
    Rename this function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ac1d298fae8d..be0d2a7607ef 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -457,7 +457,7 @@ static unsigned int pci9118_ai_samples_ready(struct comedi_device *dev,
 	return n_samples;
 }
 
-static void move_block_from_dma(struct comedi_device *dev,
+static void pci9118_ai_dma_xfer(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned short *dma_buffer,
 				unsigned int n_raw_samples)
@@ -654,7 +654,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	}
 
 	if (n_all)
-		move_block_from_dma(dev, s, dmabuf->virt, n_all);
+		pci9118_ai_dma_xfer(dev, s, dmabuf->virt, n_all);
 
 	if (!devpriv->ai_neverending) {
 		if (s->async->scans_done >= cmd->stop_arg)

commit 9459ff2b6bd103bd4bd0e31f5144a7b2b6e76bae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:02 2015 -0700

    staging: comedi: adl_pci9118: rename valid_samples_in_act_dma_buf()
    
    Rename this function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 65823493b3e3..ac1d298fae8d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -401,9 +401,9 @@ static void pci9118_ai_mode4_switch(struct comedi_device *dev,
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 }
 
-static unsigned int valid_samples_in_act_dma_buf(struct comedi_device *dev,
-						 struct comedi_subdevice *s,
-						 unsigned int n_raw_samples)
+static unsigned int pci9118_ai_samples_ready(struct comedi_device *dev,
+					     struct comedi_subdevice *s,
+					     unsigned int n_raw_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -642,7 +642,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	bool more_dma;
 
 	/* determine whether more DMA buffers to do after this one */
-	n_valid = valid_samples_in_act_dma_buf(dev, s, n_all);
+	n_valid = pci9118_ai_samples_ready(dev, s, n_all);
 	more_dma = n_valid < comedi_nsamples_left(s, n_valid + 1);
 
 	/* switch DMA buffers and restart DMA if double buffering */

commit ad1a9646b72ab58649b0e75bda794f7ca79ae497
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:01 2015 -0700

    staging: comedi: adl_pci9118: rename interrupt_pci9118_ai_mode4_switch()
    
    For aesthetics, remove "interrupt_" from this functions name to shorten
    it a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 87c2ddde6124..65823493b3e3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -386,8 +386,8 @@ static void pci9118_set_chanlist(struct comedi_device *dev,
 	/* udelay(100); important delay, or first sample will be crippled */
 }
 
-static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev,
-					      unsigned int next_buf)
+static void pci9118_ai_mode4_switch(struct comedi_device *dev,
+				    unsigned int next_buf)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[next_buf];
@@ -649,10 +649,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	if (more_dma && devpriv->dma_doublebuf) {
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
 		pci9118_amcc_setup_dma(dev, devpriv->dma_actbuf);
-		if (devpriv->ai_do == 4) {
-			interrupt_pci9118_ai_mode4_switch(dev,
-							  devpriv->dma_actbuf);
-		}
+		if (devpriv->ai_do == 4)
+			pci9118_ai_mode4_switch(dev, devpriv->dma_actbuf);
 	}
 
 	if (n_all)
@@ -670,7 +668,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	if (more_dma && !devpriv->dma_doublebuf) {
 		pci9118_amcc_setup_dma(dev, 0);
 		if (devpriv->ai_do == 4)
-			interrupt_pci9118_ai_mode4_switch(dev, 0);
+			pci9118_ai_mode4_switch(dev, 0);
 	}
 }
 

commit dd2907c3e7a759e1ea2ea5587704515d907dd937
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:13:00 2015 -0700

    staging: comedi: adl_pci9118: remove PCI9118_CHANLEN
    
    This define is only used to initialize the analog input sudevice
    'len_chanlist'. Remove the define and just open code the value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 493bdef241be..87c2ddde6124 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -83,11 +83,6 @@
 #include "amcc_s5933.h"
 #include "comedi_8254.h"
 
-#define PCI9118_CHANLEN	255	/*
-				 * len of chanlist, some source say 256,
-				 * but reality looks like 255 :-(
-				 */
-
 /*
  * PCI BAR2 Register map (dev->iobase)
  */
@@ -1595,7 +1590,7 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags	|= SDF_CMD_READ;
-		s->len_chanlist	= PCI9118_CHANLEN;
+		s->len_chanlist	= 255;
 		s->do_cmdtest	= pci9118_ai_cmdtest;
 		s->do_cmd	= pci9118_ai_cmd;
 		s->cancel	= pci9118_ai_cancel;

commit 766957f6f1841e5d435798741852f2697ad0b2ad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:12:59 2015 -0700

    staging: comedi: adl_pci9118: remove unused defines
    
    These defines are not used in the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 08cd04691bea..493bdef241be 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -83,7 +83,6 @@
 #include "amcc_s5933.h"
 #include "comedi_8254.h"
 
-#define IORANGE_9118	64	/* I hope */
 #define PCI9118_CHANLEN	255	/*
 				 * len of chanlist, some source say 256,
 				 * but reality looks like 255 :-(
@@ -141,8 +140,6 @@
 #define STOP_AI_EXT	0x02	/* stop measure on external trigger */
 #define STOP_AI_INT	0x08	/* stop measure on internal trigger */
 
-#define PCI9118_HALF_FIFO_SZ	(1024 / 2)
-
 static const struct comedi_lrange pci9118_ai_range = {
 	8, {
 		BIP_RANGE(5),

commit 0f3cb85ac85a6819248544113b495af27921e454
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:12:58 2015 -0700

    staging: comedi: adl_pci9118: tidy up check_channel_list()
    
    Rename this function to give it namespace associated with the driver.
    
    Currently this function is called by both the AI (*do_cmdtest) and the (*do_cmd)
    functions. It really only needs to be called by the (*do_cmdtest) to validate
    that the chanlist meets the requirements of the hardware. It's only called by
    the (*do_cmd) to verify that the scan length is not to large after adding the
    extra samples needed to satisfy the DMA.
    
    Move the extra scan length check into the (*do_cmd) function and remove the
    unnecessary parameters 'frontadd' and 'backadd'.
    
    Tidy up the reset of the function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dcfe5cc08220..08cd04691bea 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -169,11 +169,6 @@ static const struct comedi_lrange pci9118hg_ai_range = {
 	}
 };
 
-#define PCI9118_BIPOLAR_RANGES	4	/*
-					 * used for test on mixture
-					 * of BIP/UNI ranges
-					 */
-
 enum pci9118_boardid {
 	BOARD_PCI9118DG,
 	BOARD_PCI9118HG,
@@ -296,46 +291,44 @@ static void pci9118_ai_reset_fifo(struct comedi_device *dev)
 	outl(0, dev->iobase + PCI9118_FIFO_RESET_REG);
 }
 
-static int check_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int frontadd, int backadd)
+static int pci9118_ai_check_chanlist(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_cmd *cmd)
 {
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, differencial = 0, bipolar = 0;
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	unsigned int aref0 = CR_AREF(cmd->chanlist[0]);
+	int i;
 
-	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		dev_err(dev->class_dev,
-			"range/channel list is too long for actual configuration!\n");
+	/* single channel scans are always ok */
+	if (cmd->chanlist_len == 1)
 		return 0;
-	}
 
-	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/* all input must be diff */
-	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/* all input must be bipolar */
-	if (n_chan > 1)
-		for (i = 1; i < n_chan; i++) {	/* check S.E/diff */
-			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
-			    (differencial)) {
-				dev_err(dev->class_dev,
-					"Differential and single ended inputs can't be mixed!\n");
-				return 0;
-			}
-			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
-			    (bipolar)) {
-				dev_err(dev->class_dev,
-					"Bipolar and unipolar ranges can't be mixed!\n");
-				return 0;
-			}
-			if (!devpriv->usemux && differencial &&
-			    (CR_CHAN(chanlist[i]) >= (s->n_chan / 2))) {
-				dev_err(dev->class_dev,
-					"AREF_DIFF is only available for the first 8 channels!\n");
-				return 0;
-			}
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+		unsigned int aref = CR_AREF(cmd->chanlist[i]);
+
+		if (aref != aref0) {
+			dev_err(dev->class_dev,
+				"Differential and single ended inputs can't be mixed!\n");
+			return -EINVAL;
+		}
+		if (comedi_range_is_bipolar(s, range) !=
+		    comedi_range_is_bipolar(s, range0)) {
+			dev_err(dev->class_dev,
+				"Bipolar and unipolar ranges can't be mixed!\n");
+			return -EINVAL;
+		}
+		if (!devpriv->usemux && aref == AREF_DIFF &&
+		    (chan >= (s->n_chan / 2))) {
+			dev_err(dev->class_dev,
+				"AREF_DIFF is only available for the first 8 channels!\n");
+			return -EINVAL;
 		}
+	}
 
-	return 1;
+	return 0;
 }
 
 static void pci9118_set_chanlist(struct comedi_device *dev,
@@ -940,6 +933,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_8254 *pacer = dev->pacer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
+	unsigned int scanlen;
 
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
@@ -1025,19 +1019,20 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 	}
 	/* well, we now know what must be all added */
-	devpriv->ai_n_realscanlen =	/*
-					 * what we must take from card in real
-					 * to have cmd->scan_end_arg on output?
-					 */
-	    (devpriv->ai_add_front + cmd->chanlist_len +
-	     devpriv->ai_add_back) * (cmd->scan_end_arg /
-				      cmd->chanlist_len);
-
-	/* check and setup channel list */
-	if (!check_channel_list(dev, s, cmd->chanlist_len,
-				cmd->chanlist, devpriv->ai_add_front,
-				devpriv->ai_add_back))
+	scanlen = devpriv->ai_add_front + cmd->chanlist_len +
+		  devpriv->ai_add_back;
+	/*
+	 * what we must take from card in real to have cmd->scan_end_arg
+	 * on output?
+	 */
+	devpriv->ai_n_realscanlen = scanlen *
+				    (cmd->scan_end_arg / cmd->chanlist_len);
+
+	if (scanlen > s->len_chanlist) {
+		dev_err(dev->class_dev,
+			"range/channel list is too long for actual configuration!\n");
 		return -EINVAL;
+	}
 
 	/*
 	 * Configure analog input and load the chanlist.
@@ -1307,10 +1302,13 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
+	/* Step 5: check channel list if it exists */
+
 	if (cmd->chanlist)
-		if (!check_channel_list(dev, s, cmd->chanlist_len,
-					cmd->chanlist, 0, 0))
-			return 5;	/* incorrect channels list */
+		err |= pci9118_ai_check_chanlist(dev, s, cmd);
+
+	if (err)
+		return 5;
 
 	return 0;
 }

commit 7c999314efef94be997b762bc22f0be55e139df8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:12:57 2015 -0700

    staging: comedi: adl_pci9118: remove unnecessary check in check_channel_list()
    
    Step 3 of the AI (*do_cmdtest) validates that the cmd->chanlist_len is >= 1. If
    it's not the (*do_cmdtest) fails and check_channel_list() is never called. This
    This function is also called by the AI (*do_cmd) and the comedi core ensures
    that the async command has a valid chanlist. Remove the unnecessary 'n_chan'
    check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a7c974423a3e..dcfe5cc08220 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -303,11 +303,6 @@ static int check_channel_list(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, differencial = 0, bipolar = 0;
 
-	/* correct channel and range number check itself comedi/range.c */
-	if (n_chan < 1) {
-		dev_err(dev->class_dev, "range/channel list is empty!\n");
-		return 0;
-	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
 		dev_err(dev->class_dev,
 			"range/channel list is too long for actual configuration!\n");

commit 323538b825d4b1eb6c8a9022998822898ab52dff
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 13:12:56 2015 -0700

    staging: comedi: adl_pci9118: TRIG_INT is not vaild for scan_begin_src
    
    The (*do_cmdtest) in this driver validated the scan_begin_src as being
    TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT. The TRIG_INT source is not valid.
    
    Remove the Step 2 mutual compatibility check that makes sure that TRIG_INT
    is only used for the start_src or the scan_begin_src.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e5e0e1c4e50b..a7c974423a3e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1205,9 +1205,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
 		err |= -EINVAL;
 
-	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT)
-		err |= -EINVAL;
-
 	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
 	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))
 		err |= -EINVAL;

commit eb12dfc93a0e3021fc61959b6887dfe68daa8234
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 9 11:09:35 2015 -0700

    staging: comedi: adl_pci9118: rename Compute_and_setup_dma()
    
    Rename this CamelCase function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 87746983783f..e5e0e1c4e50b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -816,8 +816,8 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-static int Compute_and_setup_dma(struct comedi_device *dev,
-				 struct comedi_subdevice *s)
+static int pci9118_ai_setup_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1141,7 +1141,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_act_dmapos = 0;
 
 	if (devpriv->usedma) {
-		Compute_and_setup_dma(dev, s);
+		pci9118_ai_setup_dma(dev, s);
 
 		outl(0x02000000 | AINT_WRITE_COMPL,
 		     devpriv->iobase_a + AMCC_OP_REG_INTCSR);

commit 7db6ed68cae2c5b24d2a41a085c42f092efc3c93
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 9 11:09:34 2015 -0700

    staging: comedi: adl_pci9118: prefer using the BIT macro
    
    As suggested by checkpatch.pl, use the BIT macro to define the
    register bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index fb3043dcfff1..87746983783f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -96,24 +96,24 @@
 #define PCI9118_AI_FIFO_REG		0x10
 #define PCI9118_AO_REG(x)		(0x10 + ((x) * 4))
 #define PCI9118_AI_STATUS_REG		0x18
-#define PCI9118_AI_STATUS_NFULL		(1 << 8)  /* 0=FIFO full (fatal) */
-#define PCI9118_AI_STATUS_NHFULL	(1 << 7)  /* 0=FIFO half full */
-#define PCI9118_AI_STATUS_NEPTY		(1 << 6)  /* 0=FIFO empty */
-#define PCI9118_AI_STATUS_ACMP		(1 << 5)  /* 1=about trigger complete */
-#define PCI9118_AI_STATUS_DTH		(1 << 4)  /* 1=ext. digital trigger */
-#define PCI9118_AI_STATUS_BOVER		(1 << 3)  /* 1=burst overrun (fatal) */
-#define PCI9118_AI_STATUS_ADOS		(1 << 2)  /* 1=A/D over speed (warn) */
-#define PCI9118_AI_STATUS_ADOR		(1 << 1)  /* 1=A/D overrun (fatal) */
-#define PCI9118_AI_STATUS_ADRDY		(1 << 0)  /* 1=A/D ready */
+#define PCI9118_AI_STATUS_NFULL		BIT(8)	/* 0=FIFO full (fatal) */
+#define PCI9118_AI_STATUS_NHFULL	BIT(7)	/* 0=FIFO half full */
+#define PCI9118_AI_STATUS_NEPTY		BIT(6)	/* 0=FIFO empty */
+#define PCI9118_AI_STATUS_ACMP		BIT(5)	/* 1=about trigger complete */
+#define PCI9118_AI_STATUS_DTH		BIT(4)	/* 1=ext. digital trigger */
+#define PCI9118_AI_STATUS_BOVER		BIT(3)	/* 1=burst overrun (fatal) */
+#define PCI9118_AI_STATUS_ADOS		BIT(2)	/* 1=A/D over speed (warn) */
+#define PCI9118_AI_STATUS_ADOR		BIT(1)	/* 1=A/D overrun (fatal) */
+#define PCI9118_AI_STATUS_ADRDY		BIT(0)	/* 1=A/D ready */
 #define PCI9118_AI_CTRL_REG		0x18
-#define PCI9118_AI_CTRL_UNIP		(1 << 7)  /* 1=unipolar */
-#define PCI9118_AI_CTRL_DIFF		(1 << 6)  /* 1=differential inputs */
-#define PCI9118_AI_CTRL_SOFTG		(1 << 5)  /* 1=8254 software gate */
-#define PCI9118_AI_CTRL_EXTG		(1 << 4)  /* 1=8254 TGIN(pin 46) gate */
-#define PCI9118_AI_CTRL_EXTM		(1 << 3)  /* 1=ext. trigger (pin 44) */
-#define PCI9118_AI_CTRL_TMRTR		(1 << 2)  /* 1=8254 is trigger source */
-#define PCI9118_AI_CTRL_INT		(1 << 1)  /* 1=enable interrupt */
-#define PCI9118_AI_CTRL_DMA		(1 << 0)  /* 1=enable DMA */
+#define PCI9118_AI_CTRL_UNIP		BIT(7)	/* 1=unipolar */
+#define PCI9118_AI_CTRL_DIFF		BIT(6)	/* 1=differential inputs */
+#define PCI9118_AI_CTRL_SOFTG		BIT(5)	/* 1=8254 software gate */
+#define PCI9118_AI_CTRL_EXTG		BIT(4)	/* 1=8254 TGIN(pin 46) gate */
+#define PCI9118_AI_CTRL_EXTM		BIT(3)	/* 1=ext. trigger (pin 44) */
+#define PCI9118_AI_CTRL_TMRTR		BIT(2)	/* 1=8254 is trigger source */
+#define PCI9118_AI_CTRL_INT		BIT(1)	/* 1=enable interrupt */
+#define PCI9118_AI_CTRL_DMA		BIT(0)	/* 1=enable DMA */
 #define PCI9118_DIO_REG			0x1c
 #define PCI9118_SOFTTRG_REG		0x20
 #define PCI9118_AI_CHANLIST_REG		0x24
@@ -122,20 +122,20 @@
 #define PCI9118_AI_BURST_NUM_REG	0x28
 #define PCI9118_AI_AUTOSCAN_MODE_REG	0x2c
 #define PCI9118_AI_CFG_REG		0x30
-#define PCI9118_AI_CFG_PDTRG		(1 << 7)  /* 1=positive trigger */
-#define PCI9118_AI_CFG_PETRG		(1 << 6)  /* 1=positive ext. trigger */
-#define PCI9118_AI_CFG_BSSH		(1 << 5)  /* 1=with sample & hold */
-#define PCI9118_AI_CFG_BM		(1 << 4)  /* 1=burst mode */
-#define PCI9118_AI_CFG_BS		(1 << 3)  /* 1=burst mode start */
-#define PCI9118_AI_CFG_PM		(1 << 2)  /* 1=post trigger */
-#define PCI9118_AI_CFG_AM		(1 << 1)  /* 1=about trigger */
-#define PCI9118_AI_CFG_START		(1 << 0)  /* 1=trigger start */
+#define PCI9118_AI_CFG_PDTRG		BIT(7)	/* 1=positive trigger */
+#define PCI9118_AI_CFG_PETRG		BIT(6)	/* 1=positive ext. trigger */
+#define PCI9118_AI_CFG_BSSH		BIT(5)	/* 1=with sample & hold */
+#define PCI9118_AI_CFG_BM		BIT(4)	/* 1=burst mode */
+#define PCI9118_AI_CFG_BS		BIT(3)	/* 1=burst mode start */
+#define PCI9118_AI_CFG_PM		BIT(2)	/* 1=post trigger */
+#define PCI9118_AI_CFG_AM		BIT(1)	/* 1=about trigger */
+#define PCI9118_AI_CFG_START		BIT(0)	/* 1=trigger start */
 #define PCI9118_FIFO_RESET_REG		0x34
 #define PCI9118_INT_CTRL_REG		0x38
-#define PCI9118_INT_CTRL_TIMER		(1 << 3)  /* timer interrupt */
-#define PCI9118_INT_CTRL_ABOUT		(1 << 2)  /* about trigger complete */
-#define PCI9118_INT_CTRL_HFULL		(1 << 1)  /* A/D FIFO half full */
-#define PCI9118_INT_CTRL_DTRG		(1 << 0)  /* ext. digital trigger */
+#define PCI9118_INT_CTRL_TIMER		BIT(3)	/* timer interrupt */
+#define PCI9118_INT_CTRL_ABOUT		BIT(2)	/* about trigger complete */
+#define PCI9118_INT_CTRL_HFULL		BIT(1)	/* A/D FIFO half full */
+#define PCI9118_INT_CTRL_DTRG		BIT(0)	/* ext. digital trigger */
 
 #define START_AI_EXT	0x01	/* start measure on external trigger */
 #define STOP_AI_EXT	0x02	/* stop measure on external trigger */

commit 94fff03def69fa26b85057f2a57e186ea7310946
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:13:57 2015 +0000

    staging: comedi: adl_pci9118: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index eb4a528b6431..fb3043dcfff1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -82,7 +82,6 @@
 
 #include "amcc_s5933.h"
 #include "comedi_8254.h"
-#include "comedi_fc.h"
 
 #define IORANGE_9118	64	/* I hope */
 #define PCI9118_CHANLEN	255	/*
@@ -1174,21 +1173,21 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src,
+	err |= comedi_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_EXT | TRIG_INT);
 
 	flags = TRIG_FOLLOW;
 	if (devpriv->master)
 		flags |= TRIG_TIMER | TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);
 
 	flags = TRIG_TIMER | TRIG_EXT;
 	if (devpriv->master)
 		flags |= TRIG_NOW;
-	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
+	err |= comedi_check_trigger_src(&cmd->convert_src, flags);
 
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src,
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src,
 					TRIG_COUNT | TRIG_NONE | TRIG_EXT);
 
 	if (err)
@@ -1196,10 +1195,10 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -1228,7 +1227,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	switch (cmd->start_src) {
 	case TRIG_NOW:
 	case TRIG_EXT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_INT:
 		/* start_arg is the internal trigger (any value) */
@@ -1236,7 +1235,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	}
 
 	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
 	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
@@ -1245,34 +1244,37 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 		cmd->scan_begin_arg = 0;
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 devpriv->ai_ns_min);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    devpriv->ai_ns_min);
+	}
 
-	if (cmd->scan_begin_src == TRIG_EXT)
+	if (cmd->scan_begin_src == TRIG_EXT) {
 		if (cmd->scan_begin_arg) {
 			cmd->scan_begin_arg = 0;
 			err |= -EINVAL;
-			err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg,
-							 65535);
+			err |= comedi_check_trigger_arg_max(&cmd->scan_end_arg,
+							    65535);
 		}
+	}
 
-	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 devpriv->ai_ns_min);
+	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    devpriv->ai_ns_min);
+	}
 
 	if (cmd->convert_src == TRIG_EXT)
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
 
-	err |= cfc_check_trigger_arg_min(&cmd->scan_end_arg,
-					 cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->scan_end_arg,
+					    cmd->chanlist_len);
 
 	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
 		cmd->scan_end_arg =
@@ -1288,13 +1290,13 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		arg = cmd->convert_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER &&
 		    cmd->convert_src == TRIG_NOW) {
@@ -1304,8 +1306,9 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			} else {
 				arg = cmd->convert_arg * cmd->chanlist_len;
 			}
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 arg);
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    arg);
 		}
 	}
 

commit b2ad146af57a9e0eb758c75b32e09091fff00a73
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:37 2015 +0000

    staging: comedi: adl_pci9118: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 65b702cc04c1..eb4a528b6431 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -73,13 +73,12 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "amcc_s5933.h"
 #include "comedi_8254.h"

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 1cd54556a2dd..65b702cc04c1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -633,7 +633,6 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 			array[i] ^= 0x8000;
 		else
 			array[i] = (array[i] >> 4) & 0x0fff;
-
 	}
 }
 

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4b604423635f..1cd54556a2dd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -936,7 +936,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 /* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
 	pci9118_amcc_dma_ena(dev, true);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,
-			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 						/* allow bus mastering */
 
 	return 0;

commit a9da9d20576685b7b3818013d5e1de2367bcff8b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:53 2015 -0700

    staging: comedi: adl_pci9118: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f61e392c2d3e..4b604423635f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -82,7 +82,7 @@
 #include "../comedidev.h"
 
 #include "amcc_s5933.h"
-#include "8253.h"
+#include "comedi_8254.h"
 #include "comedi_fc.h"
 
 #define IORANGE_9118	64	/* I hope */
@@ -94,8 +94,7 @@
 /*
  * PCI BAR2 Register map (dev->iobase)
  */
-#define PCI9118_TIMER_REG(x)		(0x00 + ((x) * 4))
-#define PCI9118_TIMER_CTRL_REG		0x0c
+#define PCI9118_TIMER_BASE		0x00
 #define PCI9118_AI_FIFO_REG		0x10
 #define PCI9118_AO_REG(x)		(0x10 + ((x) * 4))
 #define PCI9118_AI_STATUS_REG		0x18
@@ -239,10 +238,6 @@ struct pci9118_private {
 					 * measure can start/stop
 					 * on external trigger
 					 */
-	unsigned int ai_divisor1, ai_divisor2;	/*
-						 * divisors for start of measure
-						 * on external start
-						 */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	struct pci9118_dmabuf dmabuf[2];
 	int softsshdelay;		/*
@@ -297,24 +292,6 @@ static void pci9118_amcc_int_ena(struct comedi_device *dev, bool enable)
 	outl(intcsr, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 }
 
-static void pci9118_timer_write(struct comedi_device *dev,
-				unsigned int timer, unsigned int val)
-{
-	outl(val & 0xff, dev->iobase + PCI9118_TIMER_REG(timer));
-	outl((val >> 8) & 0xff, dev->iobase + PCI9118_TIMER_REG(timer));
-}
-
-static void pci9118_timer_set_mode(struct comedi_device *dev,
-				   unsigned int timer, unsigned int mode)
-{
-	unsigned int val;
-
-	val = timer << 6;	/* select timer */
-	val |= 0x30;		/* load low then high byte */
-	val |= mode;		/* set timer mode and BCD|binary */
-	outl(val, dev->iobase + PCI9118_TIMER_CTRL_REG);
-}
-
 static void pci9118_ai_reset_fifo(struct comedi_device *dev)
 {
 	/* writing any value resets the A/D FIFO */
@@ -440,8 +417,8 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev,
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
 			  PCI9118_AI_CFG_AM;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-	pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
+	comedi_8254_load(dev->pacer, 0, dmabuf->hw >> 1,
+			 I8254_MODE0 | I8254_BINARY);
 	devpriv->ai_cfg |= PCI9118_AI_CFG_START;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 }
@@ -577,15 +554,16 @@ static void pci9118_calc_divisors(struct comedi_device *dev,
 				  unsigned int *div1, unsigned int *div2,
 				  unsigned int chnsshfront)
 {
+	struct comedi_8254 *pacer = dev->pacer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	*div1 = *tim2 / I8254_OSC_BASE_4MHZ;	/* convert timer (burst) */
-	*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
+	*div1 = *tim2 / pacer->osc_base;	/* convert timer (burst) */
+	*div2 = *tim1 / pacer->osc_base;	/* scan timer */
 	*div2 = *div2 / *div1;			/* major timer is c1*c2 */
 	if (*div2 < chans)
 		*div2 = chans;
 
-	*tim2 = *div1 * I8254_OSC_BASE_4MHZ;	/* real convert timer */
+	*tim2 = *div1 * pacer->osc_base;	/* real convert timer */
 
 	if (cmd->convert_src == TRIG_NOW && !chnsshfront) {
 		/* use BSSH signal */
@@ -593,21 +571,13 @@ static void pci9118_calc_divisors(struct comedi_device *dev,
 			*div2 = chans + 2;
 	}
 
-	*tim1 = *div1 * *div2 * I8254_OSC_BASE_4MHZ;
+	*tim1 = *div1 * *div2 * pacer->osc_base;
 }
 
 static void pci9118_start_pacer(struct comedi_device *dev, int mode)
 {
-	struct pci9118_private *devpriv = dev->private;
-
-	pci9118_timer_set_mode(dev, 1, I8254_MODE2);
-	pci9118_timer_set_mode(dev, 2, I8254_MODE2);
-	udelay(1);
-
-	if ((mode == 1) || (mode == 2) || (mode == 4)) {
-		pci9118_timer_write(dev, 2, devpriv->ai_divisor2);
-		pci9118_timer_write(dev, 1, devpriv->ai_divisor1);
-	}
+	if (mode == 1 || mode == 2 || mode == 4)
+		comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
 }
 
 static int pci9118_ai_cancel(struct comedi_device *dev,
@@ -618,7 +588,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	if (devpriv->usedma)
 		pci9118_amcc_dma_ena(dev, false);
 	pci9118_exttrg_enable(dev, false);
-	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
+	comedi_8254_pacer_enable(dev->pacer, 1, 2, false);
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
@@ -975,6 +945,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_8254 *pacer = dev->pacer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
 
@@ -1093,12 +1064,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		else
 			devpriv->ai_do = 1;
 
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  &devpriv->ai_divisor1,
-					  &devpriv->ai_divisor2,
-					  &cmd->convert_arg,
-					  devpriv->ai_flags &
-					  CMDF_ROUND_NEAREST);
+		comedi_8254_cascade_ns_to_timer(pacer, &cmd->convert_arg,
+						devpriv->ai_flags &
+						CMDF_ROUND_NEAREST);
+		comedi_8254_update_divisors(pacer);
 
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
 
@@ -1112,8 +1081,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 			devpriv->ai_cfg |= PCI9118_AI_CFG_AM;
 			outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-			pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-			pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
+			comedi_8254_load(pacer, 0, dmabuf->hw >> 1,
+					 I8254_MODE0 | I8254_BINARY);
 			devpriv->ai_cfg |= PCI9118_AI_CFG_START;
 		}
 	}
@@ -1133,8 +1102,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      &cmd->scan_begin_arg, &cmd->convert_arg,
 				      devpriv->ai_flags,
 				      devpriv->ai_n_realscanlen,
-				      &devpriv->ai_divisor1,
-				      &devpriv->ai_divisor2,
+				      &pacer->divisor1,
+				      &pacer->divisor2,
 				      devpriv->ai_add_front);
 
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
@@ -1162,8 +1131,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->usedma)
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_DMA;
 
-	pci9118_start_pacer(dev, -1);	/* stop pacer */
-
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
@@ -1206,7 +1173,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	unsigned int flags;
 	unsigned int arg;
-	unsigned int divisor1 = 0, divisor2 = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -1323,17 +1289,13 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  &divisor1, &divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  &divisor1, &divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER &&
@@ -1482,10 +1444,6 @@ static void pci9118_reset(struct comedi_device *dev)
 	inl(dev->iobase + PCI9118_INT_CTRL_REG);
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
 
-	/* reset and stop counters */
-	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-	pci9118_start_pacer(dev, 0);
-
 	/* reset DMA and scan queue */
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
@@ -1590,6 +1548,11 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	devpriv->iobase_a = pci_resource_start(pcidev, 0);
 	dev->iobase = pci_resource_start(pcidev, 2);
 
+	dev->pacer = comedi_8254_init(dev->iobase + PCI9118_TIMER_BASE,
+				      I8254_OSC_BASE_4MHZ, I8254_IO32, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	pci9118_reset(dev);
 
 	if (pcidev->irq) {

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 26603582e71a..f61e392c2d3e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -749,13 +749,13 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 
 	if (intcsr & MASTER_ABORT_INT) {
 		dev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
 		goto interrupt_exit;
 	}
 
 	if (intcsr & TARGET_ABORT_INT) {
 		dev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
 		goto interrupt_exit;
 	}
 

commit e87f65b238a6c1e76776469d92190f6c46c5817f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 27 11:37:19 2014 +0000

    staging: comedi: adl_pci9118: eliminate DMA buffer defragmentation step
    
    The DMA operations used by the driver may have been set up to acquire
    data from unwanted channels in addition to the wanted channels.
    Currently, `interrupt_pci9118_ai_dma()` calls `defragment_dma_buffer()`
    to move all the wanted data to the start of the DMA buffer and then
    calls `comedi_buf_write_samples()` to copy it all to the comedi async
    buffer.  Those two functions used to be called from
    `move_block_from_dma()` which was absorbed into
    `interrupt_pci9118_ai_dma()`.
    
    Reinstate `move_block_from_dma()` but rewrite it to copy data directly
    from the wanted fragments of the DMA buffer to the comedi async buffer
    without defragmenting the buffer first.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c0ea7335ed38..26603582e71a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -502,29 +502,56 @@ static unsigned int valid_samples_in_act_dma_buf(struct comedi_device *dev,
 	return n_samples;
 }
 
-static unsigned int defragment_dma_buffer(struct comedi_device *dev,
-					  struct comedi_subdevice *s,
-					  unsigned short *dma_buffer,
-					  unsigned int num_samples)
+static void move_block_from_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned short *dma_buffer,
+				unsigned int n_raw_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int i = 0, j = 0;
-	unsigned int start_pos = devpriv->ai_add_front,
-	    stop_pos = devpriv->ai_add_front + cmd->chanlist_len;
-	unsigned int raw_scanlen = devpriv->ai_add_front + cmd->chanlist_len +
-	    devpriv->ai_add_back;
+	unsigned int start_pos = devpriv->ai_add_front;
+	unsigned int stop_pos = start_pos + cmd->chanlist_len;
+	unsigned int span_len = stop_pos + devpriv->ai_add_back;
+	unsigned int dma_pos = devpriv->ai_act_dmapos;
+	unsigned int x;
 
-	for (i = 0; i < num_samples; i++) {
-		if (devpriv->ai_act_dmapos >= start_pos &&
-		    devpriv->ai_act_dmapos < stop_pos) {
-			dma_buffer[j++] = dma_buffer[i];
+	if (span_len == cmd->chanlist_len) {
+		/* All samples are to be copied. */
+		comedi_buf_write_samples(s, dma_buffer, n_raw_samples);
+		dma_pos += n_raw_samples;
+	} else {
+		/*
+		 * Not all samples are to be copied.  Buffer contents consist
+		 * of a possibly non-whole number of spans and a region of
+		 * each span is to be copied.
+		 */
+		while (n_raw_samples) {
+			if (dma_pos < start_pos) {
+				/* Skip samples before start position. */
+				x = start_pos - dma_pos;
+				if (x > n_raw_samples)
+					x = n_raw_samples;
+				dma_pos += x;
+				n_raw_samples -= x;
+				if (!n_raw_samples)
+					break;
+			}
+			if (dma_pos < stop_pos) {
+				/* Copy samples before stop position. */
+				x = stop_pos - dma_pos;
+				if (x > n_raw_samples)
+					x = n_raw_samples;
+				comedi_buf_write_samples(s, dma_buffer, x);
+				dma_pos += x;
+				n_raw_samples -= x;
+			}
+			/* Advance to next span. */
+			start_pos += span_len;
+			stop_pos += span_len;
 		}
-		devpriv->ai_act_dmapos++;
-		devpriv->ai_act_dmapos %= raw_scanlen;
 	}
-
-	return j;
+	/* Update position in span for next time. */
+	devpriv->ai_act_dmapos = dma_pos % span_len;
 }
 
 static void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)
@@ -681,10 +708,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		}
 	}
 
-	if (n_all) {
-		n_valid = defragment_dma_buffer(dev, s, dmabuf->virt, n_all);
-		comedi_buf_write_samples(s, dmabuf->virt, n_valid);
-	}
+	if (n_all)
+		move_block_from_dma(dev, s, dmabuf->virt, n_all);
 
 	if (!devpriv->ai_neverending) {
 		if (s->async->scans_done >= cmd->stop_arg)

commit bb4a51a1b5d5acde77f814689aa467304bd942fb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 27 11:37:18 2014 +0000

    staging: comedi: adl_pci9118: try and avoid unnecessary DMA restart
    
    `interrupt_pci9118_ai_dma()` is called on interrupt to transfer data
    from DMA buffers into the comedi async data buffer.  Currently it always
    restarts DMA.  If double buffering, it restarts DMA on the next DMA
    buffer before processing the current DMA buffer, otherwise it restarts
    DMA on the same DMA buffer after it has been processed.
    
    For single buffering we can avoid restarting the DMA transfer by
    checking the async event flags after the current buffer has been
    processed, which is easy.
    
    For double buffering, we need to know how many valid samples there are
    in the current buffer before it has been processed and determine whether
    there is enough to complete the acquisition.  Call new function
    `valid_samples_in_act_dma_buf()` to determine the number of valid
    samples in the current DMA buffer, and compare that with the result of
    `comedi_nsamples_left()` to determine if DMA needs to be restarted.
    (`comedi_nsamples_left()` needs an upper bound to clamp to, so use the
    number of valid samples in the DMA buffer plus one for our test.)
    
    It is still possible for DMA to be restarted unnecessarily in the double
    buffer case if a `COMEDI_CB_OVERFLOW` event occurs while copying to the
    comedi async buffer, but it doesn't really matter.  The ongoing DMA
    operation will get disabled when the subdevice's `cancel()` handler is
    called when the events are handled later in the interrupt service
    routine (as it does currently).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index aecfae891628..c0ea7335ed38 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -446,6 +446,62 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev,
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 }
 
+static unsigned int valid_samples_in_act_dma_buf(struct comedi_device *dev,
+						 struct comedi_subdevice *s,
+						 unsigned int n_raw_samples)
+{
+	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int start_pos = devpriv->ai_add_front;
+	unsigned int stop_pos = start_pos + cmd->chanlist_len;
+	unsigned int span_len = stop_pos + devpriv->ai_add_back;
+	unsigned int dma_pos = devpriv->ai_act_dmapos;
+	unsigned int whole_spans, n_samples, x;
+
+	if (span_len == cmd->chanlist_len)
+		return n_raw_samples;	/* use all samples */
+
+	/*
+	 * Not all samples are to be used.  Buffer contents consist of a
+	 * possibly non-whole number of spans and a region of each span
+	 * is to be used.
+	 *
+	 * Account for samples in whole number of spans.
+	 */
+	whole_spans = n_raw_samples / span_len;
+	n_samples = whole_spans * cmd->chanlist_len;
+	n_raw_samples -= whole_spans * span_len;
+
+	/*
+	 * Deal with remaining samples which could overlap up to two spans.
+	 */
+	while (n_raw_samples) {
+		if (dma_pos < start_pos) {
+			/* Skip samples before start position. */
+			x = start_pos - dma_pos;
+			if (x > n_raw_samples)
+				x = n_raw_samples;
+			dma_pos += x;
+			n_raw_samples -= x;
+			if (!n_raw_samples)
+				break;
+		}
+		if (dma_pos < stop_pos) {
+			/* Include samples before stop position. */
+			x = stop_pos - dma_pos;
+			if (x > n_raw_samples)
+				x = n_raw_samples;
+			n_samples += x;
+			dma_pos += x;
+			n_raw_samples -= x;
+		}
+		/* Advance to next span. */
+		start_pos += span_len;
+		stop_pos += span_len;
+	}
+	return n_samples;
+}
+
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
 					  unsigned short *dma_buffer,
@@ -607,10 +663,16 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];
-	unsigned int nsamples = comedi_bytes_to_samples(s, dmabuf->use_size);
+	unsigned int n_all = comedi_bytes_to_samples(s, dmabuf->use_size);
+	unsigned int n_valid;
+	bool more_dma;
+
+	/* determine whether more DMA buffers to do after this one */
+	n_valid = valid_samples_in_act_dma_buf(dev, s, n_all);
+	more_dma = n_valid < comedi_nsamples_left(s, n_valid + 1);
 
 	/* switch DMA buffers and restart DMA if double buffering */
-	if (devpriv->dma_doublebuf) {
+	if (more_dma && devpriv->dma_doublebuf) {
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
 		pci9118_amcc_setup_dma(dev, devpriv->dma_actbuf);
 		if (devpriv->ai_do == 4) {
@@ -619,10 +681,9 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		}
 	}
 
-	if (nsamples) {
-		nsamples = defragment_dma_buffer(dev, s, dmabuf->virt,
-						 nsamples);
-		comedi_buf_write_samples(s, dmabuf->virt, nsamples);
+	if (n_all) {
+		n_valid = defragment_dma_buffer(dev, s, dmabuf->virt, n_all);
+		comedi_buf_write_samples(s, dmabuf->virt, n_valid);
 	}
 
 	if (!devpriv->ai_neverending) {
@@ -630,8 +691,11 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 			s->async->events |= COMEDI_CB_EOA;
 	}
 
+	if (s->async->events & COMEDI_CB_CANCEL_MASK)
+		more_dma = false;
+
 	/* restart DMA if not double buffering */
-	if (!devpriv->dma_doublebuf) {
+	if (more_dma && !devpriv->dma_doublebuf) {
 		pci9118_amcc_setup_dma(dev, 0);
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev, 0);

commit ac33c20dadf927b7fc96292810007633805a6fe2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 27 11:37:17 2014 +0000

    staging: comedi: adl_pci9118: simplify interrupt_pci9118_ai_dma() a bit
    
    Eliminate the `next_dma_buf` variable in `interrupt_pci9118_ai_dma()`.
    It holds the next value of `devpriv->dma_actbuf` when double buffering
    is used, but we can just set that to the next value directly at the
    point where the buffers are switched as the old value is not used
    anywhere else.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5e0ff9db6a47..aecfae891628 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -608,16 +608,15 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];
 	unsigned int nsamples = comedi_bytes_to_samples(s, dmabuf->use_size);
-	unsigned int next_dma_buf;
 
-	if (devpriv->dma_doublebuf) {	/*
-					 * switch DMA buffers if is used
-					 * double buffering
-					 */
-		next_dma_buf = 1 - devpriv->dma_actbuf;
-		pci9118_amcc_setup_dma(dev, next_dma_buf);
-		if (devpriv->ai_do == 4)
-			interrupt_pci9118_ai_mode4_switch(dev, next_dma_buf);
+	/* switch DMA buffers and restart DMA if double buffering */
+	if (devpriv->dma_doublebuf) {
+		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
+		pci9118_amcc_setup_dma(dev, devpriv->dma_actbuf);
+		if (devpriv->ai_do == 4) {
+			interrupt_pci9118_ai_mode4_switch(dev,
+							  devpriv->dma_actbuf);
+		}
 	}
 
 	if (nsamples) {
@@ -631,11 +630,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 			s->async->events |= COMEDI_CB_EOA;
 	}
 
-	if (devpriv->dma_doublebuf) {
-		/* switch dma buffers */
-		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
-	} else {
-		/* restart DMA if is not used double buffering */
+	/* restart DMA if not double buffering */
+	if (!devpriv->dma_doublebuf) {
 		pci9118_amcc_setup_dma(dev, 0);
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev, 0);

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 498e0c7775e5..5e0ff9db6a47 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1588,7 +1588,6 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar10;
 	s->insn_write	= pci9118_ao_insn_write;
-	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit f6266a41d820feaa7b7febe122b285e336e40bfd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 17:57:56 2014 -0700

    staging: comedi: adl_pci9118: use comedi_bytes_to_samples()
    
    Remove the assumption of the sample size by using the comedi_bytes_to_samples()
    helper function to convert the number of bytes to the number of samples.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b527748658f0..498e0c7775e5 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -607,11 +607,9 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];
-	unsigned int nsamples;
+	unsigned int nsamples = comedi_bytes_to_samples(s, dmabuf->use_size);
 	unsigned int next_dma_buf;
 
-	nsamples = dmabuf->use_size >> 1;	/* number of received samples */
-
 	if (devpriv->dma_doublebuf) {	/*
 					 * switch DMA buffers if is used
 					 * double buffering

commit e57bfa673c3056747f8014b956e6fbed02f917d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 17:57:55 2014 -0700

    staging: comedi: adl_pci9118: absorb move_block_from_dma()
    
    Absorb this simple helper function into interrupt_pci9118_ai_dma().
    
    Remove the unnecessary local variables 'sampls' and 'm'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 971235402289..b527748658f0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -471,15 +471,6 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 	return j;
 }
 
-static void move_block_from_dma(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				unsigned short *dma_buffer,
-				unsigned int num_samples)
-{
-	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
-	comedi_buf_write_samples(s, dma_buffer, num_samples);
-}
-
 static void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -616,9 +607,10 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];
-	unsigned int next_dma_buf, samplesinbuf, sampls, m;
+	unsigned int nsamples;
+	unsigned int next_dma_buf;
 
-	samplesinbuf = dmabuf->use_size >> 1;	/* number of received samples */
+	nsamples = dmabuf->use_size >> 1;	/* number of received samples */
 
 	if (devpriv->dma_doublebuf) {	/*
 					 * switch DMA buffers if is used
@@ -630,12 +622,10 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 			interrupt_pci9118_ai_mode4_switch(dev, next_dma_buf);
 	}
 
-	if (samplesinbuf) {
-		/* how many samples is to end of buffer */
-		m = s->async->prealloc_bufsz >> 1;
-		sampls = m;
-		move_block_from_dma(dev, s, dmabuf->virt, samplesinbuf);
-		m = m - sampls;		/* m=how many samples was transferred */
+	if (nsamples) {
+		nsamples = defragment_dma_buffer(dev, s, dmabuf->virt,
+						 nsamples);
+		comedi_buf_write_samples(s, dmabuf->virt, nsamples);
 	}
 
 	if (!devpriv->ai_neverending) {

commit 6250d982ee02ba44c230b7fb6f17432732a7a0fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Nov 10 17:57:54 2014 -0700

    staging: comedi: adl_pci9118: use comedi_async 'scans_done' to detect EOA
    
    The comedi core now counts the number of samples added to the async buffer and
    detects the end-of-scan and increments the comedi_async 'scans_done' counter.
    
    Remove the private data member 'ai_act_scan' and use the 'scans_done' member
    to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2aef881b6ee4..971235402289 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -221,7 +221,6 @@ struct pci9118_private {
 	unsigned char int_ctrl;
 	unsigned char ai_cfg;
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
-	unsigned int ai_act_scan;	/* how many scans we finished */
 	unsigned int ai_n_realscanlen;	/*
 					 * what we must transfer for one
 					 * outgoing scan include front/back adds
@@ -477,13 +476,7 @@ static void move_block_from_dma(struct comedi_device *dev,
 				unsigned short *dma_buffer,
 				unsigned int num_samples)
 {
-	struct pci9118_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
-	devpriv->ai_act_scan +=
-	    (s->async->cur_chan + num_samples) / cmd->scan_end_arg;
-
 	comedi_buf_write_samples(s, dma_buffer, num_samples);
 }
 
@@ -571,7 +564,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
 
-	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
 	s->async->inttrig = NULL;
 	devpriv->ai_neverending = 0;
@@ -612,13 +604,9 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 
 	comedi_buf_write_samples(s, &sampl, 1);
 
-	if (s->async->cur_chan == 0) {
-		devpriv->ai_act_scan++;
-		if (!devpriv->ai_neverending) {
-			/* all data sampled? */
-			if (devpriv->ai_act_scan >= cmd->stop_arg)
-				s->async->events |= COMEDI_CB_EOA;
-		}
+	if (!devpriv->ai_neverending) {
+		if (s->async->scans_done >= cmd->stop_arg)
+			s->async->events |= COMEDI_CB_EOA;
 	}
 }
 
@@ -651,8 +639,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	}
 
 	if (!devpriv->ai_neverending) {
-		/* all data sampled? */
-		if (devpriv->ai_act_scan >= cmd->stop_arg)
+		if (s->async->scans_done >= cmd->stop_arg)
 			s->async->events |= COMEDI_CB_EOA;
 	}
 
@@ -1114,7 +1101,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
 	inl(dev->iobase + PCI9118_INT_CTRL_REG);
 
-	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
 
 	if (devpriv->usedma) {

commit 1d3d32a7525bbc9c989f8c3e592dc206ee8b145a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:33 2014 -0700

    staging: comedi: adl_pci9118: use sample manipulation helpers
    
    Use the recently added sample manipulation helpers to remove the hardcoded
    assumption of the sample size.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 93b41e6712a6..2aef881b6ee4 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -586,8 +586,9 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 			     unsigned int start_chan_index)
 {
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, num_samples = num_bytes / sizeof(short);
 	unsigned short *array = data;
+	unsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);
+	unsigned int i;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)

commit f8736ca466e2014d6e8bad478fcc5e5cb0105af0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 09:49:31 2014 -0700

    staging: comedi: drivers: move comedi_async 'cur_chan' tracking into the core
    
    The commedi_async 'cur_chan' member is used to track the current position
    in the chanlist for a scan. Currently only a couple comedi drivers use
    this member.
    
    For aeshtetics, move the 'cur_chan' tracking into the core for non-SDF_PACKED
    subdevices. The 'cur_chan' will be updated after reading or writing samples
    to the async buffer by comedi_inc_scan_progress(). All non-SDF_PACKED subdevices
    will then automatiaclly track the 'cur_chan'.
    
    Some of the drivers use the 'cur_chan' to detect the end of scan event when
    counting scans. The COMEDI_CB_EOS event is automatically added by the core
    when the end of scan is detected. The drivers just need to check if the
    'cur_chan' is 0 to count the number of scans completed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 83c381357c14..93b41e6712a6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -483,8 +483,6 @@ static void move_block_from_dma(struct comedi_device *dev,
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
 	devpriv->ai_act_scan +=
 	    (s->async->cur_chan + num_samples) / cmd->scan_end_arg;
-	s->async->cur_chan += num_samples;
-	s->async->cur_chan %= cmd->scan_end_arg;
 
 	comedi_buf_write_samples(s, dma_buffer, num_samples);
 }
@@ -612,10 +610,8 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	sampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 
 	comedi_buf_write_samples(s, &sampl, 1);
-	s->async->cur_chan++;
-	if (s->async->cur_chan >= cmd->scan_end_arg) {
-							/* one scan done */
-		s->async->cur_chan %= cmd->scan_end_arg;
+
+	if (s->async->cur_chan == 0) {
 		devpriv->ai_act_scan++;
 		if (!devpriv->ai_neverending) {
 			/* all data sampled? */

commit a7d3de75cf00574f8d360d51d0e1beb3c561cc89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:21:54 2014 -0700

    staging: comedi: drivers do not need to reset the async->cur_chan
    
    The comedi core calls comedi_buf_reset() before starting an async command
    (*do_cmd) and after returning a subdevice to an idle state (*cancel).
    
    The drivers do not need to reset the async->cur_chan in those functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cb2c48522efd..83c381357c14 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -575,7 +575,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 
 	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
-	s->async->cur_chan = 0;
 	s->async->inttrig = NULL;
 	devpriv->ai_neverending = 0;
 	devpriv->dma_actbuf = 0;
@@ -1120,7 +1119,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
-	s->async->cur_chan = 0;
 
 	if (devpriv->usedma) {
 		Compute_and_setup_dma(dev, s);

commit 28e8c8984c95202cf09ee3d27becf4d1494350ee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:34 2014 -0700

    staging: comedi: adl_pci9118: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    The number of bytes to add is determined automatically based on the
    number of samples and the bytes_per_sample().
    
    Change the return type of move_block_from_dma() to void and remove the
    unnecessary check of the return value of comedi_buf_write_samples().
    The callers don't check the return and it's really not necessary. If
    comedi_buf_write_samples() fails to allocate enough space in the async
    buffer to add all the samples it sets the COMEDI_CB_OVERFLOW event.
    This will cause the async command to (*cancel) when the events are
    handled.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7b1720f8fb30..cb2c48522efd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -472,26 +472,21 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 	return j;
 }
 
-static int move_block_from_dma(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       unsigned short *dma_buffer,
-			       unsigned int num_samples)
+static void move_block_from_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned short *dma_buffer,
+				unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
 	devpriv->ai_act_scan +=
 	    (s->async->cur_chan + num_samples) / cmd->scan_end_arg;
 	s->async->cur_chan += num_samples;
 	s->async->cur_chan %= cmd->scan_end_arg;
-	num_bytes =
-	    cfc_write_array_to_buffer(s, dma_buffer,
-				      num_samples * sizeof(short));
-	if (num_bytes < num_samples * sizeof(short))
-		return -1;
-	return 0;
+
+	comedi_buf_write_samples(s, dma_buffer, num_samples);
 }
 
 static void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)
@@ -617,7 +612,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 
 	sampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 
-	cfc_write_to_buffer(s, sampl);
+	comedi_buf_write_samples(s, &sampl, 1);
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= cmd->scan_end_arg) {
 							/* one scan done */

commit f5b5164d935ed0a1603a040d631afc6b7004d449
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:15 2014 -0700

    staging: comedi: adl_pci9118: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e18fd9569a2b..7b1720f8fb30 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -766,7 +766,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 		interrupt_pci9118_ai_onesample(dev, s);
 
 interrupt_exit:
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit 75fbdbf61dd9f68a28a5e233ad1ccdda7c6f94e8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 12 10:04:44 2014 +0100

    staging: comedi: adl_pci9118: use dma_alloc_coherent()
    
    Use `dma_alloc_coherent()` to allocate the DMA buffers instead of
    using `__get_free_pages()` to allocate and `virt_to_bus()` to get the
    hardware address.  The coherent buffers are fairly small - at most 4
    pages (although there are two of them).  Use of `virt_to_bus()` is
    discouraged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6ab9e0a27588..e18fd9569a2b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -204,11 +204,10 @@ static const struct pci9118_boardinfo pci9118_boards[] = {
 };
 
 struct pci9118_dmabuf {
-	unsigned long virt;	/* virtual address of buffer */
-	unsigned long hw;	/* hardware (bus) address of buffer */
+	unsigned short *virt;	/* virtual address of buffer */
+	dma_addr_t hw;		/* hardware (bus) address of buffer */
 	unsigned int size;	/* size of dma buffer in bytes */
 	unsigned int use_size;	/* which size we may now use for transfer */
-	int order;		/* log2 number of pages in buffer */
 };
 
 struct pci9118_private {
@@ -475,12 +474,11 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 
 static int move_block_from_dma(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       unsigned long virt_addr,
+			       unsigned short *dma_buffer,
 			       unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned short *dma_buffer = (unsigned short *)virt_addr;
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
@@ -1485,15 +1483,15 @@ static void pci9118_alloc_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
 		for (order = 2; order >= 0; order--) {
-			dmabuf->virt = __get_free_pages(GFP_KERNEL, order);
+			dmabuf->virt =
+			    dma_alloc_coherent(dev->hw_dev, PAGE_SIZE << order,
+					       &dmabuf->hw, GFP_KERNEL);
 			if (dmabuf->virt)
 				break;
 		}
 		if (!dmabuf->virt)
 			break;
-		dmabuf->order = order;
 		dmabuf->size = PAGE_SIZE << order;
-		dmabuf->hw = virt_to_bus((void *)dmabuf->virt);
 
 		if (i == 0)
 			devpriv->master = 1;
@@ -1513,8 +1511,10 @@ static void pci9118_free_dma(struct comedi_device *dev)
 
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
-		if (dmabuf->virt)
-			free_pages(dmabuf->virt, dmabuf->order);
+		if (dmabuf->virt) {
+			dma_free_coherent(dev->hw_dev, dmabuf->size,
+					  dmabuf->virt, dmabuf->hw);
+		}
 	}
 }
 

commit f39f87e9ea944ca07b53d8261ba60bfbf4f097da
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 12 10:04:43 2014 +0100

    staging: comedi: adl_pci9118: don't overallocate DMA buffer
    
    The last parameter of `__get_free_pages()` is log2 (the 'order') of the
    number of pages to be allocated.  This driver seems to think it is the
    linear number of pages, so `pci9118_alloc_dma()` first tries to allocate
    16 pages, but only uses 4 of them, setting the buffer size to PAGE_SIZE
    multiplied by the 'order'.  If the allocation fails, it tries
    progressively smaller orders, down to 0.  If the allocation at order 0
    succeeds, the buffer size is set to 0, which is likely to cause
    problems.
    
    Set the buffer size to `PAGE_SIZE` shifted left by the allocation order.
    Since the maximum buffer size previously used was 4, start with an
    allocation order of 2 instead of 4.  Rename the `pages` member of
    `struct pci9118_dmabuf` (and the local variable in
    `pci9118_alloc_dma()`) to `order` to make it clearer what it is.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 116910401067..6ab9e0a27588 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -208,7 +208,7 @@ struct pci9118_dmabuf {
 	unsigned long hw;	/* hardware (bus) address of buffer */
 	unsigned int size;	/* size of dma buffer in bytes */
 	unsigned int use_size;	/* which size we may now use for transfer */
-	int pages;		/* number of pages in buffer */
+	int order;		/* log2 number of pages in buffer */
 };
 
 struct pci9118_private {
@@ -1479,20 +1479,20 @@ static void pci9118_alloc_dma(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct pci9118_dmabuf *dmabuf;
-	int pages;
+	int order;
 	int i;
 
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
-		for (pages = 4; pages >= 0; pages--) {
-			dmabuf->virt = __get_free_pages(GFP_KERNEL, pages);
+		for (order = 2; order >= 0; order--) {
+			dmabuf->virt = __get_free_pages(GFP_KERNEL, order);
 			if (dmabuf->virt)
 				break;
 		}
 		if (!dmabuf->virt)
 			break;
-		dmabuf->pages = pages;
-		dmabuf->size = PAGE_SIZE * pages;
+		dmabuf->order = order;
+		dmabuf->size = PAGE_SIZE << order;
 		dmabuf->hw = virt_to_bus((void *)dmabuf->virt);
 
 		if (i == 0)
@@ -1514,7 +1514,7 @@ static void pci9118_free_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
 		if (dmabuf->virt)
-			free_pages(dmabuf->virt, dmabuf->pages);
+			free_pages(dmabuf->virt, dmabuf->order);
 	}
 }
 

commit d5733baf238533e9df41d92948e1ace5e0eae1de
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Sep 12 10:04:42 2014 +0100

    staging: comedi: adl_pci9118: don't allocate 2nd DMA buffer on failure
    
    `pci9118_alloc_dma()` tries to allocate two DMA buffers but may allocate
    a single buffer or none at all.  If it fails to allocate the first
    buffer, it still tries to allocate the second buffer, even though it
    won't be used.  Change it to not bother trying to allocate the second
    buffer if the first one fails.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 8d3f81322eae..116910401067 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1489,16 +1489,16 @@ static void pci9118_alloc_dma(struct comedi_device *dev)
 			if (dmabuf->virt)
 				break;
 		}
-		if (dmabuf->virt) {
-			dmabuf->pages = pages;
-			dmabuf->size = PAGE_SIZE * pages;
-			dmabuf->hw = virt_to_bus((void *)dmabuf->virt);
-
-			if (i == 0)
-				devpriv->master = 1;
-			if (i == 1)
-				devpriv->dma_doublebuf = 1;
-		}
+		if (!dmabuf->virt)
+			break;
+		dmabuf->pages = pages;
+		dmabuf->size = PAGE_SIZE * pages;
+		dmabuf->hw = virt_to_bus((void *)dmabuf->virt);
+
+		if (i == 0)
+			devpriv->master = 1;
+		if (i == 1)
+			devpriv->dma_doublebuf = 1;
 	}
 }
 

commit 0220d472dfa98357c5642b9ca80602fad431e046
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:15 2014 +0100

    staging: comedi: adl_pci9118: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 281135876ec9..8d3f81322eae 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1521,7 +1521,7 @@ static void pci9118_free_dma(struct comedi_device *dev)
 static int pci9118_common_attach(struct comedi_device *dev,
 				 int ext_mux, int softsshdelay)
 {
-	const struct pci9118_boardinfo *board = comedi_board(dev);
+	const struct pci9118_boardinfo *board = dev->board_ptr;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pci9118_private *devpriv;
 	struct comedi_subdevice *s;

commit 8c469410741c017137a81f34c161af82a979846e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:55 2014 -0700

    staging: comedi: adl_pci9118: move pci9118_ai_cmdtest()
    
    For aesthetics, move this function closer to the (*do_cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5ab9e79ba3b1..281135876ec9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -800,168 +800,6 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-static int pci9118_ai_cmdtest(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_cmd *cmd)
-{
-	struct pci9118_private *devpriv = dev->private;
-	int err = 0;
-	unsigned int flags;
-	unsigned int arg;
-	unsigned int divisor1 = 0, divisor2 = 0;
-
-	/* Step 1 : check if triggers are trivially valid */
-
-	err |= cfc_check_trigger_src(&cmd->start_src,
-					TRIG_NOW | TRIG_EXT | TRIG_INT);
-
-	flags = TRIG_FOLLOW;
-	if (devpriv->master)
-		flags |= TRIG_TIMER | TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
-
-	flags = TRIG_TIMER | TRIG_EXT;
-	if (devpriv->master)
-		flags |= TRIG_NOW;
-	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
-
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src,
-					TRIG_COUNT | TRIG_NONE | TRIG_EXT);
-
-	if (err)
-		return 1;
-
-	/* Step 2a : make sure trigger sources are unique */
-
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
-
-	/* Step 2b : and mutually compatible */
-
-	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
-		err |= -EINVAL;
-
-	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT)
-		err |= -EINVAL;
-
-	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
-	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))
-		err |= -EINVAL;
-
-	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
-	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT))))
-		err |= -EINVAL;
-
-	if (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
-		err |= -EINVAL;
-
-	if (err)
-		return 2;
-
-	/* Step 3: check if arguments are trivially valid */
-
-	switch (cmd->start_src) {
-	case TRIG_NOW:
-	case TRIG_EXT:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-		break;
-	case TRIG_INT:
-		/* start_arg is the internal trigger (any value) */
-		break;
-	}
-
-	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-
-	if ((cmd->scan_begin_src == TRIG_TIMER) &&
-	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
-		cmd->scan_begin_src = TRIG_FOLLOW;
-		cmd->convert_arg = cmd->scan_begin_arg;
-		cmd->scan_begin_arg = 0;
-	}
-
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 devpriv->ai_ns_min);
-
-	if (cmd->scan_begin_src == TRIG_EXT)
-		if (cmd->scan_begin_arg) {
-			cmd->scan_begin_arg = 0;
-			err |= -EINVAL;
-			err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg,
-							 65535);
-		}
-
-	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 devpriv->ai_ns_min);
-
-	if (cmd->convert_src == TRIG_EXT)
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-
-	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
-	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-
-	err |= cfc_check_trigger_arg_min(&cmd->scan_end_arg,
-					 cmd->chanlist_len);
-
-	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
-		cmd->scan_end_arg =
-		    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);
-		err |= -EINVAL;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		arg = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  &divisor1, &divisor2,
-					  &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
-	}
-
-	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
-		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  &divisor1, &divisor2,
-					  &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
-
-		if (cmd->scan_begin_src == TRIG_TIMER &&
-		    cmd->convert_src == TRIG_NOW) {
-			if (cmd->convert_arg == 0) {
-				arg = devpriv->ai_ns_min *
-				      (cmd->scan_end_arg + 2);
-			} else {
-				arg = cmd->convert_arg * cmd->chanlist_len;
-			}
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 arg);
-		}
-	}
-
-	if (err)
-		return 4;
-
-	if (cmd->chanlist)
-		if (!check_channel_list(dev, s, cmd->chanlist_len,
-					cmd->chanlist, 0, 0))
-			return 5;	/* incorrect channels list */
-
-	return 0;
-}
-
 static int Compute_and_setup_dma(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
@@ -1313,6 +1151,168 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
+static int pci9118_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
+{
+	struct pci9118_private *devpriv = dev->private;
+	int err = 0;
+	unsigned int flags;
+	unsigned int arg;
+	unsigned int divisor1 = 0, divisor2 = 0;
+
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_EXT | TRIG_INT);
+
+	flags = TRIG_FOLLOW;
+	if (devpriv->master)
+		flags |= TRIG_TIMER | TRIG_EXT;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
+
+	flags = TRIG_TIMER | TRIG_EXT;
+	if (devpriv->master)
+		flags |= TRIG_NOW;
+	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
+
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_NONE | TRIG_EXT);
+
+	if (err)
+		return 1;
+
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
+
+	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
+		err |= -EINVAL;
+
+	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT)
+		err |= -EINVAL;
+
+	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))
+		err |= -EINVAL;
+
+	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT))))
+		err |= -EINVAL;
+
+	if (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
+		err |= -EINVAL;
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+	case TRIG_EXT:
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_INT:
+		/* start_arg is the internal trigger (any value) */
+		break;
+	}
+
+	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+
+	if ((cmd->scan_begin_src == TRIG_TIMER) &&
+	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
+		cmd->scan_begin_src = TRIG_FOLLOW;
+		cmd->convert_arg = cmd->scan_begin_arg;
+		cmd->scan_begin_arg = 0;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 devpriv->ai_ns_min);
+
+	if (cmd->scan_begin_src == TRIG_EXT)
+		if (cmd->scan_begin_arg) {
+			cmd->scan_begin_arg = 0;
+			err |= -EINVAL;
+			err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg,
+							 65535);
+		}
+
+	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 devpriv->ai_ns_min);
+
+	if (cmd->convert_src == TRIG_EXT)
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+
+	err |= cfc_check_trigger_arg_min(&cmd->scan_end_arg,
+					 cmd->chanlist_len);
+
+	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
+		cmd->scan_end_arg =
+		    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);
+		err |= -EINVAL;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		arg = cmd->scan_begin_arg;
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
+					  &divisor1, &divisor2,
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+	}
+
+	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
+		arg = cmd->convert_arg;
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
+					  &divisor1, &divisor2,
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+
+		if (cmd->scan_begin_src == TRIG_TIMER &&
+		    cmd->convert_src == TRIG_NOW) {
+			if (cmd->convert_arg == 0) {
+				arg = devpriv->ai_ns_min *
+				      (cmd->scan_end_arg + 2);
+			} else {
+				arg = cmd->convert_arg * cmd->chanlist_len;
+			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 arg);
+		}
+	}
+
+	if (err)
+		return 4;
+
+	if (cmd->chanlist)
+		if (!check_channel_list(dev, s, cmd->chanlist_len,
+					cmd->chanlist, 0, 0))
+			return 5;	/* incorrect channels list */
+
+	return 0;
+}
+
 static int pci9118_ai_eoc(struct comedi_device *dev,
 			  struct comedi_subdevice *s,
 			  struct comedi_insn *insn,

commit fa795752c2720a672efff0147f5ef715acde945b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:54 2014 -0700

    staging: comedi: adl_pci9118: absorb DMA and non-DMA helpers
    
    Currently the pci9118_ai_docmd_dma() or pci9118_ai_docmd_sampl() helper
    is called by the (*do_cmd) to do the final setup for the command. Most
    of this invloves setting various bits in 'ai_ctrl' and 'int_ctrl' to
    setup the acquisition based on the 'ai_do' mode. Most of this is the
    same for the DMA and non-DMA setup. The differences are easily handled
    by either checking the cmd trigger sources or if DMA is used.
    
    Absorb the helper functions into the (*do_cmd) to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 127799788c89..5ab9e79ba3b1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1085,89 +1085,11 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
-				  struct comedi_subdevice *s)
-{
-	struct pci9118_private *devpriv = dev->private;
-
-	switch (devpriv->ai_do) {
-	case 1:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
-		break;
-	case 2:
-		dev_err(dev->class_dev, "%s mode 2 bug!\n", __func__);
-		return -EIO;
-	case 3:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;
-		break;
-	case 4:
-		dev_err(dev->class_dev, "%s mode 4 bug!\n", __func__);
-		return -EIO;
-	default:
-		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
-		return -EIO;
-	}
-
-	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
-		devpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;
-
-	devpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;
-
-	pci9118_amcc_int_ena(dev, true);
-
-	return 0;
-}
-
-static int pci9118_ai_docmd_dma(struct comedi_device *dev,
-				struct comedi_subdevice *s)
-{
-	struct pci9118_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[0];
-
-	Compute_and_setup_dma(dev, s);
-
-	switch (devpriv->ai_do) {
-	case 1:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
-		break;
-	case 2:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
-		devpriv->ai_cfg |= PCI9118_AI_CFG_BM |
-				   PCI9118_AI_CFG_BS;
-		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
-			devpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;
-		outl(devpriv->ai_n_realscanlen,
-		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
-		break;
-	case 3:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;
-		break;
-	case 4:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
-		devpriv->ai_cfg |= PCI9118_AI_CFG_AM;
-		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-		pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
-		devpriv->ai_cfg |= PCI9118_AI_CFG_START;
-		break;
-	default:
-		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
-		return -EIO;
-	}
-
-	outl(0x02000000 | AINT_WRITE_COMPL,
-	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-
-	return 0;
-}
-
 static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
-	int ret = 0;
 
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
@@ -1275,6 +1197,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			     devpriv->ai_add_front, devpriv->ai_add_back);
 
 	/* Determine acqusition mode and calculate timing */
+	devpriv->ai_do = 0;
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->convert_src == TRIG_TIMER) {
 		/* cascaded timers 1 and 2 are used for convert timing */
@@ -1282,12 +1205,30 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ai_do = 4;
 		else
 			devpriv->ai_do = 1;
+
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  &devpriv->ai_divisor1,
 					  &devpriv->ai_divisor2,
 					  &cmd->convert_arg,
 					  devpriv->ai_flags &
 					  CMDF_ROUND_NEAREST);
+
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
+
+		if (!devpriv->usedma) {
+			devpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;
+			devpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;
+		}
+
+		if (cmd->scan_begin_src == TRIG_EXT) {
+			struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[0];
+
+			devpriv->ai_cfg |= PCI9118_AI_CFG_AM;
+			outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
+			pci9118_timer_set_mode(dev, 0, I8254_MODE0);
+			pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
+			devpriv->ai_cfg |= PCI9118_AI_CFG_START;
+		}
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER &&
@@ -1300,6 +1241,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 		/* double timed action */
 		devpriv->ai_do = 2;
+
 		pci9118_calc_divisors(dev, s,
 				      &cmd->scan_begin_arg, &cmd->convert_arg,
 				      devpriv->ai_flags,
@@ -1307,12 +1249,27 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      &devpriv->ai_divisor1,
 				      &devpriv->ai_divisor2,
 				      devpriv->ai_add_front);
+
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
+		devpriv->ai_cfg |= PCI9118_AI_CFG_BM | PCI9118_AI_CFG_BS;
+		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
+			devpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;
+		outl(devpriv->ai_n_realscanlen,
+		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 	}
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW &&
 	    cmd->convert_src == TRIG_EXT) {
 		/* external trigger conversion */
 		devpriv->ai_do = 3;
+
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;
+	}
+
+	if (devpriv->ai_do == 0) {
+		dev_err(dev->class_dev,
+			"Unable to determine acqusition mode! BUG in (*do_cmdtest)?\n");
+		return -EINVAL;
 	}
 
 	if (devpriv->usedma)
@@ -1334,12 +1291,14 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_act_dmapos = 0;
 	s->async->cur_chan = 0;
 
-	if (devpriv->usedma)
-		ret = pci9118_ai_docmd_dma(dev, s);
-	else
-		ret = pci9118_ai_docmd_sampl(dev, s);
-	if (ret)
-		return ret;
+	if (devpriv->usedma) {
+		Compute_and_setup_dma(dev, s);
+
+		outl(0x02000000 | AINT_WRITE_COMPL,
+		     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	} else {
+		pci9118_amcc_int_ena(dev, true);
+	}
 
 	/* start async command now or wait for internal trigger */
 	if (cmd->start_src == TRIG_NOW)

commit e7d2191b0ba09e070c1417fc8af73c3c5cd744f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:53 2014 -0700

    staging: comedi: adl_pci9118: clarify async command start
    
    The async command can start immediately (TRIG_NOW), from an internal
    trigger (TRIG_INT), or from an external trigger (TRIG_EXT). Currently
    the start of the command is scattered in the DMA and non-DMA helper
    functions.
    
    Consolidate the start of the async command at the end of the (*do_cmd)
    function. For aesthetics, use the 'cmd->start_src' directly instead
    of the 'ai12_startstop' in the private data to determine how to start
    the command. This also fixes a minor bug where the external trigger
    gets enabled for a start_src == TRIG_INT.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cf7bd2fbdb15..127799788c89 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -142,7 +142,6 @@
 
 #define START_AI_EXT	0x01	/* start measure on external trigger */
 #define STOP_AI_EXT	0x02	/* stop measure on external trigger */
-#define START_AI_INT	0x04	/* start measure on internal trigger */
 #define STOP_AI_INT	0x08	/* stop measure on internal trigger */
 
 #define PCI9118_HALF_FIFO_SZ	(1024 / 2)
@@ -790,15 +789,12 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int trig_num)
 {
-	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	devpriv->ai12_startstop &= ~START_AI_INT;
 	s->async->inttrig = NULL;
-
 	pci9118_ai_cmd_start(dev);
 
 	return 1;
@@ -1112,9 +1108,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	if (devpriv->ai12_startstop)
-		pci9118_exttrg_enable(dev, true);
-
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;
 
@@ -1122,9 +1115,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	pci9118_amcc_int_ena(dev, true);
 
-	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT)))
-		pci9118_ai_cmd_start(dev);
-
 	return 0;
 }
 
@@ -1166,15 +1156,9 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	if (devpriv->ai12_startstop)
-		pci9118_exttrg_enable(dev, true);
-
 	outl(0x02000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
-	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT)))
-		pci9118_ai_cmd_start(dev);
-
 	return 0;
 }
 
@@ -1197,10 +1181,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_neverending = 1;
 		devpriv->ai12_startstop |= STOP_AI_EXT;
 	}
-	if (cmd->start_src == TRIG_INT) {
-		devpriv->ai12_startstop |= START_AI_INT;
-		s->async->inttrig = pci9118_ai_inttrig;
-	}
 	if (cmd->stop_src == TRIG_NONE)
 		devpriv->ai_neverending = 1;
 	if (cmd->stop_src == TRIG_COUNT)
@@ -1358,8 +1338,20 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		ret = pci9118_ai_docmd_dma(dev, s);
 	else
 		ret = pci9118_ai_docmd_sampl(dev, s);
+	if (ret)
+		return ret;
+
+	/* start async command now or wait for internal trigger */
+	if (cmd->start_src == TRIG_NOW)
+		pci9118_ai_cmd_start(dev);
+	else if (cmd->start_src == TRIG_INT)
+		s->async->inttrig = pci9118_ai_inttrig;
 
-	return ret;
+	/* enable external trigger for command start/stop */
+	if (cmd->start_src == TRIG_EXT || cmd->stop_src == TRIG_EXT)
+		pci9118_exttrg_enable(dev, true);
+
+	return 0;
 }
 
 static int pci9118_ai_eoc(struct comedi_device *dev,

commit 5e17ae870c21c1860eb9dc3d911a8d2fe3d7a73e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:52 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_ai_cmd_start()
    
    Introduce a helper function to start the async command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 558863133dd6..cf7bd2fbdb15 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -773,6 +773,19 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
+static void pci9118_ai_cmd_start(struct comedi_device *dev)
+{
+	struct pci9118_private *devpriv = dev->private;
+
+	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
+	if (devpriv->ai_do != 3) {
+		pci9118_start_pacer(dev, devpriv->ai_do);
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
+	}
+	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
+}
+
 static int pci9118_ai_inttrig(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      unsigned int trig_num)
@@ -786,13 +799,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	devpriv->ai12_startstop &= ~START_AI_INT;
 	s->async->inttrig = NULL;
 
-	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-	if (devpriv->ai_do != 3) {
-		pci9118_start_pacer(dev, devpriv->ai_do);
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
-	}
-	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
+	pci9118_ai_cmd_start(dev);
 
 	return 1;
 }
@@ -1115,15 +1122,8 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	pci9118_amcc_int_ena(dev, true);
 
-	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-		if (devpriv->ai_do != 3) {
-			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
-		}
-		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-	}
+	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT)))
+		pci9118_ai_cmd_start(dev);
 
 	return 0;
 }
@@ -1172,15 +1172,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	outl(0x02000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
-	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-		if (devpriv->ai_do != 3) {
-			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
-		}
-		outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
-	}
+	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT)))
+		pci9118_ai_cmd_start(dev);
 
 	return 0;
 }

commit d900197e9e0ee372a6eabce6a8a98ec8c4174c2b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:51 2014 -0700

    staging: comedi: adl_pci9118: enable DMA in common code path
    
    The pci9118_ai_docmd_dma() function enables the DMA bit in the ai control
    register for all acquisition modes. For aesthetics, move the enable of
    this bit into the (*do_cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 48064c20103d..558863133dd6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1139,12 +1139,10 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 	switch (devpriv->ai_do) {
 	case 1:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
-				    PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
 		break;
 	case 2:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
-				    PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
 		devpriv->ai_cfg |= PCI9118_AI_CFG_BM |
 				   PCI9118_AI_CFG_BS;
 		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
@@ -1153,12 +1151,10 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 		break;
 	case 3:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM |
-				    PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;
 		break;
 	case 4:
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
-				    PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
 		devpriv->ai_cfg |= PCI9118_AI_CFG_AM;
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
@@ -1346,6 +1342,9 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_do = 3;
 	}
 
+	if (devpriv->usedma)
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_DMA;
+
 	pci9118_start_pacer(dev, -1);	/* stop pacer */
 
 	/* set default config (disable burst and triggers) */

commit 4cf13a1dc89b0f5e23ec5d33905c91e240e1f831
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:50 2014 -0700

    staging: comedi: adl_pci9118: tidy up 'ai_cfg' in pci9118_ai_docmd_dma()
    
    The 'ai_cfg' was already set to PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG.
    Don't bother setting those bits in pci9118_ai_docmd_dma().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5961fefebf3f..48064c20103d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1145,10 +1145,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	case 2:
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
 				    PCI9118_AI_CTRL_DMA;
-		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
-				  PCI9118_AI_CFG_PETRG |
-				  PCI9118_AI_CFG_BM |
-				  PCI9118_AI_CFG_BS;
+		devpriv->ai_cfg |= PCI9118_AI_CFG_BM |
+				   PCI9118_AI_CFG_BS;
 		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
 			devpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;
 		outl(devpriv->ai_n_realscanlen,
@@ -1157,15 +1155,11 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	case 3:
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM |
 				    PCI9118_AI_CTRL_DMA;
-		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
-				  PCI9118_AI_CFG_PETRG;
 		break;
 	case 4:
 		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
 				    PCI9118_AI_CTRL_DMA;
-		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
-				  PCI9118_AI_CFG_PETRG |
-				  PCI9118_AI_CFG_AM;
+		devpriv->ai_cfg |= PCI9118_AI_CFG_AM;
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 		pci9118_timer_write(dev, 0, dmabuf->hw >> 1);

commit f3d3dad659df423f46ea8ec5050eb1af69eb1bf1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:49 2014 -0700

    staging: comedi: adl_pci9118: clarify acquisition mode (ai_do) determination
    
    The async command can operation in 4 modes in this driver.
    
    Modes 1 and 4 use timers 1 and 2 as a cascaded timer to trigger each conversion.
    Mode 1 begins the acquisitions immediately (scan_begin_src == TRIG_FOLLOW) and
    Mode 4 begins after an external trigger (scan_begin_src == TRIG_EXT). Both modes
    use a convert_src == TRIG_TIMER.
    
    Mode 2 uses timers 1 and 2 in a double timed action (scan_begin_src == TRIG_TIMER
    and convert_src != TRIG_EXT (TRIG_TIMER and TRIG_NOW are valid)).
    
    Mode 3 does not use the timers. Each acquisition is triggered by an external
    signal (scan_begin_src == TRIG_FOLLOW and convert_src == TRIG_EXT.
    
    The (*do_cmdtest) validates the scan_begin_src as TRIG_FOLLOW, TRIG_TIMER,
    or TRIG_EXT. Remove the invalid check for TRIG_INT in the (*do_cmd).
    
    Clarify the logic used to determine the mode in the (*do_cmd).
    
    Also, simplify pci9118_calc_divisors(). Call i8253_cascade_ns_to_timer() directly
    in the (*do_cmd) for the mode 1 and mode 4 cases. Call pci9118_calc_divisors()
    only for mode 2 acquisitions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 98922d735f00..5961fefebf3f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -513,7 +513,7 @@ static void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)
 		pci9118_amcc_int_ena(dev, false);
 }
 
-static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
+static void pci9118_calc_divisors(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned int *tim1, unsigned int *tim2,
 				  unsigned int flags, int chans,
@@ -522,32 +522,21 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	switch (mode) {
-	case 1:
-	case 4:
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
-					  div1, div2,
-					  tim2, flags & CMDF_ROUND_NEAREST);
-		break;
-	case 2:
-		*div1 = *tim2 / I8254_OSC_BASE_4MHZ;
-						/* convert timer (burst) */
-		*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
-		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
-		if (*div2 < chans)
-			*div2 = chans;
-
-		*tim2 = *div1 * I8254_OSC_BASE_4MHZ;	/* real convert timer */
-
-		if (cmd->convert_src == TRIG_NOW && !chnsshfront) {
-			/* use BSSH signal */
-			if (*div2 < (chans + 2))
-				*div2 = chans + 2;
-		}
+	*div1 = *tim2 / I8254_OSC_BASE_4MHZ;	/* convert timer (burst) */
+	*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
+	*div2 = *div2 / *div1;			/* major timer is c1*c2 */
+	if (*div2 < chans)
+		*div2 = chans;
 
-		*tim1 = *div1 * *div2 * I8254_OSC_BASE_4MHZ;
-		break;
+	*tim2 = *div1 * I8254_OSC_BASE_4MHZ;	/* real convert timer */
+
+	if (cmd->convert_src == TRIG_NOW && !chnsshfront) {
+		/* use BSSH signal */
+		if (*div2 < (chans + 2))
+			*div2 = chans + 2;
 	}
+
+	*tim1 = *div1 * *div2 * I8254_OSC_BASE_4MHZ;
 }
 
 static void pci9118_start_pacer(struct comedi_device *dev, int mode)
@@ -1322,40 +1311,33 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	pci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,
 			     devpriv->ai_add_front, devpriv->ai_add_back);
 
-	/* compute timers settings */
-	/*
-	 * simplest way, fr=4Mhz/(tim1*tim2),
-	 * channel manipulation without timers effect
-	 */
-	if (((cmd->scan_begin_src == TRIG_FOLLOW) ||
-		(cmd->scan_begin_src == TRIG_EXT)) &&
-		(cmd->convert_src == TRIG_TIMER)) {
-					/* both timer is used for one time */
+	/* Determine acqusition mode and calculate timing */
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->convert_src == TRIG_TIMER) {
+		/* cascaded timers 1 and 2 are used for convert timing */
 		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->ai_do = 4;
 		else
 			devpriv->ai_do = 1;
-		pci9118_calc_divisors(devpriv->ai_do, dev, s,
-				      &cmd->scan_begin_arg, &cmd->convert_arg,
-				      devpriv->ai_flags,
-				      devpriv->ai_n_realscanlen,
-				      &devpriv->ai_divisor1,
-				      &devpriv->ai_divisor2,
-				      devpriv->ai_add_front);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
+					  &devpriv->ai_divisor1,
+					  &devpriv->ai_divisor2,
+					  &cmd->convert_arg,
+					  devpriv->ai_flags &
+					  CMDF_ROUND_NEAREST);
 	}
 
-	if ((cmd->scan_begin_src == TRIG_TIMER) &&
-		((cmd->convert_src == TRIG_TIMER) ||
-		(cmd->convert_src == TRIG_NOW))) {
-						/* double timed action */
+	if (cmd->scan_begin_src == TRIG_TIMER &&
+	    cmd->convert_src != TRIG_EXT) {
 		if (!devpriv->usedma) {
 			dev_err(dev->class_dev,
 				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!\n");
 			return -EIO;
 		}
 
+		/* double timed action */
 		devpriv->ai_do = 2;
-		pci9118_calc_divisors(devpriv->ai_do, dev, s,
+		pci9118_calc_divisors(dev, s,
 				      &cmd->scan_begin_arg, &cmd->convert_arg,
 				      devpriv->ai_flags,
 				      devpriv->ai_n_realscanlen,
@@ -1364,8 +1346,9 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      devpriv->ai_add_front);
 	}
 
-	if ((cmd->scan_begin_src == TRIG_FOLLOW)
-	    && (cmd->convert_src == TRIG_EXT)) {
+	if (cmd->scan_begin_src == TRIG_FOLLOW &&
+	    cmd->convert_src == TRIG_EXT) {
+		/* external trigger conversion */
 		devpriv->ai_do = 3;
 	}
 

commit abaaa7f83a505f9a6cd0405d1dc92ab19a0c7805
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:48 2014 -0700

    staging: comedi: adl_pci9118: TRIG_INT is not a valid scan_begin_src
    
    The (*do_cmdtest) validates the scan_begin_src as TRIG_FOLLOW, TRIG_TIMER,
    or TRIG_EXT. Remove the invalid check for TRIG_INT in the (*do_cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 86c8b66ba9eb..98922d735f00 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1328,8 +1328,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * channel manipulation without timers effect
 	 */
 	if (((cmd->scan_begin_src == TRIG_FOLLOW) ||
-		(cmd->scan_begin_src == TRIG_EXT) ||
-		(cmd->scan_begin_src == TRIG_INT)) &&
+		(cmd->scan_begin_src == TRIG_EXT)) &&
 		(cmd->convert_src == TRIG_TIMER)) {
 					/* both timer is used for one time */
 		if (cmd->scan_begin_src == TRIG_EXT)

commit d397fd5886090f9462098432bd9523fd8f3df37b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:47 2014 -0700

    staging: comedi: adl_pci9118: remove sanity checks in pci9118_calc_divisors()
    
    The 'tim2' parameter to this function is actually the cmd->convert_arg which
    was validated in the (*do_cmdtest) as:
    
            err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
                                             devprivriv->ai_ns_min);
    
    The sanity checks in this function are just repeating that validation. The
    'min_pacer' sanity check is simply not needed.
    
    Remove these unnecessary checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 95d9f2c49961..86c8b66ba9eb 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -520,27 +520,18 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int *div1, unsigned int *div2,
 				  unsigned int chnsshfront)
 {
-	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int min_pacer;
 
 	switch (mode) {
 	case 1:
 	case 4:
-		if (*tim2 < devpriv->ai_ns_min)
-			*tim2 = devpriv->ai_ns_min;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  div1, div2,
 					  tim2, flags & CMDF_ROUND_NEAREST);
 		break;
 	case 2:
-		if (*tim2 < devpriv->ai_ns_min)
-			*tim2 = devpriv->ai_ns_min;
 		*div1 = *tim2 / I8254_OSC_BASE_4MHZ;
 						/* convert timer (burst) */
-		min_pacer = devpriv->ai_ns_min / I8254_OSC_BASE_4MHZ;
-		if (*div1 < min_pacer)
-			*div1 = min_pacer;
 		*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
 		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
 		if (*div2 < chans)

commit 5fc6c95c2fdc9c6bccf57ff15ab054530382ae76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:46 2014 -0700

    staging: comedi: adl_pci9118: tidy up pci9118_set_chanlist()
    
    Define some macros to set the 'chan' and 'range' bits in the chanlist
    register. Use them to tidy up this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 8820eea78f01..95d9f2c49961 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -120,6 +120,8 @@
 #define PCI9118_DIO_REG			0x1c
 #define PCI9118_SOFTTRG_REG		0x20
 #define PCI9118_AI_CHANLIST_REG		0x24
+#define PCI9118_AI_CHANLIST_RANGE(x)	(((x) & 0x3) << 8)
+#define PCI9118_AI_CHANLIST_CHAN(x)	((x) << 0)
 #define PCI9118_AI_BURST_NUM_REG	0x28
 #define PCI9118_AI_AUTOSCAN_MODE_REG	0x2c
 #define PCI9118_AI_CFG_REG		0x30
@@ -375,9 +377,11 @@ static void pci9118_set_chanlist(struct comedi_device *dev,
 				 int frontadd, int backadd)
 {
 	struct pci9118_private *devpriv = dev->private;
+	unsigned int chan0 = CR_CHAN(chanlist[0]);
 	unsigned int range0 = CR_RANGE(chanlist[0]);
 	unsigned int aref0 = CR_AREF(chanlist[0]);
-	unsigned int scanquad, gain, ssh = 0x00;
+	unsigned int ssh = 0x00;
+	unsigned int val;
 	int i;
 
 	/*
@@ -397,37 +401,33 @@ static void pci9118_set_chanlist(struct comedi_device *dev,
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 
-	if (frontadd) {		/* insert channels for S&H */
+	/* insert channels for S&H */
+	if (frontadd) {
+		val = PCI9118_AI_CHANLIST_CHAN(chan0) |
+		      PCI9118_AI_CHANLIST_RANGE(range0);
 		ssh = devpriv->softsshsample;
 		for (i = 0; i < frontadd; i++) {
-						/* store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);
-						/* get channel number; */
-			gain = CR_RANGE(chanlist[0]);
-						/* get gain number */
-			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh,
-			     dev->iobase + PCI9118_AI_CHANLIST_REG);
+			outl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
 			ssh = devpriv->softsshhold;
 		}
 	}
 
-	for (i = 0; i < n_chan; i++) {	/* store range list to card */
-		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
-		gain = CR_RANGE(chanlist[i]);		/* get gain number */
-		scanquad |= ((gain & 0x03) << 8);
-		outl(scanquad | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
+	/* store chanlist */
+	for (i = 0; i < n_chan; i++) {
+		unsigned int chan = CR_CHAN(chanlist[i]);
+		unsigned int range = CR_RANGE(chanlist[i]);
+
+		val = PCI9118_AI_CHANLIST_CHAN(chan) |
+		      PCI9118_AI_CHANLIST_RANGE(range);
+		outl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
 	}
 
-	if (backadd) {		/* insert channels for fit onto 32bit DMA */
-		for (i = 0; i < backadd; i++) {	/* store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);
-							/* get channel number */
-			gain = CR_RANGE(chanlist[0]);	/* get gain number */
-			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh,
-			     dev->iobase + PCI9118_AI_CHANLIST_REG);
-		}
+	/* insert channels to fit onto 32bit DMA */
+	if (backadd) {
+		val = PCI9118_AI_CHANLIST_CHAN(chan0) |
+		      PCI9118_AI_CHANLIST_RANGE(range0);
+		for (i = 0; i < backadd; i++)
+			outl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
 	}
 	/* close scan queue */
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);

commit b7a078e9cd8e92a989e5afa524e4d9f945e58c75
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:45 2014 -0700

    staging: comedi: adl_pci9118: absorb pci9118_ai_set_range_aref()
    
    This function is called by the analog input (*insn_read) and (*do_cmd)
    operations. The pci9118_set_chanlist() function is also called by those
    operations. Setting the range and aref logically belongs with setting
    the chanlist. To clarify the code, absorb pci9118_ai_set_range_aref()
    into pci9118_set_chanlist().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 89a6ea578968..8820eea78f01 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -322,22 +322,6 @@ static void pci9118_ai_reset_fifo(struct comedi_device *dev)
 	outl(0, dev->iobase + PCI9118_FIFO_RESET_REG);
 }
 
-static void pci9118_ai_set_range_aref(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      unsigned int chanspec)
-{
-	struct pci9118_private *devpriv = dev->private;
-	unsigned int range = CR_RANGE(chanspec);
-	unsigned int aref = CR_AREF(chanspec);
-
-	devpriv->ai_ctrl = 0;
-	if (comedi_range_is_unipolar(s, range))
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_UNIP;
-	if (aref == AREF_DIFF)
-		devpriv->ai_ctrl |= PCI9118_AI_CTRL_DIFF;
-	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
-}
-
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -391,9 +375,23 @@ static void pci9118_set_chanlist(struct comedi_device *dev,
 				 int frontadd, int backadd)
 {
 	struct pci9118_private *devpriv = dev->private;
+	unsigned int range0 = CR_RANGE(chanlist[0]);
+	unsigned int aref0 = CR_AREF(chanlist[0]);
 	unsigned int scanquad, gain, ssh = 0x00;
 	int i;
 
+	/*
+	 * Configure analog input based on the first chanlist entry.
+	 * All entries are either unipolar or bipolar and single-ended
+	 * or differential.
+	 */
+	devpriv->ai_ctrl = 0;
+	if (comedi_range_is_unipolar(s, range0))
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_UNIP;
+	if (aref0 == AREF_DIFF)
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_DIFF;
+	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
+
 	/* gods know why this sequence! */
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
@@ -1327,14 +1325,9 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EINVAL;
 
 	/*
-	 * Configure analog input based on the first chanlist entry.
-	 * All entries are either unipolar or bipolar and single-ended
-	 * or differential.
-	 *
+	 * Configure analog input and load the chanlist.
 	 * The acqusition control bits are enabled later.
 	 */
-	pci9118_ai_set_range_aref(dev, s, cmd->chanlist[0]);
-
 	pci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,
 			     devpriv->ai_add_front, devpriv->ai_add_back);
 
@@ -1443,14 +1436,12 @@ static int pci9118_ai_insn_read(struct comedi_device *dev,
 	* Configure analog input based on the chanspec.
 	* Acqusition is software controlled without interrupts.
 	*/
-	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
+	pci9118_set_chanlist(dev, s, 1, &insn->chanspec, 0, 0);
 
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 
-	pci9118_set_chanlist(dev, s, 1, &insn->chanspec, 0, 0);
-
 	pci9118_ai_reset_fifo(dev);
 
 	for (i = 0; i < insn->n; i++) {

commit 7d62b548ded7a5540ecd89fb38d0dab876aec78f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:44 2014 -0700

    staging: comedi: adl_pci9118: rename setup_channel_list()
    
    Rename this function so it has namespace associated with the driver.
    
    Also, this function always succeeds. Change the return type to void
    and remove the unnecessary error handling by the callers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 67f8ff14efa8..89a6ea578968 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -385,10 +385,10 @@ static int check_channel_list(struct comedi_device *dev,
 	return 1;
 }
 
-static int setup_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int frontadd,
-			      int backadd)
+static void pci9118_set_chanlist(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 int n_chan, unsigned int *chanlist,
+				 int frontadd, int backadd)
 {
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int scanquad, gain, ssh = 0x00;
@@ -434,8 +434,6 @@ static int setup_channel_list(struct comedi_device *dev,
 	/* close scan queue */
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	/* udelay(100); important delay, or first sample will be crippled */
-
-	return 1;		/* we can serve this with scan logic */
 }
 
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev,
@@ -1337,10 +1335,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	pci9118_ai_set_range_aref(dev, s, cmd->chanlist[0]);
 
-	if (!setup_channel_list(dev, s, cmd->chanlist_len,
-				cmd->chanlist, devpriv->ai_add_front,
-				devpriv->ai_add_back))
-		return -EINVAL;
+	pci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,
+			     devpriv->ai_add_front, devpriv->ai_add_back);
 
 	/* compute timers settings */
 	/*
@@ -1453,8 +1449,7 @@ static int pci9118_ai_insn_read(struct comedi_device *dev,
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 
-	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0))
-		return -EINVAL;
+	pci9118_set_chanlist(dev, s, 1, &insn->chanspec, 0, 0);
 
 	pci9118_ai_reset_fifo(dev);
 

commit acdc21c2030659de8d9a9d3960b3b004a38eeec7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:43 2014 -0700

    staging: comedi: adl_pci9118: remove unused parameters from setup_channel_list()
    
    The 'rot' and 'usedma' parameters are not used in this function. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 319ec1aa91c4..67f8ff14efa8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -387,18 +387,13 @@ static int check_channel_list(struct comedi_device *dev,
 
 static int setup_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int rot, int frontadd,
-			      int backadd, int usedma)
+			      unsigned int *chanlist, int frontadd,
+			      int backadd)
 {
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int scanquad, gain, ssh = 0x00;
 	int i;
 
-	if (usedma == 1) {
-		rot = 8;
-		usedma = 0;
-	}
-
 	/* gods know why this sequence! */
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
@@ -1343,8 +1338,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	pci9118_ai_set_range_aref(dev, s, cmd->chanlist[0]);
 
 	if (!setup_channel_list(dev, s, cmd->chanlist_len,
-				cmd->chanlist, 0, devpriv->ai_add_front,
-				devpriv->ai_add_back, devpriv->usedma))
+				cmd->chanlist, devpriv->ai_add_front,
+				devpriv->ai_add_back))
 		return -EINVAL;
 
 	/* compute timers settings */
@@ -1458,7 +1453,7 @@ static int pci9118_ai_insn_read(struct comedi_device *dev,
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 
-	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
+	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0))
 		return -EINVAL;
 
 	pci9118_ai_reset_fifo(dev);

commit 11822f0218b4f44ff16a27b15a0742165a916936
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:42 2014 -0700

    staging: comedi: adl_pci9118: merge pci9118_exttrg_{add,del}()
    
    For aesthetics, merge these two helper functions and add a parameter,
    'enable', to determine if the external trigger is being added (enabled)
    or deleted (disabled).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 69b879879ddd..319ec1aa91c4 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -506,23 +506,20 @@ static int move_block_from_dma(struct comedi_device *dev,
 	return 0;
 }
 
-static void pci9118_exttrg_add(struct comedi_device *dev)
+static void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	devpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;
+	if (enable)
+		devpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;
+	else
+		devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
 	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-	pci9118_amcc_int_ena(dev, true);
-}
-
-static void pci9118_exttrg_del(struct comedi_device *dev)
-{
-	struct pci9118_private *devpriv = dev->private;
 
-	devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
-	if (!devpriv->int_ctrl)
+	if (devpriv->int_ctrl)
+		pci9118_amcc_int_ena(dev, true);
+	else
 		pci9118_amcc_int_ena(dev, false);
-	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 }
 
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
@@ -592,7 +589,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 
 	if (devpriv->usedma)
 		pci9118_amcc_dma_ena(dev, false);
-	pci9118_exttrg_del(dev);
+	pci9118_exttrg_enable(dev, false);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
@@ -778,7 +775,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 				/* deactivate EXT trigger */
 				devpriv->ai12_startstop &= ~START_AI_EXT;
 				if (!(devpriv->ai12_startstop & STOP_AI_EXT))
-					pci9118_exttrg_del(dev);
+					pci9118_exttrg_enable(dev, false);
 
 				/* start pacer */
 				pci9118_start_pacer(dev, devpriv->ai_do);
@@ -787,7 +784,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
 				/* deactivate EXT trigger */
 				devpriv->ai12_startstop &= ~STOP_AI_EXT;
-				pci9118_exttrg_del(dev);
+				pci9118_exttrg_enable(dev, false);
 
 				/* on next interrupt measure will stop */
 				devpriv->ai_neverending = 0;
@@ -1138,8 +1135,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	}
 
 	if (devpriv->ai12_startstop)
-		pci9118_exttrg_add(dev);
-						/* activate EXT trigger */
+		pci9118_exttrg_enable(dev, true);
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;
@@ -1209,10 +1205,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	if (devpriv->ai12_startstop) {
-		pci9118_exttrg_add(dev);
-						/* activate EXT trigger */
-	}
+	if (devpriv->ai12_startstop)
+		pci9118_exttrg_enable(dev, true);
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);

commit 664e244ca5d90c5f3d97a67202cbdf821a3feeb0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:41 2014 -0700

    staging: comedi: adl_pci9118: exttrg source is always EXTTRG_AI
    
    The 'source'  passed to pci9118_exttrg_{add,del}() is always EXTTRG_AI.
    Remove the parameter and unnecessary sanity checking. Also, since there
    is only one vaild exttrg source, remove the unnecessary 'exttrg_users'
    member from the private data.
    
    The pci9118_exttrg_{add,del}() functions always succeed. For aesthetics
    change the return type to void.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7781d8786372..69b879879ddd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -143,8 +143,6 @@
 #define START_AI_INT	0x04	/* start measure on internal trigger */
 #define STOP_AI_INT	0x08	/* stop measure on internal trigger */
 
-#define EXTTRG_AI	0	/* ext trg is used by AI */
-
 #define PCI9118_HALF_FIFO_SZ	(1024 / 2)
 
 static const struct comedi_lrange pci9118_ai_range = {
@@ -248,10 +246,6 @@ struct pci9118_private {
 						 */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	struct pci9118_dmabuf dmabuf[2];
-	unsigned char exttrg_users;		/*
-						 * bit field of external trigger
-						 * users(0-AI, 1-AO, 2-DI, 3-DO)
-						 */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
 					 * numer is requested delay in ns
@@ -512,33 +506,23 @@ static int move_block_from_dma(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
+static void pci9118_exttrg_add(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	if (source > 3)
-		return -1;				/* incorrect source */
-	devpriv->exttrg_users |= (1 << source);
 	devpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;
 	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	pci9118_amcc_int_ena(dev, true);
-	return 0;
 }
 
-static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
+static void pci9118_exttrg_del(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	if (source > 3)
-		return -1;			/* incorrect source */
-	devpriv->exttrg_users &= ~(1 << source);
-	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
-		devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
-		if (!devpriv->int_ctrl)
-			pci9118_amcc_int_ena(dev, false);
-		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-	}
-	return 0;
+	devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
+	if (!devpriv->int_ctrl)
+		pci9118_amcc_int_ena(dev, false);
+	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 }
 
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
@@ -608,7 +592,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 
 	if (devpriv->usedma)
 		pci9118_amcc_dma_ena(dev, false);
-	pci9118_exttrg_del(dev, EXTTRG_AI);
+	pci9118_exttrg_del(dev);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
 	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
@@ -794,7 +778,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 				/* deactivate EXT trigger */
 				devpriv->ai12_startstop &= ~START_AI_EXT;
 				if (!(devpriv->ai12_startstop & STOP_AI_EXT))
-					pci9118_exttrg_del(dev, EXTTRG_AI);
+					pci9118_exttrg_del(dev);
 
 				/* start pacer */
 				pci9118_start_pacer(dev, devpriv->ai_do);
@@ -803,7 +787,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
 				/* deactivate EXT trigger */
 				devpriv->ai12_startstop &= ~STOP_AI_EXT;
-				pci9118_exttrg_del(dev, EXTTRG_AI);
+				pci9118_exttrg_del(dev);
 
 				/* on next interrupt measure will stop */
 				devpriv->ai_neverending = 0;
@@ -1154,7 +1138,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	}
 
 	if (devpriv->ai12_startstop)
-		pci9118_exttrg_add(dev, EXTTRG_AI);
+		pci9118_exttrg_add(dev);
 						/* activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
@@ -1226,7 +1210,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	}
 
 	if (devpriv->ai12_startstop) {
-		pci9118_exttrg_add(dev, EXTTRG_AI);
+		pci9118_exttrg_add(dev);
 						/* activate EXT trigger */
 	}
 

commit f9d208d3eaffcf4e014592fa3a004e8c3f4a4a13
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:40 2014 -0700

    staging: comedi: adl_pci9118: fix interrupt_pci9118_ai_mode4_switch()
    
    This function modifies the analog input acquistion programming after the first
    DMA cycle to continue a "mode4" acqusition. Part of this programs timer 0 based
    on the hardware address of the next buffer. When double buffering is not used
    for DMA the "next" buffer is always the first, and only, buffer.
    
    Add a parameter to this function to indicate what the "next" buffer actually is
    and fix the callers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3e3405ccdede..7781d8786372 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -449,12 +449,11 @@ static int setup_channel_list(struct comedi_device *dev,
 	return 1;		/* we can serve this with scan logic */
 }
 
-static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
+static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev,
+					      unsigned int next_buf)
 {
 	struct pci9118_private *devpriv = dev->private;
-	struct pci9118_dmabuf *dmabuf;
-
-	dmabuf = &devpriv->dmabuf[1 - devpriv->dma_actbuf];
+	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[next_buf];
 
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
 			  PCI9118_AI_CFG_AM;
@@ -700,7 +699,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		pci9118_amcc_setup_dma(dev, next_dma_buf);
 		if (devpriv->ai_do == 4)
-			interrupt_pci9118_ai_mode4_switch(dev);
+			interrupt_pci9118_ai_mode4_switch(dev, next_dma_buf);
 	}
 
 	if (samplesinbuf) {
@@ -724,7 +723,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		/* restart DMA if is not used double buffering */
 		pci9118_amcc_setup_dma(dev, 0);
 		if (devpriv->ai_do == 4)
-			interrupt_pci9118_ai_mode4_switch(dev);
+			interrupt_pci9118_ai_mode4_switch(dev, 0);
 	}
 }
 

commit e652632fc240f4ed40da60ec899cdcf3655afd37
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:39 2014 -0700

    staging: comedi: adl_pci9118: change type of pci9118_dmabuf 'virt' member
    
    For aesthetics, change the type of this member to avoid the casts when allocating
    and freeing the DMA buffers. This does introduce a cast in move_block_from_dma()
    but that cast is cleaner.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7bfaac781ae2..3e3405ccdede 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -205,7 +205,7 @@ static const struct pci9118_boardinfo pci9118_boards[] = {
 };
 
 struct pci9118_dmabuf {
-	unsigned short *virt;	/* virtual address of buffer */
+	unsigned long virt;	/* virtual address of buffer */
 	unsigned long hw;	/* hardware (bus) address of buffer */
 	unsigned int size;	/* size of dma buffer in bytes */
 	unsigned int use_size;	/* which size we may now use for transfer */
@@ -491,12 +491,13 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 }
 
 static int move_block_from_dma(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					unsigned short *dma_buffer,
-					unsigned int num_samples)
+			       struct comedi_subdevice *s,
+			       unsigned long virt_addr,
+			       unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned short *dma_buffer = (unsigned short *)virt_addr;
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
@@ -1616,8 +1617,7 @@ static void pci9118_alloc_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
 		for (pages = 4; pages >= 0; pages--) {
-			dmabuf->virt = (unsigned short *)
-					__get_free_pages(GFP_KERNEL, pages);
+			dmabuf->virt = __get_free_pages(GFP_KERNEL, pages);
 			if (dmabuf->virt)
 				break;
 		}
@@ -1646,7 +1646,7 @@ static void pci9118_free_dma(struct comedi_device *dev)
 	for (i = 0; i < 2; i++) {
 		dmabuf = &devpriv->dmabuf[i];
 		if (dmabuf->virt)
-			free_pages((unsigned long)dmabuf->virt, dmabuf->pages);
+			free_pages(dmabuf->virt, dmabuf->pages);
 	}
 }
 

commit 1f2cbe2c5b8ba5f34e3d6bde5c285b009e6342b4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:38 2014 -0700

    staging: comedi: adl_pci9118: introduce struct pci9118_dmabuf
    
    For aesthetics, wrap the DMA buffer information in a struct.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7de8732bf9a5..7bfaac781ae2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -204,6 +204,14 @@ static const struct pci9118_boardinfo pci9118_boards[] = {
 	},
 };
 
+struct pci9118_dmabuf {
+	unsigned short *virt;	/* virtual address of buffer */
+	unsigned long hw;	/* hardware (bus) address of buffer */
+	unsigned int size;	/* size of dma buffer in bytes */
+	unsigned int use_size;	/* which size we may now use for transfer */
+	int pages;		/* number of pages in buffer */
+};
+
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
 	unsigned int master:1;
@@ -239,19 +247,7 @@ struct pci9118_private {
 						 * on external start
 						 */
 	unsigned int dma_actbuf;		/* which buffer is used now */
-	unsigned short *dmabuf_virt[2];		/*
-						 * pointers to begin of
-						 * DMA buffer
-						 */
-	unsigned long dmabuf_hw[2];		/* hw address of DMA buff */
-	unsigned int dmabuf_size[2];		/*
-						 * size of dma buffer in bytes
-						 */
-	unsigned int dmabuf_use_size[2];	/*
-						 * which size we may now use
-						 * for transfer
-						 */
-	int dmabuf_pages[2];			/* number of pages in buffer */
+	struct pci9118_dmabuf dmabuf[2];
 	unsigned char exttrg_users;		/*
 						 * bit field of external trigger
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
@@ -274,11 +270,11 @@ struct pci9118_private {
 static void pci9118_amcc_setup_dma(struct comedi_device *dev, unsigned int buf)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[buf];
 
 	/* set the master write address and transfer count */
-	outl(devpriv->dmabuf_hw[buf], devpriv->iobase_a + AMCC_OP_REG_MWAR);
-	outl(devpriv->dmabuf_use_size[buf],
-	     devpriv->iobase_a + AMCC_OP_REG_MWTC);
+	outl(dmabuf->hw, devpriv->iobase_a + AMCC_OP_REG_MWAR);
+	outl(dmabuf->use_size, devpriv->iobase_a + AMCC_OP_REG_MWTC);
 }
 
 static void pci9118_amcc_dma_ena(struct comedi_device *dev, bool enable)
@@ -456,13 +452,15 @@ static int setup_channel_list(struct comedi_device *dev,
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct pci9118_dmabuf *dmabuf;
+
+	dmabuf = &devpriv->dmabuf[1 - devpriv->dma_actbuf];
 
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
 			  PCI9118_AI_CFG_AM;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-	pci9118_timer_write(dev, 0,
-			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
+	pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
 	devpriv->ai_cfg |= PCI9118_AI_CFG_START;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 }
@@ -689,10 +687,10 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
-	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;
-					/* number of received real samples */
+	samplesinbuf = dmabuf->use_size >> 1;	/* number of received samples */
 
 	if (devpriv->dma_doublebuf) {	/*
 					 * switch DMA buffers if is used
@@ -708,9 +706,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		/* how many samples is to end of buffer */
 		m = s->async->prealloc_bufsz >> 1;
 		sampls = m;
-		move_block_from_dma(dev, s,
-				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
-				    samplesinbuf);
+		move_block_from_dma(dev, s, dmabuf->virt, samplesinbuf);
 		m = m - sampls;		/* m=how many samples was transferred */
 	}
 
@@ -1016,10 +1012,12 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct pci9118_dmabuf *dmabuf0 = &devpriv->dmabuf[0];
+	struct pci9118_dmabuf *dmabuf1 = &devpriv->dmabuf[1];
 	unsigned int dmalen0, dmalen1, i;
 
-	dmalen0 = devpriv->dmabuf_size[0];
-	dmalen1 = devpriv->dmabuf_size[1];
+	dmalen0 = dmabuf0->size;
+	dmalen1 = dmabuf1->size;
 	/* isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > s->async->prealloc_bufsz) {
 		/* align to 32bit down */
@@ -1115,8 +1113,8 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 
 	/* these DMA buffer size will be used */
 	devpriv->dma_actbuf = 0;
-	devpriv->dmabuf_use_size[0] = dmalen0;
-	devpriv->dmabuf_use_size[1] = dmalen1;
+	dmabuf0->use_size = dmalen0;
+	dmabuf1->use_size = dmalen1;
 
 	pci9118_amcc_dma_ena(dev, false);
 	pci9118_amcc_setup_dma(dev, 0);
@@ -1184,6 +1182,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[0];
 
 	Compute_and_setup_dma(dev, s);
 
@@ -1218,7 +1217,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 				  PCI9118_AI_CFG_AM;
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
+		pci9118_timer_write(dev, 0, dmabuf->hw >> 1);
 		devpriv->ai_cfg |= PCI9118_AI_CFG_START;
 		break;
 	default:
@@ -1610,44 +1609,45 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 static void pci9118_alloc_dma(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct pci9118_dmabuf *dmabuf;
 	int pages;
 	int i;
 
 	for (i = 0; i < 2; i++) {
+		dmabuf = &devpriv->dmabuf[i];
 		for (pages = 4; pages >= 0; pages--) {
-			devpriv->dmabuf_virt[i] =
-				(unsigned short *)__get_free_pages(GFP_KERNEL,
-								   pages);
-			if (devpriv->dmabuf_virt[i])
+			dmabuf->virt = (unsigned short *)
+					__get_free_pages(GFP_KERNEL, pages);
+			if (dmabuf->virt)
 				break;
 		}
-		if (devpriv->dmabuf_virt[i]) {
-			devpriv->dmabuf_pages[i] = pages;
-			devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
-			devpriv->dmabuf_hw[i] = virt_to_bus((void *)
-						devpriv->dmabuf_virt[i]);
+		if (dmabuf->virt) {
+			dmabuf->pages = pages;
+			dmabuf->size = PAGE_SIZE * pages;
+			dmabuf->hw = virt_to_bus((void *)dmabuf->virt);
+
+			if (i == 0)
+				devpriv->master = 1;
+			if (i == 1)
+				devpriv->dma_doublebuf = 1;
 		}
 	}
-
-	if (devpriv->dmabuf_virt[0])
-		devpriv->master = 1;
-	if (devpriv->dmabuf_virt[1])
-		devpriv->dma_doublebuf = 1;
 }
 
 static void pci9118_free_dma(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct pci9118_dmabuf *dmabuf;
+	int i;
 
 	if (!devpriv)
 		return;
 
-	if (devpriv->dmabuf_virt[0])
-		free_pages((unsigned long)devpriv->dmabuf_virt[0],
-			   devpriv->dmabuf_pages[0]);
-	if (devpriv->dmabuf_virt[1])
-		free_pages((unsigned long)devpriv->dmabuf_virt[1],
-			   devpriv->dmabuf_pages[1]);
+	for (i = 0; i < 2; i++) {
+		dmabuf = &devpriv->dmabuf[i];
+		if (dmabuf->virt)
+			free_pages((unsigned long)dmabuf->virt, dmabuf->pages);
+	}
 }
 
 static int pci9118_common_attach(struct comedi_device *dev,

commit 231649a475c3938199f752410dc3ef0944ff37c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:37 2014 -0700

    staging: comedi: adl_pci9118: remove 'dmabuf_used_size' from private data
    
    This member of the private data is set but never used. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 98f2581a170c..7de8732bf9a5 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -251,7 +251,6 @@ struct pci9118_private {
 						 * which size we may now use
 						 * for transfer
 						 */
-	unsigned int dmabuf_used_size[2];	/* which size was truly used */
 	int dmabuf_pages[2];			/* number of pages in buffer */
 	unsigned char exttrg_users;		/*
 						 * bit field of external trigger
@@ -701,8 +700,6 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 					 */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		pci9118_amcc_setup_dma(dev, next_dma_buf);
-		devpriv->dmabuf_used_size[next_dma_buf] =
-		    devpriv->dmabuf_use_size[next_dma_buf];
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}

commit 32502f5aa1cd4772d29eabdce1cf82985edcfadd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:36 2014 -0700

    staging: comedi: adl_pci9118: convert private data true/false flags to bit-fields
    
    For aesthetics convert the private data true/false flags to bit-fields. The
    'usemux' member is used in the driver as a flag. Refactor the analog input
    subdevice init so this member can also be a bit-field.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cc48fe57ceb5..98f2581a170c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -206,12 +206,14 @@ static const struct pci9118_boardinfo pci9118_boards[] = {
 
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
-	unsigned int master;	/* master capable */
-	unsigned int usemux;	/* we want to use external multiplexor! */
+	unsigned int master:1;
+	unsigned int dma_doublebuf:1;
+	unsigned int ai_neverending:1;
+	unsigned int usedma:1;
+	unsigned int usemux:1;
 	unsigned char ai_ctrl;
 	unsigned char int_ctrl;
 	unsigned char ai_cfg;
-	char ai_neverending;		/* we do unlimited AI */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
 	unsigned int ai_n_realscanlen;	/*
@@ -236,7 +238,6 @@ struct pci9118_private {
 						 * divisors for start of measure
 						 * on external start
 						 */
-	char dma_doublebuf;			/* use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	unsigned short *dmabuf_virt[2];		/*
 						 * pointers to begin of
@@ -256,7 +257,6 @@ struct pci9118_private {
 						 * bit field of external trigger
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
 						 */
-	unsigned char usedma;		/* =1 use DMA transfer and not INT */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
 					 * numer is requested delay in ns
@@ -1694,7 +1694,7 @@ static int pci9118_common_attach(struct comedi_device *dev,
 		if (softsshdelay > 0)
 			if (ext_mux > 128)
 				ext_mux = 128;
-		devpriv->usemux = ext_mux;
+		devpriv->usemux = 1;
 	} else {
 		devpriv->usemux = 0;
 	}
@@ -1722,7 +1722,7 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
-	s->n_chan	= (devpriv->usemux) ? devpriv->usemux : 16;
+	s->n_chan	= (devpriv->usemux) ? ext_mux : 16;
 	s->maxdata	= board->ai_is_16bit ? 0xffff : 0x0fff;
 	s->range_table	= board->is_hg ? &pci9118hg_ai_range
 				       : &pci9118_ai_range;

commit f463b8c08067f58eee5352a5822e67f5fe7360f5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:35 2014 -0700

    staging: comedi: adl_pci9118: remove 'dmabuf_panic_size' from private data
    
    This member of the private data is only used in some #if 0'ed code. Remove
    it along with the unused code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dc5901493c9d..cc48fe57ceb5 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -251,7 +251,6 @@ struct pci9118_private {
 						 * for transfer
 						 */
 	unsigned int dmabuf_used_size[2];	/* which size was truly used */
-	unsigned int dmabuf_panic_size[2];
 	int dmabuf_pages[2];			/* number of pages in buffer */
 	unsigned char exttrg_users;		/*
 						 * bit field of external trigger
@@ -1122,22 +1121,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
 
-#if 0
-	if (cmd->scan_end_arg < PCI9118_HALF_FIFO_SZ) {
-		devpriv->dmabuf_panic_size[0] =
-		    (PCI9118_HALF_FIFO_SZ / cmd->scan_end_arg +
-		     1) * cmd->scan_end_arg * sizeof(short);
-		devpriv->dmabuf_panic_size[1] =
-		    (PCI9118_HALF_FIFO_SZ / cmd->scan_end_arg +
-		     1) * cmd->scan_end_arg * sizeof(short);
-	} else {
-		devpriv->dmabuf_panic_size[0] =
-		    (cmd->scan_end_arg << 1) % devpriv->dmabuf_size[0];
-		devpriv->dmabuf_panic_size[1] =
-		    (cmd->scan_end_arg << 1) % devpriv->dmabuf_size[1];
-	}
-#endif
-
 	pci9118_amcc_dma_ena(dev, false);
 	pci9118_amcc_setup_dma(dev, 0);
 	/* init DMA transfer */

commit 006e81e2bb06812bf6b0917d19c7f1ae1bbfcd3c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:34 2014 -0700

    staging: comedi: adl_pci9118: remove PCI9118_PARANOIDCHECK code
    
    The comment states that paramoid checks are broken. They also would only
    work for 12-bit analog input samples.
    
    Instead of fixing the paranoid checking just remove it to simplify the
    driver a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a5a59ee827e9..dc5901493c9d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -85,12 +85,6 @@
 #include "8253.h"
 #include "comedi_fc.h"
 
-/* paranoid checks are broken */
-#undef PCI9118_PARANOIDCHECK	/*
-				 * if defined, then is used code which control
-				 * correct channel number on every 12 bit sample
-				 */
-
 #define IORANGE_9118	64	/* I hope */
 #define PCI9118_CHANLEN	255	/*
 				 * len of chanlist, some source say 256,
@@ -214,13 +208,6 @@ struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
 	unsigned int master;	/* master capable */
 	unsigned int usemux;	/* we want to use external multiplexor! */
-#ifdef PCI9118_PARANOIDCHECK
-	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*
-							 * list of
-							 * scanned channel
-							 */
-	unsigned char chanlistlen;	/* number of scanlist */
-#endif
 	unsigned char ai_ctrl;
 	unsigned char int_ctrl;
 	unsigned char ai_cfg;
@@ -429,12 +416,6 @@ static int setup_channel_list(struct comedi_device *dev,
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 
-#ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlistlen = n_chan;
-	for (i = 0; i < (PCI9118_CHANLEN + 1); i++)
-		devpriv->chanlist[i] = 0x55aa;
-#endif
-
 	if (frontadd) {		/* insert channels for S&H */
 		ssh = devpriv->softsshsample;
 		for (i = 0; i < frontadd; i++) {
@@ -452,9 +433,6 @@ static int setup_channel_list(struct comedi_device *dev,
 
 	for (i = 0; i < n_chan; i++) {	/* store range list to card */
 		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
-#ifdef PCI9118_PARANOIDCHECK
-		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
-#endif
 		gain = CR_RANGE(chanlist[i]);		/* get gain number */
 		scanquad |= ((gain & 0x03) << 8);
 		outl(scanquad | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
@@ -470,10 +448,6 @@ static int setup_channel_list(struct comedi_device *dev,
 			     dev->iobase + PCI9118_AI_CHANLIST_REG);
 		}
 	}
-#ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
-						/* for 32bit operations */
-#endif
 	/* close scan queue */
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	/* udelay(100); important delay, or first sample will be crippled */
@@ -698,19 +672,6 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 
 	sampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 
-#ifdef PCI9118_PARANOIDCHECK
-	if (s->maxdata != 0xffff) {
-		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {
-							/* data dropout! */
-			dev_info(dev->class_dev,
-				 "A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
-				 sampl & 0x000f,
-				 devpriv->chanlist[s->async->cur_chan]);
-			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-			return;
-		}
-	}
-#endif
 	cfc_write_to_buffer(s, sampl);
 	s->async->cur_chan++;
 	if (s->async->cur_chan >= cmd->scan_end_arg) {

commit 45ada8e85c1c2c434256dcd54fb80450ed956ea6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:33 2014 -0700

    staging: comedi: adl_pci9118: do cfc_handle_events() at end of interrupt
    
    Each of the error detections currently do a cfc_handle_events() and exits
    the interrupt handler if the error is detected. The DMA and non-DMA handlers
    also to a cfc_handle_events().
    
    For aesthetics, use goto to exit the interrupt handler if an error is detected
    and move the cfc_handle_events() call to the end of the interrupt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 48d09de6ffc9..a5a59ee827e9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -707,7 +707,6 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 				 sampl & 0x000f,
 				 devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-			cfc_handle_events(dev, s);
 			return;
 		}
 	}
@@ -724,8 +723,6 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 				s->async->events |= COMEDI_CB_EOA;
 		}
 	}
-
-	cfc_handle_events(dev, s);
 }
 
 static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
@@ -775,8 +772,6 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
-
-	cfc_handle_events(dev, s);
 }
 
 static irqreturn_t pci9118_interrupt(int irq, void *d)
@@ -802,15 +797,13 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	if (intcsr & MASTER_ABORT_INT) {
 		dev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 
 	if (intcsr & TARGET_ABORT_INT) {
 		dev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 
 	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG);
@@ -818,27 +811,23 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 		dev_err(dev->class_dev,
 			"A/D FIFO Full status (Fatal Error!)\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 	if (adstat & PCI9118_AI_STATUS_BOVER) {
 		dev_err(dev->class_dev,
 			"A/D Burst Mode Overrun Status (Fatal Error!)\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 	if (adstat & PCI9118_AI_STATUS_ADOS) {
 		dev_err(dev->class_dev, "A/D Over Speed Status (Warning!)\n");
 		s->async->events |= COMEDI_CB_ERROR;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 	if (adstat & PCI9118_AI_STATUS_ADOR) {
 		dev_err(dev->class_dev, "A/D Overrun Status (Fatal Error!)\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-		cfc_handle_events(dev, s);
-		return IRQ_HANDLED;
+		goto interrupt_exit;
 	}
 
 	if (!devpriv->ai_do)
@@ -874,6 +863,8 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	else
 		interrupt_pci9118_ai_onesample(dev, s);
 
+interrupt_exit:
+	cfc_handle_events(dev, s);
 	return IRQ_HANDLED;
 }
 

commit f16a7b85168af1dc6621a7edb7925fca577e1017
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:32 2014 -0700

    staging: comedi: adl_pci9118: handle hardware errors in interrupt handler
    
    Hardware errors will now always terminate an async command. For aesthetics,
    absorb pci9118_decode_error_status() into the interrupt handler and use
    the register map defines to remove the "magic" numbers. Refactor the code
    to set the appropriate comedi event bits and handle the event.
    
    Remove the unnecessary 'ai_maskerr' and 'ai_maskharderr' members from the
    private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c10d35adb7a9..48d09de6ffc9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -283,8 +283,6 @@ struct pci9118_private {
 					 * polarity of S&H signal
 					 * in hold state
 					 */
-	unsigned int ai_maskerr;	/* which warning was printed */
-	unsigned int ai_maskharderr;	/* on which error bits stops */
 	unsigned int ai_ns_min;
 };
 
@@ -671,39 +669,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static char pci9118_decode_error_status(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					unsigned char m)
-{
-	struct pci9118_private *devpriv = dev->private;
-
-	if (m & 0x100) {
-		dev_err(dev->class_dev,
-			"A/D FIFO Full status (Fatal Error!)\n");
-		devpriv->ai_maskerr &= ~0x100L;
-	}
-	if (m & 0x008) {
-		dev_err(dev->class_dev,
-			"A/D Burst Mode Overrun Status (Fatal Error!)\n");
-		devpriv->ai_maskerr &= ~0x008L;
-	}
-	if (m & 0x004) {
-		dev_err(dev->class_dev, "A/D Over Speed Status (Warning!)\n");
-		devpriv->ai_maskerr &= ~0x004L;
-	}
-	if (m & 0x002) {
-		dev_err(dev->class_dev, "A/D Overrun Status (Fatal Error!)\n");
-		devpriv->ai_maskerr &= ~0x002L;
-	}
-	if (m & devpriv->ai_maskharderr) {
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		return 1;
-	}
-
-	return 0;
-}
-
 static void pci9118_ai_munge(struct comedi_device *dev,
 			     struct comedi_subdevice *s, void *data,
 			     unsigned int num_bytes,
@@ -848,10 +813,33 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG) & 0x1ff;
-	if (adstat & devpriv->ai_maskerr)
-		if (pci9118_decode_error_status(dev, s, adstat))
-			return IRQ_HANDLED;
+	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG);
+	if ((adstat & PCI9118_AI_STATUS_NFULL) == 0) {
+		dev_err(dev->class_dev,
+			"A/D FIFO Full status (Fatal Error!)\n");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
+	if (adstat & PCI9118_AI_STATUS_BOVER) {
+		dev_err(dev->class_dev,
+			"A/D Burst Mode Overrun Status (Fatal Error!)\n");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
+	if (adstat & PCI9118_AI_STATUS_ADOS) {
+		dev_err(dev->class_dev, "A/D Over Speed Status (Warning!)\n");
+		s->async->events |= COMEDI_CB_ERROR;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
+	if (adstat & PCI9118_AI_STATUS_ADOR) {
+		dev_err(dev->class_dev, "A/D Overrun Status (Fatal Error!)\n");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
 
 	if (!devpriv->ai_do)
 		return IRQ_HANDLED;
@@ -1338,7 +1326,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
-	devpriv->ai_maskerr = 0x10e;
 
 	/* prepare for start/stop conditions */
 	if (cmd->start_src == TRIG_EXT)
@@ -1868,8 +1855,6 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	/* get the current state of the digital outputs */
 	s->state = inl(dev->iobase + PCI9118_DIO_REG) >> 4;
 
-	devpriv->ai_maskharderr = 0x10a;
-
 	return 0;
 }
 

commit fed2c8406016f04b0d35b87c4aec77f4f0b7609b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:31 2014 -0700

    staging: comedi: adl_pci9118: handle error detection in main interrupt handler
    
    The DMA and non-DMA both check the analog input status value to detect
    hardware errors. For aesthetics, move the this detection into the main
    interrupt handler. This allows removing the unused 'int_adstat' parameter
    from the  DMA and non-DMA handlers. In addition, the 'int_daq' parameter
    is also not used so remove it also.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index d32c84a810a8..c10d35adb7a9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -725,18 +725,12 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 }
 
 static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
-					   struct comedi_subdevice *s,
-					   unsigned short int_adstat,
-					   unsigned short int_daq)
+					   struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short sampl;
 
-	if (int_adstat & devpriv->ai_maskerr)
-		if (pci9118_decode_error_status(dev, s, int_adstat))
-			return;
-
 	sampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 
 #ifdef PCI9118_PARANOIDCHECK
@@ -770,19 +764,12 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 }
 
 static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     unsigned short int_adstat,
-				     unsigned short int_daq)
+				     struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
-	if (int_adstat & devpriv->ai_maskerr)
-					/* if (int_adstat & 0x106) */
-		if (pci9118_decode_error_status(dev, s, int_adstat))
-			return;
-
 	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;
 					/* number of received real samples */
 
@@ -862,6 +849,9 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	}
 
 	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG) & 0x1ff;
+	if (adstat & devpriv->ai_maskerr)
+		if (pci9118_decode_error_status(dev, s, adstat))
+			return IRQ_HANDLED;
 
 	if (!devpriv->ai_do)
 		return IRQ_HANDLED;
@@ -892,9 +882,9 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->usedma)
-		interrupt_pci9118_ai_dma(dev, s, adstat, intsrc);
+		interrupt_pci9118_ai_dma(dev, s);
 	else
-		interrupt_pci9118_ai_onesample(dev, s, adstat, intsrc);
+		interrupt_pci9118_ai_onesample(dev, s);
 
 	return IRQ_HANDLED;
 }

commit 318141a18f7337338451512cc37ada3bf0a22ae6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:30 2014 -0700

    staging: comedi: adl_pci9118: handle master/target abort in main interrupt handler
    
    For aesthetics, move the master/target abort detection from the DMA handler to the
    main interrupt handler. This allows removing the unused 'int_amcc' parameter from
    the DMA and non-DMA handlers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 728df2503cc7..d32c84a810a8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -727,7 +727,6 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 					   struct comedi_subdevice *s,
 					   unsigned short int_adstat,
-					   unsigned int int_amcc,
 					   unsigned short int_daq)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -773,26 +772,12 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     unsigned short int_adstat,
-				     unsigned int int_amcc,
 				     unsigned short int_daq)
 {
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
-	if (int_amcc & MASTER_ABORT_INT) {
-		dev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		return;
-	}
-
-	if (int_amcc & TARGET_ABORT_INT) {
-		dev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
-		return;
-	}
 	if (int_adstat & devpriv->ai_maskerr)
 					/* if (int_adstat & 0x106) */
 		if (pci9118_decode_error_status(dev, s, int_adstat))
@@ -862,6 +847,20 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 
 	outl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
+	if (intcsr & MASTER_ABORT_INT) {
+		dev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
+
+	if (intcsr & TARGET_ABORT_INT) {
+		dev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		cfc_handle_events(dev, s);
+		return IRQ_HANDLED;
+	}
+
 	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG) & 0x1ff;
 
 	if (!devpriv->ai_do)
@@ -893,9 +892,9 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	}
 
 	if (devpriv->usedma)
-		interrupt_pci9118_ai_dma(dev, s, adstat, intcsr, intsrc);
+		interrupt_pci9118_ai_dma(dev, s, adstat, intsrc);
 	else
-		interrupt_pci9118_ai_onesample(dev, s, adstat, intcsr, intsrc);
+		interrupt_pci9118_ai_onesample(dev, s, adstat, intsrc);
 
 	return IRQ_HANDLED;
 }

commit 9e5314851a87ebf0ed4cfed100fd984b22111962
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:29 2014 -0700

    staging: comedi: adl_pci9118: don't ignore hardware errors
    
    The legacy (*attach) currently allows the user to pass a mask of error conditions
    to ignore when running async commands. Remove this support so that the async
    command is always terminated if the hardware reports an error.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 96d3d18cf412..728df2503cc7 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -55,11 +55,7 @@
  *	 0 != use ADCHN7(pin 23) signal is generated from driver, number say how
  *		long delay is requested in ns and sign polarity of the hold
  *		(in this case external multiplexor can serve only 128 channels)
- * [5] - 0=stop measure on all hardware errors
- *	 2 | = ignore ADOR - A/D Overrun status
- *	 8|=ignore Bover - A/D Burst Mode Overrun status
- *	 256|=ignore nFull - A/D FIFO Full status
- *
+ * [5] - ignored
  */
 
 /*
@@ -1747,8 +1743,7 @@ static void pci9118_free_dma(struct comedi_device *dev)
 }
 
 static int pci9118_common_attach(struct comedi_device *dev,
-				 int ext_mux, int softsshdelay,
-				 int hw_err_mask)
+				 int ext_mux, int softsshdelay)
 {
 	const struct pci9118_boardinfo *board = comedi_board(dev);
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -1885,9 +1880,6 @@ static int pci9118_common_attach(struct comedi_device *dev,
 	s->state = inl(dev->iobase + PCI9118_DIO_REG) >> 4;
 
 	devpriv->ai_maskharderr = 0x10a;
-					/* default measure crash condition */
-	if (hw_err_mask)		/* disable some requested */
-		devpriv->ai_maskharderr &= ~hw_err_mask;
 
 	return 0;
 }
@@ -1896,18 +1888,17 @@ static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
-	int ext_mux, softsshdelay, hw_err_mask;
+	int ext_mux, softsshdelay;
 
 	ext_mux = it->options[2];
 	softsshdelay = it->options[4];
-	hw_err_mask = it->options[5];
 
 	pcidev = pci9118_find_pci(dev, it);
 	if (!pcidev)
 		return -EIO;
 	comedi_set_hw_dev(dev, &pcidev->dev);
 
-	return pci9118_common_attach(dev, ext_mux, softsshdelay, hw_err_mask);
+	return pci9118_common_attach(dev, ext_mux, softsshdelay);
 }
 
 static int pci9118_auto_attach(struct comedi_device *dev,
@@ -1928,8 +1919,8 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 	 * (The 'put' also matches the implicit 'get' by pci9118_find_pci().)
 	 */
 	pci_dev_get(pcidev);
-	/* no external mux, no sample-hold delay, no error mask. */
-	return pci9118_common_attach(dev, 0, 0, 0);
+	/* no external mux, no sample-hold delay */
+	return pci9118_common_attach(dev, 0, 0);
 }
 
 static void pci9118_detach(struct comedi_device *dev)

commit cb578327814da1d9c91dc22c3e3f9a3ed6d7c40b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:28 2014 -0700

    staging: comedi: adl_pci9118: always try to use interrupt and DMA
    
    This driver currently supports both the (*auto_attach) and legacy (*attach)
    mechanisms. The (*auto_attach) always tries to use the interrupt and DMA to
    support async commands with the analog input subdevice. The legacy (*attach)
    only enables them depending on a user option that is passed to the (*attach).
    The 'default' (i.e. option == 0) is to enable both the interrupt and DMA.
    
    Simplify the attach by always trying to enable the interrupt and DMA.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f924ad978a15..96d3d18cf412 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -49,9 +49,7 @@
  *	 card will be used.
  * [2] - 0= standard 8 DIFF/16 SE channels configuration
  *	 n = external multiplexer connected, 1 <= n <= 256
- * [3] - 0=autoselect DMA or EOC interrupts operation
- *	 1 = disable DMA mode
- *	 3 = disable DMA and INT, only insn interface will work
+ * [3] - ignored
  * [4] - sample&hold signal - card can generate signal for external S&H board
  *	 0 = use SSHO(pin 45) signal is generated in onboard hardware S&H logic
  *	 0 != use ADCHN7(pin 23) signal is generated from driver, number say how
@@ -1748,8 +1746,8 @@ static void pci9118_free_dma(struct comedi_device *dev)
 			   devpriv->dmabuf_pages[1]);
 }
 
-static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
-				 int master, int ext_mux, int softsshdelay,
+static int pci9118_common_attach(struct comedi_device *dev,
+				 int ext_mux, int softsshdelay,
 				 int hw_err_mask)
 {
 	const struct pci9118_boardinfo *board = comedi_board(dev);
@@ -1767,22 +1765,20 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
-	if (master)
-		pci_set_master(pcidev);
+	pci_set_master(pcidev);
 
 	devpriv->iobase_a = pci_resource_start(pcidev, 0);
 	dev->iobase = pci_resource_start(pcidev, 2);
 
 	pci9118_reset(dev);
 
-	if (!disable_irq && pcidev->irq) {
+	if (pcidev->irq) {
 		ret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
 		if (ret == 0) {
 			dev->irq = pcidev->irq;
 
-			if (master)
-				pci9118_alloc_dma(dev);
+			pci9118_alloc_dma(dev);
 		}
 	}
 
@@ -1900,11 +1896,9 @@ static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
 	struct pci_dev *pcidev;
-	int ext_mux, disable_irq, master, softsshdelay, hw_err_mask;
+	int ext_mux, softsshdelay, hw_err_mask;
 
 	ext_mux = it->options[2];
-	master = ((it->options[3] & 1) == 0);
-	disable_irq = ((it->options[3] & 2) != 0);
 	softsshdelay = it->options[4];
 	hw_err_mask = it->options[5];
 
@@ -1913,8 +1907,7 @@ static int pci9118_attach(struct comedi_device *dev,
 		return -EIO;
 	comedi_set_hw_dev(dev, &pcidev->dev);
 
-	return pci9118_common_attach(dev, disable_irq, master, ext_mux,
-				     softsshdelay, hw_err_mask);
+	return pci9118_common_attach(dev, ext_mux, softsshdelay, hw_err_mask);
 }
 
 static int pci9118_auto_attach(struct comedi_device *dev,
@@ -1935,9 +1928,8 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 	 * (The 'put' also matches the implicit 'get' by pci9118_find_pci().)
 	 */
 	pci_dev_get(pcidev);
-	/* Don't disable irq, use bus master, no external mux,
-	 * no sample-hold delay, no error mask. */
-	return pci9118_common_attach(dev, 0, 1, 0, 0, 0);
+	/* no external mux, no sample-hold delay, no error mask. */
+	return pci9118_common_attach(dev, 0, 0, 0);
 }
 
 static void pci9118_detach(struct comedi_device *dev)

commit 6cf6b36768db5770c3faf4cb5864926142b069fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:27 2014 -0700

    staging: comedi: adl_pci9118: DMA requires an interrupt
    
    In order for DMA to work we also need an interrupt. Refactor the code
    so that the DMA allocation is only done if the interrupt is available.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7a55c9c70c7e..f924ad978a15 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1775,8 +1775,16 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 
 	pci9118_reset(dev);
 
-	if (master)
-		pci9118_alloc_dma(dev);
+	if (!disable_irq && pcidev->irq) {
+		ret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,
+				  dev->board_name, dev);
+		if (ret == 0) {
+			dev->irq = pcidev->irq;
+
+			if (master)
+				pci9118_alloc_dma(dev);
+		}
+	}
 
 	if (ext_mux > 0) {
 		if (ext_mux > 256)
@@ -1804,13 +1812,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	pci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);
 				/* Enable parity check for parity error */
 
-	if (!disable_irq && pcidev->irq) {
-		ret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,
-				  dev->board_name, dev);
-		if (ret == 0)
-			dev->irq = pcidev->irq;
-	}
-
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;

commit b9ca5508bc39462ee2e1988a23021d8fb1cadd6b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 13:05:26 2014 -0700

    staging: comedi: adl_pci9118: factor out DMA alloc/free
    
    For aesthetics, factor the DMA allocation/free code out of the attach
    and detach functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 41fa6152b74c..7a55c9c70c7e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1705,6 +1705,49 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 	return NULL;
 }
 
+static void pci9118_alloc_dma(struct comedi_device *dev)
+{
+	struct pci9118_private *devpriv = dev->private;
+	int pages;
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		for (pages = 4; pages >= 0; pages--) {
+			devpriv->dmabuf_virt[i] =
+				(unsigned short *)__get_free_pages(GFP_KERNEL,
+								   pages);
+			if (devpriv->dmabuf_virt[i])
+				break;
+		}
+		if (devpriv->dmabuf_virt[i]) {
+			devpriv->dmabuf_pages[i] = pages;
+			devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
+			devpriv->dmabuf_hw[i] = virt_to_bus((void *)
+						devpriv->dmabuf_virt[i]);
+		}
+	}
+
+	if (devpriv->dmabuf_virt[0])
+		devpriv->master = 1;
+	if (devpriv->dmabuf_virt[1])
+		devpriv->dma_doublebuf = 1;
+}
+
+static void pci9118_free_dma(struct comedi_device *dev)
+{
+	struct pci9118_private *devpriv = dev->private;
+
+	if (!devpriv)
+		return;
+
+	if (devpriv->dmabuf_virt[0])
+		free_pages((unsigned long)devpriv->dmabuf_virt[0],
+			   devpriv->dmabuf_pages[0]);
+	if (devpriv->dmabuf_virt[1])
+		free_pages((unsigned long)devpriv->dmabuf_virt[1],
+			   devpriv->dmabuf_pages[1]);
+}
+
 static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 				 int master, int ext_mux, int softsshdelay,
 				 int hw_err_mask)
@@ -1713,7 +1756,8 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pci9118_private *devpriv;
 	struct comedi_subdevice *s;
-	int ret, pages, i;
+	int ret;
+	int i;
 	u16 u16w;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -1731,33 +1775,8 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 
 	pci9118_reset(dev);
 
-	if (master) {		/* alloc DMA buffers */
-		devpriv->dma_doublebuf = 0;
-		for (i = 0; i < 2; i++) {
-			for (pages = 4; pages >= 0; pages--) {
-				devpriv->dmabuf_virt[i] =
-				    (unsigned short *)
-				    __get_free_pages(GFP_KERNEL, pages);
-				if (devpriv->dmabuf_virt[i])
-					break;
-			}
-			if (devpriv->dmabuf_virt[i]) {
-				devpriv->dmabuf_pages[i] = pages;
-				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
-				devpriv->dmabuf_hw[i] =
-				    virt_to_bus((void *)
-						devpriv->dmabuf_virt[i]);
-			}
-		}
-		if (!devpriv->dmabuf_virt[0]) {
-			dev_warn(dev->class_dev,
-				 "Can't allocate DMA buffer, DMA disabled!\n");
-			master = 0;
-		}
-		if (devpriv->dmabuf_virt[1])
-			devpriv->dma_doublebuf = 1;
-	}
-	devpriv->master = master;
+	if (master)
+		pci9118_alloc_dma(dev);
 
 	if (ext_mux > 0) {
 		if (ext_mux > 256)
@@ -1923,19 +1942,11 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 static void pci9118_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct pci9118_private *devpriv = dev->private;
 
 	if (dev->iobase)
 		pci9118_reset(dev);
 	comedi_pci_detach(dev);
-	if (devpriv) {
-		if (devpriv->dmabuf_virt[0])
-			free_pages((unsigned long)devpriv->dmabuf_virt[0],
-				   devpriv->dmabuf_pages[0]);
-		if (devpriv->dmabuf_virt[1])
-			free_pages((unsigned long)devpriv->dmabuf_virt[1],
-				   devpriv->dmabuf_pages[1]);
-	}
+	pci9118_free_dma(dev);
 	if (pcidev)
 		pci_dev_put(pcidev);
 }

commit 649a7d15d3ec3bc5327b8910946e2119e92425e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:51 2014 -0700

    staging: comedi: adl_pci9118: move analog input (*insn_read) function
    
    For aesthetics, move the analog input (*insn_read) function so it
    is not located in the middle of the async command support functions.
    Also, rename it for consistency.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 1fb63706bda8..41fa6152b74c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -489,66 +489,6 @@ static int setup_channel_list(struct comedi_device *dev,
 	return 1;		/* we can serve this with scan logic */
 }
 
-static int pci9118_ai_eoc(struct comedi_device *dev,
-			  struct comedi_subdevice *s,
-			  struct comedi_insn *insn,
-			  unsigned long context)
-{
-	unsigned int status;
-
-	status = inl(dev->iobase + PCI9118_AI_STATUS_REG);
-	if (status & PCI9118_AI_STATUS_ADRDY)
-		return 0;
-	return -EBUSY;
-}
-
-static void pci9118_ai_start_conv(struct comedi_device *dev)
-{
-	/* writing any value triggers an A/D conversion */
-	outl(0, dev->iobase + PCI9118_SOFTTRG_REG);
-}
-
-static int pci9118_insn_read_ai(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
-{
-	struct pci9118_private *devpriv = dev->private;
-	unsigned int val;
-	int ret;
-	int n;
-
-       /*
-	* Configure analog input based on the chanspec.
-	* Acqusition is software controlled without interrupts.
-	*/
-	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
-
-	/* set default config (disable burst and triggers) */
-	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
-	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-
-	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
-		return -EINVAL;
-
-	pci9118_ai_reset_fifo(dev);
-
-	for (n = 0; n < insn->n; n++) {
-		pci9118_ai_start_conv(dev);
-
-		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
-		if (ret)
-			return ret;
-
-		val = inl(dev->iobase + PCI9118_AI_FIFO_REG);
-		if (s->maxdata == 0xffff)
-			data[n] = (val & 0xffff) ^ 0x8000;
-		else
-			data[n] = (val >> 4) & 0xfff;
-	}
-
-	return n;
-}
-
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1600,6 +1540,67 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
+static int pci9118_ai_eoc(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_insn *insn,
+			  unsigned long context)
+{
+	unsigned int status;
+
+	status = inl(dev->iobase + PCI9118_AI_STATUS_REG);
+	if (status & PCI9118_AI_STATUS_ADRDY)
+		return 0;
+	return -EBUSY;
+}
+
+static void pci9118_ai_start_conv(struct comedi_device *dev)
+{
+	/* writing any value triggers an A/D conversion */
+	outl(0, dev->iobase + PCI9118_SOFTTRG_REG);
+}
+
+static int pci9118_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int val;
+	int ret;
+	int i;
+
+       /*
+	* Configure analog input based on the chanspec.
+	* Acqusition is software controlled without interrupts.
+	*/
+	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
+
+	/* set default config (disable burst and triggers) */
+	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
+
+	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
+		return -EINVAL;
+
+	pci9118_ai_reset_fifo(dev);
+
+	for (i = 0; i < insn->n; i++) {
+		pci9118_ai_start_conv(dev);
+
+		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
+		if (ret)
+			return ret;
+
+		val = inl(dev->iobase + PCI9118_AI_FIFO_REG);
+		if (s->maxdata == 0xffff)
+			data[i] = (val & 0xffff) ^ 0x8000;
+		else
+			data[i] = (val >> 4) & 0xfff;
+	}
+
+	return insn->n;
+}
+
 static int pci9118_ao_insn_write(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn,
@@ -1803,7 +1804,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->maxdata	= board->ai_is_16bit ? 0xffff : 0x0fff;
 	s->range_table	= board->is_hg ? &pci9118hg_ai_range
 				       : &pci9118_ai_range;
-	s->insn_read	= pci9118_insn_read_ai;
+	s->insn_read	= pci9118_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags	|= SDF_CMD_READ;

commit 4ed1bd5aa53de9995e40a22ab1bc3ba8850e0dcd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:50 2014 -0700

    staging: comedi: adl_pci9118: tidy up some wordy comments
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5743960f0928..1fb63706bda8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -523,15 +523,9 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	*/
 	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
 
+	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-						/*
-						 * positive triggers, no S&H,
-						 * no burst, burst stop,
-						 * no post trigger,
-						 * no about trigger,
-						 * trigger stop
-						 */
 
 	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
 		return -EINVAL;
@@ -714,20 +708,12 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 		pci9118_amcc_dma_ena(dev, false);
 	pci9118_exttrg_del(dev, EXTTRG_AI);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
+	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-					/*
-					 * positive triggers, no S&H, no burst,
-					 * burst stop, no post trigger,
-					 * no about trigger, trigger stop
-					 */
+	/* reset acqusition control */
 	devpriv->ai_ctrl = 0;
 	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
-					/*
-					 * bipolar, S.E., use 8254, stop 8354,
-					 * internal trigger, soft trigger,
-					 * disable INT and DMA
-					 */
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
 	/* reset scan queue */
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
@@ -1592,12 +1578,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	pci9118_start_pacer(dev, -1);	/* stop pacer */
 
+	/* set default config (disable burst and triggers) */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
-					/*
-					 * positive triggers, no S&H, no burst,
-					 * burst stop, no post trigger,
-					 * no about trigger, trigger stop
-					 */
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	udelay(1);
 	pci9118_ai_reset_fifo(dev);

commit 91ed3f750e10b785878a962637b7c360e61070df
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:49 2014 -0700

    staging: comedi: adl_pci9118: no need to reset ai FIFO after (*insn_read)
    
    The analog input FIFO is reset at the start of every (*insn_read) and (*do_cmd)
    operation. It's also reset for the analog input (*cancel).
    
    There's no reason to reset the FIFO if an (*insn_read) times out or after
    all the samples have been acquired.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c90afdfd76ca..5743960f0928 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -542,10 +542,8 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 		pci9118_ai_start_conv(dev);
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
-		if (ret) {
-			pci9118_ai_reset_fifo(dev);
+		if (ret)
 			return ret;
-		}
 
 		val = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 		if (s->maxdata == 0xffff)
@@ -554,9 +552,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 			data[n] = (val >> 4) & 0xfff;
 	}
 
-	pci9118_ai_reset_fifo(dev);
 	return n;
-
 }
 
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)

commit 959068c35447a5eb24d3ab3494e270a3bf6753e9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:48 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_amcc_setup_dma()
    
    Introduce a helper function to program the AMCC master write address and
    transfer count registers to setup a DMA transaction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0526afe02c8c..c90afdfd76ca 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -294,6 +294,16 @@ struct pci9118_private {
 	unsigned int ai_ns_min;
 };
 
+static void pci9118_amcc_setup_dma(struct comedi_device *dev, unsigned int buf)
+{
+	struct pci9118_private *devpriv = dev->private;
+
+	/* set the master write address and transfer count */
+	outl(devpriv->dmabuf_hw[buf], devpriv->iobase_a + AMCC_OP_REG_MWAR);
+	outl(devpriv->dmabuf_use_size[buf],
+	     devpriv->iobase_a + AMCC_OP_REG_MWTC);
+}
+
 static void pci9118_amcc_dma_ena(struct comedi_device *dev, bool enable)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -880,10 +890,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 					 * double buffering
 					 */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
-		outl(devpriv->dmabuf_hw[next_dma_buf],
-		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
-		outl(devpriv->dmabuf_use_size[next_dma_buf],
-		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		pci9118_amcc_setup_dma(dev, next_dma_buf);
 		devpriv->dmabuf_used_size[next_dma_buf] =
 		    devpriv->dmabuf_use_size[next_dma_buf];
 		if (devpriv->ai_do == 4)
@@ -906,13 +913,12 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 			s->async->events |= COMEDI_CB_EOA;
 	}
 
-	if (devpriv->dma_doublebuf) {	/* switch dma buffers */
+	if (devpriv->dma_doublebuf) {
+		/* switch dma buffers */
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
-	} else {	/* restart DMA if is not used double buffering */
-		outl(devpriv->dmabuf_hw[0],
-		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
-		outl(devpriv->dmabuf_use_size[0],
-		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
+	} else {
+		/* restart DMA if is not used double buffering */
+		pci9118_amcc_setup_dma(dev, 0);
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
@@ -1288,8 +1294,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 #endif
 
 	pci9118_amcc_dma_ena(dev, false);
-	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
-	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
+	pci9118_amcc_setup_dma(dev, 0);
 	/* init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);

commit 97d09d462aecd4e6c9b127a6fbe605c72b5dbeb6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:47 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_amcc_dma_ena()
    
    Introduce a helper function to program the AMCC master control/status
    register to enable/disable dma.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 834f6191e5e2..0526afe02c8c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -294,6 +294,19 @@ struct pci9118_private {
 	unsigned int ai_ns_min;
 };
 
+static void pci9118_amcc_dma_ena(struct comedi_device *dev, bool enable)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int mcsr;
+
+	mcsr = inl(devpriv->iobase_a + AMCC_OP_REG_MCSR);
+	if (enable)
+		mcsr |= RESET_A2P_FLAGS | A2P_HI_PRIORITY | EN_A2P_TRANSFERS;
+	else
+		mcsr &= ~EN_A2P_TRANSFERS;
+	outl(mcsr, devpriv->iobase_a + AMCC_OP_REG_MCSR);
+}
+
 static void pci9118_amcc_int_ena(struct comedi_device *dev, bool enable)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -692,9 +705,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 
 	if (devpriv->usedma)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &
-			(~EN_A2P_TRANSFERS),
-			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
+		pci9118_amcc_dma_ena(dev, false);
 	pci9118_exttrg_del(dev, EXTTRG_AI);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
 	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
@@ -1276,18 +1287,14 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	}
 #endif
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS),
-			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
+	pci9118_amcc_dma_ena(dev, false);
 	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
 	/* init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 /* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
-
-	outl(inl(devpriv->iobase_a +
-		 AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
-	     EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
+	pci9118_amcc_dma_ena(dev, true);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,
 			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 						/* allow bus mastering */

commit 312eaf0bfec60c840825312deccd6ffcc124b9d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:46 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_amcc_int_ena()
    
    Introduce a helper function to program the AMCC interrupt control/
    status register to enable/disable interrupts.
    
    Fix the analog input (*cancel). The analog input async command support
    is the only interrupt generator. The (*cancel) should always disable
    interrupts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 48287a5b8bb2..834f6191e5e2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -294,6 +294,20 @@ struct pci9118_private {
 	unsigned int ai_ns_min;
 };
 
+static void pci9118_amcc_int_ena(struct comedi_device *dev, bool enable)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int intcsr;
+
+	/* enable/disable interrupt for AMCC Incoming Mailbox 4 (32-bit) */
+	intcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	if (enable)
+		intcsr |= 0x1f00;
+	else
+		intcsr &= ~0x1f00;
+	outl(intcsr, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+}
+
 static void pci9118_timer_write(struct comedi_device *dev,
 				unsigned int timer, unsigned int val)
 {
@@ -592,9 +606,7 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 	devpriv->exttrg_users |= (1 << source);
 	devpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;
 	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-							/* allow INT in AMCC */
+	pci9118_amcc_int_ena(dev, true);
 	return 0;
 }
 
@@ -607,11 +619,8 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 	devpriv->exttrg_users &= ~(1 << source);
 	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
 		devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
-		if (!devpriv->int_ctrl)	/* all IRQ disabled */
-			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
-					(~0x00001f00),
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-						/* disable int in AMCC */
+		if (!devpriv->int_ctrl)
+			pci9118_amcc_int_ena(dev, false);
 		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	}
 	return 0;
@@ -708,6 +717,10 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	pci9118_ai_reset_fifo(dev);
 
+	devpriv->int_ctrl = 0;
+	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
+	pci9118_amcc_int_ena(dev, false);
+
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
 
@@ -718,11 +731,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	devpriv->ai_neverending = 0;
 	devpriv->dma_actbuf = 0;
 
-	if (!devpriv->int_ctrl)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-							/* allow INT in AMCC */
-
 	return 0;
 }
 
@@ -1319,9 +1327,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	devpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
-			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-							/* allow INT in AMCC */
+	pci9118_amcc_int_ena(dev, true);
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);

commit 26ec77653975adca0600e1ed865d95e5e442d7ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:45 2014 -0700

    staging: comedi: adl_pci9118: rename 'IntControlReg'
    
    Rename this CamelCase member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 1efa9ff4f854..48287a5b8bb2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -228,7 +228,7 @@ struct pci9118_private {
 	unsigned char chanlistlen;	/* number of scanlist */
 #endif
 	unsigned char ai_ctrl;
-	unsigned char IntControlReg;	/* Interrupt control register */
+	unsigned char int_ctrl;
 	unsigned char ai_cfg;
 	char ai_neverending;		/* we do unlimited AI */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
@@ -590,8 +590,8 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 	if (source > 3)
 		return -1;				/* incorrect source */
 	devpriv->exttrg_users |= (1 << source);
-	devpriv->IntControlReg |= PCI9118_INT_CTRL_DTRG;
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
+	devpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;
+	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 							/* allow INT in AMCC */
@@ -606,14 +606,13 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 		return -1;			/* incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
 	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
-		devpriv->IntControlReg &= ~PCI9118_INT_CTRL_DTRG;
-		if (!devpriv->IntControlReg)	/* all IRQ disabled */
+		devpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;
+		if (!devpriv->int_ctrl)	/* all IRQ disabled */
 			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
 					(~0x00001f00),
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 						/* disable int in AMCC */
-		outl(devpriv->IntControlReg,
-		     dev->iobase + PCI9118_INT_CTRL_REG);
+		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	}
 	return 0;
 }
@@ -719,7 +718,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	devpriv->ai_neverending = 0;
 	devpriv->dma_actbuf = 0;
 
-	if (!devpriv->IntControlReg)
+	if (!devpriv->int_ctrl)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 							/* allow INT in AMCC */
@@ -973,7 +972,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	devpriv->ai12_startstop &= ~START_AI_INT;
 	s->async->inttrig = NULL;
 
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
+	outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
@@ -1316,7 +1315,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 						/* activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
-		devpriv->IntControlReg |= PCI9118_INT_CTRL_TIMER;
+		devpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;
 
 	devpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;
 
@@ -1325,15 +1324,13 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 							/* allow INT in AMCC */
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->IntControlReg,
-		     dev->iobase + PCI9118_INT_CTRL_REG);
+		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
 		}
-		outl(devpriv->IntControlReg,
-		     dev->iobase + PCI9118_INT_CTRL_REG);
+		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 	}
 
 	return 0;
@@ -1396,8 +1393,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
-		outl(devpriv->IntControlReg,
-		     dev->iobase + PCI9118_INT_CTRL_REG);
+		outl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;

commit 559cc1ee79b1926891ce8ffb0b13acf8c6780857
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:44 2014 -0700

    staging: comedi: adl_pci9118: rename 'AdControlReg'
    
    Rename this CamelCase member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 349d960c4973..1efa9ff4f854 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -227,7 +227,7 @@ struct pci9118_private {
 							 */
 	unsigned char chanlistlen;	/* number of scanlist */
 #endif
-	unsigned char AdControlReg;	/* A/D control register */
+	unsigned char ai_ctrl;
 	unsigned char IntControlReg;	/* Interrupt control register */
 	unsigned char ai_cfg;
 	char ai_neverending;		/* we do unlimited AI */
@@ -326,12 +326,12 @@ static void pci9118_ai_set_range_aref(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(chanspec);
 	unsigned int aref = CR_AREF(chanspec);
 
-	devpriv->AdControlReg = 0;
+	devpriv->ai_ctrl = 0;
 	if (comedi_range_is_unipolar(s, range))
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_UNIP;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_UNIP;
 	if (aref == AREF_DIFF)
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_DIFF;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_DIFF;
+	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
 }
 
 static int check_channel_list(struct comedi_device *dev,
@@ -696,8 +696,8 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 					 * burst stop, no post trigger,
 					 * no about trigger, trigger stop
 					 */
-	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
+	devpriv->ai_ctrl = 0;
+	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
 					/*
 					 * bipolar, S.E., use 8254, stop 8354,
 					 * internal trigger, soft trigger,
@@ -939,7 +939,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 
 				/* start pacer */
 				pci9118_start_pacer(dev, devpriv->ai_do);
-				outl(devpriv->AdControlReg,
+				outl(devpriv->ai_ctrl,
 				     dev->iobase + PCI9118_AI_CTRL_REG);
 			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
 				/* deactivate EXT trigger */
@@ -977,9 +977,9 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
 	}
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
+	outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
 
 	return 1;
 }
@@ -1295,13 +1295,13 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	switch (devpriv->ai_do) {
 	case 1:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;
 		break;
 	case 2:
 		dev_err(dev->class_dev, "%s mode 2 bug!\n", __func__);
 		return -EIO;
 	case 3:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;
 		break;
 	case 4:
 		dev_err(dev->class_dev, "%s mode 4 bug!\n", __func__);
@@ -1318,7 +1318,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->IntControlReg |= PCI9118_INT_CTRL_TIMER;
 
-	devpriv->AdControlReg |= PCI9118_AI_CTRL_INT;
+	devpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;
 
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -1330,7 +1330,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
+			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
 		}
 		outl(devpriv->IntControlReg,
 		     dev->iobase + PCI9118_INT_CTRL_REG);
@@ -1349,12 +1349,12 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 	switch (devpriv->ai_do) {
 	case 1:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
-					 PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
+				    PCI9118_AI_CTRL_DMA;
 		break;
 	case 2:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
-					 PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
+				    PCI9118_AI_CTRL_DMA;
 		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
 				  PCI9118_AI_CFG_PETRG |
 				  PCI9118_AI_CFG_BM |
@@ -1365,14 +1365,14 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 		break;
 	case 3:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM |
-					 PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM |
+				    PCI9118_AI_CTRL_DMA;
 		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
 				  PCI9118_AI_CFG_PETRG;
 		break;
 	case 4:
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
-					 PCI9118_AI_CTRL_DMA;
+		devpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR |
+				    PCI9118_AI_CTRL_DMA;
 		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
 				  PCI9118_AI_CFG_PETRG |
 				  PCI9118_AI_CFG_AM;
@@ -1400,9 +1400,9 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		     dev->iobase + PCI9118_INT_CTRL_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
+			devpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;
 		}
-		outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
+		outl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);
 	}
 
 	return 0;

commit 5bdee661653cebd4f4f3fd0ea836c9ea91a383e9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:43 2014 -0700

    staging: comedi: adl_pci9118: rename 'AdFunctionReg'
    
    Rename this CamelCase member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 398f6e1574eb..349d960c4973 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -229,7 +229,7 @@ struct pci9118_private {
 #endif
 	unsigned char AdControlReg;	/* A/D control register */
 	unsigned char IntControlReg;	/* Interrupt control register */
-	unsigned char AdFunctionReg;	/* A/D function register */
+	unsigned char ai_cfg;
 	char ai_neverending;		/* we do unlimited AI */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
@@ -486,8 +486,8 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	*/
 	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
 
-	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
 						 * positive triggers, no S&H,
 						 * no burst, burst stop,
@@ -526,14 +526,14 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
-				 PCI9118_AI_CFG_AM;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
+			  PCI9118_AI_CFG_AM;
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_timer_write(dev, 0,
 			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
-	devpriv->AdFunctionReg |= PCI9118_AI_CFG_START;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	devpriv->ai_cfg |= PCI9118_AI_CFG_START;
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 }
 
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
@@ -689,8 +689,8 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
-	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 					/*
 					 * positive triggers, no S&H, no burst,
 					 * burst stop, no post trigger,
@@ -974,7 +974,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
@@ -1327,7 +1327,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->IntControlReg,
 		     dev->iobase + PCI9118_INT_CTRL_REG);
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
@@ -1355,31 +1355,31 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	case 2:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
-					 PCI9118_AI_CFG_PETRG |
-					 PCI9118_AI_CFG_BM |
-					 PCI9118_AI_CFG_BS;
+		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
+				  PCI9118_AI_CFG_PETRG |
+				  PCI9118_AI_CFG_BM |
+				  PCI9118_AI_CFG_BS;
 		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
-			devpriv->AdFunctionReg |= PCI9118_AI_CFG_BSSH;
+			devpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;
 		outl(devpriv->ai_n_realscanlen,
 		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 		break;
 	case 3:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
-					 PCI9118_AI_CFG_PETRG;
+		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
+				  PCI9118_AI_CFG_PETRG;
 		break;
 	case 4:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
-					 PCI9118_AI_CFG_PETRG |
-					 PCI9118_AI_CFG_AM;
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+		devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG |
+				  PCI9118_AI_CFG_PETRG |
+				  PCI9118_AI_CFG_AM;
+		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
-		devpriv->AdFunctionReg |= PCI9118_AI_CFG_START;
+		devpriv->ai_cfg |= PCI9118_AI_CFG_START;
 		break;
 	default:
 		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
@@ -1395,7 +1395,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+		outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 		outl(devpriv->IntControlReg,
 		     dev->iobase + PCI9118_INT_CTRL_REG);
 		if (devpriv->ai_do != 3) {
@@ -1582,13 +1582,13 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	pci9118_start_pacer(dev, -1);	/* stop pacer */
 
-	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
+	devpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 					/*
 					 * positive triggers, no S&H, no burst,
 					 * burst stop, no post trigger,
 					 * no about trigger, trigger stop
 					 */
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
+	outl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);
 	udelay(1);
 	pci9118_ai_reset_fifo(dev);
 

commit 26318c1c167517a83f3561767738d08e98757630
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:42 2014 -0700

    staging: comedi: adl_pci9118: fix ai range/aref programming
    
    Currently the analog input range and aref are set in setup_channel_list().
    This works for the (*insn_read) but the (*do_cmd) has a problem.
    
    In (*do_cmd) the ai control register is reset to 0 before the function works
    out the bits needed to control the acquisition. This happens after the
    setup_channel_list() call so the range is reset to bipolar and the aref to
    single-ended.
    
    Introduce a helper function, pci9118_ai_set_range_aref(), to handle the
    programming of the range and aref bits. This function first clears the
    cached value of the ai control register in the private data then sets the
    appropriate bits. The (*insn_read) and (*do_cmd) can then set the other
    bits needed to control the acquisition.
    
    Then setup_channel_list() just needs to program the chanlist scan data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e3e405237330..398f6e1574eb 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -318,6 +318,22 @@ static void pci9118_ai_reset_fifo(struct comedi_device *dev)
 	outl(0, dev->iobase + PCI9118_FIFO_RESET_REG);
 }
 
+static void pci9118_ai_set_range_aref(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int chanspec)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int range = CR_RANGE(chanspec);
+	unsigned int aref = CR_AREF(chanspec);
+
+	devpriv->AdControlReg = 0;
+	if (comedi_range_is_unipolar(s, range))
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_UNIP;
+	if (aref == AREF_DIFF)
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_DIFF;
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
+}
+
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -371,33 +387,14 @@ static int setup_channel_list(struct comedi_device *dev,
 			      int backadd, int usedma)
 {
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, differencial = 0, bipolar = 0;
 	unsigned int scanquad, gain, ssh = 0x00;
+	int i;
 
 	if (usedma == 1) {
 		rot = 8;
 		usedma = 0;
 	}
 
-	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/* all input must be diff */
-	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/* all input must be bipolar */
-
-	/* All is ok, so we can setup channel/range list */
-
-	if (!bipolar)
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_UNIP;
-	else
-		devpriv->AdControlReg &= ~PCI9118_AI_CTRL_UNIP;
-
-	if (differencial)
-		devpriv->AdControlReg |= PCI9118_AI_CTRL_DIFF;
-	else
-		devpriv->AdControlReg &= ~PCI9118_AI_CTRL_DIFF;
-
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
-								/* setup mode */
 	/* gods know why this sequence! */
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
@@ -483,7 +480,12 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	int ret;
 	int n;
 
-	devpriv->AdControlReg = 0;
+       /*
+	* Configure analog input based on the chanspec.
+	* Acqusition is software controlled without interrupts.
+	*/
+	pci9118_ai_set_range_aref(dev, s, insn->chanspec);
+
 	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
@@ -1515,6 +1517,16 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				cmd->chanlist, devpriv->ai_add_front,
 				devpriv->ai_add_back))
 		return -EINVAL;
+
+	/*
+	 * Configure analog input based on the first chanlist entry.
+	 * All entries are either unipolar or bipolar and single-ended
+	 * or differential.
+	 *
+	 * The acqusition control bits are enabled later.
+	 */
+	pci9118_ai_set_range_aref(dev, s, cmd->chanlist[0]);
+
 	if (!setup_channel_list(dev, s, cmd->chanlist_len,
 				cmd->chanlist, 0, devpriv->ai_add_front,
 				devpriv->ai_add_back, devpriv->usedma))
@@ -1570,12 +1582,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	pci9118_start_pacer(dev, -1);	/* stop pacer */
 
-	devpriv->AdControlReg = 0;	/*
-					 * bipolar, S.E., use 8254, stop 8354,
-					 * internal trigger, soft trigger,
-					 * disable DMA
-					 */
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 					/*
 					 * positive triggers, no S&H, no burst,

commit bdbeaed3f869d474774edc72a8f1ba6e091e2d82
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:41 2014 -0700

    staging: comedi: adl_pci9118: ai (*insn_read) does not use interrupts
    
    The analog input (*insn_read) in this driver is done as a software-triggered,
    polled operation. The PCI9118_AI_CTRL_INT bit in the control register, which
    is actually set in setup_channel_list(), should not be set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 56458acdac75..e3e405237330 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -483,7 +483,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	int ret;
 	int n;
 
-	devpriv->AdControlReg = PCI9118_AI_CTRL_INT;
+	devpriv->AdControlReg = 0;
 	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*

commit 5358e8996f76ba5f44992226f7eb15d502c663fa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:40 2014 -0700

    staging: comedi: adl_pci9118: cleanup and simplify pci9118_reset()
    
    Change the return type to void, this function always succeeds and the
    callers never check the return value.
    
    According to the The User Manual for the PCI-9118, the hardware does not
    require any particular "reset" in order to function. Simplify the reset
    so it justs gets the board info a known state with interrupts disabled.
    
    There is no reason to initialize the private data members in this function.
    They all default to '0' due to the kzalloc() of the private data and the
    subdevice operations all initialize them as needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4a956ccb1acc..56458acdac75 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1654,63 +1654,30 @@ static int pci9118_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int pci9118_reset(struct comedi_device *dev)
+static void pci9118_reset(struct comedi_device *dev)
 {
-	struct pci9118_private *devpriv = dev->private;
+	/* reset analog input subsystem */
+	outl(0, dev->iobase + PCI9118_INT_CTRL_REG);
+	outl(0, dev->iobase + PCI9118_AI_CTRL_REG);
+	outl(0, dev->iobase + PCI9118_AI_CFG_REG);
+	pci9118_ai_reset_fifo(dev);
 
-	devpriv->IntControlReg = 0;
-	devpriv->exttrg_users = 0;
-	/* clear interrupts then disable all interrupt sources */
+	/* clear any pending interrupts and status */
 	inl(dev->iobase + PCI9118_INT_CTRL_REG);
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
+	inl(dev->iobase + PCI9118_AI_STATUS_REG);
+
+	/* reset and stop counters */
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
-	pci9118_start_pacer(dev, 0);		/* stop 8254 counters */
-	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
-						/*
-						 * bipolar, S.E., use 8254,
-						 * stop 8354, internal trigger,
-						 * soft trigger,
-						 * disable INT and DMA
-						 */
+	pci9118_start_pacer(dev, 0);
+
+	/* reset DMA and scan queue */
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
-	/* reset scan queue */
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
-	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
-						/*
-						 * positive triggers, no S&H,
-						 * no burst, burst stop,
-						 * no post trigger,
-						 * no about trigger,
-						 * trigger stop
-						 */
 
 	/* reset analog outputs to 0V */
 	outl(2047, dev->iobase + PCI9118_AO_REG(0));
 	outl(2047, dev->iobase + PCI9118_AO_REG(1));
-
-	udelay(10);
-	inl(dev->iobase + PCI9118_AI_FIFO_REG);
-	pci9118_ai_reset_fifo(dev);
-	/* disable all interrupt sources */
-	outl(0, dev->iobase + PCI9118_INT_CTRL_REG);
-	/* clear A/D and INT status registers */
-	inl(dev->iobase + PCI9118_AI_STATUS_REG);
-	inl(dev->iobase + PCI9118_INT_CTRL_REG);
-	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
-						/*
-						 * bipolar, S.E., use 8254,
-						 * stop 8354, internal trigger,
-						 * soft trigger,
-						 * disable INT and DMA
-						 */
-
-	devpriv->exttrg_users = 0;
-
-	return 0;
 }
 
 static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,

commit 3cb3fc0a0292a720a87651337497af39f77ac64a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:39 2014 -0700

    staging: comedi: adl_pci9118: move analog output (*insn_write) function
    
    For aesthetics, move the analog output (*insn_write) function so it
    is not located in the middle of the analog input functions. Also,
    rename it for consistency.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index bd4dee21b302..4a956ccb1acc 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -520,24 +520,6 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 }
 
-static int pci9118_insn_write_ao(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn,
-				 unsigned int *data)
-{
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int val = s->readback[chan];
-	int i;
-
-	for (i = 0; i < insn->n; i++) {
-		val = data[i];
-		outl(val, dev->iobase + PCI9118_AO_REG(chan));
-	}
-	s->readback[chan] = val;
-
-	return insn->n;
-}
-
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1620,6 +1602,24 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
+static int pci9118_ao_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int val = s->readback[chan];
+	int i;
+
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		outl(val, dev->iobase + PCI9118_AO_REG(chan));
+	}
+	s->readback[chan] = val;
+
+	return insn->n;
+}
+
 static int pci9118_di_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -1870,7 +1870,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->n_chan	= 2;
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar10;
-	s->insn_write	= pci9118_insn_write_ao;
+	s->insn_write	= pci9118_ao_insn_write;
 	s->insn_read	= comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);

commit 458a76f4eeb3cb042878001d36ad796d411e7d80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:38 2014 -0700

    staging: comedi: adl_pci9118: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    The board is "reset" prior to the subdevice init. Part of this reset
    sets all the analog output channels to 0V. Move the initialization of
    the 'readback' values after the 'readback' member has been allocated.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b89021ff6080..bd4dee21b302 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -255,7 +255,6 @@ struct pci9118_private {
 						 * divisors for start of measure
 						 * on external start
 						 */
-	unsigned short ao_data[2];		/* data output buffer */
 	char dma_doublebuf;			/* use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	unsigned short *dmabuf_virt[2];		/*
@@ -523,32 +522,20 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 static int pci9118_insn_write_ao(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
-	struct pci9118_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	int n;
+	unsigned int val = s->readback[chan];
+	int i;
 
-	for (n = 0; n < insn->n; n++) {
-		outl(data[n], dev->iobase + PCI9118_AO_REG(chan));
-		devpriv->ao_data[chan] = data[n];
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		outl(val, dev->iobase + PCI9118_AO_REG(chan));
 	}
+	s->readback[chan] = val;
 
-	return n;
-}
-
-static int pci9118_insn_read_ao(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
-{
-	struct pci9118_private *devpriv = dev->private;
-	int n, chan;
-
-	chan = CR_CHAN(insn->chanspec);
-	for (n = 0; n < insn->n; n++)
-		data[n] = devpriv->ao_data[chan];
-
-	return n;
+	return insn->n;
 }
 
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
@@ -1701,10 +1688,8 @@ static int pci9118_reset(struct comedi_device *dev)
 						 */
 
 	/* reset analog outputs to 0V */
-	devpriv->ao_data[0] = 2047;
-	devpriv->ao_data[1] = 2047;
-	outl(devpriv->ao_data[0], dev->iobase + PCI9118_AO_REG(0));
-	outl(devpriv->ao_data[1], dev->iobase + PCI9118_AO_REG(1));
+	outl(2047, dev->iobase + PCI9118_AO_REG(0));
+	outl(2047, dev->iobase + PCI9118_AO_REG(1));
 
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
@@ -1886,7 +1871,15 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->maxdata	= 0x0fff;
 	s->range_table	= &range_bipolar10;
 	s->insn_write	= pci9118_insn_write_ao;
-	s->insn_read	= pci9118_insn_read_ao;
+	s->insn_read	= comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
+	/* the analog outputs were reset to 0V, make the readback match */
+	for (i = 0; i < s->n_chan; i++)
+		s->readback[i] = 2047;
 
 	/* Digital Input subdevice */
 	s = &dev->subdevices[2];

commit f300fab2fcc281ef5b975ba0af9abd4a88af8599
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:37 2014 -0700

    staging: comedi: adl_pci9118: move digitial input (*insn_bits) function
    
    For aesthetics, move the digital inputs (*insn_bits) function so it
    is not located in the middle of the analog input functions. Also,
    rename it for consistency.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c758a467aad4..b89021ff6080 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -551,21 +551,6 @@ static int pci9118_insn_read_ao(struct comedi_device *dev,
 	return n;
 }
 
-static int pci9118_insn_bits_di(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
-{
-	/*
-	 * The digital inputs and outputs share the read register.
-	 * bits [7:4] are the digital outputs
-	 * bits [3:0] are the digital inputs
-	 */
-	data[1] = inl(dev->iobase + PCI9118_DIO_REG) & 0xf;
-
-	return insn->n;
-}
-
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1648,6 +1633,21 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
+static int pci9118_di_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+	/*
+	 * The digital inputs and outputs share the read register.
+	 * bits [7:4] are the digital outputs
+	 * bits [3:0] are the digital inputs
+	 */
+	data[1] = inl(dev->iobase + PCI9118_DIO_REG) & 0xf;
+
+	return insn->n;
+}
+
 static int pci9118_do_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -1895,7 +1895,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->n_chan	= 4;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_bits	= pci9118_insn_bits_di;
+	s->insn_bits	= pci9118_di_insn_bits;
 
 	/* Digital Output subdevice */
 	s = &dev->subdevices[3];

commit 304e2be17e9f1675516e90a7e38cc40769567d4b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:36 2014 -0700

    staging: comedi: adl_pci9118: don't reset digital outputs
    
    Currently this driver resets the digital output channels to a low state
    when the driver is attached and detached.
    
    Since the digital output state can be read, initialize the subdevice
    state when the driver is attached and don't reset them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a9fd34306676..c758a467aad4 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1706,7 +1706,6 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(devpriv->ao_data[0], dev->iobase + PCI9118_AO_REG(0));
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_AO_REG(1));
 
-	outl(0, dev->iobase + PCI9118_DIO_REG);	/* reset digi outs to L */
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
 	pci9118_ai_reset_fifo(dev);
@@ -1907,6 +1906,9 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->range_table	= &range_digital;
 	s->insn_bits	= pci9118_do_insn_bits;
 
+	/* get the current state of the digital outputs */
+	s->state = inl(dev->iobase + PCI9118_DIO_REG) >> 4;
+
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */
 	if (hw_err_mask)		/* disable some requested */

commit 8df6166b4da383fa9712b3a3883c64c4e4b24501
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Sep 5 09:25:35 2014 -0700

    staging: comedi: adl_pci9118: move digitial output (*insn_bits) function
    
    For aesthetics, move the digital outputs (*insn_bits) function so it
    is not located in the middle of the analog input functions. Also,
    rename it for consistency.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 03ca818297f0..a9fd34306676 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -566,25 +566,6 @@ static int pci9118_insn_bits_di(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int pci9118_insn_bits_do(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
-{
-	/*
-	 * The digital outputs are set with the same register that
-	 * the digital inputs and outputs are read from. But the
-	 * outputs are set with bits [3:0] so we can simply write
-	 * the s->state to set them.
-	 */
-	if (comedi_dio_update_state(s, data))
-		outl(s->state, dev->iobase + PCI9118_DIO_REG);
-
-	data[1] = s->state;
-
-	return insn->n;
-}
-
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1667,6 +1648,25 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
+static int pci9118_do_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+	/*
+	 * The digital outputs are set with the same register that
+	 * the digital inputs and outputs are read from. But the
+	 * outputs are set with bits [3:0] so we can simply write
+	 * the s->state to set them.
+	 */
+	if (comedi_dio_update_state(s, data))
+		outl(s->state, dev->iobase + PCI9118_DIO_REG);
+
+	data[1] = s->state;
+
+	return insn->n;
+}
+
 static int pci9118_reset(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1905,7 +1905,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->n_chan	= 4;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_bits	= pci9118_insn_bits_do;
+	s->insn_bits	= pci9118_do_insn_bits;
 
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */

commit 00bd059fee89b26d7c4b064abff716174aaacae0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:27 2014 -0700

    staging: comedi: adl_pci9118: tidy up the interrupt control/status bit defines
    
    Rename the CamelCase defines used for the interrupt control/status register
    bits and convert them to bit shifts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dd7faed9a699..03ca818297f0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -145,13 +145,10 @@
 #define PCI9118_AI_CFG_START		(1 << 0)  /* 1=trigger start */
 #define PCI9118_FIFO_RESET_REG		0x34
 #define PCI9118_INT_CTRL_REG		0x38
-
-/* bits for interrupt reason and control (PCI9118_INT_CTRL_REG) */
-/* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
-#define Int_Timer	0x08	/* timer interrupt */
-#define Int_About	0x04	/* about trigger complete */
-#define Int_Hfull	0x02	/* A/D FIFO hlaf full */
-#define Int_DTrg	0x01	/* external digital trigger */
+#define PCI9118_INT_CTRL_TIMER		(1 << 3)  /* timer interrupt */
+#define PCI9118_INT_CTRL_ABOUT		(1 << 2)  /* about trigger complete */
+#define PCI9118_INT_CTRL_HFULL		(1 << 1)  /* A/D FIFO half full */
+#define PCI9118_INT_CTRL_DTRG		(1 << 0)  /* ext. digital trigger */
 
 #define START_AI_EXT	0x01	/* start measure on external trigger */
 #define STOP_AI_EXT	0x02	/* stop measure on external trigger */
@@ -656,7 +653,7 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 	if (source > 3)
 		return -1;				/* incorrect source */
 	devpriv->exttrg_users |= (1 << source);
-	devpriv->IntControlReg |= Int_DTrg;
+	devpriv->IntControlReg |= PCI9118_INT_CTRL_DTRG;
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -672,7 +669,7 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 		return -1;			/* incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
 	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
-		devpriv->IntControlReg &= ~Int_DTrg;
+		devpriv->IntControlReg &= ~PCI9118_INT_CTRL_DTRG;
 		if (!devpriv->IntControlReg)	/* all IRQ disabled */
 			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
 					(~0x00001f00),
@@ -994,7 +991,8 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 
 	if (devpriv->ai12_startstop) {
-		if ((adstat & PCI9118_AI_STATUS_DTH) && (intsrc & Int_DTrg)) {
+		if ((adstat & PCI9118_AI_STATUS_DTH) &&
+		    (intsrc & PCI9118_INT_CTRL_DTRG)) {
 			/* start/stop of measure */
 			if (devpriv->ai12_startstop & START_AI_EXT) {
 				/* deactivate EXT trigger */
@@ -1381,7 +1379,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 						/* activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
-		devpriv->IntControlReg |= Int_Timer;
+		devpriv->IntControlReg |= PCI9118_INT_CTRL_TIMER;
 
 	devpriv->AdControlReg |= PCI9118_AI_CTRL_INT;
 

commit 74ba15ede74b78e8721d3d8750f5158aa31cfa87
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:26 2014 -0700

    staging: comedi: adl_pci9118: tidy up the interrupt control/status register
    
    The register at offset 0x38 is the "interrupt control" register when written
    and the "interrupt status" register when read. Both registers use the same
    bit defines.
    
    For aesthetics, use a common define for this register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 266eb3f3a4ed..dd7faed9a699 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -144,11 +144,9 @@
 #define PCI9118_AI_CFG_AM		(1 << 1)  /* 1=about trigger */
 #define PCI9118_AI_CFG_START		(1 << 0)  /* 1=trigger start */
 #define PCI9118_FIFO_RESET_REG		0x34
+#define PCI9118_INT_CTRL_REG		0x38
 
-#define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
-#define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
-
-/* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
+/* bits for interrupt reason and control (PCI9118_INT_CTRL_REG) */
 /* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
 #define Int_About	0x04	/* about trigger complete */
@@ -659,7 +657,7 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 		return -1;				/* incorrect source */
 	devpriv->exttrg_users |= (1 << source);
 	devpriv->IntControlReg |= Int_DTrg;
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 							/* allow INT in AMCC */
@@ -680,7 +678,8 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 					(~0x00001f00),
 					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 						/* disable int in AMCC */
-		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		outl(devpriv->IntControlReg,
+		     dev->iobase + PCI9118_INT_CTRL_REG);
 	}
 	return 0;
 }
@@ -981,7 +980,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 	if (!dev->attached)
 		return IRQ_NONE;
 
-	intsrc = inl(dev->iobase + PCI9118_INTSRC) & 0xf;
+	intsrc = inl(dev->iobase + PCI9118_INT_CTRL_REG) & 0xf;
 	intcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
 	if (!intsrc && !(intcsr & ANY_S593X_INT))
@@ -1039,7 +1038,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	devpriv->ai12_startstop &= ~START_AI_INT;
 	s->async->inttrig = NULL;
 
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
@@ -1391,13 +1390,15 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 							/* allow INT in AMCC */
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		outl(devpriv->IntControlReg,
+		     dev->iobase + PCI9118_INT_CTRL_REG);
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
 		}
-		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		outl(devpriv->IntControlReg,
+		     dev->iobase + PCI9118_INT_CTRL_REG);
 	}
 
 	return 0;
@@ -1460,7 +1461,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
-		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		outl(devpriv->IntControlReg,
+		     dev->iobase + PCI9118_INT_CTRL_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
@@ -1653,7 +1655,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* clear A/D and INT status registers */
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
-	inl(dev->iobase + PCI9118_INTSRC);
+	inl(dev->iobase + PCI9118_INT_CTRL_REG);
 
 	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
@@ -1673,9 +1675,9 @@ static int pci9118_reset(struct comedi_device *dev)
 
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
-	inl(dev->iobase + PCI9118_INTCTRL);
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-						/* disable interrupts source */
+	/* clear interrupts then disable all interrupt sources */
+	inl(dev->iobase + PCI9118_INT_CTRL_REG);
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INT_CTRL_REG);
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_start_pacer(dev, 0);		/* stop 8254 counters */
 	devpriv->AdControlReg = 0;
@@ -1710,10 +1712,11 @@ static int pci9118_reset(struct comedi_device *dev)
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
 	pci9118_ai_reset_fifo(dev);
-	outl(0, dev->iobase + PCI9118_INTSRC);	/* remove INT requests */
+	/* disable all interrupt sources */
+	outl(0, dev->iobase + PCI9118_INT_CTRL_REG);
 	/* clear A/D and INT status registers */
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
-	inl(dev->iobase + PCI9118_INTSRC);
+	inl(dev->iobase + PCI9118_INT_CTRL_REG);
 	devpriv->AdControlReg = 0;
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 						/*

commit 582e59c042641b4b68a26fa8a5da8467b099c3ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:25 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_ai_reset_fifo()
    
    Introduce a helper function to reset the analog input FIFO. For
    aesthetics, rename the register used to reset the FIFO.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dfac7975a53e..266eb3f3a4ed 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -143,8 +143,8 @@
 #define PCI9118_AI_CFG_PM		(1 << 2)  /* 1=post trigger */
 #define PCI9118_AI_CFG_AM		(1 << 1)  /* 1=about trigger */
 #define PCI9118_AI_CFG_START		(1 << 0)  /* 1=trigger start */
+#define PCI9118_FIFO_RESET_REG		0x34
 
-#define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
@@ -318,6 +318,12 @@ static void pci9118_timer_set_mode(struct comedi_device *dev,
 	outl(val, dev->iobase + PCI9118_TIMER_CTRL_REG);
 }
 
+static void pci9118_ai_reset_fifo(struct comedi_device *dev)
+{
+	/* writing any value resets the A/D FIFO */
+	outl(0, dev->iobase + PCI9118_FIFO_RESET_REG);
+}
+
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -497,14 +503,14 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
 		return -EINVAL;
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	pci9118_ai_reset_fifo(dev);
 
 	for (n = 0; n < insn->n; n++) {
 		pci9118_ai_start_conv(dev);
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
 		if (ret) {
-			outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+			pci9118_ai_reset_fifo(dev);
 			return ret;
 		}
 
@@ -515,7 +521,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 			data[n] = (val >> 4) & 0xfff;
 	}
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	pci9118_ai_reset_fifo(dev);
 	return n;
 
 }
@@ -768,7 +774,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	/* reset scan queue */
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	pci9118_ai_reset_fifo(dev);
 
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
@@ -1643,7 +1649,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	udelay(1);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	pci9118_ai_reset_fifo(dev);
 
 	/* clear A/D and INT status registers */
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
@@ -1703,7 +1709,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(0, dev->iobase + PCI9118_DIO_REG);	/* reset digi outs to L */
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	pci9118_ai_reset_fifo(dev);
 	outl(0, dev->iobase + PCI9118_INTSRC);	/* remove INT requests */
 	/* clear A/D and INT status registers */
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);

commit ade7e01362848f864ca1e9632cb88a522f32657f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:24 2014 -0700

    staging: comedi: adl_pci9118: tidy up the ai config register bit defines
    
    Rename the CamelCase defines used for the analog input config register
    bits and convert them to bit shifts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 308a7937c1e6..dfac7975a53e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -135,38 +135,19 @@
 #define PCI9118_AI_BURST_NUM_REG	0x28
 #define PCI9118_AI_AUTOSCAN_MODE_REG	0x2c
 #define PCI9118_AI_CFG_REG		0x30
+#define PCI9118_AI_CFG_PDTRG		(1 << 7)  /* 1=positive trigger */
+#define PCI9118_AI_CFG_PETRG		(1 << 6)  /* 1=positive ext. trigger */
+#define PCI9118_AI_CFG_BSSH		(1 << 5)  /* 1=with sample & hold */
+#define PCI9118_AI_CFG_BM		(1 << 4)  /* 1=burst mode */
+#define PCI9118_AI_CFG_BS		(1 << 3)  /* 1=burst mode start */
+#define PCI9118_AI_CFG_PM		(1 << 2)  /* 1=post trigger */
+#define PCI9118_AI_CFG_AM		(1 << 1)  /* 1=about trigger */
+#define PCI9118_AI_CFG_START		(1 << 0)  /* 1=trigger start */
 
 #define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-/* bits from A/D function register (PCI9118_AI_CFG_REG) */
-#define AdFunction_PDTrg	0x80	/*
-					 * 1=positive,
-					 * 0=negative digital trigger
-					 * (only positive is correct)
-					 */
-#define AdFunction_PETrg	0x40	/*
-					 * 1=positive,
-					 * 0=negative external trigger
-					 * (only positive is correct)
-					 */
-#define AdFunction_BSSH		0x20	/* 1=with sample&hold, 0=without */
-#define AdFunction_BM		0x10	/* 1=burst mode, 0=normal mode */
-#define AdFunction_BS		0x08	/*
-					 * 1=burst mode start,
-					 * 0=burst mode stop
-					 */
-#define AdFunction_PM		0x04	/*
-					 * 1=post trigger mode,
-					 * 0=not post trigger
-					 */
-#define AdFunction_AM		0x02	/*
-					 * 1=about trigger mode,
-					 * 0=not about trigger
-					 */
-#define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
-
 /* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
 /* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
@@ -503,7 +484,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	int n;
 
 	devpriv->AdControlReg = PCI9118_AI_CTRL_INT;
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
 						 * positive triggers, no S&H,
@@ -607,13 +588,13 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	devpriv->AdFunctionReg =
-	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |
+				 PCI9118_AI_CFG_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_timer_write(dev, 0,
 			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
-	devpriv->AdFunctionReg |= AdFunction_Start;
+	devpriv->AdFunctionReg |= PCI9118_AI_CFG_START;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 }
 
@@ -769,7 +750,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 					/*
 					 * positive triggers, no S&H, no burst,
@@ -1432,28 +1413,31 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	case 2:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg =
-		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
-		    AdFunction_BS;
+		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
+					 PCI9118_AI_CFG_PETRG |
+					 PCI9118_AI_CFG_BM |
+					 PCI9118_AI_CFG_BS;
 		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
-			devpriv->AdFunctionReg |= AdFunction_BSSH;
+			devpriv->AdFunctionReg |= PCI9118_AI_CFG_BSSH;
 		outl(devpriv->ai_n_realscanlen,
 		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 		break;
 	case 3:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
+					 PCI9118_AI_CFG_PETRG;
 		break;
 	case 4:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
 					 PCI9118_AI_CTRL_DMA;
-		devpriv->AdFunctionReg =
-		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+		devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG |
+					 PCI9118_AI_CFG_PETRG |
+					 PCI9118_AI_CFG_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
-		devpriv->AdFunctionReg |= AdFunction_Start;
+		devpriv->AdFunctionReg |= PCI9118_AI_CFG_START;
 		break;
 	default:
 		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
@@ -1651,7 +1635,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 * disable DMA
 					 */
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 					/*
 					 * positive triggers, no S&H, no burst,
 					 * burst stop, no post trigger,
@@ -1700,7 +1684,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	/* reset scan queue */
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	devpriv->AdFunctionReg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
 						 * positive triggers, no S&H,

commit 7b460e9e2466b3baa10b6a669558528a1832e16b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:23 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_ADFUNC define
    
    For aesthetics, rename this define used for the analog input function
    config register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 68cecb5b49e3..308a7937c1e6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -134,13 +134,13 @@
 #define PCI9118_AI_CHANLIST_REG		0x24
 #define PCI9118_AI_BURST_NUM_REG	0x28
 #define PCI9118_AI_AUTOSCAN_MODE_REG	0x2c
+#define PCI9118_AI_CFG_REG		0x30
 
-#define PCI9118_ADFUNC	0x30	/* W:   A/D function register */
 #define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-/* bits from A/D function register (PCI9118_ADFUNC) */
+/* bits from A/D function register (PCI9118_AI_CFG_REG) */
 #define AdFunction_PDTrg	0x80	/*
 					 * 1=positive,
 					 * 0=negative digital trigger
@@ -504,7 +504,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 	devpriv->AdControlReg = PCI9118_AI_CTRL_INT;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
 						 * positive triggers, no S&H,
 						 * no burst, burst stop,
@@ -609,12 +609,12 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 
 	devpriv->AdFunctionReg =
 	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_timer_write(dev, 0,
 			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
 	devpriv->AdFunctionReg |= AdFunction_Start;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 }
 
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
@@ -770,7 +770,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	pci9118_exttrg_del(dev, EXTTRG_AI);
 	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 					/*
 					 * positive triggers, no S&H, no burst,
 					 * burst stop, no post trigger,
@@ -1053,7 +1053,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	s->async->inttrig = NULL;
 
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
@@ -1405,7 +1405,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
@@ -1450,7 +1450,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 					 PCI9118_AI_CTRL_DMA;
 		devpriv->AdFunctionReg =
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
 		devpriv->AdFunctionReg |= AdFunction_Start;
@@ -1469,7 +1469,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
-		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
@@ -1657,7 +1657,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 * burst stop, no post trigger,
 					 * no about trigger, trigger stop
 					 */
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 	udelay(1);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
@@ -1701,7 +1701,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_AI_CFG_REG);
 						/*
 						 * positive triggers, no S&H,
 						 * no burst, burst stop,

commit 89a7dc157359cc39760551c95a51cb405834a968
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:22 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_SCANMOD define
    
    For aesthetics, rename this define used for the analog input auto scan
    mode register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index d832cb38e98a..68cecb5b49e3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -133,8 +133,8 @@
 #define PCI9118_SOFTTRG_REG		0x20
 #define PCI9118_AI_CHANLIST_REG		0x24
 #define PCI9118_AI_BURST_NUM_REG	0x28
+#define PCI9118_AI_AUTOSCAN_MODE_REG	0x2c
 
-#define PCI9118_SCANMOD	0x2c	/* W:   A/D auto scan mode */
 #define PCI9118_ADFUNC	0x30	/* W:   A/D function register */
 #define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
@@ -417,11 +417,10 @@ static int setup_channel_list(struct comedi_device *dev,
 
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 								/* setup mode */
-
-	outl(2, dev->iobase + PCI9118_SCANMOD);
-					/* gods know why this sequence! */
-	outl(0, dev->iobase + PCI9118_SCANMOD);
-	outl(1, dev->iobase + PCI9118_SCANMOD);
+	/* gods know why this sequence! */
+	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
+	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
+	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 
 #ifdef PCI9118_PARANOIDCHECK
 	devpriv->chanlistlen = n_chan;
@@ -468,7 +467,8 @@ static int setup_channel_list(struct comedi_device *dev,
 	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
 						/* for 32bit operations */
 #endif
-	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
+	/* close scan queue */
+	outl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	/* udelay(100); important delay, or first sample will be crippled */
 
 	return 1;		/* we can serve this with scan logic */
@@ -784,8 +784,9 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 					 * disable INT and DMA
 					 */
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
-	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
+	/* reset scan queue */
+	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
+	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
 	devpriv->ai_do = 0;
@@ -1696,8 +1697,9 @@ static int pci9118_reset(struct comedi_device *dev)
 						 * disable INT and DMA
 						 */
 	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
-	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
+	/* reset scan queue */
+	outl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
+	outl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 						/*

commit 16d44e86d59db2d5706479184479426a467c9cc6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:21 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_BURST define
    
    For aesthetics, rename this define used for the analog input burst
    number register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 19a23537ad5d..d832cb38e98a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -132,8 +132,8 @@
 #define PCI9118_DIO_REG			0x1c
 #define PCI9118_SOFTTRG_REG		0x20
 #define PCI9118_AI_CHANLIST_REG		0x24
+#define PCI9118_AI_BURST_NUM_REG	0x28
 
-#define PCI9118_BURST	0x28	/* W:   A/D burst number register */
 #define PCI9118_SCANMOD	0x2c	/* W:   A/D auto scan mode */
 #define PCI9118_ADFUNC	0x30	/* W:   A/D function register */
 #define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
@@ -783,7 +783,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 					 * internal trigger, soft trigger,
 					 * disable INT and DMA
 					 */
-	outl(0, dev->iobase + PCI9118_BURST);
+	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
 	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
@@ -1436,7 +1436,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		    AdFunction_BS;
 		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
 			devpriv->AdFunctionReg |= AdFunction_BSSH;
-		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
+		outl(devpriv->ai_n_realscanlen,
+		     dev->iobase + PCI9118_AI_BURST_NUM_REG);
 		break;
 	case 3:
 		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM |
@@ -1694,7 +1695,7 @@ static int pci9118_reset(struct comedi_device *dev)
 						 * soft trigger,
 						 * disable INT and DMA
 						 */
-	outl(0, dev->iobase + PCI9118_BURST);
+	outl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
 	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;

commit 7e38f36b3bf064b2c85cec670d8822d570d1593c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:20 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_GAIN define
    
    For aesthetics, rename this define used for the analog input chanlist
    programming register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5eca67f13cc7..19a23537ad5d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -131,8 +131,8 @@
 #define PCI9118_AI_CTRL_DMA		(1 << 0)  /* 1=enable DMA */
 #define PCI9118_DIO_REG			0x1c
 #define PCI9118_SOFTTRG_REG		0x20
+#define PCI9118_AI_CHANLIST_REG		0x24
 
-#define PCI9118_GAIN	0x24	/* W:   A/D gain/channel register */
 #define PCI9118_BURST	0x28	/* W:   A/D burst number register */
 #define PCI9118_SCANMOD	0x2c	/* W:   A/D auto scan mode */
 #define PCI9118_ADFUNC	0x30	/* W:   A/D function register */
@@ -438,7 +438,8 @@ static int setup_channel_list(struct comedi_device *dev,
 			gain = CR_RANGE(chanlist[0]);
 						/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+			outl(scanquad | ssh,
+			     dev->iobase + PCI9118_AI_CHANLIST_REG);
 			ssh = devpriv->softsshhold;
 		}
 	}
@@ -450,7 +451,7 @@ static int setup_channel_list(struct comedi_device *dev,
 #endif
 		gain = CR_RANGE(chanlist[i]);		/* get gain number */
 		scanquad |= ((gain & 0x03) << 8);
-		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+		outl(scanquad | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);
 	}
 
 	if (backadd) {		/* insert channels for fit onto 32bit DMA */
@@ -459,7 +460,8 @@ static int setup_channel_list(struct comedi_device *dev,
 							/* get channel number */
 			gain = CR_RANGE(chanlist[0]);	/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+			outl(scanquad | ssh,
+			     dev->iobase + PCI9118_AI_CHANLIST_REG);
 		}
 	}
 #ifdef PCI9118_PARANOIDCHECK

commit 1750bed3f795ad33d9b37c3669f97fe036fa7570
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:19 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_ai_start_conv()
    
    Writing any value to the "software trigger" register generates a trigger
    pulse to start an A/D conversion. Introduce a helper function to clarify
    this. For aesthetics, rename the define used for the register.
    
    According to the datasheet the extra delay is not needed after starting
    the conversion. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6fb46cb03594..5eca67f13cc7 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -130,8 +130,8 @@
 #define PCI9118_AI_CTRL_INT		(1 << 1)  /* 1=enable interrupt */
 #define PCI9118_AI_CTRL_DMA		(1 << 0)  /* 1=enable DMA */
 #define PCI9118_DIO_REG			0x1c
+#define PCI9118_SOFTTRG_REG		0x20
 
-#define PCI9118_SOFTTRG	0x20	/* W:   soft trigger for A/D */
 #define PCI9118_GAIN	0x24	/* W:   A/D gain/channel register */
 #define PCI9118_BURST	0x28	/* W:   A/D burst number register */
 #define PCI9118_SCANMOD	0x2c	/* W:   A/D auto scan mode */
@@ -485,6 +485,12 @@ static int pci9118_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
+static void pci9118_ai_start_conv(struct comedi_device *dev)
+{
+	/* writing any value triggers an A/D conversion */
+	outl(0, dev->iobase + PCI9118_SOFTTRG_REG);
+}
+
 static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -511,8 +517,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
 	for (n = 0; n < insn->n; n++) {
-		outl(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
-		udelay(2);
+		pci9118_ai_start_conv(dev);
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
 		if (ret) {

commit c7f499bd03aa735d652e086762e48117d2b197b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:18 2014 -0700

    staging: comedi: adl_pci9118: clarify the digital I/O register
    
    The same register is used for both the digital inputs and outputs.
    Reading the register returns the state of the 4 digtial input channels
    and the 4 digital output channels. Writing to the register updates the
    digital outputs.
    
    Add some comments to clarify this and use a single define for the register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4e083159e7cd..6fb46cb03594 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -129,9 +129,8 @@
 #define PCI9118_AI_CTRL_TMRTR		(1 << 2)  /* 1=8254 is trigger source */
 #define PCI9118_AI_CTRL_INT		(1 << 1)  /* 1=enable interrupt */
 #define PCI9118_AI_CTRL_DMA		(1 << 0)  /* 1=enable DMA */
+#define PCI9118_DIO_REG			0x1c
 
-#define PCI9118_DI	0x1c	/* R:   digi input register */
-#define PCI9118_DO	0x1c	/* W:   digi output register */
 #define PCI9118_SOFTTRG	0x20	/* W:   soft trigger for A/D */
 #define PCI9118_GAIN	0x24	/* W:   A/D gain/channel register */
 #define PCI9118_BURST	0x28	/* W:   A/D burst number register */
@@ -565,9 +564,15 @@ static int pci9118_insn_read_ao(struct comedi_device *dev,
 
 static int pci9118_insn_bits_di(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
+	/*
+	 * The digital inputs and outputs share the read register.
+	 * bits [7:4] are the digital outputs
+	 * bits [3:0] are the digital inputs
+	 */
+	data[1] = inl(dev->iobase + PCI9118_DIO_REG) & 0xf;
 
 	return insn->n;
 }
@@ -577,8 +582,14 @@ static int pci9118_insn_bits_do(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
+	/*
+	 * The digital outputs are set with the same register that
+	 * the digital inputs and outputs are read from. But the
+	 * outputs are set with bits [3:0] so we can simply write
+	 * the s->state to set them.
+	 */
 	if (comedi_dio_update_state(s, data))
-		outl(s->state & 0x0f, dev->iobase + PCI9118_DO);
+		outl(s->state, dev->iobase + PCI9118_DIO_REG);
 
 	data[1] = s->state;
 
@@ -1695,7 +1706,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(devpriv->ao_data[0], dev->iobase + PCI9118_AO_REG(0));
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_AO_REG(1));
 
-	outl(0, dev->iobase + PCI9118_DO);	/* reset digi outs to L */
+	outl(0, dev->iobase + PCI9118_DIO_REG);	/* reset digi outs to L */
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */

commit 862be05ecf79157a3f9ae09a98b97e2066d2cc90
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:17 2014 -0700

    staging: comedi: adl_pci9118: tidy up the ai control register bit defines
    
    Rename the CamelCase defines used for the analog input control register
    bits and convert them to bit shifts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ad7aee023ce1..4e083159e7cd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -121,6 +121,14 @@
 #define PCI9118_AI_STATUS_ADOR		(1 << 1)  /* 1=A/D overrun (fatal) */
 #define PCI9118_AI_STATUS_ADRDY		(1 << 0)  /* 1=A/D ready */
 #define PCI9118_AI_CTRL_REG		0x18
+#define PCI9118_AI_CTRL_UNIP		(1 << 7)  /* 1=unipolar */
+#define PCI9118_AI_CTRL_DIFF		(1 << 6)  /* 1=differential inputs */
+#define PCI9118_AI_CTRL_SOFTG		(1 << 5)  /* 1=8254 software gate */
+#define PCI9118_AI_CTRL_EXTG		(1 << 4)  /* 1=8254 TGIN(pin 46) gate */
+#define PCI9118_AI_CTRL_EXTM		(1 << 3)  /* 1=ext. trigger (pin 44) */
+#define PCI9118_AI_CTRL_TMRTR		(1 << 2)  /* 1=8254 is trigger source */
+#define PCI9118_AI_CTRL_INT		(1 << 1)  /* 1=enable interrupt */
+#define PCI9118_AI_CTRL_DMA		(1 << 0)  /* 1=enable DMA */
 
 #define PCI9118_DI	0x1c	/* R:   digi input register */
 #define PCI9118_DO	0x1c	/* W:   digi output register */
@@ -133,26 +141,6 @@
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-/* bits from A/D control register (PCI9118_AI_CTRL_REG) */
-#define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
-#define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
-#define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
-#define	AdControl_ExtG	0x10	/*
-				 * 1=8254 countrol controlled by TGIN(pin 46),
-				 * 0=controlled by SoftG
-				 */
-#define AdControl_ExtM	0x08	/*
-				 * 1=external hardware trigger (pin 44),
-				 * 0=internal trigger
-				 */
-#define AdControl_TmrTr	0x04	/*
-				 * 1=8254 is iternal trigger source,
-				 * 0=software trigger is source
-				 * (register PCI9118_SOFTTRG)
-				 */
-#define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
-#define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
-
 /* bits from A/D function register (PCI9118_ADFUNC) */
 #define AdFunction_PDTrg	0x80	/*
 					 * 1=positive,
@@ -418,21 +406,15 @@ static int setup_channel_list(struct comedi_device *dev,
 
 	/* All is ok, so we can setup channel/range list */
 
-	if (!bipolar) {
-		devpriv->AdControlReg |= AdControl_UniP;
-							/* set unibipolar */
-	} else {
-		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);
-							/* enable bipolar */
-	}
+	if (!bipolar)
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_UNIP;
+	else
+		devpriv->AdControlReg &= ~PCI9118_AI_CTRL_UNIP;
 
-	if (differencial) {
-		devpriv->AdControlReg |= AdControl_Diff;
-							/* enable diff inputs */
-	} else {
-		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);
-						/* set single ended inputs */
-	}
+	if (differencial)
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_DIFF;
+	else
+		devpriv->AdControlReg &= ~PCI9118_AI_CTRL_DIFF;
 
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 								/* setup mode */
@@ -513,7 +495,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	int ret;
 	int n;
 
-	devpriv->AdControlReg = AdControl_Int & 0xff;
+	devpriv->AdControlReg = PCI9118_AI_CTRL_INT;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 						/*
@@ -1055,7 +1037,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	if (devpriv->ai_do != 3) {
 		pci9118_start_pacer(dev, devpriv->ai_do);
-		devpriv->AdControlReg |= AdControl_SoftG;
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
 	}
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 
@@ -1373,13 +1355,13 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 
 	switch (devpriv->ai_do) {
 	case 1:
-		devpriv->AdControlReg |= AdControl_TmrTr;
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR;
 		break;
 	case 2:
 		dev_err(dev->class_dev, "%s mode 2 bug!\n", __func__);
 		return -EIO;
 	case 3:
-		devpriv->AdControlReg |= AdControl_ExtM;
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM;
 		break;
 	case 4:
 		dev_err(dev->class_dev, "%s mode 4 bug!\n", __func__);
@@ -1396,7 +1378,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->IntControlReg |= Int_Timer;
 
-	devpriv->AdControlReg |= AdControl_Int;
+	devpriv->AdControlReg |= PCI9118_AI_CTRL_INT;
 
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
 			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -1407,7 +1389,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->AdControlReg |= AdControl_SoftG;
+			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
 		}
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
@@ -1425,12 +1407,12 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 	switch (devpriv->ai_do) {
 	case 1:
-		devpriv->AdControlReg |=
-		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
+					 PCI9118_AI_CTRL_DMA;
 		break;
 	case 2:
-		devpriv->AdControlReg |=
-		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
+					 PCI9118_AI_CTRL_DMA;
 		devpriv->AdFunctionReg =
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
 		    AdFunction_BS;
@@ -1439,13 +1421,13 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
 		break;
 	case 3:
-		devpriv->AdControlReg |=
-		    ((AdControl_ExtM | AdControl_Dma) & 0xff);
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_EXTM |
+					 PCI9118_AI_CTRL_DMA;
 		devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 		break;
 	case 4:
-		devpriv->AdControlReg |=
-		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		devpriv->AdControlReg |= PCI9118_AI_CTRL_TMRTR |
+					 PCI9118_AI_CTRL_DMA;
 		devpriv->AdFunctionReg =
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
@@ -1471,7 +1453,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		if (devpriv->ai_do != 3) {
 			pci9118_start_pacer(dev, devpriv->ai_do);
-			devpriv->AdControlReg |= AdControl_SoftG;
+			devpriv->AdControlReg |= PCI9118_AI_CTRL_SOFTG;
 		}
 		outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 	}

commit a2a1fc7a4f5a0f6d99c6eb72858c715a13f40729
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:16 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_ADCNTRL define
    
    For aesthetics, rename this define used for the analog input control
    register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 350df462fca6..ad7aee023ce1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -120,8 +120,8 @@
 #define PCI9118_AI_STATUS_ADOS		(1 << 2)  /* 1=A/D over speed (warn) */
 #define PCI9118_AI_STATUS_ADOR		(1 << 1)  /* 1=A/D overrun (fatal) */
 #define PCI9118_AI_STATUS_ADRDY		(1 << 0)  /* 1=A/D ready */
+#define PCI9118_AI_CTRL_REG		0x18
 
-#define PCI9118_ADCNTRL	0x18	/* W:   A/D control register */
 #define PCI9118_DI	0x1c	/* R:   digi input register */
 #define PCI9118_DO	0x1c	/* W:   digi output register */
 #define PCI9118_SOFTTRG	0x20	/* W:   soft trigger for A/D */
@@ -133,7 +133,7 @@
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-/* bits from A/D control register (PCI9118_ADCNTRL) */
+/* bits from A/D control register (PCI9118_AI_CTRL_REG) */
 #define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
 #define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
 #define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
@@ -434,7 +434,7 @@ static int setup_channel_list(struct comedi_device *dev,
 						/* set single ended inputs */
 	}
 
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 								/* setup mode */
 
 	outl(2, dev->iobase + PCI9118_SCANMOD);
@@ -777,7 +777,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 					 * no about trigger, trigger stop
 					 */
 	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 					/*
 					 * bipolar, S.E., use 8254, stop 8354,
 					 * internal trigger, soft trigger,
@@ -1018,7 +1018,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 				/* start pacer */
 				pci9118_start_pacer(dev, devpriv->ai_do);
 				outl(devpriv->AdControlReg,
-				     dev->iobase + PCI9118_ADCNTRL);
+				     dev->iobase + PCI9118_AI_CTRL_REG);
 			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
 				/* deactivate EXT trigger */
 				devpriv->ai12_startstop &= ~STOP_AI_EXT;
@@ -1057,7 +1057,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 		pci9118_start_pacer(dev, devpriv->ai_do);
 		devpriv->AdControlReg |= AdControl_SoftG;
 	}
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 
 	return 1;
 }
@@ -1473,7 +1473,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
-		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+		outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 	}
 
 	return 0;
@@ -1648,7 +1648,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 * internal trigger, soft trigger,
 					 * disable DMA
 					 */
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 					/*
 					 * positive triggers, no S&H, no burst,
@@ -1687,7 +1687,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_start_pacer(dev, 0);		/* stop 8254 counters */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 						/*
 						 * bipolar, S.E., use 8254,
 						 * stop 8354, internal trigger,
@@ -1722,7 +1722,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	inl(dev->iobase + PCI9118_AI_STATUS_REG);
 	inl(dev->iobase + PCI9118_INTSRC);
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_AI_CTRL_REG);
 						/*
 						 * bipolar, S.E., use 8254,
 						 * stop 8354, internal trigger,

commit aa2f430caacc2711032aa051a996735b21a0c0bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:15 2014 -0700

    staging: comedi: adl_pci9118: tidy up the ai status register bit defines
    
    Rename the CamelCase defines used for the analog input status register
    bits and convert them to bit shifts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 484518c99906..350df462fca6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -111,6 +111,15 @@
 #define PCI9118_AI_FIFO_REG		0x10
 #define PCI9118_AO_REG(x)		(0x10 + ((x) * 4))
 #define PCI9118_AI_STATUS_REG		0x18
+#define PCI9118_AI_STATUS_NFULL		(1 << 8)  /* 0=FIFO full (fatal) */
+#define PCI9118_AI_STATUS_NHFULL	(1 << 7)  /* 0=FIFO half full */
+#define PCI9118_AI_STATUS_NEPTY		(1 << 6)  /* 0=FIFO empty */
+#define PCI9118_AI_STATUS_ACMP		(1 << 5)  /* 1=about trigger complete */
+#define PCI9118_AI_STATUS_DTH		(1 << 4)  /* 1=ext. digital trigger */
+#define PCI9118_AI_STATUS_BOVER		(1 << 3)  /* 1=burst overrun (fatal) */
+#define PCI9118_AI_STATUS_ADOS		(1 << 2)  /* 1=A/D over speed (warn) */
+#define PCI9118_AI_STATUS_ADOR		(1 << 1)  /* 1=A/D overrun (fatal) */
+#define PCI9118_AI_STATUS_ADRDY		(1 << 0)  /* 1=A/D ready */
 
 #define PCI9118_ADCNTRL	0x18	/* W:   A/D control register */
 #define PCI9118_DI	0x1c	/* R:   digi input register */
@@ -171,17 +180,6 @@
 					 */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
-/* bits from A/D status register (PCI9118_AI_STATUS_REG) */
-#define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
-#define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
-#define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
-#define AdStatus_Acmp	0x020	/*  */
-#define AdStatus_DTH	0x010	/* 1=external digital trigger */
-#define AdStatus_Bover	0x008	/* 1=burst mode overrun (fatal) */
-#define AdStatus_ADOS	0x004	/* 1=A/D over speed (warning) */
-#define AdStatus_ADOR	0x002	/* 1=A/D overrun (fatal) */
-#define AdStatus_ADrdy	0x001	/* 1=A/D already ready, 0=not ready */
-
 /* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
 /* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
@@ -501,7 +499,7 @@ static int pci9118_ai_eoc(struct comedi_device *dev,
 	unsigned int status;
 
 	status = inl(dev->iobase + PCI9118_AI_STATUS_REG);
-	if (status & AdStatus_ADrdy)
+	if (status & PCI9118_AI_STATUS_ADRDY)
 		return 0;
 	return -EBUSY;
 }
@@ -1009,7 +1007,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 
 	if (devpriv->ai12_startstop) {
-		if ((adstat & AdStatus_DTH) && (intsrc & Int_DTrg)) {
+		if ((adstat & PCI9118_AI_STATUS_DTH) && (intsrc & Int_DTrg)) {
 			/* start/stop of measure */
 			if (devpriv->ai12_startstop & START_AI_EXT) {
 				/* deactivate EXT trigger */

commit 602c1729caed253b50058df3851f86f645a0d2e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:14 2014 -0700

    staging: comedi: adl_pci9118: rename PCI9118_ADSTAT define
    
    For aesthetics, rename this define used for the analog input status
    register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5c9bb73e06f1..484518c99906 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -110,8 +110,8 @@
 #define PCI9118_TIMER_CTRL_REG		0x0c
 #define PCI9118_AI_FIFO_REG		0x10
 #define PCI9118_AO_REG(x)		(0x10 + ((x) * 4))
+#define PCI9118_AI_STATUS_REG		0x18
 
-#define PCI9118_ADSTAT	0x18	/* R:   A/D status register */
 #define PCI9118_ADCNTRL	0x18	/* W:   A/D control register */
 #define PCI9118_DI	0x1c	/* R:   digi input register */
 #define PCI9118_DO	0x1c	/* W:   digi output register */
@@ -171,7 +171,7 @@
 					 */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
-/* bits from A/D status register (PCI9118_ADSTAT) */
+/* bits from A/D status register (PCI9118_AI_STATUS_REG) */
 #define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
 #define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
 #define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
@@ -500,7 +500,7 @@ static int pci9118_ai_eoc(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inl(dev->iobase + PCI9118_ADSTAT);
+	status = inl(dev->iobase + PCI9118_AI_STATUS_REG);
 	if (status & AdStatus_ADrdy)
 		return 0;
 	return -EBUSY;
@@ -1003,7 +1003,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 
 	outl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
-	adstat = inl(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
+	adstat = inl(dev->iobase + PCI9118_AI_STATUS_REG) & 0x1ff;
 
 	if (!devpriv->ai_do)
 		return IRQ_HANDLED;
@@ -1660,10 +1660,9 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	udelay(1);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
-	inl(dev->iobase + PCI9118_ADSTAT);	/*
-						 * flush A/D and INT
-						 * status register
-						 */
+
+	/* clear A/D and INT status registers */
+	inl(dev->iobase + PCI9118_AI_STATUS_REG);
 	inl(dev->iobase + PCI9118_INTSRC);
 
 	devpriv->ai_act_scan = 0;
@@ -1721,8 +1720,9 @@ static int pci9118_reset(struct comedi_device *dev)
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 	outl(0, dev->iobase + PCI9118_INTSRC);	/* remove INT requests */
-	inl(dev->iobase + PCI9118_ADSTAT);	/* flush A/D status register */
-	inl(dev->iobase + PCI9118_INTSRC);	/* flush INT requests */
+	/* clear A/D and INT status registers */
+	inl(dev->iobase + PCI9118_AI_STATUS_REG);
+	inl(dev->iobase + PCI9118_INTSRC);
 	devpriv->AdControlReg = 0;
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
 						/*

commit c6908517f23baedaca31dbe738230bda9ffa377a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:13 2014 -0700

    staging: comedi: adl_pci9118: tidy up analog output register defines
    
    Replace the current defines with a macro that calculates the correct
    register offset based on the channel.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7c2385b8ad34..5c9bb73e06f1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -109,9 +109,8 @@
 #define PCI9118_TIMER_REG(x)		(0x00 + ((x) * 4))
 #define PCI9118_TIMER_CTRL_REG		0x0c
 #define PCI9118_AI_FIFO_REG		0x10
+#define PCI9118_AO_REG(x)		(0x10 + ((x) * 4))
 
-#define PCI9118_DA1	0x10	/* W:   D/A registers */
-#define PCI9118_DA2	0x14
 #define PCI9118_ADSTAT	0x18	/* R:   A/D status register */
 #define PCI9118_ADCNTRL	0x18	/* W:   A/D control register */
 #define PCI9118_DI	0x1c	/* R:   digi input register */
@@ -559,18 +558,12 @@ static int pci9118_insn_write_ao(struct comedi_device *dev,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	struct pci9118_private *devpriv = dev->private;
-	int n, chanreg, ch;
-
-	ch = CR_CHAN(insn->chanspec);
-	if (ch)
-		chanreg = PCI9118_DA2;
-	else
-		chanreg = PCI9118_DA1;
-
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int n;
 
 	for (n = 0; n < insn->n; n++) {
-		outl(data[n], dev->iobase + chanreg);
-		devpriv->ao_data[ch] = data[n];
+		outl(data[n], dev->iobase + PCI9118_AO_REG(chan));
+		devpriv->ao_data[chan] = data[n];
 	}
 
 	return n;
@@ -1717,11 +1710,12 @@ static int pci9118_reset(struct comedi_device *dev)
 						 * trigger stop
 						 */
 
+	/* reset analog outputs to 0V */
 	devpriv->ao_data[0] = 2047;
 	devpriv->ao_data[1] = 2047;
-	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);
-						/* reset A/D outs to 0V */
-	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
+	outl(devpriv->ao_data[0], dev->iobase + PCI9118_AO_REG(0));
+	outl(devpriv->ao_data[1], dev->iobase + PCI9118_AO_REG(1));
+
 	outl(0, dev->iobase + PCI9118_DO);	/* reset digi outs to L */
 	udelay(10);
 	inl(dev->iobase + PCI9118_AI_FIFO_REG);

commit 7cc1110ddaaafe18506fd002632557f0e155a012
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:12 2014 -0700

    staging: comedi: adl_pci9118: tidy up analog input fifo register define
    
    For aesthetics, rename the define used for the analog input fifo register
    and tidy up its use in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c1e6cce105e7..7c2385b8ad34 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -108,8 +108,8 @@
  */
 #define PCI9118_TIMER_REG(x)		(0x00 + ((x) * 4))
 #define PCI9118_TIMER_CTRL_REG		0x0c
+#define PCI9118_AI_FIFO_REG		0x10
 
-#define PCI9118_AD_DATA	0x10	/* R:   A/D data */
 #define PCI9118_DA1	0x10	/* W:   D/A registers */
 #define PCI9118_DA2	0x14
 #define PCI9118_ADSTAT	0x18	/* R:   A/D status register */
@@ -512,6 +512,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	struct pci9118_private *devpriv = dev->private;
+	unsigned int val;
 	int ret;
 	int n;
 
@@ -541,14 +542,11 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 			return ret;
 		}
 
-		if (s->maxdata == 0xffff) {
-			data[n] =
-			    (inl(dev->iobase +
-				 PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
-		} else {
-			data[n] =
-			    (inl(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;
-		}
+		val = inl(dev->iobase + PCI9118_AI_FIFO_REG);
+		if (s->maxdata == 0xffff)
+			data[n] = (val & 0xffff) ^ 0x8000;
+		else
+			data[n] = (val >> 4) & 0xfff;
 	}
 
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
@@ -884,7 +882,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	sampl = inl(dev->iobase + PCI9118_AD_DATA);
+	sampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (s->maxdata != 0xffff) {
@@ -1726,7 +1724,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
 	outl(0, dev->iobase + PCI9118_DO);	/* reset digi outs to L */
 	udelay(10);
-	inl(dev->iobase + PCI9118_AD_DATA);
+	inl(dev->iobase + PCI9118_AI_FIFO_REG);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 	outl(0, dev->iobase + PCI9118_INTSRC);	/* remove INT requests */
 	inl(dev->iobase + PCI9118_ADSTAT);	/* flush A/D status register */

commit b8dbcc2d027d959300b172bf11764af92f9a8dcf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:11 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_timer_set_mode()
    
    This driver uses 32-bit instructions to write the 8254 timers so we
    can't use the helper functions provided by 8253.h.
    
    To clarify the code introduce a helper function to set the timer mode.
    
    Remove the unnecessary commented out timer mode programming.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index eb1bfcb95006..c1e6cce105e7 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -107,8 +107,8 @@
  * PCI BAR2 Register map (dev->iobase)
  */
 #define PCI9118_TIMER_REG(x)		(0x00 + ((x) * 4))
+#define PCI9118_TIMER_CTRL_REG		0x0c
 
-#define PCI9118_CNTCTRL	0x0c	/* W:   8254 counter control */
 #define PCI9118_AD_DATA	0x10	/* R:   A/D data */
 #define PCI9118_DA1	0x10	/* W:   D/A registers */
 #define PCI9118_DA2	0x14
@@ -342,6 +342,17 @@ static void pci9118_timer_write(struct comedi_device *dev,
 	outl((val >> 8) & 0xff, dev->iobase + PCI9118_TIMER_REG(timer));
 }
 
+static void pci9118_timer_set_mode(struct comedi_device *dev,
+				   unsigned int timer, unsigned int mode)
+{
+	unsigned int val;
+
+	val = timer << 6;	/* select timer */
+	val |= 0x30;		/* load low then high byte */
+	val |= mode;		/* set timer mode and BCD|binary */
+	outl(val, dev->iobase + PCI9118_TIMER_CTRL_REG);
+}
+
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -610,7 +621,7 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 	devpriv->AdFunctionReg =
 	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
-	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_timer_write(dev, 0,
 			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
 	devpriv->AdFunctionReg |= AdFunction_Start;
@@ -748,9 +759,8 @@ static void pci9118_start_pacer(struct comedi_device *dev, int mode)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
-	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-/* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
+	pci9118_timer_set_mode(dev, 1, I8254_MODE2);
+	pci9118_timer_set_mode(dev, 2, I8254_MODE2);
 	udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
@@ -1450,7 +1460,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		devpriv->AdFunctionReg =
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
-		outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+		pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
 		devpriv->AdFunctionReg |= AdFunction_Start;
 		break;
@@ -1686,8 +1696,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	inl(dev->iobase + PCI9118_INTCTRL);
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 						/* disable interrupts source */
-	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
-/* outl(0xb4, dev->iobase + PCI9118_CNTCTRL); */
+	pci9118_timer_set_mode(dev, 0, I8254_MODE0);
 	pci9118_start_pacer(dev, 0);		/* stop 8254 counters */
 	devpriv->AdControlReg = 0;
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);

commit 6dc359535c3dfc5289bf321e5a1e192733810311
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:10 2014 -0700

    staging: comedi: adl_pci9118: introduce pci9118_timer_write()
    
    This driver uses 32-bit instructions to write the 8254 timers so we
    can't use the helper functions provided by 8253.h.
    
    To clarify the code introduce a helper function to write to the timers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0a59e3dac86e..eb1bfcb95006 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -103,9 +103,11 @@
 				 * but reality looks like 255 :-(
 				 */
 
-#define PCI9118_CNT0	0x00	/* R/W: 8254 counter 0 */
-#define PCI9118_CNT1	0x04	/* R/W: 8254 counter 0 */
-#define PCI9118_CNT2	0x08	/* R/W: 8254 counter 0 */
+/*
+ * PCI BAR2 Register map (dev->iobase)
+ */
+#define PCI9118_TIMER_REG(x)		(0x00 + ((x) * 4))
+
 #define PCI9118_CNTCTRL	0x0c	/* W:   8254 counter control */
 #define PCI9118_AD_DATA	0x10	/* R:   A/D data */
 #define PCI9118_DA1	0x10	/* W:   D/A registers */
@@ -333,6 +335,13 @@ struct pci9118_private {
 	unsigned int ai_ns_min;
 };
 
+static void pci9118_timer_write(struct comedi_device *dev,
+				unsigned int timer, unsigned int val)
+{
+	outl(val & 0xff, dev->iobase + PCI9118_TIMER_REG(timer));
+	outl((val >> 8) & 0xff, dev->iobase + PCI9118_TIMER_REG(timer));
+}
+
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -602,10 +611,8 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
-	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1) & 0xff,
-	     dev->iobase + PCI9118_CNT0);
-	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 9) & 0xff,
-	     dev->iobase + PCI9118_CNT0);
+	pci9118_timer_write(dev, 0,
+			    devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1);
 	devpriv->AdFunctionReg |= AdFunction_Start;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 }
@@ -740,8 +747,6 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 static void pci9118_start_pacer(struct comedi_device *dev, int mode)
 {
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int divisor1 = devpriv->ai_divisor1;
-	unsigned int divisor2 = devpriv->ai_divisor2;
 
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
@@ -749,10 +754,8 @@ static void pci9118_start_pacer(struct comedi_device *dev, int mode)
 	udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
-		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
-		outl((divisor2 >> 8) & 0xff, dev->iobase + PCI9118_CNT2);
-		outl(divisor1 & 0xff, dev->iobase + PCI9118_CNT1);
-		outl((divisor1 >> 8) & 0xff, dev->iobase + PCI9118_CNT1);
+		pci9118_timer_write(dev, 2, devpriv->ai_divisor2);
+		pci9118_timer_write(dev, 1, devpriv->ai_divisor1);
 	}
 }
 
@@ -1448,10 +1451,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(0x30, dev->iobase + PCI9118_CNTCTRL);
-		outl((devpriv->dmabuf_hw[0] >> 1) & 0xff,
-		     dev->iobase + PCI9118_CNT0);
-		outl((devpriv->dmabuf_hw[0] >> 9) & 0xff,
-		     dev->iobase + PCI9118_CNT0);
+		pci9118_timer_write(dev, 0, devpriv->dmabuf_hw[0] >> 1);
 		devpriv->AdFunctionReg |= AdFunction_Start;
 		break;
 	default:

commit 7362afc32b7d7b4279a1cd12572dcff500ec132a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 12:14:09 2014 -0700

    staging: comedi: adl_pci9118: all registers are 32-bit
    
    According to the PCI-9118 User's Manual, all registers are 32-bit. Fix a
    couple of read/write operations that use 16-bit access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 225c0469cda9..0a59e3dac86e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -512,7 +512,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
 	for (n = 0; n < insn->n; n++) {
-		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
+		outl(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
 		udelay(2);
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
@@ -527,7 +527,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 				 PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
 		} else {
 			data[n] =
-			    (inw(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;
+			    (inl(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;
 		}
 	}
 
@@ -871,7 +871,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	sampl = inw(dev->iobase + PCI9118_AD_DATA);
+	sampl = inl(dev->iobase + PCI9118_AD_DATA);
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (s->maxdata != 0xffff) {
@@ -999,7 +999,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 
 	outl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
-	adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
+	adstat = inl(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
 
 	if (!devpriv->ai_do)
 		return IRQ_HANDLED;

commit 76c1b7bc45136d509c6fd3c0ff45b6e291421780
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:42 2014 -0700

    staging: comedi: adl_pci9118: tidy up analog input subdevice init
    
    For aesthetics, add some whitespace to the analog input subdevice init.
    Tidy up the subdevice n_chan initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2ff9bc79bb18..225c0469cda9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1853,26 +1853,23 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	if (ret)
 		return ret;
 
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
-	if (devpriv->usemux)
-		s->n_chan = devpriv->usemux;
-	else
-		s->n_chan = 16;
-
-	s->maxdata = board->ai_is_16bit ? 0xffff : 0x0fff;
-	s->range_table = board->is_hg ? &pci9118hg_ai_range
-				      : &pci9118_ai_range;
-	s->insn_read = pci9118_insn_read_ai;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
+	s->n_chan	= (devpriv->usemux) ? devpriv->usemux : 16;
+	s->maxdata	= board->ai_is_16bit ? 0xffff : 0x0fff;
+	s->range_table	= board->is_hg ? &pci9118hg_ai_range
+				       : &pci9118_ai_range;
+	s->insn_read	= pci9118_insn_read_ai;
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->subdev_flags |= SDF_CMD_READ;
-		s->len_chanlist = PCI9118_CHANLEN;
-		s->do_cmdtest = pci9118_ai_cmdtest;
-		s->do_cmd = pci9118_ai_cmd;
-		s->cancel = pci9118_ai_cancel;
-		s->munge = pci9118_ai_munge;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= PCI9118_CHANLEN;
+		s->do_cmdtest	= pci9118_ai_cmdtest;
+		s->do_cmd	= pci9118_ai_cmd;
+		s->cancel	= pci9118_ai_cancel;
+		s->munge	= pci9118_ai_munge;
 	}
 
 	if (s->maxdata == 0xffff) {

commit 949dcfce4f5412fb3cd677a7e3820da5b750c1f5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:41 2014 -0700

    staging: comedi: adl_pci9118: tidy up analog output subdevice init
    
    For aesthetics, add some whitespace to the analog output subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f9598b0702a2..2ff9bc79bb18 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1889,14 +1889,15 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		devpriv->ai_ns_min = 3000;
 	}
 
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
-	s->n_chan = 2;
-	s->maxdata = 0x0fff;
-	s->range_table = &range_bipolar10;
-	s->insn_write = pci9118_insn_write_ao;
-	s->insn_read = pci9118_insn_read_ao;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan	= 2;
+	s->maxdata	= 0x0fff;
+	s->range_table	= &range_bipolar10;
+	s->insn_write	= pci9118_insn_write_ao;
+	s->insn_read	= pci9118_insn_read_ao;
 
 	/* Digital Input subdevice */
 	s = &dev->subdevices[2];

commit 32034aaf03ecc5ed0e895505306e4a0a8b433811
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:40 2014 -0700

    staging: comedi: adl_pci9118: tidy up digital input subdevice init
    
    For aesthetics, add some whitespace to the digital input subdevice init.
    
    Remove the SDF_GROUND and SDF_COMMON subdev_flags. These flags only apply
    to analog subdevices.
    
    Remove the 'len_chanlist' init, this subdevice member is only used with
    subdevices that support async commands.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index d7af6f74d363..f9598b0702a2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1898,14 +1898,14 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->insn_write = pci9118_insn_write_ao;
 	s->insn_read = pci9118_insn_read_ao;
 
+	/* Digital Input subdevice */
 	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->len_chanlist = 4;
-	s->range_table = &range_digital;
-	s->insn_bits = pci9118_insn_bits_di;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pci9118_insn_bits_di;
 
 	/* Digital Output subdevice */
 	s = &dev->subdevices[3];

commit 1e9879f7a443d9bd06dd40544c1b91766008b880
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:39 2014 -0700

    staging: comedi: adl_pci9118: tidy up digital output subdevice init
    
    For aesthetics, add some whitespace to the digital output subdevice init.
    
    Remove the SDF_GROUND and SDF_COMMON subdev_flags. These flags only apply
    to analog subdevices.
    
    Remove the 'len_chanlist' init, this subdevice member is only used with
    subdevices that support async commands.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 8b086c22b2e9..d7af6f74d363 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1907,14 +1907,14 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->range_table = &range_digital;
 	s->insn_bits = pci9118_insn_bits_di;
 
+	/* Digital Output subdevice */
 	s = &dev->subdevices[3];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->len_chanlist = 4;
-	s->range_table = &range_digital;
-	s->insn_bits = pci9118_insn_bits_do;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= pci9118_insn_bits_do;
 
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */

commit f6009ae536ec642e451d29327bf04532c4c7e0aa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:38 2014 -0700

    staging: comedi: adl_pci9118: allocate private data in pci9118_common_attach()
    
    The (*auto_attach) and legacy (*attach) both allocate the private data but
    don't use it. For aesthetics, move the allocation into the common attach
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 81ba59feb68c..8b086c22b2e9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1767,12 +1767,16 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 				 int hw_err_mask)
 {
 	const struct pci9118_boardinfo *board = comedi_board(dev);
-	struct pci9118_private *devpriv = dev->private;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pci9118_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret, pages, i;
 	u16 u16w;
 
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
+	if (!devpriv)
+		return -ENOMEM;
+
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
@@ -1923,7 +1927,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
-	struct pci9118_private *devpriv;
 	struct pci_dev *pcidev;
 	int ext_mux, disable_irq, master, softsshdelay, hw_err_mask;
 
@@ -1933,10 +1936,6 @@ static int pci9118_attach(struct comedi_device *dev,
 	softsshdelay = it->options[4];
 	hw_err_mask = it->options[5];
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	pcidev = pci9118_find_pci(dev, it);
 	if (!pcidev)
 		return -EIO;
@@ -1951,7 +1950,6 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct pci9118_boardinfo *board = NULL;
-	struct pci9118_private *devpriv;
 
 	if (context < ARRAY_SIZE(pci9118_boards))
 		board = &pci9118_boards[context];
@@ -1960,10 +1958,6 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 	dev->board_ptr = board;
 	dev->board_name = board->name;
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	/*
 	 * Need to 'get' the PCI device to match the 'put' in pci9118_detach().
 	 * (The 'put' also matches the implicit 'get' by pci9118_find_pci().)

commit 25a8aaf03e1701c1821f3087f0f12a7da6aa17ed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:37 2014 -0700

    staging: comedi: adl_pci9118: rename boardinfo struct
    
    For aesthetics, rename the struct used for the boardinfo so it has
    namespace associated with the driver. Also, rename the local variable
    used for the boardinfo pointer to simply 'board'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c582301a2c9c..81ba59feb68c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -234,13 +234,13 @@ enum pci9118_boardid {
 	BOARD_PCI9118HR,
 };
 
-struct boardtype {
-	const char *name;		/* board name */
+struct pci9118_boardinfo {
+	const char *name;
 	unsigned int ai_is_16bit:1;
 	unsigned int is_hg:1;
 };
 
-static const struct boardtype boardtypes[] = {
+static const struct pci9118_boardinfo pci9118_boards[] = {
 	[BOARD_PCI9118DG] = {
 		.name		= "pci9118dg",
 	},
@@ -1766,7 +1766,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 				 int master, int ext_mux, int softsshdelay,
 				 int hw_err_mask)
 {
-	const struct boardtype *this_board = comedi_board(dev);
+	const struct pci9118_boardinfo *board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct comedi_subdevice *s;
@@ -1857,9 +1857,9 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	else
 		s->n_chan = 16;
 
-	s->maxdata = this_board->ai_is_16bit ? 0xffff : 0x0fff;
-	s->range_table = this_board->is_hg ? &pci9118hg_ai_range
-					   : &pci9118_ai_range;
+	s->maxdata = board->ai_is_16bit ? 0xffff : 0x0fff;
+	s->range_table = board->is_hg ? &pci9118hg_ai_range
+				      : &pci9118_ai_range;
 	s->insn_read = pci9118_insn_read_ai;
 	if (dev->irq) {
 		dev->read_subdev = s;
@@ -1950,11 +1950,11 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 			       unsigned long context)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct boardtype *board = NULL;
+	const struct pci9118_boardinfo *board = NULL;
 	struct pci9118_private *devpriv;
 
-	if (context < ARRAY_SIZE(boardtypes))
-		board = &boardtypes[context];
+	if (context < ARRAY_SIZE(pci9118_boards))
+		board = &pci9118_boards[context];
 	if (!board)
 		return -ENODEV;
 	dev->board_ptr = board;
@@ -2000,9 +2000,9 @@ static struct comedi_driver adl_pci9118_driver = {
 	.attach		= pci9118_attach,
 	.auto_attach	= pci9118_auto_attach,
 	.detach		= pci9118_detach,
-	.num_names	= ARRAY_SIZE(boardtypes),
-	.board_name	= &boardtypes[0].name,
-	.offset		= sizeof(struct boardtype),
+	.num_names	= ARRAY_SIZE(pci9118_boards),
+	.board_name	= &pci9118_boards[0].name,
+	.offset		= sizeof(struct pci9118_boardinfo),
 };
 
 static int adl_pci9118_pci_probe(struct pci_dev *dev,

commit f34afce444ca2e3a65264126bec2982358a25a1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:36 2014 -0700

    staging: comedi: adl_pci9118: remove unnecessary dev->board_name initialization
    
    The (*auto_attach) in this driver will set the dev->board_name and the comedi core
    will set it when using the legacy (*attach). Remove the unnecessary initialization
    in pci9118_common_attach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6471f2c6cda0..c582301a2c9c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1773,7 +1773,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	int ret, pages, i;
 	u16 u16w;
 
-	dev->board_name = this_board->name;
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;

commit 8bd1e1dfcacd184abdf60dccc4c62ee02aeafc9b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:35 2014 -0700

    staging: comedi: adl_pci9118: remove 'device_id' from boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dc0d0cb795bf..6471f2c6cda0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -236,7 +236,6 @@ enum pci9118_boardid {
 
 struct boardtype {
 	const char *name;		/* board name */
-	int device_id;			/* PCI device ID of card */
 	unsigned int ai_is_16bit:1;
 	unsigned int is_hg:1;
 };
@@ -244,16 +243,13 @@ struct boardtype {
 static const struct boardtype boardtypes[] = {
 	[BOARD_PCI9118DG] = {
 		.name		= "pci9118dg",
-		.device_id	= 0x80d9,
 	},
 	[BOARD_PCI9118HG] = {
 		.name		= "pci9118hg",
-		.device_id	= 0x80d9,
 		.is_hg		= 1,
 	},
 	[BOARD_PCI9118HR] = {
 		.name		= "pci9118hr",
-		.device_id	= 0x80d9,
 		.ai_is_16bit	= 1,
 	},
 };
@@ -1743,7 +1739,6 @@ static int pci9118_reset(struct comedi_device *dev)
 static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 					struct comedi_devconfig *it)
 {
-	const struct boardtype *this_board = comedi_board(dev);
 	struct pci_dev *pcidev = NULL;
 	int bus = it->options[0];
 	int slot = it->options[1];
@@ -1751,7 +1746,7 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 	for_each_pci_dev(pcidev) {
 		if (pcidev->vendor != PCI_VENDOR_ID_AMCC)
 			continue;
-		if (pcidev->device != this_board->device_id)
+		if (pcidev->device != 0x80d9)
 			continue;
 		if (bus || slot) {
 			/* requested particular bus/slot */

commit 83defe83332e68f7e477370439d6da6826b715ad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:34 2014 -0700

    staging: comedi: adl_pci9118: use 'context' in (*auto_attach)
    
    The pci_device_id 'driver_data' is passed as the 'context' when the (*auto_attach)
    mechanism is used to attach this driver. Add a boardid enum and index the boardinfo
    so that the "pci9118dg" boardinfo is automatically selected. This allow removing
    the pci9118_find_boardinfo() helper.
    
    Unfortunately all the boards supported by this driver have the same device id.
    Add commented out entries in the device table for them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 333c68f5d5a2..dc0d0cb795bf 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -228,6 +228,12 @@ static const struct comedi_lrange pci9118hg_ai_range = {
 					 * of BIP/UNI ranges
 					 */
 
+enum pci9118_boardid {
+	BOARD_PCI9118DG,
+	BOARD_PCI9118HG,
+	BOARD_PCI9118HR,
+};
+
 struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
@@ -236,14 +242,16 @@ struct boardtype {
 };
 
 static const struct boardtype boardtypes[] = {
-	{
+	[BOARD_PCI9118DG] = {
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
-	}, {
+	},
+	[BOARD_PCI9118HG] = {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
 		.is_hg		= 1,
-	}, {
+	},
+	[BOARD_PCI9118HR] = {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
 		.ai_is_16bit	= 1,
@@ -1732,20 +1740,6 @@ static int pci9118_reset(struct comedi_device *dev)
 	return 0;
 }
 
-/*
- * FIXME - this is pretty ineffective because all the supported board types
- * have the same device ID!
- */
-static const struct boardtype *pci9118_find_boardinfo(struct pci_dev *pcidev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(boardtypes); i++)
-		if (pcidev->device == boardtypes[i].device_id)
-			return &boardtypes[i];
-	return NULL;
-}
-
 static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 					struct comedi_devconfig *it)
 {
@@ -1959,22 +1953,23 @@ static int pci9118_attach(struct comedi_device *dev,
 }
 
 static int pci9118_auto_attach(struct comedi_device *dev,
-					 unsigned long context_unused)
+			       unsigned long context)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct boardtype *board = NULL;
 	struct pci9118_private *devpriv;
 
+	if (context < ARRAY_SIZE(boardtypes))
+		board = &boardtypes[context];
+	if (!board)
+		return -ENODEV;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
+
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
 
-	dev->board_ptr = pci9118_find_boardinfo(pcidev);
-	if (dev->board_ptr == NULL) {
-		dev_err(dev->class_dev,
-			"adl_pci9118: cannot determine board type for pci %s\n",
-			pci_name(pcidev));
-		return -EINVAL;
-	}
 	/*
 	 * Need to 'get' the PCI device to match the 'put' in pci9118_detach().
 	 * (The 'put' also matches the implicit 'get' by pci9118_find_pci().)
@@ -2023,8 +2018,11 @@ static int adl_pci9118_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
+/* FIXME: All the supported board types have the same device ID! */
 static const struct pci_device_id adl_pci9118_pci_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
+	{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118DG },
+/*	{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118HG }, */
+/*	{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118HR }, */
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, adl_pci9118_pci_table);

commit a0972008b2dfa2161ff1223214f5aae574bfe803
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:33 2014 -0700

    staging: comedi: adl_pci9118: refactor 'ai_maxdata' in boardinfo
    
    The boards supported by this driver either have 12-bit or 16-bit analog
    inputs. For aesthetics, replace the 'ai_maxdata' member in the boardinfo
    with a bit-field flag, 'ai_is_16bit', and refactor the subdevice init to
    use the new member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f8214273ec2c..333c68f5d5a2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -231,7 +231,7 @@ static const struct comedi_lrange pci9118hg_ai_range = {
 struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
-	int ai_maxdata;			/* resolution of A/D */
+	unsigned int ai_is_16bit:1;
 	unsigned int is_hg:1;
 };
 
@@ -239,16 +239,14 @@ static const struct boardtype boardtypes[] = {
 	{
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
-		.ai_maxdata	= 0x0fff,
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
-		.ai_maxdata	= 0x0fff,
 		.is_hg		= 1,
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
-		.ai_maxdata	= 0xffff,
+		.ai_is_16bit	= 1,
 	},
 };
 
@@ -1871,7 +1869,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	else
 		s->n_chan = 16;
 
-	s->maxdata = this_board->ai_maxdata;
+	s->maxdata = this_board->ai_is_16bit ? 0xffff : 0x0fff;
 	s->range_table = this_board->is_hg ? &pci9118hg_ai_range
 					   : &pci9118_ai_range;
 	s->insn_read = pci9118_insn_read_ai;

commit 344a15c14162d9976bfdf2a6145eab7989c513d4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:32 2014 -0700

    staging: comedi: adl_pci9118: refactor 'rangelist_ai' in boardinfo
    
    The boards supported by this driver either have "normal" or "high gain"
    analog input ranges.
    
    For aesthetics, replace the 'rangelist_ai' member in the boardinfo with
    a bit-field flag 'is_hg' to indicate the "high gain" range is used.
    Refactor the subdevice init to use the flag to set the correct range_table.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 8653e42df8d5..f8214273ec2c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -197,7 +197,7 @@
 
 #define PCI9118_HALF_FIFO_SZ	(1024 / 2)
 
-static const struct comedi_lrange range_pci9118dg_hr = {
+static const struct comedi_lrange pci9118_ai_range = {
 	8, {
 		BIP_RANGE(5),
 		BIP_RANGE(2.5),
@@ -210,7 +210,7 @@ static const struct comedi_lrange range_pci9118dg_hr = {
 	}
 };
 
-static const struct comedi_lrange range_pci9118hg = {
+static const struct comedi_lrange pci9118hg_ai_range = {
 	8, {
 		BIP_RANGE(5),
 		BIP_RANGE(0.5),
@@ -232,7 +232,7 @@ struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
 	int ai_maxdata;			/* resolution of A/D */
-	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
+	unsigned int is_hg:1;
 };
 
 static const struct boardtype boardtypes[] = {
@@ -240,17 +240,15 @@ static const struct boardtype boardtypes[] = {
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
-		.rangelist_ai	= &range_pci9118dg_hr,
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
-		.rangelist_ai	= &range_pci9118hg,
+		.is_hg		= 1,
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0xffff,
-		.rangelist_ai	= &range_pci9118dg_hr,
 	},
 };
 
@@ -1874,7 +1872,8 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		s->n_chan = 16;
 
 	s->maxdata = this_board->ai_maxdata;
-	s->range_table = this_board->rangelist_ai;
+	s->range_table = this_board->is_hg ? &pci9118hg_ai_range
+					   : &pci9118_ai_range;
 	s->insn_read = pci9118_insn_read_ai;
 	if (dev->irq) {
 		dev->read_subdev = s;

commit 84f3e3a8adad518b449807b4a9e74a0d6a5be0fb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:31 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_pacer_min' from boardinfo
    
    This value can easily be calculated based on the minimum sampling rate,
    'ai_ns_min', and the base clock speed of the timers. Do that instead and
    remove the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3e83b21bed07..8653e42df8d5 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -233,10 +233,6 @@ struct boardtype {
 	int device_id;			/* PCI device ID of card */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
-	unsigned int ai_pacer_min;	/*
-					 * minimal pacer value
-					 * (c1*c2 or c1 in burst)
-					 */
 };
 
 static const struct boardtype boardtypes[] = {
@@ -245,19 +241,16 @@ static const struct boardtype boardtypes[] = {
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.ai_pacer_min	= 12,
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
-		.ai_pacer_min	= 12,
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.ai_pacer_min	= 40,
 	},
 };
 
@@ -705,9 +698,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int *div1, unsigned int *div2,
 				  unsigned int chnsshfront)
 {
-	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int min_pacer;
 
 	switch (mode) {
 	case 1:
@@ -723,8 +716,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 			*tim2 = devpriv->ai_ns_min;
 		*div1 = *tim2 / I8254_OSC_BASE_4MHZ;
 						/* convert timer (burst) */
-		if (*div1 < this_board->ai_pacer_min)
-			*div1 = this_board->ai_pacer_min;
+		min_pacer = devpriv->ai_ns_min / I8254_OSC_BASE_4MHZ;
+		if (*div1 < min_pacer)
+			*div1 = min_pacer;
 		*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
 		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
 		if (*div2 < chans)

commit 34607db8ad9d381bee30389731e42f66ff5a2c03
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:30 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_ns_min' from boardinfo
    
    The minimum convert time 'ai_ns_min' is based on the sampling rate of the A/D
    converter. This driver supports boards that use different ADC chips for 16-bit
    and 12-bit analog inputs. These chips have different sampling rates.
    
    For aesthetics, move the 'ai_ns_min' member from the boardinfo to the private
    data. Initialize the member during the attach based on the 'maxdata' of the
    analog inputs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3d25753d2631..3e83b21bed07 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -233,7 +233,6 @@ struct boardtype {
 	int device_id;			/* PCI device ID of card */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
-	unsigned int ai_ns_min;		/* max sample speed of card v ns */
 	unsigned int ai_pacer_min;	/*
 					 * minimal pacer value
 					 * (c1*c2 or c1 in burst)
@@ -246,21 +245,18 @@ static const struct boardtype boardtypes[] = {
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
-		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.ai_ns_min	= 10000,
 		.ai_pacer_min	= 40,
 	},
 };
@@ -341,6 +337,7 @@ struct pci9118_private {
 					 */
 	unsigned int ai_maskerr;	/* which warning was printed */
 	unsigned int ai_maskharderr;	/* on which error bits stops */
+	unsigned int ai_ns_min;
 };
 
 static int check_channel_list(struct comedi_device *dev,
@@ -709,20 +706,21 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int chnsshfront)
 {
 	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	switch (mode) {
 	case 1:
 	case 4:
-		if (*tim2 < this_board->ai_ns_min)
-			*tim2 = this_board->ai_ns_min;
+		if (*tim2 < devpriv->ai_ns_min)
+			*tim2 = devpriv->ai_ns_min;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  div1, div2,
 					  tim2, flags & CMDF_ROUND_NEAREST);
 		break;
 	case 2:
-		if (*tim2 < this_board->ai_ns_min)
-			*tim2 = this_board->ai_ns_min;
+		if (*tim2 < devpriv->ai_ns_min)
+			*tim2 = devpriv->ai_ns_min;
 		*div1 = *tim2 / I8254_OSC_BASE_4MHZ;
 						/* convert timer (burst) */
 		if (*div1 < this_board->ai_pacer_min)
@@ -1072,7 +1070,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_cmd *cmd)
 {
-	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int flags;
@@ -1154,7 +1151,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER)
 		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 this_board->ai_ns_min);
+						 devpriv->ai_ns_min);
 
 	if (cmd->scan_begin_src == TRIG_EXT)
 		if (cmd->scan_begin_arg) {
@@ -1166,7 +1163,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
 		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 this_board->ai_ns_min);
+						 devpriv->ai_ns_min);
 
 	if (cmd->convert_src == TRIG_EXT)
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
@@ -1210,7 +1207,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 		if (cmd->scan_begin_src == TRIG_TIMER &&
 		    cmd->convert_src == TRIG_NOW) {
 			if (cmd->convert_arg == 0) {
-				arg = this_board->ai_ns_min *
+				arg = devpriv->ai_ns_min *
 				      (cmd->scan_end_arg + 2);
 			} else {
 				arg = cmd->convert_arg * cmd->chanlist_len;
@@ -1491,7 +1488,6 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 
 static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
@@ -1569,8 +1565,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ai_add_front++;
 			devpriv->ai_add_back = 0;
 		}
-		if (cmd->convert_arg < this_board->ai_ns_min)
-			cmd->convert_arg = this_board->ai_ns_min;
+		if (cmd->convert_arg < devpriv->ai_ns_min)
+			cmd->convert_arg = devpriv->ai_ns_min;
 		addchans = devpriv->softsshdelay / cmd->convert_arg;
 		if (devpriv->softsshdelay % cmd->convert_arg)
 			addchans++;
@@ -1896,6 +1892,20 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		s->munge = pci9118_ai_munge;
 	}
 
+	if (s->maxdata == 0xffff) {
+		/*
+		 * 16-bit samples are from an ADS7805 A/D converter.
+		 * Minimum sampling rate is 10us.
+		 */
+		devpriv->ai_ns_min = 10000;
+	} else {
+		/*
+		 * 12-bit samples are from an ADS7800 A/D converter.
+		 * Minimum sampling rate is 3us.
+		 */
+		devpriv->ai_ns_min = 3000;
+	}
+
 	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;

commit df925ca27c10f27c06173e7227c9efacce599789
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:29 2014 -0700

    staging: comedi: adl_pci9118: remove 'n_aichan' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Also, remove the initialization of the subdevice 'len_chanlist'. This
    member is only used if the subdevice supports async commands.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 392afb5ebb30..3d25753d2631 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -231,7 +231,6 @@ static const struct comedi_lrange range_pci9118hg = {
 struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
-	int n_aichan;			/* num of A/D chans */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
@@ -245,7 +244,6 @@ static const struct boardtype boardtypes[] = {
 	{
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
-		.n_aichan	= 16,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
@@ -253,7 +251,6 @@ static const struct boardtype boardtypes[] = {
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
-		.n_aichan	= 16,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
@@ -261,7 +258,6 @@ static const struct boardtype boardtypes[] = {
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
-		.n_aichan	= 16,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
@@ -1885,7 +1881,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	if (devpriv->usemux)
 		s->n_chan = devpriv->usemux;
 	else
-		s->n_chan = this_board->n_aichan;
+		s->n_chan = 16;
 
 	s->maxdata = this_board->ai_maxdata;
 	s->range_table = this_board->rangelist_ai;

commit 12fa2fe1ac6f3b2d51f8a06331a1f1a0e86863fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:28 2014 -0700

    staging: comedi: adl_pci9118: remove 'n_aichand' boardinfo
    
    This member of the boardinfo is the same for all entries. It's also
    half the subdevice 'n_chan'. Use that instead and remove the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e4c52b4b7314..392afb5ebb30 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -232,7 +232,6 @@ struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
 	int n_aichan;			/* num of A/D chans */
-	int n_aichand;			/* num of A/D chans in diff mode */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
@@ -247,7 +246,6 @@ static const struct boardtype boardtypes[] = {
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
-		.n_aichand	= 8,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
@@ -256,7 +254,6 @@ static const struct boardtype boardtypes[] = {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
-		.n_aichand	= 8,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
@@ -265,7 +262,6 @@ static const struct boardtype boardtypes[] = {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
-		.n_aichand	= 8,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
@@ -355,7 +351,6 @@ static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
 {
-	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, differencial = 0, bipolar = 0;
 
@@ -389,7 +384,7 @@ static int check_channel_list(struct comedi_device *dev,
 				return 0;
 			}
 			if (!devpriv->usemux && differencial &&
-			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
+			    (CR_CHAN(chanlist[i]) >= (s->n_chan / 2))) {
 				dev_err(dev->class_dev,
 					"AREF_DIFF is only available for the first 8 channels!\n");
 				return 0;

commit b7e1f441607f07e6e8bf3762f109b81aa87d8513
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:27 2014 -0700

    staging: comedi: adl_pci9118: remove 'n_aichanlist' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3abb2551c377..e4c52b4b7314 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -233,7 +233,6 @@ struct boardtype {
 	int device_id;			/* PCI device ID of card */
 	int n_aichan;			/* num of A/D chans */
 	int n_aichand;			/* num of A/D chans in diff mode */
-	int n_aichanlist;		/* len of chanlist */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
@@ -249,7 +248,6 @@ static const struct boardtype boardtypes[] = {
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.n_aichanlist	= PCI9118_CHANLEN,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
@@ -259,7 +257,6 @@ static const struct boardtype boardtypes[] = {
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.n_aichanlist	= PCI9118_CHANLEN,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
@@ -269,7 +266,6 @@ static const struct boardtype boardtypes[] = {
 		.device_id	= 0x80d9,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.n_aichanlist	= PCI9118_CHANLEN,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
@@ -1902,7 +1898,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
-		s->len_chanlist = this_board->n_aichanlist;
+		s->len_chanlist = PCI9118_CHANLEN;
 		s->do_cmdtest = pci9118_ai_cmdtest;
 		s->do_cmd = pci9118_ai_cmd;
 		s->cancel = pci9118_ai_cancel;

commit ea2d3993ce7edaf67d53ce9340ab6c984dfd08af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:26 2014 -0700

    staging: comedi: adl_pci9118: remove 'half_fifo_size' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 558732c0f621..3abb2551c377 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -195,6 +195,8 @@
 
 #define EXTTRG_AI	0	/* ext trg is used by AI */
 
+#define PCI9118_HALF_FIFO_SZ	(1024 / 2)
+
 static const struct comedi_lrange range_pci9118dg_hr = {
 	8, {
 		BIP_RANGE(5),
@@ -239,8 +241,6 @@ struct boardtype {
 					 * minimal pacer value
 					 * (c1*c2 or c1 in burst)
 					 */
-	int half_fifo_size;		/* size of FIFO/2 */
-
 };
 
 static const struct boardtype boardtypes[] = {
@@ -254,7 +254,6 @@ static const struct boardtype boardtypes[] = {
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
-		.half_fifo_size	= 512,
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
@@ -265,7 +264,6 @@ static const struct boardtype boardtypes[] = {
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
-		.half_fifo_size	= 512,
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
@@ -276,7 +274,6 @@ static const struct boardtype boardtypes[] = {
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
 		.ai_pacer_min	= 40,
-		.half_fifo_size	= 512,
 	},
 };
 
@@ -1355,12 +1352,12 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	devpriv->dmabuf_use_size[1] = dmalen1;
 
 #if 0
-	if (cmd->scan_end_arg < this_board->half_fifo_size) {
+	if (cmd->scan_end_arg < PCI9118_HALF_FIFO_SZ) {
 		devpriv->dmabuf_panic_size[0] =
-		    (this_board->half_fifo_size / cmd->scan_end_arg +
+		    (PCI9118_HALF_FIFO_SZ / cmd->scan_end_arg +
 		     1) * cmd->scan_end_arg * sizeof(short);
 		devpriv->dmabuf_panic_size[1] =
-		    (this_board->half_fifo_size / cmd->scan_end_arg +
+		    (PCI9118_HALF_FIFO_SZ / cmd->scan_end_arg +
 		     1) * cmd->scan_end_arg * sizeof(short);
 	} else {
 		devpriv->dmabuf_panic_size[0] =

commit 44aa94e8cc406d70263495e34475e7e842952289
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:25 2014 -0700

    staging: comedi: adl_pci9118: remove 'n_aochan' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Also, remove the initialization of the subdevice 'len_chanlist'. This
    member is only used if the subdevice supports async commands.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 45fa701e3c9c..558732c0f621 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -232,7 +232,6 @@ struct boardtype {
 	int n_aichan;			/* num of A/D chans */
 	int n_aichand;			/* num of A/D chans in diff mode */
 	int n_aichanlist;		/* len of chanlist */
-	int n_aochan;			/* num of D/A chans */
 	int ai_maxdata;			/* resolution of A/D */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
@@ -251,7 +250,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichan	= 16,
 		.n_aichand	= 8,
 		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
@@ -263,7 +261,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichan	= 16,
 		.n_aichand	= 8,
 		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
@@ -275,7 +272,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichan	= 16,
 		.n_aichand	= 8,
 		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
 		.ai_maxdata	= 0xffff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
@@ -1919,9 +1915,8 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
-	s->n_chan = this_board->n_aochan;
+	s->n_chan = 2;
 	s->maxdata = 0x0fff;
-	s->len_chanlist = this_board->n_aochan;
 	s->range_table = &range_bipolar10;
 	s->insn_write = pci9118_insn_write_ao;
 	s->insn_read = pci9118_insn_read_ao;

commit b22699d6734d66a68816a95f2628b27840da9dad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:24 2014 -0700

    staging: comedi: adl_pci9118: remove 'ao_maxdata' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9686a134825c..45fa701e3c9c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -234,7 +234,6 @@ struct boardtype {
 	int n_aichanlist;		/* len of chanlist */
 	int n_aochan;			/* num of D/A chans */
 	int ai_maxdata;			/* resolution of A/D */
-	int ao_maxdata;			/* resolution of D/A */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
 	unsigned int ai_pacer_min;	/*
@@ -254,7 +253,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
-		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
@@ -267,7 +265,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
-		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
@@ -280,7 +277,6 @@ static const struct boardtype boardtypes[] = {
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0xffff,
-		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
 		.ai_ns_min	= 10000,
 		.ai_pacer_min	= 40,
@@ -1924,7 +1920,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
 	s->n_chan = this_board->n_aochan;
-	s->maxdata = this_board->ao_maxdata;
+	s->maxdata = 0x0fff;
 	s->len_chanlist = this_board->n_aochan;
 	s->range_table = &range_bipolar10;
 	s->insn_write = pci9118_insn_write_ao;

commit 1ac986af0f176c8345b465bc3a5d70ebdc0cecaf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:23 2014 -0700

    staging: comedi: adl_pci9118: remove 'rangelist_ao' boardinfo
    
    This member of the boardinfo is the same for all entries. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 300d85e36a62..9686a134825c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -236,7 +236,6 @@ struct boardtype {
 	int ai_maxdata;			/* resolution of A/D */
 	int ao_maxdata;			/* resolution of D/A */
 	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
-	const struct comedi_lrange *rangelist_ao;	/* rangelist for D/A */
 	unsigned int ai_ns_min;		/* max sample speed of card v ns */
 	unsigned int ai_pacer_min;	/*
 					 * minimal pacer value
@@ -257,7 +256,6 @@ static const struct boardtype boardtypes[] = {
 		.ai_maxdata	= 0x0fff,
 		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.rangelist_ao	= &range_bipolar10,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
 		.half_fifo_size	= 512,
@@ -271,7 +269,6 @@ static const struct boardtype boardtypes[] = {
 		.ai_maxdata	= 0x0fff,
 		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118hg,
-		.rangelist_ao	= &range_bipolar10,
 		.ai_ns_min	= 3000,
 		.ai_pacer_min	= 12,
 		.half_fifo_size	= 512,
@@ -285,7 +282,6 @@ static const struct boardtype boardtypes[] = {
 		.ai_maxdata	= 0xffff,
 		.ao_maxdata	= 0x0fff,
 		.rangelist_ai	= &range_pci9118dg_hr,
-		.rangelist_ao	= &range_bipolar10,
 		.ai_ns_min	= 10000,
 		.ai_pacer_min	= 40,
 		.half_fifo_size	= 512,
@@ -1930,7 +1926,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->n_chan = this_board->n_aochan;
 	s->maxdata = this_board->ao_maxdata;
 	s->len_chanlist = this_board->n_aochan;
-	s->range_table = this_board->rangelist_ao;
+	s->range_table = &range_bipolar10;
 	s->insn_write = pci9118_insn_write_ao;
 	s->insn_read = pci9118_insn_read_ao;
 

commit 06db74b4de6eba986c0be736fa1919d5a27c47d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 4 10:39:22 2014 -0700

    staging: comedi: adl_pci9118: remove unused boardinfo
    
    Remove all the boardinfo members that are not used by the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b71b0cf041c4..300d85e36a62 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -229,14 +229,8 @@ static const struct comedi_lrange range_pci9118hg = {
 struct boardtype {
 	const char *name;		/* board name */
 	int device_id;			/* PCI device ID of card */
-	int iorange_amcc;		/* iorange for own S5933 region */
-	int iorange_9118;		/* pass thru card region size */
 	int n_aichan;			/* num of A/D chans */
 	int n_aichand;			/* num of A/D chans in diff mode */
-	int mux_aichan;			/*
-					 * num of A/D chans with
-					 * external multiplexor
-					 */
 	int n_aichanlist;		/* len of chanlist */
 	int n_aochan;			/* num of D/A chans */
 	int ai_maxdata;			/* resolution of A/D */
@@ -256,11 +250,8 @@ static const struct boardtype boardtypes[] = {
 	{
 		.name		= "pci9118dg",
 		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.mux_aichan	= 256,
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
@@ -273,11 +264,8 @@ static const struct boardtype boardtypes[] = {
 	}, {
 		.name		= "pci9118hg",
 		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.mux_aichan	= 256,
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0x0fff,
@@ -290,11 +278,8 @@ static const struct boardtype boardtypes[] = {
 	}, {
 		.name		= "pci9118hr",
 		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
 		.n_aichan	= 16,
 		.n_aichand	= 8,
-		.mux_aichan	= 256,
 		.n_aichanlist	= PCI9118_CHANLEN,
 		.n_aochan	= 2,
 		.ai_maxdata	= 0xffff,

commit ed23e413bd2614f3fc767e1cd1250ff3a677f857
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:48 2014 +0100

    staging: comedi: adl_pci9118: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3e16b5f06efe..b71b0cf041c4 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -761,7 +761,7 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 			*tim2 = this_board->ai_ns_min;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  div1, div2,
-					  tim2, flags & TRIG_ROUND_NEAREST);
+					  tim2, flags & CMDF_ROUND_NEAREST);
 		break;
 	case 2:
 		if (*tim2 < this_board->ai_ns_min)

commit c25dec5773e3e4d66c29d53c96d008ac7ec9cb56
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:32 2014 +0100

    staging: comedi: adl_pci9118: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.  Also change
    diagnostic messages to use "CMDF_WAKE_EOS" instead of "TRIG_WAKE_EOS"
    and change the Comedi driver description comment to use "CMDF_WAKE_EOS".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6fc50b3735c0..3e16b5f06efe 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -36,8 +36,8 @@
  * b) DMA transfers must have the length aligned to two samples (32 bit),
  *  so there is some problems if cmd->chanlist_len is odd. This driver tries
  *  bypass this with adding one sample to the end of the every scan and discard
- *  it on output but this cann't be used if cmd->scan_begin_src=TRIG_FOLLOW
- *  and is used flag TRIG_WAKE_EOS, then driver switch to interrupt driven mode
+ *  it on output but this can't be used if cmd->scan_begin_src=TRIG_FOLLOW
+ *  and is used flag CMDF_WAKE_EOS, then driver switch to interrupt driven mode
  *  with interrupt after every sample.
  * c) If isn't used DMA then you can use only mode where
  *  cmd->scan_begin_src=TRIG_FOLLOW.
@@ -1294,12 +1294,12 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	}
 
 	/* we want wake up every scan? */
-	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
+	if (devpriv->ai_flags & CMDF_WAKE_EOS) {
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
 			/* uff, too short DMA buffer, disable EOS support! */
-			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
+			devpriv->ai_flags &= (~CMDF_WAKE_EOS);
 			dev_info(dev->class_dev,
-				 "WAR: DMA0 buf too short, can't support TRIG_WAKE_EOS (%d<%d)\n",
+				 "WAR: DMA0 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",
 				  dmalen0, devpriv->ai_n_realscanlen << 1);
 		} else {
 			/* short first DMA buffer to one scan */
@@ -1312,12 +1312,12 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 			}
 		}
 	}
-	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
+	if (devpriv->ai_flags & CMDF_WAKE_EOS) {
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
 			/* uff, too short DMA buffer, disable EOS support! */
-			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
+			devpriv->ai_flags &= (~CMDF_WAKE_EOS);
 			dev_info(dev->class_dev,
-				 "WAR: DMA1 buf too short, can't support TRIG_WAKE_EOS (%d<%d)\n",
+				 "WAR: DMA1 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",
 				 dmalen1, devpriv->ai_n_realscanlen << 1);
 		} else {
 			/* short second DMA buffer to one scan */
@@ -1331,8 +1331,8 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 		}
 	}
 
-	/* transfer without TRIG_WAKE_EOS */
-	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
+	/* transfer without CMDF_WAKE_EOS */
+	if (!(devpriv->ai_flags & CMDF_WAKE_EOS)) {
 		/* if it's possible then align DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
@@ -1570,7 +1570,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_add_back = 0;
 	if (devpriv->master) {
 		devpriv->usedma = 1;
-		if ((cmd->flags & TRIG_WAKE_EOS) &&
+		if ((cmd->flags & CMDF_WAKE_EOS) &&
 		    (cmd->scan_end_arg == 1)) {
 			if (cmd->convert_src == TRIG_NOW)
 				devpriv->ai_add_back = 1;
@@ -1582,7 +1582,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 */
 			}
 		}
-		if ((cmd->flags & TRIG_WAKE_EOS) &&
+		if ((cmd->flags & CMDF_WAKE_EOS) &&
 		    (cmd->scan_end_arg & 1) &&
 		    (cmd->scan_end_arg > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f30b84e1987b..6fc50b3735c0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2033,11 +2033,10 @@ static void pci9118_detach(struct comedi_device *dev)
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pci9118_private *devpriv = dev->private;
 
+	if (dev->iobase)
+		pci9118_reset(dev);
+	comedi_pci_detach(dev);
 	if (devpriv) {
-		if (dev->iobase)
-			pci9118_reset(dev);
-		if (dev->irq)
-			free_irq(dev->irq, dev);
 		if (devpriv->dmabuf_virt[0])
 			free_pages((unsigned long)devpriv->dmabuf_virt[0],
 				   devpriv->dmabuf_pages[0]);
@@ -2045,7 +2044,6 @@ static void pci9118_detach(struct comedi_device *dev)
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
 				   devpriv->dmabuf_pages[1]);
 	}
-	comedi_pci_disable(dev);
 	if (pcidev)
 		pci_dev_put(pcidev);
 }

commit c8ea69c4a8c76a59aea1738d41781590389cdc02
Author: Sam Asadi <asadi.samuel@gmail.com>
Date:   Sat Jul 19 14:53:03 2014 +0300

    Staging: comedi: adl_paci9118: organized entry comments
    
    Introductory comments organized according to Linux's comment
    coding style.
    
    Signed-off-by: Sam Asadi <asadi.samuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index da3fecd93275..f30b84e1987b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -7,61 +7,62 @@
  *
  * Author: Michal Dobes <dobes@tesnet.cz>
  *
-*/
+ */
+
 /*
-Driver: adl_pci9118
-Description: Adlink PCI-9118DG, PCI-9118HG, PCI-9118HR
-Author: Michal Dobes <dobes@tesnet.cz>
-Devices: [ADLink] PCI-9118DG (pci9118dg), PCI-9118HG (pci9118hg),
-  PCI-9118HR (pci9118hr)
-Status: works
-
-This driver supports AI, AO, DI and DO subdevices.
-AI subdevice supports cmd and insn interface,
-other subdevices support only insn interface.
-For AI:
-- If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
-- If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
-- If cmd->start_src/stop_src=TRIG_EXT then trigger input is TGIN (pin 46).
-- It is not necessary to have cmd.scan_end_arg=cmd.chanlist_len but
-  cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
-- If return value of cmdtest is 5 then you've bad channel list
-  (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
-  ranges).
-
-There are some hardware limitations:
-a) You cann't use mixture of unipolar/bipoar ranges or differencial/single
-   ended inputs.
-b) DMA transfers must have the length aligned to two samples (32 bit),
-   so there is some problems if cmd->chanlist_len is odd. This driver tries
-   bypass this with adding one sample to the end of the every scan and discard
-   it on output but this cann't be used if cmd->scan_begin_src=TRIG_FOLLOW
-   and is used flag TRIG_WAKE_EOS, then driver switch to interrupt driven mode
-   with interrupt after every sample.
-c) If isn't used DMA then you can use only mode where
-   cmd->scan_begin_src=TRIG_FOLLOW.
-
-Configuration options:
-  [0] - PCI bus of device (optional)
-  [1] - PCI slot of device (optional)
-	If bus/slot is not specified, then first available PCI
-	card will be used.
-  [2] - 0= standard 8 DIFF/16 SE channels configuration
-	n = external multiplexer connected, 1 <= n <= 256
-  [3] - 0=autoselect DMA or EOC interrupts operation
-	1 = disable DMA mode
-	3 = disable DMA and INT, only insn interface will work
-  [4] - sample&hold signal - card can generate signal for external S&H board
-	0 = use SSHO(pin 45) signal is generated in onboard hardware S&H logic
-	0 != use ADCHN7(pin 23) signal is generated from driver, number say how
-		long delay is requested in ns and sign polarity of the hold
-		(in this case external multiplexor can serve only 128 channels)
-  [5] - 0=stop measure on all hardware errors
-	2 | = ignore ADOR - A/D Overrun status
-	8|=ignore Bover - A/D Burst Mode Overrun status
-	256|=ignore nFull - A/D FIFO Full status
-
-*/
+ * Driver: adl_pci9118
+ * Description: Adlink PCI-9118DG, PCI-9118HG, PCI-9118HR
+ * Author: Michal Dobes <dobes@tesnet.cz>
+ * Devices: [ADLink] PCI-9118DG (pci9118dg), PCI-9118HG (pci9118hg),
+ * PCI-9118HR (pci9118hr)
+ * Status: works
+ *
+ * This driver supports AI, AO, DI and DO subdevices.
+ * AI subdevice supports cmd and insn interface,
+ * other subdevices support only insn interface.
+ * For AI:
+ * - If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
+ * - If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
+ * - If cmd->start_src/stop_src=TRIG_EXT then trigger input is TGIN (pin 46).
+ * - It is not necessary to have cmd.scan_end_arg=cmd.chanlist_len but
+ * cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
+ * - If return value of cmdtest is 5 then you've bad channel list
+ * (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
+ * ranges).
+ *
+ * There are some hardware limitations:
+ * a) You cann't use mixture of unipolar/bipoar ranges or differencial/single
+ *  ended inputs.
+ * b) DMA transfers must have the length aligned to two samples (32 bit),
+ *  so there is some problems if cmd->chanlist_len is odd. This driver tries
+ *  bypass this with adding one sample to the end of the every scan and discard
+ *  it on output but this cann't be used if cmd->scan_begin_src=TRIG_FOLLOW
+ *  and is used flag TRIG_WAKE_EOS, then driver switch to interrupt driven mode
+ *  with interrupt after every sample.
+ * c) If isn't used DMA then you can use only mode where
+ *  cmd->scan_begin_src=TRIG_FOLLOW.
+ *
+ * Configuration options:
+ * [0] - PCI bus of device (optional)
+ * [1] - PCI slot of device (optional)
+ *	 If bus/slot is not specified, then first available PCI
+ *	 card will be used.
+ * [2] - 0= standard 8 DIFF/16 SE channels configuration
+ *	 n = external multiplexer connected, 1 <= n <= 256
+ * [3] - 0=autoselect DMA or EOC interrupts operation
+ *	 1 = disable DMA mode
+ *	 3 = disable DMA and INT, only insn interface will work
+ * [4] - sample&hold signal - card can generate signal for external S&H board
+ *	 0 = use SSHO(pin 45) signal is generated in onboard hardware S&H logic
+ *	 0 != use ADCHN7(pin 23) signal is generated from driver, number say how
+ *		long delay is requested in ns and sign polarity of the hold
+ *		(in this case external multiplexor can serve only 128 channels)
+ * [5] - 0=stop measure on all hardware errors
+ *	 2 | = ignore ADOR - A/D Overrun status
+ *	 8|=ignore Bover - A/D Burst Mode Overrun status
+ *	 256|=ignore nFull - A/D FIFO Full status
+ *
+ */
 
 /*
  * FIXME

commit c11da2df834c2d93133f9890afbfcab7b0e38ded
Author: Sam Asadi <asadi.samuel@gmail.com>
Date:   Fri Jul 18 23:13:08 2014 +0300

    Staging: comedi: adl_pci9118: line over 80 fixed
    
    A 'line over 80 characters' issue fixed.
    
    Signed-off-by: Sam Asadi <asadi.samuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7cb93791155b..da3fecd93275 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -346,7 +346,7 @@ struct pci9118_private {
 						 * on external start
 						 */
 	unsigned short ao_data[2];		/* data output buffer */
-	char dma_doublebuf;			/* we can use double buffering */
+	char dma_doublebuf;			/* use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	unsigned short *dmabuf_virt[2];		/*
 						 * pointers to begin of

commit 027a8ccf2c42ffdb472a2001d965a938d48261c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:51 2014 -0700

    staging: comedi: adl_pci9118: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 93bd9ee42da1..7cb93791155b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -394,12 +394,12 @@ static int check_channel_list(struct comedi_device *dev,
 
 	/* correct channel and range number check itself comedi/range.c */
 	if (n_chan < 1) {
-		comedi_error(dev, "range/channel list is empty!");
+		dev_err(dev->class_dev, "range/channel list is empty!\n");
 		return 0;
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		comedi_error(dev,
-			    "range/channel list is too long for actual configuration!\n");
+		dev_err(dev->class_dev,
+			"range/channel list is too long for actual configuration!\n");
 		return 0;
 	}
 
@@ -411,22 +411,20 @@ static int check_channel_list(struct comedi_device *dev,
 		for (i = 1; i < n_chan; i++) {	/* check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 			    (differencial)) {
-				comedi_error(dev,
-					     "Differential and single ended inputs can't be mixed!");
+				dev_err(dev->class_dev,
+					"Differential and single ended inputs can't be mixed!\n");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
 			    (bipolar)) {
-				comedi_error(dev,
-					     "Bipolar and unipolar ranges "
-							"can't be mixtured!");
+				dev_err(dev->class_dev,
+					"Bipolar and unipolar ranges can't be mixed!\n");
 				return 0;
 			}
 			if (!devpriv->usemux && differencial &&
 			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
-				comedi_error(dev,
-					     "If AREF_DIFF is used then is "
-					"available only first 8 channels!");
+				dev_err(dev->class_dev,
+					"AREF_DIFF is only available for the first 8 channels!\n");
 				return 0;
 			}
 		}
@@ -863,20 +861,21 @@ static char pci9118_decode_error_status(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 
 	if (m & 0x100) {
-		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
+		dev_err(dev->class_dev,
+			"A/D FIFO Full status (Fatal Error!)\n");
 		devpriv->ai_maskerr &= ~0x100L;
 	}
 	if (m & 0x008) {
-		comedi_error(dev,
-			     "A/D Burst Mode Overrun Status (Fatal Error!)");
+		dev_err(dev->class_dev,
+			"A/D Burst Mode Overrun Status (Fatal Error!)\n");
 		devpriv->ai_maskerr &= ~0x008L;
 	}
 	if (m & 0x004) {
-		comedi_error(dev, "A/D Over Speed Status (Warning!)");
+		dev_err(dev->class_dev, "A/D Over Speed Status (Warning!)\n");
 		devpriv->ai_maskerr &= ~0x004L;
 	}
 	if (m & 0x002) {
-		comedi_error(dev, "A/D Overrun Status (Fatal Error!)");
+		dev_err(dev->class_dev, "A/D Overrun Status (Fatal Error!)\n");
 		devpriv->ai_maskerr &= ~0x002L;
 	}
 	if (m & devpriv->ai_maskharderr) {
@@ -965,14 +964,14 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
 	if (int_amcc & MASTER_ABORT_INT) {
-		comedi_error(dev, "AMCC IRQ - MASTER DMA ABORT!");
+		dev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		return;
 	}
 
 	if (int_amcc & TARGET_ABORT_INT) {
-		comedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");
+		dev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		return;
@@ -1426,17 +1425,16 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		devpriv->AdControlReg |= AdControl_TmrTr;
 		break;
 	case 2:
-		comedi_error(dev, "pci9118_ai_docmd_sampl() mode 2 bug!\n");
+		dev_err(dev->class_dev, "%s mode 2 bug!\n", __func__);
 		return -EIO;
 	case 3:
 		devpriv->AdControlReg |= AdControl_ExtM;
 		break;
 	case 4:
-		comedi_error(dev, "pci9118_ai_docmd_sampl() mode 4 bug!\n");
+		dev_err(dev->class_dev, "%s mode 4 bug!\n", __func__);
 		return -EIO;
 	default:
-		comedi_error(dev,
-			     "pci9118_ai_docmd_sampl() mode number bug!\n");
+		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
 		return -EIO;
 	}
 
@@ -1508,7 +1506,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		devpriv->AdFunctionReg |= AdFunction_Start;
 		break;
 	default:
-		comedi_error(dev, "pci9118_ai_docmd_dma() mode number bug!\n");
+		dev_err(dev->class_dev, "%s mode number bug!\n", __func__);
 		return -EIO;
 	}
 
@@ -1676,9 +1674,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		(cmd->convert_src == TRIG_NOW))) {
 						/* double timed action */
 		if (!devpriv->usedma) {
-			comedi_error(dev,
-				     "cmd->scan_begin_src=TRIG_TIMER works "
-						"only with bus mastering!");
+			dev_err(dev->class_dev,
+				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!\n");
 			return -EIO;
 		}
 

commit 2cbc7a3fbac49836bf67bd02b7ca036076470e7c
Author: Sam Asadi <asadi.samuel@gmail.com>
Date:   Wed Jul 16 23:23:56 2014 +0300

    Staging: adl_pci9118: a language issue fixed
    
    For better use of English, 'mixtured' which is not right, replaced
    by 'mixed'.
    
    Signed-off-by: Sam Asadi <asadi.samuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f2a2d042f1c3..93bd9ee42da1 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -412,7 +412,7 @@ static int check_channel_list(struct comedi_device *dev,
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 			    (differencial)) {
 				comedi_error(dev,
-					     "Differential and single ended inputs can't be mixtured!");
+					     "Differential and single ended inputs can't be mixed!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=

commit 08aa75496ff15450666b99700e449727036870a1
Author: Sam Asadi <asadi.samuel@gmail.com>
Date:   Wed Jul 16 18:23:00 2014 +0300

    Staging: comedi: adl_pci9118: fractured spelling fixed
    
    a fractured spelling in previous style issue fix mended.
    
    Signed-off-by: Sam Asadi <asadi.samuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b2d25f585438..f2a2d042f1c3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -412,7 +412,7 @@ static int check_channel_list(struct comedi_device *dev,
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 			    (differencial)) {
 				comedi_error(dev,
-					     "Differencial and single ended inputs can't be mixtured!");
+					     "Differential and single ended inputs can't be mixtured!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=

commit b86bc99054560d49d27816349550d0e1b96addc4
Author: Sam Asadi <asadi.samuel@gmail.com>
Date:   Wed Jul 16 18:22:59 2014 +0300

    Staging: comedi: adl_pci9118: a style issue fixed
    
    'quoted string split across lines' warning in checkpatching fixed
    by group whole string in one line.
    
    Signed-off-by: Sam Asadi <asadi.samuel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 59a65cbc6db9..b2d25f585438 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -412,8 +412,7 @@ static int check_channel_list(struct comedi_device *dev,
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 			    (differencial)) {
 				comedi_error(dev,
-					     "Differencial and single ended "
-						"inputs can't be mixtured!");
+					     "Differencial and single ended inputs can't be mixtured!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=

commit 9c1efda8388fd9f6f99df0053eb25996a39fba89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:42 2014 -0700

    staging: comedi: adl_pci9118: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper, cfc_check_trigger_arg_is(), to validate the
    arguments for the TRIG_TIMER command sources. Pass the local variable to
    i8253_cascade_ns_to_timer() instead of the cmd argument. This value
    is modified by that function to return the actual time (in nanoseconds)
    that the timer will be programmed with based on the calculated divisors.
    The cfc_check_trigger_arg_is() helper will then validate that the argument
    is that value and modify it if not.
    
    Use cfc_check_trigger_arg_min() to do validate the cmd->scan_begin_arg
    when the scan_begin_src is TRIG_TIMER and the convert_src is TRIG_NOW.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 89ed2d6dea0a..59a65cbc6db9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1120,7 +1120,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int flags;
-	int tmp;
+	unsigned int arg;
 	unsigned int divisor1 = 0, divisor2 = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -1237,45 +1237,30 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
+		arg = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  &divisor1, &divisor2,
-					  &cmd->scan_begin_arg, cmd->flags);
-		if (cmd->scan_begin_arg < this_board->ai_ns_min)
-			cmd->scan_begin_arg = this_board->ai_ns_min;
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
-		tmp = cmd->convert_arg;
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  &divisor1, &divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (cmd->convert_arg < this_board->ai_ns_min)
-			cmd->convert_arg = this_board->ai_ns_min;
-		if (tmp != cmd->convert_arg)
-			err++;
-		if (cmd->scan_begin_src == TRIG_TIMER
-		    && cmd->convert_src == TRIG_NOW) {
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+
+		if (cmd->scan_begin_src == TRIG_TIMER &&
+		    cmd->convert_src == TRIG_NOW) {
 			if (cmd->convert_arg == 0) {
-				if (cmd->scan_begin_arg <
-				    this_board->ai_ns_min *
-				    (cmd->scan_end_arg + 2)) {
-					cmd->scan_begin_arg =
-					    this_board->ai_ns_min *
-					    (cmd->scan_end_arg + 2);
-					err++;
-				}
+				arg = this_board->ai_ns_min *
+				      (cmd->scan_end_arg + 2);
 			} else {
-				if (cmd->scan_begin_arg <
-				    cmd->convert_arg * cmd->chanlist_len) {
-					cmd->scan_begin_arg =
-					    cmd->convert_arg *
-					    cmd->chanlist_len;
-					err++;
-				}
+				arg = cmd->convert_arg * cmd->chanlist_len;
 			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 arg);
 		}
 	}
 

commit 3cc6a135d5123ecfdc4493cfd0a6a1b5b8530aca
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:48 2014 -0700

    staging: comedi: adl_pci9118: remove 'dmabuf_samples' from private data
    
    This member of the private data is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c9c6f14f3948..89ed2d6dea0a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -362,7 +362,6 @@ struct pci9118_private {
 						 */
 	unsigned int dmabuf_used_size[2];	/* which size was truly used */
 	unsigned int dmabuf_panic_size[2];
-	unsigned int dmabuf_samples[2];		/* size in samples */
 	int dmabuf_pages[2];			/* number of pages in buffer */
 	unsigned char exttrg_users;		/*
 						 * bit field of external trigger
@@ -1885,8 +1884,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 			if (devpriv->dmabuf_virt[i]) {
 				devpriv->dmabuf_pages[i] = pages;
 				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
-				devpriv->dmabuf_samples[i] =
-				    devpriv->dmabuf_size[i] >> 1;
 				devpriv->dmabuf_hw[i] =
 				    virt_to_bus((void *)
 						devpriv->dmabuf_virt[i]);

commit bdf2fed27642c2202f49387a6150e506a1a63535
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:47 2014 -0700

    staging: comedi: adl_pci9118: remove 'cnt0_divisor' from private data
    
    This member of the private data is not used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2be703767516..c9c6f14f3948 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -368,7 +368,6 @@ struct pci9118_private {
 						 * bit field of external trigger
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
 						 */
-	unsigned int cnt0_divisor;		/* actual CNT0 divisor */
 	unsigned char usedma;		/* =1 use DMA transfer and not INT */
 	int softsshdelay;		/*
 					 * >0 use software S&H,

commit bd3772ec57f27807f6f1846b1696f0a1d0de9e5b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:46 2014 -0700

    staging: comedi: adl_pci9118: tidy up start_pacer()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    The divisors used to load the counters are stored in the private data.
    Get them from there and remove the parameters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b1d9e35cc657..2be703767516 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -792,9 +792,12 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 	}
 }
 
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2)
+static void pci9118_start_pacer(struct comedi_device *dev, int mode)
 {
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int divisor1 = devpriv->ai_divisor1;
+	unsigned int divisor2 = devpriv->ai_divisor2;
+
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
 /* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
@@ -818,7 +821,7 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 			(~EN_A2P_TRANSFERS),
 			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	/* stop 8254 counters */
+	pci9118_start_pacer(dev, 0);	/* stop 8254 counters */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 					/*
@@ -1065,9 +1068,7 @@ static irqreturn_t pci9118_interrupt(int irq, void *d)
 					pci9118_exttrg_del(dev, EXTTRG_AI);
 
 				/* start pacer */
-				start_pacer(dev, devpriv->ai_do,
-					    devpriv->ai_divisor1,
-					    devpriv->ai_divisor2);
+				pci9118_start_pacer(dev, devpriv->ai_do);
 				outl(devpriv->AdControlReg,
 				     dev->iobase + PCI9118_ADCNTRL);
 			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
@@ -1105,8 +1106,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	if (devpriv->ai_do != 3) {
-		start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-			    devpriv->ai_divisor2);
+		pci9118_start_pacer(dev, devpriv->ai_do);
 		devpriv->AdControlReg |= AdControl_SoftG;
 	}
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -1475,8 +1475,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		if (devpriv->ai_do != 3) {
-			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				    devpriv->ai_divisor2);
+			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1543,8 +1542,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		if (devpriv->ai_do != 3) {
-			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				    devpriv->ai_divisor2);
+			pci9118_start_pacer(dev, devpriv->ai_do);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -1717,7 +1715,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_do = 3;
 	}
 
-	start_pacer(dev, -1, 0, 0);	/* stop pacer */
+	pci9118_start_pacer(dev, -1);	/* stop pacer */
 
 	devpriv->AdControlReg = 0;	/*
 					 * bipolar, S.E., use 8254, stop 8354,
@@ -1763,7 +1761,7 @@ static int pci9118_reset(struct comedi_device *dev)
 						/* disable interrupts source */
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 /* outl(0xb4, dev->iobase + PCI9118_CNTCTRL); */
-	start_pacer(dev, 0, 0, 0);		/* stop 8254 counters */
+	pci9118_start_pacer(dev, 0);		/* stop 8254 counters */
 	devpriv->AdControlReg = 0;
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
 						/*

commit c089d5af6e93107af52494b816682b05affe809d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:45 2014 -0700

    staging: comedi: adl_pci9118: tidy up interrupt_pci9118()
    
    For aesthetics, rename this function so it has namespace associated
    with the driver.
    
    Refactor the function to reduce the indent level and tidy up the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 358f09c64629..b1d9e35cc657 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1030,75 +1030,62 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	cfc_handle_events(dev, s);
 }
 
-static irqreturn_t interrupt_pci9118(int irq, void *d)
+static irqreturn_t pci9118_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int int_daq = 0, int_amcc, int_adstat;
+	unsigned int intsrc;	/* IRQ reasons from card */
+	unsigned int intcsr;	/* INT register from AMCC chip */
+	unsigned int adstat;	/* STATUS register */
 
 	if (!dev->attached)
-		return IRQ_NONE;	/* not fully initialized */
-
-	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;
-					/* get IRQ reasons from card */
-	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-					/* get INT register from AMCC chip */
-
-	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
-		return IRQ_NONE;	/* interrupt from other source */
-
-	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-					/* shutdown IRQ reasons in AMCC */
-
-	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
-					/* get STATUS register */
-
-	if (devpriv->ai_do) {
-		if (devpriv->ai12_startstop) {
-			if ((int_adstat & AdStatus_DTH) &&
-							(int_daq & Int_DTrg)) {
-						/* start stop of measure */
-				if (devpriv->ai12_startstop & START_AI_EXT) {
-					devpriv->ai12_startstop &=
-					    ~START_AI_EXT;
-					if (!(devpriv->ai12_startstop &
-							STOP_AI_EXT))
-							pci9118_exttrg_del
-							(dev, EXTTRG_AI);
-						/* deactivate EXT trigger */
-					start_pacer(dev, devpriv->ai_do,
-						devpriv->ai_divisor1,
-						devpriv->ai_divisor2);
-						/* start pacer */
-					outl(devpriv->AdControlReg,
-						dev->iobase + PCI9118_ADCNTRL);
-				} else {
-					if (devpriv->ai12_startstop &
-						STOP_AI_EXT) {
-						devpriv->ai12_startstop &=
-							~STOP_AI_EXT;
-						pci9118_exttrg_del
-							(dev, EXTTRG_AI);
-						/* deactivate EXT trigger */
-						devpriv->ai_neverending = 0;
-						/*
-						 * well, on next interrupt from
-						 * DMA/EOC measure will stop
-						 */
-					}
-				}
+		return IRQ_NONE;
+
+	intsrc = inl(dev->iobase + PCI9118_INTSRC) & 0xf;
+	intcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+
+	if (!intsrc && !(intcsr & ANY_S593X_INT))
+		return IRQ_NONE;
+
+	outl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+
+	adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
+
+	if (!devpriv->ai_do)
+		return IRQ_HANDLED;
+
+	if (devpriv->ai12_startstop) {
+		if ((adstat & AdStatus_DTH) && (intsrc & Int_DTrg)) {
+			/* start/stop of measure */
+			if (devpriv->ai12_startstop & START_AI_EXT) {
+				/* deactivate EXT trigger */
+				devpriv->ai12_startstop &= ~START_AI_EXT;
+				if (!(devpriv->ai12_startstop & STOP_AI_EXT))
+					pci9118_exttrg_del(dev, EXTTRG_AI);
+
+				/* start pacer */
+				start_pacer(dev, devpriv->ai_do,
+					    devpriv->ai_divisor1,
+					    devpriv->ai_divisor2);
+				outl(devpriv->AdControlReg,
+				     dev->iobase + PCI9118_ADCNTRL);
+			} else if (devpriv->ai12_startstop & STOP_AI_EXT) {
+				/* deactivate EXT trigger */
+				devpriv->ai12_startstop &= ~STOP_AI_EXT;
+				pci9118_exttrg_del(dev, EXTTRG_AI);
+
+				/* on next interrupt measure will stop */
+				devpriv->ai_neverending = 0;
 			}
 		}
+	}
 
-		if (devpriv->usedma)
-			interrupt_pci9118_ai_dma(dev, s, int_adstat,
-						 int_amcc, int_daq);
-		else
-			interrupt_pci9118_ai_onesample(dev, s, int_adstat,
-						       int_amcc, int_daq);
+	if (devpriv->usedma)
+		interrupt_pci9118_ai_dma(dev, s, adstat, intcsr, intsrc);
+	else
+		interrupt_pci9118_ai_onesample(dev, s, adstat, intcsr, intsrc);
 
-	}
 	return IRQ_HANDLED;
 }
 
@@ -1945,7 +1932,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 				/* Enable parity check for parity error */
 
 	if (!disable_irq && pcidev->irq) {
-		ret = request_irq(pcidev->irq, interrupt_pci9118, IRQF_SHARED,
+		ret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
 		if (ret == 0)
 			dev->irq = pcidev->irq;

commit 901be534fc8b8d7dcafa5af439df705aad31de93
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:44 2014 -0700

    staging: comedi: adl_pci9118: remove 'int_ai_func' from private data
    
    The devpriv->usedma flag can be checked to determine which handler
    function should be used to transfer the analog input data. Do that
    instead and remove the member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0e9fc0de8c5a..358f09c64629 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -369,13 +369,6 @@ struct pci9118_private {
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
 						 */
 	unsigned int cnt0_divisor;		/* actual CNT0 divisor */
-	void (*int_ai_func)(struct comedi_device *, struct comedi_subdevice *,
-		unsigned short,
-		unsigned int,
-		unsigned short);	/*
-					 * ptr to actual interrupt
-					 * AI function
-					 */
 	unsigned char usedma;		/* =1 use DMA transfer and not INT */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
@@ -1040,6 +1033,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 static irqreturn_t interrupt_pci9118(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct comedi_subdevice *s = dev->read_subdev;
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
@@ -1061,7 +1055,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 					/* get STATUS register */
 
 	if (devpriv->ai_do) {
-		if (devpriv->ai12_startstop)
+		if (devpriv->ai12_startstop) {
 			if ((int_adstat & AdStatus_DTH) &&
 							(int_daq & Int_DTrg)) {
 						/* start stop of measure */
@@ -1095,9 +1089,14 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 					}
 				}
 			}
+		}
 
-		(devpriv->int_ai_func) (dev, dev->read_subdev, int_adstat,
-					int_amcc, int_daq);
+		if (devpriv->usedma)
+			interrupt_pci9118_ai_dma(dev, s, int_adstat,
+						 int_amcc, int_daq);
+		else
+			interrupt_pci9118_ai_onesample(dev, s, int_adstat,
+						       int_amcc, int_daq);
 
 	}
 	return IRQ_HANDLED;
@@ -1472,9 +1471,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;
-						/* transfer function */
-
 	if (devpriv->ai12_startstop)
 		pci9118_exttrg_add(dev, EXTTRG_AI);
 						/* activate EXT trigger */
@@ -1553,9 +1549,6 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 						/* activate EXT trigger */
 	}
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_dma;
-						/* transfer function */
-
 	outl(0x02000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 

commit 1fb2082df601fc1800ce3f16d9454f6847356c64
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:43 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai16bits' from private data
    
    This member of the private data is only set when the analog input
    subdevice maxdata is 0xffff. Just check the s->maxdata and remove
    the private data member.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 394337e05617..0e9fc0de8c5a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -376,7 +376,6 @@ struct pci9118_private {
 					 * ptr to actual interrupt
 					 * AI function
 					 */
-	unsigned char ai16bits;		/* =1 16 bit card */
 	unsigned char usedma;		/* =1 use DMA transfer and not INT */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
@@ -586,7 +585,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 			return ret;
 		}
 
-		if (devpriv->ai16bits) {
+		if (s->maxdata == 0xffff) {
 			data[n] =
 			    (inl(dev->iobase +
 				 PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
@@ -908,7 +907,7 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)
 			array[i] = be16_to_cpu(array[i]);
-		if (devpriv->ai16bits)
+		if (s->maxdata == 0xffff)
 			array[i] ^= 0x8000;
 		else
 			array[i] = (array[i] >> 4) & 0x0fff;
@@ -933,7 +932,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	sampl = inw(dev->iobase + PCI9118_AD_DATA);
 
 #ifdef PCI9118_PARANOIDCHECK
-	if (devpriv->ai16bits == 0) {
+	if (s->maxdata != 0xffff) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {
 							/* data dropout! */
 			dev_info(dev->class_dev,
@@ -2017,15 +2016,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	if (hw_err_mask)		/* disable some requested */
 		devpriv->ai_maskharderr &= ~hw_err_mask;
 
-	switch (this_board->ai_maxdata) {
-	case 0xffff:
-		devpriv->ai16bits = 1;
-		break;
-	default:
-		devpriv->ai16bits = 0;
-		break;
-	}
-
 	return 0;
 }
 

commit 4029bd3dad217bbf5b37ed3b2cb0c0d0005a2097
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:42 2014 -0700

    staging: comedi: adl_pci9118: remove 'useeoshandle' from private data
    
    This member of the private data is always set to 0. Remove it and the
    affected code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 8814b060407b..394337e05617 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -378,10 +378,6 @@ struct pci9118_private {
 					 */
 	unsigned char ai16bits;		/* =1 16 bit card */
 	unsigned char usedma;		/* =1 use DMA transfer and not INT */
-	unsigned char useeoshandle;	/*
-					 * =1 change WAKE_EOS DMA transfer
-					 * to fit on every second
-					 */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
 					 * numer is requested delay in ns
@@ -452,7 +448,7 @@ static int check_channel_list(struct comedi_device *dev,
 static int setup_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int rot, int frontadd,
-			      int backadd, int usedma, char useeos)
+			      int backadd, int usedma)
 {
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, differencial = 0, bipolar = 0;
@@ -536,18 +532,6 @@ static int setup_channel_list(struct comedi_device *dev,
 #ifdef PCI9118_PARANOIDCHECK
 	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
 						/* for 32bit operations */
-	if (useeos) {
-		for (i = 1; i < n_chan; i++) {	/* store range list to card */
-			devpriv->chanlist[(n_chan + i) ^ usedma] =
-			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
-		}
-		devpriv->chanlist[(2 * n_chan) ^ usedma] =
-						devpriv->chanlist[0 ^ usedma];
-						/* for 32bit operations */
-		useeos = 2;
-	} else {
-		useeos = 1;
-	}
 #endif
 	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
 	/* udelay(100); important delay, or first sample will be crippled */
@@ -587,7 +571,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 						 * trigger stop
 						 */
 
-	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))
+	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0))
 		return -EINVAL;
 
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
@@ -1353,8 +1337,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 		} else {
 			/* short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
-			if (devpriv->useeoshandle)
-				dmalen0 += 2;
 			if (dmalen0 < 4) {
 				dev_info(dev->class_dev,
 					 "ERR: DMA0 buf len bug? (%d<4)\n",
@@ -1373,8 +1355,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 		} else {
 			/* short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
-			if (devpriv->useeoshandle)
-				dmalen1 -= 2;
 			if (dmalen1 < 4) {
 				dev_info(dev->class_dev,
 					 "ERR: DMA1 buf len bug? (%d<4)\n",
@@ -1630,7 +1610,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 */
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
-	devpriv->useeoshandle = 0;
 	if (devpriv->master) {
 		devpriv->usedma = 1;
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
@@ -1649,10 +1628,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		    (cmd->scan_end_arg & 1) &&
 		    (cmd->scan_end_arg > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
-				/*
-				 * vpriv->useeoshandle=1; // change DMA transfer
-				 * block to fit EOS on every second call
-				 */
 				devpriv->usedma = 0;
 				/*
 				 * XXX maybe can be corrected to use 16 bit DMA
@@ -1711,8 +1686,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EINVAL;
 	if (!setup_channel_list(dev, s, cmd->chanlist_len,
 				cmd->chanlist, 0, devpriv->ai_add_front,
-				devpriv->ai_add_back, devpriv->usedma,
-				devpriv->useeoshandle))
+				devpriv->ai_add_back, devpriv->usedma))
 		return -EINVAL;
 
 	/* compute timers settings */

commit ad7a6230a98728e70b23559aa5e64d1ad6233d83
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:41 2014 -0700

    staging: comedi: adl_pci9118: remove 'cnt0_users' from private data
    
    This member of the private data is set to 0 but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f60dc41756e2..8814b060407b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -364,10 +364,6 @@ struct pci9118_private {
 	unsigned int dmabuf_panic_size[2];
 	unsigned int dmabuf_samples[2];		/* size in samples */
 	int dmabuf_pages[2];			/* number of pages in buffer */
-	unsigned char cnt0_users;		/*
-						 * bit field of 8254 CNT0 users
-						 * (0-unused, 1-AO, 2-DI, 3-DO)
-						 */
 	unsigned char exttrg_users;		/*
 						 * bit field of external trigger
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
@@ -1857,7 +1853,6 @@ static int pci9118_reset(struct comedi_device *dev)
 						 * disable INT and DMA
 						 */
 
-	devpriv->cnt0_users = 0;
 	devpriv->exttrg_users = 0;
 
 	return 0;

commit 49b61195e5b5fd7884a3bddab43a2e53983988c7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:40 2014 -0700

    staging: comedi: adl_pci9118: remove 'valid' from private data
    
    This member of the private data is set only used during the (*detach)
    to check if the board can be reset. The pci9118_reset() function just
    needs a valid dev->iobase. Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dd1cd6be66ec..f60dc41756e2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -320,7 +320,6 @@ struct pci9118_private {
 	unsigned char AdControlReg;	/* A/D control register */
 	unsigned char IntControlReg;	/* Interrupt control register */
 	unsigned char AdFunctionReg;	/* A/D function register */
-	char valid;			/* driver is ok */
 	char ai_neverending;		/* we do unlimited AI */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
@@ -2044,7 +2043,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->range_table = &range_digital;
 	s->insn_bits = pci9118_insn_bits_do;
 
-	devpriv->valid = 1;
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */
 	if (hw_err_mask)		/* disable some requested */
@@ -2121,7 +2119,7 @@ static void pci9118_detach(struct comedi_device *dev)
 	struct pci9118_private *devpriv = dev->private;
 
 	if (devpriv) {
-		if (devpriv->valid)
+		if (dev->iobase)
 			pci9118_reset(dev);
 		if (dev->irq)
 			free_irq(dev->irq, dev);

commit b8546f93d9026ecfe334b31587572e7d24bac39c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:39 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_buf_ptr' from private data
    
    This member of the private data is set to 0 but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 89e6b9277250..dd1cd6be66ec 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -324,7 +324,6 @@ struct pci9118_private {
 	char ai_neverending;		/* we do unlimited AI */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
-	unsigned int ai_buf_ptr;	/* data buffer ptr in samples */
 	unsigned int ai_n_realscanlen;	/*
 					 * what we must transfer for one
 					 * outgoing scan include front/back adds
@@ -875,7 +874,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	devpriv->ai_act_dmapos = 0;
 	s->async->cur_chan = 0;
 	s->async->inttrig = NULL;
-	devpriv->ai_buf_ptr = 0;
 	devpriv->ai_neverending = 0;
 	devpriv->dma_actbuf = 0;
 
@@ -1797,7 +1795,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_act_scan = 0;
 	devpriv->ai_act_dmapos = 0;
 	s->async->cur_chan = 0;
-	devpriv->ai_buf_ptr = 0;
 
 	if (devpriv->usedma)
 		ret = pci9118_ai_docmd_dma(dev, s);

commit 681a89b3e0c0b966eeda481503c658e051604d17
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:38 2014 -0700

    staging: comedi: adl_pci9118: cmd->stop_src == TRIG_INT is not supported
    
    The (*do_cmdtest) only allows TRIG_COUNT, TRIG_NONE, or TRIG_EXT as the
    cmd->stop_src. Remove the disabled code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 60cc41a7a43a..89e6b9277250 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1626,12 +1626,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai12_startstop |= START_AI_INT;
 		s->async->inttrig = pci9118_ai_inttrig;
 	}
-#if 0
-	if (cmd->stop_src == TRIG_INT) {
-		devpriv->ai_neverending = 1;
-		devpriv->ai12_startstop |= STOP_AI_INT;
-	}
-#endif
 	if (cmd->stop_src == TRIG_NONE)
 		devpriv->ai_neverending = 1;
 	if (cmd->stop_src == TRIG_COUNT)

commit f3f15e54ac48b6f68f05973164abc824c4f7dfcf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:37 2014 -0700

    staging: comedi: adl_pci9118: remove 'usessh' from private data
    
    This member of the private data is only set when the cmd->convert_src
    is TRIG_NOW. Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index bfcd90c4b1f8..60cc41a7a43a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -388,7 +388,6 @@ struct pci9118_private {
 					 * =1 change WAKE_EOS DMA transfer
 					 * to fit on every second
 					 */
-	unsigned char usessh;		/* =1 turn on S&H support */
 	int softsshdelay;		/*
 					 * >0 use software S&H,
 					 * numer is requested delay in ns
@@ -784,9 +783,10 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int *tim1, unsigned int *tim2,
 				  unsigned int flags, int chans,
 				  unsigned int *div1, unsigned int *div2,
-				  char usessh, unsigned int chnsshfront)
+				  unsigned int chnsshfront)
 {
 	const struct boardtype *this_board = comedi_board(dev);
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	switch (mode) {
 	case 1:
@@ -811,9 +811,11 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 
 		*tim2 = *div1 * I8254_OSC_BASE_4MHZ;	/* real convert timer */
 
-		if (usessh && (chnsshfront == 0))	/* use BSSH signal */
+		if (cmd->convert_src == TRIG_NOW && !chnsshfront) {
+			/* use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
+		}
 
 		*tim1 = *div1 * *div2 * I8254_OSC_BASE_4MHZ;
 		break;
@@ -1532,6 +1534,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	Compute_and_setup_dma(dev, s);
 
@@ -1546,7 +1549,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		devpriv->AdFunctionReg =
 		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
 		    AdFunction_BS;
-		if (devpriv->usessh && (!devpriv->softsshdelay))
+		if (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)
 			devpriv->AdFunctionReg |= AdFunction_BSSH;
 		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
 		break;
@@ -1634,14 +1637,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_neverending = 0;
 
-	/* use sample&hold signal? */
-	if (cmd->convert_src == TRIG_NOW)
-		devpriv->usessh = 1;
-	/* yes */
-	else
-		devpriv->usessh = 0;
-				/*  no */
-
 	/*
 	 * use additional sample at end of every scan
 	 * to satisty DMA 32 bit transfer?
@@ -1690,7 +1685,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	 * we need software S&H signal?
 	 * It adds two samples before every scan as minimum
 	 */
-	if (devpriv->usessh && devpriv->softsshdelay) {
+	if (cmd->convert_src == TRIG_NOW && devpriv->softsshdelay) {
 		devpriv->ai_add_front = 2;
 		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {
 							/* move it to front */
@@ -1752,7 +1747,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      devpriv->ai_flags,
 				      devpriv->ai_n_realscanlen,
 				      &devpriv->ai_divisor1,
-				      &devpriv->ai_divisor2, devpriv->usessh,
+				      &devpriv->ai_divisor2,
 				      devpriv->ai_add_front);
 	}
 
@@ -1773,7 +1768,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      devpriv->ai_flags,
 				      devpriv->ai_n_realscanlen,
 				      &devpriv->ai_divisor1,
-				      &devpriv->ai_divisor2, devpriv->usessh,
+				      &devpriv->ai_divisor2,
 				      devpriv->ai_add_front);
 	}
 

commit 80ffd625f327066e2649e632cb9f13455042e551
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:36 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_scans' from private data
    
    This member of the private data is just a copy of the cmd->stop_arg.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ae8afc7788d9..bfcd90c4b1f8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -348,7 +348,6 @@ struct pci9118_private {
 						 * on external start
 						 */
 	unsigned short ao_data[2];		/* data output buffer */
-	unsigned int ai_scans;			/* number of scans to do */
 	char dma_doublebuf;			/* we can use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	unsigned short *dmabuf_virt[2];		/*
@@ -976,7 +975,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 		devpriv->ai_act_scan++;
 		if (!devpriv->ai_neverending) {
 			/* all data sampled? */
-			if (devpriv->ai_act_scan >= devpriv->ai_scans)
+			if (devpriv->ai_act_scan >= cmd->stop_arg)
 				s->async->events |= COMEDI_CB_EOA;
 		}
 	}
@@ -991,6 +990,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 				     unsigned short int_daq)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
 	if (int_amcc & MASTER_ABORT_INT) {
@@ -1041,7 +1041,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 
 	if (!devpriv->ai_neverending) {
 		/* all data sampled? */
-		if (devpriv->ai_act_scan >= devpriv->ai_scans)
+		if (devpriv->ai_act_scan >= cmd->stop_arg)
 			s->async->events |= COMEDI_CB_EOA;
 	}
 
@@ -1332,6 +1332,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int dmalen0, dmalen1, i;
 
 	dmalen0 = devpriv->dmabuf_size[0];
@@ -1413,10 +1414,10 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 			/* fits whole measure into one DMA buffer? */
 			if (dmalen0 >
 			    ((devpriv->ai_n_realscanlen << 1) *
-			     devpriv->ai_scans)) {
+			     cmd->stop_arg)) {
 				dmalen0 =
 				    (devpriv->ai_n_realscanlen << 1) *
-				    devpriv->ai_scans;
+				    cmd->stop_arg;
 				dmalen0 &= ~3L;
 			} else {	/*
 					 * fits whole measure into
@@ -1424,10 +1425,10 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 					 */
 				if (dmalen1 >
 				    ((devpriv->ai_n_realscanlen << 1) *
-				     devpriv->ai_scans - dmalen0))
+				     cmd->stop_arg - dmalen0))
 					dmalen1 =
 					    (devpriv->ai_n_realscanlen << 1) *
-					    devpriv->ai_scans - dmalen0;
+					    cmd->stop_arg - dmalen0;
 				dmalen1 &= ~3L;
 			}
 		}
@@ -1630,12 +1631,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 #endif
 	if (cmd->stop_src == TRIG_NONE)
 		devpriv->ai_neverending = 1;
-	if (cmd->stop_src == TRIG_COUNT) {
-		devpriv->ai_scans = cmd->stop_arg;
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ai_neverending = 0;
-	} else {
-		devpriv->ai_scans = 0;
-	}
 
 	/* use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW)

commit 1b27a4369ba9804ad87d2160d9a76e23a484d4de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:35 2014 -0700

    staging: comedi: adl_pci9118: remove 'i8254_osc_base' from private data
    
    This member of the private data is always set to I8254_OSC_BASE_4MHZ.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index bdb1ed357adc..ae8afc7788d9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -322,7 +322,6 @@ struct pci9118_private {
 	unsigned char AdFunctionReg;	/* A/D function register */
 	char valid;			/* driver is ok */
 	char ai_neverending;		/* we do unlimited AI */
-	unsigned int i8254_osc_base;	/* frequence of onboard oscilator */
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
 	unsigned int ai_buf_ptr;	/* data buffer ptr in samples */
@@ -789,37 +788,35 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  char usessh, unsigned int chnsshfront)
 {
 	const struct boardtype *this_board = comedi_board(dev);
-	struct pci9118_private *devpriv = dev->private;
 
 	switch (mode) {
 	case 1:
 	case 4:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  div1, div2,
 					  tim2, flags & TRIG_ROUND_NEAREST);
 		break;
 	case 2:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
-		*div1 = *tim2 / devpriv->i8254_osc_base;
+		*div1 = *tim2 / I8254_OSC_BASE_4MHZ;
 						/* convert timer (burst) */
 		if (*div1 < this_board->ai_pacer_min)
 			*div1 = this_board->ai_pacer_min;
-		*div2 = *tim1 / devpriv->i8254_osc_base;	/* scan timer */
+		*div2 = *tim1 / I8254_OSC_BASE_4MHZ;	/* scan timer */
 		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
 		if (*div2 < chans)
 			*div2 = chans;
 
-		*tim2 = *div1 * devpriv->i8254_osc_base;
-							/* real convert timer */
+		*tim2 = *div1 * I8254_OSC_BASE_4MHZ;	/* real convert timer */
 
 		if (usessh && (chnsshfront == 0))	/* use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 
-		*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;
+		*tim1 = *div1 * *div2 * I8254_OSC_BASE_4MHZ;
 		break;
 	}
 }
@@ -1279,7 +1276,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  &divisor1, &divisor2,
 					  &cmd->scan_begin_arg, cmd->flags);
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
@@ -1290,7 +1287,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_4MHZ,
 					  &divisor1, &divisor2,
 					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < this_board->ai_ns_min)
@@ -2065,7 +2062,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;
-	devpriv->i8254_osc_base = I8254_OSC_BASE_4MHZ;
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */
 	if (hw_err_mask)		/* disable some requested */

commit dab18a96483d9f07d06948a181173e5517ed3afa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:34 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_n_scanlen' from private data
    
    This member of the private data is just a copy of the cmd->scan_end_arg.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index da1ae75e3482..bdb1ed357adc 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -326,7 +326,6 @@ struct pci9118_private {
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
 	unsigned int ai_buf_ptr;	/* data buffer ptr in samples */
-	unsigned int ai_n_scanlen;	/* len of actual scanlist */
 	unsigned int ai_n_realscanlen;	/*
 					 * what we must transfer for one
 					 * outgoing scan include front/back adds
@@ -732,13 +731,14 @@ static int move_block_from_dma(struct comedi_device *dev,
 					unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
 	devpriv->ai_act_scan +=
-	    (s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
+	    (s->async->cur_chan + num_samples) / cmd->scan_end_arg;
 	s->async->cur_chan += num_samples;
-	s->async->cur_chan %= devpriv->ai_n_scanlen;
+	s->async->cur_chan %= cmd->scan_end_arg;
 	num_bytes =
 	    cfc_write_array_to_buffer(s, dma_buffer,
 				      num_samples * sizeof(short));
@@ -948,6 +948,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 					   unsigned short int_daq)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short sampl;
 
 	if (int_adstat & devpriv->ai_maskerr)
@@ -972,9 +973,9 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 #endif
 	cfc_write_to_buffer(s, sampl);
 	s->async->cur_chan++;
-	if (s->async->cur_chan >= devpriv->ai_n_scanlen) {
+	if (s->async->cur_chan >= cmd->scan_end_arg) {
 							/* one scan done */
-		s->async->cur_chan %= devpriv->ai_n_scanlen;
+		s->async->cur_chan %= cmd->scan_end_arg;
 		devpriv->ai_act_scan++;
 		if (!devpriv->ai_neverending) {
 			/* all data sampled? */
@@ -1441,18 +1442,18 @@ static int Compute_and_setup_dma(struct comedi_device *dev,
 	devpriv->dmabuf_use_size[1] = dmalen1;
 
 #if 0
-	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
+	if (cmd->scan_end_arg < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =
-		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
-		     1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / cmd->scan_end_arg +
+		     1) * cmd->scan_end_arg * sizeof(short);
 		devpriv->dmabuf_panic_size[1] =
-		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
-		     1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / cmd->scan_end_arg +
+		     1) * cmd->scan_end_arg * sizeof(short);
 	} else {
 		devpriv->dmabuf_panic_size[0] =
-		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
+		    (cmd->scan_end_arg << 1) % devpriv->dmabuf_size[0];
 		devpriv->dmabuf_panic_size[1] =
-		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
+		    (cmd->scan_end_arg << 1) % devpriv->dmabuf_size[1];
 	}
 #endif
 
@@ -1609,7 +1610,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
-	devpriv->ai_n_scanlen = cmd->scan_end_arg;
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
 	devpriv->ai_maskerr = 0x10e;
@@ -1658,7 +1658,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->master) {
 		devpriv->usedma = 1;
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-		    (devpriv->ai_n_scanlen == 1)) {
+		    (cmd->scan_end_arg == 1)) {
 			if (cmd->convert_src == TRIG_NOW)
 				devpriv->ai_add_back = 1;
 			if (cmd->convert_src == TRIG_TIMER) {
@@ -1670,8 +1670,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-		    (devpriv->ai_n_scanlen & 1) &&
-		    (devpriv->ai_n_scanlen > 1)) {
+		    (cmd->scan_end_arg & 1) &&
+		    (cmd->scan_end_arg > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
 				/*
 				 * vpriv->useeoshandle=1; // change DMA transfer
@@ -1722,10 +1722,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* well, we now know what must be all added */
 	devpriv->ai_n_realscanlen =	/*
 					 * what we must take from card in real
-					 * to have ai_n_scanlen on output?
+					 * to have cmd->scan_end_arg on output?
 					 */
 	    (devpriv->ai_add_front + cmd->chanlist_len +
-	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
+	     devpriv->ai_add_back) * (cmd->scan_end_arg /
 				      cmd->chanlist_len);
 
 	/* check and setup channel list */

commit f398b0ea67cc81601b2c0cfcf3471dfd3811ccd3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:33 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_timer2' from private data
    
    This member of the private data is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b30d3e83b892..da1ae75e3482 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -340,7 +340,6 @@ struct pci9118_private {
 					 * how many channels we must add
 					 * before scan to satisfy DMA?
 					 */
-	unsigned int ai_timer2;
 	unsigned int ai_flags;
 	char ai12_startstop;		/*
 					 * measure can start/stop
@@ -1611,7 +1610,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
-	devpriv->ai_timer2 = 0;
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
 	devpriv->ai_maskerr = 0x10e;
@@ -1762,7 +1760,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      &devpriv->ai_divisor1,
 				      &devpriv->ai_divisor2, devpriv->usessh,
 				      devpriv->ai_add_front);
-		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
@@ -1784,7 +1781,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      &devpriv->ai_divisor1,
 				      &devpriv->ai_divisor2, devpriv->usessh,
 				      devpriv->ai_add_front);
-		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW)

commit c8d4bd1b23ccafdca24ae65734aab2f06d840e2d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:32 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_timer1' from private data
    
    This member of the private data is set but never used. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 94ede354b4fa..b30d3e83b892 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -340,7 +340,6 @@ struct pci9118_private {
 					 * how many channels we must add
 					 * before scan to satisfy DMA?
 					 */
-	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
 	char ai12_startstop;		/*
@@ -1612,7 +1611,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
-	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
@@ -1786,7 +1784,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				      &devpriv->ai_divisor1,
 				      &devpriv->ai_divisor2, devpriv->usessh,
 				      devpriv->ai_add_front);
-		devpriv->ai_timer1 = cmd->scan_begin_arg;
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 

commit cc06e2413114d21045f30545fde573583b8fb024
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:31 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_data_len' from private data
    
    This member of the private data is just a copy of the s->async->prealloc_bufsz.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cc56da4fe857..94ede354b4fa 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -351,7 +351,6 @@ struct pci9118_private {
 						 * divisors for start of measure
 						 * on external start
 						 */
-	unsigned int ai_data_len;
 	unsigned short ao_data[2];		/* data output buffer */
 	unsigned int ai_scans;			/* number of scans to do */
 	char dma_doublebuf;			/* we can use double buffering */
@@ -1035,10 +1034,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	}
 
 	if (samplesinbuf) {
-		m = devpriv->ai_data_len >> 1;	/*
-						 * how many samples is to
-						 * end of buffer
-						 */
+		/* how many samples is to end of buffer */
+		m = s->async->prealloc_bufsz >> 1;
 		sampls = m;
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
@@ -1335,7 +1332,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static int Compute_and_setup_dma(struct comedi_device *dev)
+static int Compute_and_setup_dma(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int dmalen0, dmalen1, i;
@@ -1343,15 +1341,13 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	dmalen0 = devpriv->dmabuf_size[0];
 	dmalen1 = devpriv->dmabuf_size[1];
 	/* isn't output buff smaller that our DMA buff? */
-	if (dmalen0 > (devpriv->ai_data_len)) {
-		dmalen0 = devpriv->ai_data_len & ~3L;	/*
-							 * align to 32bit down
-							 */
+	if (dmalen0 > s->async->prealloc_bufsz) {
+		/* align to 32bit down */
+		dmalen0 = s->async->prealloc_bufsz & ~3L;
 	}
-	if (dmalen1 > (devpriv->ai_data_len)) {
-		dmalen1 = devpriv->ai_data_len & ~3L;	/*
-							 * align to 32bit down
-							 */
+	if (dmalen1 > s->async->prealloc_bufsz) {
+		/* align to 32bit down */
+		dmalen1 = s->async->prealloc_bufsz & ~3L;
 	}
 
 	/* we want wake up every scan? */
@@ -1540,7 +1536,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	Compute_and_setup_dma(dev);
+	Compute_and_setup_dma(dev, s);
 
 	switch (devpriv->ai_do) {
 	case 1:
@@ -1616,7 +1612,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
-	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
 	devpriv->ai_add_front = 0;

commit b1869854f477e6d4c96cf1fc753f0e6b6fbbe21d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:30 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_chanlist' from private data
    
    This member of the private data is just a copy of the cmd->chanlist.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6b64484c6ced..cc56da4fe857 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -340,7 +340,6 @@ struct pci9118_private {
 					 * how many channels we must add
 					 * before scan to satisfy DMA?
 					 */
-	unsigned int *ai_chanlist;	/* actual chanlist */
 	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
@@ -1617,7 +1616,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
-	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
@@ -1741,11 +1739,11 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* check and setup channel list */
 	if (!check_channel_list(dev, s, cmd->chanlist_len,
-				devpriv->ai_chanlist, devpriv->ai_add_front,
+				cmd->chanlist, devpriv->ai_add_front,
 				devpriv->ai_add_back))
 		return -EINVAL;
 	if (!setup_channel_list(dev, s, cmd->chanlist_len,
-				devpriv->ai_chanlist, 0, devpriv->ai_add_front,
+				cmd->chanlist, 0, devpriv->ai_add_front,
 				devpriv->ai_add_back, devpriv->usedma,
 				devpriv->useeoshandle))
 		return -EINVAL;

commit 0642d08045aafe4f0bbef129e65264cc60502faa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 5 09:35:29 2014 -0700

    staging: comedi: adl_pci9118: remove 'ai_n_chan' from private data
    
    This member of the private data is just a copy of the cmd->chanlist_len.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4be5f67cf14a..6b64484c6ced 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -326,7 +326,6 @@ struct pci9118_private {
 	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
 	unsigned int ai_act_scan;	/* how many scans we finished */
 	unsigned int ai_buf_ptr;	/* data buffer ptr in samples */
-	unsigned int ai_n_chan;		/* how many channels is measured */
 	unsigned int ai_n_scanlen;	/* len of actual scanlist */
 	unsigned int ai_n_realscanlen;	/*
 					 * what we must transfer for one
@@ -712,10 +711,11 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 					  unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
-	    stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
-	unsigned int raw_scanlen = devpriv->ai_add_front + devpriv->ai_n_chan +
+	    stop_pos = devpriv->ai_add_front + cmd->chanlist_len;
+	unsigned int raw_scanlen = devpriv->ai_add_front + cmd->chanlist_len +
 	    devpriv->ai_add_back;
 
 	for (i = 0; i < num_samples; i++) {
@@ -1616,7 +1616,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
-	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
 	devpriv->ai_chanlist = cmd->chanlist;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
@@ -1725,7 +1724,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
-				     devpriv->ai_n_chan +
+				     cmd->chanlist_len +
 				     devpriv->ai_add_back) & 1)
 					devpriv->ai_add_front++;
 							/* round up to 32 bit */
@@ -1736,16 +1735,16 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 					 * what we must take from card in real
 					 * to have ai_n_scanlen on output?
 					 */
-	    (devpriv->ai_add_front + devpriv->ai_n_chan +
+	    (devpriv->ai_add_front + cmd->chanlist_len +
 	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
-				      devpriv->ai_n_chan);
+				      cmd->chanlist_len);
 
 	/* check and setup channel list */
-	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
+	if (!check_channel_list(dev, s, cmd->chanlist_len,
 				devpriv->ai_chanlist, devpriv->ai_add_front,
 				devpriv->ai_add_back))
 		return -EINVAL;
-	if (!setup_channel_list(dev, s, devpriv->ai_n_chan,
+	if (!setup_channel_list(dev, s, cmd->chanlist_len,
 				devpriv->ai_chanlist, 0, devpriv->ai_add_front,
 				devpriv->ai_add_back, devpriv->usedma,
 				devpriv->useeoshandle))

commit 01dc2a05f46280f825378be0bee8a2f13ca12c0a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:52 2014 -0700

    staging: comedi: adl_pci9118: fix the ai cmd->start_arg validation and use
    
    This driver supports three cmd->start_src values, TRIG_NOW, TRIG_EXT, and
    TRIG_INT. TRIG_NOW sources should always have an arg of 0 and arg for TRIG_EXT
    sources is driver specific. This driver does not use the cmd->start_arg with
    the TRIG_EXT source so a trivial value of 0 is good.
    
    When the cmd->start_src is TRIG_INT the cmd->start_arg is actually the valid
    trig_num that is passed to the async (*inttrig) callback. This driver allows
    any value to be used and currently carries that value in the private data.
    
    Refactor the (*do_cmdtest) so that the trivial validation of the cmd->start_arg
    is clear.
    
    Refactor the (*inttrig) so that the cmd->start_arg is used directly to check
    the trig_num and remove the then unused 'ai_inttrig_start' member from the
    private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 53bbc59f6176..4be5f67cf14a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -411,7 +411,6 @@ struct pci9118_private {
 					 */
 	unsigned int ai_maskerr;	/* which warning was printed */
 	unsigned int ai_maskharderr;	/* on which error bits stops */
-	unsigned int ai_inttrig_start;	/* TRIG_INT for start */
 };
 
 static int check_channel_list(struct comedi_device *dev,
@@ -1135,11 +1134,13 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 }
 
 static int pci9118_ai_inttrig(struct comedi_device *dev,
-			      struct comedi_subdevice *s, unsigned int trignum)
+			      struct comedi_subdevice *s,
+			      unsigned int trig_num)
 {
 	struct pci9118_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (trignum != devpriv->ai_inttrig_start)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	devpriv->ai12_startstop &= ~START_AI_INT;
@@ -1221,8 +1222,15 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src & (TRIG_NOW | TRIG_EXT))
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+	case TRIG_EXT:
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_INT:
+		/* start_arg is the internal trigger (any value) */
+		break;
+	}
 
 	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
@@ -1627,7 +1635,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 	if (cmd->start_src == TRIG_INT) {
 		devpriv->ai12_startstop |= START_AI_INT;
-		devpriv->ai_inttrig_start = cmd->start_arg;
 		s->async->inttrig = pci9118_ai_inttrig;
 	}
 #if 0

commit 860b7c398a744c1eef42a59b661e870aca12d9be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:46 2014 -0700

    staging: comedi: drivers: core validates chanlist_len max
    
    The comedi core checks if the (cmd->chanlist_len > s->len_chanlist) when the
    comedi_cmd is copied from user to kernel space by __comedi_get_user_cmd().
    If so, the core returns -EINVAL and will not call the subdevice (*do_cmdtest)
    and (*do_cmd).
    
    Remove the unnecessary "max" checks in the comedi driver (*do_cmdtest) and
    helper functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b6abef6ceab7..53bbc59f6176 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1259,8 +1259,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_max(&cmd->chanlist_len,
-					 this_board->n_aichanlist);
 
 	err |= cfc_check_trigger_arg_min(&cmd->scan_end_arg,
 					 cmd->chanlist_len);

commit 110775bd5dbc811ab4d55f7498a57ef96994dbde
Author: Richard Leitner <me@g0hl1n.net>
Date:   Wed Apr 9 18:27:13 2014 +0200

    staging: comedi: adl_pci9118: fix whitespace issues
    
    Removed not needed spaces and fixed too long lines
    
    Signed-off-by: Richard Leitner <me@g0hl1n.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3cfa1756fa6a..b6abef6ceab7 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -96,7 +96,7 @@ Configuration options:
 				 * correct channel number on every 12 bit sample
 				 */
 
-#define IORANGE_9118 	64	/* I hope */
+#define IORANGE_9118	64	/* I hope */
 #define PCI9118_CHANLEN	255	/*
 				 * len of chanlist, some source say 256,
 				 * but reality looks like 255 :-(
@@ -383,7 +383,7 @@ struct pci9118_private {
 						 * users(0-AI, 1-AO, 2-DI, 3-DO)
 						 */
 	unsigned int cnt0_divisor;		/* actual CNT0 divisor */
-	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *,
+	void (*int_ai_func)(struct comedi_device *, struct comedi_subdevice *,
 		unsigned short,
 		unsigned int,
 		unsigned short);	/*
@@ -1045,7 +1045,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
 				    samplesinbuf);
-		m = m - sampls;		/* m= how many samples was transferred */
+		m = m - sampls;		/* m=how many samples was transferred */
 	}
 
 	if (!devpriv->ai_neverending) {

commit 52037a0d520e988e3287b28bc767b58ddc66ad94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:46 2014 -0700

    staging: comedi: drivers should not clear the async->events
    
    The comedi core resets the async->events in comedi_buf_reset() which is
    called when the subdevice is restored to an idle state and at the start
    of an async command. The async->events are also cleared after handling
    the events in comedi_event().
    
    Drivers should not clear the events manually.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 980ce495c8d0..3cfa1756fa6a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -955,8 +955,6 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	struct pci9118_private *devpriv = dev->private;
 	unsigned short sampl;
 
-	s->async->events = 0;
-
 	if (int_adstat & devpriv->ai_maskerr)
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;

commit def69d7f8228625626936dd9b75566a1566d7f9f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:27 2014 -0700

    staging: comedi: adl_pci9118: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    In the Kconfig, COMEDI_ADL_PCI9118 already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6ca6c429c722..980ce495c8d0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -919,8 +919,7 @@ static char pci9118_decode_error_status(struct comedi_device *dev,
 	}
 	if (m & devpriv->ai_maskharderr) {
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		pci9118_ai_cancel(dev, s);
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		return 1;
 	}
 
@@ -973,8 +972,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 				 sampl & 0x000f,
 				 devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-			pci9118_ai_cancel(dev, s);
-			comedi_event(dev, s);
+			cfc_handle_events(dev, s);
 			return;
 		}
 	}
@@ -985,16 +983,14 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 							/* one scan done */
 		s->async->cur_chan %= devpriv->ai_n_scanlen;
 		devpriv->ai_act_scan++;
-		if (!(devpriv->ai_neverending))
-			if (devpriv->ai_act_scan >= devpriv->ai_scans) {
-							/* all data sampled */
-				pci9118_ai_cancel(dev, s);
+		if (!devpriv->ai_neverending) {
+			/* all data sampled? */
+			if (devpriv->ai_act_scan >= devpriv->ai_scans)
 				s->async->events |= COMEDI_CB_EOA;
-			}
+		}
 	}
 
-	if (s->async->events)
-		comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
@@ -1009,16 +1005,14 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	if (int_amcc & MASTER_ABORT_INT) {
 		comedi_error(dev, "AMCC IRQ - MASTER DMA ABORT!");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		pci9118_ai_cancel(dev, s);
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		return;
 	}
 
 	if (int_amcc & TARGET_ABORT_INT) {
 		comedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");
 		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		pci9118_ai_cancel(dev, s);
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		return;
 	}
 	if (int_adstat & devpriv->ai_maskerr)
@@ -1056,12 +1050,11 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		m = m - sampls;		/* m= how many samples was transferred */
 	}
 
-	if (!devpriv->ai_neverending)
-		if (devpriv->ai_act_scan >= devpriv->ai_scans) {
-							/* all data sampled */
-			pci9118_ai_cancel(dev, s);
+	if (!devpriv->ai_neverending) {
+		/* all data sampled? */
+		if (devpriv->ai_act_scan >= devpriv->ai_scans)
 			s->async->events |= COMEDI_CB_EOA;
-		}
+	}
 
 	if (devpriv->dma_doublebuf) {	/* switch dma buffers */
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
@@ -1074,7 +1067,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 static irqreturn_t interrupt_pci9118(int irq, void *d)

commit dbd446fc7aab519c213e63eefa15c82586a50989
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:46 2014 -0700

    staging: comedi: don't clear 'data' on (*insn_read) timeout
    
    It's not necessary to clear the returned data pointer when an (*insn_read)
    times out. For aesthetics, remove all of these in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9218e9293cf5..6ca6c429c722 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -614,7 +614,6 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
 		if (ret) {
-			data[n] = 0;
 			outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 			return ret;
 		}

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6492bd81efe8..9218e9293cf5 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -614,7 +614,6 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
 		if (ret) {
-			comedi_error(dev, "A/D insn timeout");
 			data[n] = 0;
 			outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 			return ret;

commit e934b994efcffd3c27579593e9dfae88d5c59b2b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:28 2014 -0700

    staging: comedi: adl_pci9118: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ef5afdb3bd09..6492bd81efe8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -571,12 +571,26 @@ static int setup_channel_list(struct comedi_device *dev,
 	return 1;		/* we can serve this with scan logic */
 }
 
+static int pci9118_ai_eoc(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_insn *insn,
+			  unsigned long context)
+{
+	unsigned int status;
+
+	status = inl(dev->iobase + PCI9118_ADSTAT);
+	if (status & AdStatus_ADrdy)
+		return 0;
+	return -EBUSY;
+}
+
 static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	struct pci9118_private *devpriv = dev->private;
-	int n, timeout;
+	int ret;
+	int n;
 
 	devpriv->AdControlReg = AdControl_Int & 0xff;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
@@ -597,19 +611,15 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
 		udelay(2);
-		timeout = 100;
-		while (timeout--) {
-			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
-				goto conv_finish;
-			udelay(1);
-		}
 
-		comedi_error(dev, "A/D insn timeout");
-		data[n] = 0;
-		outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
-		return -ETIME;
+		ret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);
+		if (ret) {
+			comedi_error(dev, "A/D insn timeout");
+			data[n] = 0;
+			outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+			return ret;
+		}
 
-conv_finish:
 		if (devpriv->ai16bits) {
 			data[n] =
 			    (inl(dev->iobase +

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4bdd9720e9eb..ef5afdb3bd09 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1936,28 +1936,6 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 	return NULL;
 }
 
-static void pci9118_report_attach(struct comedi_device *dev, unsigned int irq)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct pci9118_private *devpriv = dev->private;
-	char irqbuf[30];
-	char muxbuf[30];
-
-	if (irq)
-		snprintf(irqbuf, sizeof(irqbuf), "irq %u%s", irq,
-			 (dev->irq ? "" : " UNAVAILABLE"));
-	else
-		snprintf(irqbuf, sizeof(irqbuf), "irq DISABLED");
-	if (devpriv->usemux)
-		snprintf(muxbuf, sizeof(muxbuf), "ext mux %u chans",
-			 devpriv->usemux);
-	else
-		snprintf(muxbuf, sizeof(muxbuf), "no ext mux");
-	dev_info(dev->class_dev, "%s (pci %s, %s, %sbus master, %s) attached\n",
-		 dev->board_name, pci_name(pcidev), irqbuf,
-		 (devpriv->master ? "" : "no "), muxbuf);
-}
-
 static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 				 int master, int ext_mux, int softsshdelay,
 				 int hw_err_mask)
@@ -2113,7 +2091,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		break;
 	}
 
-	pci9118_report_attach(dev, dev->irq);
 	return 0;
 }
 

commit 713d5512740e90bfc6db4b1e05b171391a95ec1a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:10 2013 -0700

    staging: comedi: adl_pci9118: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a1de96356e30..4bdd9720e9eb 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -194,28 +194,30 @@ Configuration options:
 
 #define EXTTRG_AI	0	/* ext trg is used by AI */
 
-static const struct comedi_lrange range_pci9118dg_hr = { 8, {
-							     BIP_RANGE(5),
-							     BIP_RANGE(2.5),
-							     BIP_RANGE(1.25),
-							     BIP_RANGE(0.625),
-							     UNI_RANGE(10),
-							     UNI_RANGE(5),
-							     UNI_RANGE(2.5),
-							     UNI_RANGE(1.25)
-							     }
+static const struct comedi_lrange range_pci9118dg_hr = {
+	8, {
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
-static const struct comedi_lrange range_pci9118hg = { 8, {
-							  BIP_RANGE(5),
-							  BIP_RANGE(0.5),
-							  BIP_RANGE(0.05),
-							  BIP_RANGE(0.005),
-							  UNI_RANGE(10),
-							  UNI_RANGE(1),
-							  UNI_RANGE(0.1),
-							  UNI_RANGE(0.01)
-							  }
+static const struct comedi_lrange range_pci9118hg = {
+	8, {
+		BIP_RANGE(5),
+		BIP_RANGE(0.5),
+		BIP_RANGE(0.05),
+		BIP_RANGE(0.005),
+		UNI_RANGE(10),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.01)
+	}
 };
 
 #define PCI9118_BIPOLAR_RANGES	4	/*

commit d2443fe3b1b968a7bde4fa8e70542ba5baac3d89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:42 2013 -0700

    staging: comedi: adl_pci9118: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7e66978dc4b2..a1de96356e30 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1126,7 +1126,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 				}
 			}
 
-		(devpriv->int_ai_func) (dev, &dev->subdevices[0], int_adstat,
+		(devpriv->int_ai_func) (dev, dev->read_subdev, int_adstat,
 					int_amcc, int_daq);
 
 	}

commit 19cf54dd39f2213232ceb4ed1102876a3bd983f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:34 2013 -0700

    staging: comedi: adl_pci9118: tidy up irq request
    
    Clean up the irq request in the attach of this driver and remove the
    dev_{level} noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 97343cc40515..7e66978dc4b2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1965,7 +1965,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct comedi_subdevice *s;
 	int ret, pages, i;
-	unsigned int irq;
 	u16 u16w;
 
 	dev->board_name = this_board->name;
@@ -2036,12 +2035,18 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	pci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);
 				/* Enable parity check for parity error */
 
+	if (!disable_irq && pcidev->irq) {
+		ret = request_irq(pcidev->irq, interrupt_pci9118, IRQF_SHARED,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = pcidev->irq;
+	}
+
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;
 
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
 	if (devpriv->usemux)
@@ -2050,11 +2055,17 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		s->n_chan = this_board->n_aichan;
 
 	s->maxdata = this_board->ai_maxdata;
-	s->len_chanlist = this_board->n_aichanlist;
 	s->range_table = this_board->rangelist_ai;
-	s->cancel = pci9118_ai_cancel;
 	s->insn_read = pci9118_insn_read_ai;
-	s->munge = pci9118_ai_munge;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->len_chanlist = this_board->n_aichanlist;
+		s->do_cmdtest = pci9118_ai_cmdtest;
+		s->do_cmd = pci9118_ai_cmd;
+		s->cancel = pci9118_ai_cancel;
+		s->munge = pci9118_ai_munge;
+	}
 
 	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
@@ -2100,27 +2111,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		break;
 	}
 
-	if (disable_irq)
-		irq = 0;
-	else
-		irq = pcidev->irq;
-	if (irq > 0) {
-		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
-				dev->board_name, dev)) {
-			dev_warn(dev->class_dev,
-				 "unable to allocate IRQ %u, DISABLING IT\n",
-				 irq);
-		} else {
-			dev->irq = irq;
-			/* Enable AI commands */
-			s = &dev->subdevices[0];
-			s->subdev_flags |= SDF_CMD_READ;
-			s->do_cmdtest = pci9118_ai_cmdtest;
-			s->do_cmd = pci9118_ai_cmd;
-		}
-	}
-
-	pci9118_report_attach(dev, irq);
+	pci9118_report_attach(dev, dev->irq);
 	return 0;
 }
 

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 986489641ed7..97343cc40515 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2217,7 +2217,7 @@ static int adl_pci9118_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(adl_pci9118_pci_table) = {
+static const struct pci_device_id adl_pci9118_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
 	{ 0 }
 };

commit 95fd62a1174306d53f529e73a9713764072cc511
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Oct 21 10:42:37 2013 +0100

    staging: comedi: adl_pci9118: fix a misaligned comment
    
    As pointed out by Hartley Sweeten, one of my recent patches resulted in
    the start of a multi-line comment ending up misaligned.  Fix it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0f2e8591c697..986489641ed7 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -356,7 +356,7 @@ struct pci9118_private {
 	unsigned int ai_scans;			/* number of scans to do */
 	char dma_doublebuf;			/* we can use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
-	unsigned short *dmabuf_virt[2];			/*
+	unsigned short *dmabuf_virt[2];		/*
 						 * pointers to begin of
 						 * DMA buffer
 						 */

commit 6cda0d26b11c0b71e8cc43166fe9f669e68b61d6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:09 2013 +0100

    staging: comedi: adl_pci9118: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change the `ao_data[]` and `dmabuf_virt[]` members of `struct
    pci9118_private` and various local variables dealing with sample values
    to use `unsigned short` instead of `short` for consistency.
    
    Also remove the `short *ai_data` member of `struct pci9118_private` as
    it is only assigned to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index bd5c8bbad090..0f2e8591c697 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -352,12 +352,11 @@ struct pci9118_private {
 						 * on external start
 						 */
 	unsigned int ai_data_len;
-	short *ai_data;
-	short ao_data[2];			/* data output buffer */
+	unsigned short ao_data[2];		/* data output buffer */
 	unsigned int ai_scans;			/* number of scans to do */
 	char dma_doublebuf;			/* we can use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
-	short *dmabuf_virt[2];			/*
+	unsigned short *dmabuf_virt[2];			/*
 						 * pointers to begin of
 						 * DMA buffer
 						 */
@@ -700,7 +699,7 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
-					  short *dma_buffer,
+					  unsigned short *dma_buffer,
 					  unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -724,7 +723,7 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 
 static int move_block_from_dma(struct comedi_device *dev,
 					struct comedi_subdevice *s,
-					short *dma_buffer,
+					unsigned short *dma_buffer,
 					unsigned int num_samples)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -925,7 +924,7 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, num_samples = num_bytes / sizeof(short);
-	short *array = data;
+	unsigned short *array = data;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)
@@ -945,7 +944,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 					   unsigned short int_daq)
 {
 	struct pci9118_private *devpriv = dev->private;
-	register short sampl;
+	unsigned short sampl;
 
 	s->async->events = 0;
 
@@ -1613,7 +1612,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_n_chan = cmd->chanlist_len;
 	devpriv->ai_n_scanlen = cmd->scan_end_arg;
 	devpriv->ai_chanlist = cmd->chanlist;
-	devpriv->ai_data = s->async->prealloc_buf;
 	devpriv->ai_data_len = s->async->prealloc_bufsz;
 	devpriv->ai_timer1 = 0;
 	devpriv->ai_timer2 = 0;
@@ -1987,8 +1985,8 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--) {
 				devpriv->dmabuf_virt[i] =
-				    (short *)__get_free_pages(GFP_KERNEL,
-							      pages);
+				    (unsigned short *)
+				    __get_free_pages(GFP_KERNEL, pages);
 				if (devpriv->dmabuf_virt[i])
 					break;
 			}

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f50dbea67240..bd5c8bbad090 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -792,7 +792,8 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 	case 4:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+					  div1, div2,
 					  tim2, flags & TRIG_ROUND_NEAREST);
 		break;
 	case 2:
@@ -1277,9 +1278,9 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-					  &divisor2, &cmd->scan_begin_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+					  &divisor1, &divisor2,
+					  &cmd->scan_begin_arg, cmd->flags);
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -1288,9 +1289,9 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-					  &divisor2, &cmd->convert_arg,
-					  cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base,
+					  &divisor1, &divisor2,
+					  &cmd->convert_arg, cmd->flags);
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -2086,7 +2087,7 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;
-	devpriv->i8254_osc_base = 250;	/* 250ns=4MHz */
+	devpriv->i8254_osc_base = I8254_OSC_BASE_4MHZ;
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */
 	if (hw_err_mask)		/* disable some requested */

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7d2cff3eab85..f50dbea67240 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -671,13 +671,12 @@ static int pci9118_insn_bits_di(struct comedi_device *dev,
 
 static int pci9118_insn_bits_do(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
+	if (comedi_dio_update_state(s, data))
 		outl(s->state & 0x0f, dev->iobase + PCI9118_DO);
-	}
+
 	data[1] = s->state;
 
 	return insn->n;

commit 09567cb4373e962a3079bb06352e1e5452d9a340
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 10:47:03 2013 -0700

    staging: comedi: initialize subdevice s->io_bits in postconfig
    
    The subdevice 'io_bits' is a bit mask of the i/o configuration for
    digital subdevices. '0' values indicate that a channel is configured
    as an input and '1' values that the channel is an output. Since the
    subdevice data is kzalloc()'d, all channels default as inputs.
    
    Modify __comedi_device_postconfig() so that 'io_bits' is correctly
    initialized for Digital Output subdevices.
    
    Remove all the unnecessary initializations of 's->io_bits' from the
    drivers. Also, remove the unnecessary initialization of the 's->state'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 22196ada0362..7d2cff3eab85 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2075,7 +2075,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->maxdata = 1;
 	s->len_chanlist = 4;
 	s->range_table = &range_digital;
-	s->io_bits = 0;		/* all bits input */
 	s->insn_bits = pci9118_insn_bits_di;
 
 	s = &dev->subdevices[3];
@@ -2085,7 +2084,6 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	s->maxdata = 1;
 	s->len_chanlist = 4;
 	s->range_table = &range_digital;
-	s->io_bits = 0xf;	/* all bits output */
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2a48f8421ca0..22196ada0362 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -77,6 +77,7 @@ Configuration options:
  * manual attachment.
  */
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/gfp.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cb4ef2dcbf02..2a48f8421ca0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2140,10 +2140,9 @@ static int pci9118_attach(struct comedi_device *dev,
 	softsshdelay = it->options[4];
 	hw_err_mask = it->options[5];
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	pcidev = pci9118_find_pci(dev, it);
 	if (!pcidev)
@@ -2160,10 +2159,9 @@ static int pci9118_auto_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct pci9118_private *devpriv;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	dev->board_ptr = pci9118_find_boardinfo(pcidev);
 	if (dev->board_ptr == NULL) {

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2bf00e834540..cb4ef2dcbf02 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1970,12 +1970,9 @@ static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
 	u16 u16w;
 
 	dev->board_name = this_board->name;
-	ret = comedi_pci_enable(pcidev, dev->board_name);
-	if (ret) {
-		dev_err(dev->class_dev,
-			"cannot enable PCI device %s\n", pci_name(pcidev));
+	ret = comedi_pci_enable(dev);
+	if (ret)
 		return ret;
-	}
 	if (master)
 		pci_set_master(pcidev);
 

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a0277a83115d..2bf00e834540 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2202,12 +2202,9 @@ static void pci9118_detach(struct comedi_device *dev)
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
 				   devpriv->dmabuf_pages[1]);
 	}
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-
+	comedi_pci_disable(dev);
+	if (pcidev)
 		pci_dev_put(pcidev);
-	}
 }
 
 static struct comedi_driver adl_pci9118_driver = {

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4dbac7459a48..a0277a83115d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2222,9 +2222,10 @@ static struct comedi_driver adl_pci9118_driver = {
 };
 
 static int adl_pci9118_pci_probe(struct pci_dev *dev,
-					   const struct pci_device_id *ent)
+				 const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &adl_pci9118_driver);
+	return comedi_pci_auto_config(dev, &adl_pci9118_driver,
+				      id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(adl_pci9118_pci_table) = {

commit 8289ad0578ad7e66b2052754746b4deb1a88cc4a
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu Feb 14 22:27:06 2013 +0100

    staging/comedi: Use && instead of & for logical comparision
    
    sparse complains that:
    drivers/staging/comedi/drivers/adl_pci9118.c:813 pci9118_calc_divisors()
    warn: maybe use && instead of &
    
    usessh is used as a boolean flag (0 and 1) and is compared to a boolean
    value so we should use && here.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ef4dbe5ff0b8..4dbac7459a48 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -810,7 +810,7 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 		*tim2 = *div1 * devpriv->i8254_osc_base;
 							/* real convert timer */
 
-		if (usessh & (chnsshfront == 0))	/* use BSSH signal */
+		if (usessh && (chnsshfront == 0))	/* use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index d21dfe65ba85..ef4dbe5ff0b8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -76,13 +76,15 @@ Configuration options:
  * attachment if necessary, and possibly to set other options supported by
  * manual attachment.
  */
-#include "../comedidev.h"
 
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 
+#include "../comedidev.h"
+
 #include "amcc_s5933.h"
 #include "8253.h"
 #include "comedi_fc.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b6dda809bd13..d21dfe65ba85 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2225,11 +2225,6 @@ static int adl_pci9118_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &adl_pci9118_driver);
 }
 
-static void adl_pci9118_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(adl_pci9118_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
 	{ 0 }
@@ -2240,7 +2235,7 @@ static struct pci_driver adl_pci9118_pci_driver = {
 	.name		= "adl_pci9118",
 	.id_table	= adl_pci9118_pci_table,
 	.probe		= adl_pci9118_pci_probe,
-	.remove		= adl_pci9118_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(adl_pci9118_driver, adl_pci9118_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c35b25d29781..b6dda809bd13 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2225,7 +2225,7 @@ static int adl_pci9118_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &adl_pci9118_driver);
 }
 
-static void __devexit adl_pci9118_pci_remove(struct pci_dev *dev)
+static void adl_pci9118_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c7d0f33e143a..c35b25d29781 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2155,7 +2155,7 @@ static int pci9118_attach(struct comedi_device *dev,
 				     softsshdelay, hw_err_mask);
 }
 
-static int __devinit pci9118_auto_attach(struct comedi_device *dev,
+static int pci9118_auto_attach(struct comedi_device *dev,
 					 unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -2219,7 +2219,7 @@ static struct comedi_driver adl_pci9118_driver = {
 	.offset		= sizeof(struct boardtype),
 };
 
-static int __devinit adl_pci9118_pci_probe(struct pci_dev *dev,
+static int adl_pci9118_pci_probe(struct pci_dev *dev,
 					   const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &adl_pci9118_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a6b21cb61da6..c7d0f33e143a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2240,7 +2240,7 @@ static struct pci_driver adl_pci9118_pci_driver = {
 	.name		= "adl_pci9118",
 	.id_table	= adl_pci9118_pci_table,
 	.probe		= adl_pci9118_pci_probe,
-	.remove		= __devexit_p(adl_pci9118_pci_remove),
+	.remove		= adl_pci9118_pci_remove,
 };
 module_comedi_pci_driver(adl_pci9118_driver, adl_pci9118_pci_driver);
 

commit 1b44331348ddda4d0194036b647bd46f436b1d08
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:52:04 2012 -0700

    staging: comedi: adl_pci9118: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of pci9118_ai_do_cmd_test().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2b1d21bd324e..a6b21cb61da6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1216,19 +1216,13 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	if (cmd->start_src & (TRIG_NOW | TRIG_EXT))
-		if (cmd->start_arg != 0) {
-			cmd->start_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
 	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
@@ -1238,64 +1232,40 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER)
-		if (cmd->scan_begin_arg < this_board->ai_ns_min) {
-			cmd->scan_begin_arg = this_board->ai_ns_min;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 this_board->ai_ns_min);
 
 	if (cmd->scan_begin_src == TRIG_EXT)
 		if (cmd->scan_begin_arg) {
 			cmd->scan_begin_arg = 0;
-			err++;
-			if (cmd->scan_end_arg > 65535) {
-				cmd->scan_end_arg = 65535;
-				err++;
-			}
+			err |= -EINVAL;
+			err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg,
+							 65535);
 		}
 
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
-		if (cmd->convert_arg < this_board->ai_ns_min) {
-			cmd->convert_arg = this_board->ai_ns_min;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 this_board->ai_ns_min);
 
 	if (cmd->convert_src == TRIG_EXT)
-		if (cmd->convert_arg) {
-			cmd->convert_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
-	} else {		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
-
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
-	if (cmd->chanlist_len > this_board->n_aichanlist) {
-		cmd->chanlist_len = this_board->n_aichanlist;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_max(&cmd->chanlist_len,
+					 this_board->n_aichanlist);
 
-	if (cmd->scan_end_arg < cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_min(&cmd->scan_end_arg,
+					 cmd->chanlist_len);
 
 	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
 		cmd->scan_end_arg =
 		    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);
-		err++;
+		err |= -EINVAL;
 	}
 
 	if (err)

commit 15358a7f777529500cb1fcb089c09fb792fecf30
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 13:52:32 2012 +0000

    staging: comedi: adl_pci9118: support auto-attachment
    
    Support auto-attachment of supported PCI devices by adding the
    `auto_attach()` hook (`pci9118_auto_attach()`) to the `struct
    comedi_driver`.  This is called via `comedi_pci_auto_attach()` at PCI
    probe time.
    
    Previously, the driver's call to `comedi_pci_auto_config()` would fall
    back to the old method of auto-attaching devices and would fail because
    it couldn't find a board name matching the driver name.  The new method
    doesn't care about that.
    
    There are still a few problems.  All the boards supported by this driver
    have the same PCI vendor and device ID, so it will just pick the first
    supported board type, "pci9118dg".  (Other supported board types have
    different AI ranges or different AI speeds, but are otherwise the same.)
    Also, manual attachment of devices allows several optional features to
    be configured, such as use of an external multiplexord, specified
    sample&hold delays and options to ignore certain hardware errors.  These
    will all be set to defaults for auto-attached devices.  A future version
    of the driver may address these issues via configurable device
    attributes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 0bd720b0ba62..2b1d21bd324e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -62,6 +62,20 @@ Configuration options:
 	256|=ignore nFull - A/D FIFO Full status
 
 */
+
+/*
+ * FIXME
+ *
+ * All the supported boards have the same PCI vendor and device IDs, so
+ * auto-attachment of PCI devices will always find the first board type.
+ *
+ * Perhaps the boards have different subdevice IDs that we could use to
+ * distinguish them?
+ *
+ * Need some device attributes so the board type can be corrected after
+ * attachment if necessary, and possibly to set other options supported by
+ * manual attachment.
+ */
 #include "../comedidev.h"
 
 #include <linux/delay.h>
@@ -232,6 +246,61 @@ struct boardtype {
 
 };
 
+static const struct boardtype boardtypes[] = {
+	{
+		.name		= "pci9118dg",
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0x0fff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118dg_hr,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 3000,
+		.ai_pacer_min	= 12,
+		.half_fifo_size	= 512,
+	}, {
+		.name		= "pci9118hg",
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0x0fff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118hg,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 3000,
+		.ai_pacer_min	= 12,
+		.half_fifo_size	= 512,
+	}, {
+		.name		= "pci9118hr",
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0xffff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118dg_hr,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 10000,
+		.ai_pacer_min	= 40,
+		.half_fifo_size	= 512,
+	},
+};
+
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
 	unsigned int master;	/* master capable */
@@ -1853,6 +1922,20 @@ static int pci9118_reset(struct comedi_device *dev)
 	return 0;
 }
 
+/*
+ * FIXME - this is pretty ineffective because all the supported board types
+ * have the same device ID!
+ */
+static const struct boardtype *pci9118_find_boardinfo(struct pci_dev *pcidev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(boardtypes); i++)
+		if (pcidev->device == boardtypes[i].device_id)
+			return &boardtypes[i];
+	return NULL;
+}
+
 static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 					struct comedi_devconfig *it)
 {
@@ -2102,6 +2185,34 @@ static int pci9118_attach(struct comedi_device *dev,
 				     softsshdelay, hw_err_mask);
 }
 
+static int __devinit pci9118_auto_attach(struct comedi_device *dev,
+					 unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pci9118_private *devpriv;
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	dev->board_ptr = pci9118_find_boardinfo(pcidev);
+	if (dev->board_ptr == NULL) {
+		dev_err(dev->class_dev,
+			"adl_pci9118: cannot determine board type for pci %s\n",
+			pci_name(pcidev));
+		return -EINVAL;
+	}
+	/*
+	 * Need to 'get' the PCI device to match the 'put' in pci9118_detach().
+	 * (The 'put' also matches the implicit 'get' by pci9118_find_pci().)
+	 */
+	pci_dev_get(pcidev);
+	/* Don't disable irq, use bus master, no external mux,
+	 * no sample-hold delay, no error mask. */
+	return pci9118_common_attach(dev, 0, 1, 0, 0, 0);
+}
+
 static void pci9118_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -2127,65 +2238,11 @@ static void pci9118_detach(struct comedi_device *dev)
 	}
 }
 
-static const struct boardtype boardtypes[] = {
-	{
-		.name		= "pci9118dg",
-		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
-		.n_aichan	= 16,
-		.n_aichand	= 8,
-		.mux_aichan	= 256,
-		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
-		.ai_maxdata	= 0x0fff,
-		.ao_maxdata	= 0x0fff,
-		.rangelist_ai	= &range_pci9118dg_hr,
-		.rangelist_ao	= &range_bipolar10,
-		.ai_ns_min	= 3000,
-		.ai_pacer_min	= 12,
-		.half_fifo_size	= 512,
-	}, {
-		.name		= "pci9118hg",
-		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
-		.n_aichan	= 16,
-		.n_aichand	= 8,
-		.mux_aichan	= 256,
-		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
-		.ai_maxdata	= 0x0fff,
-		.ao_maxdata	= 0x0fff,
-		.rangelist_ai	= &range_pci9118hg,
-		.rangelist_ao	= &range_bipolar10,
-		.ai_ns_min	= 3000,
-		.ai_pacer_min	= 12,
-		.half_fifo_size	= 512,
-	}, {
-		.name		= "pci9118hr",
-		.device_id	= 0x80d9,
-		.iorange_amcc	= AMCC_OP_REG_SIZE,
-		.iorange_9118	= IORANGE_9118,
-		.n_aichan	= 16,
-		.n_aichand	= 8,
-		.mux_aichan	= 256,
-		.n_aichanlist	= PCI9118_CHANLEN,
-		.n_aochan	= 2,
-		.ai_maxdata	= 0xffff,
-		.ao_maxdata	= 0x0fff,
-		.rangelist_ai	= &range_pci9118dg_hr,
-		.rangelist_ao	= &range_bipolar10,
-		.ai_ns_min	= 10000,
-		.ai_pacer_min	= 40,
-		.half_fifo_size	= 512,
-	},
-};
-
 static struct comedi_driver adl_pci9118_driver = {
 	.driver_name	= "adl_pci9118",
 	.module		= THIS_MODULE,
 	.attach		= pci9118_attach,
+	.auto_attach	= pci9118_auto_attach,
 	.detach		= pci9118_detach,
 	.num_names	= ARRAY_SIZE(boardtypes),
 	.board_name	= &boardtypes[0].name,

commit 00d9319475a80d372de726c7cabbfb45d7531a24
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 13:52:31 2012 +0000

    staging: comedi: adl_pci9118: cards have same vendor ID
    
    Don't bother recording the PCI vendor ID of each board in `boardtypes[]`
    as they are all the same and the code doesn't use it anyway.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cc46d641aafc..0bd720b0ba62 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -208,8 +208,7 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 
 struct boardtype {
 	const char *name;		/* board name */
-	int vendor_id;			/* PCI vendor a device ID of card */
-	int device_id;
+	int device_id;			/* PCI device ID of card */
 	int iorange_amcc;		/* iorange for own S5933 region */
 	int iorange_9118;		/* pass thru card region size */
 	int n_aichan;			/* num of A/D chans */
@@ -2131,7 +2130,6 @@ static void pci9118_detach(struct comedi_device *dev)
 static const struct boardtype boardtypes[] = {
 	{
 		.name		= "pci9118dg",
-		.vendor_id	= PCI_VENDOR_ID_AMCC,
 		.device_id	= 0x80d9,
 		.iorange_amcc	= AMCC_OP_REG_SIZE,
 		.iorange_9118	= IORANGE_9118,
@@ -2149,7 +2147,6 @@ static const struct boardtype boardtypes[] = {
 		.half_fifo_size	= 512,
 	}, {
 		.name		= "pci9118hg",
-		.vendor_id	= PCI_VENDOR_ID_AMCC,
 		.device_id	= 0x80d9,
 		.iorange_amcc	= AMCC_OP_REG_SIZE,
 		.iorange_9118	= IORANGE_9118,
@@ -2167,7 +2164,6 @@ static const struct boardtype boardtypes[] = {
 		.half_fifo_size	= 512,
 	}, {
 		.name		= "pci9118hr",
-		.vendor_id	= PCI_VENDOR_ID_AMCC,
 		.device_id	= 0x80d9,
 		.iorange_amcc	= AMCC_OP_REG_SIZE,
 		.iorange_9118	= IORANGE_9118,

commit f3b81d54585b2b050257228555f15c0e507024d1
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 13:52:30 2012 +0000

    staging: comedi: adl_pci9118: split pci9118_attach()
    
    Split most of the functionality of the attach routine `pci9118_attach()`
    into a new function `pci9118_common_attach()` that can be called when
    auto-attachment of devices is supported.  Move the enabling of the PCI
    device and its i/o regions into this function.  Do the requesting of the
    interrupt near the end of the function so it doesn't get enabled before
    the device is ready.
    
    Note that auto-attachment of PCI devices is currently broken in this
    driver because the list of board names referred to by the `struct
    comedi_driver` does not contain a "wildcard" entry matching the comedi
    driver name.  This won't be a problem once support for the
    `auto_attach()` method is added.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 01c9ba3ccac9..cc46d641aafc 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1873,12 +1873,6 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 			    PCI_SLOT(pcidev->devfn) != slot)
 				continue;
 		}
-		/*
-		 * Look for device that isn't in use.
-		 * Enable PCI device and request regions.
-		 */
-		if (comedi_pci_enable(pcidev, "adl_pci9118"))
-			continue;
 		return pcidev;
 	}
 	dev_err(dev->class_dev,
@@ -1909,56 +1903,33 @@ static void pci9118_report_attach(struct comedi_device *dev, unsigned int irq)
 		 (devpriv->master ? "" : "no "), muxbuf);
 }
 
-static int pci9118_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it)
+static int pci9118_common_attach(struct comedi_device *dev, int disable_irq,
+				 int master, int ext_mux, int softsshdelay,
+				 int hw_err_mask)
 {
 	const struct boardtype *this_board = comedi_board(dev);
-	struct pci9118_private *devpriv;
-	struct pci_dev *pcidev;
+	struct pci9118_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	struct comedi_subdevice *s;
 	int ret, pages, i;
-	unsigned short master;
 	unsigned int irq;
 	u16 u16w;
 
-	if (it->options[3] & 1)
-		master = 0;	/* user don't want use bus master */
-	else
-		master = 1;
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	pcidev = pci9118_find_pci(dev, it);
-	if (!pcidev)
-		return -EIO;
-	comedi_set_hw_dev(dev, &pcidev->dev);
-
+	dev->board_name = this_board->name;
+	ret = comedi_pci_enable(pcidev, dev->board_name);
+	if (ret) {
+		dev_err(dev->class_dev,
+			"cannot enable PCI device %s\n", pci_name(pcidev));
+		return ret;
+	}
 	if (master)
 		pci_set_master(pcidev);
 
-	irq = pcidev->irq;
 	devpriv->iobase_a = pci_resource_start(pcidev, 0);
 	dev->iobase = pci_resource_start(pcidev, 2);
 
-	dev->board_name = this_board->name;
-
 	pci9118_reset(dev);
 
-	if (it->options[3] & 2)
-		irq = 0;	/* user don't want use IRQ */
-	if (irq > 0) {
-		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
-				"ADLink PCI-9118", dev))
-			dev_warn(dev->class_dev,
-				 "unable to allocate IRQ %u, DISABLING IT\n",
-				 irq);
-		else
-			dev->irq = irq;
-	}
-
 	if (master) {		/* alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
@@ -1984,32 +1955,29 @@ static int pci9118_attach(struct comedi_device *dev,
 				 "Can't allocate DMA buffer, DMA disabled!\n");
 			master = 0;
 		}
-
 		if (devpriv->dmabuf_virt[1])
 			devpriv->dma_doublebuf = 1;
-
 	}
-
 	devpriv->master = master;
-	devpriv->usemux = 0;
-	if (it->options[2] > 0) {
-		devpriv->usemux = it->options[2];
-		if (devpriv->usemux > 256)
-			devpriv->usemux = 256;	/* max 256 channels! */
-		if (it->options[4] > 0)
-			if (devpriv->usemux > 128) {
-				devpriv->usemux = 128;
-					/* max 128 channels with softare S&H! */
-			}
+
+	if (ext_mux > 0) {
+		if (ext_mux > 256)
+			ext_mux = 256;	/* max 256 channels! */
+		if (softsshdelay > 0)
+			if (ext_mux > 128)
+				ext_mux = 128;
+		devpriv->usemux = ext_mux;
+	} else {
+		devpriv->usemux = 0;
 	}
 
-	devpriv->softsshdelay = it->options[4];
-	if (devpriv->softsshdelay < 0) {
-					/* select sample&hold signal polarity */
-		devpriv->softsshdelay = -devpriv->softsshdelay;
+	if (softsshdelay < 0) {
+		/* select sample&hold signal polarity */
+		devpriv->softsshdelay = -softsshdelay;
 		devpriv->softsshsample = 0x80;
 		devpriv->softsshhold = 0x00;
 	} else {
+		devpriv->softsshdelay = softsshdelay;
 		devpriv->softsshsample = 0x00;
 		devpriv->softsshhold = 0x80;
 	}
@@ -2036,12 +2004,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	s->range_table = this_board->rangelist_ai;
 	s->cancel = pci9118_ai_cancel;
 	s->insn_read = pci9118_insn_read_ai;
-	if (dev->irq) {
-		s->subdev_flags |= SDF_CMD_READ;
-		s->do_cmdtest = pci9118_ai_cmdtest;
-		s->do_cmd = pci9118_ai_cmd;
-		s->munge = pci9118_ai_munge;
-	}
+	s->munge = pci9118_ai_munge;
 
 	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
@@ -2077,8 +2040,8 @@ static int pci9118_attach(struct comedi_device *dev,
 	devpriv->i8254_osc_base = 250;	/* 250ns=4MHz */
 	devpriv->ai_maskharderr = 0x10a;
 					/* default measure crash condition */
-	if (it->options[5])		/* disable some requested */
-		devpriv->ai_maskharderr &= ~it->options[5];
+	if (hw_err_mask)		/* disable some requested */
+		devpriv->ai_maskharderr &= ~hw_err_mask;
 
 	switch (this_board->ai_maxdata) {
 	case 0xffff:
@@ -2088,10 +2051,58 @@ static int pci9118_attach(struct comedi_device *dev,
 		devpriv->ai16bits = 0;
 		break;
 	}
+
+	if (disable_irq)
+		irq = 0;
+	else
+		irq = pcidev->irq;
+	if (irq > 0) {
+		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
+				dev->board_name, dev)) {
+			dev_warn(dev->class_dev,
+				 "unable to allocate IRQ %u, DISABLING IT\n",
+				 irq);
+		} else {
+			dev->irq = irq;
+			/* Enable AI commands */
+			s = &dev->subdevices[0];
+			s->subdev_flags |= SDF_CMD_READ;
+			s->do_cmdtest = pci9118_ai_cmdtest;
+			s->do_cmd = pci9118_ai_cmd;
+		}
+	}
+
 	pci9118_report_attach(dev, irq);
 	return 0;
 }
 
+static int pci9118_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
+{
+	struct pci9118_private *devpriv;
+	struct pci_dev *pcidev;
+	int ext_mux, disable_irq, master, softsshdelay, hw_err_mask;
+
+	ext_mux = it->options[2];
+	master = ((it->options[3] & 1) == 0);
+	disable_irq = ((it->options[3] & 2) != 0);
+	softsshdelay = it->options[4];
+	hw_err_mask = it->options[5];
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	pcidev = pci9118_find_pci(dev, it);
+	if (!pcidev)
+		return -EIO;
+	comedi_set_hw_dev(dev, &pcidev->dev);
+
+	return pci9118_common_attach(dev, disable_irq, master, ext_mux,
+				     softsshdelay, hw_err_mask);
+}
+
 static void pci9118_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);

commit f41d2573b22c5eafff868824004095fff92b0e8c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 2 13:52:29 2012 +0000

    staging: comedi: adl_pci9118: replace printks
    
    Replace or remove the `printk()` calls in this driver.  Call new function
    `pci9118_report_attach()` to report successful attachment of the board.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a5d0be21eff0..01c9ba3ccac9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -356,10 +356,8 @@ static int check_channel_list(struct comedi_device *dev,
 		return 0;
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		printk
-		    ("comedi%d: range/channel list is too long for "
-						"actual configuration (%d>%d)!",
-		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
+		comedi_error(dev,
+			    "range/channel list is too long for actual configuration!\n");
 		return 0;
 	}
 
@@ -890,11 +888,10 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	if (devpriv->ai16bits == 0) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {
 							/* data dropout! */
-			printk
-			    ("comedi: A/D  SAMPL - data dropout: "
-				"received channel %d, expected %d!\n",
-				sampl & 0x000f,
-				devpriv->chanlist[s->async->cur_chan]);
+			dev_info(dev->class_dev,
+				 "A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
+				 sampl & 0x000f,
+				 devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 			pci9118_ai_cancel(dev, s);
 			comedi_event(dev, s);
@@ -1316,21 +1313,18 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
 			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			printk
-			    ("comedi%d: WAR: DMA0 buf too short, can't "
-					"support TRIG_WAKE_EOS (%d<%d)\n",
-			     dev->minor, dmalen0,
-			     devpriv->ai_n_realscanlen << 1);
+			dev_info(dev->class_dev,
+				 "WAR: DMA0 buf too short, can't support TRIG_WAKE_EOS (%d<%d)\n",
+				  dmalen0, devpriv->ai_n_realscanlen << 1);
 		} else {
 			/* short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
-				printk
-					("comedi%d: ERR: DMA0 buf len bug? "
-								"(%d<4)\n",
-					dev->minor, dmalen0);
+				dev_info(dev->class_dev,
+					 "ERR: DMA0 buf len bug? (%d<4)\n",
+					 dmalen0);
 				dmalen0 = 4;
 			}
 		}
@@ -1339,21 +1333,18 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
 			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			printk
-			    ("comedi%d: WAR: DMA1 buf too short, "
-					"can't support TRIG_WAKE_EOS (%d<%d)\n",
-			     dev->minor, dmalen1,
-			     devpriv->ai_n_realscanlen << 1);
+			dev_info(dev->class_dev,
+				 "WAR: DMA1 buf too short, can't support TRIG_WAKE_EOS (%d<%d)\n",
+				 dmalen1, devpriv->ai_n_realscanlen << 1);
 		} else {
 			/* short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
-				printk
-					("comedi%d: ERR: DMA1 buf len bug? "
-								"(%d<4)\n",
-					dev->minor, dmalen1);
+				dev_info(dev->class_dev,
+					 "ERR: DMA1 buf len bug? (%d<4)\n",
+					 dmalen1);
 				dmalen1 = 4;
 			}
 		}
@@ -1888,20 +1879,36 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 		 */
 		if (comedi_pci_enable(pcidev, "adl_pci9118"))
 			continue;
-		printk(KERN_ERR ", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx",
-			pcidev->bus->number,
-			PCI_SLOT(pcidev->devfn),
-			PCI_FUNC(pcidev->devfn),
-			(unsigned long)pci_resource_start(pcidev, 2),
-			(unsigned long)pci_resource_start(pcidev, 0));
 		return pcidev;
 	}
-	printk(KERN_ERR
-		"comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
-		dev->minor, bus, slot);
+	dev_err(dev->class_dev,
+		"no supported board found! (req. bus/slot : %d/%d)\n",
+		bus, slot);
 	return NULL;
 }
 
+static void pci9118_report_attach(struct comedi_device *dev, unsigned int irq)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pci9118_private *devpriv = dev->private;
+	char irqbuf[30];
+	char muxbuf[30];
+
+	if (irq)
+		snprintf(irqbuf, sizeof(irqbuf), "irq %u%s", irq,
+			 (dev->irq ? "" : " UNAVAILABLE"));
+	else
+		snprintf(irqbuf, sizeof(irqbuf), "irq DISABLED");
+	if (devpriv->usemux)
+		snprintf(muxbuf, sizeof(muxbuf), "ext mux %u chans",
+			 devpriv->usemux);
+	else
+		snprintf(muxbuf, sizeof(muxbuf), "no ext mux");
+	dev_info(dev->class_dev, "%s (pci %s, %s, %sbus master, %s) attached\n",
+		 dev->board_name, pci_name(pcidev), irqbuf,
+		 (devpriv->master ? "" : "no "), muxbuf);
+}
+
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
@@ -1914,8 +1921,6 @@ static int pci9118_attach(struct comedi_device *dev,
 	unsigned int irq;
 	u16 u16w;
 
-	printk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);
-
 	if (it->options[3] & 1)
 		master = 0;	/* user don't want use bus master */
 	else
@@ -1946,19 +1951,14 @@ static int pci9118_attach(struct comedi_device *dev,
 		irq = 0;	/* user don't want use IRQ */
 	if (irq > 0) {
 		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
-				"ADLink PCI-9118", dev)) {
-			printk(", unable to allocate IRQ %d, DISABLING IT",
-			       irq);
-			irq = 0;	/* Can't use IRQ */
-		} else {
-			printk(", irq=%u", irq);
-		}
-	} else {
-		printk(", IRQ disabled");
+				"ADLink PCI-9118", dev))
+			dev_warn(dev->class_dev,
+				 "unable to allocate IRQ %u, DISABLING IT\n",
+				 irq);
+		else
+			dev->irq = irq;
 	}
 
-	dev->irq = irq;
-
 	if (master) {		/* alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
@@ -1980,7 +1980,8 @@ static int pci9118_attach(struct comedi_device *dev,
 			}
 		}
 		if (!devpriv->dmabuf_virt[0]) {
-			printk(", Can't allocate DMA buffer, DMA disabled!");
+			dev_warn(dev->class_dev,
+				 "Can't allocate DMA buffer, DMA disabled!\n");
 			master = 0;
 		}
 
@@ -1990,11 +1991,6 @@ static int pci9118_attach(struct comedi_device *dev,
 	}
 
 	devpriv->master = master;
-	if (devpriv->master)
-		printk(", bus master");
-	else
-		printk(", no bus master");
-
 	devpriv->usemux = 0;
 	if (it->options[2] > 0) {
 		devpriv->usemux = it->options[2];
@@ -2005,7 +2001,6 @@ static int pci9118_attach(struct comedi_device *dev,
 				devpriv->usemux = 128;
 					/* max 128 channels with softare S&H! */
 			}
-		printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
@@ -2019,8 +2014,6 @@ static int pci9118_attach(struct comedi_device *dev,
 		devpriv->softsshhold = 0x80;
 	}
 
-	printk(".\n");
-
 	pci_read_config_word(pcidev, PCI_COMMAND, &u16w);
 	pci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);
 				/* Enable parity check for parity error */
@@ -2095,6 +2088,7 @@ static int pci9118_attach(struct comedi_device *dev,
 		devpriv->ai16bits = 0;
 		break;
 	}
+	pci9118_report_attach(dev, irq);
 	return 0;
 }
 

commit 268533124d621360710e08e0ce71a3f5313b6c78
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 18:14:00 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_AMCC
    
    Add a define for the Applied Micro Circuits Corp. PCI vendor id.
    Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4bcc5b1171d9..a5d0be21eff0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -73,8 +73,6 @@ Configuration options:
 #include "8253.h"
 #include "comedi_fc.h"
 
-#define PCI_VENDOR_ID_AMCC	0x10e8
-
 /* paranoid checks are broken */
 #undef PCI9118_PARANOIDCHECK	/*
 				 * if defined, then is used code which control

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4eca8764685f..4bcc5b1171d9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1923,10 +1923,10 @@ static int pci9118_attach(struct comedi_device *dev,
 	else
 		master = 1;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	pcidev = pci9118_find_pci(dev, it);
 	if (!pcidev)

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 06ff65c85c9f..4eca8764685f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1924,10 +1924,8 @@ static int pci9118_attach(struct comedi_device *dev,
 		master = 1;
 
 	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret < 0) {
-		printk(" - Allocation failed!\n");
-		return -ENOMEM;
-	}
+	if (ret)
+		return ret;
 	devpriv = dev->private;
 
 	pcidev = pci9118_find_pci(dev, it);

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f7b254d004dc..06ff65c85c9f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1102,7 +1102,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	int tmp;
 	unsigned int divisor1 = 0, divisor2 = 0;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src,
 					TRIG_NOW | TRIG_EXT | TRIG_INT);
@@ -1124,70 +1124,31 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/*
-	 * step 2:
-	 * make sure trigger sources are
-	 * unique and mutually compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW &&
-	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
-		cmd->start_src = TRIG_NOW;
-		err++;
-	}
-
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_INT &&
-	    cmd->scan_begin_src != TRIG_FOLLOW) {
-		cmd->scan_begin_src = TRIG_FOLLOW;
-		err++;
-	}
-
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
-		cmd->convert_src = TRIG_TIMER;
-		err++;
-	}
-
-	if (cmd->scan_end_src != TRIG_COUNT) {
-		cmd->scan_end_src = TRIG_COUNT;
-		err++;
-	}
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
 
-	if (cmd->stop_src != TRIG_NONE &&
-	    cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
-		cmd->stop_src = TRIG_COUNT;
-		err++;
-	}
+	/* Step 2b : and mutually compatible */
 
-	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {
-		cmd->start_src = TRIG_NOW;
-		err++;
-	}
+	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
+		err |= -EINVAL;
 
-	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT) {
-		cmd->start_src = TRIG_NOW;
-		err++;
-	}
+	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT)
+		err |= -EINVAL;
 
 	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
-	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
-		cmd->convert_src = TRIG_TIMER;
-		err++;
-	}
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))
+		err |= -EINVAL;
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
-	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
-		cmd->convert_src = TRIG_TIMER;
-		err++;
-	}
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT))))
+		err |= -EINVAL;
 
-	if (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {
-		cmd->stop_src = TRIG_COUNT;
-		err++;
-	}
+	if (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit 22d4b56f5b4185db609f5c94113d8ee6ca8807dc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:42:11 2012 -0700

    staging: comedi: adl_pci9118: use cfc_check_trigger_src
    
    The the cfc_check_trigger_src helper for the "step 1" tests in
    pci9118_ai_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f3beeb8c9ee3..f7b254d004dc 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1098,43 +1098,28 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 	int err = 0;
+	unsigned int flags;
 	int tmp;
 	unsigned int divisor1 = 0, divisor2 = 0;
 
 	/* step 1: make sure trigger sources are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src,
+					TRIG_NOW | TRIG_EXT | TRIG_INT);
 
-	tmp = cmd->scan_begin_src;
+	flags = TRIG_FOLLOW;
 	if (devpriv->master)
-		cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
-	else
-		cmd->scan_begin_src &= TRIG_FOLLOW;
+		flags |= TRIG_TIMER | TRIG_EXT;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
 
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
+	flags = TRIG_TIMER | TRIG_EXT;
 	if (devpriv->master)
-		cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
-	else
-		cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+		flags |= TRIG_NOW;
+	err |= cfc_check_trigger_src(&cmd->convert_src, flags);
 
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE | TRIG_EXT;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_NONE | TRIG_EXT);
 
 	if (err)
 		return 1;

commit 5e49e5152cf10d3e5a3c699859f220a97852c687
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:41:36 2012 -0700

    staging: comedi: adl_pci9118: remove forward declarations
    
    Move some of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 7c8ce2cbbbe3..f3beeb8c9ee3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -346,25 +346,162 @@ struct pci9118_private {
 
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int frontadd,
-			      int backadd);
+			      unsigned int *chanlist, int frontadd, int backadd)
+{
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int i, differencial = 0, bipolar = 0;
+
+	/* correct channel and range number check itself comedi/range.c */
+	if (n_chan < 1) {
+		comedi_error(dev, "range/channel list is empty!");
+		return 0;
+	}
+	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
+		printk
+		    ("comedi%d: range/channel list is too long for "
+						"actual configuration (%d>%d)!",
+		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
+		return 0;
+	}
+
+	if (CR_AREF(chanlist[0]) == AREF_DIFF)
+		differencial = 1;	/* all input must be diff */
+	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
+		bipolar = 1;	/* all input must be bipolar */
+	if (n_chan > 1)
+		for (i = 1; i < n_chan; i++) {	/* check S.E/diff */
+			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
+			    (differencial)) {
+				comedi_error(dev,
+					     "Differencial and single ended "
+						"inputs can't be mixtured!");
+				return 0;
+			}
+			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
+			    (bipolar)) {
+				comedi_error(dev,
+					     "Bipolar and unipolar ranges "
+							"can't be mixtured!");
+				return 0;
+			}
+			if (!devpriv->usemux && differencial &&
+			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
+				comedi_error(dev,
+					     "If AREF_DIFF is used then is "
+					"available only first 8 channels!");
+				return 0;
+			}
+		}
+
+	return 1;
+}
+
 static int setup_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int rot, int frontadd,
-			      int backadd, int usedma, char eoshandle);
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2);
-static int pci9118_reset(struct comedi_device *dev);
-static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source);
-static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source);
-static int pci9118_ai_cancel(struct comedi_device *dev,
-			     struct comedi_subdevice *s);
-static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  unsigned int *tim1, unsigned int *tim2,
-				  unsigned int flags, int chans,
-				  unsigned int *div1, unsigned int *div2,
-				  char usessh, unsigned int chnsshfront);
+			      int backadd, int usedma, char useeos)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int i, differencial = 0, bipolar = 0;
+	unsigned int scanquad, gain, ssh = 0x00;
+
+	if (usedma == 1) {
+		rot = 8;
+		usedma = 0;
+	}
+
+	if (CR_AREF(chanlist[0]) == AREF_DIFF)
+		differencial = 1;	/* all input must be diff */
+	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
+		bipolar = 1;	/* all input must be bipolar */
+
+	/* All is ok, so we can setup channel/range list */
+
+	if (!bipolar) {
+		devpriv->AdControlReg |= AdControl_UniP;
+							/* set unibipolar */
+	} else {
+		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);
+							/* enable bipolar */
+	}
+
+	if (differencial) {
+		devpriv->AdControlReg |= AdControl_Diff;
+							/* enable diff inputs */
+	} else {
+		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);
+						/* set single ended inputs */
+	}
+
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+								/* setup mode */
+
+	outl(2, dev->iobase + PCI9118_SCANMOD);
+					/* gods know why this sequence! */
+	outl(0, dev->iobase + PCI9118_SCANMOD);
+	outl(1, dev->iobase + PCI9118_SCANMOD);
+
+#ifdef PCI9118_PARANOIDCHECK
+	devpriv->chanlistlen = n_chan;
+	for (i = 0; i < (PCI9118_CHANLEN + 1); i++)
+		devpriv->chanlist[i] = 0x55aa;
+#endif
+
+	if (frontadd) {		/* insert channels for S&H */
+		ssh = devpriv->softsshsample;
+		for (i = 0; i < frontadd; i++) {
+						/* store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);
+						/* get channel number; */
+			gain = CR_RANGE(chanlist[0]);
+						/* get gain number */
+			scanquad |= ((gain & 0x03) << 8);
+			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+			ssh = devpriv->softsshhold;
+		}
+	}
+
+	for (i = 0; i < n_chan; i++) {	/* store range list to card */
+		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
+#ifdef PCI9118_PARANOIDCHECK
+		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
+#endif
+		gain = CR_RANGE(chanlist[i]);		/* get gain number */
+		scanquad |= ((gain & 0x03) << 8);
+		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+	}
+
+	if (backadd) {		/* insert channels for fit onto 32bit DMA */
+		for (i = 0; i < backadd; i++) {	/* store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);
+							/* get channel number */
+			gain = CR_RANGE(chanlist[0]);	/* get gain number */
+			scanquad |= ((gain & 0x03) << 8);
+			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+		}
+	}
+#ifdef PCI9118_PARANOIDCHECK
+	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
+						/* for 32bit operations */
+	if (useeos) {
+		for (i = 1; i < n_chan; i++) {	/* store range list to card */
+			devpriv->chanlist[(n_chan + i) ^ usedma] =
+			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
+		}
+		devpriv->chanlist[(2 * n_chan) ^ usedma] =
+						devpriv->chanlist[0 ^ usedma];
+						/* for 32bit operations */
+		useeos = 2;
+	} else {
+		useeos = 1;
+	}
+#endif
+	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
+	/* udelay(100); important delay, or first sample will be crippled */
+
+	return 1;		/* we can serve this with scan logic */
+}
 
 static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_subdevice *s,
@@ -540,69 +677,210 @@ static int move_block_from_dma(struct comedi_device *dev,
 	return 0;
 }
 
-static char pci9118_decode_error_status(struct comedi_device *dev,
-					struct comedi_subdevice *s,
-					unsigned char m)
+static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	if (m & 0x100) {
-		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
-		devpriv->ai_maskerr &= ~0x100L;
-	}
-	if (m & 0x008) {
-		comedi_error(dev,
-			     "A/D Burst Mode Overrun Status (Fatal Error!)");
-		devpriv->ai_maskerr &= ~0x008L;
-	}
-	if (m & 0x004) {
-		comedi_error(dev, "A/D Over Speed Status (Warning!)");
-		devpriv->ai_maskerr &= ~0x004L;
-	}
-	if (m & 0x002) {
-		comedi_error(dev, "A/D Overrun Status (Fatal Error!)");
-		devpriv->ai_maskerr &= ~0x002L;
-	}
-	if (m & devpriv->ai_maskharderr) {
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		pci9118_ai_cancel(dev, s);
-		comedi_event(dev, s);
-		return 1;
-	}
-
+	if (source > 3)
+		return -1;				/* incorrect source */
+	devpriv->exttrg_users |= (1 << source);
+	devpriv->IntControlReg |= Int_DTrg;
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+							/* allow INT in AMCC */
 	return 0;
 }
 
-static void pci9118_ai_munge(struct comedi_device *dev,
-			     struct comedi_subdevice *s, void *data,
-			     unsigned int num_bytes,
-			     unsigned int start_chan_index)
+static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 {
 	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, num_samples = num_bytes / sizeof(short);
-	short *array = data;
-
-	for (i = 0; i < num_samples; i++) {
-		if (devpriv->usedma)
-			array[i] = be16_to_cpu(array[i]);
-		if (devpriv->ai16bits)
-			array[i] ^= 0x8000;
-		else
-			array[i] = (array[i] >> 4) & 0x0fff;
 
+	if (source > 3)
+		return -1;			/* incorrect source */
+	devpriv->exttrg_users &= ~(1 << source);
+	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
+		devpriv->IntControlReg &= ~Int_DTrg;
+		if (!devpriv->IntControlReg)	/* all IRQ disabled */
+			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
+					(~0x00001f00),
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+						/* disable int in AMCC */
+		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
+	return 0;
 }
 
-static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
-					   struct comedi_subdevice *s,
-					   unsigned short int_adstat,
-					   unsigned int int_amcc,
-					   unsigned short int_daq)
+static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  unsigned int *tim1, unsigned int *tim2,
+				  unsigned int flags, int chans,
+				  unsigned int *div1, unsigned int *div2,
+				  char usessh, unsigned int chnsshfront)
 {
+	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
-	register short sampl;
 
-	s->async->events = 0;
+	switch (mode) {
+	case 1:
+	case 4:
+		if (*tim2 < this_board->ai_ns_min)
+			*tim2 = this_board->ai_ns_min;
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
+					  tim2, flags & TRIG_ROUND_NEAREST);
+		break;
+	case 2:
+		if (*tim2 < this_board->ai_ns_min)
+			*tim2 = this_board->ai_ns_min;
+		*div1 = *tim2 / devpriv->i8254_osc_base;
+						/* convert timer (burst) */
+		if (*div1 < this_board->ai_pacer_min)
+			*div1 = this_board->ai_pacer_min;
+		*div2 = *tim1 / devpriv->i8254_osc_base;	/* scan timer */
+		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
+		if (*div2 < chans)
+			*div2 = chans;
+
+		*tim2 = *div1 * devpriv->i8254_osc_base;
+							/* real convert timer */
+
+		if (usessh & (chnsshfront == 0))	/* use BSSH signal */
+			if (*div2 < (chans + 2))
+				*div2 = chans + 2;
+
+		*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;
+		break;
+	}
+}
+
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
+{
+	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
+	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
+/* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
+	udelay(1);
+
+	if ((mode == 1) || (mode == 2) || (mode == 4)) {
+		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
+		outl((divisor2 >> 8) & 0xff, dev->iobase + PCI9118_CNT2);
+		outl(divisor1 & 0xff, dev->iobase + PCI9118_CNT1);
+		outl((divisor1 >> 8) & 0xff, dev->iobase + PCI9118_CNT1);
+	}
+}
+
+static int pci9118_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
+{
+	struct pci9118_private *devpriv = dev->private;
+
+	if (devpriv->usedma)
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &
+			(~EN_A2P_TRANSFERS),
+			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
+	pci9118_exttrg_del(dev, EXTTRG_AI);
+	start_pacer(dev, 0, 0, 0);	/* stop 8254 counters */
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+					/*
+					 * positive triggers, no S&H, no burst,
+					 * burst stop, no post trigger,
+					 * no about trigger, trigger stop
+					 */
+	devpriv->AdControlReg = 0x00;
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+					/*
+					 * bipolar, S.E., use 8254, stop 8354,
+					 * internal trigger, soft trigger,
+					 * disable INT and DMA
+					 */
+	outl(0, dev->iobase + PCI9118_BURST);
+	outl(1, dev->iobase + PCI9118_SCANMOD);
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+
+	devpriv->ai_do = 0;
+	devpriv->usedma = 0;
+
+	devpriv->ai_act_scan = 0;
+	devpriv->ai_act_dmapos = 0;
+	s->async->cur_chan = 0;
+	s->async->inttrig = NULL;
+	devpriv->ai_buf_ptr = 0;
+	devpriv->ai_neverending = 0;
+	devpriv->dma_actbuf = 0;
+
+	if (!devpriv->IntControlReg)
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+							/* allow INT in AMCC */
+
+	return 0;
+}
+
+static char pci9118_decode_error_status(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					unsigned char m)
+{
+	struct pci9118_private *devpriv = dev->private;
+
+	if (m & 0x100) {
+		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x100L;
+	}
+	if (m & 0x008) {
+		comedi_error(dev,
+			     "A/D Burst Mode Overrun Status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x008L;
+	}
+	if (m & 0x004) {
+		comedi_error(dev, "A/D Over Speed Status (Warning!)");
+		devpriv->ai_maskerr &= ~0x004L;
+	}
+	if (m & 0x002) {
+		comedi_error(dev, "A/D Overrun Status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x002L;
+	}
+	if (m & devpriv->ai_maskharderr) {
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		pci9118_ai_cancel(dev, s);
+		comedi_event(dev, s);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void pci9118_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s, void *data,
+			     unsigned int num_bytes,
+			     unsigned int start_chan_index)
+{
+	struct pci9118_private *devpriv = dev->private;
+	unsigned int i, num_samples = num_bytes / sizeof(short);
+	short *array = data;
+
+	for (i = 0; i < num_samples; i++) {
+		if (devpriv->usedma)
+			array[i] = be16_to_cpu(array[i]);
+		if (devpriv->ai16bits)
+			array[i] ^= 0x8000;
+		else
+			array[i] = (array[i] >> 4) & 0x0fff;
+
+	}
+}
+
+static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
+					   struct comedi_subdevice *s,
+					   unsigned short int_adstat,
+					   unsigned int int_amcc,
+					   unsigned short int_daq)
+{
+	struct pci9118_private *devpriv = dev->private;
+	register short sampl;
+
+	s->async->events = 0;
 
 	if (int_adstat & devpriv->ai_maskerr)
 		if (pci9118_decode_error_status(dev, s, int_adstat))
@@ -1581,306 +1859,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
-static int check_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int frontadd, int backadd)
-{
-	const struct boardtype *this_board = comedi_board(dev);
-	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, differencial = 0, bipolar = 0;
-
-	/* correct channel and range number check itself comedi/range.c */
-	if (n_chan < 1) {
-		comedi_error(dev, "range/channel list is empty!");
-		return 0;
-	}
-	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		printk
-		    ("comedi%d: range/channel list is too long for "
-						"actual configuration (%d>%d)!",
-		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
-		return 0;
-	}
-
-	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/* all input must be diff */
-	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/* all input must be bipolar */
-	if (n_chan > 1)
-		for (i = 1; i < n_chan; i++) {	/* check S.E/diff */
-			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
-			    (differencial)) {
-				comedi_error(dev,
-					     "Differencial and single ended "
-						"inputs can't be mixtured!");
-				return 0;
-			}
-			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
-			    (bipolar)) {
-				comedi_error(dev,
-					     "Bipolar and unipolar ranges "
-							"can't be mixtured!");
-				return 0;
-			}
-			if (!devpriv->usemux && differencial &&
-			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
-				comedi_error(dev,
-					     "If AREF_DIFF is used then is "
-					"available only first 8 channels!");
-				return 0;
-			}
-		}
-
-	return 1;
-}
-
-static int setup_channel_list(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int n_chan,
-			      unsigned int *chanlist, int rot, int frontadd,
-			      int backadd, int usedma, char useeos)
-{
-	struct pci9118_private *devpriv = dev->private;
-	unsigned int i, differencial = 0, bipolar = 0;
-	unsigned int scanquad, gain, ssh = 0x00;
-
-	if (usedma == 1) {
-		rot = 8;
-		usedma = 0;
-	}
-
-	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/* all input must be diff */
-	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/* all input must be bipolar */
-
-	/* All is ok, so we can setup channel/range list */
-
-	if (!bipolar) {
-		devpriv->AdControlReg |= AdControl_UniP;
-							/* set unibipolar */
-	} else {
-		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);
-							/* enable bipolar */
-	}
-
-	if (differencial) {
-		devpriv->AdControlReg |= AdControl_Diff;
-							/* enable diff inputs */
-	} else {
-		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);
-						/* set single ended inputs */
-	}
-
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
-								/* setup mode */
-
-	outl(2, dev->iobase + PCI9118_SCANMOD);
-					/* gods know why this sequence! */
-	outl(0, dev->iobase + PCI9118_SCANMOD);
-	outl(1, dev->iobase + PCI9118_SCANMOD);
-
-#ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlistlen = n_chan;
-	for (i = 0; i < (PCI9118_CHANLEN + 1); i++)
-		devpriv->chanlist[i] = 0x55aa;
-#endif
-
-	if (frontadd) {		/* insert channels for S&H */
-		ssh = devpriv->softsshsample;
-		for (i = 0; i < frontadd; i++) {
-						/* store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);
-						/* get channel number; */
-			gain = CR_RANGE(chanlist[0]);
-						/* get gain number */
-			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-			ssh = devpriv->softsshhold;
-		}
-	}
-
-	for (i = 0; i < n_chan; i++) {	/* store range list to card */
-		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
-#ifdef PCI9118_PARANOIDCHECK
-		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
-#endif
-		gain = CR_RANGE(chanlist[i]);		/* get gain number */
-		scanquad |= ((gain & 0x03) << 8);
-		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-	}
-
-	if (backadd) {		/* insert channels for fit onto 32bit DMA */
-		for (i = 0; i < backadd; i++) {	/* store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);
-							/* get channel number */
-			gain = CR_RANGE(chanlist[0]);	/* get gain number */
-			scanquad |= ((gain & 0x03) << 8);
-			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-		}
-	}
-#ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
-						/* for 32bit operations */
-	if (useeos) {
-		for (i = 1; i < n_chan; i++) {	/* store range list to card */
-			devpriv->chanlist[(n_chan + i) ^ usedma] =
-			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
-		}
-		devpriv->chanlist[(2 * n_chan) ^ usedma] =
-						devpriv->chanlist[0 ^ usedma];
-						/* for 32bit operations */
-		useeos = 2;
-	} else {
-		useeos = 1;
-	}
-#endif
-	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
-	/* udelay(100); important delay, or first sample will be crippled */
-
-	return 1;		/* we can serve this with scan logic */
-}
-
-static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  unsigned int *tim1, unsigned int *tim2,
-				  unsigned int flags, int chans,
-				  unsigned int *div1, unsigned int *div2,
-				  char usessh, unsigned int chnsshfront)
-{
-	const struct boardtype *this_board = comedi_board(dev);
-	struct pci9118_private *devpriv = dev->private;
-
-	switch (mode) {
-	case 1:
-	case 4:
-		if (*tim2 < this_board->ai_ns_min)
-			*tim2 = this_board->ai_ns_min;
-		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
-					  tim2, flags & TRIG_ROUND_NEAREST);
-		break;
-	case 2:
-		if (*tim2 < this_board->ai_ns_min)
-			*tim2 = this_board->ai_ns_min;
-		*div1 = *tim2 / devpriv->i8254_osc_base;
-						/* convert timer (burst) */
-		if (*div1 < this_board->ai_pacer_min)
-			*div1 = this_board->ai_pacer_min;
-		*div2 = *tim1 / devpriv->i8254_osc_base;	/* scan timer */
-		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
-		if (*div2 < chans)
-			*div2 = chans;
-
-		*tim2 = *div1 * devpriv->i8254_osc_base;
-							/* real convert timer */
-
-		if (usessh & (chnsshfront == 0))	/* use BSSH signal */
-			if (*div2 < (chans + 2))
-				*div2 = chans + 2;
-
-		*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;
-		break;
-	}
-}
-
-static void start_pacer(struct comedi_device *dev, int mode,
-			unsigned int divisor1, unsigned int divisor2)
-{
-	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
-	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-/* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
-	udelay(1);
-
-	if ((mode == 1) || (mode == 2) || (mode == 4)) {
-		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
-		outl((divisor2 >> 8) & 0xff, dev->iobase + PCI9118_CNT2);
-		outl(divisor1 & 0xff, dev->iobase + PCI9118_CNT1);
-		outl((divisor1 >> 8) & 0xff, dev->iobase + PCI9118_CNT1);
-	}
-}
-
-static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
-{
-	struct pci9118_private *devpriv = dev->private;
-
-	if (source > 3)
-		return -1;				/* incorrect source */
-	devpriv->exttrg_users |= (1 << source);
-	devpriv->IntControlReg |= Int_DTrg;
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-							/* allow INT in AMCC */
-	return 0;
-}
-
-static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
-{
-	struct pci9118_private *devpriv = dev->private;
-
-	if (source > 3)
-		return -1;			/* incorrect source */
-	devpriv->exttrg_users &= ~(1 << source);
-	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
-		devpriv->IntControlReg &= ~Int_DTrg;
-		if (!devpriv->IntControlReg)	/* all IRQ disabled */
-			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
-					(~0x00001f00),
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-						/* disable int in AMCC */
-		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	}
-	return 0;
-}
-
-static int pci9118_ai_cancel(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	struct pci9118_private *devpriv = dev->private;
-
-	if (devpriv->usedma)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &
-			(~EN_A2P_TRANSFERS),
-			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
-	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	/* stop 8254 counters */
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
-					/*
-					 * positive triggers, no S&H, no burst,
-					 * burst stop, no post trigger,
-					 * no about trigger, trigger stop
-					 */
-	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
-					/*
-					 * bipolar, S.E., use 8254, stop 8354,
-					 * internal trigger, soft trigger,
-					 * disable INT and DMA
-					 */
-	outl(0, dev->iobase + PCI9118_BURST);
-	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
-
-	devpriv->ai_do = 0;
-	devpriv->usedma = 0;
-
-	devpriv->ai_act_scan = 0;
-	devpriv->ai_act_dmapos = 0;
-	s->async->cur_chan = 0;
-	s->async->inttrig = NULL;
-	devpriv->ai_buf_ptr = 0;
-	devpriv->ai_neverending = 0;
-	devpriv->dma_actbuf = 0;
-
-	if (!devpriv->IntControlReg)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
-					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-							/* allow INT in AMCC */
-
-	return 0;
-}
-
 static int pci9118_reset(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;

commit 435c8851eadb102475f8c025e6891290b47d6958
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:41:05 2012 -0700

    staging: comedi: adl_pci9118: remove commented out printk debug
    
    These debug messages should be removed from the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c0f77a617d8c..7c8ce2cbbbe3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1018,11 +1018,9 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-/* printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 					  &divisor2, &cmd->scan_begin_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
-/* printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -1034,7 +1032,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 					  &divisor2, &cmd->convert_arg,
 					  cmd->flags & TRIG_ROUND_MASK);
-/* printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -1048,7 +1045,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 					cmd->scan_begin_arg =
 					    this_board->ai_ns_min *
 					    (cmd->scan_end_arg + 2);
-/* printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
@@ -1057,7 +1053,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 					cmd->scan_begin_arg =
 					    cmd->convert_arg *
 					    cmd->chanlist_len;
-/* printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			}

commit 80f3023b452655155e1e216dfc64ce6767982d0a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:40:32 2012 -0700

    staging: comedi: adl_pci9118: remove the function separation comments
    
    These are just unnecessary whitespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cfef73964025..c0f77a617d8c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -344,10 +344,6 @@ struct pci9118_private {
 	unsigned int ai_inttrig_start;	/* TRIG_INT for start */
 };
 
-/*
-==============================================================================
-*/
-
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd,
@@ -370,9 +366,6 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int *div1, unsigned int *div2,
 				  char usessh, unsigned int chnsshfront);
 
-/*
-==============================================================================
-*/
 static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -427,9 +420,6 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_insn_write_ao(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
@@ -452,9 +442,6 @@ static int pci9118_insn_write_ao(struct comedi_device *dev,
 	return n;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_insn_read_ao(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -469,9 +456,6 @@ static int pci9118_insn_read_ao(struct comedi_device *dev,
 	return n;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_insn_bits_di(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -481,9 +465,6 @@ static int pci9118_insn_bits_di(struct comedi_device *dev,
 	return insn->n;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_insn_bits_do(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
@@ -498,9 +479,6 @@ static int pci9118_insn_bits_do(struct comedi_device *dev,
 	return insn->n;
 }
 
-/*
-==============================================================================
-*/
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -541,9 +519,6 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 	return j;
 }
 
-/*
-==============================================================================
-*/
 static int move_block_from_dma(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					short *dma_buffer,
@@ -565,9 +540,6 @@ static int move_block_from_dma(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static char pci9118_decode_error_status(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					unsigned char m)
@@ -621,9 +593,6 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 	}
 }
 
-/*
-==============================================================================
-*/
 static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 					   struct comedi_subdevice *s,
 					   unsigned short int_adstat,
@@ -675,9 +644,6 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 		comedi_event(dev, s);
 }
 
-/*
-==============================================================================
-*/
 static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     unsigned short int_adstat,
@@ -758,9 +724,6 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	comedi_event(dev, s);
 }
 
-/*
-==============================================================================
-*/
 static irqreturn_t interrupt_pci9118(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -827,9 +790,6 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_inttrig(struct comedi_device *dev,
 			      struct comedi_subdevice *s, unsigned int trignum)
 {
@@ -853,9 +813,6 @@ static int pci9118_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_cmd *cmd)
@@ -1118,9 +1075,6 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int Compute_and_setup_dma(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1273,9 +1227,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
@@ -1330,9 +1281,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
@@ -1403,9 +1351,6 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct boardtype *this_board = comedi_board(dev);
@@ -1641,9 +1586,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return ret;
 }
 
-/*
-==============================================================================
-*/
 static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
@@ -1697,9 +1639,6 @@ static int check_channel_list(struct comedi_device *dev,
 	return 1;
 }
 
-/*
-==============================================================================
-*/
 static int setup_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int rot, int frontadd,
@@ -1806,10 +1745,6 @@ static int setup_channel_list(struct comedi_device *dev,
 	return 1;		/* we can serve this with scan logic */
 }
 
-/*
-==============================================================================
-  calculate 8254 divisors if they are used for dual timing
-*/
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned int *tim1, unsigned int *tim2,
@@ -1852,9 +1787,6 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 	}
 }
 
-/*
-==============================================================================
-*/
 static void start_pacer(struct comedi_device *dev, int mode,
 			unsigned int divisor1, unsigned int divisor2)
 {
@@ -1871,9 +1803,6 @@ static void start_pacer(struct comedi_device *dev, int mode,
 	}
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1889,9 +1818,6 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 {
 	struct pci9118_private *devpriv = dev->private;
@@ -1911,9 +1837,6 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
@@ -1963,9 +1886,6 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_reset(struct comedi_device *dev)
 {
 	struct pci9118_private *devpriv = dev->private;

commit ca82a6e7e37693a84de542d06f3700037cc56525
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:39:44 2012 -0700

    staging: comedi: adl_pci9118: remove PCI9118_EXTDEBUG and DPRINTK
    
    These macros enable a bunch of function trace messages. These should
    not be in the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b9d33d8e8074..cfef73964025 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -81,18 +81,6 @@ Configuration options:
 				 * correct channel number on every 12 bit sample
 				 */
 
-#undef PCI9118_EXTDEBUG		/*
-				 * if defined then driver prints
-				 * a lot of messages
-				 */
-
-#undef DPRINTK
-#ifdef PCI9118_EXTDEBUG
-#define DPRINTK(fmt, args...) printk(fmt, ## args)
-#else
-#define DPRINTK(fmt, args...)
-#endif
-
 #define IORANGE_9118 	64	/* I hope */
 #define PCI9118_CHANLEN	255	/*
 				 * len of chanlist, some source say 256,
@@ -721,7 +709,6 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 
 	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;
 					/* number of received real samples */
-/* DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf); */
 
 	if (devpriv->dma_doublebuf) {	/*
 					 * switch DMA buffers if is used
@@ -743,17 +730,12 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 						 * how many samples is to
 						 * end of buffer
 						 */
-/*
- * DPRINTK("samps=%d m=%d %d %d\n",
- * samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr);
- */
 		sampls = m;
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
 				    samplesinbuf);
 		m = m - sampls;		/* m= how many samples was transferred */
 	}
-/* DPRINTK("YYY\n"); */
 
 	if (!devpriv->ai_neverending)
 		if (devpriv->ai_act_scan >= devpriv->ai_scans) {
@@ -793,14 +775,6 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 					/* get INT register from AMCC chip */
 
-/*
- * DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x
- * MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n",
- * int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR),
- * inl(devpriv->iobase_a+AMCC_OP_REG_MWTC),
- * inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do);
- */
-
 	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
 		return IRQ_NONE;	/* interrupt from other source */
 
@@ -1152,11 +1126,8 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	struct pci9118_private *devpriv = dev->private;
 	unsigned int dmalen0, dmalen1, i;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: Compute_and_setup_dma()\n");
 	dmalen0 = devpriv->dmabuf_size[0];
 	dmalen1 = devpriv->dmabuf_size[1];
-	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
-		devpriv->ai_data_len);
 	/* isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > (devpriv->ai_data_len)) {
 		dmalen0 = devpriv->ai_data_len & ~3L;	/*
@@ -1168,7 +1139,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 							 * align to 32bit down
 							 */
 	}
-	DPRINTK("2 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 
 	/* we want wake up every scan? */
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
@@ -1183,11 +1153,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		} else {
 			/* short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK
-				("21 dmalen0=%d ai_n_realscanlen=%d "
-							"useeoshandle=%d\n",
-				dmalen0, devpriv->ai_n_realscanlen,
-				devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
@@ -1211,11 +1176,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		} else {
 			/* short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK
-			    ("22 dmalen1=%d ai_n_realscanlen=%d "
-							"useeoshandle=%d\n",
-			     dmalen1, devpriv->ai_n_realscanlen,
-			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
@@ -1228,7 +1188,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		}
 	}
 
-	DPRINTK("3 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 	/* transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
 		/* if it's possible then align DMA buffers to length of scan */
@@ -1255,15 +1214,9 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			if (dmalen0 >
 			    ((devpriv->ai_n_realscanlen << 1) *
 			     devpriv->ai_scans)) {
-				DPRINTK
-				    ("3.0 ai_n_realscanlen=%d ai_scans=%d\n",
-				     devpriv->ai_n_realscanlen,
-				     devpriv->ai_scans);
 				dmalen0 =
 				    (devpriv->ai_n_realscanlen << 1) *
 				    devpriv->ai_scans;
-				DPRINTK("3.1 dmalen0=%d dmalen1=%d\n", dmalen0,
-					dmalen1);
 				dmalen0 &= ~3L;
 			} else {	/*
 					 * fits whole measure into
@@ -1275,21 +1228,16 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 					dmalen1 =
 					    (devpriv->ai_n_realscanlen << 1) *
 					    devpriv->ai_scans - dmalen0;
-				DPRINTK("3.2 dmalen0=%d dmalen1=%d\n", dmalen0,
-					dmalen1);
 				dmalen1 &= ~3L;
 			}
 		}
 	}
 
-	DPRINTK("4 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
-
 	/* these DMA buffer size will be used */
 	devpriv->dma_actbuf = 0;
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
 
-	DPRINTK("5 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 #if 0
 	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =
@@ -1322,7 +1270,6 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 						/* allow bus mastering */
 
-	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
 	return 0;
 }
 
@@ -1334,8 +1281,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
-		dev->minor, devpriv->ai_do);
 	switch (devpriv->ai_do) {
 	case 1:
 		devpriv->AdControlReg |= AdControl_TmrTr;
@@ -1382,7 +1327,6 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
 
-	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_docmd_sampl()\n");
 	return 0;
 }
 
@@ -1394,8 +1338,6 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 {
 	struct pci9118_private *devpriv = dev->private;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
-		dev->minor, devpriv->ai_do, devpriv->usedma);
 	Compute_and_setup_dma(dev);
 
 	switch (devpriv->ai_do) {
@@ -1458,7 +1400,6 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
 	}
 
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma()\n");
 	return 0;
 }
 
@@ -1473,7 +1414,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int addchans = 0;
 	int ret = 0;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_cmd(%d,)\n", dev->minor);
 	devpriv->ai12_startstop = 0;
 	devpriv->ai_flags = cmd->flags;
 	devpriv->ai_n_chan = cmd->chanlist_len;
@@ -1522,10 +1462,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->usessh = 0;
 				/*  no */
 
-	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
-		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
-		devpriv->ai12_startstop);
-
 	/*
 	 * use additional sample at end of every scan
 	 * to satisty DMA 32 bit transfer?
@@ -1606,12 +1542,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
 				      devpriv->ai_n_chan);
 
-	DPRINTK("2 usedma=%d realscan=%d af=%u n_chan=%d ab=%d n_scanlen=%d\n",
-		devpriv->usedma,
-		devpriv->ai_n_realscanlen, devpriv->ai_add_front,
-		devpriv->ai_n_chan, devpriv->ai_add_back,
-		devpriv->ai_n_scanlen);
-
 	/* check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
 				devpriv->ai_chanlist, devpriv->ai_add_front,
@@ -1708,7 +1638,6 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	else
 		ret = pci9118_ai_docmd_sampl(dev, s);
 
-	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_cmd()\n");
 	return ret;
 }
 
@@ -1780,11 +1709,6 @@ static int setup_channel_list(struct comedi_device *dev,
 	unsigned int i, differencial = 0, bipolar = 0;
 	unsigned int scanquad, gain, ssh = 0x00;
 
-	DPRINTK
-	    ("adl_pci9118 EDBG: BGN: setup_channel_list"
-						"(%d,.,%d,.,%d,%d,%d,%d)\n",
-	     dev->minor, n_chan, rot, frontadd, backadd, usedma);
-
 	if (usedma == 1) {
 		rot = 8;
 		usedma = 0;
@@ -1829,7 +1753,6 @@ static int setup_channel_list(struct comedi_device *dev,
 
 	if (frontadd) {		/* insert channels for S&H */
 		ssh = devpriv->softsshsample;
-		DPRINTK("FA: %04x: ", ssh);
 		for (i = 0; i < frontadd; i++) {
 						/* store range list to card */
 			scanquad = CR_CHAN(chanlist[0]);
@@ -1838,13 +1761,10 @@ static int setup_channel_list(struct comedi_device *dev,
 						/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-			DPRINTK("%02x ", scanquad | ssh);
 			ssh = devpriv->softsshhold;
 		}
-		DPRINTK("\n ");
 	}
 
-	DPRINTK("SL: ", ssh);
 	for (i = 0; i < n_chan; i++) {	/* store range list to card */
 		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
 #ifdef PCI9118_PARANOIDCHECK
@@ -1853,21 +1773,16 @@ static int setup_channel_list(struct comedi_device *dev,
 		gain = CR_RANGE(chanlist[i]);		/* get gain number */
 		scanquad |= ((gain & 0x03) << 8);
 		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-		DPRINTK("%02x ", scanquad | ssh);
 	}
-	DPRINTK("\n ");
 
 	if (backadd) {		/* insert channels for fit onto 32bit DMA */
-		DPRINTK("BA: %04x: ", ssh);
 		for (i = 0; i < backadd; i++) {	/* store range list to card */
 			scanquad = CR_CHAN(chanlist[0]);
 							/* get channel number */
 			gain = CR_RANGE(chanlist[0]);	/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
-			DPRINTK("%02x ", scanquad | ssh);
 		}
-		DPRINTK("\n ");
 	}
 #ifdef PCI9118_PARANOIDCHECK
 	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
@@ -1884,18 +1799,10 @@ static int setup_channel_list(struct comedi_device *dev,
 	} else {
 		useeos = 1;
 	}
-#ifdef PCI9118_EXTDEBUG
-	DPRINTK("CHL: ");
-	for (i = 0; i <= (useeos * n_chan); i++)
-		DPRINTK("%04x ", devpriv->chanlist[i]);
-
-	DPRINTK("\n ");
-#endif
 #endif
 	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
 	/* udelay(100); important delay, or first sample will be crippled */
 
-	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
 	return 1;		/* we can serve this with scan logic */
 }
 
@@ -1913,10 +1820,6 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 	const struct boardtype *this_board = comedi_board(dev);
 	struct pci9118_private *devpriv = dev->private;
 
-	DPRINTK
-	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors"
-					"(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
-	     mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
 	switch (mode) {
 	case 1:
 	case 4:
@@ -1924,32 +1827,18 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 			*tim2 = this_board->ai_ns_min;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
 					  tim2, flags & TRIG_ROUND_NEAREST);
-		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u\n",
-			devpriv->i8254_osc_base, *div1, *div2, *tim1);
 		break;
 	case 2:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
-		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		*div1 = *tim2 / devpriv->i8254_osc_base;
 						/* convert timer (burst) */
-		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		if (*div1 < this_board->ai_pacer_min)
 			*div1 = this_board->ai_pacer_min;
-		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		*div2 = *tim1 / devpriv->i8254_osc_base;	/* scan timer */
-		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
-		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		if (*div2 < chans)
 			*div2 = chans;
-		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 
 		*tim2 = *div1 * devpriv->i8254_osc_base;
 							/* real convert timer */
@@ -1958,15 +1847,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 
-		DPRINTK("7 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
-			*tim1, *tim2);
 		*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;
-		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u timer2=%u\n",
-			devpriv->i8254_osc_base, *div1, *div2, *tim1, *tim2);
 		break;
 	}
-	DPRINTK("adl_pci9118 EDBG: END: pci9118_calc_divisors(%u,%u)\n",
-		*div1, *div2);
 }
 
 /*

commit ae34f6aa4edff204b4a7b36ca20b576da3d857b3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Sep 11 16:39:10 2012 -0700

    staging: comedi: adl_pci9118: remove devpriv and this_board macros
    
    These macros rely on a local variable having a specific name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index fdb0f5daa2aa..b9d33d8e8074 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -356,9 +356,6 @@ struct pci9118_private {
 	unsigned int ai_inttrig_start;	/* TRIG_INT for start */
 };
 
-#define devpriv ((struct pci9118_private *)dev->private)
-#define this_board ((struct boardtype *)dev->board_ptr)
-
 /*
 ==============================================================================
 */
@@ -392,7 +389,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-
+	struct pci9118_private *devpriv = dev->private;
 	int n, timeout;
 
 	devpriv->AdControlReg = AdControl_Int & 0xff;
@@ -449,6 +446,7 @@ static int pci9118_insn_write_ao(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct pci9118_private *devpriv = dev->private;
 	int n, chanreg, ch;
 
 	ch = CR_CHAN(insn->chanspec);
@@ -473,6 +471,7 @@ static int pci9118_insn_read_ao(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct pci9118_private *devpriv = dev->private;
 	int n, chan;
 
 	chan = CR_CHAN(insn->chanspec);
@@ -516,6 +515,8 @@ static int pci9118_insn_bits_do(struct comedi_device *dev,
 */
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	devpriv->AdFunctionReg =
 	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
@@ -533,6 +534,7 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 					  short *dma_buffer,
 					  unsigned int num_samples)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
 	    stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
@@ -559,6 +561,7 @@ static int move_block_from_dma(struct comedi_device *dev,
 					short *dma_buffer,
 					unsigned int num_samples)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
@@ -581,6 +584,8 @@ static char pci9118_decode_error_status(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					unsigned char m)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	if (m & 0x100) {
 		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
 		devpriv->ai_maskerr &= ~0x100L;
@@ -613,6 +618,7 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 			     unsigned int num_bytes,
 			     unsigned int start_chan_index)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *array = data;
 
@@ -636,6 +642,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 					   unsigned int int_amcc,
 					   unsigned short int_daq)
 {
+	struct pci9118_private *devpriv = dev->private;
 	register short sampl;
 
 	s->async->events = 0;
@@ -689,6 +696,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 				     unsigned int int_amcc,
 				     unsigned short int_daq)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
 	if (int_amcc & MASTER_ABORT_INT) {
@@ -774,6 +782,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 static irqreturn_t interrupt_pci9118(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev->attached)
@@ -850,6 +859,8 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 static int pci9118_ai_inttrig(struct comedi_device *dev,
 			      struct comedi_subdevice *s, unsigned int trignum)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	if (trignum != devpriv->ai_inttrig_start)
 		return -EINVAL;
 
@@ -875,6 +886,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_cmd *cmd)
 {
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 	unsigned int divisor1 = 0, divisor2 = 0;
@@ -1136,6 +1149,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 */
 static int Compute_and_setup_dma(struct comedi_device *dev)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int dmalen0, dmalen1, i;
 
 	DPRINTK("adl_pci9118 EDBG: BGN: Compute_and_setup_dma()\n");
@@ -1318,6 +1332,8 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 				  struct comedi_subdevice *s)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
 	switch (devpriv->ai_do) {
@@ -1376,6 +1392,8 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 				struct comedi_subdevice *s)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
 	Compute_and_setup_dma(dev);
@@ -1449,6 +1467,8 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 */
 static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
 	int ret = 0;
@@ -1699,6 +1719,8 @@ static int check_channel_list(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int n_chan,
 			      unsigned int *chanlist, int frontadd, int backadd)
 {
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, differencial = 0, bipolar = 0;
 
 	/* correct channel and range number check itself comedi/range.c */
@@ -1754,6 +1776,7 @@ static int setup_channel_list(struct comedi_device *dev,
 			      unsigned int *chanlist, int rot, int frontadd,
 			      int backadd, int usedma, char useeos)
 {
+	struct pci9118_private *devpriv = dev->private;
 	unsigned int i, differencial = 0, bipolar = 0;
 	unsigned int scanquad, gain, ssh = 0x00;
 
@@ -1887,6 +1910,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  unsigned int *div1, unsigned int *div2,
 				  char usessh, unsigned int chnsshfront)
 {
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv = dev->private;
+
 	DPRINTK
 	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors"
 					"(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
@@ -1967,6 +1993,8 @@ static void start_pacer(struct comedi_device *dev, int mode,
 */
 static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	if (source > 3)
 		return -1;				/* incorrect source */
 	devpriv->exttrg_users |= (1 << source);
@@ -1983,6 +2011,8 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 */
 static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	if (source > 3)
 		return -1;			/* incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
@@ -2004,6 +2034,8 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 static int pci9118_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &
 			(~EN_A2P_TRANSFERS),
@@ -2053,6 +2085,8 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 */
 static int pci9118_reset(struct comedi_device *dev)
 {
+	struct pci9118_private *devpriv = dev->private;
+
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
 	inl(dev->iobase + PCI9118_INTCTRL);
@@ -2112,6 +2146,7 @@ static int pci9118_reset(struct comedi_device *dev)
 static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 					struct comedi_devconfig *it)
 {
+	const struct boardtype *this_board = comedi_board(dev);
 	struct pci_dev *pcidev = NULL;
 	int bus = it->options[0];
 	int slot = it->options[1];
@@ -2150,6 +2185,8 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
+	const struct boardtype *this_board = comedi_board(dev);
+	struct pci9118_private *devpriv;
 	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
 	int ret, pages, i;
@@ -2164,11 +2201,12 @@ static int pci9118_attach(struct comedi_device *dev,
 	else
 		master = 1;
 
-	ret = alloc_private(dev, sizeof(struct pci9118_private));
+	ret = alloc_private(dev, sizeof(*devpriv));
 	if (ret < 0) {
 		printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
+	devpriv = dev->private;
 
 	pcidev = pci9118_find_pci(dev, it);
 	if (!pcidev)
@@ -2345,8 +2383,9 @@ static int pci9118_attach(struct comedi_device *dev,
 static void pci9118_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct pci9118_private *devpriv = dev->private;
 
-	if (dev->private) {
+	if (devpriv) {
 		if (devpriv->valid)
 			pci9118_reset(dev);
 		if (dev->irq)

commit 17c7ac9144f0733ef91b64599481dfecb7d940fc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:26:16 2012 -0700

    staging: comedi: adl_pci9118: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a1f74c2590e8..fdb0f5daa2aa 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -837,7 +837,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 				}
 			}
 
-		(devpriv->int_ai_func) (dev, dev->subdevices + 0, int_adstat,
+		(devpriv->int_ai_func) (dev, &dev->subdevices[0], int_adstat,
 					int_amcc, int_daq);
 
 	}
@@ -2273,7 +2273,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
@@ -2294,7 +2294,7 @@ static int pci9118_attach(struct comedi_device *dev,
 		s->munge = pci9118_ai_munge;
 	}
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
 	s->n_chan = this_board->n_aochan;
@@ -2304,7 +2304,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	s->insn_write = pci9118_insn_write_ao;
 	s->insn_read = pci9118_insn_read_ao;
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
 	s->n_chan = 4;
@@ -2314,7 +2314,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	s->io_bits = 0;		/* all bits input */
 	s->insn_bits = pci9118_insn_bits_di;
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
 	s->n_chan = 4;

commit c945a1d1189428101c357220ee25f6adc906a7de
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:29:15 2012 -0700

    staging: comedi: adl_pci9118: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4482aabb3dcc..a1f74c2590e8 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -250,7 +250,6 @@ struct boardtype {
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
 	unsigned int master;	/* master capable */
-	struct pci_dev *pcidev;	/* ptr to actual pcidev */
 	unsigned int usemux;	/* we want to use external multiplexor! */
 #ifdef PCI9118_PARANOIDCHECK
 	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*
@@ -2151,6 +2150,7 @@ static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
+	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
 	int ret, pages, i;
 	unsigned short master;
@@ -2170,16 +2170,17 @@ static int pci9118_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	devpriv->pcidev = pci9118_find_pci(dev, it);
-	if (!devpriv->pcidev)
+	pcidev = pci9118_find_pci(dev, it);
+	if (!pcidev)
 		return -EIO;
+	comedi_set_hw_dev(dev, &pcidev->dev);
 
 	if (master)
-		pci_set_master(devpriv->pcidev);
+		pci_set_master(pcidev);
 
-	irq = devpriv->pcidev->irq;
-	devpriv->iobase_a = pci_resource_start(devpriv->pcidev, 0);
-	dev->iobase = pci_resource_start(devpriv->pcidev, 2);
+	irq = pcidev->irq;
+	devpriv->iobase_a = pci_resource_start(pcidev, 0);
+	dev->iobase = pci_resource_start(pcidev, 2);
 
 	dev->board_name = this_board->name;
 
@@ -2264,8 +2265,8 @@ static int pci9118_attach(struct comedi_device *dev,
 
 	printk(".\n");
 
-	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
-	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);
+	pci_read_config_word(pcidev, PCI_COMMAND, &u16w);
+	pci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);
 				/* Enable parity check for parity error */
 
 	ret = comedi_alloc_subdevices(dev, 4);
@@ -2343,17 +2344,13 @@ static int pci9118_attach(struct comedi_device *dev,
 
 static void pci9118_detach(struct comedi_device *dev)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+
 	if (dev->private) {
 		if (devpriv->valid)
 			pci9118_reset(dev);
 		if (dev->irq)
 			free_irq(dev->irq, dev);
-		if (devpriv->pcidev) {
-			if (dev->iobase)
-				comedi_pci_disable(devpriv->pcidev);
-
-			pci_dev_put(devpriv->pcidev);
-		}
 		if (devpriv->dmabuf_virt[0])
 			free_pages((unsigned long)devpriv->dmabuf_virt[0],
 				   devpriv->dmabuf_pages[0]);
@@ -2361,6 +2358,12 @@ static void pci9118_detach(struct comedi_device *dev)
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
 				   devpriv->dmabuf_pages[1]);
 	}
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+
+		pci_dev_put(pcidev);
+	}
 }
 
 static const struct boardtype boardtypes[] = {

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9a7b6a5797bb..4482aabb3dcc 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -492,7 +492,7 @@ static int pci9118_insn_bits_di(struct comedi_device *dev,
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
-	return 2;
+	return insn->n;
 }
 
 /*
@@ -509,7 +509,7 @@ static int pci9118_insn_bits_do(struct comedi_device *dev,
 	}
 	data[1] = s->state;
 
-	return 2;
+	return insn->n;
 }
 
 /*

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ebd8b8ec8c31..9a7b6a5797bb 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2269,7 +2269,7 @@ static int pci9118_attach(struct comedi_device *dev,
 				/* Enable parity check for parity error */
 
 	ret = comedi_alloc_subdevices(dev, 4);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5a5c903f5e03..ebd8b8ec8c31 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2268,7 +2268,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);
 				/* Enable parity check for parity error */
 
-	ret = alloc_subdevices(dev, 4);
+	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret < 0)
 		return ret;
 

commit 0bdf8ec0a57e5c4f90f4d6e83938f24653360d84
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Jun 7 17:31:19 2012 -0700

    staging: comedi: adl_pci9118: if test should use logical AND not bitwise AND
    
    This quiets a couple sparse warnings about:
    
    warning: dubious: !x & y
    
    Also, remove the unnecessary parentheses around the variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3670ebdbcd81..5a5c903f5e03 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1735,7 +1735,7 @@ static int check_channel_list(struct comedi_device *dev,
 							"can't be mixtured!");
 				return 0;
 			}
-			if ((!devpriv->usemux) & (differencial) &
+			if (!devpriv->usemux && differencial &&
 			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
 				comedi_error(dev,
 					     "If AREF_DIFF is used then is "

commit bc04bec0e0c982dfc90e206ea51f19bd650ccee2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun May 27 01:45:19 2012 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typo in comments within staging/comedi.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f2135bfca290..3670ebdbcd81 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -299,7 +299,7 @@ struct pci9118_private {
 	short *ai_data;
 	short ao_data[2];			/* data output buffer */
 	unsigned int ai_scans;			/* number of scans to do */
-	char dma_doublebuf;			/* we can use double buffring */
+	char dma_doublebuf;			/* we can use double buffering */
 	unsigned int dma_actbuf;		/* which buffer is used now */
 	short *dmabuf_virt[2];			/*
 						 * pointers to begin of

commit 93b6e4790ecd3025a1a38d3758ee1ac0b264799c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed May 23 16:34:58 2012 -0700

    staging: comedi: adl_pci9118: factor out the find PCI device code
    
    Factor out the code that finds a matching PCI device from attach
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index aa4244e5f918..f2135bfca290 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2110,6 +2110,44 @@ static int pci9118_reset(struct comedi_device *dev)
 	return 0;
 }
 
+static struct pci_dev *pci9118_find_pci(struct comedi_device *dev,
+					struct comedi_devconfig *it)
+{
+	struct pci_dev *pcidev = NULL;
+	int bus = it->options[0];
+	int slot = it->options[1];
+
+	for_each_pci_dev(pcidev) {
+		if (pcidev->vendor != PCI_VENDOR_ID_AMCC)
+			continue;
+		if (pcidev->device != this_board->device_id)
+			continue;
+		if (bus || slot) {
+			/* requested particular bus/slot */
+			if (pcidev->bus->number != bus ||
+			    PCI_SLOT(pcidev->devfn) != slot)
+				continue;
+		}
+		/*
+		 * Look for device that isn't in use.
+		 * Enable PCI device and request regions.
+		 */
+		if (comedi_pci_enable(pcidev, "adl_pci9118"))
+			continue;
+		printk(KERN_ERR ", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx",
+			pcidev->bus->number,
+			PCI_SLOT(pcidev->devfn),
+			PCI_FUNC(pcidev->devfn),
+			(unsigned long)pci_resource_start(pcidev, 2),
+			(unsigned long)pci_resource_start(pcidev, 0));
+		return pcidev;
+	}
+	printk(KERN_ERR
+		"comedi%d: no supported board found! (req. bus/slot : %d/%d)\n",
+		dev->minor, bus, slot);
+	return NULL;
+}
+
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
@@ -2117,17 +2155,10 @@ static int pci9118_attach(struct comedi_device *dev,
 	int ret, pages, i;
 	unsigned short master;
 	unsigned int irq;
-	unsigned long iobase_a, iobase_9;
-	struct pci_dev *pcidev;
-	int opt_bus, opt_slot;
-	const char *errstr;
-	unsigned char pci_bus, pci_slot, pci_func;
 	u16 u16w;
 
 	printk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);
 
-	opt_bus = it->options[0];
-	opt_slot = it->options[1];
 	if (it->options[3] & 1)
 		master = 0;	/* user don't want use bus master */
 	else
@@ -2139,61 +2170,19 @@ static int pci9118_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	}
 
-	/* Look for matching PCI device */
-	errstr = "not found!";
-	pcidev = NULL;
-	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
-						this_board->device_id,
-						pcidev))) {
-		/* Found matching vendor/device. */
-		if (opt_bus || opt_slot) {
-			/* Check bus/slot. */
-			if (opt_bus != pcidev->bus->number
-			    || opt_slot != PCI_SLOT(pcidev->devfn))
-				continue;	/* no match */
-		}
-		/*
-		 * Look for device that isn't in use.
-		 * Enable PCI device and request regions.
-		 */
-		if (comedi_pci_enable(pcidev, "adl_pci9118")) {
-			errstr =
-			    "failed to enable PCI device and request regions!";
-			continue;
-		}
-		break;
-	}
-
-	if (!pcidev) {
-		if (opt_bus || opt_slot) {
-			printk(KERN_ERR " - Card at b:s %d:%d %s\n",
-			       opt_bus, opt_slot, errstr);
-		} else {
-			printk(KERN_ERR " - Card %s\n", errstr);
-		}
+	devpriv->pcidev = pci9118_find_pci(dev, it);
+	if (!devpriv->pcidev)
 		return -EIO;
-	}
 
 	if (master)
-		pci_set_master(pcidev);
+		pci_set_master(devpriv->pcidev);
 
+	irq = devpriv->pcidev->irq;
+	devpriv->iobase_a = pci_resource_start(devpriv->pcidev, 0);
+	dev->iobase = pci_resource_start(devpriv->pcidev, 2);
 
-	pci_bus = pcidev->bus->number;
-	pci_slot = PCI_SLOT(pcidev->devfn);
-	pci_func = PCI_FUNC(pcidev->devfn);
-	irq = pcidev->irq;
-	iobase_a = pci_resource_start(pcidev, 0);
-	iobase_9 = pci_resource_start(pcidev, 2);
-
-	printk(KERN_ERR ", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus,
-				pci_slot, pci_func, iobase_9, iobase_a);
-
-	dev->iobase = iobase_9;
 	dev->board_name = this_board->name;
 
-	devpriv->pcidev = pcidev;
-	devpriv->iobase_a = iobase_a;
-
 	pci9118_reset(dev);
 
 	if (it->options[3] & 2)

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 78645863297b..aa4244e5f918 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -71,7 +71,6 @@ Configuration options:
 
 #include "amcc_s5933.h"
 #include "8253.h"
-#include "comedi_pci.h"
 #include "comedi_fc.h"
 
 #define PCI_VENDOR_ID_AMCC	0x10e8

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dd9dfec5384c..78645863297b 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2353,7 +2353,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	return 0;
 }
 
-static int pci9118_detach(struct comedi_device *dev)
+static void pci9118_detach(struct comedi_device *dev)
 {
 	if (dev->private) {
 		if (devpriv->valid)
@@ -2373,8 +2373,6 @@ static int pci9118_detach(struct comedi_device *dev)
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
 				   devpriv->dmabuf_pages[1]);
 	}
-
-	return 0;
 }
 
 static const struct boardtype boardtypes[] = {

commit 618fc38f0047db1a3dbaf221d236b67deb5ae944
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 13:42:04 2012 -0700

    staging: comedi: refactor adl_pci9118 driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    While moving the struct boardtype, convert it to C99 initializers
    to improve code readability. This results is a slight increase in
    the total lines of code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5b845734fe83..dd9dfec5384c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -221,10 +221,6 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 					 * of BIP/UNI ranges
 					 */
 
-static int pci9118_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it);
-static int pci9118_detach(struct comedi_device *dev);
-
 struct boardtype {
 	const char *name;		/* board name */
 	int vendor_id;			/* PCI vendor a device ID of card */
@@ -252,79 +248,6 @@ struct boardtype {
 
 };
 
-static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
-	{ 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, pci9118_pci_table);
-
-static const struct boardtype boardtypes[] = {
-	{"pci9118dg", PCI_VENDOR_ID_AMCC, 0x80d9,
-	 AMCC_OP_REG_SIZE, IORANGE_9118,
-	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-	 &range_pci9118dg_hr, &range_bipolar10,
-	 3000, 12, 512},
-	{"pci9118hg", PCI_VENDOR_ID_AMCC, 0x80d9,
-	 AMCC_OP_REG_SIZE, IORANGE_9118,
-	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-	 &range_pci9118hg, &range_bipolar10,
-	 3000, 12, 512},
-	{"pci9118hr", PCI_VENDOR_ID_AMCC, 0x80d9,
-	 AMCC_OP_REG_SIZE, IORANGE_9118,
-	 16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
-	 &range_pci9118dg_hr, &range_bipolar10,
-	 10000, 40, 512},
-};
-
-static struct comedi_driver driver_pci9118 = {
-	.driver_name = "adl_pci9118",
-	.module = THIS_MODULE,
-	.attach = pci9118_attach,
-	.detach = pci9118_detach,
-	.num_names = ARRAY_SIZE(boardtypes),
-	.board_name = &boardtypes[0].name,
-	.offset = sizeof(struct boardtype),
-};
-
-static int __devinit driver_pci9118_pci_probe(struct pci_dev *dev,
-					      const struct pci_device_id *ent)
-{
-	return comedi_pci_auto_config(dev, &driver_pci9118);
-}
-
-static void __devexit driver_pci9118_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver driver_pci9118_pci_driver = {
-	.id_table = pci9118_pci_table,
-	.probe = &driver_pci9118_pci_probe,
-	.remove = __devexit_p(&driver_pci9118_pci_remove)
-};
-
-static int __init driver_pci9118_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_pci9118);
-	if (retval < 0)
-		return retval;
-
-	driver_pci9118_pci_driver.name = (char *)driver_pci9118.driver_name;
-	return pci_register_driver(&driver_pci9118_pci_driver);
-}
-
-static void __exit driver_pci9118_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_pci9118_pci_driver);
-	comedi_driver_unregister(&driver_pci9118);
-}
-
-module_init(driver_pci9118_init_module);
-module_exit(driver_pci9118_cleanup_module);
-
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */
 	unsigned int master;	/* master capable */
@@ -2188,9 +2111,6 @@ static int pci9118_reset(struct comedi_device *dev)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
@@ -2433,9 +2353,6 @@ static int pci9118_attach(struct comedi_device *dev,
 	return 0;
 }
 
-/*
-==============================================================================
-*/
 static int pci9118_detach(struct comedi_device *dev)
 {
 	if (dev->private) {
@@ -2460,9 +2377,98 @@ static int pci9118_detach(struct comedi_device *dev)
 	return 0;
 }
 
-/*
-==============================================================================
-*/
+static const struct boardtype boardtypes[] = {
+	{
+		.name		= "pci9118dg",
+		.vendor_id	= PCI_VENDOR_ID_AMCC,
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0x0fff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118dg_hr,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 3000,
+		.ai_pacer_min	= 12,
+		.half_fifo_size	= 512,
+	}, {
+		.name		= "pci9118hg",
+		.vendor_id	= PCI_VENDOR_ID_AMCC,
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0x0fff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118hg,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 3000,
+		.ai_pacer_min	= 12,
+		.half_fifo_size	= 512,
+	}, {
+		.name		= "pci9118hr",
+		.vendor_id	= PCI_VENDOR_ID_AMCC,
+		.device_id	= 0x80d9,
+		.iorange_amcc	= AMCC_OP_REG_SIZE,
+		.iorange_9118	= IORANGE_9118,
+		.n_aichan	= 16,
+		.n_aichand	= 8,
+		.mux_aichan	= 256,
+		.n_aichanlist	= PCI9118_CHANLEN,
+		.n_aochan	= 2,
+		.ai_maxdata	= 0xffff,
+		.ao_maxdata	= 0x0fff,
+		.rangelist_ai	= &range_pci9118dg_hr,
+		.rangelist_ao	= &range_bipolar10,
+		.ai_ns_min	= 10000,
+		.ai_pacer_min	= 40,
+		.half_fifo_size	= 512,
+	},
+};
+
+static struct comedi_driver adl_pci9118_driver = {
+	.driver_name	= "adl_pci9118",
+	.module		= THIS_MODULE,
+	.attach		= pci9118_attach,
+	.detach		= pci9118_detach,
+	.num_names	= ARRAY_SIZE(boardtypes),
+	.board_name	= &boardtypes[0].name,
+	.offset		= sizeof(struct boardtype),
+};
+
+static int __devinit adl_pci9118_pci_probe(struct pci_dev *dev,
+					   const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &adl_pci9118_driver);
+}
+
+static void __devexit adl_pci9118_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(adl_pci9118_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, adl_pci9118_pci_table);
+
+static struct pci_driver adl_pci9118_pci_driver = {
+	.name		= "adl_pci9118",
+	.id_table	= adl_pci9118_pci_table,
+	.probe		= adl_pci9118_pci_probe,
+	.remove		= __devexit_p(adl_pci9118_pci_remove),
+};
+module_comedi_pci_driver(adl_pci9118_driver, adl_pci9118_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 542038f4df5a9d5d806a4af8725d2d21c4423a15
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 20 12:05:04 2012 -0700

    staging: comedi: use ARRAY_SIZE instead of custom n_boardtypes macros
    
    The n_boardtypes macros are simply open-coded versions of the kernels
    ARRAY_SIZE macro. Use the kernel provided macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cfe164a67ee9..5b845734fe83 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -277,14 +277,12 @@ static const struct boardtype boardtypes[] = {
 	 10000, 40, 512},
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
-
 static struct comedi_driver driver_pci9118 = {
 	.driver_name = "adl_pci9118",
 	.module = THIS_MODULE,
 	.attach = pci9118_attach,
 	.detach = pci9118_detach,
-	.num_names = n_boardtypes,
+	.num_names = ARRAY_SIZE(boardtypes),
 	.board_name = &boardtypes[0].name,
 	.offset = sizeof(struct boardtype),
 };

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index f17654e44aef..cfe164a67ee9 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -292,7 +292,7 @@ static struct comedi_driver driver_pci9118 = {
 static int __devinit driver_pci9118_pci_probe(struct pci_dev *dev,
 					      const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_pci9118.driver_name);
+	return comedi_pci_auto_config(dev, &driver_pci9118);
 }
 
 static void __devexit driver_pci9118_pci_remove(struct pci_dev *dev)

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 08b71d9974b6..f17654e44aef 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -67,6 +67,7 @@ Configuration options:
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 
 #include "amcc_s5933.h"
 #include "8253.h"

commit 95cd17c9f3734091a5811fabbd778e3f7b1f0789
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 10 14:31:35 2011 -0700

    staging: Remove unnecessary semicolons when switch (foo) {...};
    
    Done via perl script:
    
    $ cat remove_semi_switch.pl
    my $match_balanced_parentheses = qr/(\((?:[^\(\)]++|(?-1))*\))/;
    my $match_balanced_braces      = qr/(\{(?:[^\{\}]++|(?-1))*\})/;
    
    foreach my $file (@ARGV) {
        my $f;
        my $text;
        my $oldtext;
    
        next if ((-d $file));
    
        open($f, '<', $file)
            or die "$P: Can't open $file for read\n";
        $oldtext = do { local($/) ; <$f> };
        close($f);
    
        next if ($oldtext eq "");
    
        $text = $oldtext;
    
        my $count = 0;
        do {
            $count = 0;
            $count += $text =~ s@\b(switch\s*${match_balanced_parentheses}\s*)${match_balanced_braces}\s*;@"$1$3"@egx;
        } while ($count > 0);
    
        if ($text ne $oldtext) {
            my $newfile = $file;
    
            open($f, '>', $newfile)
                or die "$P: Can't open $newfile for write\n";
            print $f $text;
            close($f);
        }
    }
    
    $
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 632d5d0721cd..08b71d9974b6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1417,7 +1417,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		comedi_error(dev,
 			     "pci9118_ai_docmd_sampl() mode number bug!\n");
 		return -EIO;
-	};
+	}
 
 	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;
 						/* transfer function */
@@ -1496,7 +1496,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	default:
 		comedi_error(dev, "pci9118_ai_docmd_dma() mode number bug!\n");
 		return -EIO;
-	};
+	}
 
 	if (devpriv->ai12_startstop) {
 		pci9118_exttrg_add(dev, EXTTRG_AI);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 766103c882ad..632d5d0721cd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -23,7 +23,7 @@ For AI:
 - If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
 - If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
 - If cmd->start_src/stop_src=TRIG_EXT then trigger input is TGIN (pin 46).
-- It is not neccessary to have cmd.scan_end_arg=cmd.chanlist_len but
+- It is not necessary to have cmd.scan_end_arg=cmd.chanlist_len but
   cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
 - If return value of cmdtest is 5 then you've bad channel list
   (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
@@ -823,7 +823,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
 				    samplesinbuf);
-		m = m - sampls;		/* m= how many samples was transfered */
+		m = m - sampls;		/* m= how many samples was transferred */
 	}
 /* DPRINTK("YYY\n"); */
 
@@ -1297,7 +1297,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	DPRINTK("3 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 	/* transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
-		/* if it's possible then allign DMA buffers to length of scan */
+		/* if it's possible then align DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *

commit beb50909a748b25eb3118cbc2942442208fd9017
Author: Maurice Dawson <mauricedawson2699@gmail.com>
Date:   Thu Oct 7 19:45:38 2010 +0100

    Staging: comedi: file: Removed braces from some statement blocks
    
    Unnecessary braces in some statement blocks
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 3e2bb14e3095..766103c882ad 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1575,12 +1575,12 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	}
 
 	/* use sample&hold signal? */
-	if (cmd->convert_src == TRIG_NOW) {
+	if (cmd->convert_src == TRIG_NOW)
 		devpriv->usessh = 1;
-	} /* yes */
-	else {
+	/* yes */
+	else
 		devpriv->usessh = 0;
-	}			/*  no */
+				/*  no */
 
 	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
 		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
@@ -1597,9 +1597,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->usedma = 1;
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
 		    (devpriv->ai_n_scanlen == 1)) {
-			if (cmd->convert_src == TRIG_NOW) {
+			if (cmd->convert_src == TRIG_NOW)
 				devpriv->ai_add_back = 1;
-			}
 			if (cmd->convert_src == TRIG_TIMER) {
 				devpriv->usedma = 0;
 					/*
@@ -1694,11 +1693,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		(cmd->scan_begin_src == TRIG_INT)) &&
 		(cmd->convert_src == TRIG_TIMER)) {
 					/* both timer is used for one time */
-		if (cmd->scan_begin_src == TRIG_EXT) {
+		if (cmd->scan_begin_src == TRIG_EXT)
 			devpriv->ai_do = 4;
-		} else {
+		else
 			devpriv->ai_do = 1;
-		}
 		pci9118_calc_divisors(devpriv->ai_do, dev, s,
 				      &cmd->scan_begin_arg, &cmd->convert_arg,
 				      devpriv->ai_flags,
@@ -2212,11 +2210,10 @@ static int pci9118_attach(struct comedi_device *dev,
 
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
-	if (it->options[3] & 1) {
+	if (it->options[3] & 1)
 		master = 0;	/* user don't want use bus master */
-	} else {
+	else
 		master = 1;
-	}
 
 	ret = alloc_private(dev, sizeof(struct pci9118_private));
 	if (ret < 0) {

commit a285bf995da256be5d96110ec0e7592cb6b2e600
Author: Maurice Dawson <mauricedawson2699@gmail.com>
Date:   Thu Sep 30 19:55:18 2010 +0100

    staging: comedi: file: Removed whitespaces before quoted newlines
    
    Unnecessary whitespaces before quoted newlines
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cb2843d34bea..3e2bb14e3095 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1234,7 +1234,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 							 * align to 32bit down
 							 */
 	}
-	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+	DPRINTK("2 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 
 	/* we want wake up every scan? */
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
@@ -1294,7 +1294,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		}
 	}
 
-	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+	DPRINTK("3 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 	/* transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
 		/* if it's possible then allign DMA buffers to length of scan */
@@ -1322,13 +1322,13 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			    ((devpriv->ai_n_realscanlen << 1) *
 			     devpriv->ai_scans)) {
 				DPRINTK
-				    ("3.0 ai_n_realscanlen=%d ai_scans=%d \n",
+				    ("3.0 ai_n_realscanlen=%d ai_scans=%d\n",
 				     devpriv->ai_n_realscanlen,
 				     devpriv->ai_scans);
 				dmalen0 =
 				    (devpriv->ai_n_realscanlen << 1) *
 				    devpriv->ai_scans;
-				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
+				DPRINTK("3.1 dmalen0=%d dmalen1=%d\n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
 			} else {	/*
@@ -1341,21 +1341,21 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 					dmalen1 =
 					    (devpriv->ai_n_realscanlen << 1) *
 					    devpriv->ai_scans - dmalen0;
-				DPRINTK("3.2 dmalen0=%d dmalen1=%d \n", dmalen0,
+				DPRINTK("3.2 dmalen0=%d dmalen1=%d\n", dmalen0,
 					dmalen1);
 				dmalen1 &= ~3L;
 			}
 		}
 	}
 
-	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+	DPRINTK("4 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 
 	/* these DMA buffer size will be used */
 	devpriv->dma_actbuf = 0;
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
 
-	DPRINTK("5 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+	DPRINTK("5 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 #if 0
 	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =

commit d6269644e1f8fc7931c4d6b86d58de7af63a5fc9
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Sep 5 21:00:24 2010 +0200

    Staging: comedi: Fix unsigned return type
    
    In each case, the function has an unsigned return type, but returns a
    negative constant to indicate an error condition.  For move_block_from_dma,
    there is only one call and the return value is dropped, so it need not be
    unsigned.  For labpc_eeprom_write, there is only one call and the result is
    stored in a signed variable, so again the unsigned return type is not
    necessary.
    
    A sematic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @exists@
    identifier f;
    constant C;
    @@
    
     unsigned f(...)
     { <+...
    *  return -C;
     ...+> }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a2bd4e6aff19..cb2843d34bea 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -634,7 +634,7 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 /*
 ==============================================================================
 */
-static unsigned int move_block_from_dma(struct comedi_device *dev,
+static int move_block_from_dma(struct comedi_device *dev,
 					struct comedi_subdevice *s,
 					short *dma_buffer,
 					unsigned int num_samples)

commit 20b6a7f3d56482085497179b77f6cd1ab1feb7ba
Author: Javier Martinez Canillas <martinez.javier@gmail.com>
Date:   Sat Aug 7 02:39:33 2010 -0400

    staging: comedi (adl_pci9118): use PCI_DEVICE() macro
    
    Use PCI_DEVICE() macro for pci table entries on comedi driver and thus improves readability.
    
    Signed-off-by: Javier Martinez Canillas <martinez.javier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index b0e39cb74774..a2bd4e6aff19 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -252,9 +252,8 @@ struct boardtype {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
-	{
-	PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80d9) },
+	{ 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, pci9118_pci_table);

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index d6c17e268ccd..b0e39cb74774 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -289,7 +289,43 @@ static struct comedi_driver driver_pci9118 = {
 	.offset = sizeof(struct boardtype),
 };
 
-COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
+static int __devinit driver_pci9118_pci_probe(struct pci_dev *dev,
+					      const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_pci9118.driver_name);
+}
+
+static void __devexit driver_pci9118_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_pci9118_pci_driver = {
+	.id_table = pci9118_pci_table,
+	.probe = &driver_pci9118_pci_probe,
+	.remove = __devexit_p(&driver_pci9118_pci_remove)
+};
+
+static int __init driver_pci9118_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_pci9118);
+	if (retval < 0)
+		return retval;
+
+	driver_pci9118_pci_driver.name = (char *)driver_pci9118.driver_name;
+	return pci_register_driver(&driver_pci9118_pci_driver);
+}
+
+static void __exit driver_pci9118_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_pci9118_pci_driver);
+	comedi_driver_unregister(&driver_pci9118);
+}
+
+module_init(driver_pci9118_init_module);
+module_exit(driver_pci9118_cleanup_module);
 
 struct pci9118_private {
 	unsigned long iobase_a;	/* base+size for AMCC chip */

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ccef549778e4..d6c17e268ccd 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -2432,3 +2432,7 @@ static int pci9118_detach(struct comedi_device *dev)
 /*
 ==============================================================================
 */
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5f35f3f19fd12226482f8b57c70d9a0f82470c87
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:08:51 2010 -0700

    Staging: comedi: adl_pci9118.c: fix unsigned problem with divisors
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index dc4bd0423e6f..ccef549778e4 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -921,7 +921,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp, divisor1 = 0, divisor2 = 0;
+	int tmp;
+	unsigned int divisor1 = 0, divisor2 = 0;
 
 	/* step 1: make sure trigger sources are trivially valid */
 

commit 47c92858446004d3cf28d8115266d631cdfd5d0a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 15:48:19 2010 -0700

    Staging: comedi: remove local pci_ids.h file
    
    It's only being used for one vendor id, so move it into
    the driver that uses it and delete the file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c7cba9579d07..dc4bd0423e6f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -63,7 +63,6 @@ Configuration options:
 
 */
 #include "../comedidev.h"
-#include "../pci_ids.h"
 
 #include <linux/delay.h>
 #include <linux/gfp.h>
@@ -74,6 +73,8 @@ Configuration options:
 #include "comedi_pci.h"
 #include "comedi_fc.h"
 
+#define PCI_VENDOR_ID_AMCC	0x10e8
+
 /* paranoid checks are broken */
 #undef PCI9118_PARANOIDCHECK	/*
 				 * if defined, then is used code which control

commit a41aec1be2b3b21c08b84fb1e70e23aab29c5820
Author: Jason Wong <tsanghan@gmail.com>
Date:   Sat Mar 27 09:48:38 2010 +0800

    Staging: comedi: adl_pci9118: fixed multiple brace coding style issues
    
    Fixed multiple coding style issues
    
    Signed-off-by: Jason Wong <tsanghan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 2205113ee435..c7cba9579d07 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -496,11 +496,11 @@ static int pci9118_insn_write_ao(struct comedi_device *dev,
 	int n, chanreg, ch;
 
 	ch = CR_CHAN(insn->chanspec);
-	if (ch) {
+	if (ch)
 		chanreg = PCI9118_DA2;
-	} else {
+	else
 		chanreg = PCI9118_DA1;
-	}
+
 
 	for (n = 0; n < insn->n; n++) {
 		outl(data[n], dev->iobase + chanreg);
@@ -663,11 +663,11 @@ static void pci9118_ai_munge(struct comedi_device *dev,
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)
 			array[i] = be16_to_cpu(array[i]);
-		if (devpriv->ai16bits) {
+		if (devpriv->ai16bits)
 			array[i] ^= 0x8000;
-		} else {
+		else
 			array[i] = (array[i] >> 4) & 0x0fff;
-		}
+
 	}
 }
 
@@ -930,20 +930,20 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 		err++;
 
 	tmp = cmd->scan_begin_src;
-	if (devpriv->master) {
+	if (devpriv->master)
 		cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
-	} else {
+	else
 		cmd->scan_begin_src &= TRIG_FOLLOW;
-	}
+
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
 	tmp = cmd->convert_src;
-	if (devpriv->master) {
+	if (devpriv->master)
 		cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
-	} else {
+	else
 		cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	}
+
 	if (!cmd->convert_src || tmp != cmd->convert_src)
 		err++;
 
@@ -1908,9 +1908,9 @@ static int setup_channel_list(struct comedi_device *dev,
 	}
 #ifdef PCI9118_EXTDEBUG
 	DPRINTK("CHL: ");
-	for (i = 0; i <= (useeos * n_chan); i++) {
+	for (i = 0; i <= (useeos * n_chan); i++)
 		DPRINTK("%04x ", devpriv->chanlist[i]);
-	}
+
 	DPRINTK("\n ");
 #endif
 #endif
@@ -2222,9 +2222,9 @@ static int pci9118_attach(struct comedi_device *dev,
 		return -EIO;
 	}
 
-	if (master) {
+	if (master)
 		pci_set_master(pcidev);
-	}
+
 
 	pci_bus = pcidev->bus->number;
 	pci_slot = PCI_SLOT(pcidev->devfn);
@@ -2335,11 +2335,11 @@ static int pci9118_attach(struct comedi_device *dev,
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
-	if (devpriv->usemux) {
+	if (devpriv->usemux)
 		s->n_chan = devpriv->usemux;
-	} else {
+	else
 		s->n_chan = this_board->n_aichan;
-	}
+
 	s->maxdata = this_board->ai_maxdata;
 	s->len_chanlist = this_board->n_aichanlist;
 	s->range_table = this_board->rangelist_ai;
@@ -2411,9 +2411,9 @@ static int pci9118_detach(struct comedi_device *dev)
 		if (dev->irq)
 			free_irq(dev->irq, dev);
 		if (devpriv->pcidev) {
-			if (dev->iobase) {
+			if (dev->iobase)
 				comedi_pci_disable(devpriv->pcidev);
-			}
+
 			pci_dev_put(devpriv->pcidev);
 		}
 		if (devpriv->dmabuf_virt[0])

commit cf8d3af5aed0d7bc40e8966b45aeced7c7bf1bef
Author: Maurice Dawson <mauricedawson2699@googlemail.com>
Date:   Fri Mar 19 14:20:10 2010 +0000

    Staging: comedi: fix KERN_facility level coding style issue in adl_pci9118.c
    
    This is a patch to the adl_pci9118.c file that fixes WARNING: printk() should include KERN_facility level found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 4f9fd7dd0cf2..2205113ee435 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -750,9 +750,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		comedi_event(dev, s);
 		return;
 	}
-
 	if (int_adstat & devpriv->ai_maskerr)
-/* if (int_adstat & 0x106) */
+					/* if (int_adstat & 0x106) */
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
@@ -2215,10 +2214,10 @@ static int pci9118_attach(struct comedi_device *dev,
 
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
-			printk(" - Card at b:s %d:%d %s\n",
+			printk(KERN_ERR " - Card at b:s %d:%d %s\n",
 			       opt_bus, opt_slot, errstr);
 		} else {
-			printk(" - Card %s\n", errstr);
+			printk(KERN_ERR " - Card %s\n", errstr);
 		}
 		return -EIO;
 	}
@@ -2234,8 +2233,8 @@ static int pci9118_attach(struct comedi_device *dev,
 	iobase_a = pci_resource_start(pcidev, 0);
 	iobase_9 = pci_resource_start(pcidev, 2);
 
-	printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
-	       pci_func, iobase_9, iobase_a);
+	printk(KERN_ERR ", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus,
+				pci_slot, pci_func, iobase_9, iobase_a);
 
 	dev->iobase = iobase_9;
 	dev->board_name = this_board->name;

commit 242467bd058f09ec05985bb09201a9cd0b1d89e5
Author: Maurice Dawson <mauricedawson2699@googlemail.com>
Date:   Thu Mar 18 14:46:37 2010 +0000

    Staging: comedi: fix 80 character coding style issue in adl_pci9118.c
    
    Fixes all over 80 character warnings in the adl_pci9118.c file found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index bed7e41445aa..4f9fd7dd0cf2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -75,9 +75,15 @@ Configuration options:
 #include "comedi_fc.h"
 
 /* paranoid checks are broken */
-#undef PCI9118_PARANOIDCHECK	/* if defined, then is used code which control correct channel number on every 12 bit sample */
+#undef PCI9118_PARANOIDCHECK	/*
+				 * if defined, then is used code which control
+				 * correct channel number on every 12 bit sample
+				 */
 
-#undef PCI9118_EXTDEBUG		/* if defined then driver prints a lot of messages */
+#undef PCI9118_EXTDEBUG		/*
+				 * if defined then driver prints
+				 * a lot of messages
+				 */
 
 #undef DPRINTK
 #ifdef PCI9118_EXTDEBUG
@@ -87,7 +93,10 @@ Configuration options:
 #endif
 
 #define IORANGE_9118 	64	/* I hope */
-#define PCI9118_CHANLEN	255	/* len of chanlist, some source say 256, but reality looks like 255 :-( */
+#define PCI9118_CHANLEN	255	/*
+				 * len of chanlist, some source say 256,
+				 * but reality looks like 255 :-(
+				 */
 
 #define PCI9118_CNT0	0x00	/* R/W: 8254 counter 0 */
 #define PCI9118_CNT1	0x04	/* R/W: 8254 counter 0 */
@@ -113,20 +122,47 @@ Configuration options:
 #define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
 #define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
 #define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
-#define	AdControl_ExtG	0x10	/* 1=8254 countrol controlled by TGIN(pin 46), 0=controled by SoftG */
-#define AdControl_ExtM	0x08	/* 1=external hardware trigger (pin 44), 0=internal trigger */
-#define AdControl_TmrTr	0x04	/* 1=8254 is iternal trigger source, 0=software trigger is source (register PCI9118_SOFTTRG) */
+#define	AdControl_ExtG	0x10	/*
+				 * 1=8254 countrol controlled by TGIN(pin 46),
+				 * 0=controlled by SoftG
+				 */
+#define AdControl_ExtM	0x08	/*
+				 * 1=external hardware trigger (pin 44),
+				 * 0=internal trigger
+				 */
+#define AdControl_TmrTr	0x04	/*
+				 * 1=8254 is iternal trigger source,
+				 * 0=software trigger is source
+				 * (register PCI9118_SOFTTRG)
+				 */
 #define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
 #define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
 
 /* bits from A/D function register (PCI9118_ADFUNC) */
-#define AdFunction_PDTrg	0x80	/* 1=positive, 0=negative digital trigger (only positive is correct) */
-#define AdFunction_PETrg	0x40	/* 1=positive, 0=negative external trigger (only positive is correct) */
+#define AdFunction_PDTrg	0x80	/*
+					 * 1=positive,
+					 * 0=negative digital trigger
+					 * (only positive is correct)
+					 */
+#define AdFunction_PETrg	0x40	/*
+					 * 1=positive,
+					 * 0=negative external trigger
+					 * (only positive is correct)
+					 */
 #define AdFunction_BSSH		0x20	/* 1=with sample&hold, 0=without */
 #define AdFunction_BM		0x10	/* 1=burst mode, 0=normal mode */
-#define AdFunction_BS		0x08	/* 1=burst mode start, 0=burst mode stop */
-#define AdFunction_PM		0x04	/* 1=post trigger mode, 0=not post trigger */
-#define AdFunction_AM		0x02	/* 1=about trigger mode, 0=not about trigger */
+#define AdFunction_BS		0x08	/*
+					 * 1=burst mode start,
+					 * 0=burst mode stop
+					 */
+#define AdFunction_PM		0x04	/*
+					 * 1=post trigger mode,
+					 * 0=not post trigger
+					 */
+#define AdFunction_AM		0x02	/*
+					 * 1=about trigger mode,
+					 * 0=not about trigger
+					 */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
 /* bits from A/D status register (PCI9118_ADSTAT) */
@@ -178,30 +214,39 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 							  }
 };
 
-#define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
+#define PCI9118_BIPOLAR_RANGES	4	/*
+					 * used for test on mixture
+					 * of BIP/UNI ranges
+					 */
 
 static int pci9118_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it);
 static int pci9118_detach(struct comedi_device *dev);
 
 struct boardtype {
-	const char *name;	/*  board name */
-	int vendor_id;		/*  PCI vendor a device ID of card */
+	const char *name;		/* board name */
+	int vendor_id;			/* PCI vendor a device ID of card */
 	int device_id;
-	int iorange_amcc;	/*  iorange for own S5933 region */
-	int iorange_9118;	/*  pass thru card region size */
-	int n_aichan;		/*  num of A/D chans */
-	int n_aichand;		/*  num of A/D chans in diff mode */
-	int mux_aichan;		/*  num of A/D chans with external multiplexor */
-	int n_aichanlist;	/*  len of chanlist */
-	int n_aochan;		/*  num of D/A chans */
-	int ai_maxdata;		/*  resolution of A/D */
-	int ao_maxdata;		/*  resolution of D/A */
-	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
-	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
-	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
-	unsigned int ai_pacer_min;	/*  minimal pacer value (c1*c2 or c1 in burst) */
-	int half_fifo_size;	/*  size of FIFO/2 */
+	int iorange_amcc;		/* iorange for own S5933 region */
+	int iorange_9118;		/* pass thru card region size */
+	int n_aichan;			/* num of A/D chans */
+	int n_aichand;			/* num of A/D chans in diff mode */
+	int mux_aichan;			/*
+					 * num of A/D chans with
+					 * external multiplexor
+					 */
+	int n_aichanlist;		/* len of chanlist */
+	int n_aochan;			/* num of D/A chans */
+	int ai_maxdata;			/* resolution of A/D */
+	int ao_maxdata;			/* resolution of D/A */
+	const struct comedi_lrange *rangelist_ai;	/* rangelist for A/D */
+	const struct comedi_lrange *rangelist_ao;	/* rangelist for D/A */
+	unsigned int ai_ns_min;		/* max sample speed of card v ns */
+	unsigned int ai_pacer_min;	/*
+					 * minimal pacer value
+					 * (c1*c2 or c1 in burst)
+					 */
+	int half_fifo_size;		/* size of FIFO/2 */
 
 };
 
@@ -246,63 +291,113 @@ static struct comedi_driver driver_pci9118 = {
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
 
 struct pci9118_private {
-	unsigned long iobase_a;	/*  base+size for AMCC chip */
-	unsigned int master;	/*  master capable */
-	struct pci_dev *pcidev;	/*  ptr to actual pcidev */
-	unsigned int usemux;	/*  we want to use external multiplexor! */
+	unsigned long iobase_a;	/* base+size for AMCC chip */
+	unsigned int master;	/* master capable */
+	struct pci_dev *pcidev;	/* ptr to actual pcidev */
+	unsigned int usemux;	/* we want to use external multiplexor! */
 #ifdef PCI9118_PARANOIDCHECK
-	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*  list of scaned channel */
-	unsigned char chanlistlen;	/*  number of scanlist */
+	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*
+							 * list of
+							 * scanned channel
+							 */
+	unsigned char chanlistlen;	/* number of scanlist */
 #endif
-	unsigned char AdControlReg;	/*  A/D control register */
-	unsigned char IntControlReg;	/*  Interrupt control register */
-	unsigned char AdFunctionReg;	/*  A/D function register */
-	char valid;		/*  driver is ok */
-	char ai_neverending;	/*  we do unlimited AI */
-	unsigned int i8254_osc_base;	/*  frequence of onboard oscilator */
-	unsigned int ai_do;	/*  what do AI? 0=nothing, 1 to 4 mode */
-	unsigned int ai_act_scan;	/*  how many scans we finished */
-	unsigned int ai_buf_ptr;	/*  data buffer ptr in samples */
-	unsigned int ai_n_chan;	/*  how many channels is measured */
-	unsigned int ai_n_scanlen;	/*  len of actual scanlist */
-	unsigned int ai_n_realscanlen;	/*  what we must transfer for one outgoing scan include front/back adds */
-	unsigned int ai_act_dmapos;	/*  position in actual real stream */
-	unsigned int ai_add_front;	/*  how many channels we must add before scan to satisfy S&H? */
-	unsigned int ai_add_back;	/*  how many channels we must add before scan to satisfy DMA? */
-	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	unsigned char AdControlReg;	/* A/D control register */
+	unsigned char IntControlReg;	/* Interrupt control register */
+	unsigned char AdFunctionReg;	/* A/D function register */
+	char valid;			/* driver is ok */
+	char ai_neverending;		/* we do unlimited AI */
+	unsigned int i8254_osc_base;	/* frequence of onboard oscilator */
+	unsigned int ai_do;		/* what do AI? 0=nothing, 1 to 4 mode */
+	unsigned int ai_act_scan;	/* how many scans we finished */
+	unsigned int ai_buf_ptr;	/* data buffer ptr in samples */
+	unsigned int ai_n_chan;		/* how many channels is measured */
+	unsigned int ai_n_scanlen;	/* len of actual scanlist */
+	unsigned int ai_n_realscanlen;	/*
+					 * what we must transfer for one
+					 * outgoing scan include front/back adds
+					 */
+	unsigned int ai_act_dmapos;	/* position in actual real stream */
+	unsigned int ai_add_front;	/*
+					 * how many channels we must add
+					 * before scan to satisfy S&H?
+					 */
+	unsigned int ai_add_back;	/*
+					 * how many channels we must add
+					 * before scan to satisfy DMA?
+					 */
+	unsigned int *ai_chanlist;	/* actual chanlist */
 	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
-	char ai12_startstop;	/*  measure can start/stop on external trigger */
-	unsigned int ai_divisor1, ai_divisor2;	/*  divisors for start of measure on external start */
+	char ai12_startstop;		/*
+					 * measure can start/stop
+					 * on external trigger
+					 */
+	unsigned int ai_divisor1, ai_divisor2;	/*
+						 * divisors for start of measure
+						 * on external start
+						 */
 	unsigned int ai_data_len;
 	short *ai_data;
-	short ao_data[2];	/*  data output buffer */
-	unsigned int ai_scans;	/*  number of scans to do */
-	char dma_doublebuf;	/*  we can use double buffring */
-	unsigned int dma_actbuf;	/*  which buffer is used now */
-	short *dmabuf_virt[2];	/*  pointers to begin of DMA buffer */
-	unsigned long dmabuf_hw[2];	/*  hw address of DMA buff */
-	unsigned int dmabuf_size[2];	/*  size of dma buffer in bytes */
-	unsigned int dmabuf_use_size[2];	/*  which size we may now used for transfer */
-	unsigned int dmabuf_used_size[2];	/*  which size was trully used */
+	short ao_data[2];			/* data output buffer */
+	unsigned int ai_scans;			/* number of scans to do */
+	char dma_doublebuf;			/* we can use double buffring */
+	unsigned int dma_actbuf;		/* which buffer is used now */
+	short *dmabuf_virt[2];			/*
+						 * pointers to begin of
+						 * DMA buffer
+						 */
+	unsigned long dmabuf_hw[2];		/* hw address of DMA buff */
+	unsigned int dmabuf_size[2];		/*
+						 * size of dma buffer in bytes
+						 */
+	unsigned int dmabuf_use_size[2];	/*
+						 * which size we may now use
+						 * for transfer
+						 */
+	unsigned int dmabuf_used_size[2];	/* which size was truly used */
 	unsigned int dmabuf_panic_size[2];
-	unsigned int dmabuf_samples[2];	/*  size in samples */
-	int dmabuf_pages[2];	/*  number of pages in buffer */
-	unsigned char cnt0_users;	/*  bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO) */
-	unsigned char exttrg_users;	/*  bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO) */
-	unsigned int cnt0_divisor;	/*  actual CNT0 divisor */
-	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	/*  ptr to actual interrupt AI function */
-	unsigned char ai16bits;	/*  =1 16 bit card */
-	unsigned char usedma;	/*  =1 use DMA transfer and not INT */
-	unsigned char useeoshandle;	/*  =1 change WAKE_EOS DMA transfer to fit on every second */
-	unsigned char usessh;	/*  =1 turn on S&H support */
-	int softsshdelay;	/*  >0 use software S&H, numer is requested delay in ns */
-	unsigned char softsshsample;	/*  polarity of S&H signal in sample state */
-	unsigned char softsshhold;	/*  polarity of S&H signal in hold state */
-	unsigned int ai_maskerr;	/*  which warning was printed */
-	unsigned int ai_maskharderr;	/*  on which error bits stops */
-	unsigned int ai_inttrig_start;	/*  TRIG_INT for start */
+	unsigned int dmabuf_samples[2];		/* size in samples */
+	int dmabuf_pages[2];			/* number of pages in buffer */
+	unsigned char cnt0_users;		/*
+						 * bit field of 8254 CNT0 users
+						 * (0-unused, 1-AO, 2-DI, 3-DO)
+						 */
+	unsigned char exttrg_users;		/*
+						 * bit field of external trigger
+						 * users(0-AI, 1-AO, 2-DI, 3-DO)
+						 */
+	unsigned int cnt0_divisor;		/* actual CNT0 divisor */
+	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *,
+		unsigned short,
+		unsigned int,
+		unsigned short);	/*
+					 * ptr to actual interrupt
+					 * AI function
+					 */
+	unsigned char ai16bits;		/* =1 16 bit card */
+	unsigned char usedma;		/* =1 use DMA transfer and not INT */
+	unsigned char useeoshandle;	/*
+					 * =1 change WAKE_EOS DMA transfer
+					 * to fit on every second
+					 */
+	unsigned char usessh;		/* =1 turn on S&H support */
+	int softsshdelay;		/*
+					 * >0 use software S&H,
+					 * numer is requested delay in ns
+					 */
+	unsigned char softsshsample;	/*
+					 * polarity of S&H signal
+					 * in sample state
+					 */
+	unsigned char softsshhold;	/*
+					 * polarity of S&H signal
+					 * in hold state
+					 */
+	unsigned int ai_maskerr;	/* which warning was printed */
+	unsigned int ai_maskharderr;	/* on which error bits stops */
+	unsigned int ai_inttrig_start;	/* TRIG_INT for start */
 };
 
 #define devpriv ((struct pci9118_private *)dev->private)
@@ -346,12 +441,19 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 	devpriv->AdControlReg = AdControl_Int & 0xff;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+						/*
+						 * positive triggers, no S&H,
+						 * no burst, burst stop,
+						 * no post trigger,
+						 * no about trigger,
+						 * trigger stop
+						 */
 
 	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))
 		return -EINVAL;
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
@@ -365,7 +467,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 
 		comedi_error(dev, "A/D insn timeout");
 		data[n] = 0;
-		outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+		outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 		return -ETIME;
 
 conv_finish:
@@ -379,7 +481,7 @@ static int pci9118_insn_read_ai(struct comedi_device *dev,
 		}
 	}
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 	return n;
 
 }
@@ -590,11 +692,13 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv->ai16bits == 0) {
-		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
+		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {
+							/* data dropout! */
 			printk
-			    ("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
-			     sampl & 0x000f,
-			     devpriv->chanlist[s->async->cur_chan]);
+			    ("comedi: A/D  SAMPL - data dropout: "
+				"received channel %d, expected %d!\n",
+				sampl & 0x000f,
+				devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 			pci9118_ai_cancel(dev, s);
 			comedi_event(dev, s);
@@ -604,11 +708,13 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 #endif
 	cfc_write_to_buffer(s, sampl);
 	s->async->cur_chan++;
-	if (s->async->cur_chan >= devpriv->ai_n_scanlen) {	/* one scan done */
+	if (s->async->cur_chan >= devpriv->ai_n_scanlen) {
+							/* one scan done */
 		s->async->cur_chan %= devpriv->ai_n_scanlen;
 		devpriv->ai_act_scan++;
 		if (!(devpriv->ai_neverending))
-			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+			if (devpriv->ai_act_scan >= devpriv->ai_scans) {
+							/* all data sampled */
 				pci9118_ai_cancel(dev, s);
 				s->async->events |= COMEDI_CB_EOA;
 			}
@@ -650,10 +756,14 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	/*  number of received real samples */
+	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;
+					/* number of received real samples */
 /* DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf); */
 
-	if (devpriv->dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
+	if (devpriv->dma_doublebuf) {	/*
+					 * switch DMA buffers if is used
+					 * double buffering
+					 */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		outl(devpriv->dmabuf_hw[next_dma_buf],
 		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
@@ -666,25 +776,32 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 	}
 
 	if (samplesinbuf) {
-		m = devpriv->ai_data_len >> 1;	/*  how many samples is to end of buffer */
-/* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr); */
+		m = devpriv->ai_data_len >> 1;	/*
+						 * how many samples is to
+						 * end of buffer
+						 */
+/*
+ * DPRINTK("samps=%d m=%d %d %d\n",
+ * samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr);
+ */
 		sampls = m;
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
 				    samplesinbuf);
-		m = m - sampls;	/*  m= how many samples was transfered */
+		m = m - sampls;		/* m= how many samples was transfered */
 	}
 /* DPRINTK("YYY\n"); */
 
 	if (!devpriv->ai_neverending)
-		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+		if (devpriv->ai_act_scan >= devpriv->ai_scans) {
+							/* all data sampled */
 			pci9118_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_EOA;
 		}
 
-	if (devpriv->dma_doublebuf) {	/*  switch dma buffers */
+	if (devpriv->dma_doublebuf) {	/* switch dma buffers */
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
-	} else {		/*  restart DMA if is not used double buffering */
+	} else {	/* restart DMA if is not used double buffering */
 		outl(devpriv->dmabuf_hw[0],
 		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[0],
@@ -705,39 +822,62 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev->attached)
-		return IRQ_NONE;	/*  not fully initialized */
+		return IRQ_NONE;	/* not fully initialized */
 
-	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	/*  get IRQ reasons from card */
-	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  get INT register from AMCC chip */
+	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;
+					/* get IRQ reasons from card */
+	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+					/* get INT register from AMCC chip */
 
-/* DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do); */
+/*
+ * DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x
+ * MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n",
+ * int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR),
+ * inl(devpriv->iobase_a+AMCC_OP_REG_MWTC),
+ * inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do);
+ */
 
 	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
-		return IRQ_NONE;	/*  interrupt from other source */
+		return IRQ_NONE;	/* interrupt from other source */
 
-	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  shutdown IRQ reasons in AMCC */
+	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+					/* shutdown IRQ reasons in AMCC */
 
-	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	/*  get STATUS register */
+	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;
+					/* get STATUS register */
 
 	if (devpriv->ai_do) {
 		if (devpriv->ai12_startstop)
-			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	/*  start stop of measure */
+			if ((int_adstat & AdStatus_DTH) &&
+							(int_daq & Int_DTrg)) {
+						/* start stop of measure */
 				if (devpriv->ai12_startstop & START_AI_EXT) {
 					devpriv->ai12_startstop &=
 					    ~START_AI_EXT;
 					if (!(devpriv->ai12_startstop &
-					      STOP_AI_EXT))
-						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
-					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	/*  start pacer */
+							STOP_AI_EXT))
+							pci9118_exttrg_del
+							(dev, EXTTRG_AI);
+						/* deactivate EXT trigger */
+					start_pacer(dev, devpriv->ai_do,
+						devpriv->ai_divisor1,
+						devpriv->ai_divisor2);
+						/* start pacer */
 					outl(devpriv->AdControlReg,
-					     dev->iobase + PCI9118_ADCNTRL);
+						dev->iobase + PCI9118_ADCNTRL);
 				} else {
 					if (devpriv->ai12_startstop &
-					    STOP_AI_EXT) {
+						STOP_AI_EXT) {
 						devpriv->ai12_startstop &=
-						    ~STOP_AI_EXT;
-						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
-						devpriv->ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
+							~STOP_AI_EXT;
+						pci9118_exttrg_del
+							(dev, EXTTRG_AI);
+						/* deactivate EXT trigger */
+						devpriv->ai_neverending = 0;
+						/*
+						 * well, on next interrupt from
+						 * DMA/EOC measure will stop
+						 */
 					}
 				}
 			}
@@ -821,7 +961,11 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2:
+	 * make sure trigger sources are
+	 * unique and mutually compatible
+	 */
 
 	if (cmd->start_src != TRIG_NOW &&
 	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
@@ -1026,7 +1170,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->chanlist)
 		if (!check_channel_list(dev, s, cmd->chanlist_len,
 					cmd->chanlist, 0, 0))
-			return 5;	/*  incorrect channels list */
+			return 5;	/* incorrect channels list */
 
 	return 0;
 }
@@ -1043,88 +1187,101 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	dmalen1 = devpriv->dmabuf_size[1];
 	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
 		devpriv->ai_data_len);
-	/*  isn't output buff smaller that our DMA buff? */
+	/* isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > (devpriv->ai_data_len)) {
-		dmalen0 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
+		dmalen0 = devpriv->ai_data_len & ~3L;	/*
+							 * align to 32bit down
+							 */
 	}
 	if (dmalen1 > (devpriv->ai_data_len)) {
-		dmalen1 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
+		dmalen1 = devpriv->ai_data_len & ~3L;	/*
+							 * align to 32bit down
+							 */
 	}
 	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	/*  we want wake up every scan? */
+	/* we want wake up every scan? */
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
-			/*  uff, too short DMA buffer, disable EOS support! */
+			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-			    ("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			    ("comedi%d: WAR: DMA0 buf too short, can't "
+					"support TRIG_WAKE_EOS (%d<%d)\n",
 			     dev->minor, dmalen0,
 			     devpriv->ai_n_realscanlen << 1);
 		} else {
-			/*  short first DMA buffer to one scan */
+			/* short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK
-			    ("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n",
-			     dmalen0, devpriv->ai_n_realscanlen,
-			     devpriv->useeoshandle);
+				("21 dmalen0=%d ai_n_realscanlen=%d "
+							"useeoshandle=%d\n",
+				dmalen0, devpriv->ai_n_realscanlen,
+				devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
 				printk
-				    ("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
-				     dev->minor, dmalen0);
+					("comedi%d: ERR: DMA0 buf len bug? "
+								"(%d<4)\n",
+					dev->minor, dmalen0);
 				dmalen0 = 4;
 			}
 		}
 	}
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
-			/*  uff, too short DMA buffer, disable EOS support! */
+			/* uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-			    ("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			    ("comedi%d: WAR: DMA1 buf too short, "
+					"can't support TRIG_WAKE_EOS (%d<%d)\n",
 			     dev->minor, dmalen1,
 			     devpriv->ai_n_realscanlen << 1);
 		} else {
-			/*  short second DMA buffer to one scan */
+			/* short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK
-			    ("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n",
+			    ("22 dmalen1=%d ai_n_realscanlen=%d "
+							"useeoshandle=%d\n",
 			     dmalen1, devpriv->ai_n_realscanlen,
 			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
 				printk
-				    ("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
-				     dev->minor, dmalen1);
+					("comedi%d: ERR: DMA1 buf len bug? "
+								"(%d<4)\n",
+					dev->minor, dmalen1);
 				dmalen1 = 4;
 			}
 		}
 	}
 
 	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
-	/*  transfer without TRIG_WAKE_EOS */
+	/* transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
-		/*  if it's possible then allign DMA buffers to length of scan */
+		/* if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
 		    (devpriv->ai_n_realscanlen << 1);
 		dmalen0 &= ~3L;
 		if (!dmalen0)
-			dmalen0 = i;	/*  uff. very long scan? */
+			dmalen0 = i;	/* uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
 		    (dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
 		    (devpriv->ai_n_realscanlen << 1);
 		dmalen1 &= ~3L;
 		if (!dmalen1)
-			dmalen1 = i;	/*  uff. very long scan? */
-		/*  if measure isn't neverending then test, if it whole fits into one or two DMA buffers */
+			dmalen1 = i;	/* uff. very long scan? */
+		/*
+		 * if measure isn't neverending then test, if it fits whole
+		 * into one or two DMA buffers
+		 */
 		if (!devpriv->ai_neverending) {
-			/*  fits whole measure into one DMA buffer? */
+			/* fits whole measure into one DMA buffer? */
 			if (dmalen0 >
 			    ((devpriv->ai_n_realscanlen << 1) *
 			     devpriv->ai_scans)) {
@@ -1138,7 +1295,10 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
-			} else {	/*  fits whole measure into two DMA buffer? */
+			} else {	/*
+					 * fits whole measure into
+					 * two DMA buffer?
+					 */
 				if (dmalen1 >
 				    ((devpriv->ai_n_realscanlen << 1) *
 				     devpriv->ai_scans - dmalen0))
@@ -1154,7 +1314,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 
 	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	/*  these DMA buffer size we'll be used */
+	/* these DMA buffer size will be used */
 	devpriv->dma_actbuf = 0;
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
@@ -1176,10 +1336,11 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	}
 #endif
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS),
+			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
 	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
-	/*  init DMA transfer */
+	/* init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 /* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
@@ -1187,7 +1348,9 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	outl(inl(devpriv->iobase_a +
 		 AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
 	     EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,
+			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+						/* allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
 	return 0;
@@ -1220,17 +1383,21 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
 		return -EIO;
 	};
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	/* transfer function */
+	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;
+						/* transfer function */
 
 	if (devpriv->ai12_startstop)
-		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
+		pci9118_exttrg_add(dev, EXTTRG_AI);
+						/* activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->IntControlReg |= Int_Timer;
 
 	devpriv->AdControlReg |= AdControl_Int;
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
+			devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+							/* allow INT in AMCC */
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1296,10 +1463,12 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev,
 	};
 
 	if (devpriv->ai12_startstop) {
-		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
+		pci9118_exttrg_add(dev, EXTTRG_AI);
+						/* activate EXT trigger */
 	}
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
+	devpriv->int_ai_func = interrupt_pci9118_ai_dma;
+						/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
 	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -1342,7 +1511,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ai_add_back = 0;
 	devpriv->ai_maskerr = 0x10e;
 
-	/*  prepare for start/stop conditions */
+	/* prepare for start/stop conditions */
 	if (cmd->start_src == TRIG_EXT)
 		devpriv->ai12_startstop |= START_AI_EXT;
 	if (cmd->stop_src == TRIG_EXT) {
@@ -1369,10 +1538,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_scans = 0;
 	}
 
-	/*  use sample&hold signal? */
+	/* use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW) {
 		devpriv->usessh = 1;
-	} /*  yes */
+	} /* yes */
 	else {
 		devpriv->usessh = 0;
 	}			/*  no */
@@ -1381,7 +1550,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
 		devpriv->ai12_startstop);
 
-	/*  use additional sample at end of every scan to satisty DMA 32 bit transfer? */
+	/*
+	 * use additional sample at end of every scan
+	 * to satisty DMA 32 bit transfer?
+	 */
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
 	devpriv->useeoshandle = 0;
@@ -1393,27 +1565,44 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				devpriv->ai_add_back = 1;
 			}
 			if (cmd->convert_src == TRIG_TIMER) {
-				devpriv->usedma = 0;	/*  use INT transfer if scanlist have only one channel */
+				devpriv->usedma = 0;
+					/*
+					 * use INT transfer if scanlist
+					 * have only one channel
+					 */
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
 		    (devpriv->ai_n_scanlen & 1) &&
 		    (devpriv->ai_n_scanlen > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
-				/* vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
-				devpriv->usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
-			} else {	/*  well, we must insert one sample to end of EOS to meet 32 bit transfer */
+				/*
+				 * vpriv->useeoshandle=1; // change DMA transfer
+				 * block to fit EOS on every second call
+				 */
+				devpriv->usedma = 0;
+				/*
+				 * XXX maybe can be corrected to use 16 bit DMA
+				 */
+			} else {	/*
+					 * well, we must insert one sample
+					 * to end of EOS to meet 32 bit transfer
+					 */
 				devpriv->ai_add_back = 1;
 			}
 		}
-	} else {		/*  interrupt transfer don't need any correction */
+	} else {	/* interrupt transfer don't need any correction */
 		devpriv->usedma = 0;
 	}
 
-	/*  we need software S&H signal? It add  two samples before every scan as minimum */
+	/*
+	 * we need software S&H signal?
+	 * It adds two samples before every scan as minimum
+	 */
 	if (devpriv->usessh && devpriv->softsshdelay) {
 		devpriv->ai_add_front = 2;
-		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	/*  move it to front */
+		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {
+							/* move it to front */
 			devpriv->ai_add_front++;
 			devpriv->ai_add_back = 0;
 		}
@@ -1422,17 +1611,22 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		addchans = devpriv->softsshdelay / cmd->convert_arg;
 		if (devpriv->softsshdelay % cmd->convert_arg)
 			addchans++;
-		if (addchans > (devpriv->ai_add_front - 1)) {	/*  uff, still short :-( */
+		if (addchans > (devpriv->ai_add_front - 1)) {
+							/* uff, still short */
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
 				     devpriv->ai_n_chan +
 				     devpriv->ai_add_back) & 1)
-					devpriv->ai_add_front++;	/*  round up to 32 bit */
+					devpriv->ai_add_front++;
+							/* round up to 32 bit */
 		}
 	}
-	/*  well, we now know what must be all added */
-	devpriv->ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
+	/* well, we now know what must be all added */
+	devpriv->ai_n_realscanlen =	/*
+					 * what we must take from card in real
+					 * to have ai_n_scanlen on output?
+					 */
 	    (devpriv->ai_add_front + devpriv->ai_n_chan +
 	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
 				      devpriv->ai_n_chan);
@@ -1443,7 +1637,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_n_chan, devpriv->ai_add_back,
 		devpriv->ai_n_scanlen);
 
-	/*  check and setup channel list */
+	/* check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
 				devpriv->ai_chanlist, devpriv->ai_add_front,
 				devpriv->ai_add_back))
@@ -1454,9 +1648,16 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 				devpriv->useeoshandle))
 		return -EINVAL;
 
-	/*  compute timers settings */
-	/*  simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect */
-	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	/*  both timer is used for one time */
+	/* compute timers settings */
+	/*
+	 * simplest way, fr=4Mhz/(tim1*tim2),
+	 * channel manipulation without timers effect
+	 */
+	if (((cmd->scan_begin_src == TRIG_FOLLOW) ||
+		(cmd->scan_begin_src == TRIG_EXT) ||
+		(cmd->scan_begin_src == TRIG_INT)) &&
+		(cmd->convert_src == TRIG_TIMER)) {
+					/* both timer is used for one time */
 		if (cmd->scan_begin_src == TRIG_EXT) {
 			devpriv->ai_do = 4;
 		} else {
@@ -1472,10 +1673,14 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
-	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	/*  double timed action */
+	if ((cmd->scan_begin_src == TRIG_TIMER) &&
+		((cmd->convert_src == TRIG_TIMER) ||
+		(cmd->convert_src == TRIG_NOW))) {
+						/* double timed action */
 		if (!devpriv->usedma) {
 			comedi_error(dev,
-				     "cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
+				     "cmd->scan_begin_src=TRIG_TIMER works "
+						"only with bus mastering!");
 			return -EIO;
 		}
 
@@ -1496,15 +1701,27 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_do = 3;
 	}
 
-	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
+	start_pacer(dev, -1, 0, 0);	/* stop pacer */
 
-	devpriv->AdControlReg = 0;	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA */
+	devpriv->AdControlReg = 0;	/*
+					 * bipolar, S.E., use 8254, stop 8354,
+					 * internal trigger, soft trigger,
+					 * disable DMA
+					 */
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+					/*
+					 * positive triggers, no S&H, no burst,
+					 * burst stop, no post trigger,
+					 * no about trigger, trigger stop
+					 */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	udelay(1);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
-	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	inl(dev->iobase + PCI9118_ADSTAT);	/*
+						 * flush A/D and INT
+						 * status register
+						 */
 	inl(dev->iobase + PCI9118_INTSRC);
 
 	devpriv->ai_act_scan = 0;
@@ -1537,33 +1754,37 @@ static int check_channel_list(struct comedi_device *dev,
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
 		printk
-		    ("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
+		    ("comedi%d: range/channel list is too long for "
+						"actual configuration (%d>%d)!",
 		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
 		return 0;
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/*  all input must be diff */
+		differencial = 1;	/* all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/*  all input must be bipolar */
+		bipolar = 1;	/* all input must be bipolar */
 	if (n_chan > 1)
-		for (i = 1; i < n_chan; i++) {	/*  check S.E/diff */
+		for (i = 1; i < n_chan; i++) {	/* check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 			    (differencial)) {
 				comedi_error(dev,
-					     "Differencial and single ended inputs cann't be mixtured!");
+					     "Differencial and single ended "
+						"inputs can't be mixtured!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
 			    (bipolar)) {
 				comedi_error(dev,
-					     "Bipolar and unipolar ranges cann't be mixtured!");
+					     "Bipolar and unipolar ranges "
+							"can't be mixtured!");
 				return 0;
 			}
 			if ((!devpriv->usemux) & (differencial) &
 			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
 				comedi_error(dev,
-					     "If AREF_DIFF is used then is available only first 8 channels!");
+					     "If AREF_DIFF is used then is "
+					"available only first 8 channels!");
 				return 0;
 			}
 		}
@@ -1583,7 +1804,8 @@ static int setup_channel_list(struct comedi_device *dev,
 	unsigned int scanquad, gain, ssh = 0x00;
 
 	DPRINTK
-	    ("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n",
+	    ("adl_pci9118 EDBG: BGN: setup_channel_list"
+						"(%d,.,%d,.,%d,%d,%d,%d)\n",
 	     dev->minor, n_chan, rot, frontadd, backadd, usedma);
 
 	if (usedma == 1) {
@@ -1592,27 +1814,33 @@ static int setup_channel_list(struct comedi_device *dev,
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	/*  all input must be diff */
+		differencial = 1;	/* all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	/*  all input must be bipolar */
+		bipolar = 1;	/* all input must be bipolar */
 
-	/*  All is ok, so we can setup channel/range list */
+	/* All is ok, so we can setup channel/range list */
 
 	if (!bipolar) {
-		devpriv->AdControlReg |= AdControl_UniP;	/*  set unibipolar */
+		devpriv->AdControlReg |= AdControl_UniP;
+							/* set unibipolar */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	/*  enable bipolar */
+		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);
+							/* enable bipolar */
 	}
 
 	if (differencial) {
-		devpriv->AdControlReg |= AdControl_Diff;	/*  enable diff inputs */
+		devpriv->AdControlReg |= AdControl_Diff;
+							/* enable diff inputs */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	/*  set single ended inputs */
+		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);
+						/* set single ended inputs */
 	}
 
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  setup mode */
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+								/* setup mode */
 
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  gods know why this sequence! */
+	outl(2, dev->iobase + PCI9118_SCANMOD);
+					/* gods know why this sequence! */
 	outl(0, dev->iobase + PCI9118_SCANMOD);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
 
@@ -1622,12 +1850,15 @@ static int setup_channel_list(struct comedi_device *dev,
 		devpriv->chanlist[i] = 0x55aa;
 #endif
 
-	if (frontadd) {		/*  insert channels for S&H */
+	if (frontadd) {		/* insert channels for S&H */
 		ssh = devpriv->softsshsample;
 		DPRINTK("FA: %04x: ", ssh);
-		for (i = 0; i < frontadd; i++) {	/*  store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
-			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
+		for (i = 0; i < frontadd; i++) {
+						/* store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);
+						/* get channel number; */
+			gain = CR_RANGE(chanlist[0]);
+						/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1637,23 +1868,24 @@ static int setup_channel_list(struct comedi_device *dev,
 	}
 
 	DPRINTK("SL: ", ssh);
-	for (i = 0; i < n_chan; i++) {	/*  store range list to card */
-		scanquad = CR_CHAN(chanlist[i]);	/*  get channel number; */
+	for (i = 0; i < n_chan; i++) {	/* store range list to card */
+		scanquad = CR_CHAN(chanlist[i]);	/* get channel number */
 #ifdef PCI9118_PARANOIDCHECK
 		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
 #endif
-		gain = CR_RANGE(chanlist[i]);	/*  get gain number */
+		gain = CR_RANGE(chanlist[i]);		/* get gain number */
 		scanquad |= ((gain & 0x03) << 8);
 		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 		DPRINTK("%02x ", scanquad | ssh);
 	}
 	DPRINTK("\n ");
 
-	if (backadd) {		/*  insert channels for fit onto 32bit DMA */
+	if (backadd) {		/* insert channels for fit onto 32bit DMA */
 		DPRINTK("BA: %04x: ", ssh);
-		for (i = 0; i < backadd; i++) {	/*  store range list to card */
-			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
-			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
+		for (i = 0; i < backadd; i++) {	/* store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);
+							/* get channel number */
+			gain = CR_RANGE(chanlist[0]);	/* get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1661,13 +1893,16 @@ static int setup_channel_list(struct comedi_device *dev,
 		DPRINTK("\n ");
 	}
 #ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
+	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];
+						/* for 32bit operations */
 	if (useeos) {
-		for (i = 1; i < n_chan; i++) {	/*  store range list to card */
+		for (i = 1; i < n_chan; i++) {	/* store range list to card */
 			devpriv->chanlist[(n_chan + i) ^ usedma] =
 			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
 		}
-		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
+		devpriv->chanlist[(2 * n_chan) ^ usedma] =
+						devpriv->chanlist[0 ^ usedma];
+						/* for 32bit operations */
 		useeos = 2;
 	} else {
 		useeos = 1;
@@ -1680,11 +1915,11 @@ static int setup_channel_list(struct comedi_device *dev,
 	DPRINTK("\n ");
 #endif
 #endif
-	outl(0, dev->iobase + PCI9118_SCANMOD);	/*  close scan queue */
-/* udelay(100);                               important delay, or first sample will be cripled */
+	outl(0, dev->iobase + PCI9118_SCANMOD);	/* close scan queue */
+	/* udelay(100); important delay, or first sample will be crippled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
-	return 1;		/*  we can serve this with scan logic */
+	return 1;		/* we can serve this with scan logic */
 }
 
 /*
@@ -1699,7 +1934,8 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 				  char usessh, unsigned int chnsshfront)
 {
 	DPRINTK
-	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
+	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors"
+					"(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
 	     mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
 	switch (mode) {
 	case 1:
@@ -1716,17 +1952,18 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 			*tim2 = this_board->ai_ns_min;
 		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div1 = *tim2 / devpriv->i8254_osc_base;	/*  convert timer (burst) */
+		*div1 = *tim2 / devpriv->i8254_osc_base;
+						/* convert timer (burst) */
 		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div1 < this_board->ai_pacer_min)
 			*div1 = this_board->ai_pacer_min;
 		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *tim1 / devpriv->i8254_osc_base;	/*  scan timer */
+		*div2 = *tim1 / devpriv->i8254_osc_base;	/* scan timer */
 		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *div2 / *div1;	/*  major timer is c1*c2 */
+		*div2 = *div2 / *div1;		/* major timer is c1*c2 */
 		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div2 < chans)
@@ -1734,9 +1971,10 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 
-		*tim2 = *div1 * devpriv->i8254_osc_base;	/*  real convert timer */
+		*tim2 = *div1 * devpriv->i8254_osc_base;
+							/* real convert timer */
 
-		if (usessh & (chnsshfront == 0))	/*  use BSSH signal */
+		if (usessh & (chnsshfront == 0))	/* use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 
@@ -1776,11 +2014,13 @@ static void start_pacer(struct comedi_device *dev, int mode,
 static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	/*  incorrect source */
+		return -1;				/* incorrect source */
 	devpriv->exttrg_users |= (1 << source);
 	devpriv->IntControlReg |= Int_DTrg;
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+							/* allow INT in AMCC */
 	return 0;
 }
 
@@ -1790,12 +2030,15 @@ static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	/*  incorrect source */
+		return -1;			/* incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
-	if (!devpriv->exttrg_users) {	/*  shutdown ext trg intterrupts */
+	if (!devpriv->exttrg_users) {	/* shutdown ext trg intterrupts */
 		devpriv->IntControlReg &= ~Int_DTrg;
-		if (!devpriv->IntControlReg)	/*  all IRQ disabled */
-			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  disable int in AMCC */
+		if (!devpriv->IntControlReg)	/* all IRQ disabled */
+			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) &
+					(~0x00001f00),
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+						/* disable int in AMCC */
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
 	return 0;
@@ -1808,17 +2051,29 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	if (devpriv->usedma)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) &
+			(~EN_A2P_TRANSFERS),
+			devpriv->iobase_a + AMCC_OP_REG_MCSR);	/* stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
+	start_pacer(dev, 0, 0, 0);	/* stop 8254 counters */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+					/*
+					 * positive triggers, no S&H, no burst,
+					 * burst stop, no post trigger,
+					 * no about trigger, trigger stop
+					 */
 	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+					/*
+					 * bipolar, S.E., use 8254, stop 8354,
+					 * internal trigger, soft trigger,
+					 * disable INT and DMA
+					 */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
 
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
@@ -1832,7 +2087,9 @@ static int pci9118_ai_cancel(struct comedi_device *dev,
 	devpriv->dma_actbuf = 0;
 
 	if (!devpriv->IntControlReg)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00,
+					devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+							/* allow INT in AMCC */
 
 	return 0;
 }
@@ -1845,31 +2102,52 @@ static int pci9118_reset(struct comedi_device *dev)
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
 	inl(dev->iobase + PCI9118_INTCTRL);
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	/*  disable interrupts source */
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+						/* disable interrupts source */
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 /* outl(0xb4, dev->iobase + PCI9118_CNTCTRL); */
-	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
+	start_pacer(dev, 0, 0, 0);		/* stop 8254 counters */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+						/*
+						 * bipolar, S.E., use 8254,
+						 * stop 8354, internal trigger,
+						 * soft trigger,
+						 * disable INT and DMA
+						 */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/* reset scan queue */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+						/*
+						 * positive triggers, no S&H,
+						 * no burst, burst stop,
+						 * no post trigger,
+						 * no about trigger,
+						 * trigger stop
+						 */
 
 	devpriv->ao_data[0] = 2047;
 	devpriv->ao_data[1] = 2047;
-	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
+	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);
+						/* reset A/D outs to 0V */
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
-	outl(0, dev->iobase + PCI9118_DO);	/*  reset digi outs to L */
+	outl(0, dev->iobase + PCI9118_DO);	/* reset digi outs to L */
 	udelay(10);
 	inl(dev->iobase + PCI9118_AD_DATA);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
-	outl(0, dev->iobase + PCI9118_INTSRC);	/*  remove INT requests */
-	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D status register */
-	inl(dev->iobase + PCI9118_INTSRC);	/*  flush INT requests */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/* flush FIFO */
+	outl(0, dev->iobase + PCI9118_INTSRC);	/* remove INT requests */
+	inl(dev->iobase + PCI9118_ADSTAT);	/* flush A/D status register */
+	inl(dev->iobase + PCI9118_INTSRC);	/* flush INT requests */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+						/*
+						 * bipolar, S.E., use 8254,
+						 * stop 8354, internal trigger,
+						 * soft trigger,
+						 * disable INT and DMA
+						 */
 
 	devpriv->cnt0_users = 0;
 	devpriv->exttrg_users = 0;
@@ -1899,7 +2177,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 	if (it->options[3] & 1) {
-		master = 0;	/*  user don't want use bus master */
+		master = 0;	/* user don't want use bus master */
 	} else {
 		master = 1;
 	}
@@ -1968,7 +2246,7 @@ static int pci9118_attach(struct comedi_device *dev,
 	pci9118_reset(dev);
 
 	if (it->options[3] & 2)
-		irq = 0;	/*  user don't want use IRQ */
+		irq = 0;	/* user don't want use IRQ */
 	if (irq > 0) {
 		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
@@ -1984,7 +2262,7 @@ static int pci9118_attach(struct comedi_device *dev,
 
 	dev->irq = irq;
 
-	if (master) {		/*  alloc DMA buffers */
+	if (master) {		/* alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--) {
@@ -2024,16 +2302,18 @@ static int pci9118_attach(struct comedi_device *dev,
 	if (it->options[2] > 0) {
 		devpriv->usemux = it->options[2];
 		if (devpriv->usemux > 256)
-			devpriv->usemux = 256;	/*  max 256 channels! */
+			devpriv->usemux = 256;	/* max 256 channels! */
 		if (it->options[4] > 0)
 			if (devpriv->usemux > 128) {
-				devpriv->usemux = 128;	/*  max 128 channels with softare S&H! */
+				devpriv->usemux = 128;
+					/* max 128 channels with softare S&H! */
 			}
 		printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
-	if (devpriv->softsshdelay < 0) {	/*  select sample&hold signal polarity */
+	if (devpriv->softsshdelay < 0) {
+					/* select sample&hold signal polarity */
 		devpriv->softsshdelay = -devpriv->softsshdelay;
 		devpriv->softsshsample = 0x80;
 		devpriv->softsshhold = 0x00;
@@ -2045,7 +2325,8 @@ static int pci9118_attach(struct comedi_device *dev,
 	printk(".\n");
 
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
-	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
+	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);
+				/* Enable parity check for parity error */
 
 	ret = alloc_subdevices(dev, 4);
 	if (ret < 0)
@@ -2103,9 +2384,10 @@ static int pci9118_attach(struct comedi_device *dev,
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;
-	devpriv->i8254_osc_base = 250;	/*  250ns=4MHz */
-	devpriv->ai_maskharderr = 0x10a;	/*  default measure crash condition */
-	if (it->options[5])	/*  disable some requested */
+	devpriv->i8254_osc_base = 250;	/* 250ns=4MHz */
+	devpriv->ai_maskharderr = 0x10a;
+					/* default measure crash condition */
+	if (it->options[5])		/* disable some requested */
 		devpriv->ai_maskharderr &= ~it->options[5];
 
 	switch (this_board->ai_maxdata) {

commit d607c7811279b51fb1a7dbbe01533f7acf26ab23
Author: Maurice Dawson <mauricedawson2699@googlemail.com>
Date:   Wed Mar 17 13:40:11 2010 +0000

    Staging: comedi: fix indent coding style issue in adl_pci9118.c
    
    Patch to the adl_pci9118.c that fixes, ERROR: code indent should use tabs where possible, found by the checkpatch.pl tool
    
    Signed-off-by: Maurice Dawson <mauricedawson2699@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 944f20ae5a6a..bed7e41445aa 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -44,20 +44,20 @@ c) If isn't used DMA then you can use only mode where
 Configuration options:
   [0] - PCI bus of device (optional)
   [1] - PCI slot of device (optional)
-          If bus/slot is not specified, then first available PCI
-          card will be used.
+	If bus/slot is not specified, then first available PCI
+	card will be used.
   [2] - 0= standard 8 DIFF/16 SE channels configuration
-        n= external multiplexer connected, 1<=n<=256
+	n = external multiplexer connected, 1 <= n <= 256
   [3] - 0=autoselect DMA or EOC interrupts operation
-        1=disable DMA mode
-        3=disable DMA and INT, only insn interface will work
+	1 = disable DMA mode
+	3 = disable DMA and INT, only insn interface will work
   [4] - sample&hold signal - card can generate signal for external S&H board
-        0=use SSHO (pin 45) signal is generated in onboard hardware S&H logic
-        0!=use ADCHN7 (pin 23) signal is generated from driver, number
-           say how long delay is requested in ns and sign polarity of the hold
-           (in this case external multiplexor can serve only 128 channels)
+	0 = use SSHO(pin 45) signal is generated in onboard hardware S&H logic
+	0 != use ADCHN7(pin 23) signal is generated from driver, number say how
+		long delay is requested in ns and sign polarity of the hold
+		(in this case external multiplexor can serve only 128 channels)
   [5] - 0=stop measure on all hardware errors
-        2|=ignore ADOR - A/D Overrun status
+	2 | = ignore ADOR - A/D Overrun status
 	8|=ignore Bover - A/D Burst Mode Overrun status
 	256|=ignore nFull - A/D FIFO Full status
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9934a3cf2548..944f20ae5a6a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -66,6 +66,7 @@ Configuration options:
 #include "../pci_ids.h"
 
 #include <linux/delay.h>
+#include <linux/gfp.h>
 #include <linux/interrupt.h>
 
 #include "amcc_s5933.h"

commit d5a2ffd8e8d602293339f69180aff8914c454d83
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 12 15:57:59 2010 +0100

    staging: fix typos "couter" -> "counter"
    
    This patch was generated by
    
            git grep -l 'couter' drivers/staging | xargs -r perl -p -i -e 's/couter/counter/'
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 791ea8334e1e..9934a3cf2548 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -88,9 +88,9 @@ Configuration options:
 #define IORANGE_9118 	64	/* I hope */
 #define PCI9118_CHANLEN	255	/* len of chanlist, some source say 256, but reality looks like 255 :-( */
 
-#define PCI9118_CNT0	0x00	/* R/W: 8254 couter 0 */
-#define PCI9118_CNT1	0x04	/* R/W: 8254 couter 0 */
-#define PCI9118_CNT2	0x08	/* R/W: 8254 couter 0 */
+#define PCI9118_CNT0	0x00	/* R/W: 8254 counter 0 */
+#define PCI9118_CNT1	0x04	/* R/W: 8254 counter 0 */
+#define PCI9118_CNT2	0x08	/* R/W: 8254 counter 0 */
 #define PCI9118_CNTCTRL	0x0c	/* W:   8254 counter control */
 #define PCI9118_AD_DATA	0x10	/* R:   A/D data */
 #define PCI9118_DA1	0x10	/* W:   D/A registers */

commit 48b1aff5b93521c5ad90842bef52b218ac50a4ab
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Nov 20 11:32:37 2009 +0000

    Staging: comedi: initialize divisor variables
    
    The i8253_cascade_ns_to_timer_2div() function (and
    i8253_cascade_ns_to_timer macro) checks the old values *d1 and *d2
    for correctness as a heuristic before calculating new values.  Don't
    call the function with uninitialized values in *d1 and *d2.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 1ee4b6a91c1f..791ea8334e1e 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -780,7 +780,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev,
 			      struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp, divisor1, divisor2;
+	int tmp, divisor1 = 0, divisor2 = 0;
 
 	/* step 1: make sure trigger sources are trivially valid */
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 65f522be9124..1ee4b6a91c1f 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -154,32 +154,33 @@ Configuration options:
 #define EXTTRG_AI	0	/* ext trg is used by AI */
 
 static const struct comedi_lrange range_pci9118dg_hr = { 8, {
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			BIP_RANGE(0.625),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-	}
+							     BIP_RANGE(5),
+							     BIP_RANGE(2.5),
+							     BIP_RANGE(1.25),
+							     BIP_RANGE(0.625),
+							     UNI_RANGE(10),
+							     UNI_RANGE(5),
+							     UNI_RANGE(2.5),
+							     UNI_RANGE(1.25)
+							     }
 };
 
 static const struct comedi_lrange range_pci9118hg = { 8, {
-			BIP_RANGE(5),
-			BIP_RANGE(0.5),
-			BIP_RANGE(0.05),
-			BIP_RANGE(0.005),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-	}
+							  BIP_RANGE(5),
+							  BIP_RANGE(0.5),
+							  BIP_RANGE(0.05),
+							  BIP_RANGE(0.005),
+							  UNI_RANGE(10),
+							  UNI_RANGE(1),
+							  UNI_RANGE(0.1),
+							  UNI_RANGE(0.01)
+							  }
 };
 
 #define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
 
-static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci9118_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int pci9118_detach(struct comedi_device *dev);
 
 struct boardtype {
@@ -204,28 +205,29 @@ struct boardtype {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
-	{PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, pci9118_pci_table);
 
 static const struct boardtype boardtypes[] = {
 	{"pci9118dg", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-			&range_pci9118dg_hr, &range_bipolar10,
-		3000, 12, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+	 &range_pci9118dg_hr, &range_bipolar10,
+	 3000, 12, 512},
 	{"pci9118hg", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
-			&range_pci9118hg, &range_bipolar10,
-		3000, 12, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+	 &range_pci9118hg, &range_bipolar10,
+	 3000, 12, 512},
 	{"pci9118hr", PCI_VENDOR_ID_AMCC, 0x80d9,
-			AMCC_OP_REG_SIZE, IORANGE_9118,
-			16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
-			&range_pci9118dg_hr, &range_bipolar10,
-		10000, 40, 512},
+	 AMCC_OP_REG_SIZE, IORANGE_9118,
+	 16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
+	 &range_pci9118dg_hr, &range_bipolar10,
+	 10000, 40, 512},
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
@@ -309,27 +311,34 @@ struct pci9118_private {
 ==============================================================================
 */
 
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
-static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
-	int usedma, char eoshandle);
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2);
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int frontadd,
+			      int backadd);
+static int setup_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int rot, int frontadd,
+			      int backadd, int usedma, char eoshandle);
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2);
 static int pci9118_reset(struct comedi_device *dev);
 static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source);
 static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source);
-static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int pci9118_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
-	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
-	char usessh, unsigned int chnsshfront);
+				  struct comedi_subdevice *s,
+				  unsigned int *tim1, unsigned int *tim2,
+				  unsigned int flags, int chans,
+				  unsigned int *div1, unsigned int *div2,
+				  char usessh, unsigned int chnsshfront);
 
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_read_ai(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n, timeout;
@@ -358,15 +367,14 @@ static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevi
 		outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 		return -ETIME;
 
-	      conv_finish:
+conv_finish:
 		if (devpriv->ai16bits) {
 			data[n] =
-				(inl(dev->iobase +
-					PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
+			    (inl(dev->iobase +
+				 PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
 		} else {
 			data[n] =
-				(inw(dev->iobase +
-					PCI9118_AD_DATA) >> 4) & 0xfff;
+			    (inw(dev->iobase + PCI9118_AD_DATA) >> 4) & 0xfff;
 		}
 	}
 
@@ -378,8 +386,9 @@ static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevi
 /*
 ==============================================================================
 */
-static int pci9118_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_write_ao(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chanreg, ch;
 
@@ -401,8 +410,9 @@ static int pci9118_insn_write_ao(struct comedi_device *dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_read_ao(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -416,8 +426,9 @@ static int pci9118_insn_read_ao(struct comedi_device *dev, struct comedi_subdevi
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_bits_di(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
@@ -427,8 +438,9 @@ static int pci9118_insn_bits_di(struct comedi_device *dev, struct comedi_subdevi
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int pci9118_insn_bits_do(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -446,29 +458,31 @@ static int pci9118_insn_bits_do(struct comedi_device *dev, struct comedi_subdevi
 static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	devpriv->AdFunctionReg =
-		AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+	    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1) & 0xff,
-		dev->iobase + PCI9118_CNT0);
+	     dev->iobase + PCI9118_CNT0);
 	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 9) & 0xff,
-		dev->iobase + PCI9118_CNT0);
+	     dev->iobase + PCI9118_CNT0);
 	devpriv->AdFunctionReg |= AdFunction_Start;
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 }
 
 static unsigned int defragment_dma_buffer(struct comedi_device *dev,
-	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
+					  struct comedi_subdevice *s,
+					  short *dma_buffer,
+					  unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
-		stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
+	    stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
 	unsigned int raw_scanlen = devpriv->ai_add_front + devpriv->ai_n_chan +
-		devpriv->ai_add_back;
+	    devpriv->ai_add_back;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->ai_act_dmapos >= start_pos &&
-			devpriv->ai_act_dmapos < stop_pos) {
+		    devpriv->ai_act_dmapos < stop_pos) {
 			dma_buffer[j++] = dma_buffer[i];
 		}
 		devpriv->ai_act_dmapos++;
@@ -482,18 +496,20 @@ static unsigned int defragment_dma_buffer(struct comedi_device *dev,
 ==============================================================================
 */
 static unsigned int move_block_from_dma(struct comedi_device *dev,
-	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
+					struct comedi_subdevice *s,
+					short *dma_buffer,
+					unsigned int num_samples)
 {
 	unsigned int num_bytes;
 
 	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
 	devpriv->ai_act_scan +=
-		(s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
+	    (s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
 	s->async->cur_chan += num_samples;
 	s->async->cur_chan %= devpriv->ai_n_scanlen;
 	num_bytes =
-		cfc_write_array_to_buffer(s, dma_buffer,
-		num_samples * sizeof(short));
+	    cfc_write_array_to_buffer(s, dma_buffer,
+				      num_samples * sizeof(short));
 	if (num_bytes < num_samples * sizeof(short))
 		return -1;
 	return 0;
@@ -503,7 +519,8 @@ static unsigned int move_block_from_dma(struct comedi_device *dev,
 ==============================================================================
 */
 static char pci9118_decode_error_status(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned char m)
+					struct comedi_subdevice *s,
+					unsigned char m)
 {
 	if (m & 0x100) {
 		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
@@ -511,7 +528,7 @@ static char pci9118_decode_error_status(struct comedi_device *dev,
 	}
 	if (m & 0x008) {
 		comedi_error(dev,
-			"A/D Burst Mode Overrun Status (Fatal Error!)");
+			     "A/D Burst Mode Overrun Status (Fatal Error!)");
 		devpriv->ai_maskerr &= ~0x008L;
 	}
 	if (m & 0x004) {
@@ -532,8 +549,10 @@ static char pci9118_decode_error_status(struct comedi_device *dev,
 	return 0;
 }
 
-static void pci9118_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
-	void *data, unsigned int num_bytes, unsigned int start_chan_index)
+static void pci9118_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s, void *data,
+			     unsigned int num_bytes,
+			     unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
 	short *array = data;
@@ -553,8 +572,10 @@ static void pci9118_ai_munge(struct comedi_device *dev, struct comedi_subdevice
 ==============================================================================
 */
 static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned short int_adstat, unsigned int int_amcc,
-	unsigned short int_daq)
+					   struct comedi_subdevice *s,
+					   unsigned short int_adstat,
+					   unsigned int int_amcc,
+					   unsigned short int_daq)
 {
 	register short sampl;
 
@@ -570,9 +591,9 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 	if (devpriv->ai16bits == 0) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
 			printk
-				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
-				sampl & 0x000f,
-				devpriv->chanlist[s->async->cur_chan]);
+			    ("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
+			     sampl & 0x000f,
+			     devpriv->chanlist[s->async->cur_chan]);
 			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 			pci9118_ai_cancel(dev, s);
 			comedi_event(dev, s);
@@ -599,9 +620,11 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned short int_adstat, unsigned int int_amcc,
-	unsigned short int_daq)
+static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     unsigned short int_adstat,
+				     unsigned int int_amcc,
+				     unsigned short int_daq)
 {
 	unsigned int next_dma_buf, samplesinbuf, sampls, m;
 
@@ -632,11 +655,11 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_su
 	if (devpriv->dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		outl(devpriv->dmabuf_hw[next_dma_buf],
-			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[next_dma_buf],
-			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
 		devpriv->dmabuf_used_size[next_dma_buf] =
-			devpriv->dmabuf_use_size[next_dma_buf];
+		    devpriv->dmabuf_use_size[next_dma_buf];
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
@@ -646,8 +669,8 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_su
 /* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr); */
 		sampls = m;
 		move_block_from_dma(dev, s,
-			devpriv->dmabuf_virt[devpriv->dma_actbuf],
-			samplesinbuf);
+				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
+				    samplesinbuf);
 		m = m - sampls;	/*  m= how many samples was transfered */
 	}
 /* DPRINTK("YYY\n"); */
@@ -662,9 +685,9 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_su
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
 	} else {		/*  restart DMA if is not used double buffering */
 		outl(devpriv->dmabuf_hw[0],
-			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		     devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[0],
-			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		     devpriv->iobase_a + AMCC_OP_REG_MWTC);
 		if (devpriv->ai_do == 4)
 			interrupt_pci9118_ai_mode4_switch(dev);
 	}
@@ -700,18 +723,18 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	/*  start stop of measure */
 				if (devpriv->ai12_startstop & START_AI_EXT) {
 					devpriv->ai12_startstop &=
-						~START_AI_EXT;
+					    ~START_AI_EXT;
 					if (!(devpriv->ai12_startstop &
-							STOP_AI_EXT))
+					      STOP_AI_EXT))
 						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
 					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	/*  start pacer */
 					outl(devpriv->AdControlReg,
-						dev->iobase + PCI9118_ADCNTRL);
+					     dev->iobase + PCI9118_ADCNTRL);
 				} else {
-					if (devpriv->
-						ai12_startstop & STOP_AI_EXT) {
+					if (devpriv->ai12_startstop &
+					    STOP_AI_EXT) {
 						devpriv->ai12_startstop &=
-							~STOP_AI_EXT;
+						    ~STOP_AI_EXT;
 						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
 						devpriv->ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
 					}
@@ -719,7 +742,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 			}
 
 		(devpriv->int_ai_func) (dev, dev->subdevices + 0, int_adstat,
-			int_amcc, int_daq);
+					int_amcc, int_daq);
 
 	}
 	return IRQ_HANDLED;
@@ -728,8 +751,8 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 /*
 ==============================================================================
 */
-static int pci9118_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int pci9118_ai_inttrig(struct comedi_device *dev,
+			      struct comedi_subdevice *s, unsigned int trignum)
 {
 	if (trignum != devpriv->ai_inttrig_start)
 		return -EINVAL;
@@ -741,7 +764,7 @@ static int pci9118_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	if (devpriv->ai_do != 3) {
 		start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-			devpriv->ai_divisor2);
+			    devpriv->ai_divisor2);
 		devpriv->AdControlReg |= AdControl_SoftG;
 	}
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -752,8 +775,9 @@ static int pci9118_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int pci9118_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -799,21 +823,21 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
+	    cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
 		cmd->start_src = TRIG_NOW;
 		err++;
 	}
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_INT &&
-		cmd->scan_begin_src != TRIG_FOLLOW) {
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_INT &&
+	    cmd->scan_begin_src != TRIG_FOLLOW) {
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		err++;
 	}
 
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
@@ -824,8 +848,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	}
 
 	if (cmd->stop_src != TRIG_NONE &&
-		cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
+	    cmd->stop_src != TRIG_COUNT &&
+	    cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
 		cmd->stop_src = TRIG_COUNT;
 		err++;
 	}
@@ -841,13 +865,13 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	}
 
 	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
-		(!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
-		(!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
+	    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
 		cmd->convert_src = TRIG_TIMER;
 		err++;
 	}
@@ -875,7 +899,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) &&
-		(cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
+	    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
 		cmd->scan_begin_src = TRIG_FOLLOW;
 		cmd->convert_arg = cmd->scan_begin_arg;
 		cmd->scan_begin_arg = 0;
@@ -938,8 +962,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
 		cmd->scan_end_arg =
-			cmd->chanlist_len * (cmd->scan_end_arg /
-			cmd->chanlist_len);
+		    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);
 		err++;
 	}
 
@@ -952,8 +975,8 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		tmp = cmd->scan_begin_arg;
 /* printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->scan_begin_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 /* printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
@@ -964,31 +987,31 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
-			&divisor2, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					  &divisor2, &cmd->convert_arg,
+					  cmd->flags & TRIG_ROUND_MASK);
 /* printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
 			err++;
 		if (cmd->scan_begin_src == TRIG_TIMER
-			&& cmd->convert_src == TRIG_NOW) {
+		    && cmd->convert_src == TRIG_NOW) {
 			if (cmd->convert_arg == 0) {
 				if (cmd->scan_begin_arg <
-					this_board->ai_ns_min *
-					(cmd->scan_end_arg + 2)) {
+				    this_board->ai_ns_min *
+				    (cmd->scan_end_arg + 2)) {
 					cmd->scan_begin_arg =
-						this_board->ai_ns_min *
-						(cmd->scan_end_arg + 2);
+					    this_board->ai_ns_min *
+					    (cmd->scan_end_arg + 2);
 /* printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
 				if (cmd->scan_begin_arg <
-					cmd->convert_arg * cmd->chanlist_len) {
+				    cmd->convert_arg * cmd->chanlist_len) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 /* printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
@@ -1001,7 +1024,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 	if (cmd->chanlist)
 		if (!check_channel_list(dev, s, cmd->chanlist_len,
-				cmd->chanlist, 0, 0))
+					cmd->chanlist, 0, 0))
 			return 5;	/*  incorrect channels list */
 
 	return 0;
@@ -1034,19 +1057,22 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
-				dev->minor, dmalen0,
-				devpriv->ai_n_realscanlen << 1);
+			    ("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			     dev->minor, dmalen0,
+			     devpriv->ai_n_realscanlen << 1);
 		} else {
 			/*  short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			DPRINTK
+			    ("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n",
+			     dmalen0, devpriv->ai_n_realscanlen,
+			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
 				printk
-					("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
-					dev->minor, dmalen0);
+				    ("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
+				     dev->minor, dmalen0);
 				dmalen0 = 4;
 			}
 		}
@@ -1056,19 +1082,22 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			printk
-				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
-				dev->minor, dmalen1,
-				devpriv->ai_n_realscanlen << 1);
+			    ("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+			     dev->minor, dmalen1,
+			     devpriv->ai_n_realscanlen << 1);
 		} else {
 			/*  short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
-			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			DPRINTK
+			    ("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n",
+			     dmalen1, devpriv->ai_n_realscanlen,
+			     devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
 				printk
-					("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
-					dev->minor, dmalen1);
+				    ("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
+				     dev->minor, dmalen1);
 				dmalen1 = 4;
 			}
 		}
@@ -1080,15 +1109,15 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		/*  if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
-			(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
-			(devpriv->ai_n_realscanlen << 1);
+		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
+		    (devpriv->ai_n_realscanlen << 1);
 		dmalen0 &= ~3L;
 		if (!dmalen0)
 			dmalen0 = i;	/*  uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
-			(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
-			(devpriv->ai_n_realscanlen << 1);
+		    (dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
+		    (devpriv->ai_n_realscanlen << 1);
 		dmalen1 &= ~3L;
 		if (!dmalen1)
 			dmalen1 = i;	/*  uff. very long scan? */
@@ -1096,23 +1125,25 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		if (!devpriv->ai_neverending) {
 			/*  fits whole measure into one DMA buffer? */
 			if (dmalen0 >
-				((devpriv->ai_n_realscanlen << 1) *
-					devpriv->ai_scans)) {
-				DPRINTK("3.0 ai_n_realscanlen=%d ai_scans=%d \n", devpriv->ai_n_realscanlen, devpriv->ai_scans);
+			    ((devpriv->ai_n_realscanlen << 1) *
+			     devpriv->ai_scans)) {
+				DPRINTK
+				    ("3.0 ai_n_realscanlen=%d ai_scans=%d \n",
+				     devpriv->ai_n_realscanlen,
+				     devpriv->ai_scans);
 				dmalen0 =
-					(devpriv->ai_n_realscanlen << 1) *
-					devpriv->ai_scans;
+				    (devpriv->ai_n_realscanlen << 1) *
+				    devpriv->ai_scans;
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
 			} else {	/*  fits whole measure into two DMA buffer? */
 				if (dmalen1 >
-					((devpriv->ai_n_realscanlen << 1) *
-						devpriv->ai_scans - dmalen0))
+				    ((devpriv->ai_n_realscanlen << 1) *
+				     devpriv->ai_scans - dmalen0))
 					dmalen1 =
-						(devpriv->
-						ai_n_realscanlen << 1) *
-						devpriv->ai_scans - dmalen0;
+					    (devpriv->ai_n_realscanlen << 1) *
+					    devpriv->ai_scans - dmalen0;
 				DPRINTK("3.2 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen1 &= ~3L;
@@ -1131,16 +1162,16 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 #if 0
 	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =
-			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
+		     1) * devpriv->ai_n_scanlen * sizeof(short);
 		devpriv->dmabuf_panic_size[1] =
-			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(short);
+		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
+		     1) * devpriv->ai_n_scanlen * sizeof(short);
 	} else {
 		devpriv->dmabuf_panic_size[0] =
-			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
+		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
 		devpriv->dmabuf_panic_size[1] =
-			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
+		    (devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
 	}
 #endif
 
@@ -1149,12 +1180,12 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
 	/*  init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
-		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 /* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
 
 	outl(inl(devpriv->iobase_a +
-			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
-		EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
+		 AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
+	     EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
 	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
@@ -1164,7 +1195,8 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_docmd_sampl(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
@@ -1183,7 +1215,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subde
 		return -EIO;
 	default:
 		comedi_error(dev,
-			"pci9118_ai_docmd_sampl() mode number bug!\n");
+			     "pci9118_ai_docmd_sampl() mode number bug!\n");
 		return -EIO;
 	};
 
@@ -1204,7 +1236,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subde
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		if (devpriv->ai_do != 3) {
 			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				devpriv->ai_divisor2);
+				    devpriv->ai_divisor2);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1217,7 +1249,8 @@ static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subde
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_dma(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_docmd_dma(struct comedi_device *dev,
+				struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
@@ -1226,34 +1259,34 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev, struct comedi_subdevi
 	switch (devpriv->ai_do) {
 	case 1:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		break;
 	case 2:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg =
-			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
-			AdFunction_BS;
+		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
+		    AdFunction_BS;
 		if (devpriv->usessh && (!devpriv->softsshdelay))
 			devpriv->AdFunctionReg |= AdFunction_BSSH;
 		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
 		break;
 	case 3:
 		devpriv->AdControlReg |=
-			((AdControl_ExtM | AdControl_Dma) & 0xff);
+		    ((AdControl_ExtM | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
 		break;
 	case 4:
 		devpriv->AdControlReg |=
-			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		    ((AdControl_TmrTr | AdControl_Dma) & 0xff);
 		devpriv->AdFunctionReg =
-			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+		    AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(0x30, dev->iobase + PCI9118_CNTCTRL);
 		outl((devpriv->dmabuf_hw[0] >> 1) & 0xff,
-			dev->iobase + PCI9118_CNT0);
+		     dev->iobase + PCI9118_CNT0);
 		outl((devpriv->dmabuf_hw[0] >> 9) & 0xff,
-			dev->iobase + PCI9118_CNT0);
+		     dev->iobase + PCI9118_CNT0);
 		devpriv->AdFunctionReg |= AdFunction_Start;
 		break;
 	default:
@@ -1268,14 +1301,14 @@ static int pci9118_ai_docmd_dma(struct comedi_device *dev, struct comedi_subdevi
 	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
-		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+	     devpriv->iobase_a + AMCC_OP_REG_INTCSR);
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 		if (devpriv->ai_do != 3) {
 			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
-				devpriv->ai_divisor2);
+				    devpriv->ai_divisor2);
 			devpriv->AdControlReg |= AdControl_SoftG;
 		}
 		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
@@ -1338,7 +1371,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW) {
 		devpriv->usessh = 1;
-	}			/*  yes */
+	} /*  yes */
 	else {
 		devpriv->usessh = 0;
 	}			/*  no */
@@ -1354,7 +1387,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->master) {
 		devpriv->usedma = 1;
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-			(devpriv->ai_n_scanlen == 1)) {
+		    (devpriv->ai_n_scanlen == 1)) {
 			if (cmd->convert_src == TRIG_NOW) {
 				devpriv->ai_add_back = 1;
 			}
@@ -1363,8 +1396,8 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
-			(devpriv->ai_n_scanlen & 1) &&
-			(devpriv->ai_n_scanlen > 1)) {
+		    (devpriv->ai_n_scanlen & 1) &&
+		    (devpriv->ai_n_scanlen > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
 				/* vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
 				devpriv->usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
@@ -1392,16 +1425,16 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
-						devpriv->ai_n_chan +
-						devpriv->ai_add_back) & 1)
+				     devpriv->ai_n_chan +
+				     devpriv->ai_add_back) & 1)
 					devpriv->ai_add_front++;	/*  round up to 32 bit */
 		}
-	}			/*  well, we now know what must be all added */
-
+	}
+	/*  well, we now know what must be all added */
 	devpriv->ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
-		(devpriv->ai_add_front + devpriv->ai_n_chan +
-		devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
-		devpriv->ai_n_chan);
+	    (devpriv->ai_add_front + devpriv->ai_n_chan +
+	     devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
+				      devpriv->ai_n_chan);
 
 	DPRINTK("2 usedma=%d realscan=%d af=%u n_chan=%d ab=%d n_scanlen=%d\n",
 		devpriv->usedma,
@@ -1411,13 +1444,13 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/*  check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
-			devpriv->ai_chanlist, devpriv->ai_add_front,
-			devpriv->ai_add_back))
+				devpriv->ai_chanlist, devpriv->ai_add_front,
+				devpriv->ai_add_back))
 		return -EINVAL;
 	if (!setup_channel_list(dev, s, devpriv->ai_n_chan,
-			devpriv->ai_chanlist, 0, devpriv->ai_add_front,
-			devpriv->ai_add_back, devpriv->usedma,
-			devpriv->useeoshandle))
+				devpriv->ai_chanlist, 0, devpriv->ai_add_front,
+				devpriv->ai_add_back, devpriv->usedma,
+				devpriv->useeoshandle))
 		return -EINVAL;
 
 	/*  compute timers settings */
@@ -1429,32 +1462,36 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			devpriv->ai_do = 1;
 		}
 		pci9118_calc_divisors(devpriv->ai_do, dev, s,
-			&cmd->scan_begin_arg, &cmd->convert_arg,
-			devpriv->ai_flags, devpriv->ai_n_realscanlen,
-			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
-			devpriv->usessh, devpriv->ai_add_front);
+				      &cmd->scan_begin_arg, &cmd->convert_arg,
+				      devpriv->ai_flags,
+				      devpriv->ai_n_realscanlen,
+				      &devpriv->ai_divisor1,
+				      &devpriv->ai_divisor2, devpriv->usessh,
+				      devpriv->ai_add_front);
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	/*  double timed action */
 		if (!devpriv->usedma) {
 			comedi_error(dev,
-				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
+				     "cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
 			return -EIO;
 		}
 
 		devpriv->ai_do = 2;
 		pci9118_calc_divisors(devpriv->ai_do, dev, s,
-			&cmd->scan_begin_arg, &cmd->convert_arg,
-			devpriv->ai_flags, devpriv->ai_n_realscanlen,
-			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
-			devpriv->usessh, devpriv->ai_add_front);
+				      &cmd->scan_begin_arg, &cmd->convert_arg,
+				      devpriv->ai_flags,
+				      devpriv->ai_n_realscanlen,
+				      &devpriv->ai_divisor1,
+				      &devpriv->ai_divisor2, devpriv->usessh,
+				      devpriv->ai_add_front);
 		devpriv->ai_timer1 = cmd->scan_begin_arg;
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
 	if ((cmd->scan_begin_src == TRIG_FOLLOW)
-		&& (cmd->convert_src == TRIG_EXT)) {
+	    && (cmd->convert_src == TRIG_EXT)) {
 		devpriv->ai_do = 3;
 	}
 
@@ -1486,8 +1523,9 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 /*
 ==============================================================================
 */
-static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
+static int check_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int frontadd, int backadd)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
 
@@ -1498,9 +1536,8 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
 		printk
-			("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
-			dev->minor, n_chan,
-			s->len_chanlist - frontadd - backadd);
+		    ("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
+		     dev->minor, n_chan, s->len_chanlist - frontadd - backadd);
 		return 0;
 	}
 
@@ -1511,22 +1548,21 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 	if (n_chan > 1)
 		for (i = 1; i < n_chan; i++) {	/*  check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
-				(differencial)) {
+			    (differencial)) {
 				comedi_error(dev,
-					"Differencial and single ended inputs cann't be mixtured!");
+					     "Differencial and single ended inputs cann't be mixtured!");
 				return 0;
 			}
 			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
-				(bipolar)) {
+			    (bipolar)) {
 				comedi_error(dev,
-					"Bipolar and unipolar ranges cann't be mixtured!");
+					     "Bipolar and unipolar ranges cann't be mixtured!");
 				return 0;
 			}
 			if ((!devpriv->usemux) & (differencial) &
-				(CR_CHAN(chanlist[i]) >=
-					this_board->n_aichand)) {
+			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
 				comedi_error(dev,
-					"If AREF_DIFF is used then is available only first 8 channels!");
+					     "If AREF_DIFF is used then is available only first 8 channels!");
 				return 0;
 			}
 		}
@@ -1537,14 +1573,17 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 /*
 ==============================================================================
 */
-static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
-	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
-	int usedma, char useeos)
+static int setup_channel_list(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int n_chan,
+			      unsigned int *chanlist, int rot, int frontadd,
+			      int backadd, int usedma, char useeos)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
 	unsigned int scanquad, gain, ssh = 0x00;
 
-	DPRINTK("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n", dev->minor, n_chan, rot, frontadd, backadd, usedma);
+	DPRINTK
+	    ("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n",
+	     dev->minor, n_chan, rot, frontadd, backadd, usedma);
 
 	if (usedma == 1) {
 		rot = 8;
@@ -1625,7 +1664,7 @@ static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 	if (useeos) {
 		for (i = 1; i < n_chan; i++) {	/*  store range list to card */
 			devpriv->chanlist[(n_chan + i) ^ usedma] =
-				(CR_CHAN(chanlist[i]) & 0xf) << rot;
+			    (CR_CHAN(chanlist[i]) & 0xf) << rot;
 		}
 		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 		useeos = 2;
@@ -1652,18 +1691,22 @@ static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
   calculate 8254 divisors if they are used for dual timing
 */
 static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
-	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
-	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
-	char usessh, unsigned int chnsshfront)
+				  struct comedi_subdevice *s,
+				  unsigned int *tim1, unsigned int *tim2,
+				  unsigned int flags, int chans,
+				  unsigned int *div1, unsigned int *div2,
+				  char usessh, unsigned int chnsshfront)
 {
-	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n", mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
+	DPRINTK
+	    ("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n",
+	     mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
 	switch (mode) {
 	case 1:
 	case 4:
 		if (*tim2 < this_board->ai_ns_min)
 			*tim2 = this_board->ai_ns_min;
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
-			tim2, flags & TRIG_ROUND_NEAREST);
+					  tim2, flags & TRIG_ROUND_NEAREST);
 		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u\n",
 			devpriv->i8254_osc_base, *div1, *div2, *tim1);
 		break;
@@ -1710,8 +1753,8 @@ static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
-	unsigned int divisor2)
+static void start_pacer(struct comedi_device *dev, int mode,
+			unsigned int divisor1, unsigned int divisor2)
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
@@ -1760,7 +1803,8 @@ static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int pci9118_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
@@ -1835,7 +1879,8 @@ static int pci9118_reset(struct comedi_device *dev)
 /*
 ==============================================================================
 */
-static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int pci9118_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, pages, i;
@@ -1848,8 +1893,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	unsigned char pci_bus, pci_slot, pci_func;
 	u16 u16w;
 
-	printk("comedi%d: adl_pci9118: board=%s", dev->minor,
-		this_board->name);
+	printk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);
 
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
@@ -1869,12 +1913,13 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	errstr = "not found!";
 	pcidev = NULL;
 	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
-				this_board->device_id, pcidev))) {
+						this_board->device_id,
+						pcidev))) {
 		/* Found matching vendor/device. */
 		if (opt_bus || opt_slot) {
 			/* Check bus/slot. */
 			if (opt_bus != pcidev->bus->number
-				|| opt_slot != PCI_SLOT(pcidev->devfn))
+			    || opt_slot != PCI_SLOT(pcidev->devfn))
 				continue;	/* no match */
 		}
 		/*
@@ -1882,7 +1927,8 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		 * Enable PCI device and request regions.
 		 */
 		if (comedi_pci_enable(pcidev, "adl_pci9118")) {
-			errstr = "failed to enable PCI device and request regions!";
+			errstr =
+			    "failed to enable PCI device and request regions!";
 			continue;
 		}
 		break;
@@ -1891,7 +1937,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
 			printk(" - Card at b:s %d:%d %s\n",
-				opt_bus, opt_slot, errstr);
+			       opt_bus, opt_slot, errstr);
 		} else {
 			printk(" - Card %s\n", errstr);
 		}
@@ -1910,7 +1956,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	iobase_9 = pci_resource_start(pcidev, 2);
 
 	printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
-		pci_func, iobase_9, iobase_a);
+	       pci_func, iobase_9, iobase_a);
 
 	dev->iobase = iobase_9;
 	dev->board_name = this_board->name;
@@ -1926,7 +1972,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
 			printk(", unable to allocate IRQ %d, DISABLING IT",
-				irq);
+			       irq);
 			irq = 0;	/* Can't use IRQ */
 		} else {
 			printk(", irq=%u", irq);
@@ -1942,8 +1988,8 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--) {
 				devpriv->dmabuf_virt[i] =
-					(short *) __get_free_pages(GFP_KERNEL,
-								   pages);
+				    (short *)__get_free_pages(GFP_KERNEL,
+							      pages);
 				if (devpriv->dmabuf_virt[i])
 					break;
 			}
@@ -1951,10 +1997,10 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 				devpriv->dmabuf_pages[i] = pages;
 				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
 				devpriv->dmabuf_samples[i] =
-					devpriv->dmabuf_size[i] >> 1;
+				    devpriv->dmabuf_size[i] >> 1;
 				devpriv->dmabuf_hw[i] =
-					virt_to_bus((void *)devpriv->
-					dmabuf_virt[i]);
+				    virt_to_bus((void *)
+						devpriv->dmabuf_virt[i]);
 			}
 		}
 		if (!devpriv->dmabuf_virt[0]) {
@@ -2090,10 +2136,10 @@ static int pci9118_detach(struct comedi_device *dev)
 		}
 		if (devpriv->dmabuf_virt[0])
 			free_pages((unsigned long)devpriv->dmabuf_virt[0],
-				devpriv->dmabuf_pages[0]);
+				   devpriv->dmabuf_pages[0]);
 		if (devpriv->dmabuf_virt[1])
 			free_pages((unsigned long)devpriv->dmabuf_virt[1],
-				devpriv->dmabuf_pages[1]);
+				   devpriv->dmabuf_pages[1]);
 	}
 
 	return 0;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 59b6498ded60..65f522be9124 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -80,7 +80,7 @@ Configuration options:
 
 #undef DPRINTK
 #ifdef PCI9118_EXTDEBUG
-#define DPRINTK(fmt, args...) rt_printk(fmt, ## args)
+#define DPRINTK(fmt, args...) printk(fmt, ## args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -345,12 +345,12 @@ static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevi
 
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
-		comedi_udelay(2);
+		udelay(2);
 		timeout = 100;
 		while (timeout--) {
 			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
 				goto conv_finish;
-			comedi_udelay(1);
+			udelay(1);
 		}
 
 		comedi_error(dev, "A/D insn timeout");
@@ -569,7 +569,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv->ai16bits == 0) {
 		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
-			rt_printk
+			printk
 				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
 				sampl & 0x000f,
 				devpriv->chanlist[s->async->cur_chan]);
@@ -950,11 +950,11 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-/* rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-/* rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -966,7 +966,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-/* rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -980,7 +980,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 					cmd->scan_begin_arg =
 						this_board->ai_ns_min *
 						(cmd->scan_end_arg + 2);
-/* rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
@@ -989,7 +989,7 @@ static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 					cmd->scan_begin_arg =
 						cmd->convert_arg *
 						cmd->chanlist_len;
-/* rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
+/* printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			}
@@ -1033,7 +1033,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			rt_printk
+			printk
 				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen0,
 				devpriv->ai_n_realscanlen << 1);
@@ -1044,7 +1044,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			if (devpriv->useeoshandle)
 				dmalen0 += 2;
 			if (dmalen0 < 4) {
-				rt_printk
+				printk
 					("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
 					dev->minor, dmalen0);
 				dmalen0 = 4;
@@ -1055,7 +1055,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
 			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
-			rt_printk
+			printk
 				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen1,
 				devpriv->ai_n_realscanlen << 1);
@@ -1066,7 +1066,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 			if (devpriv->useeoshandle)
 				dmalen1 -= 2;
 			if (dmalen1 < 4) {
-				rt_printk
+				printk
 					("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
 					dev->minor, dmalen1);
 				dmalen1 = 4;
@@ -1464,7 +1464,7 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
-	comedi_udelay(1);
+	udelay(1);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
 	inl(dev->iobase + PCI9118_INTSRC);
@@ -1497,7 +1497,7 @@ static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice
 		return 0;
 	}
 	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
-		rt_printk
+		printk
 			("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
 			dev->minor, n_chan,
 			s->len_chanlist - frontadd - backadd);
@@ -1641,7 +1641,7 @@ static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice
 #endif
 #endif
 	outl(0, dev->iobase + PCI9118_SCANMOD);	/*  close scan queue */
-/* comedi_udelay(100);                               important delay, or first sample will be cripled */
+/* udelay(100);                               important delay, or first sample will be cripled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
 	return 1;		/*  we can serve this with scan logic */
@@ -1716,7 +1716,7 @@ static void start_pacer(struct comedi_device *dev, int mode, unsigned int diviso
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
 /* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
-	comedi_udelay(1);
+	udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
 		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
@@ -1817,7 +1817,7 @@ static int pci9118_reset(struct comedi_device *dev)
 	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
 	outl(0, dev->iobase + PCI9118_DO);	/*  reset digi outs to L */
-	comedi_udelay(10);
+	udelay(10);
 	inl(dev->iobase + PCI9118_AD_DATA);
 	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	outl(0, dev->iobase + PCI9118_INTSRC);	/*  remove INT requests */
@@ -1848,7 +1848,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	unsigned char pci_bus, pci_slot, pci_func;
 	u16 u16w;
 
-	rt_printk("comedi%d: adl_pci9118: board=%s", dev->minor,
+	printk("comedi%d: adl_pci9118: board=%s", dev->minor,
 		this_board->name);
 
 	opt_bus = it->options[0];
@@ -1861,7 +1861,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	ret = alloc_private(dev, sizeof(struct pci9118_private));
 	if (ret < 0) {
-		rt_printk(" - Allocation failed!\n");
+		printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
 
@@ -1890,10 +1890,10 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	if (!pcidev) {
 		if (opt_bus || opt_slot) {
-			rt_printk(" - Card at b:s %d:%d %s\n",
+			printk(" - Card at b:s %d:%d %s\n",
 				opt_bus, opt_slot, errstr);
 		} else {
-			rt_printk(" - Card %s\n", errstr);
+			printk(" - Card %s\n", errstr);
 		}
 		return -EIO;
 	}
@@ -1909,7 +1909,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	iobase_a = pci_resource_start(pcidev, 0);
 	iobase_9 = pci_resource_start(pcidev, 2);
 
-	rt_printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
+	printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
 		pci_func, iobase_9, iobase_a);
 
 	dev->iobase = iobase_9;
@@ -1923,16 +1923,16 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	if (it->options[3] & 2)
 		irq = 0;	/*  user don't want use IRQ */
 	if (irq > 0) {
-		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
+		if (request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
-			rt_printk(", unable to allocate IRQ %d, DISABLING IT",
+			printk(", unable to allocate IRQ %d, DISABLING IT",
 				irq);
 			irq = 0;	/* Can't use IRQ */
 		} else {
-			rt_printk(", irq=%u", irq);
+			printk(", irq=%u", irq);
 		}
 	} else {
-		rt_printk(", IRQ disabled");
+		printk(", IRQ disabled");
 	}
 
 	dev->irq = irq;
@@ -1958,7 +1958,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 			}
 		}
 		if (!devpriv->dmabuf_virt[0]) {
-			rt_printk(", Can't allocate DMA buffer, DMA disabled!");
+			printk(", Can't allocate DMA buffer, DMA disabled!");
 			master = 0;
 		}
 
@@ -1969,9 +1969,9 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	devpriv->master = master;
 	if (devpriv->master)
-		rt_printk(", bus master");
+		printk(", bus master");
 	else
-		rt_printk(", no bus master");
+		printk(", no bus master");
 
 	devpriv->usemux = 0;
 	if (it->options[2] > 0) {
@@ -1982,7 +1982,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 			if (devpriv->usemux > 128) {
 				devpriv->usemux = 128;	/*  max 128 channels with softare S&H! */
 			}
-		rt_printk(", ext. mux %d channels", devpriv->usemux);
+		printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
@@ -1995,7 +1995,7 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		devpriv->softsshhold = 0x80;
 	}
 
-	rt_printk(".\n");
+	printk(".\n");
 
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
 	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
@@ -2081,7 +2081,7 @@ static int pci9118_detach(struct comedi_device *dev)
 		if (devpriv->valid)
 			pci9118_reset(dev);
 		if (dev->irq)
-			comedi_free_irq(dev->irq, dev);
+			free_irq(dev->irq, dev);
 		if (devpriv->pcidev) {
 			if (dev->iobase) {
 				comedi_pci_disable(devpriv->pcidev);

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index a1e669cf4cc6..59b6498ded60 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -231,13 +231,13 @@ static const struct boardtype boardtypes[] = {
 #define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
 
 static struct comedi_driver driver_pci9118 = {
-      driver_name:"adl_pci9118",
-      module:THIS_MODULE,
-      attach:pci9118_attach,
-      detach:pci9118_detach,
-      num_names:n_boardtypes,
-      board_name:&boardtypes[0].name,
-      offset:sizeof(struct boardtype),
+	.driver_name = "adl_pci9118",
+	.module = THIS_MODULE,
+	.attach = pci9118_attach,
+	.detach = pci9118_detach,
+	.num_names = n_boardtypes,
+	.board_name = &boardtypes[0].name,
+	.offset = sizeof(struct boardtype),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 20f7bf0c2b42..a1e669cf4cc6 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -1474,11 +1474,10 @@ static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	s->async->cur_chan = 0;
 	devpriv->ai_buf_ptr = 0;
 
-	if (devpriv->usedma) {
+	if (devpriv->usedma)
 		ret = pci9118_ai_docmd_dma(dev, s);
-	} else {
+	else
 		ret = pci9118_ai_docmd_sampl(dev, s);
-	}
 
 	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_cmd()\n");
 	return ret;
@@ -1860,7 +1859,8 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		master = 1;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct pci9118_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct pci9118_private));
+	if (ret < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}
@@ -1940,11 +1940,13 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	if (master) {		/*  alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
-			for (pages = 4; pages >= 0; pages--)
-				if ((devpriv->dmabuf_virt[i] = (short *)
-						__get_free_pages(GFP_KERNEL,
-							pages)))
+			for (pages = 4; pages >= 0; pages--) {
+				devpriv->dmabuf_virt[i] =
+					(short *) __get_free_pages(GFP_KERNEL,
+								   pages);
+				if (devpriv->dmabuf_virt[i])
 					break;
+			}
 			if (devpriv->dmabuf_virt[i]) {
 				devpriv->dmabuf_pages[i] = pages;
 				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
@@ -1965,11 +1967,11 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	}
 
-	if ((devpriv->master = master)) {
+	devpriv->master = master;
+	if (devpriv->master)
 		rt_printk(", bus master");
-	} else {
+	else
 		rt_printk(", no bus master");
-	}
 
 	devpriv->usemux = 0;
 	if (it->options[2] > 0) {
@@ -1998,7 +2000,8 @@ static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
 	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
 
-	if ((ret = alloc_subdevices(dev, 4)) < 0)
+	ret = alloc_subdevices(dev, 4);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 6a8a4e2d45aa..20f7bf0c2b42 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -179,8 +179,8 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 
 #define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
 
-static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int pci9118_detach(struct comedi_device * dev);
+static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int pci9118_detach(struct comedi_device *dev);
 
 struct boardtype {
 	const char *name;	/*  board name */
@@ -309,27 +309,27 @@ struct pci9118_private {
 ==============================================================================
 */
 
-static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
-static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char eoshandle);
-static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
-static int pci9118_reset(struct comedi_device * dev);
-static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source);
-static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source);
-static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+static int pci9118_reset(struct comedi_device *dev);
+static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source);
+static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source);
+static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront);
 
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci9118_insn_read_ai(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	int n, timeout;
@@ -378,8 +378,8 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static int pci9118_insn_write_ao(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci9118_insn_write_ao(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chanreg, ch;
 
@@ -401,8 +401,8 @@ static int pci9118_insn_write_ao(struct comedi_device * dev, struct comedi_subde
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ao(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci9118_insn_read_ao(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, chan;
 
@@ -416,8 +416,8 @@ static int pci9118_insn_read_ao(struct comedi_device * dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_di(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci9118_insn_bits_di(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
@@ -427,8 +427,8 @@ static int pci9118_insn_bits_di(struct comedi_device * dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_do(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int pci9118_insn_bits_do(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -443,7 +443,7 @@ static int pci9118_insn_bits_do(struct comedi_device * dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_mode4_switch(struct comedi_device * dev)
+static void interrupt_pci9118_ai_mode4_switch(struct comedi_device *dev)
 {
 	devpriv->AdFunctionReg =
 		AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
@@ -457,8 +457,8 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device * dev)
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 }
 
-static unsigned int defragment_dma_buffer(struct comedi_device * dev,
-	struct comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
+static unsigned int defragment_dma_buffer(struct comedi_device *dev,
+	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
@@ -481,8 +481,8 @@ static unsigned int defragment_dma_buffer(struct comedi_device * dev,
 /*
 ==============================================================================
 */
-static unsigned int move_block_from_dma(struct comedi_device * dev,
-	struct comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
+static unsigned int move_block_from_dma(struct comedi_device *dev,
+	struct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)
 {
 	unsigned int num_bytes;
 
@@ -502,8 +502,8 @@ static unsigned int move_block_from_dma(struct comedi_device * dev,
 /*
 ==============================================================================
 */
-static char pci9118_decode_error_status(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned char m)
+static char pci9118_decode_error_status(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned char m)
 {
 	if (m & 0x100) {
 		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
@@ -532,7 +532,7 @@ static char pci9118_decode_error_status(struct comedi_device * dev,
 	return 0;
 }
 
-static void pci9118_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
+static void pci9118_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,
 	void *data, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
@@ -552,8 +552,8 @@ static void pci9118_ai_munge(struct comedi_device * dev, struct comedi_subdevice
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
+static void interrupt_pci9118_ai_onesample(struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
 	register short sampl;
@@ -599,7 +599,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_subdevice * s,
+static void interrupt_pci9118_ai_dma(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
@@ -728,7 +728,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d)
 /*
 ==============================================================================
 */
-static int pci9118_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int pci9118_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != devpriv->ai_inttrig_start)
@@ -752,8 +752,8 @@ static int pci9118_ai_inttrig(struct comedi_device * dev, struct comedi_subdevic
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int pci9118_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1010,7 +1010,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 /*
 ==============================================================================
 */
-static int Compute_and_setup_dma(struct comedi_device * dev)
+static int Compute_and_setup_dma(struct comedi_device *dev)
 {
 	unsigned int dmalen0, dmalen1, i;
 
@@ -1164,7 +1164,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_sampl(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci9118_ai_docmd_sampl(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
@@ -1217,7 +1217,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device * dev, struct comedi_subd
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci9118_ai_docmd_dma(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
@@ -1288,7 +1288,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdev
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
@@ -1487,7 +1487,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 /*
 ==============================================================================
 */
-static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int check_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
@@ -1538,7 +1538,7 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 /*
 ==============================================================================
 */
-static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device *dev, struct comedi_subdevice *s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char useeos)
 {
@@ -1652,8 +1652,8 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 ==============================================================================
   calculate 8254 divisors if they are used for dual timing
 */
-static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
-	struct comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+static void pci9118_calc_divisors(char mode, struct comedi_device *dev,
+	struct comedi_subdevice *s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront)
 {
@@ -1711,7 +1711,7 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 /*
 ==============================================================================
 */
-static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
@@ -1730,7 +1730,7 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 /*
 ==============================================================================
 */
-static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
+static int pci9118_exttrg_add(struct comedi_device *dev, unsigned char source)
 {
 	if (source > 3)
 		return -1;	/*  incorrect source */
@@ -1744,7 +1744,7 @@ static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
+static int pci9118_exttrg_del(struct comedi_device *dev, unsigned char source)
 {
 	if (source > 3)
 		return -1;	/*  incorrect source */
@@ -1761,7 +1761,7 @@ static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int pci9118_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
@@ -1796,7 +1796,7 @@ static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 /*
 ==============================================================================
 */
-static int pci9118_reset(struct comedi_device * dev)
+static int pci9118_reset(struct comedi_device *dev)
 {
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
@@ -1836,7 +1836,7 @@ static int pci9118_reset(struct comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int pci9118_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int ret, pages, i;
@@ -2072,7 +2072,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 /*
 ==============================================================================
 */
-static int pci9118_detach(struct comedi_device * dev)
+static int pci9118_detach(struct comedi_device *dev)
 {
 	if (dev->private) {
 		if (devpriv->valid)

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9f0f9deafc3d..6a8a4e2d45aa 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -66,6 +66,7 @@ Configuration options:
 #include "../pci_ids.h"
 
 #include <linux/delay.h>
+#include <linux/interrupt.h>
 
 #include "amcc_s5933.h"
 #include "8253.h"
@@ -674,7 +675,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 /*
 ==============================================================================
 */
-static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
+static irqreturn_t interrupt_pci9118(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned int int_daq = 0, int_amcc, int_adstat;

commit 0f04c356551f9ae55d9a0c5ea211699903cf1f93
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:30:23 2009 -0400

    Staging: comedi: remove C99 comments in adl_pci9118.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 278cf30cc4a3..9f0f9deafc3d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -107,7 +107,7 @@ Configuration options:
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-// bits from A/D control register (PCI9118_ADCNTRL)
+/* bits from A/D control register (PCI9118_ADCNTRL) */
 #define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
 #define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
 #define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
@@ -117,7 +117,7 @@ Configuration options:
 #define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
 #define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
 
-// bits from A/D function register (PCI9118_ADFUNC)
+/* bits from A/D function register (PCI9118_ADFUNC) */
 #define AdFunction_PDTrg	0x80	/* 1=positive, 0=negative digital trigger (only positive is correct) */
 #define AdFunction_PETrg	0x40	/* 1=positive, 0=negative external trigger (only positive is correct) */
 #define AdFunction_BSSH		0x20	/* 1=with sample&hold, 0=without */
@@ -127,7 +127,7 @@ Configuration options:
 #define AdFunction_AM		0x02	/* 1=about trigger mode, 0=not about trigger */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
-// bits from A/D status register (PCI9118_ADSTAT)
+/* bits from A/D status register (PCI9118_ADSTAT) */
 #define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
 #define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
 #define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
@@ -138,8 +138,8 @@ Configuration options:
 #define AdStatus_ADOR	0x002	/* 1=A/D overrun (fatal) */
 #define AdStatus_ADrdy	0x001	/* 1=A/D already ready, 0=not ready */
 
-// bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL)
-// 1=interrupt occur, enable source,  0=interrupt not occur, disable source
+/* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
+/* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
 #define Int_About	0x04	/* about trigger complete */
 #define Int_Hfull	0x02	/* A/D FIFO hlaf full */
@@ -182,23 +182,23 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 static int pci9118_detach(struct comedi_device * dev);
 
 struct boardtype {
-	const char *name;	// board name
-	int vendor_id;		// PCI vendor a device ID of card
+	const char *name;	/*  board name */
+	int vendor_id;		/*  PCI vendor a device ID of card */
 	int device_id;
-	int iorange_amcc;	// iorange for own S5933 region
-	int iorange_9118;	// pass thru card region size
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int mux_aichan;		// num of A/D chans with external multiplexor
-	int n_aichanlist;	// len of chanlist
-	int n_aochan;		// num of D/A chans
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
-	unsigned int ai_ns_min;	// max sample speed of card v ns
-	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
-	int half_fifo_size;	// size of FIFO/2
+	int iorange_amcc;	/*  iorange for own S5933 region */
+	int iorange_9118;	/*  pass thru card region size */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int mux_aichan;		/*  num of A/D chans with external multiplexor */
+	int n_aichanlist;	/*  len of chanlist */
+	int n_aochan;		/*  num of D/A chans */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
+	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
+	unsigned int ai_pacer_min;	/*  minimal pacer value (c1*c2 or c1 in burst) */
+	int half_fifo_size;	/*  size of FIFO/2 */
 
 };
 
@@ -242,63 +242,63 @@ static struct comedi_driver driver_pci9118 = {
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
 
 struct pci9118_private {
-	unsigned long iobase_a;	// base+size for AMCC chip
-	unsigned int master;	// master capable
-	struct pci_dev *pcidev;	// ptr to actual pcidev
-	unsigned int usemux;	// we want to use external multiplexor!
+	unsigned long iobase_a;	/*  base+size for AMCC chip */
+	unsigned int master;	/*  master capable */
+	struct pci_dev *pcidev;	/*  ptr to actual pcidev */
+	unsigned int usemux;	/*  we want to use external multiplexor! */
 #ifdef PCI9118_PARANOIDCHECK
-	unsigned short chanlist[PCI9118_CHANLEN + 1];	// list of scaned channel
-	unsigned char chanlistlen;	// number of scanlist
+	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*  list of scaned channel */
+	unsigned char chanlistlen;	/*  number of scanlist */
 #endif
-	unsigned char AdControlReg;	// A/D control register
-	unsigned char IntControlReg;	// Interrupt control register
-	unsigned char AdFunctionReg;	// A/D function register
-	char valid;		// driver is ok
-	char ai_neverending;	// we do unlimited AI
-	unsigned int i8254_osc_base;	// frequence of onboard oscilator
-	unsigned int ai_do;	// what do AI? 0=nothing, 1 to 4 mode
-	unsigned int ai_act_scan;	// how many scans we finished
-	unsigned int ai_buf_ptr;	// data buffer ptr in samples
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int ai_n_scanlen;	// len of actual scanlist
-	unsigned int ai_n_realscanlen;	// what we must transfer for one outgoing scan include front/back adds
-	unsigned int ai_act_dmapos;	// position in actual real stream
-	unsigned int ai_add_front;	// how many channels we must add before scan to satisfy S&H?
-	unsigned int ai_add_back;	// how many channels we must add before scan to satisfy DMA?
-	unsigned int *ai_chanlist;	// actaul chanlist
+	unsigned char AdControlReg;	/*  A/D control register */
+	unsigned char IntControlReg;	/*  Interrupt control register */
+	unsigned char AdFunctionReg;	/*  A/D function register */
+	char valid;		/*  driver is ok */
+	char ai_neverending;	/*  we do unlimited AI */
+	unsigned int i8254_osc_base;	/*  frequence of onboard oscilator */
+	unsigned int ai_do;	/*  what do AI? 0=nothing, 1 to 4 mode */
+	unsigned int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_buf_ptr;	/*  data buffer ptr in samples */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int ai_n_scanlen;	/*  len of actual scanlist */
+	unsigned int ai_n_realscanlen;	/*  what we must transfer for one outgoing scan include front/back adds */
+	unsigned int ai_act_dmapos;	/*  position in actual real stream */
+	unsigned int ai_add_front;	/*  how many channels we must add before scan to satisfy S&H? */
+	unsigned int ai_add_back;	/*  how many channels we must add before scan to satisfy DMA? */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
-	char ai12_startstop;	// measure can start/stop on external trigger
-	unsigned int ai_divisor1, ai_divisor2;	// divisors for start of measure on external start
+	char ai12_startstop;	/*  measure can start/stop on external trigger */
+	unsigned int ai_divisor1, ai_divisor2;	/*  divisors for start of measure on external start */
 	unsigned int ai_data_len;
 	short *ai_data;
-	short ao_data[2];	// data output buffer
-	unsigned int ai_scans;	// number of scans to do
-	char dma_doublebuf;	// we can use double buffring
-	unsigned int dma_actbuf;	// which buffer is used now
-	short *dmabuf_virt[2];	// pointers to begin of DMA buffer
-	unsigned long dmabuf_hw[2];	// hw address of DMA buff
-	unsigned int dmabuf_size[2];	// size of dma buffer in bytes
-	unsigned int dmabuf_use_size[2];	// which size we may now used for transfer
-	unsigned int dmabuf_used_size[2];	// which size was trully used
+	short ao_data[2];	/*  data output buffer */
+	unsigned int ai_scans;	/*  number of scans to do */
+	char dma_doublebuf;	/*  we can use double buffring */
+	unsigned int dma_actbuf;	/*  which buffer is used now */
+	short *dmabuf_virt[2];	/*  pointers to begin of DMA buffer */
+	unsigned long dmabuf_hw[2];	/*  hw address of DMA buff */
+	unsigned int dmabuf_size[2];	/*  size of dma buffer in bytes */
+	unsigned int dmabuf_use_size[2];	/*  which size we may now used for transfer */
+	unsigned int dmabuf_used_size[2];	/*  which size was trully used */
 	unsigned int dmabuf_panic_size[2];
-	unsigned int dmabuf_samples[2];	// size in samples
-	int dmabuf_pages[2];	// number of pages in buffer
-	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
-	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
-	unsigned int cnt0_divisor;	// actual CNT0 divisor
-	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
-	unsigned char ai16bits;	// =1 16 bit card
-	unsigned char usedma;	// =1 use DMA transfer and not INT
-	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
-	unsigned char usessh;	// =1 turn on S&H support
-	int softsshdelay;	// >0 use software S&H, numer is requested delay in ns
-	unsigned char softsshsample;	// polarity of S&H signal in sample state
-	unsigned char softsshhold;	// polarity of S&H signal in hold state
-	unsigned int ai_maskerr;	// which warning was printed
-	unsigned int ai_maskharderr;	// on which error bits stops
-	unsigned int ai_inttrig_start;	// TRIG_INT for start
+	unsigned int dmabuf_samples[2];	/*  size in samples */
+	int dmabuf_pages[2];	/*  number of pages in buffer */
+	unsigned char cnt0_users;	/*  bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO) */
+	unsigned char exttrg_users;	/*  bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO) */
+	unsigned int cnt0_divisor;	/*  actual CNT0 divisor */
+	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	/*  ptr to actual interrupt AI function */
+	unsigned char ai16bits;	/*  =1 16 bit card */
+	unsigned char usedma;	/*  =1 use DMA transfer and not INT */
+	unsigned char useeoshandle;	/*  =1 change WAKE_EOS DMA transfer to fit on every second */
+	unsigned char usessh;	/*  =1 turn on S&H support */
+	int softsshdelay;	/*  >0 use software S&H, numer is requested delay in ns */
+	unsigned char softsshsample;	/*  polarity of S&H signal in sample state */
+	unsigned char softsshhold;	/*  polarity of S&H signal in hold state */
+	unsigned int ai_maskerr;	/*  which warning was printed */
+	unsigned int ai_maskharderr;	/*  on which error bits stops */
+	unsigned int ai_inttrig_start;	/*  TRIG_INT for start */
 };
 
 #define devpriv ((struct pci9118_private *)dev->private)
@@ -335,12 +335,12 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 
 	devpriv->AdControlReg = AdControl_Int & 0xff;
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))
 		return -EINVAL;
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	for (n = 0; n < insn->n; n++) {
 		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
@@ -354,7 +354,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 
 		comedi_error(dev, "A/D insn timeout");
 		data[n] = 0;
-		outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+		outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 		return -ETIME;
 
 	      conv_finish:
@@ -369,7 +369,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 		}
 	}
 
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	return n;
 
 }
@@ -567,7 +567,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv->ai16bits == 0) {
-		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	// data dropout!
+		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	/*  data dropout! */
 			rt_printk
 				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
 				sampl & 0x000f,
@@ -621,14 +621,14 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 	}
 
 	if (int_adstat & devpriv->ai_maskerr)
-//      if (int_adstat & 0x106)
+/* if (int_adstat & 0x106) */
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	// number of received real samples
-//      DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf);
+	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	/*  number of received real samples */
+/* DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf); */
 
-	if (devpriv->dma_doublebuf) {	// switch DMA buffers if is used double buffering
+	if (devpriv->dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv->dma_actbuf;
 		outl(devpriv->dmabuf_hw[next_dma_buf],
 			devpriv->iobase_a + AMCC_OP_REG_MWAR);
@@ -641,15 +641,15 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 	}
 
 	if (samplesinbuf) {
-		m = devpriv->ai_data_len >> 1;	// how many samples is to end of buffer
-//              DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr);
+		m = devpriv->ai_data_len >> 1;	/*  how many samples is to end of buffer */
+/* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr); */
 		sampls = m;
 		move_block_from_dma(dev, s,
 			devpriv->dmabuf_virt[devpriv->dma_actbuf],
 			samplesinbuf);
-		m = m - sampls;	// m= how many samples was transfered
+		m = m - sampls;	/*  m= how many samples was transfered */
 	}
-//      DPRINTK("YYY\n");
+/* DPRINTK("YYY\n"); */
 
 	if (!devpriv->ai_neverending)
 		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
@@ -657,9 +657,9 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 			s->async->events |= COMEDI_CB_EOA;
 		}
 
-	if (devpriv->dma_doublebuf) {	// switch dma buffers
+	if (devpriv->dma_doublebuf) {	/*  switch dma buffers */
 		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
-	} else {		// restart DMA if is not used double buffering
+	} else {		/*  restart DMA if is not used double buffering */
 		outl(devpriv->dmabuf_hw[0],
 			devpriv->iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv->dmabuf_use_size[0],
@@ -680,30 +680,30 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev->attached)
-		return IRQ_NONE;	// not fully initialized
+		return IRQ_NONE;	/*  not fully initialized */
 
-	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	// get IRQ reasons from card
-	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// get INT register from AMCC chip
+	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	/*  get IRQ reasons from card */
+	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  get INT register from AMCC chip */
 
-//      DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do);
+/* DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do); */
 
 	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
-		return IRQ_NONE;	// interrupt from other source
+		return IRQ_NONE;	/*  interrupt from other source */
 
-	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// shutdown IRQ reasons in AMCC
+	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  shutdown IRQ reasons in AMCC */
 
-	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	// get STATUS register
+	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	/*  get STATUS register */
 
 	if (devpriv->ai_do) {
 		if (devpriv->ai12_startstop)
-			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	// start stop of measure
+			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	/*  start stop of measure */
 				if (devpriv->ai12_startstop & START_AI_EXT) {
 					devpriv->ai12_startstop &=
 						~START_AI_EXT;
 					if (!(devpriv->ai12_startstop &
 							STOP_AI_EXT))
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	// start pacer
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	/*  start pacer */
 					outl(devpriv->AdControlReg,
 						dev->iobase + PCI9118_ADCNTRL);
 				} else {
@@ -711,8 +711,8 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 						ai12_startstop & STOP_AI_EXT) {
 						devpriv->ai12_startstop &=
 							~STOP_AI_EXT;
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-						devpriv->ai_neverending = 0;	//well, on next interrupt from DMA/EOC measure will stop
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+						devpriv->ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
 					}
 				}
 			}
@@ -949,11 +949,11 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-//              rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-//              rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->scan_begin_arg < this_board->ai_ns_min)
 			cmd->scan_begin_arg = this_board->ai_ns_min;
 		if (tmp != cmd->scan_begin_arg)
@@ -965,7 +965,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
 			&divisor2, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
-//              rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 		if (cmd->convert_arg < this_board->ai_ns_min)
 			cmd->convert_arg = this_board->ai_ns_min;
 		if (tmp != cmd->convert_arg)
@@ -979,7 +979,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 					cmd->scan_begin_arg =
 						this_board->ai_ns_min *
 						(cmd->scan_end_arg + 2);
-//              rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			} else {
@@ -988,7 +988,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 					cmd->scan_begin_arg =
 						cmd->convert_arg *
 						cmd->chanlist_len;
-//              rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+/* rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg); */
 					err++;
 				}
 			}
@@ -1001,7 +1001,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 	if (cmd->chanlist)
 		if (!check_channel_list(dev, s, cmd->chanlist_len,
 				cmd->chanlist, 0, 0))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 
 	return 0;
 }
@@ -1018,26 +1018,26 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	dmalen1 = devpriv->dmabuf_size[1];
 	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
 		devpriv->ai_data_len);
-	// isn't output buff smaller that our DMA buff?
+	/*  isn't output buff smaller that our DMA buff? */
 	if (dmalen0 > (devpriv->ai_data_len)) {
-		dmalen0 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+		dmalen0 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
 	}
 	if (dmalen1 > (devpriv->ai_data_len)) {
-		dmalen1 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+		dmalen1 = devpriv->ai_data_len & ~3L;	/*  allign to 32bit down */
 	}
 	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// we want wake up every scan?
+	/*  we want wake up every scan? */
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen0,
 				devpriv->ai_n_realscanlen << 1);
 		} else {
-			// short first DMA buffer to one scan
+			/*  short first DMA buffer to one scan */
 			dmalen0 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
@@ -1052,14 +1052,14 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
 		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
 				dev->minor, dmalen1,
 				devpriv->ai_n_realscanlen << 1);
 		} else {
-			// short second DMA buffer to one scan
+			/*  short second DMA buffer to one scan */
 			dmalen1 = devpriv->ai_n_realscanlen << 1;
 			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
 			if (devpriv->useeoshandle)
@@ -1074,26 +1074,26 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 
 	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
-	// transfer without TRIG_WAKE_EOS
+	/*  transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
-		// if it's possible then allign DMA buffers to length of scan
+		/*  if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 			(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
 			(devpriv->ai_n_realscanlen << 1);
 		dmalen0 &= ~3L;
 		if (!dmalen0)
-			dmalen0 = i;	// uff. very long scan?
+			dmalen0 = i;	/*  uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
 			(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
 			(devpriv->ai_n_realscanlen << 1);
 		dmalen1 &= ~3L;
 		if (!dmalen1)
-			dmalen1 = i;	// uff. very long scan?
-		// if measure isn't neverending then test, if it whole fits into one or two DMA buffers
+			dmalen1 = i;	/*  uff. very long scan? */
+		/*  if measure isn't neverending then test, if it whole fits into one or two DMA buffers */
 		if (!devpriv->ai_neverending) {
-			// fits whole measure into one DMA buffer?
+			/*  fits whole measure into one DMA buffer? */
 			if (dmalen0 >
 				((devpriv->ai_n_realscanlen << 1) *
 					devpriv->ai_scans)) {
@@ -1104,7 +1104,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &= ~3L;
-			} else {	// fits whole measure into two DMA buffer?
+			} else {	/*  fits whole measure into two DMA buffer? */
 				if (dmalen1 >
 					((devpriv->ai_n_realscanlen << 1) *
 						devpriv->ai_scans - dmalen0))
@@ -1121,7 +1121,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 
 	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// these DMA buffer size we'll be used
+	/*  these DMA buffer size we'll be used */
 	devpriv->dma_actbuf = 0;
 	devpriv->dmabuf_use_size[0] = dmalen0;
 	devpriv->dmabuf_use_size[1] = dmalen1;
@@ -1143,18 +1143,18 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 #endif
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
 	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
-	// init DMA transfer
+	/*  init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
-//      outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR);
+/* outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR); */
 
 	outl(inl(devpriv->iobase_a +
 			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
 		EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow bus mastering
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
 	return 0;
@@ -1186,17 +1186,17 @@ static int pci9118_ai_docmd_sampl(struct comedi_device * dev, struct comedi_subd
 		return -EIO;
 	};
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	//transfer function
+	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	/* transfer function */
 
 	if (devpriv->ai12_startstop)
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 
 	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
 		devpriv->IntControlReg |= Int_Timer;
 
 	devpriv->AdControlReg |= AdControl_Int;
 
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
@@ -1261,10 +1261,10 @@ static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdev
 	};
 
 	if (devpriv->ai12_startstop) {
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 	}
 
-	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	//transfer function
+	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
 		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
@@ -1307,7 +1307,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 	devpriv->ai_add_back = 0;
 	devpriv->ai_maskerr = 0x10e;
 
-	// prepare for start/stop conditions
+	/*  prepare for start/stop conditions */
 	if (cmd->start_src == TRIG_EXT)
 		devpriv->ai12_startstop |= START_AI_EXT;
 	if (cmd->stop_src == TRIG_EXT) {
@@ -1334,19 +1334,19 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv->ai_scans = 0;
 	}
 
-	// use sample&hold signal?
+	/*  use sample&hold signal? */
 	if (cmd->convert_src == TRIG_NOW) {
 		devpriv->usessh = 1;
-	}			// yes
+	}			/*  yes */
 	else {
 		devpriv->usessh = 0;
-	}			// no
+	}			/*  no */
 
 	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
 		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
 		devpriv->ai12_startstop);
 
-	// use additional sample at end of every scan to satisty DMA 32 bit transfer?
+	/*  use additional sample at end of every scan to satisty DMA 32 bit transfer? */
 	devpriv->ai_add_front = 0;
 	devpriv->ai_add_back = 0;
 	devpriv->useeoshandle = 0;
@@ -1358,27 +1358,27 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 				devpriv->ai_add_back = 1;
 			}
 			if (cmd->convert_src == TRIG_TIMER) {
-				devpriv->usedma = 0;	// use INT transfer if scanlist have only one channel
+				devpriv->usedma = 0;	/*  use INT transfer if scanlist have only one channel */
 			}
 		}
 		if ((cmd->flags & TRIG_WAKE_EOS) &&
 			(devpriv->ai_n_scanlen & 1) &&
 			(devpriv->ai_n_scanlen > 1)) {
 			if (cmd->scan_begin_src == TRIG_FOLLOW) {
-				//vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call
-				devpriv->usedma = 0;	// XXX maybe can be corrected to use 16 bit DMA
-			} else {	// well, we must insert one sample to end of EOS to meet 32 bit transfer
+				/* vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
+				devpriv->usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
+			} else {	/*  well, we must insert one sample to end of EOS to meet 32 bit transfer */
 				devpriv->ai_add_back = 1;
 			}
 		}
-	} else {		// interrupt transfer don't need any correction
+	} else {		/*  interrupt transfer don't need any correction */
 		devpriv->usedma = 0;
 	}
 
-	// we need software S&H signal? It add  two samples before every scan as minimum
+	/*  we need software S&H signal? It add  two samples before every scan as minimum */
 	if (devpriv->usessh && devpriv->softsshdelay) {
 		devpriv->ai_add_front = 2;
-		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	// move it to front
+		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	/*  move it to front */
 			devpriv->ai_add_front++;
 			devpriv->ai_add_back = 0;
 		}
@@ -1387,17 +1387,17 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		addchans = devpriv->softsshdelay / cmd->convert_arg;
 		if (devpriv->softsshdelay % cmd->convert_arg)
 			addchans++;
-		if (addchans > (devpriv->ai_add_front - 1)) {	// uff, still short :-(
+		if (addchans > (devpriv->ai_add_front - 1)) {	/*  uff, still short :-( */
 			devpriv->ai_add_front = addchans + 1;
 			if (devpriv->usedma == 1)
 				if ((devpriv->ai_add_front +
 						devpriv->ai_n_chan +
 						devpriv->ai_add_back) & 1)
-					devpriv->ai_add_front++;	// round up to 32 bit
+					devpriv->ai_add_front++;	/*  round up to 32 bit */
 		}
-	}			// well, we now know what must be all added
+	}			/*  well, we now know what must be all added */
 
-	devpriv->ai_n_realscanlen =	// what we must take from card in real to have ai_n_scanlen on output?
+	devpriv->ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
 		(devpriv->ai_add_front + devpriv->ai_n_chan +
 		devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
 		devpriv->ai_n_chan);
@@ -1408,7 +1408,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv->ai_n_chan, devpriv->ai_add_back,
 		devpriv->ai_n_scanlen);
 
-	// check and setup channel list
+	/*  check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
 			devpriv->ai_chanlist, devpriv->ai_add_front,
 			devpriv->ai_add_back))
@@ -1419,9 +1419,9 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 			devpriv->useeoshandle))
 		return -EINVAL;
 
-	// compute timers settings
-	// simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect
-	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	// both timer is used for one time
+	/*  compute timers settings */
+	/*  simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect */
+	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	/*  both timer is used for one time */
 		if (cmd->scan_begin_src == TRIG_EXT) {
 			devpriv->ai_do = 4;
 		} else {
@@ -1435,7 +1435,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv->ai_timer2 = cmd->convert_arg;
 	}
 
-	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	// double timed action
+	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	/*  double timed action */
 		if (!devpriv->usedma) {
 			comedi_error(dev,
 				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
@@ -1457,15 +1457,15 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv->ai_do = 3;
 	}
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
-	devpriv->AdControlReg = 0;	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA
+	devpriv->AdControlReg = 0;	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA */
 	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
-	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 	comedi_udelay(1);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
-	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D and INT status register
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
 	inl(dev->iobase + PCI9118_INTSRC);
 
 	devpriv->ai_act_scan = 0;
@@ -1505,11 +1505,11 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 	if (n_chan > 1)
-		for (i = 1; i < n_chan; i++) {	// check S.E/diff
+		for (i = 1; i < n_chan; i++) {	/*  check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 				(differencial)) {
 				comedi_error(dev,
@@ -1552,27 +1552,27 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 
-	// All is ok, so we can setup channel/range list
+	/*  All is ok, so we can setup channel/range list */
 
 	if (!bipolar) {
-		devpriv->AdControlReg |= AdControl_UniP;	// set unibipolar
+		devpriv->AdControlReg |= AdControl_UniP;	/*  set unibipolar */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	// enable bipolar
+		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	/*  enable bipolar */
 	}
 
 	if (differencial) {
-		devpriv->AdControlReg |= AdControl_Diff;	// enable diff inputs
+		devpriv->AdControlReg |= AdControl_Diff;	/*  enable diff inputs */
 	} else {
-		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	// set single ended inputs
+		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	/*  set single ended inputs */
 	}
 
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// setup mode
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  setup mode */
 
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// gods know why this sequence!
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  gods know why this sequence! */
 	outl(0, dev->iobase + PCI9118_SCANMOD);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
 
@@ -1582,12 +1582,12 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 		devpriv->chanlist[i] = 0x55aa;
 #endif
 
-	if (frontadd) {		// insert channels for S&H
+	if (frontadd) {		/*  insert channels for S&H */
 		ssh = devpriv->softsshsample;
 		DPRINTK("FA: %04x: ", ssh);
-		for (i = 0; i < frontadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i < frontadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1597,23 +1597,23 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	DPRINTK("SL: ", ssh);
-	for (i = 0; i < n_chan; i++) {	// store range list to card
-		scanquad = CR_CHAN(chanlist[i]);	// get channel number;
+	for (i = 0; i < n_chan; i++) {	/*  store range list to card */
+		scanquad = CR_CHAN(chanlist[i]);	/*  get channel number; */
 #ifdef PCI9118_PARANOIDCHECK
 		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
 #endif
-		gain = CR_RANGE(chanlist[i]);	// get gain number
+		gain = CR_RANGE(chanlist[i]);	/*  get gain number */
 		scanquad |= ((gain & 0x03) << 8);
 		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 		DPRINTK("%02x ", scanquad | ssh);
 	}
 	DPRINTK("\n ");
 
-	if (backadd) {		// insert channels for fit onto 32bit DMA
+	if (backadd) {		/*  insert channels for fit onto 32bit DMA */
 		DPRINTK("BA: %04x: ", ssh);
-		for (i = 0; i < backadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i < backadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain & 0x03) << 8);
 			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1621,13 +1621,13 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 		DPRINTK("\n ");
 	}
 #ifdef PCI9118_PARANOIDCHECK
-	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 	if (useeos) {
-		for (i = 1; i < n_chan; i++) {	// store range list to card
+		for (i = 1; i < n_chan; i++) {	/*  store range list to card */
 			devpriv->chanlist[(n_chan + i) ^ usedma] =
 				(CR_CHAN(chanlist[i]) & 0xf) << rot;
 		}
-		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	/*  for 32bit oerations */
 		useeos = 2;
 	} else {
 		useeos = 1;
@@ -1640,11 +1640,11 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	DPRINTK("\n ");
 #endif
 #endif
-	outl(0, dev->iobase + PCI9118_SCANMOD);	// close scan queue
-//      comedi_udelay(100);                             // important delay, or first sample will be cripled
+	outl(0, dev->iobase + PCI9118_SCANMOD);	/*  close scan queue */
+/* comedi_udelay(100);                               important delay, or first sample will be cripled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
-	return 1;		// we can serve this with scan logic
+	return 1;		/*  we can serve this with scan logic */
 }
 
 /*
@@ -1672,17 +1672,17 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 			*tim2 = this_board->ai_ns_min;
 		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div1 = *tim2 / devpriv->i8254_osc_base;	// convert timer (burst)
+		*div1 = *tim2 / devpriv->i8254_osc_base;	/*  convert timer (burst) */
 		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div1 < this_board->ai_pacer_min)
 			*div1 = this_board->ai_pacer_min;
 		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *tim1 / devpriv->i8254_osc_base;	// scan timer
+		*div2 = *tim1 / devpriv->i8254_osc_base;	/*  scan timer */
 		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *div2 / *div1;	// major timer is c1*c2
+		*div2 = *div2 / *div1;	/*  major timer is c1*c2 */
 		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div2 < chans)
@@ -1690,9 +1690,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 
-		*tim2 = *div1 * devpriv->i8254_osc_base;	// real convert timer
+		*tim2 = *div1 * devpriv->i8254_osc_base;	/*  real convert timer */
 
-		if (usessh & (chnsshfront == 0))	// use BSSH signal
+		if (usessh & (chnsshfront == 0))	/*  use BSSH signal */
 			if (*div2 < (chans + 2))
 				*div2 = chans + 2;
 
@@ -1715,7 +1715,7 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-//      outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+/* outl(0x30, dev->iobase + PCI9118_CNTCTRL); */
 	comedi_udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
@@ -1732,11 +1732,11 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv->exttrg_users |= (1 << source);
 	devpriv->IntControlReg |= Int_DTrg;
 	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
-	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 	return 0;
 }
 
@@ -1746,12 +1746,12 @@ static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv->exttrg_users &= ~(1 << source);
-	if (!devpriv->exttrg_users) {	// shutdown ext trg intterrupts
+	if (!devpriv->exttrg_users) {	/*  shutdown ext trg intterrupts */
 		devpriv->IntControlReg &= ~Int_DTrg;
-		if (!devpriv->IntControlReg)	// all IRQ disabled
-			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// disable int in AMCC
+		if (!devpriv->IntControlReg)	/*  all IRQ disabled */
+			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  disable int in AMCC */
 		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
 	}
 	return 0;
@@ -1763,17 +1763,17 @@ static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->usedma)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	devpriv->AdControlReg = 0x00;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	devpriv->ai_do = 0;
 	devpriv->usedma = 0;
@@ -1787,7 +1787,7 @@ static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 	devpriv->dma_actbuf = 0;
 
 	if (!devpriv->IntControlReg)
-		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	return 0;
 }
@@ -1800,31 +1800,31 @@ static int pci9118_reset(struct comedi_device * dev)
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
 	inl(dev->iobase + PCI9118_INTCTRL);
-	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	// disable interrupts source
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	/*  disable interrupts source */
 	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
-//        outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+/* outl(0xb4, dev->iobase + PCI9118_CNTCTRL); */
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev->iobase + PCI9118_BURST);
 	outl(1, dev->iobase + PCI9118_SCANMOD);
-	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
+	outl(2, dev->iobase + PCI9118_SCANMOD);	/*  reset scan queue */
 	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	devpriv->ao_data[0] = 2047;
 	devpriv->ao_data[1] = 2047;
-	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	// reset A/D outs to 0V
+	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
 	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
-	outl(0, dev->iobase + PCI9118_DO);	// reset digi outs to L
+	outl(0, dev->iobase + PCI9118_DO);	/*  reset digi outs to L */
 	comedi_udelay(10);
 	inl(dev->iobase + PCI9118_AD_DATA);
-	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
-	outl(0, dev->iobase + PCI9118_INTSRC);	// remove INT requests
-	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D status register
-	inl(dev->iobase + PCI9118_INTSRC);	// flush INT requests
+	outl(0, dev->iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(0, dev->iobase + PCI9118_INTSRC);	/*  remove INT requests */
+	inl(dev->iobase + PCI9118_ADSTAT);	/*  flush A/D status register */
+	inl(dev->iobase + PCI9118_INTSRC);	/*  flush INT requests */
 	devpriv->AdControlReg = 0;
-	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 
 	devpriv->cnt0_users = 0;
 	devpriv->exttrg_users = 0;
@@ -1854,7 +1854,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	opt_bus = it->options[0];
 	opt_slot = it->options[1];
 	if (it->options[3] & 1) {
-		master = 0;	// user don't want use bus master
+		master = 0;	/*  user don't want use bus master */
 	} else {
 		master = 1;
 	}
@@ -1920,7 +1920,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	pci9118_reset(dev);
 
 	if (it->options[3] & 2)
-		irq = 0;	// user don't want use IRQ
+		irq = 0;	/*  user don't want use IRQ */
 	if (irq > 0) {
 		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
@@ -1936,7 +1936,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 	dev->irq = irq;
 
-	if (master) {		// alloc DMA buffers
+	if (master) {		/*  alloc DMA buffers */
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--)
@@ -1974,16 +1974,16 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	if (it->options[2] > 0) {
 		devpriv->usemux = it->options[2];
 		if (devpriv->usemux > 256)
-			devpriv->usemux = 256;	// max 256 channels!
+			devpriv->usemux = 256;	/*  max 256 channels! */
 		if (it->options[4] > 0)
 			if (devpriv->usemux > 128) {
-				devpriv->usemux = 128;	// max 128 channels with softare S&H!
+				devpriv->usemux = 128;	/*  max 128 channels with softare S&H! */
 			}
 		rt_printk(", ext. mux %d channels", devpriv->usemux);
 	}
 
 	devpriv->softsshdelay = it->options[4];
-	if (devpriv->softsshdelay < 0) {	// select sample&hold signal polarity
+	if (devpriv->softsshdelay < 0) {	/*  select sample&hold signal polarity */
 		devpriv->softsshdelay = -devpriv->softsshdelay;
 		devpriv->softsshsample = 0x80;
 		devpriv->softsshhold = 0x00;
@@ -1995,7 +1995,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	rt_printk(".\n");
 
 	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
-	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	// Enable parity check for parity error
+	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
 
 	if ((ret = alloc_subdevices(dev, 4)) < 0)
 		return ret;
@@ -2052,9 +2052,9 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	s->insn_bits = pci9118_insn_bits_do;
 
 	devpriv->valid = 1;
-	devpriv->i8254_osc_base = 250;	// 250ns=4MHz
-	devpriv->ai_maskharderr = 0x10a;	// default measure crash condition
-	if (it->options[5])	// disable some requested
+	devpriv->i8254_osc_base = 250;	/*  250ns=4MHz */
+	devpriv->ai_maskharderr = 0x10a;	/*  default measure crash condition */
+	if (it->options[5])	/*  disable some requested */
 		devpriv->ai_maskharderr &= ~it->options[5];
 
 	switch (this_board->ai_maxdata) {

commit 5b5fc21b060cc7a2a68ea3f3e145442f589000b6
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:07:57 2009 -0400

    Staging: comedi: Remove pci9118_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index ca4d780f0785..278cf30cc4a3 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -241,7 +241,7 @@ static struct comedi_driver driver_pci9118 = {
 
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
 
-typedef struct {
+struct pci9118_private {
 	unsigned long iobase_a;	// base+size for AMCC chip
 	unsigned int master;	// master capable
 	struct pci_dev *pcidev;	// ptr to actual pcidev
@@ -299,9 +299,9 @@ typedef struct {
 	unsigned int ai_maskerr;	// which warning was printed
 	unsigned int ai_maskharderr;	// on which error bits stops
 	unsigned int ai_inttrig_start;	// TRIG_INT for start
-} pci9118_private;
+};
 
-#define devpriv ((pci9118_private *)dev->private)
+#define devpriv ((struct pci9118_private *)dev->private)
 #define this_board ((struct boardtype *)dev->board_ptr)
 
 /*
@@ -1859,7 +1859,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 		master = 1;
 	}
 
-	if ((ret = alloc_private(dev, sizeof(pci9118_private))) < 0) {
+	if ((ret = alloc_private(dev, sizeof(struct pci9118_private))) < 0) {
 		rt_printk(" - Allocation failed!\n");
 		return -ENOMEM;
 	}

commit 193a21e402f023c786490dacd864b642898976d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:07:52 2009 -0400

    Staging: comedi: Remove boardtype typedef in adl_pci9118.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 131498a5b69a..ca4d780f0785 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -181,7 +181,7 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pci9118_detach(struct comedi_device * dev);
 
-typedef struct {
+struct boardtype {
 	const char *name;	// board name
 	int vendor_id;		// PCI vendor a device ID of card
 	int device_id;
@@ -200,7 +200,7 @@ typedef struct {
 	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
 	int half_fifo_size;	// size of FIFO/2
 
-} boardtype;
+};
 
 static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
 	{PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
@@ -209,7 +209,7 @@ static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, pci9118_pci_table);
 
-static const boardtype boardtypes[] = {
+static const struct boardtype boardtypes[] = {
 	{"pci9118dg", PCI_VENDOR_ID_AMCC, 0x80d9,
 			AMCC_OP_REG_SIZE, IORANGE_9118,
 			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
@@ -227,7 +227,7 @@ static const boardtype boardtypes[] = {
 		10000, 40, 512},
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+#define n_boardtypes (sizeof(boardtypes)/sizeof(struct boardtype))
 
 static struct comedi_driver driver_pci9118 = {
       driver_name:"adl_pci9118",
@@ -236,7 +236,7 @@ static struct comedi_driver driver_pci9118 = {
       detach:pci9118_detach,
       num_names:n_boardtypes,
       board_name:&boardtypes[0].name,
-      offset:sizeof(boardtype),
+      offset:sizeof(struct boardtype),
 };
 
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
@@ -302,7 +302,7 @@ typedef struct {
 } pci9118_private;
 
 #define devpriv ((pci9118_private *)dev->private)
-#define this_board ((boardtype *)dev->board_ptr)
+#define this_board ((struct boardtype *)dev->board_ptr)
 
 /*
 ==============================================================================

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 406eab7fd435..131498a5b69a 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -178,7 +178,7 @@ static const struct comedi_lrange range_pci9118hg = { 8, {
 
 #define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
 
-static int pci9118_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int pci9118_detach(struct comedi_device * dev);
 
 typedef struct {
@@ -1835,7 +1835,7 @@ static int pci9118_reset(struct comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	int ret, pages, i;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index cc3ea6cfdb81..406eab7fd435 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -328,7 +328,7 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 ==============================================================================
 */
 static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 
 	int n, timeout;
@@ -378,7 +378,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 ==============================================================================
 */
 static int pci9118_insn_write_ao(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, chanreg, ch;
 
@@ -401,7 +401,7 @@ static int pci9118_insn_write_ao(struct comedi_device * dev, struct comedi_subde
 ==============================================================================
 */
 static int pci9118_insn_read_ao(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, chan;
 
@@ -416,7 +416,7 @@ static int pci9118_insn_read_ao(struct comedi_device * dev, struct comedi_subdev
 ==============================================================================
 */
 static int pci9118_insn_bits_di(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
@@ -427,7 +427,7 @@ static int pci9118_insn_bits_di(struct comedi_device * dev, struct comedi_subdev
 ==============================================================================
 */
 static int pci9118_insn_bits_do(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 71745f128722..cc3ea6cfdb81 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -752,7 +752,7 @@ static int pci9118_ai_inttrig(struct comedi_device * dev, struct comedi_subdevic
 ==============================================================================
 */
 static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp, divisor1, divisor2;
@@ -1289,7 +1289,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdev
 */
 static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
 	int ret = 0;
 

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index e2a6c29534d2..71745f128722 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -152,7 +152,7 @@ Configuration options:
 
 #define EXTTRG_AI	0	/* ext trg is used by AI */
 
-static const comedi_lrange range_pci9118dg_hr = { 8, {
+static const struct comedi_lrange range_pci9118dg_hr = { 8, {
 			BIP_RANGE(5),
 			BIP_RANGE(2.5),
 			BIP_RANGE(1.25),
@@ -164,7 +164,7 @@ static const comedi_lrange range_pci9118dg_hr = { 8, {
 	}
 };
 
-static const comedi_lrange range_pci9118hg = { 8, {
+static const struct comedi_lrange range_pci9118hg = { 8, {
 			BIP_RANGE(5),
 			BIP_RANGE(0.5),
 			BIP_RANGE(0.05),
@@ -194,8 +194,8 @@ typedef struct {
 	int n_aochan;		// num of D/A chans
 	int ai_maxdata;		// resolution of A/D
 	int ao_maxdata;		// resolution of D/A
-	const comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const comedi_lrange *rangelist_ao;	// rangelist for D/A
+	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
+	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
 	unsigned int ai_ns_min;	// max sample speed of card v ns
 	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
 	int half_fifo_size;	// size of FIFO/2

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 67e26a3c847c..e2a6c29534d2 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -229,7 +229,7 @@ static const boardtype boardtypes[] = {
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
 
-static comedi_driver driver_pci9118 = {
+static struct comedi_driver driver_pci9118 = {
       driver_name:"adl_pci9118",
       module:THIS_MODULE,
       attach:pci9118_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index c352e37d97ae..67e26a3c847c 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -288,7 +288,7 @@ typedef struct {
 	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
 	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
 	unsigned int cnt0_divisor;	// actual CNT0 divisor
-	void (*int_ai_func) (struct comedi_device *, comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
+	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
 	unsigned char ai16bits;	// =1 16 bit card
 	unsigned char usedma;	// =1 use DMA transfer and not INT
 	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
@@ -308,9 +308,9 @@ typedef struct {
 ==============================================================================
 */
 
-static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
-static int setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char eoshandle);
 static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
@@ -318,16 +318,16 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 static int pci9118_reset(struct comedi_device * dev);
 static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source);
 static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source);
-static int pci9118_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+	struct comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront);
 
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ai(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 
@@ -377,7 +377,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, comedi_subdevice * s
 /*
 ==============================================================================
 */
-static int pci9118_insn_write_ao(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_write_ao(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, chanreg, ch;
@@ -400,7 +400,7 @@ static int pci9118_insn_write_ao(struct comedi_device * dev, comedi_subdevice *
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ao(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_read_ao(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, chan;
@@ -415,7 +415,7 @@ static int pci9118_insn_read_ao(struct comedi_device * dev, comedi_subdevice * s
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_di(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_bits_di(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
@@ -426,7 +426,7 @@ static int pci9118_insn_bits_di(struct comedi_device * dev, comedi_subdevice * s
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_do(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_bits_do(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -457,7 +457,7 @@ static void interrupt_pci9118_ai_mode4_switch(struct comedi_device * dev)
 }
 
 static unsigned int defragment_dma_buffer(struct comedi_device * dev,
-	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
+	struct comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
@@ -481,7 +481,7 @@ static unsigned int defragment_dma_buffer(struct comedi_device * dev,
 ==============================================================================
 */
 static unsigned int move_block_from_dma(struct comedi_device * dev,
-	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
+	struct comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int num_bytes;
 
@@ -502,7 +502,7 @@ static unsigned int move_block_from_dma(struct comedi_device * dev,
 ==============================================================================
 */
 static char pci9118_decode_error_status(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned char m)
+	struct comedi_subdevice * s, unsigned char m)
 {
 	if (m & 0x100) {
 		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
@@ -531,7 +531,7 @@ static char pci9118_decode_error_status(struct comedi_device * dev,
 	return 0;
 }
 
-static void pci9118_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
+static void pci9118_ai_munge(struct comedi_device * dev, struct comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
@@ -552,7 +552,7 @@ static void pci9118_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
 */
 static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
-	comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
+	struct comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
 	register short sampl;
@@ -598,7 +598,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_dma(struct comedi_device * dev, comedi_subdevice * s,
+static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
@@ -727,7 +727,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 /*
 ==============================================================================
 */
-static int pci9118_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_ai_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != devpriv->ai_inttrig_start)
@@ -751,7 +751,7 @@ static int pci9118_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1163,7 +1163,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_sampl(struct comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_docmd_sampl(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
@@ -1216,7 +1216,7 @@ static int pci9118_ai_docmd_sampl(struct comedi_device * dev, comedi_subdevice *
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_dma(struct comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
@@ -1287,7 +1287,7 @@ static int pci9118_ai_docmd_dma(struct comedi_device * dev, comedi_subdevice * s
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
@@ -1486,7 +1486,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 /*
 ==============================================================================
 */
-static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
@@ -1537,7 +1537,7 @@ static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char useeos)
 {
@@ -1652,7 +1652,7 @@ static int setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
   calculate 8254 divisors if they are used for dual timing
 */
 static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
-	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+	struct comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront)
 {
@@ -1760,7 +1760,7 @@ static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
@@ -1837,7 +1837,7 @@ static int pci9118_reset(struct comedi_device * dev)
 */
 static int pci9118_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int ret, pages, i;
 	unsigned short master;
 	unsigned int irq;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 9dc30b282973..c352e37d97ae 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -178,8 +178,8 @@ static const comedi_lrange range_pci9118hg = { 8, {
 
 #define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
 
-static int pci9118_attach(comedi_device * dev, comedi_devconfig * it);
-static int pci9118_detach(comedi_device * dev);
+static int pci9118_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int pci9118_detach(struct comedi_device * dev);
 
 typedef struct {
 	const char *name;	// board name
@@ -288,7 +288,7 @@ typedef struct {
 	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
 	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
 	unsigned int cnt0_divisor;	// actual CNT0 divisor
-	void (*int_ai_func) (comedi_device *, comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
+	void (*int_ai_func) (struct comedi_device *, comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
 	unsigned char ai16bits;	// =1 16 bit card
 	unsigned char usedma;	// =1 use DMA transfer and not INT
 	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
@@ -308,18 +308,18 @@ typedef struct {
 ==============================================================================
 */
 
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
-static int setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char eoshandle);
-static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2);
-static int pci9118_reset(comedi_device * dev);
-static int pci9118_exttrg_add(comedi_device * dev, unsigned char source);
-static int pci9118_exttrg_del(comedi_device * dev, unsigned char source);
-static int pci9118_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static void pci9118_calc_divisors(char mode, comedi_device * dev,
+static int pci9118_reset(struct comedi_device * dev);
+static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source);
+static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source);
+static int pci9118_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront);
@@ -327,7 +327,7 @@ static void pci9118_calc_divisors(char mode, comedi_device * dev,
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_read_ai(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 
@@ -377,7 +377,7 @@ static int pci9118_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_write_ao(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, chanreg, ch;
@@ -400,7 +400,7 @@ static int pci9118_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_read_ao(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, chan;
@@ -415,7 +415,7 @@ static int pci9118_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_bits_di(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
@@ -426,7 +426,7 @@ static int pci9118_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_insn_bits_do(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -442,7 +442,7 @@ static int pci9118_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_mode4_switch(comedi_device * dev)
+static void interrupt_pci9118_ai_mode4_switch(struct comedi_device * dev)
 {
 	devpriv->AdFunctionReg =
 		AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
@@ -456,7 +456,7 @@ static void interrupt_pci9118_ai_mode4_switch(comedi_device * dev)
 	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
 }
 
-static unsigned int defragment_dma_buffer(comedi_device * dev,
+static unsigned int defragment_dma_buffer(struct comedi_device * dev,
 	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
@@ -480,7 +480,7 @@ static unsigned int defragment_dma_buffer(comedi_device * dev,
 /*
 ==============================================================================
 */
-static unsigned int move_block_from_dma(comedi_device * dev,
+static unsigned int move_block_from_dma(struct comedi_device * dev,
 	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int num_bytes;
@@ -501,7 +501,7 @@ static unsigned int move_block_from_dma(comedi_device * dev,
 /*
 ==============================================================================
 */
-static char pci9118_decode_error_status(comedi_device * dev,
+static char pci9118_decode_error_status(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned char m)
 {
 	if (m & 0x100) {
@@ -531,7 +531,7 @@ static char pci9118_decode_error_status(comedi_device * dev,
 	return 0;
 }
 
-static void pci9118_ai_munge(comedi_device * dev, comedi_subdevice * s,
+static void pci9118_ai_munge(struct comedi_device * dev, comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int start_chan_index)
 {
 	unsigned int i, num_samples = num_bytes / sizeof(short);
@@ -551,7 +551,7 @@ static void pci9118_ai_munge(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_onesample(comedi_device * dev,
+static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
 	comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
@@ -598,7 +598,7 @@ static void interrupt_pci9118_ai_onesample(comedi_device * dev,
 /*
 ==============================================================================
 */
-static void interrupt_pci9118_ai_dma(comedi_device * dev, comedi_subdevice * s,
+static void interrupt_pci9118_ai_dma(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
@@ -676,7 +676,7 @@ static void interrupt_pci9118_ai_dma(comedi_device * dev, comedi_subdevice * s,
 */
 static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev->attached)
@@ -727,7 +727,7 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 /*
 ==============================================================================
 */
-static int pci9118_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_ai_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	if (trignum != devpriv->ai_inttrig_start)
@@ -751,7 +751,7 @@ static int pci9118_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int pci9118_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1009,7 +1009,7 @@ static int pci9118_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int Compute_and_setup_dma(comedi_device * dev)
+static int Compute_and_setup_dma(struct comedi_device * dev)
 {
 	unsigned int dmalen0, dmalen1, i;
 
@@ -1163,7 +1163,7 @@ static int Compute_and_setup_dma(comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_sampl(comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_docmd_sampl(struct comedi_device * dev, comedi_subdevice * s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
 		dev->minor, devpriv->ai_do);
@@ -1216,7 +1216,7 @@ static int pci9118_ai_docmd_sampl(comedi_device * dev, comedi_subdevice * s)
 /*
 ==============================================================================
 */
-static int pci9118_ai_docmd_dma(comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_docmd_dma(struct comedi_device * dev, comedi_subdevice * s)
 {
 	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
 		dev->minor, devpriv->ai_do, devpriv->usedma);
@@ -1287,7 +1287,7 @@ static int pci9118_ai_docmd_dma(comedi_device * dev, comedi_subdevice * s)
 /*
 ==============================================================================
 */
-static int pci9118_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int addchans = 0;
@@ -1486,7 +1486,7 @@ static int pci9118_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 /*
 ==============================================================================
 */
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
 {
 	unsigned int i, differencial = 0, bipolar = 0;
@@ -1537,7 +1537,7 @@ static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
 /*
 ==============================================================================
 */
-static int setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int setup_channel_list(struct comedi_device * dev, comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
 	int usedma, char useeos)
 {
@@ -1651,7 +1651,7 @@ static int setup_channel_list(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
   calculate 8254 divisors if they are used for dual timing
 */
-static void pci9118_calc_divisors(char mode, comedi_device * dev,
+static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
 	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
 	char usessh, unsigned int chnsshfront)
@@ -1710,7 +1710,7 @@ static void pci9118_calc_divisors(char mode, comedi_device * dev,
 /*
 ==============================================================================
 */
-static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+static void start_pacer(struct comedi_device * dev, int mode, unsigned int divisor1,
 	unsigned int divisor2)
 {
 	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
@@ -1729,7 +1729,7 @@ static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
 /*
 ==============================================================================
 */
-static int pci9118_exttrg_add(comedi_device * dev, unsigned char source)
+static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
 		return -1;	// incorrect source
@@ -1743,7 +1743,7 @@ static int pci9118_exttrg_add(comedi_device * dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_exttrg_del(comedi_device * dev, unsigned char source)
+static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 {
 	if (source > 3)
 		return -1;	// incorrect source
@@ -1760,7 +1760,7 @@ static int pci9118_exttrg_del(comedi_device * dev, unsigned char source)
 /*
 ==============================================================================
 */
-static int pci9118_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int pci9118_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	if (devpriv->usedma)
 		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
@@ -1795,7 +1795,7 @@ static int pci9118_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 /*
 ==============================================================================
 */
-static int pci9118_reset(comedi_device * dev)
+static int pci9118_reset(struct comedi_device * dev)
 {
 	devpriv->IntControlReg = 0;
 	devpriv->exttrg_users = 0;
@@ -1835,7 +1835,7 @@ static int pci9118_reset(comedi_device * dev)
 /*
 ==============================================================================
 */
-static int pci9118_attach(comedi_device * dev, comedi_devconfig * it)
+static int pci9118_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	int ret, pages, i;
@@ -2071,7 +2071,7 @@ static int pci9118_attach(comedi_device * dev, comedi_devconfig * it)
 /*
 ==============================================================================
 */
-static int pci9118_detach(comedi_device * dev)
+static int pci9118_detach(struct comedi_device * dev)
 {
 	if (dev->private) {
 		if (devpriv->valid)

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 5149c748fe8f..9dc30b282973 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -272,12 +272,12 @@ typedef struct {
 	char ai12_startstop;	// measure can start/stop on external trigger
 	unsigned int ai_divisor1, ai_divisor2;	// divisors for start of measure on external start
 	unsigned int ai_data_len;
-	sampl_t *ai_data;
-	sampl_t ao_data[2];	// data output buffer
+	short *ai_data;
+	short ao_data[2];	// data output buffer
 	unsigned int ai_scans;	// number of scans to do
 	char dma_doublebuf;	// we can use double buffring
 	unsigned int dma_actbuf;	// which buffer is used now
-	sampl_t *dmabuf_virt[2];	// pointers to begin of DMA buffer
+	short *dmabuf_virt[2];	// pointers to begin of DMA buffer
 	unsigned long dmabuf_hw[2];	// hw address of DMA buff
 	unsigned int dmabuf_size[2];	// size of dma buffer in bytes
 	unsigned int dmabuf_use_size[2];	// which size we may now used for transfer
@@ -328,7 +328,7 @@ static void pci9118_calc_divisors(char mode, comedi_device * dev,
 ==============================================================================
 */
 static int pci9118_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 
 	int n, timeout;
@@ -378,7 +378,7 @@ static int pci9118_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
 */
 static int pci9118_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, chanreg, ch;
 
@@ -401,7 +401,7 @@ static int pci9118_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
 */
 static int pci9118_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, chan;
 
@@ -416,7 +416,7 @@ static int pci9118_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
 */
 static int pci9118_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
 
@@ -427,7 +427,7 @@ static int pci9118_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
 ==============================================================================
 */
 static int pci9118_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -457,7 +457,7 @@ static void interrupt_pci9118_ai_mode4_switch(comedi_device * dev)
 }
 
 static unsigned int defragment_dma_buffer(comedi_device * dev,
-	comedi_subdevice * s, sampl_t * dma_buffer, unsigned int num_samples)
+	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int i = 0, j = 0;
 	unsigned int start_pos = devpriv->ai_add_front,
@@ -481,7 +481,7 @@ static unsigned int defragment_dma_buffer(comedi_device * dev,
 ==============================================================================
 */
 static unsigned int move_block_from_dma(comedi_device * dev,
-	comedi_subdevice * s, sampl_t * dma_buffer, unsigned int num_samples)
+	comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
 	unsigned int num_bytes;
 
@@ -492,8 +492,8 @@ static unsigned int move_block_from_dma(comedi_device * dev,
 	s->async->cur_chan %= devpriv->ai_n_scanlen;
 	num_bytes =
 		cfc_write_array_to_buffer(s, dma_buffer,
-		num_samples * sizeof(sampl_t));
-	if (num_bytes < num_samples * sizeof(sampl_t))
+		num_samples * sizeof(short));
+	if (num_bytes < num_samples * sizeof(short))
 		return -1;
 	return 0;
 }
@@ -534,8 +534,8 @@ static char pci9118_decode_error_status(comedi_device * dev,
 static void pci9118_ai_munge(comedi_device * dev, comedi_subdevice * s,
 	void *data, unsigned int num_bytes, unsigned int start_chan_index)
 {
-	unsigned int i, num_samples = num_bytes / sizeof(sampl_t);
-	sampl_t *array = data;
+	unsigned int i, num_samples = num_bytes / sizeof(short);
+	short *array = data;
 
 	for (i = 0; i < num_samples; i++) {
 		if (devpriv->usedma)
@@ -555,7 +555,7 @@ static void interrupt_pci9118_ai_onesample(comedi_device * dev,
 	comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
 	unsigned short int_daq)
 {
-	register sampl_t sampl;
+	register short sampl;
 
 	s->async->events = 0;
 
@@ -1131,10 +1131,10 @@ static int Compute_and_setup_dma(comedi_device * dev)
 	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
 		devpriv->dmabuf_panic_size[0] =
 			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(sampl_t);
+			1) * devpriv->ai_n_scanlen * sizeof(short);
 		devpriv->dmabuf_panic_size[1] =
 			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
-			1) * devpriv->ai_n_scanlen * sizeof(sampl_t);
+			1) * devpriv->ai_n_scanlen * sizeof(short);
 	} else {
 		devpriv->dmabuf_panic_size[0] =
 			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
@@ -1940,7 +1940,7 @@ static int pci9118_attach(comedi_device * dev, comedi_devconfig * it)
 		devpriv->dma_doublebuf = 0;
 		for (i = 0; i < 2; i++) {
 			for (pages = 4; pages >= 0; pages--)
-				if ((devpriv->dmabuf_virt[i] = (sampl_t *)
+				if ((devpriv->dmabuf_virt[i] = (short *)
 						__get_free_pages(GFP_KERNEL,
 							pages)))
 					break;

commit 3063d6de562c568839deff0aecd9fa4415fbb7fb
Author: Michal Dobes <dobes@tesnet.cz>
Date:   Thu Feb 12 15:44:54 2009 -0800

    Staging: comedi: add adl_pci9118 driver
    
    For ADLink cards:
            PCI-9118DG, PCI-9118HG, PCI-9118HR
    
    From: Michal Dobes <dobes@tesnet.cz>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
new file mode 100644
index 000000000000..5149c748fe8f
--- /dev/null
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -0,0 +1,2100 @@
+/*
+ *  comedi/drivers/adl_pci9118.c
+ *
+ *  hardware driver for ADLink cards:
+ *   card:   PCI-9118DG, PCI-9118HG, PCI-9118HR
+ *   driver: pci9118dg,  pci9118hg,  pci9118hr
+ *
+ * Author: Michal Dobes <dobes@tesnet.cz>
+ *
+*/
+/*
+Driver: adl_pci9118
+Description: Adlink PCI-9118DG, PCI-9118HG, PCI-9118HR
+Author: Michal Dobes <dobes@tesnet.cz>
+Devices: [ADLink] PCI-9118DG (pci9118dg), PCI-9118HG (pci9118hg),
+  PCI-9118HR (pci9118hr)
+Status: works
+
+This driver supports AI, AO, DI and DO subdevices.
+AI subdevice supports cmd and insn interface,
+other subdevices support only insn interface.
+For AI:
+- If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
+- If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
+- If cmd->start_src/stop_src=TRIG_EXT then trigger input is TGIN (pin 46).
+- It is not neccessary to have cmd.scan_end_arg=cmd.chanlist_len but
+  cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
+- If return value of cmdtest is 5 then you've bad channel list
+  (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
+  ranges).
+
+There are some hardware limitations:
+a) You cann't use mixture of unipolar/bipoar ranges or differencial/single
+   ended inputs.
+b) DMA transfers must have the length aligned to two samples (32 bit),
+   so there is some problems if cmd->chanlist_len is odd. This driver tries
+   bypass this with adding one sample to the end of the every scan and discard
+   it on output but this cann't be used if cmd->scan_begin_src=TRIG_FOLLOW
+   and is used flag TRIG_WAKE_EOS, then driver switch to interrupt driven mode
+   with interrupt after every sample.
+c) If isn't used DMA then you can use only mode where
+   cmd->scan_begin_src=TRIG_FOLLOW.
+
+Configuration options:
+  [0] - PCI bus of device (optional)
+  [1] - PCI slot of device (optional)
+          If bus/slot is not specified, then first available PCI
+          card will be used.
+  [2] - 0= standard 8 DIFF/16 SE channels configuration
+        n= external multiplexer connected, 1<=n<=256
+  [3] - 0=autoselect DMA or EOC interrupts operation
+        1=disable DMA mode
+        3=disable DMA and INT, only insn interface will work
+  [4] - sample&hold signal - card can generate signal for external S&H board
+        0=use SSHO (pin 45) signal is generated in onboard hardware S&H logic
+        0!=use ADCHN7 (pin 23) signal is generated from driver, number
+           say how long delay is requested in ns and sign polarity of the hold
+           (in this case external multiplexor can serve only 128 channels)
+  [5] - 0=stop measure on all hardware errors
+        2|=ignore ADOR - A/D Overrun status
+	8|=ignore Bover - A/D Burst Mode Overrun status
+	256|=ignore nFull - A/D FIFO Full status
+
+*/
+#include "../comedidev.h"
+#include "../pci_ids.h"
+
+#include <linux/delay.h>
+
+#include "amcc_s5933.h"
+#include "8253.h"
+#include "comedi_pci.h"
+#include "comedi_fc.h"
+
+/* paranoid checks are broken */
+#undef PCI9118_PARANOIDCHECK	/* if defined, then is used code which control correct channel number on every 12 bit sample */
+
+#undef PCI9118_EXTDEBUG		/* if defined then driver prints a lot of messages */
+
+#undef DPRINTK
+#ifdef PCI9118_EXTDEBUG
+#define DPRINTK(fmt, args...) rt_printk(fmt, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#define IORANGE_9118 	64	/* I hope */
+#define PCI9118_CHANLEN	255	/* len of chanlist, some source say 256, but reality looks like 255 :-( */
+
+#define PCI9118_CNT0	0x00	/* R/W: 8254 couter 0 */
+#define PCI9118_CNT1	0x04	/* R/W: 8254 couter 0 */
+#define PCI9118_CNT2	0x08	/* R/W: 8254 couter 0 */
+#define PCI9118_CNTCTRL	0x0c	/* W:   8254 counter control */
+#define PCI9118_AD_DATA	0x10	/* R:   A/D data */
+#define PCI9118_DA1	0x10	/* W:   D/A registers */
+#define PCI9118_DA2	0x14
+#define PCI9118_ADSTAT	0x18	/* R:   A/D status register */
+#define PCI9118_ADCNTRL	0x18	/* W:   A/D control register */
+#define PCI9118_DI	0x1c	/* R:   digi input register */
+#define PCI9118_DO	0x1c	/* W:   digi output register */
+#define PCI9118_SOFTTRG	0x20	/* W:   soft trigger for A/D */
+#define PCI9118_GAIN	0x24	/* W:   A/D gain/channel register */
+#define PCI9118_BURST	0x28	/* W:   A/D burst number register */
+#define PCI9118_SCANMOD	0x2c	/* W:   A/D auto scan mode */
+#define PCI9118_ADFUNC	0x30	/* W:   A/D function register */
+#define PCI9118_DELFIFO	0x34	/* W:   A/D data FIFO reset */
+#define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
+#define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
+
+// bits from A/D control register (PCI9118_ADCNTRL)
+#define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
+#define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
+#define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
+#define	AdControl_ExtG	0x10	/* 1=8254 countrol controlled by TGIN(pin 46), 0=controled by SoftG */
+#define AdControl_ExtM	0x08	/* 1=external hardware trigger (pin 44), 0=internal trigger */
+#define AdControl_TmrTr	0x04	/* 1=8254 is iternal trigger source, 0=software trigger is source (register PCI9118_SOFTTRG) */
+#define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
+#define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
+
+// bits from A/D function register (PCI9118_ADFUNC)
+#define AdFunction_PDTrg	0x80	/* 1=positive, 0=negative digital trigger (only positive is correct) */
+#define AdFunction_PETrg	0x40	/* 1=positive, 0=negative external trigger (only positive is correct) */
+#define AdFunction_BSSH		0x20	/* 1=with sample&hold, 0=without */
+#define AdFunction_BM		0x10	/* 1=burst mode, 0=normal mode */
+#define AdFunction_BS		0x08	/* 1=burst mode start, 0=burst mode stop */
+#define AdFunction_PM		0x04	/* 1=post trigger mode, 0=not post trigger */
+#define AdFunction_AM		0x02	/* 1=about trigger mode, 0=not about trigger */
+#define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
+
+// bits from A/D status register (PCI9118_ADSTAT)
+#define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
+#define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
+#define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
+#define AdStatus_Acmp	0x020	/*  */
+#define AdStatus_DTH	0x010	/* 1=external digital trigger */
+#define AdStatus_Bover	0x008	/* 1=burst mode overrun (fatal) */
+#define AdStatus_ADOS	0x004	/* 1=A/D over speed (warning) */
+#define AdStatus_ADOR	0x002	/* 1=A/D overrun (fatal) */
+#define AdStatus_ADrdy	0x001	/* 1=A/D already ready, 0=not ready */
+
+// bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL)
+// 1=interrupt occur, enable source,  0=interrupt not occur, disable source
+#define Int_Timer	0x08	/* timer interrupt */
+#define Int_About	0x04	/* about trigger complete */
+#define Int_Hfull	0x02	/* A/D FIFO hlaf full */
+#define Int_DTrg	0x01	/* external digital trigger */
+
+#define START_AI_EXT	0x01	/* start measure on external trigger */
+#define STOP_AI_EXT	0x02	/* stop measure on external trigger */
+#define START_AI_INT	0x04	/* start measure on internal trigger */
+#define STOP_AI_INT	0x08	/* stop measure on internal trigger */
+
+#define EXTTRG_AI	0	/* ext trg is used by AI */
+
+static const comedi_lrange range_pci9118dg_hr = { 8, {
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			BIP_RANGE(0.625),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25)
+	}
+};
+
+static const comedi_lrange range_pci9118hg = { 8, {
+			BIP_RANGE(5),
+			BIP_RANGE(0.5),
+			BIP_RANGE(0.05),
+			BIP_RANGE(0.005),
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01)
+	}
+};
+
+#define PCI9118_BIPOLAR_RANGES	4	/* used for test on mixture of BIP/UNI ranges */
+
+static int pci9118_attach(comedi_device * dev, comedi_devconfig * it);
+static int pci9118_detach(comedi_device * dev);
+
+typedef struct {
+	const char *name;	// board name
+	int vendor_id;		// PCI vendor a device ID of card
+	int device_id;
+	int iorange_amcc;	// iorange for own S5933 region
+	int iorange_9118;	// pass thru card region size
+	int n_aichan;		// num of A/D chans
+	int n_aichand;		// num of A/D chans in diff mode
+	int mux_aichan;		// num of A/D chans with external multiplexor
+	int n_aichanlist;	// len of chanlist
+	int n_aochan;		// num of D/A chans
+	int ai_maxdata;		// resolution of A/D
+	int ao_maxdata;		// resolution of D/A
+	const comedi_lrange *rangelist_ai;	// rangelist for A/D
+	const comedi_lrange *rangelist_ao;	// rangelist for D/A
+	unsigned int ai_ns_min;	// max sample speed of card v ns
+	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
+	int half_fifo_size;	// size of FIFO/2
+
+} boardtype;
+
+static DEFINE_PCI_DEVICE_TABLE(pci9118_pci_table) = {
+	{PCI_VENDOR_ID_AMCC, 0x80d9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, pci9118_pci_table);
+
+static const boardtype boardtypes[] = {
+	{"pci9118dg", PCI_VENDOR_ID_AMCC, 0x80d9,
+			AMCC_OP_REG_SIZE, IORANGE_9118,
+			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+			&range_pci9118dg_hr, &range_bipolar10,
+		3000, 12, 512},
+	{"pci9118hg", PCI_VENDOR_ID_AMCC, 0x80d9,
+			AMCC_OP_REG_SIZE, IORANGE_9118,
+			16, 8, 256, PCI9118_CHANLEN, 2, 0x0fff, 0x0fff,
+			&range_pci9118hg, &range_bipolar10,
+		3000, 12, 512},
+	{"pci9118hr", PCI_VENDOR_ID_AMCC, 0x80d9,
+			AMCC_OP_REG_SIZE, IORANGE_9118,
+			16, 8, 256, PCI9118_CHANLEN, 2, 0xffff, 0x0fff,
+			&range_pci9118dg_hr, &range_bipolar10,
+		10000, 40, 512},
+};
+
+#define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
+
+static comedi_driver driver_pci9118 = {
+      driver_name:"adl_pci9118",
+      module:THIS_MODULE,
+      attach:pci9118_attach,
+      detach:pci9118_detach,
+      num_names:n_boardtypes,
+      board_name:&boardtypes[0].name,
+      offset:sizeof(boardtype),
+};
+
+COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
+
+typedef struct {
+	unsigned long iobase_a;	// base+size for AMCC chip
+	unsigned int master;	// master capable
+	struct pci_dev *pcidev;	// ptr to actual pcidev
+	unsigned int usemux;	// we want to use external multiplexor!
+#ifdef PCI9118_PARANOIDCHECK
+	unsigned short chanlist[PCI9118_CHANLEN + 1];	// list of scaned channel
+	unsigned char chanlistlen;	// number of scanlist
+#endif
+	unsigned char AdControlReg;	// A/D control register
+	unsigned char IntControlReg;	// Interrupt control register
+	unsigned char AdFunctionReg;	// A/D function register
+	char valid;		// driver is ok
+	char ai_neverending;	// we do unlimited AI
+	unsigned int i8254_osc_base;	// frequence of onboard oscilator
+	unsigned int ai_do;	// what do AI? 0=nothing, 1 to 4 mode
+	unsigned int ai_act_scan;	// how many scans we finished
+	unsigned int ai_buf_ptr;	// data buffer ptr in samples
+	unsigned int ai_n_chan;	// how many channels is measured
+	unsigned int ai_n_scanlen;	// len of actual scanlist
+	unsigned int ai_n_realscanlen;	// what we must transfer for one outgoing scan include front/back adds
+	unsigned int ai_act_dmapos;	// position in actual real stream
+	unsigned int ai_add_front;	// how many channels we must add before scan to satisfy S&H?
+	unsigned int ai_add_back;	// how many channels we must add before scan to satisfy DMA?
+	unsigned int *ai_chanlist;	// actaul chanlist
+	unsigned int ai_timer1;
+	unsigned int ai_timer2;
+	unsigned int ai_flags;
+	char ai12_startstop;	// measure can start/stop on external trigger
+	unsigned int ai_divisor1, ai_divisor2;	// divisors for start of measure on external start
+	unsigned int ai_data_len;
+	sampl_t *ai_data;
+	sampl_t ao_data[2];	// data output buffer
+	unsigned int ai_scans;	// number of scans to do
+	char dma_doublebuf;	// we can use double buffring
+	unsigned int dma_actbuf;	// which buffer is used now
+	sampl_t *dmabuf_virt[2];	// pointers to begin of DMA buffer
+	unsigned long dmabuf_hw[2];	// hw address of DMA buff
+	unsigned int dmabuf_size[2];	// size of dma buffer in bytes
+	unsigned int dmabuf_use_size[2];	// which size we may now used for transfer
+	unsigned int dmabuf_used_size[2];	// which size was trully used
+	unsigned int dmabuf_panic_size[2];
+	unsigned int dmabuf_samples[2];	// size in samples
+	int dmabuf_pages[2];	// number of pages in buffer
+	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
+	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
+	unsigned int cnt0_divisor;	// actual CNT0 divisor
+	void (*int_ai_func) (comedi_device *, comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
+	unsigned char ai16bits;	// =1 16 bit card
+	unsigned char usedma;	// =1 use DMA transfer and not INT
+	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
+	unsigned char usessh;	// =1 turn on S&H support
+	int softsshdelay;	// >0 use software S&H, numer is requested delay in ns
+	unsigned char softsshsample;	// polarity of S&H signal in sample state
+	unsigned char softsshhold;	// polarity of S&H signal in hold state
+	unsigned int ai_maskerr;	// which warning was printed
+	unsigned int ai_maskharderr;	// on which error bits stops
+	unsigned int ai_inttrig_start;	// TRIG_INT for start
+} pci9118_private;
+
+#define devpriv ((pci9118_private *)dev->private)
+#define this_board ((boardtype *)dev->board_ptr)
+
+/*
+==============================================================================
+*/
+
+static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+	int n_chan, unsigned int *chanlist, int frontadd, int backadd);
+static int setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
+	int usedma, char eoshandle);
+static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2);
+static int pci9118_reset(comedi_device * dev);
+static int pci9118_exttrg_add(comedi_device * dev, unsigned char source);
+static int pci9118_exttrg_del(comedi_device * dev, unsigned char source);
+static int pci9118_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static void pci9118_calc_divisors(char mode, comedi_device * dev,
+	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
+	char usessh, unsigned int chnsshfront);
+
+/*
+==============================================================================
+*/
+static int pci9118_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	int n, timeout;
+
+	devpriv->AdControlReg = AdControl_Int & 0xff;
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+
+	if (!setup_channel_list(dev, s, 1, &insn->chanspec, 0, 0, 0, 0, 0))
+		return -EINVAL;
+
+	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+
+	for (n = 0; n < insn->n; n++) {
+		outw(0, dev->iobase + PCI9118_SOFTTRG);	/* start conversion */
+		comedi_udelay(2);
+		timeout = 100;
+		while (timeout--) {
+			if (inl(dev->iobase + PCI9118_ADSTAT) & AdStatus_ADrdy)
+				goto conv_finish;
+			comedi_udelay(1);
+		}
+
+		comedi_error(dev, "A/D insn timeout");
+		data[n] = 0;
+		outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+		return -ETIME;
+
+	      conv_finish:
+		if (devpriv->ai16bits) {
+			data[n] =
+				(inl(dev->iobase +
+					PCI9118_AD_DATA) & 0xffff) ^ 0x8000;
+		} else {
+			data[n] =
+				(inw(dev->iobase +
+					PCI9118_AD_DATA) >> 4) & 0xfff;
+		}
+	}
+
+	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	return n;
+
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, chanreg, ch;
+
+	ch = CR_CHAN(insn->chanspec);
+	if (ch) {
+		chanreg = PCI9118_DA2;
+	} else {
+		chanreg = PCI9118_DA1;
+	}
+
+	for (n = 0; n < insn->n; n++) {
+		outl(data[n], dev->iobase + chanreg);
+		devpriv->ao_data[ch] = data[n];
+	}
+
+	return n;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, chan;
+
+	chan = CR_CHAN(insn->chanspec);
+	for (n = 0; n < insn->n; n++)
+		data[n] = devpriv->ao_data[chan];
+
+	return n;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[1] = inl(dev->iobase + PCI9118_DI) & 0xf;
+
+	return 2;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		outl(s->state & 0x0f, dev->iobase + PCI9118_DO);
+	}
+	data[1] = s->state;
+
+	return 2;
+}
+
+/*
+==============================================================================
+*/
+static void interrupt_pci9118_ai_mode4_switch(comedi_device * dev)
+{
+	devpriv->AdFunctionReg =
+		AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 1) & 0xff,
+		dev->iobase + PCI9118_CNT0);
+	outl((devpriv->dmabuf_hw[1 - devpriv->dma_actbuf] >> 9) & 0xff,
+		dev->iobase + PCI9118_CNT0);
+	devpriv->AdFunctionReg |= AdFunction_Start;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+}
+
+static unsigned int defragment_dma_buffer(comedi_device * dev,
+	comedi_subdevice * s, sampl_t * dma_buffer, unsigned int num_samples)
+{
+	unsigned int i = 0, j = 0;
+	unsigned int start_pos = devpriv->ai_add_front,
+		stop_pos = devpriv->ai_add_front + devpriv->ai_n_chan;
+	unsigned int raw_scanlen = devpriv->ai_add_front + devpriv->ai_n_chan +
+		devpriv->ai_add_back;
+
+	for (i = 0; i < num_samples; i++) {
+		if (devpriv->ai_act_dmapos >= start_pos &&
+			devpriv->ai_act_dmapos < stop_pos) {
+			dma_buffer[j++] = dma_buffer[i];
+		}
+		devpriv->ai_act_dmapos++;
+		devpriv->ai_act_dmapos %= raw_scanlen;
+	}
+
+	return j;
+}
+
+/*
+==============================================================================
+*/
+static unsigned int move_block_from_dma(comedi_device * dev,
+	comedi_subdevice * s, sampl_t * dma_buffer, unsigned int num_samples)
+{
+	unsigned int num_bytes;
+
+	num_samples = defragment_dma_buffer(dev, s, dma_buffer, num_samples);
+	devpriv->ai_act_scan +=
+		(s->async->cur_chan + num_samples) / devpriv->ai_n_scanlen;
+	s->async->cur_chan += num_samples;
+	s->async->cur_chan %= devpriv->ai_n_scanlen;
+	num_bytes =
+		cfc_write_array_to_buffer(s, dma_buffer,
+		num_samples * sizeof(sampl_t));
+	if (num_bytes < num_samples * sizeof(sampl_t))
+		return -1;
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static char pci9118_decode_error_status(comedi_device * dev,
+	comedi_subdevice * s, unsigned char m)
+{
+	if (m & 0x100) {
+		comedi_error(dev, "A/D FIFO Full status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x100L;
+	}
+	if (m & 0x008) {
+		comedi_error(dev,
+			"A/D Burst Mode Overrun Status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x008L;
+	}
+	if (m & 0x004) {
+		comedi_error(dev, "A/D Over Speed Status (Warning!)");
+		devpriv->ai_maskerr &= ~0x004L;
+	}
+	if (m & 0x002) {
+		comedi_error(dev, "A/D Overrun Status (Fatal Error!)");
+		devpriv->ai_maskerr &= ~0x002L;
+	}
+	if (m & devpriv->ai_maskharderr) {
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		pci9118_ai_cancel(dev, s);
+		comedi_event(dev, s);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void pci9118_ai_munge(comedi_device * dev, comedi_subdevice * s,
+	void *data, unsigned int num_bytes, unsigned int start_chan_index)
+{
+	unsigned int i, num_samples = num_bytes / sizeof(sampl_t);
+	sampl_t *array = data;
+
+	for (i = 0; i < num_samples; i++) {
+		if (devpriv->usedma)
+			array[i] = be16_to_cpu(array[i]);
+		if (devpriv->ai16bits) {
+			array[i] ^= 0x8000;
+		} else {
+			array[i] = (array[i] >> 4) & 0x0fff;
+		}
+	}
+}
+
+/*
+==============================================================================
+*/
+static void interrupt_pci9118_ai_onesample(comedi_device * dev,
+	comedi_subdevice * s, unsigned short int_adstat, unsigned int int_amcc,
+	unsigned short int_daq)
+{
+	register sampl_t sampl;
+
+	s->async->events = 0;
+
+	if (int_adstat & devpriv->ai_maskerr)
+		if (pci9118_decode_error_status(dev, s, int_adstat))
+			return;
+
+	sampl = inw(dev->iobase + PCI9118_AD_DATA);
+
+#ifdef PCI9118_PARANOIDCHECK
+	if (devpriv->ai16bits == 0) {
+		if ((sampl & 0x000f) != devpriv->chanlist[s->async->cur_chan]) {	// data dropout!
+			rt_printk
+				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
+				sampl & 0x000f,
+				devpriv->chanlist[s->async->cur_chan]);
+			s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+			pci9118_ai_cancel(dev, s);
+			comedi_event(dev, s);
+			return;
+		}
+	}
+#endif
+	cfc_write_to_buffer(s, sampl);
+	s->async->cur_chan++;
+	if (s->async->cur_chan >= devpriv->ai_n_scanlen) {	/* one scan done */
+		s->async->cur_chan %= devpriv->ai_n_scanlen;
+		devpriv->ai_act_scan++;
+		if (!(devpriv->ai_neverending))
+			if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+				pci9118_ai_cancel(dev, s);
+				s->async->events |= COMEDI_CB_EOA;
+			}
+	}
+
+	if (s->async->events)
+		comedi_event(dev, s);
+}
+
+/*
+==============================================================================
+*/
+static void interrupt_pci9118_ai_dma(comedi_device * dev, comedi_subdevice * s,
+	unsigned short int_adstat, unsigned int int_amcc,
+	unsigned short int_daq)
+{
+	unsigned int next_dma_buf, samplesinbuf, sampls, m;
+
+	if (int_amcc & MASTER_ABORT_INT) {
+		comedi_error(dev, "AMCC IRQ - MASTER DMA ABORT!");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		pci9118_ai_cancel(dev, s);
+		comedi_event(dev, s);
+		return;
+	}
+
+	if (int_amcc & TARGET_ABORT_INT) {
+		comedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		pci9118_ai_cancel(dev, s);
+		comedi_event(dev, s);
+		return;
+	}
+
+	if (int_adstat & devpriv->ai_maskerr)
+//      if (int_adstat & 0x106)
+		if (pci9118_decode_error_status(dev, s, int_adstat))
+			return;
+
+	samplesinbuf = devpriv->dmabuf_use_size[devpriv->dma_actbuf] >> 1;	// number of received real samples
+//      DPRINTK("dma_actbuf=%d\n",devpriv->dma_actbuf);
+
+	if (devpriv->dma_doublebuf) {	// switch DMA buffers if is used double buffering
+		next_dma_buf = 1 - devpriv->dma_actbuf;
+		outl(devpriv->dmabuf_hw[next_dma_buf],
+			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		outl(devpriv->dmabuf_use_size[next_dma_buf],
+			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		devpriv->dmabuf_used_size[next_dma_buf] =
+			devpriv->dmabuf_use_size[next_dma_buf];
+		if (devpriv->ai_do == 4)
+			interrupt_pci9118_ai_mode4_switch(dev);
+	}
+
+	if (samplesinbuf) {
+		m = devpriv->ai_data_len >> 1;	// how many samples is to end of buffer
+//              DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s->async->buf_int_count,s->async->buf_int_ptr);
+		sampls = m;
+		move_block_from_dma(dev, s,
+			devpriv->dmabuf_virt[devpriv->dma_actbuf],
+			samplesinbuf);
+		m = m - sampls;	// m= how many samples was transfered
+	}
+//      DPRINTK("YYY\n");
+
+	if (!devpriv->ai_neverending)
+		if (devpriv->ai_act_scan >= devpriv->ai_scans) {	/* all data sampled */
+			pci9118_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_EOA;
+		}
+
+	if (devpriv->dma_doublebuf) {	// switch dma buffers
+		devpriv->dma_actbuf = 1 - devpriv->dma_actbuf;
+	} else {		// restart DMA if is not used double buffering
+		outl(devpriv->dmabuf_hw[0],
+			devpriv->iobase_a + AMCC_OP_REG_MWAR);
+		outl(devpriv->dmabuf_use_size[0],
+			devpriv->iobase_a + AMCC_OP_REG_MWTC);
+		if (devpriv->ai_do == 4)
+			interrupt_pci9118_ai_mode4_switch(dev);
+	}
+
+	comedi_event(dev, s);
+}
+
+/*
+==============================================================================
+*/
+static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	unsigned int int_daq = 0, int_amcc, int_adstat;
+
+	if (!dev->attached)
+		return IRQ_NONE;	// not fully initialized
+
+	int_daq = inl(dev->iobase + PCI9118_INTSRC) & 0xf;	// get IRQ reasons from card
+	int_amcc = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// get INT register from AMCC chip
+
+//      DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv->iobase_a+AMCC_OP_REG_MWAR), inl(devpriv->iobase_a+AMCC_OP_REG_MWTC), inw(dev->iobase+PCI9118_ADSTAT)&0x1ff,devpriv->ai_do);
+
+	if ((!int_daq) && (!(int_amcc & ANY_S593X_INT)))
+		return IRQ_NONE;	// interrupt from other source
+
+	outl(int_amcc | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// shutdown IRQ reasons in AMCC
+
+	int_adstat = inw(dev->iobase + PCI9118_ADSTAT) & 0x1ff;	// get STATUS register
+
+	if (devpriv->ai_do) {
+		if (devpriv->ai12_startstop)
+			if ((int_adstat & AdStatus_DTH) && (int_daq & Int_DTrg)) {	// start stop of measure
+				if (devpriv->ai12_startstop & START_AI_EXT) {
+					devpriv->ai12_startstop &=
+						~START_AI_EXT;
+					if (!(devpriv->ai12_startstop &
+							STOP_AI_EXT))
+						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
+					start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1, devpriv->ai_divisor2);	// start pacer
+					outl(devpriv->AdControlReg,
+						dev->iobase + PCI9118_ADCNTRL);
+				} else {
+					if (devpriv->
+						ai12_startstop & STOP_AI_EXT) {
+						devpriv->ai12_startstop &=
+							~STOP_AI_EXT;
+						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
+						devpriv->ai_neverending = 0;	//well, on next interrupt from DMA/EOC measure will stop
+					}
+				}
+			}
+
+		(devpriv->int_ai_func) (dev, dev->subdevices + 0, int_adstat,
+			int_amcc, int_daq);
+
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	if (trignum != devpriv->ai_inttrig_start)
+		return -EINVAL;
+
+	devpriv->ai12_startstop &= ~START_AI_INT;
+	s->async->inttrig = NULL;
+
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	if (devpriv->ai_do != 3) {
+		start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
+			devpriv->ai_divisor2);
+		devpriv->AdControlReg |= AdControl_SoftG;
+	}
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+
+	return 1;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp, divisor1, divisor2;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	if (devpriv->master) {
+		cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;
+	} else {
+		cmd->scan_begin_src &= TRIG_FOLLOW;
+	}
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	if (devpriv->master) {
+		cmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;
+	} else {
+		cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	}
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE | TRIG_EXT;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW &&
+		cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT) {
+		cmd->start_src = TRIG_NOW;
+		err++;
+	}
+
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_INT &&
+		cmd->scan_begin_src != TRIG_FOLLOW) {
+		cmd->scan_begin_src = TRIG_FOLLOW;
+		err++;
+	}
+
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW) {
+		cmd->convert_src = TRIG_TIMER;
+		err++;
+	}
+
+	if (cmd->scan_end_src != TRIG_COUNT) {
+		cmd->scan_end_src = TRIG_COUNT;
+		err++;
+	}
+
+	if (cmd->stop_src != TRIG_NONE &&
+		cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_INT && cmd->stop_src != TRIG_EXT) {
+		cmd->stop_src = TRIG_COUNT;
+		err++;
+	}
+
+	if (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {
+		cmd->start_src = TRIG_NOW;
+		err++;
+	}
+
+	if (cmd->start_src == TRIG_INT && cmd->scan_begin_src == TRIG_INT) {
+		cmd->start_src = TRIG_NOW;
+		err++;
+	}
+
+	if ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&
+		(!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW)))) {
+		cmd->convert_src = TRIG_TIMER;
+		err++;
+	}
+
+	if ((cmd->scan_begin_src == TRIG_FOLLOW) &&
+		(!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT)))) {
+		cmd->convert_src = TRIG_TIMER;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT) {
+		cmd->stop_src = TRIG_COUNT;
+		err++;
+	}
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_src & (TRIG_NOW | TRIG_EXT))
+		if (cmd->start_arg != 0) {
+			cmd->start_arg = 0;
+			err++;
+		}
+
+	if (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+
+	if ((cmd->scan_begin_src == TRIG_TIMER) &&
+		(cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {
+		cmd->scan_begin_src = TRIG_FOLLOW;
+		cmd->convert_arg = cmd->scan_begin_arg;
+		cmd->scan_begin_arg = 0;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		if (cmd->scan_begin_arg < this_board->ai_ns_min) {
+			cmd->scan_begin_arg = this_board->ai_ns_min;
+			err++;
+		}
+
+	if (cmd->scan_begin_src == TRIG_EXT)
+		if (cmd->scan_begin_arg) {
+			cmd->scan_begin_arg = 0;
+			err++;
+			if (cmd->scan_end_arg > 65535) {
+				cmd->scan_end_arg = 65535;
+				err++;
+			}
+		}
+
+	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW))
+		if (cmd->convert_arg < this_board->ai_ns_min) {
+			cmd->convert_arg = this_board->ai_ns_min;
+			err++;
+		}
+
+	if (cmd->convert_src == TRIG_EXT)
+		if (cmd->convert_arg) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+	} else {		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+
+	if (cmd->chanlist_len > this_board->n_aichanlist) {
+		cmd->chanlist_len = this_board->n_aichanlist;
+		err++;
+	}
+
+	if (cmd->scan_end_arg < cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if ((cmd->scan_end_arg % cmd->chanlist_len)) {
+		cmd->scan_end_arg =
+			cmd->chanlist_len * (cmd->scan_end_arg /
+			cmd->chanlist_len);
+		err++;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+//              rt_printk("S1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
+			&divisor2, &cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+//              rt_printk("S2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+		if (cmd->scan_begin_arg < this_board->ai_ns_min)
+			cmd->scan_begin_arg = this_board->ai_ns_min;
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {
+		tmp = cmd->convert_arg;
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,
+			&divisor2, &cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+//              rt_printk("s1 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+		if (cmd->convert_arg < this_board->ai_ns_min)
+			cmd->convert_arg = this_board->ai_ns_min;
+		if (tmp != cmd->convert_arg)
+			err++;
+		if (cmd->scan_begin_src == TRIG_TIMER
+			&& cmd->convert_src == TRIG_NOW) {
+			if (cmd->convert_arg == 0) {
+				if (cmd->scan_begin_arg <
+					this_board->ai_ns_min *
+					(cmd->scan_end_arg + 2)) {
+					cmd->scan_begin_arg =
+						this_board->ai_ns_min *
+						(cmd->scan_end_arg + 2);
+//              rt_printk("s2 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+					err++;
+				}
+			} else {
+				if (cmd->scan_begin_arg <
+					cmd->convert_arg * cmd->chanlist_len) {
+					cmd->scan_begin_arg =
+						cmd->convert_arg *
+						cmd->chanlist_len;
+//              rt_printk("s3 timer1=%u timer2=%u\n",cmd->scan_begin_arg,cmd->convert_arg);
+					err++;
+				}
+			}
+		}
+	}
+
+	if (err)
+		return 4;
+
+	if (cmd->chanlist)
+		if (!check_channel_list(dev, s, cmd->chanlist_len,
+				cmd->chanlist, 0, 0))
+			return 5;	// incorrect channels list
+
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int Compute_and_setup_dma(comedi_device * dev)
+{
+	unsigned int dmalen0, dmalen1, i;
+
+	DPRINTK("adl_pci9118 EDBG: BGN: Compute_and_setup_dma()\n");
+	dmalen0 = devpriv->dmabuf_size[0];
+	dmalen1 = devpriv->dmabuf_size[1];
+	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
+		devpriv->ai_data_len);
+	// isn't output buff smaller that our DMA buff?
+	if (dmalen0 > (devpriv->ai_data_len)) {
+		dmalen0 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+	}
+	if (dmalen1 > (devpriv->ai_data_len)) {
+		dmalen1 = devpriv->ai_data_len & ~3L;	// allign to 32bit down
+	}
+	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+
+	// we want wake up every scan?
+	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
+		if (dmalen0 < (devpriv->ai_n_realscanlen << 1)) {
+			// uff, too short DMA buffer, disable EOS support!
+			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
+			rt_printk
+				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+				dev->minor, dmalen0,
+				devpriv->ai_n_realscanlen << 1);
+		} else {
+			// short first DMA buffer to one scan
+			dmalen0 = devpriv->ai_n_realscanlen << 1;
+			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			if (devpriv->useeoshandle)
+				dmalen0 += 2;
+			if (dmalen0 < 4) {
+				rt_printk
+					("comedi%d: ERR: DMA0 buf len bug? (%d<4)\n",
+					dev->minor, dmalen0);
+				dmalen0 = 4;
+			}
+		}
+	}
+	if (devpriv->ai_flags & TRIG_WAKE_EOS) {
+		if (dmalen1 < (devpriv->ai_n_realscanlen << 1)) {
+			// uff, too short DMA buffer, disable EOS support!
+			devpriv->ai_flags &= (~TRIG_WAKE_EOS);
+			rt_printk
+				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d<%d)\n",
+				dev->minor, dmalen1,
+				devpriv->ai_n_realscanlen << 1);
+		} else {
+			// short second DMA buffer to one scan
+			dmalen1 = devpriv->ai_n_realscanlen << 1;
+			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv->ai_n_realscanlen, devpriv->useeoshandle);
+			if (devpriv->useeoshandle)
+				dmalen1 -= 2;
+			if (dmalen1 < 4) {
+				rt_printk
+					("comedi%d: ERR: DMA1 buf len bug? (%d<4)\n",
+					dev->minor, dmalen1);
+				dmalen1 = 4;
+			}
+		}
+	}
+
+	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+	// transfer without TRIG_WAKE_EOS
+	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
+		// if it's possible then allign DMA buffers to length of scan
+		i = dmalen0;
+		dmalen0 =
+			(dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
+			(devpriv->ai_n_realscanlen << 1);
+		dmalen0 &= ~3L;
+		if (!dmalen0)
+			dmalen0 = i;	// uff. very long scan?
+		i = dmalen1;
+		dmalen1 =
+			(dmalen1 / (devpriv->ai_n_realscanlen << 1)) *
+			(devpriv->ai_n_realscanlen << 1);
+		dmalen1 &= ~3L;
+		if (!dmalen1)
+			dmalen1 = i;	// uff. very long scan?
+		// if measure isn't neverending then test, if it whole fits into one or two DMA buffers
+		if (!devpriv->ai_neverending) {
+			// fits whole measure into one DMA buffer?
+			if (dmalen0 >
+				((devpriv->ai_n_realscanlen << 1) *
+					devpriv->ai_scans)) {
+				DPRINTK("3.0 ai_n_realscanlen=%d ai_scans=%d \n", devpriv->ai_n_realscanlen, devpriv->ai_scans);
+				dmalen0 =
+					(devpriv->ai_n_realscanlen << 1) *
+					devpriv->ai_scans;
+				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
+					dmalen1);
+				dmalen0 &= ~3L;
+			} else {	// fits whole measure into two DMA buffer?
+				if (dmalen1 >
+					((devpriv->ai_n_realscanlen << 1) *
+						devpriv->ai_scans - dmalen0))
+					dmalen1 =
+						(devpriv->
+						ai_n_realscanlen << 1) *
+						devpriv->ai_scans - dmalen0;
+				DPRINTK("3.2 dmalen0=%d dmalen1=%d \n", dmalen0,
+					dmalen1);
+				dmalen1 &= ~3L;
+			}
+		}
+	}
+
+	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+
+	// these DMA buffer size we'll be used
+	devpriv->dma_actbuf = 0;
+	devpriv->dmabuf_use_size[0] = dmalen0;
+	devpriv->dmabuf_use_size[1] = dmalen1;
+
+	DPRINTK("5 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
+#if 0
+	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
+		devpriv->dmabuf_panic_size[0] =
+			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
+			1) * devpriv->ai_n_scanlen * sizeof(sampl_t);
+		devpriv->dmabuf_panic_size[1] =
+			(this_board->half_fifo_size / devpriv->ai_n_scanlen +
+			1) * devpriv->ai_n_scanlen * sizeof(sampl_t);
+	} else {
+		devpriv->dmabuf_panic_size[0] =
+			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[0];
+		devpriv->dmabuf_panic_size[1] =
+			(devpriv->ai_n_scanlen << 1) % devpriv->dmabuf_size[1];
+	}
+#endif
+
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+	outl(devpriv->dmabuf_hw[0], devpriv->iobase_a + AMCC_OP_REG_MWAR);
+	outl(devpriv->dmabuf_use_size[0], devpriv->iobase_a + AMCC_OP_REG_MWTC);
+	// init DMA transfer
+	outl(0x00000000 | AINT_WRITE_COMPL,
+		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+//      outl(0x02000000|AINT_WRITE_COMPL, devpriv->iobase_a+AMCC_OP_REG_INTCSR);
+
+	outl(inl(devpriv->iobase_a +
+			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
+		EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_MCSR);
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow bus mastering
+
+	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_docmd_sampl(comedi_device * dev, comedi_subdevice * s)
+{
+	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_sampl(%d,) [%d]\n",
+		dev->minor, devpriv->ai_do);
+	switch (devpriv->ai_do) {
+	case 1:
+		devpriv->AdControlReg |= AdControl_TmrTr;
+		break;
+	case 2:
+		comedi_error(dev, "pci9118_ai_docmd_sampl() mode 2 bug!\n");
+		return -EIO;
+	case 3:
+		devpriv->AdControlReg |= AdControl_ExtM;
+		break;
+	case 4:
+		comedi_error(dev, "pci9118_ai_docmd_sampl() mode 4 bug!\n");
+		return -EIO;
+	default:
+		comedi_error(dev,
+			"pci9118_ai_docmd_sampl() mode number bug!\n");
+		return -EIO;
+	};
+
+	devpriv->int_ai_func = interrupt_pci9118_ai_onesample;	//transfer function
+
+	if (devpriv->ai12_startstop)
+		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+
+	if ((devpriv->ai_do == 1) || (devpriv->ai_do == 2))
+		devpriv->IntControlReg |= Int_Timer;
+
+	devpriv->AdControlReg |= AdControl_Int;
+
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+
+	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
+		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		if (devpriv->ai_do != 3) {
+			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
+				devpriv->ai_divisor2);
+			devpriv->AdControlReg |= AdControl_SoftG;
+		}
+		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	}
+
+	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_docmd_sampl()\n");
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_docmd_dma(comedi_device * dev, comedi_subdevice * s)
+{
+	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma(%d,) [%d,%d]\n",
+		dev->minor, devpriv->ai_do, devpriv->usedma);
+	Compute_and_setup_dma(dev);
+
+	switch (devpriv->ai_do) {
+	case 1:
+		devpriv->AdControlReg |=
+			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		break;
+	case 2:
+		devpriv->AdControlReg |=
+			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		devpriv->AdFunctionReg =
+			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_BM |
+			AdFunction_BS;
+		if (devpriv->usessh && (!devpriv->softsshdelay))
+			devpriv->AdFunctionReg |= AdFunction_BSSH;
+		outl(devpriv->ai_n_realscanlen, dev->iobase + PCI9118_BURST);
+		break;
+	case 3:
+		devpriv->AdControlReg |=
+			((AdControl_ExtM | AdControl_Dma) & 0xff);
+		devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+		break;
+	case 4:
+		devpriv->AdControlReg |=
+			((AdControl_TmrTr | AdControl_Dma) & 0xff);
+		devpriv->AdFunctionReg =
+			AdFunction_PDTrg | AdFunction_PETrg | AdFunction_AM;
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+		outl((devpriv->dmabuf_hw[0] >> 1) & 0xff,
+			dev->iobase + PCI9118_CNT0);
+		outl((devpriv->dmabuf_hw[0] >> 9) & 0xff,
+			dev->iobase + PCI9118_CNT0);
+		devpriv->AdFunctionReg |= AdFunction_Start;
+		break;
+	default:
+		comedi_error(dev, "pci9118_ai_docmd_dma() mode number bug!\n");
+		return -EIO;
+	};
+
+	if (devpriv->ai12_startstop) {
+		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+	}
+
+	devpriv->int_ai_func = interrupt_pci9118_ai_dma;	//transfer function
+
+	outl(0x02000000 | AINT_WRITE_COMPL,
+		devpriv->iobase_a + AMCC_OP_REG_INTCSR);
+
+	if (!(devpriv->ai12_startstop & (START_AI_EXT | START_AI_INT))) {
+		outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+		if (devpriv->ai_do != 3) {
+			start_pacer(dev, devpriv->ai_do, devpriv->ai_divisor1,
+				devpriv->ai_divisor2);
+			devpriv->AdControlReg |= AdControl_SoftG;
+		}
+		outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	}
+
+	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_docmd_dma()\n");
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned int addchans = 0;
+	int ret = 0;
+
+	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_ai_cmd(%d,)\n", dev->minor);
+	devpriv->ai12_startstop = 0;
+	devpriv->ai_flags = cmd->flags;
+	devpriv->ai_n_chan = cmd->chanlist_len;
+	devpriv->ai_n_scanlen = cmd->scan_end_arg;
+	devpriv->ai_chanlist = cmd->chanlist;
+	devpriv->ai_data = s->async->prealloc_buf;
+	devpriv->ai_data_len = s->async->prealloc_bufsz;
+	devpriv->ai_timer1 = 0;
+	devpriv->ai_timer2 = 0;
+	devpriv->ai_add_front = 0;
+	devpriv->ai_add_back = 0;
+	devpriv->ai_maskerr = 0x10e;
+
+	// prepare for start/stop conditions
+	if (cmd->start_src == TRIG_EXT)
+		devpriv->ai12_startstop |= START_AI_EXT;
+	if (cmd->stop_src == TRIG_EXT) {
+		devpriv->ai_neverending = 1;
+		devpriv->ai12_startstop |= STOP_AI_EXT;
+	}
+	if (cmd->start_src == TRIG_INT) {
+		devpriv->ai12_startstop |= START_AI_INT;
+		devpriv->ai_inttrig_start = cmd->start_arg;
+		s->async->inttrig = pci9118_ai_inttrig;
+	}
+#if 0
+	if (cmd->stop_src == TRIG_INT) {
+		devpriv->ai_neverending = 1;
+		devpriv->ai12_startstop |= STOP_AI_INT;
+	}
+#endif
+	if (cmd->stop_src == TRIG_NONE)
+		devpriv->ai_neverending = 1;
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ai_scans = cmd->stop_arg;
+		devpriv->ai_neverending = 0;
+	} else {
+		devpriv->ai_scans = 0;
+	}
+
+	// use sample&hold signal?
+	if (cmd->convert_src == TRIG_NOW) {
+		devpriv->usessh = 1;
+	}			// yes
+	else {
+		devpriv->usessh = 0;
+	}			// no
+
+	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
+		devpriv->ai_neverending, devpriv->ai_scans, devpriv->usessh,
+		devpriv->ai12_startstop);
+
+	// use additional sample at end of every scan to satisty DMA 32 bit transfer?
+	devpriv->ai_add_front = 0;
+	devpriv->ai_add_back = 0;
+	devpriv->useeoshandle = 0;
+	if (devpriv->master) {
+		devpriv->usedma = 1;
+		if ((cmd->flags & TRIG_WAKE_EOS) &&
+			(devpriv->ai_n_scanlen == 1)) {
+			if (cmd->convert_src == TRIG_NOW) {
+				devpriv->ai_add_back = 1;
+			}
+			if (cmd->convert_src == TRIG_TIMER) {
+				devpriv->usedma = 0;	// use INT transfer if scanlist have only one channel
+			}
+		}
+		if ((cmd->flags & TRIG_WAKE_EOS) &&
+			(devpriv->ai_n_scanlen & 1) &&
+			(devpriv->ai_n_scanlen > 1)) {
+			if (cmd->scan_begin_src == TRIG_FOLLOW) {
+				//vpriv->useeoshandle=1; // change DMA transfer block to fit EOS on every second call
+				devpriv->usedma = 0;	// XXX maybe can be corrected to use 16 bit DMA
+			} else {	// well, we must insert one sample to end of EOS to meet 32 bit transfer
+				devpriv->ai_add_back = 1;
+			}
+		}
+	} else {		// interrupt transfer don't need any correction
+		devpriv->usedma = 0;
+	}
+
+	// we need software S&H signal? It add  two samples before every scan as minimum
+	if (devpriv->usessh && devpriv->softsshdelay) {
+		devpriv->ai_add_front = 2;
+		if ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {	// move it to front
+			devpriv->ai_add_front++;
+			devpriv->ai_add_back = 0;
+		}
+		if (cmd->convert_arg < this_board->ai_ns_min)
+			cmd->convert_arg = this_board->ai_ns_min;
+		addchans = devpriv->softsshdelay / cmd->convert_arg;
+		if (devpriv->softsshdelay % cmd->convert_arg)
+			addchans++;
+		if (addchans > (devpriv->ai_add_front - 1)) {	// uff, still short :-(
+			devpriv->ai_add_front = addchans + 1;
+			if (devpriv->usedma == 1)
+				if ((devpriv->ai_add_front +
+						devpriv->ai_n_chan +
+						devpriv->ai_add_back) & 1)
+					devpriv->ai_add_front++;	// round up to 32 bit
+		}
+	}			// well, we now know what must be all added
+
+	devpriv->ai_n_realscanlen =	// what we must take from card in real to have ai_n_scanlen on output?
+		(devpriv->ai_add_front + devpriv->ai_n_chan +
+		devpriv->ai_add_back) * (devpriv->ai_n_scanlen /
+		devpriv->ai_n_chan);
+
+	DPRINTK("2 usedma=%d realscan=%d af=%u n_chan=%d ab=%d n_scanlen=%d\n",
+		devpriv->usedma,
+		devpriv->ai_n_realscanlen, devpriv->ai_add_front,
+		devpriv->ai_n_chan, devpriv->ai_add_back,
+		devpriv->ai_n_scanlen);
+
+	// check and setup channel list
+	if (!check_channel_list(dev, s, devpriv->ai_n_chan,
+			devpriv->ai_chanlist, devpriv->ai_add_front,
+			devpriv->ai_add_back))
+		return -EINVAL;
+	if (!setup_channel_list(dev, s, devpriv->ai_n_chan,
+			devpriv->ai_chanlist, 0, devpriv->ai_add_front,
+			devpriv->ai_add_back, devpriv->usedma,
+			devpriv->useeoshandle))
+		return -EINVAL;
+
+	// compute timers settings
+	// simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect
+	if (((cmd->scan_begin_src == TRIG_FOLLOW) || (cmd->scan_begin_src == TRIG_EXT) || (cmd->scan_begin_src == TRIG_INT)) && (cmd->convert_src == TRIG_TIMER)) {	// both timer is used for one time
+		if (cmd->scan_begin_src == TRIG_EXT) {
+			devpriv->ai_do = 4;
+		} else {
+			devpriv->ai_do = 1;
+		}
+		pci9118_calc_divisors(devpriv->ai_do, dev, s,
+			&cmd->scan_begin_arg, &cmd->convert_arg,
+			devpriv->ai_flags, devpriv->ai_n_realscanlen,
+			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
+			devpriv->usessh, devpriv->ai_add_front);
+		devpriv->ai_timer2 = cmd->convert_arg;
+	}
+
+	if ((cmd->scan_begin_src == TRIG_TIMER) && ((cmd->convert_src == TRIG_TIMER) || (cmd->convert_src == TRIG_NOW))) {	// double timed action
+		if (!devpriv->usedma) {
+			comedi_error(dev,
+				"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!");
+			return -EIO;
+		}
+
+		devpriv->ai_do = 2;
+		pci9118_calc_divisors(devpriv->ai_do, dev, s,
+			&cmd->scan_begin_arg, &cmd->convert_arg,
+			devpriv->ai_flags, devpriv->ai_n_realscanlen,
+			&devpriv->ai_divisor1, &devpriv->ai_divisor2,
+			devpriv->usessh, devpriv->ai_add_front);
+		devpriv->ai_timer1 = cmd->scan_begin_arg;
+		devpriv->ai_timer2 = cmd->convert_arg;
+	}
+
+	if ((cmd->scan_begin_src == TRIG_FOLLOW)
+		&& (cmd->convert_src == TRIG_EXT)) {
+		devpriv->ai_do = 3;
+	}
+
+	start_pacer(dev, -1, 0, 0);	// stop pacer
+
+	devpriv->AdControlReg = 0;	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);
+	comedi_udelay(1);
+	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D and INT status register
+	inl(dev->iobase + PCI9118_INTSRC);
+
+	devpriv->ai_act_scan = 0;
+	devpriv->ai_act_dmapos = 0;
+	s->async->cur_chan = 0;
+	devpriv->ai_buf_ptr = 0;
+
+	if (devpriv->usedma) {
+		ret = pci9118_ai_docmd_dma(dev, s);
+	} else {
+		ret = pci9118_ai_docmd_sampl(dev, s);
+	}
+
+	DPRINTK("adl_pci9118 EDBG: END: pci9118_ai_cmd()\n");
+	return ret;
+}
+
+/*
+==============================================================================
+*/
+static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+	int n_chan, unsigned int *chanlist, int frontadd, int backadd)
+{
+	unsigned int i, differencial = 0, bipolar = 0;
+
+	/* correct channel and range number check itself comedi/range.c */
+	if (n_chan < 1) {
+		comedi_error(dev, "range/channel list is empty!");
+		return 0;
+	}
+	if ((frontadd + n_chan + backadd) > s->len_chanlist) {
+		rt_printk
+			("comedi%d: range/channel list is too long for actual configuration (%d>%d)!",
+			dev->minor, n_chan,
+			s->len_chanlist - frontadd - backadd);
+		return 0;
+	}
+
+	if (CR_AREF(chanlist[0]) == AREF_DIFF)
+		differencial = 1;	// all input must be diff
+	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
+		bipolar = 1;	// all input must be bipolar
+	if (n_chan > 1)
+		for (i = 1; i < n_chan; i++) {	// check S.E/diff
+			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
+				(differencial)) {
+				comedi_error(dev,
+					"Differencial and single ended inputs cann't be mixtured!");
+				return 0;
+			}
+			if ((CR_RANGE(chanlist[i]) < PCI9118_BIPOLAR_RANGES) !=
+				(bipolar)) {
+				comedi_error(dev,
+					"Bipolar and unipolar ranges cann't be mixtured!");
+				return 0;
+			}
+			if ((!devpriv->usemux) & (differencial) &
+				(CR_CHAN(chanlist[i]) >=
+					this_board->n_aichand)) {
+				comedi_error(dev,
+					"If AREF_DIFF is used then is available only first 8 channels!");
+				return 0;
+			}
+		}
+
+	return 1;
+}
+
+/*
+==============================================================================
+*/
+static int setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+	int n_chan, unsigned int *chanlist, int rot, int frontadd, int backadd,
+	int usedma, char useeos)
+{
+	unsigned int i, differencial = 0, bipolar = 0;
+	unsigned int scanquad, gain, ssh = 0x00;
+
+	DPRINTK("adl_pci9118 EDBG: BGN: setup_channel_list(%d,.,%d,.,%d,%d,%d,%d)\n", dev->minor, n_chan, rot, frontadd, backadd, usedma);
+
+	if (usedma == 1) {
+		rot = 8;
+		usedma = 0;
+	}
+
+	if (CR_AREF(chanlist[0]) == AREF_DIFF)
+		differencial = 1;	// all input must be diff
+	if (CR_RANGE(chanlist[0]) < PCI9118_BIPOLAR_RANGES)
+		bipolar = 1;	// all input must be bipolar
+
+	// All is ok, so we can setup channel/range list
+
+	if (!bipolar) {
+		devpriv->AdControlReg |= AdControl_UniP;	// set unibipolar
+	} else {
+		devpriv->AdControlReg &= ((~AdControl_UniP) & 0xff);	// enable bipolar
+	}
+
+	if (differencial) {
+		devpriv->AdControlReg |= AdControl_Diff;	// enable diff inputs
+	} else {
+		devpriv->AdControlReg &= ((~AdControl_Diff) & 0xff);	// set single ended inputs
+	}
+
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// setup mode
+
+	outl(2, dev->iobase + PCI9118_SCANMOD);	// gods know why this sequence!
+	outl(0, dev->iobase + PCI9118_SCANMOD);
+	outl(1, dev->iobase + PCI9118_SCANMOD);
+
+#ifdef PCI9118_PARANOIDCHECK
+	devpriv->chanlistlen = n_chan;
+	for (i = 0; i < (PCI9118_CHANLEN + 1); i++)
+		devpriv->chanlist[i] = 0x55aa;
+#endif
+
+	if (frontadd) {		// insert channels for S&H
+		ssh = devpriv->softsshsample;
+		DPRINTK("FA: %04x: ", ssh);
+		for (i = 0; i < frontadd; i++) {	// store range list to card
+			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
+			gain = CR_RANGE(chanlist[0]);	// get gain number
+			scanquad |= ((gain & 0x03) << 8);
+			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+			DPRINTK("%02x ", scanquad | ssh);
+			ssh = devpriv->softsshhold;
+		}
+		DPRINTK("\n ");
+	}
+
+	DPRINTK("SL: ", ssh);
+	for (i = 0; i < n_chan; i++) {	// store range list to card
+		scanquad = CR_CHAN(chanlist[i]);	// get channel number;
+#ifdef PCI9118_PARANOIDCHECK
+		devpriv->chanlist[i ^ usedma] = (scanquad & 0xf) << rot;
+#endif
+		gain = CR_RANGE(chanlist[i]);	// get gain number
+		scanquad |= ((gain & 0x03) << 8);
+		outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+		DPRINTK("%02x ", scanquad | ssh);
+	}
+	DPRINTK("\n ");
+
+	if (backadd) {		// insert channels for fit onto 32bit DMA
+		DPRINTK("BA: %04x: ", ssh);
+		for (i = 0; i < backadd; i++) {	// store range list to card
+			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
+			gain = CR_RANGE(chanlist[0]);	// get gain number
+			scanquad |= ((gain & 0x03) << 8);
+			outl(scanquad | ssh, dev->iobase + PCI9118_GAIN);
+			DPRINTK("%02x ", scanquad | ssh);
+		}
+		DPRINTK("\n ");
+	}
+#ifdef PCI9118_PARANOIDCHECK
+	devpriv->chanlist[n_chan ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+	if (useeos) {
+		for (i = 1; i < n_chan; i++) {	// store range list to card
+			devpriv->chanlist[(n_chan + i) ^ usedma] =
+				(CR_CHAN(chanlist[i]) & 0xf) << rot;
+		}
+		devpriv->chanlist[(2 * n_chan) ^ usedma] = devpriv->chanlist[0 ^ usedma];	// for 32bit oerations
+		useeos = 2;
+	} else {
+		useeos = 1;
+	}
+#ifdef PCI9118_EXTDEBUG
+	DPRINTK("CHL: ");
+	for (i = 0; i <= (useeos * n_chan); i++) {
+		DPRINTK("%04x ", devpriv->chanlist[i]);
+	}
+	DPRINTK("\n ");
+#endif
+#endif
+	outl(0, dev->iobase + PCI9118_SCANMOD);	// close scan queue
+//      comedi_udelay(100);                             // important delay, or first sample will be cripled
+
+	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
+	return 1;		// we can serve this with scan logic
+}
+
+/*
+==============================================================================
+  calculate 8254 divisors if they are used for dual timing
+*/
+static void pci9118_calc_divisors(char mode, comedi_device * dev,
+	comedi_subdevice * s, unsigned int *tim1, unsigned int *tim2,
+	unsigned int flags, int chans, unsigned int *div1, unsigned int *div2,
+	char usessh, unsigned int chnsshfront)
+{
+	DPRINTK("adl_pci9118 EDBG: BGN: pci9118_calc_divisors(%d,%d,.,%u,%u,%u,%d,.,.,,%u,%u)\n", mode, dev->minor, *tim1, *tim2, flags, chans, usessh, chnsshfront);
+	switch (mode) {
+	case 1:
+	case 4:
+		if (*tim2 < this_board->ai_ns_min)
+			*tim2 = this_board->ai_ns_min;
+		i8253_cascade_ns_to_timer(devpriv->i8254_osc_base, div1, div2,
+			tim2, flags & TRIG_ROUND_NEAREST);
+		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u\n",
+			devpriv->i8254_osc_base, *div1, *div2, *tim1);
+		break;
+	case 2:
+		if (*tim2 < this_board->ai_ns_min)
+			*tim2 = this_board->ai_ns_min;
+		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		*div1 = *tim2 / devpriv->i8254_osc_base;	// convert timer (burst)
+		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		if (*div1 < this_board->ai_pacer_min)
+			*div1 = this_board->ai_pacer_min;
+		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		*div2 = *tim1 / devpriv->i8254_osc_base;	// scan timer
+		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		*div2 = *div2 / *div1;	// major timer is c1*c2
+		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		if (*div2 < chans)
+			*div2 = chans;
+		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+
+		*tim2 = *div1 * devpriv->i8254_osc_base;	// real convert timer
+
+		if (usessh & (chnsshfront == 0))	// use BSSH signal
+			if (*div2 < (chans + 2))
+				*div2 = chans + 2;
+
+		DPRINTK("7 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
+			*tim1, *tim2);
+		*tim1 = *div1 * *div2 * devpriv->i8254_osc_base;
+		DPRINTK("OSC base=%u div1=%u div2=%u timer1=%u timer2=%u\n",
+			devpriv->i8254_osc_base, *div1, *div2, *tim1, *tim2);
+		break;
+	}
+	DPRINTK("adl_pci9118 EDBG: END: pci9118_calc_divisors(%u,%u)\n",
+		*div1, *div2);
+}
+
+/*
+==============================================================================
+*/
+static void start_pacer(comedi_device * dev, int mode, unsigned int divisor1,
+	unsigned int divisor2)
+{
+	outl(0x74, dev->iobase + PCI9118_CNTCTRL);
+	outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
+//      outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+	comedi_udelay(1);
+
+	if ((mode == 1) || (mode == 2) || (mode == 4)) {
+		outl(divisor2 & 0xff, dev->iobase + PCI9118_CNT2);
+		outl((divisor2 >> 8) & 0xff, dev->iobase + PCI9118_CNT2);
+		outl(divisor1 & 0xff, dev->iobase + PCI9118_CNT1);
+		outl((divisor1 >> 8) & 0xff, dev->iobase + PCI9118_CNT1);
+	}
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_exttrg_add(comedi_device * dev, unsigned char source)
+{
+	if (source > 3)
+		return -1;	// incorrect source
+	devpriv->exttrg_users |= (1 << source);
+	devpriv->IntControlReg |= Int_DTrg;
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_exttrg_del(comedi_device * dev, unsigned char source)
+{
+	if (source > 3)
+		return -1;	// incorrect source
+	devpriv->exttrg_users &= ~(1 << source);
+	if (!devpriv->exttrg_users) {	// shutdown ext trg intterrupts
+		devpriv->IntControlReg &= ~Int_DTrg;
+		if (!devpriv->IntControlReg)	// all IRQ disabled
+			outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) & (~0x00001f00), devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// disable int in AMCC
+		outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);
+	}
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	if (devpriv->usedma)
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_MCSR) & (~EN_A2P_TRANSFERS), devpriv->iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+	pci9118_exttrg_del(dev, EXTTRG_AI);
+	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	devpriv->AdControlReg = 0x00;
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(0, dev->iobase + PCI9118_BURST);
+	outl(1, dev->iobase + PCI9118_SCANMOD);
+	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
+	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+
+	devpriv->ai_do = 0;
+	devpriv->usedma = 0;
+
+	devpriv->ai_act_scan = 0;
+	devpriv->ai_act_dmapos = 0;
+	s->async->cur_chan = 0;
+	s->async->inttrig = NULL;
+	devpriv->ai_buf_ptr = 0;
+	devpriv->ai_neverending = 0;
+	devpriv->dma_actbuf = 0;
+
+	if (!devpriv->IntControlReg)
+		outl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv->iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_reset(comedi_device * dev)
+{
+	devpriv->IntControlReg = 0;
+	devpriv->exttrg_users = 0;
+	inl(dev->iobase + PCI9118_INTCTRL);
+	outl(devpriv->IntControlReg, dev->iobase + PCI9118_INTCTRL);	// disable interrupts source
+	outl(0x30, dev->iobase + PCI9118_CNTCTRL);
+//        outl(0xb4, dev->iobase + PCI9118_CNTCTRL);
+	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+	devpriv->AdControlReg = 0;
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(0, dev->iobase + PCI9118_BURST);
+	outl(1, dev->iobase + PCI9118_SCANMOD);
+	outl(2, dev->iobase + PCI9118_SCANMOD);	// reset scan queue
+	devpriv->AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
+	outl(devpriv->AdFunctionReg, dev->iobase + PCI9118_ADFUNC);	// positive triggers, no S&H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+
+	devpriv->ao_data[0] = 2047;
+	devpriv->ao_data[1] = 2047;
+	outl(devpriv->ao_data[0], dev->iobase + PCI9118_DA1);	// reset A/D outs to 0V
+	outl(devpriv->ao_data[1], dev->iobase + PCI9118_DA2);
+	outl(0, dev->iobase + PCI9118_DO);	// reset digi outs to L
+	comedi_udelay(10);
+	inl(dev->iobase + PCI9118_AD_DATA);
+	outl(0, dev->iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev->iobase + PCI9118_INTSRC);	// remove INT requests
+	inl(dev->iobase + PCI9118_ADSTAT);	// flush A/D status register
+	inl(dev->iobase + PCI9118_INTSRC);	// flush INT requests
+	devpriv->AdControlReg = 0;
+	outl(devpriv->AdControlReg, dev->iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+
+	devpriv->cnt0_users = 0;
+	devpriv->exttrg_users = 0;
+
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	int ret, pages, i;
+	unsigned short master;
+	unsigned int irq;
+	unsigned long iobase_a, iobase_9;
+	struct pci_dev *pcidev;
+	int opt_bus, opt_slot;
+	const char *errstr;
+	unsigned char pci_bus, pci_slot, pci_func;
+	u16 u16w;
+
+	rt_printk("comedi%d: adl_pci9118: board=%s", dev->minor,
+		this_board->name);
+
+	opt_bus = it->options[0];
+	opt_slot = it->options[1];
+	if (it->options[3] & 1) {
+		master = 0;	// user don't want use bus master
+	} else {
+		master = 1;
+	}
+
+	if ((ret = alloc_private(dev, sizeof(pci9118_private))) < 0) {
+		rt_printk(" - Allocation failed!\n");
+		return -ENOMEM;
+	}
+
+	/* Look for matching PCI device */
+	errstr = "not found!";
+	pcidev = NULL;
+	while (NULL != (pcidev = pci_get_device(PCI_VENDOR_ID_AMCC,
+				this_board->device_id, pcidev))) {
+		/* Found matching vendor/device. */
+		if (opt_bus || opt_slot) {
+			/* Check bus/slot. */
+			if (opt_bus != pcidev->bus->number
+				|| opt_slot != PCI_SLOT(pcidev->devfn))
+				continue;	/* no match */
+		}
+		/*
+		 * Look for device that isn't in use.
+		 * Enable PCI device and request regions.
+		 */
+		if (comedi_pci_enable(pcidev, "adl_pci9118")) {
+			errstr = "failed to enable PCI device and request regions!";
+			continue;
+		}
+		break;
+	}
+
+	if (!pcidev) {
+		if (opt_bus || opt_slot) {
+			rt_printk(" - Card at b:s %d:%d %s\n",
+				opt_bus, opt_slot, errstr);
+		} else {
+			rt_printk(" - Card %s\n", errstr);
+		}
+		return -EIO;
+	}
+
+	if (master) {
+		pci_set_master(pcidev);
+	}
+
+	pci_bus = pcidev->bus->number;
+	pci_slot = PCI_SLOT(pcidev->devfn);
+	pci_func = PCI_FUNC(pcidev->devfn);
+	irq = pcidev->irq;
+	iobase_a = pci_resource_start(pcidev, 0);
+	iobase_9 = pci_resource_start(pcidev, 2);
+
+	rt_printk(", b:s:f=%d:%d:%d, io=0x%4lx, 0x%4lx", pci_bus, pci_slot,
+		pci_func, iobase_9, iobase_a);
+
+	dev->iobase = iobase_9;
+	dev->board_name = this_board->name;
+
+	devpriv->pcidev = pcidev;
+	devpriv->iobase_a = iobase_a;
+
+	pci9118_reset(dev);
+
+	if (it->options[3] & 2)
+		irq = 0;	// user don't want use IRQ
+	if (irq > 0) {
+		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
+				"ADLink PCI-9118", dev)) {
+			rt_printk(", unable to allocate IRQ %d, DISABLING IT",
+				irq);
+			irq = 0;	/* Can't use IRQ */
+		} else {
+			rt_printk(", irq=%u", irq);
+		}
+	} else {
+		rt_printk(", IRQ disabled");
+	}
+
+	dev->irq = irq;
+
+	if (master) {		// alloc DMA buffers
+		devpriv->dma_doublebuf = 0;
+		for (i = 0; i < 2; i++) {
+			for (pages = 4; pages >= 0; pages--)
+				if ((devpriv->dmabuf_virt[i] = (sampl_t *)
+						__get_free_pages(GFP_KERNEL,
+							pages)))
+					break;
+			if (devpriv->dmabuf_virt[i]) {
+				devpriv->dmabuf_pages[i] = pages;
+				devpriv->dmabuf_size[i] = PAGE_SIZE * pages;
+				devpriv->dmabuf_samples[i] =
+					devpriv->dmabuf_size[i] >> 1;
+				devpriv->dmabuf_hw[i] =
+					virt_to_bus((void *)devpriv->
+					dmabuf_virt[i]);
+			}
+		}
+		if (!devpriv->dmabuf_virt[0]) {
+			rt_printk(", Can't allocate DMA buffer, DMA disabled!");
+			master = 0;
+		}
+
+		if (devpriv->dmabuf_virt[1])
+			devpriv->dma_doublebuf = 1;
+
+	}
+
+	if ((devpriv->master = master)) {
+		rt_printk(", bus master");
+	} else {
+		rt_printk(", no bus master");
+	}
+
+	devpriv->usemux = 0;
+	if (it->options[2] > 0) {
+		devpriv->usemux = it->options[2];
+		if (devpriv->usemux > 256)
+			devpriv->usemux = 256;	// max 256 channels!
+		if (it->options[4] > 0)
+			if (devpriv->usemux > 128) {
+				devpriv->usemux = 128;	// max 128 channels with softare S&H!
+			}
+		rt_printk(", ext. mux %d channels", devpriv->usemux);
+	}
+
+	devpriv->softsshdelay = it->options[4];
+	if (devpriv->softsshdelay < 0) {	// select sample&hold signal polarity
+		devpriv->softsshdelay = -devpriv->softsshdelay;
+		devpriv->softsshsample = 0x80;
+		devpriv->softsshhold = 0x00;
+	} else {
+		devpriv->softsshsample = 0x00;
+		devpriv->softsshhold = 0x80;
+	}
+
+	rt_printk(".\n");
+
+	pci_read_config_word(devpriv->pcidev, PCI_COMMAND, &u16w);
+	pci_write_config_word(devpriv->pcidev, PCI_COMMAND, u16w | 64);	// Enable parity check for parity error
+
+	if ((ret = alloc_subdevices(dev, 4)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
+	if (devpriv->usemux) {
+		s->n_chan = devpriv->usemux;
+	} else {
+		s->n_chan = this_board->n_aichan;
+	}
+	s->maxdata = this_board->ai_maxdata;
+	s->len_chanlist = this_board->n_aichanlist;
+	s->range_table = this_board->rangelist_ai;
+	s->cancel = pci9118_ai_cancel;
+	s->insn_read = pci9118_insn_read_ai;
+	if (dev->irq) {
+		s->subdev_flags |= SDF_CMD_READ;
+		s->do_cmdtest = pci9118_ai_cmdtest;
+		s->do_cmd = pci9118_ai_cmd;
+		s->munge = pci9118_ai_munge;
+	}
+
+	s = dev->subdevices + 1;
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan = this_board->n_aochan;
+	s->maxdata = this_board->ao_maxdata;
+	s->len_chanlist = this_board->n_aochan;
+	s->range_table = this_board->rangelist_ao;
+	s->insn_write = pci9118_insn_write_ao;
+	s->insn_read = pci9118_insn_read_ao;
+
+	s = dev->subdevices + 2;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->len_chanlist = 4;
+	s->range_table = &range_digital;
+	s->io_bits = 0;		/* all bits input */
+	s->insn_bits = pci9118_insn_bits_di;
+
+	s = dev->subdevices + 3;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->len_chanlist = 4;
+	s->range_table = &range_digital;
+	s->io_bits = 0xf;	/* all bits output */
+	s->insn_bits = pci9118_insn_bits_do;
+
+	devpriv->valid = 1;
+	devpriv->i8254_osc_base = 250;	// 250ns=4MHz
+	devpriv->ai_maskharderr = 0x10a;	// default measure crash condition
+	if (it->options[5])	// disable some requested
+		devpriv->ai_maskharderr &= ~it->options[5];
+
+	switch (this_board->ai_maxdata) {
+	case 0xffff:
+		devpriv->ai16bits = 1;
+		break;
+	default:
+		devpriv->ai16bits = 0;
+		break;
+	}
+	return 0;
+}
+
+/*
+==============================================================================
+*/
+static int pci9118_detach(comedi_device * dev)
+{
+	if (dev->private) {
+		if (devpriv->valid)
+			pci9118_reset(dev);
+		if (dev->irq)
+			comedi_free_irq(dev->irq, dev);
+		if (devpriv->pcidev) {
+			if (dev->iobase) {
+				comedi_pci_disable(devpriv->pcidev);
+			}
+			pci_dev_put(devpriv->pcidev);
+		}
+		if (devpriv->dmabuf_virt[0])
+			free_pages((unsigned long)devpriv->dmabuf_virt[0],
+				devpriv->dmabuf_pages[0]);
+		if (devpriv->dmabuf_virt[1])
+			free_pages((unsigned long)devpriv->dmabuf_virt[1],
+				devpriv->dmabuf_pages[1]);
+	}
+
+	return 0;
+}
+
+/*
+==============================================================================
+*/
