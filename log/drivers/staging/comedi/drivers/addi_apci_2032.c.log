commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 5ab5a1a99608..a122f3f3f5ec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -11,16 +11,6 @@
  *	Fax: +49(0)7223/9493-92
  *	http://www.addi-data.com
  *	info@addi-data.com
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
  */
 
 #include <linux/module.h>

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 50f9eb25d7cb..5ab5a1a99608 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * addi_apci_2032.c
  * Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.

commit bb7085b1fbc7eee6d254fe978bd00ffcfe959bf6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 9 10:47:45 2015 -0700

    staging: comedi: addi_apci_2032: document the spinlock_t definition
    
    Add some comments to the private data tp quiet the checkpatch.pl
    issue about:
    
    CHECK: spinlock_t definition without comment
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index e14545dbf076..50f9eb25d7cb 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -44,9 +44,9 @@
 #define APCI2032_WDOG_REG		0x10
 
 struct apci2032_int_private {
-	spinlock_t spinlock;
-	bool active;
-	unsigned char enabled_isns;
+	spinlock_t spinlock;		/* protects the following members */
+	bool active;			/* an async command is running */
+	unsigned char enabled_isns;	/* mask of enabled interrupt channels */
 };
 
 static int apci2032_do_insn_bits(struct comedi_device *dev,

commit dc413f7ad166fcb1f88699616bb2654f42ad72ad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 9 10:47:44 2015 -0700

    staging: comedi: addi_apci_2032: prefer using the BIT macro
    
    As suggested by checkpatch.pl, use the BIT macro to define the
    register bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index ad715253bdcc..e14545dbf076 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -34,13 +34,13 @@
  */
 #define APCI2032_DO_REG			0x00
 #define APCI2032_INT_CTRL_REG		0x04
-#define APCI2032_INT_CTRL_VCC_ENA	(1 << 0)
-#define APCI2032_INT_CTRL_CC_ENA	(1 << 1)
+#define APCI2032_INT_CTRL_VCC_ENA	BIT(0)
+#define APCI2032_INT_CTRL_CC_ENA	BIT(1)
 #define APCI2032_INT_STATUS_REG		0x08
-#define APCI2032_INT_STATUS_VCC		(1 << 0)
-#define APCI2032_INT_STATUS_CC		(1 << 1)
+#define APCI2032_INT_STATUS_VCC		BIT(0)
+#define APCI2032_INT_STATUS_CC		BIT(1)
 #define APCI2032_STATUS_REG		0x0c
-#define APCI2032_STATUS_IRQ		(1 << 0)
+#define APCI2032_STATUS_IRQ		BIT(0)
 #define APCI2032_WDOG_REG		0x10
 
 struct apci2032_int_private {

commit ea7040e6364fc69291a0a3d5ded5948d66ceaa09
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:13:53 2015 +0000

    staging: comedi: addi_apci_2032: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 86abb7201698..ad715253bdcc 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -28,7 +28,6 @@
 
 #include "../comedi_pci.h"
 #include "addi_watchdog.h"
-#include "comedi_fc.h"
 
 /*
  * PCI bar 1 I/O Register map
@@ -92,17 +91,17 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -111,14 +110,15 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 66a630cad62feea5f89b526bac32da8b51efe7b6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:28 2015 +0000

    staging: comedi: addi_apci_2032: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index eebf4f151b39..86abb7201698 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -23,11 +23,10 @@
  */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 #include "addi_watchdog.h"
 #include "comedi_fc.h"
 

commit d1c87ceb441c3328cc1d0c18e07f5aeaa446306f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:20:53 2014 -0700

    staging: comedi: addi_apci_2032: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'stop_count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index fb20c5ea90b8..eebf4f151b39 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -47,7 +47,6 @@
 
 struct apci2032_int_private {
 	spinlock_t spinlock;
-	unsigned int stop_count;
 	bool active;
 	unsigned char enabled_isns;
 };
@@ -148,7 +147,6 @@ static int apci2032_int_cmd(struct comedi_device *dev,
 	spin_lock_irqsave(&subpriv->spinlock, flags);
 
 	subpriv->enabled_isns = enabled_isns;
-	subpriv->stop_count = cmd->stop_arg;
 	subpriv->active = true;
 	outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
 
@@ -211,16 +209,11 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 				bits |= (1 << i);
 		}
 
-		if (comedi_buf_write_samples(s, &bits, 1)) {
-			if (cmd->stop_src == TRIG_COUNT &&
-			    subpriv->stop_count > 0) {
-				subpriv->stop_count--;
-				if (subpriv->stop_count == 0) {
-					/* end of acquisition */
-					s->async->events |= COMEDI_CB_EOA;
-				}
-			}
-		}
+		comedi_buf_write_samples(s, &bits, 1);
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    s->async->scans_done >= cmd->stop_arg)
+			s->async->events |= COMEDI_CB_EOA;
 	}
 
 	spin_unlock(&subpriv->spinlock);

commit ef49d8329e25ee1686520315713b86419cddcb45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:34 2014 -0700

    staging: comedi: drivers: replace SDF_WRITEABLE with SDF_WRITABLE
    
    As indicated in the comedi.h uapi header, SDF_WRITEABLE was a spelling
    error in the API, SDF_WRITABLE is prefered.
    
    For aesthetics, replace all the SDF_WRITEABLE uses with SDF_WRITABLE.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 7a5659fafbb3..fb20c5ea90b8 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -267,7 +267,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	/* Initialize the digital output subdevice */
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_DO;
-	s->subdev_flags	= SDF_WRITEABLE;
+	s->subdev_flags	= SDF_WRITABLE;
 	s->n_chan	= 32;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;

commit 4c704690e743200de94526938cb03cf80c5ae0c3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:37:10 2014 -0700

    staging: comedi: addi_apci_2032: use comedi_buf_write_samples()
    
    The dev->read_subdev used in this driver for async commands returns the
    full scan with each sample so it should have the SDF_PACKED subdev_flag
    set.
    
    Add the missing subdev_flags and use comedi_buf_write_samples() to add
    the sample to the async buffer.
    
    The core sets the async events appropriately. Remove the unnecessary
    event handling in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index ad7529459429..7a5659fafbb3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -211,8 +211,7 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 				bits |= (1 << i);
 		}
 
-		if (comedi_buf_put(s, bits)) {
-			s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+		if (comedi_buf_write_samples(s, &bits, 1)) {
 			if (cmd->stop_src == TRIG_COUNT &&
 			    subpriv->stop_count > 0) {
 				subpriv->stop_count--;
@@ -221,8 +220,6 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 					s->async->events |= COMEDI_CB_EOA;
 				}
 			}
-		} else {
-			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 	}
 
@@ -299,7 +296,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 			return -ENOMEM;
 		spin_lock_init(&subpriv->spinlock);
 		s->private	= subpriv;
-		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
+		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ | SDF_PACKED;
 		s->len_chanlist = 2;
 		s->do_cmdtest	= apci2032_int_cmdtest;
 		s->do_cmd	= apci2032_int_cmd;

commit 7ff4b5847c7063c2f60bd1c40f59160389ae2449
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:35:32 2014 -0700

    staging: comedi: addi_apci_2032: use comedi_handle_events()
    
    Use comedi_handle_events() to automatically (*cancel) the async command
    for an end-of-acquisition or if an error/overflow occurs.
    
    Also, comedi_handle_events() does nothing if no events are set so the
    local variable 'do_event' can be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index aea3da325359..ad7529459429 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -178,7 +178,6 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct apci2032_int_private *subpriv;
 	unsigned int val;
-	bool do_event = false;
 
 	if (!dev->attached)
 		return IRQ_NONE;
@@ -220,19 +219,16 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 				if (subpriv->stop_count == 0) {
 					/* end of acquisition */
 					s->async->events |= COMEDI_CB_EOA;
-					apci2032_int_stop(dev, s);
 				}
 			}
 		} else {
-			apci2032_int_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
-		do_event = true;
 	}
 
 	spin_unlock(&subpriv->spinlock);
-	if (do_event)
-		comedi_event(dev, s);
+
+	comedi_handle_events(dev, s);
 
 	return IRQ_HANDLED;
 }

commit 103e280141ecd19b429567af9e9931817dfacd2a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:34 2014 -0700

    staging: comedi: addi_apci_2032: absorb apci2032_int_start()
    
    This function always returns 'false' so the caller never does the comedi_event().
    
    Absorb the function into the caller and remove the 'do_event' dead code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 8514811a988b..aea3da325359 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -86,23 +86,6 @@ static void apci2032_int_stop(struct comedi_device *dev,
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 }
 
-static bool apci2032_int_start(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       unsigned char enabled_isns)
-{
-	struct apci2032_int_private *subpriv = s->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	bool do_event;
-
-	subpriv->enabled_isns = enabled_isns;
-	subpriv->stop_count = cmd->stop_arg;
-	subpriv->active = true;
-	outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
-	do_event = false;
-
-	return do_event;
-}
-
 static int apci2032_int_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -157,18 +140,19 @@ static int apci2032_int_cmd(struct comedi_device *dev,
 	unsigned char enabled_isns;
 	unsigned int n;
 	unsigned long flags;
-	bool do_event;
 
 	enabled_isns = 0;
 	for (n = 0; n < cmd->chanlist_len; n++)
 		enabled_isns |= 1 << CR_CHAN(cmd->chanlist[n]);
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	do_event = apci2032_int_start(dev, s, enabled_isns);
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
-	if (do_event)
-		comedi_event(dev, s);
+	subpriv->enabled_isns = enabled_isns;
+	subpriv->stop_count = cmd->stop_arg;
+	subpriv->active = true;
+	outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
+
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
 }

commit 52c22b803e1b0259adddb0bd2153674ddb2da0d3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:33 2014 -0700

    staging: comedi: addi_apci_2032: remove "empty acquisition" async command
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0. This causes the (*do_cmd) to immediatelt generate a COMEDI_CB_EOA event
    without acquiring any data.
    
    This "empty acquisition" async command is not really useful. Validate that the
    cmd->stop_arg is >= 1 in the (*do_cmdtest) and remove the "empty acquisition"
    code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 45ea4a4e451b..8514811a988b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -96,16 +96,9 @@ static bool apci2032_int_start(struct comedi_device *dev,
 
 	subpriv->enabled_isns = enabled_isns;
 	subpriv->stop_count = cmd->stop_arg;
-	if (cmd->stop_src == TRIG_COUNT && subpriv->stop_count == 0) {
-		/* An empty acquisition! */
-		s->async->events |= COMEDI_CB_EOA;
-		subpriv->active = false;
-		do_event = true;
-	} else {
-		subpriv->active = true;
-		outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
-		do_event = false;
-	}
+	subpriv->active = true;
+	outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
+	do_event = false;
 
 	return do_event;
 }
@@ -141,7 +134,9 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 6768d1dc2005..45ea4a4e451b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -338,11 +338,9 @@ static void apci2032_detach(struct comedi_device *dev)
 {
 	if (dev->iobase)
 		apci2032_reset(dev);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
+	comedi_pci_detach(dev);
 	if (dev->read_subdev)
 		kfree(dev->read_subdev->private);
-	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver apci2032_driver = {

commit b3cdebbfe22e26c3004eaec91fca1d1851b248d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:24:01 2014 -0700

    staging: comedi: addi_apci_2032: remove deadcode in apci2030_int_cmdtest()
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index be0a8a7bd3b2..6768d1dc2005 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -147,10 +147,9 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: ignored */
+	/* Step 4: fix up any arguments */
 
-	if (err)
-		return 4;
+	/* Step 5: check channel list if it exists */
 
 	return 0;
 }

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 2fd14553e57c..be0a8a7bd3b2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -234,7 +234,7 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 				bits |= (1 << i);
 		}
 
-		if (comedi_buf_put(s->async, bits)) {
+		if (comedi_buf_put(s, bits)) {
 			s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 			if (cmd->stop_src == TRIG_COUNT &&
 			    subpriv->stop_count > 0) {

commit 56e781203f055e93e2ff510d87a986e2b367c071
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:36 2014 -0700

    staging: comedi: addi_apci_2032: tidy up cmd use in apci2032_interrupt()
    
    Use a local variable for the comedi_cmd and tidy up this function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index feefc7a5ca9a..2fd14553e57c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -197,6 +197,7 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	struct apci2032_int_private *subpriv;
 	unsigned int val;
 	bool do_event = false;
@@ -222,21 +223,20 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	 */
 
 	if (subpriv->active && (val & subpriv->enabled_isns) != 0) {
-		unsigned short bits;
-		unsigned int n, len;
-		unsigned int *chanlist;
+		unsigned short bits = 0;
+		int i;
 
 		/* Bits in scan data correspond to indices in channel list. */
-		bits = 0;
-		len = s->async->cmd.chanlist_len;
-		chanlist = &s->async->cmd.chanlist[0];
-		for (n = 0; n < len; n++)
-			if ((val & (1U << CR_CHAN(chanlist[n]))) != 0)
-				bits |= 1U << n;
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+
+			if (val & (1 << chan))
+				bits |= (1 << i);
+		}
 
 		if (comedi_buf_put(s->async, bits)) {
 			s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-			if (s->async->cmd.stop_src == TRIG_COUNT &&
+			if (cmd->stop_src == TRIG_COUNT &&
 			    subpriv->stop_count > 0) {
 				subpriv->stop_count--;
 				if (subpriv->stop_count == 0) {

commit b5ebcaa8d3405e14ca431257fd6c6cdc30df13c5
Author: Georg Gast <georg@schorsch-tech.de>
Date:   Tue Apr 8 18:52:58 2014 +0200

    staging: comedi: more descriptive names for addi-data drivers
    
    - more descriptive module description for following boards:
      ADDI-DATA APCI 1032/1500/1564/2032/3120
    
    Signed-off-by: Georg Gast <georg@schorsch-tech.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index c9b933cb5987..feefc7a5ca9a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -374,5 +374,5 @@ static struct pci_driver apci2032_pci_driver = {
 module_comedi_pci_driver(apci2032_driver, apci2032_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("ADDI-DATA APCI-2032, 32 channel DO boards");
 MODULE_LICENSE("GPL");

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index c77ee8732d38..c9b933cb5987 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -359,7 +359,7 @@ static int apci2032_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci2032_driver, id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(apci2032_pci_table) = {
+static const struct pci_device_id apci2032_pci_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },
 	{ 0 }
 };

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 6b0ea16ff546..c77ee8732d38 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -57,16 +57,10 @@ static int apci2032_do_insn_bits(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
-
 	s->state = inl(dev->iobase + APCI2032_DO_REG);
-	if (mask) {
-		s->state &= ~mask;
-		s->state |= (bits & mask);
 
+	if (comedi_dio_update_state(s, data))
 		outl(s->state, dev->iobase + APCI2032_DO_REG);
-	}
 
 	data[1] = s->state;
 

commit bcc27c82bac2622e352c732a0bda49651e1799b3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Jul 25 22:02:48 2013 +0200

    staging: comedi: Add missing #include <linux/slab.h>
    
    sparc64 allmodconfig:
    
    drivers/staging/comedi/drivers/addi_apci_2032.c: In function 'apci2032_auto_attach':
    drivers/staging/comedi/drivers/addi_apci_2032.c:328:3: error: implicit declaration of function 'kzalloc' [-Werror=implicit-function-declaration]
    drivers/staging/comedi/drivers/addi_apci_2032.c:328:11: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/addi_apci_2032.c: In function 'apci2032_detach':
    drivers/staging/comedi/drivers/addi_apci_2032.c:350:3: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
    
    drivers/staging/comedi/drivers/amplc_pci224.c: In function 'pci224_attach_common':
    drivers/staging/comedi/drivers/amplc_pci224.c:1289:2: error: implicit declaration of function 'kmalloc' [-Werror=implicit-function-declaration]
    drivers/staging/comedi/drivers/amplc_pci224.c:1289:23: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1296:24: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1303:25: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c:1348:42: warning: assignment makes pointer from integer without a cast [enabled by default]
    drivers/staging/comedi/drivers/amplc_pci224.c: In function 'pci224_detach':
    drivers/staging/comedi/drivers/amplc_pci224.c:1474:3: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
    
    Introduced by commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a ("staging:
    comedi: use comedi_alloc_devpriv()"), which removed some inclusions of
    <linux/slab.h>.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index cb5d26a567d3..6b0ea16ff546 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 
 #include "../comedidev.h"
 #include "addi_watchdog.h"

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 89ead8eb3c70..cb5d26a567d3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -22,6 +22,7 @@
  * more details.
  */
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index c0d83d8709f4..89ead8eb3c70 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -347,7 +347,6 @@ static void apci2032_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->read_subdev)
 		kfree(dev->read_subdev->private);
-	comedi_spriv_free(dev, 1);
 	comedi_pci_disable(dev);
 }
 

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index b666637f61be..c0d83d8709f4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -20,13 +20,6 @@
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * You should also find the complete GPL in the COPYING file accompanying
- * this source code.
  */
 
 #include <linux/pci.h>

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index e5fa20aa7f2d..b666637f61be 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -354,8 +354,7 @@ static void apci2032_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->read_subdev)
 		kfree(dev->read_subdev->private);
-	if (dev->subdevices)
-		addi_watchdog_cleanup(&dev->subdevices[1]);
+	comedi_spriv_free(dev, 1);
 	comedi_pci_disable(dev);
 }
 

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 59e092eab9f3..e5fa20aa7f2d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -287,8 +287,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	struct comedi_subdevice *s;
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 6e4ee0ae67aa..59e092eab9f3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -289,7 +289,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	dev->board_name = dev->driver->driver_name;
 
-	ret = comedi_pci_enable(pcidev, dev->board_name);
+	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
 	dev->iobase = pci_resource_start(pcidev, 1);

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 4a33b3502f40..6e4ee0ae67aa 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -350,8 +350,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 static void apci2032_detach(struct comedi_device *dev)
 {
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-
 	if (dev->iobase)
 		apci2032_reset(dev);
 	if (dev->irq)
@@ -360,10 +358,7 @@ static void apci2032_detach(struct comedi_device *dev)
 		kfree(dev->read_subdev->private);
 	if (dev->subdevices)
 		addi_watchdog_cleanup(&dev->subdevices[1]);
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-	}
+	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver apci2032_driver = {

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 9ce1d26aff2f..4a33b3502f40 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -374,9 +374,9 @@ static struct comedi_driver apci2032_driver = {
 };
 
 static int apci2032_pci_probe(struct pci_dev *dev,
-					const struct pci_device_id *ent)
+			      const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &apci2032_driver);
+	return comedi_pci_auto_config(dev, &apci2032_driver, id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(apci2032_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 15b080e737cf..9ce1d26aff2f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -29,6 +29,7 @@
  * this source code.
  */
 
+#include <linux/pci.h>
 #include <linux/interrupt.h>
 
 #include "../comedidev.h"

commit abac8b54a353b9a1ac7d09ff790812655f618896
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:21:49 2013 -0700

    staging: comedi: conditionally build in USB driver support
    
    Separate the comedi_usb_* functions out of drivers.c into a new
    source file, comedi_usb.c. This allows conditionally building
    support for comedi USB drivers into the comedi core without the
    need for the #if'defery. Fix the Kconfig and Makefile appropriately.
    For aesthetic reasons, add some whitespace to the Makefile to keep
    everything lined up.
    
    Group all the comedi_usb_* prototypes into one place in comedidev.h.
    Protect these prototypes with an #ifdef so that building a comedi
    usb driver without USB support will cause a build error. This will
    normally not happen as long as the comedi USB driver is placed in
    the proper group in the Kconfig.
    
    Remove the #include<linux/usb.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi USB driver support code and the
    USB drivers. The include should occur in those files.
    
    Removing the include of usb.h exposed a couple drivers that need
    <linux/interrupt.h> and <linux/sched.h>. Add the missing includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 5ad9db9b84b2..15b080e737cf 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -29,6 +29,8 @@
  * this source code.
  */
 
+#include <linux/interrupt.h>
+
 #include "../comedidev.h"
 #include "addi_watchdog.h"
 #include "comedi_fc.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 4660ec730266..5ad9db9b84b2 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -376,11 +376,6 @@ static int apci2032_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci2032_driver);
 }
 
-static void apci2032_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(apci2032_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },
 	{ 0 }
@@ -391,7 +386,7 @@ static struct pci_driver apci2032_pci_driver = {
 	.name		= "addi_apci_2032",
 	.id_table	= apci2032_pci_table,
 	.probe		= apci2032_pci_probe,
-	.remove		= apci2032_pci_remove,
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(apci2032_driver, apci2032_pci_driver);
 

commit 5b62fe2a03e9d25569c0fa0b81b96ac6f0c9b5fd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jan 17 17:41:25 2013 -0700

    staging: comedi: addi_apci_2032: use addi_watchdog module
    
    Use the addi_watchdog module to provide support for the watchdog
    subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 31e1259f8822..4660ec730266 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -30,6 +30,7 @@
  */
 
 #include "../comedidev.h"
+#include "addi_watchdog.h"
 #include "comedi_fc.h"
 
 /*
@@ -45,18 +46,6 @@
 #define APCI2032_STATUS_REG		0x0c
 #define APCI2032_STATUS_IRQ		(1 << 0)
 #define APCI2032_WDOG_REG		0x10
-#define APCI2032_WDOG_RELOAD_REG	0x14
-#define APCI2032_WDOG_TIMEBASE		0x18
-#define APCI2032_WDOG_CTRL_REG		0x1c
-#define APCI2032_WDOG_CTRL_ENABLE	(1 << 0)
-#define APCI2032_WDOG_CTRL_SW_TRIG	(1 << 9)
-#define APCI2032_WDOG_STATUS_REG	0x20
-#define APCI2032_WDOG_STATUS_ENABLED	(1 << 0)
-#define APCI2032_WDOG_STATUS_SW_TRIG	(1 << 1)
-
-struct apci2032_private {
-	unsigned int wdog_ctrl;
-};
 
 struct apci2032_int_private {
 	spinlock_t spinlock;
@@ -86,81 +75,6 @@ static int apci2032_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/*
- * The watchdog subdevice is configured with two INSN_CONFIG instructions:
- *
- * Enable the watchdog and set the reload timeout:
- *	data[0] = INSN_CONFIG_ARM
- *	data[1] = timeout reload value
- *
- * Disable the watchdog:
- *	data[0] = INSN_CONFIG_DISARM
- */
-static int apci2032_wdog_insn_config(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data)
-{
-	struct apci2032_private *devpriv = dev->private;
-	unsigned int reload;
-
-	switch (data[0]) {
-	case INSN_CONFIG_ARM:
-		devpriv->wdog_ctrl = APCI2032_WDOG_CTRL_ENABLE;
-		reload = data[1] & s->maxdata;
-		outw(reload, dev->iobase + APCI2032_WDOG_RELOAD_REG);
-
-		/* Time base is 20ms, let the user know the timeout */
-		dev_info(dev->class_dev, "watchdog enabled, timeout:%dms\n",
-			20 * reload + 20);
-		break;
-	case INSN_CONFIG_DISARM:
-		devpriv->wdog_ctrl = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	outw(devpriv->wdog_ctrl, dev->iobase + APCI2032_WDOG_CTRL_REG);
-
-	return insn->n;
-}
-
-static int apci2032_wdog_insn_write(struct comedi_device *dev,
-				    struct comedi_subdevice *s,
-				    struct comedi_insn *insn,
-				    unsigned int *data)
-{
-	struct apci2032_private *devpriv = dev->private;
-	int i;
-
-	if (devpriv->wdog_ctrl == 0) {
-		dev_warn(dev->class_dev, "watchdog is disabled\n");
-		return -EINVAL;
-	}
-
-	/* "ping" the watchdog */
-	for (i = 0; i < insn->n; i++) {
-		outw(devpriv->wdog_ctrl | APCI2032_WDOG_CTRL_SW_TRIG,
-			dev->iobase + APCI2032_WDOG_CTRL_REG);
-	}
-
-	return insn->n;
-}
-
-static int apci2032_wdog_insn_read(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data)
-{
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = inl(dev->iobase + APCI2032_WDOG_STATUS_REG);
-
-	return insn->n;
-}
-
 static int apci2032_int_insn_bits(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn,
@@ -357,8 +271,8 @@ static int apci2032_reset(struct comedi_device *dev)
 {
 	outl(0x0, dev->iobase + APCI2032_DO_REG);
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
-	outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
-	outl(0x0, dev->iobase + APCI2032_WDOG_RELOAD_REG);
+
+	addi_watchdog_reset(dev->iobase + APCI2032_WDOG_REG);
 
 	return 0;
 }
@@ -367,17 +281,11 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct apci2032_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
 	dev->board_name = dev->driver->driver_name;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
@@ -406,13 +314,9 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[1];
-	s->type		= COMEDI_SUBD_TIMER;
-	s->subdev_flags	= SDF_WRITEABLE;
-	s->n_chan	= 1;
-	s->maxdata	= 0xff;
-	s->insn_write	= apci2032_wdog_insn_write;
-	s->insn_read	= apci2032_wdog_insn_read;
-	s->insn_config	= apci2032_wdog_insn_config;
+	ret = addi_watchdog_init(s, dev->iobase + APCI2032_WDOG_REG);
+	if (ret)
+		return ret;
 
 	/* Initialize the interrupt subdevice */
 	s = &dev->subdevices[2];
@@ -451,6 +355,8 @@ static void apci2032_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->read_subdev)
 		kfree(dev->read_subdev->private);
+	if (dev->subdevices)
+		addi_watchdog_cleanup(&dev->subdevices[1]);
 	if (pcidev) {
 		if (dev->iobase)
 			comedi_pci_disable(pcidev);

commit 215caceb3dac9eb7d431c9da21394c6ccb778b15
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:47 2012 +0000

    staging: comedi: addi_apci_2032: support stop_src == TRIG_COUNT
    
    When setting up asynchronous commands on the special interrupt
    subdevice, support the `TRIG_COUNT` stop source to allow the command to
    stop automatically after a specified number of scans.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index c302bf9ba4ec..31e1259f8822 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -60,6 +60,7 @@ struct apci2032_private {
 
 struct apci2032_int_private {
 	spinlock_t spinlock;
+	unsigned int stop_count;
 	bool active;
 	unsigned char enabled_isns;
 };
@@ -179,6 +180,30 @@ static void apci2032_int_stop(struct comedi_device *dev,
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 }
 
+static bool apci2032_int_start(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       unsigned char enabled_isns)
+{
+	struct apci2032_int_private *subpriv = s->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	bool do_event;
+
+	subpriv->enabled_isns = enabled_isns;
+	subpriv->stop_count = cmd->stop_arg;
+	if (cmd->stop_src == TRIG_COUNT && subpriv->stop_count == 0) {
+		/* An empty acquisition! */
+		s->async->events |= COMEDI_CB_EOA;
+		subpriv->active = false;
+		do_event = true;
+	} else {
+		subpriv->active = true;
+		outl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
+		do_event = false;
+	}
+
+	return do_event;
+}
+
 static int apci2032_int_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -191,12 +216,14 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
 	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
 	/* Step 2b : and mutually compatible */
 
 	if (err)
@@ -208,7 +235,8 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -229,17 +257,19 @@ static int apci2032_int_cmd(struct comedi_device *dev,
 	unsigned char enabled_isns;
 	unsigned int n;
 	unsigned long flags;
+	bool do_event;
 
 	enabled_isns = 0;
 	for (n = 0; n < cmd->chanlist_len; n++)
 		enabled_isns |= 1 << CR_CHAN(cmd->chanlist[n]);
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	subpriv->enabled_isns = enabled_isns;
-	subpriv->active = true;
-	outl(subpriv->enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
+	do_event = apci2032_int_start(dev, s, enabled_isns);
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
+	if (do_event)
+		comedi_event(dev, s);
+
 	return 0;
 }
 
@@ -300,6 +330,15 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 
 		if (comedi_buf_put(s->async, bits)) {
 			s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+			if (s->async->cmd.stop_src == TRIG_COUNT &&
+			    subpriv->stop_count > 0) {
+				subpriv->stop_count--;
+				if (subpriv->stop_count == 0) {
+					/* end of acquisition */
+					s->async->events |= COMEDI_CB_EOA;
+					apci2032_int_stop(dev, s);
+				}
+			}
 		} else {
 			apci2032_int_stop(dev, s);
 			s->async->events |= COMEDI_CB_OVERFLOW;

commit 5f6c2a954d17544c68ce83d016ea456207cadeac
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:46 2012 +0000

    staging: comedi: addi_apci_2032: always initialize interrupt subdevice
    
    Initialize the special interrupt subdevice as a digital input subdevice
    even if the interrupt handler cannot be registered.  It's `insn_bits`
    handler will still read the interrupt status register.  This hardware
    status bits in this register might be valid even if they haven't been
    enabled in the interrupt control register, but this needs to be checked.
    In any case, initializing the subdevice as a digital input subdevice is
    harmless.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index dd81ddc3d986..c302bf9ba4ec 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -377,6 +377,12 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the interrupt subdevice */
 	s = &dev->subdevices[2];
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 2;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= apci2032_int_insn_bits;
 	if (dev->irq) {
 		struct apci2032_int_private *subpriv;
 
@@ -386,18 +392,11 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 			return -ENOMEM;
 		spin_lock_init(&subpriv->spinlock);
 		s->private	= subpriv;
-		s->type		= COMEDI_SUBD_DI;
 		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
-		s->n_chan	= 2;
 		s->len_chanlist = 2;
-		s->maxdata	= 1;
-		s->range_table	= &range_digital;
-		s->insn_bits	= apci2032_int_insn_bits;
 		s->do_cmdtest	= apci2032_int_cmdtest;
 		s->do_cmd	= apci2032_int_cmd;
 		s->cancel	= apci2032_int_cancel;
-	} else {
-		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	return 0;

commit 5c2d4cba9586ddc3505f51bddf935ddc65a0e0bb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:45 2012 +0000

    staging: comedi: addi_apci_2032: use channel list
    
    When setting up asynchronous commands for the special interrupt
    subdevice, use the channel list to decide which interrupt sources to
    enable.  Set the maximum length of the channel list to be the same as
    the number of channels (2).  Normally, the channel list would include
    channel 0, channel 1 or both.
    
    When reading the scan data in the interrupt routine, the readings from
    each channel in the channel list will be packed into a single unsigned
    short data value.  Make each bit in this value correspond to an index in
    the channel list.
    
    Since all the channels in the channel list are read at the same time,
    insist that the scan end argument is the length of the channel list and
    that the conversion source is `TRIG_NOW`.
    
    Allocate some private data for the special interrupt subdevice to hold a
    spin-lock, the channels to be enabled and an indication of whether the
    command is still active.  Stop the command if a buffer overflow occurs.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 98691fdfbd48..dd81ddc3d986 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -58,6 +58,12 @@ struct apci2032_private {
 	unsigned int wdog_ctrl;
 };
 
+struct apci2032_int_private {
+	spinlock_t spinlock;
+	bool active;
+	unsigned char enabled_isns;
+};
+
 static int apci2032_do_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn,
@@ -163,6 +169,16 @@ static int apci2032_int_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
+static void apci2032_int_stop(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
+{
+	struct apci2032_int_private *subpriv = s->private;
+
+	subpriv->active = false;
+	subpriv->enabled_isns = 0;
+	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
+}
+
 static int apci2032_int_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -172,8 +188,8 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_OTHER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
@@ -189,17 +205,9 @@ static int apci2032_int_cmdtest(struct comedi_device *dev,
 	/* Step 3: check if arguments are trivially valid */
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-
-	/*
-	 * 0 == no trigger
-	 * 1 == trigger on VCC interrupt
-	 * 2 == trigger on CC interrupt
-	 * 3 == trigger on either VCC or CC interrupt
-	 */
-	err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 3);
-
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
@@ -217,8 +225,20 @@ static int apci2032_int_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
+	struct apci2032_int_private *subpriv = s->private;
+	unsigned char enabled_isns;
+	unsigned int n;
+	unsigned long flags;
+
+	enabled_isns = 0;
+	for (n = 0; n < cmd->chanlist_len; n++)
+		enabled_isns |= 1 << CR_CHAN(cmd->chanlist[n]);
 
-	outl(cmd->scan_begin_arg, dev->iobase + APCI2032_INT_CTRL_REG);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
+	subpriv->enabled_isns = enabled_isns;
+	subpriv->active = true;
+	outl(subpriv->enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
 }
@@ -226,7 +246,13 @@ static int apci2032_int_cmd(struct comedi_device *dev,
 static int apci2032_int_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s)
 {
-	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
+	struct apci2032_int_private *subpriv = s->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&subpriv->spinlock, flags);
+	if (subpriv->active)
+		apci2032_int_stop(dev, s);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
 }
@@ -235,7 +261,9 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct apci2032_int_private *subpriv;
 	unsigned int val;
+	bool do_event = false;
 
 	if (!dev->attached)
 		return IRQ_NONE;
@@ -245,6 +273,9 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	if (!val)
 		return IRQ_NONE;
 
+	subpriv = s->private;
+	spin_lock(&subpriv->spinlock);
+
 	val = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;
 	/* Disable triggered interrupt sources. */
 	outl(~val & 3, dev->iobase + APCI2032_INT_CTRL_REG);
@@ -254,11 +285,31 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	 * they'd keep triggering interrupts repeatedly.
 	 */
 
-	if (comedi_buf_put(s->async, val))
-		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-	else
-		s->async->events |= COMEDI_CB_OVERFLOW;
-	comedi_event(dev, s);
+	if (subpriv->active && (val & subpriv->enabled_isns) != 0) {
+		unsigned short bits;
+		unsigned int n, len;
+		unsigned int *chanlist;
+
+		/* Bits in scan data correspond to indices in channel list. */
+		bits = 0;
+		len = s->async->cmd.chanlist_len;
+		chanlist = &s->async->cmd.chanlist[0];
+		for (n = 0; n < len; n++)
+			if ((val & (1U << CR_CHAN(chanlist[n]))) != 0)
+				bits |= 1U << n;
+
+		if (comedi_buf_put(s->async, bits)) {
+			s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+		} else {
+			apci2032_int_stop(dev, s);
+			s->async->events |= COMEDI_CB_OVERFLOW;
+		}
+		do_event = true;
+	}
+
+	spin_unlock(&subpriv->spinlock);
+	if (do_event)
+		comedi_event(dev, s);
 
 	return IRQ_HANDLED;
 }
@@ -327,10 +378,18 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	/* Initialize the interrupt subdevice */
 	s = &dev->subdevices[2];
 	if (dev->irq) {
+		struct apci2032_int_private *subpriv;
+
 		dev->read_subdev = s;
+		subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
+		if (!subpriv)
+			return -ENOMEM;
+		spin_lock_init(&subpriv->spinlock);
+		s->private	= subpriv;
 		s->type		= COMEDI_SUBD_DI;
 		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
 		s->n_chan	= 2;
+		s->len_chanlist = 2;
 		s->maxdata	= 1;
 		s->range_table	= &range_digital;
 		s->insn_bits	= apci2032_int_insn_bits;
@@ -352,6 +411,8 @@ static void apci2032_detach(struct comedi_device *dev)
 		apci2032_reset(dev);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
+	if (dev->read_subdev)
+		kfree(dev->read_subdev->private);
 	if (pcidev) {
 		if (dev->iobase)
 			comedi_pci_disable(pcidev);

commit ef6543dbad12c1086f3bc3565d8266352521d8a3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:44 2012 +0000

    staging: comedi: addi_apci_2032: only disable triggered interrupts
    
    The interrupt handler disables all interrupt sources when a valid
    interrupt occurs.  Just disable the triggered interrupt source so we can
    still get interrupts for the other interrupt source.
    
    Also add a comment indicating why the triggered interrupt source is
    disabled.  The interrupt sources are level-sensitive and indicate
    hardware errors that are likely to be persistent, so if we reenabled
    them they would just keep triggering repeatedly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 4c348dd2a5d5..98691fdfbd48 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -246,7 +246,13 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	val = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;
-	outl(0x00, dev->iobase + APCI2032_INT_CTRL_REG);
+	/* Disable triggered interrupt sources. */
+	outl(~val & 3, dev->iobase + APCI2032_INT_CTRL_REG);
+	/*
+	 * Note: We don't reenable the triggered interrupt sources because they
+	 * are level-sensitive, hardware error status interrupt sources and
+	 * they'd keep triggering interrupts repeatedly.
+	 */
 
 	if (comedi_buf_put(s->async, val))
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;

commit b652bd83a0528c43e935cb6f2f8df024b7a85c5e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:43 2012 +0000

    staging: comedi: addi_apci_2032: make insn_bits read live data
    
    The `insn_bits` handler for the special digital input subdevice used for
    interrupts currently uses `s->state` for the data value, which is set to
    the value of the APCI2032_INT_STATUS_REG register when a valid interrupt
    occurs.  Just read the live register contents in the `insn_bits` handler
    instead of relying on the interrupt service routine to read it for us.
    
    The register contains a couple of hardware error status bits.  They
    might also be valid even when the corresponding bits have not been
    enabled in the APCI_INT_CTRL_REG register in which case this would be
    useful for checking for hardware errors without using interrupts, but
    this needs to be checked.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index aeb34dbe02a4..4c348dd2a5d5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -159,7 +159,7 @@ static int apci2032_int_insn_bits(struct comedi_device *dev,
 				  struct comedi_insn *insn,
 				  unsigned int *data)
 {
-	data[1] = s->state;
+	data[1] = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;
 	return insn->n;
 }
 
@@ -245,10 +245,10 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	if (!val)
 		return IRQ_NONE;
 
-	s->state = inl(dev->iobase + APCI2032_INT_STATUS_REG);
-	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
+	val = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;
+	outl(0x00, dev->iobase + APCI2032_INT_CTRL_REG);
 
-	if (comedi_buf_put(s->async, s->state))
+	if (comedi_buf_put(s->async, val))
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
 	else
 		s->async->events |= COMEDI_CB_OVERFLOW;

commit 6bf9a3babe630a9972b28fd3bb7d2cfcd40e6409
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:42 2012 +0000

    staging: comedi: addi_apci_2032: set COMEDI_CB_OVERFLOW
    
    If the call to `comedi_buf_put()` fails in the interrupt routine, set
    the `COMEDI_CB_OVERFLOW` event flag.  Note that the `COMEDI_CB_ERROR`
    flag will have also been set by `comedi_buf_put()` in this case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index f04f59d33cc7..aeb34dbe02a4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -248,8 +248,10 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	s->state = inl(dev->iobase + APCI2032_INT_STATUS_REG);
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 
-	comedi_buf_put(s->async, s->state);
-	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	if (comedi_buf_put(s->async, s->state))
+		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	else
+		s->async->events |= COMEDI_CB_OVERFLOW;
 	comedi_event(dev, s);
 
 	return IRQ_HANDLED;

commit b82fe57c4d059a8ff1190ead1693d66b868353b2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:41 2012 +0000

    staging: comedi: addi_apci_2032: correct interrupt subdevice
    
    The subdevice type and flags are initialized incorrectly for the
    interrupt subdevice - the SDF_CMD_READ value belongs in the subdevice
    flags.  Fix it.  Also set the number of channels to 2 since there are 2
    interrupt sources each with its own status bit.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 3b5e1d74d129..f04f59d33cc7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -320,9 +320,9 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[2];
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->type		= COMEDI_SUBD_DI | SDF_CMD_READ;
-		s->subdev_flags	= SDF_READABLE;
-		s->n_chan	= 1;
+		s->type		= COMEDI_SUBD_DI;
+		s->subdev_flags	= SDF_READABLE | SDF_CMD_READ;
+		s->n_chan	= 2;
 		s->maxdata	= 1;
 		s->range_table	= &range_digital;
 		s->insn_bits	= apci2032_int_insn_bits;

commit 0774c2b5c1e0025cb016393d8552171c0ec55c39
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Dec 3 18:15:40 2012 +0000

    staging: comedi: addi_apci_2032: interrupt safety change
    
    Put the hardware into a safe state before enabling the interrupt.  In
    the interrupt routine, check the device has been fully configured by
    checking `dev->attached`.  In particular, `dev->read_subdev` could be
    NULL early on and although the hardware's status register should
    indicate no interrupt has occurred (since it's been put into a safe
    state), it's better not to rely on it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 8f8d3e95fc78..3b5e1d74d129 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -237,6 +237,9 @@ static irqreturn_t apci2032_interrupt(int irq, void *d)
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int val;
 
+	if (!dev->attached)
+		return IRQ_NONE;
+
 	/* Check if VCC OR CC interrupt has occurred */
 	val = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;
 	if (!val)
@@ -281,6 +284,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 	dev->iobase = pci_resource_start(pcidev, 1);
+	apci2032_reset(dev);
 
 	if (pcidev->irq > 0) {
 		ret = request_irq(pcidev->irq, apci2032_interrupt,
@@ -329,7 +333,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
-	apci2032_reset(dev);
 	return 0;
 }
 

commit 05fcdcede016a74ce7350af94aede6a49eebd5c9
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:21:24 2012 -0700

    staging: comedi: addi_apci_2032: fix interrupt support
    
    This board supports two interrupt sources:
    
    VCC : detects when the external supply voltage drops below 5V
    CC  : over temperature diagnostic
    
    Currently the interrupt support is tied into the digital output
    subdevice. It's also broken since it does not follow the comedi
    API.
    
    Create a new digital input subdevice to handle the interrupts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 4fb380ad213c..8f8d3e95fc78 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -54,8 +54,6 @@
 #define APCI2032_WDOG_STATUS_ENABLED	(1 << 0)
 #define APCI2032_WDOG_STATUS_SW_TRIG	(1 << 1)
 
-static unsigned int ui_InterruptData, ui_Type;
-
 struct apci2032_private {
 	unsigned int wdog_ctrl;
 };
@@ -156,75 +154,106 @@ static int apci2032_wdog_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
-					  struct comedi_subdevice *s,
-					  struct comedi_insn *insn,
-					  unsigned int *data)
+static int apci2032_int_insn_bits(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
-	unsigned int ul_Command = 0;
+	data[1] = s->state;
+	return insn->n;
+}
 
-	if ((data[0] != 0) && (data[0] != 1)) {
-		comedi_error(dev,
-			"Not a valid Data !!! ,Data should be 1 or 0\n");
-		return -EINVAL;
-	}
+static int apci2032_int_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
+{
+	int err = 0;
 
-	if (data[1] == 1)
-		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
-	else
-		ul_Command &= ~APCI2032_INT_CTRL_VCC_ENA;
+	/* Step 1 : check if triggers are trivially valid */
 
-	if (data[2] == 1)
-		ul_Command |= APCI2032_INT_CTRL_CC_ENA;
-	else
-		ul_Command &= ~APCI2032_INT_CTRL_CC_ENA;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_OTHER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
-	outl(ul_Command, dev->iobase + APCI2032_INT_CTRL_REG);
-	ui_InterruptData = inl(dev->iobase + APCI2032_INT_CTRL_REG);
+	if (err)
+		return 1;
 
-	return insn->n;
+	/* Step 2a : make sure trigger sources are unique */
+	/* Step 2b : and mutually compatible */
+
+	if (err)
+		return 2;
+
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	/*
+	 * 0 == no trigger
+	 * 1 == trigger on VCC interrupt
+	 * 2 == trigger on CC interrupt
+	 * 3 == trigger on either VCC or CC interrupt
+	 */
+	err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg, 3);
+
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+
+	if (err)
+		return 3;
+
+	/* step 4: ignored */
+
+	if (err)
+		return 4;
+
+	return 0;
 }
 
-static int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev,
-					  struct comedi_subdevice *s,
-					  struct comedi_insn *insn,
-					  unsigned int *data)
+static int apci2032_int_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
-	*data = ui_Type;
-	return insn->n;
+	struct comedi_cmd *cmd = &s->async->cmd;
+
+	outl(cmd->scan_begin_arg, dev->iobase + APCI2032_INT_CTRL_REG);
+
+	return 0;
 }
 
-static void v_APCI2032_Interrupt(int irq, void *d)
+static int apci2032_int_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
-	struct comedi_device *dev = d;
-	unsigned int ui_DO;
+	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 
-	/* Check if VCC OR CC interrupt has occurred */
-	ui_DO = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;
-
-	if (ui_DO == 0) {
-		printk("\nInterrupt from unKnown source\n");
-	}			/*  if(ui_DO==0) */
-	if (ui_DO) {
-		/*  Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt. */
-		ui_Type = inl(dev->iobase + APCI2032_INT_STATUS_REG);
-		ui_Type &= (APCI2032_INT_STATUS_VCC | APCI2032_INT_STATUS_CC);
-		outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
-
-		if (ui_Type)
-			; /* send an event to indicate the interrupt */
-	}
+	return 0;
 }
 
-static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
+static irqreturn_t apci2032_interrupt(int irq, void *d)
 {
-	v_APCI2032_Interrupt(irq, d);
-	return IRQ_RETVAL(1);
+	struct comedi_device *dev = d;
+	struct comedi_subdevice *s = dev->read_subdev;
+	unsigned int val;
+
+	/* Check if VCC OR CC interrupt has occurred */
+	val = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;
+	if (!val)
+		return IRQ_NONE;
+
+	s->state = inl(dev->iobase + APCI2032_INT_STATUS_REG);
+	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
+
+	comedi_buf_put(s->async, s->state);
+	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	comedi_event(dev, s);
+
+	return IRQ_HANDLED;
 }
 
 static int apci2032_reset(struct comedi_device *dev)
 {
-	ui_Type = 0;
 	outl(0x0, dev->iobase + APCI2032_DO_REG);
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 	outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
@@ -254,13 +283,13 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	dev->iobase = pci_resource_start(pcidev, 1);
 
 	if (pcidev->irq > 0) {
-		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
-				  dev->board_name, dev);
+		ret = request_irq(pcidev->irq, apci2032_interrupt,
+				  IRQF_SHARED, dev->board_name, dev);
 		if (ret == 0)
 			dev->irq = pcidev->irq;
 	}
 
-	ret = comedi_alloc_subdevices(dev, 2);
+	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)
 		return ret;
 
@@ -271,9 +300,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s->n_chan	= 32;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_config	= i_APCI2032_ConfigDigitalOutput;
 	s->insn_bits	= apci2032_do_insn_bits;
-	s->insn_read	= i_APCI2032_ReadInterruptStatus;
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[1];
@@ -285,6 +312,23 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s->insn_read	= apci2032_wdog_insn_read;
 	s->insn_config	= apci2032_wdog_insn_config;
 
+	/* Initialize the interrupt subdevice */
+	s = &dev->subdevices[2];
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->type		= COMEDI_SUBD_DI | SDF_CMD_READ;
+		s->subdev_flags	= SDF_READABLE;
+		s->n_chan	= 1;
+		s->maxdata	= 1;
+		s->range_table	= &range_digital;
+		s->insn_bits	= apci2032_int_insn_bits;
+		s->do_cmdtest	= apci2032_int_cmdtest;
+		s->do_cmd	= apci2032_int_cmd;
+		s->cancel	= apci2032_int_cancel;
+	} else {
+		s->type		= COMEDI_SUBD_UNUSED;
+	}
+
 	apci2032_reset(dev);
 	return 0;
 }

commit b3b7dab7580982a7d0b55395a8b116808447f85a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:21:06 2012 -0700

    staging: comedi: addi_apci_2032: move i_APCI2032_ConfigDigitalOutput()
    
    For aesthetic reasons, move this function.
    
    This function has nothing to do with the digital outputs. It's used
    to enable the interrupt sources that the board can generate.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index da0c8ca05ea5..4fb380ad213c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -60,35 +60,6 @@ struct apci2032_private {
 	unsigned int wdog_ctrl;
 };
 
-static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
-					  struct comedi_subdevice *s,
-					  struct comedi_insn *insn,
-					  unsigned int *data)
-{
-	unsigned int ul_Command = 0;
-
-	if ((data[0] != 0) && (data[0] != 1)) {
-		comedi_error(dev,
-			"Not a valid Data !!! ,Data should be 1 or 0\n");
-		return -EINVAL;
-	}
-
-	if (data[1] == 1)
-		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
-	else
-		ul_Command &= ~APCI2032_INT_CTRL_VCC_ENA;
-
-	if (data[2] == 1)
-		ul_Command |= APCI2032_INT_CTRL_CC_ENA;
-	else
-		ul_Command &= ~APCI2032_INT_CTRL_CC_ENA;
-
-	outl(ul_Command, dev->iobase + APCI2032_INT_CTRL_REG);
-	ui_InterruptData = inl(dev->iobase + APCI2032_INT_CTRL_REG);
-
-	return insn->n;
-}
-
 static int apci2032_do_insn_bits(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn,
@@ -185,6 +156,35 @@ static int apci2032_wdog_insn_read(struct comedi_device *dev,
 	return insn->n;
 }
 
+static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data)
+{
+	unsigned int ul_Command = 0;
+
+	if ((data[0] != 0) && (data[0] != 1)) {
+		comedi_error(dev,
+			"Not a valid Data !!! ,Data should be 1 or 0\n");
+		return -EINVAL;
+	}
+
+	if (data[1] == 1)
+		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
+	else
+		ul_Command &= ~APCI2032_INT_CTRL_VCC_ENA;
+
+	if (data[2] == 1)
+		ul_Command |= APCI2032_INT_CTRL_CC_ENA;
+	else
+		ul_Command &= ~APCI2032_INT_CTRL_CC_ENA;
+
+	outl(ul_Command, dev->iobase + APCI2032_INT_CTRL_REG);
+	ui_InterruptData = inl(dev->iobase + APCI2032_INT_CTRL_REG);
+
+	return insn->n;
+}
+
 static int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
 					  struct comedi_insn *insn,

commit 7c7c42cdf6b1968da6588de97c4978ce602b5d34
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:20:50 2012 -0700

    staging: comedi: addi_apci_2032: remove the timer s->range_table
    
    The timer subdevice does not have a digital range. Its range of
    0 to 0xff is the value used to set the reload timer.
    
    Remove the setting of s->range_table. The comedi core will then
    set it to range_unknown.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index fded4806548f..da0c8ca05ea5 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -281,7 +281,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s->subdev_flags	= SDF_WRITEABLE;
 	s->n_chan	= 1;
 	s->maxdata	= 0xff;
-	s->range_table	= &range_digital;
 	s->insn_write	= apci2032_wdog_insn_write;
 	s->insn_read	= apci2032_wdog_insn_read;
 	s->insn_config	= apci2032_wdog_insn_config;

commit cf11088242f0f73cb616ab66fb16c2da3d626fff
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:20:35 2012 -0700

    staging: comedi: addi_apci_2032: cleanup the subdevice init
    
    For aesthetic reasons, add some whitespace to the subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 4cac92cff875..fded4806548f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -266,25 +266,25 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the digital output subdevice */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 32;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_config = i_APCI2032_ConfigDigitalOutput;
-	s->insn_bits = apci2032_do_insn_bits;
-	s->insn_read = i_APCI2032_ReadInterruptStatus;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 32;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_config	= i_APCI2032_ConfigDigitalOutput;
+	s->insn_bits	= apci2032_do_insn_bits;
+	s->insn_read	= i_APCI2032_ReadInterruptStatus;
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_TIMER;
-	s->subdev_flags = SDF_WRITEABLE;
-	s->n_chan = 1;
-	s->maxdata = 0xff;
-	s->range_table = &range_digital;
-	s->insn_write = apci2032_wdog_insn_write;
-	s->insn_read = apci2032_wdog_insn_read;
-	s->insn_config = apci2032_wdog_insn_config;
+	s->type		= COMEDI_SUBD_TIMER;
+	s->subdev_flags	= SDF_WRITEABLE;
+	s->n_chan	= 1;
+	s->maxdata	= 0xff;
+	s->range_table	= &range_digital;
+	s->insn_write	= apci2032_wdog_insn_write;
+	s->insn_read	= apci2032_wdog_insn_read;
+	s->insn_config	= apci2032_wdog_insn_config;
 
 	apci2032_reset(dev);
 	return 0;

commit 23fb174746057b6d13539735241390eb9e3fdb46
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:20:19 2012 -0700

    staging: comedi: addi_apci_2032: fix the watchdog timer subdevice
    
    The watchdog timer on this board functions exactly like the one on
    the apci_1516 board. Fix the i_APCI2032_StartStopWriteWatchdog and
    i_APCI2032_ConfigWatchdo functions so that the watchdog follows the
    comedi API.
    
    Rename the CamelCase function i_APCI2032_StartStopWriteWatchdog to
    apci2032_wdog_insn_writ. This function is used to "ping" the watchdog.
    
    Rename the CamelCase function i_APCI2032_ConfigWatchdog to
    apci2032_wdog_insn_config. This function is used to enable/disable
    the watchdog and set the timeout.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 9b1dee46c2b3..4cac92cff875 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -56,6 +56,10 @@
 
 static unsigned int ui_InterruptData, ui_Type;
 
+struct apci2032_private {
+	unsigned int wdog_ctrl;
+};
+
 static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
 					  struct comedi_subdevice *s,
 					  struct comedi_insn *insn,
@@ -106,47 +110,69 @@ static int apci2032_do_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int i_APCI2032_ConfigWatchdog(struct comedi_device *dev,
+/*
+ * The watchdog subdevice is configured with two INSN_CONFIG instructions:
+ *
+ * Enable the watchdog and set the reload timeout:
+ *	data[0] = INSN_CONFIG_ARM
+ *	data[1] = timeout reload value
+ *
+ * Disable the watchdog:
+ *	data[0] = INSN_CONFIG_DISARM
+ */
+static int apci2032_wdog_insn_config(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     struct comedi_insn *insn,
 				     unsigned int *data)
 {
-	if (data[0] == 0) {
-		/* Disable the watchdog */
-		outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
-		/* Loading the Reload value */
-		outl(data[1], dev->iobase + APCI2032_WDOG_RELOAD_REG);
-	} else {
-		printk("\nThe input parameters are wrong\n");
+	struct apci2032_private *devpriv = dev->private;
+	unsigned int reload;
+
+	switch (data[0]) {
+	case INSN_CONFIG_ARM:
+		devpriv->wdog_ctrl = APCI2032_WDOG_CTRL_ENABLE;
+		reload = data[1] & s->maxdata;
+		outw(reload, dev->iobase + APCI2032_WDOG_RELOAD_REG);
+
+		/* Time base is 20ms, let the user know the timeout */
+		dev_info(dev->class_dev, "watchdog enabled, timeout:%dms\n",
+			20 * reload + 20);
+		break;
+	case INSN_CONFIG_DISARM:
+		devpriv->wdog_ctrl = 0;
+		break;
+	default:
 		return -EINVAL;
 	}
 
+	outw(devpriv->wdog_ctrl, dev->iobase + APCI2032_WDOG_CTRL_REG);
+
 	return insn->n;
 }
 
-static int i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev,
-					     struct comedi_subdevice *s,
-					     struct comedi_insn *insn,
-					     unsigned int *data)
+static int apci2032_wdog_insn_write(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
-	switch (data[0]) {
-	case 0:		/* stop the watchdog */
-		outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
-		break;
-	case 1:		/* start the watchdog */
-		outl(0x0001, dev->iobase + APCI2032_WDOG_CTRL_REG);
-		break;
-	case 2:		/* Software trigger */
-		outl(0x0201, dev->iobase + APCI2032_WDOG_CTRL_REG);
-		break;
-	default:
-		printk("\nSpecified functionality does not exist\n");
+	struct apci2032_private *devpriv = dev->private;
+	int i;
+
+	if (devpriv->wdog_ctrl == 0) {
+		dev_warn(dev->class_dev, "watchdog is disabled\n");
 		return -EINVAL;
 	}
+
+	/* "ping" the watchdog */
+	for (i = 0; i < insn->n; i++) {
+		outw(devpriv->wdog_ctrl | APCI2032_WDOG_CTRL_SW_TRIG,
+			dev->iobase + APCI2032_WDOG_CTRL_REG);
+	}
+
 	return insn->n;
 }
 
-static int apci1516_wdog_insn_read(struct comedi_device *dev,
+static int apci2032_wdog_insn_read(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
@@ -211,11 +237,17 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct apci2032_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
 	dev->board_name = dev->driver->driver_name;
 
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
@@ -248,12 +280,11 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_TIMER;
 	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 1;
-	s->maxdata = 0;
-	s->len_chanlist = 1;
+	s->maxdata = 0xff;
 	s->range_table = &range_digital;
-	s->insn_write = i_APCI2032_StartStopWriteWatchdog;
-	s->insn_read = apci1516_wdog_insn_read;
-	s->insn_config = i_APCI2032_ConfigWatchdog;
+	s->insn_write = apci2032_wdog_insn_write;
+	s->insn_read = apci2032_wdog_insn_read;
+	s->insn_config = apci2032_wdog_insn_config;
 
 	apci2032_reset(dev);
 	return 0;

commit f82a66132b5df489a56e463b63769f8b27202265
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:20:04 2012 -0700

    staging: comedi: addi_apci_2032: remove need for addi-data/addi_common.h
    
    Only the ADDIDATA_ENABLE define is used from this header. Just
    open-code the value to remove the dependency and remove the include.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 46ab1da262a0..9b1dee46c2b3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -32,8 +32,6 @@
 #include "../comedidev.h"
 #include "comedi_fc.h"
 
-#include "addi-data/addi_common.h"
-
 /*
  * PCI bar 1 I/O Register map
  */
@@ -71,12 +69,12 @@ static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
 		return -EINVAL;
 	}
 
-	if (data[1] == ADDIDATA_ENABLE)
+	if (data[1] == 1)
 		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
 	else
 		ul_Command &= ~APCI2032_INT_CTRL_VCC_ENA;
 
-	if (data[2] == ADDIDATA_ENABLE)
+	if (data[2] == 1)
 		ul_Command |= APCI2032_INT_CTRL_CC_ENA;
 	else
 		ul_Command &= ~APCI2032_INT_CTRL_CC_ENA;

commit dce10abc499ec5e53ea01683fdb2181f24d6776d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:19:41 2012 -0700

    staging: comedi: addi_apci_2032: remove use of struct addi_private
    
    The only data in addi_private used in this driver is:
    
    tsk_Current - used with send_sig to signal userspace when an interrupt
    has occurred. Interrupt support in this driver does not follow the
    standard comedi API so this functionality is currently broken. This
    will be addressed.
    
    b_OutputMemoryStatus - used in the addi-data "common" code to enable
    reading of the eeprom. Eeprom support is not needed by this driver
    and has been removed.
    
    Since this data is not needed, remove the use of struct addi_private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 537e02999907..46ab1da262a0 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -63,22 +63,14 @@ static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
 					  struct comedi_insn *insn,
 					  unsigned int *data)
 {
-	struct addi_private *devpriv = dev->private;
 	unsigned int ul_Command = 0;
 
-	devpriv->tsk_Current = current;
-
 	if ((data[0] != 0) && (data[0] != 1)) {
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
 	}
 
-	if (data[0])
-		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	else
-		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
-
 	if (data[1] == ADDIDATA_ENABLE)
 		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
 	else
@@ -181,7 +173,6 @@ static int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev,
 static void v_APCI2032_Interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
-	struct addi_private *devpriv = dev->private;
 	unsigned int ui_DO;
 
 	/* Check if VCC OR CC interrupt has occurred */
@@ -197,7 +188,7 @@ static void v_APCI2032_Interrupt(int irq, void *d)
 		outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 
 		if (ui_Type)
-			send_sig(SIGIO, devpriv->tsk_Current, 0);
+			; /* send an event to indicate the interrupt */
 	}
 }
 
@@ -209,9 +200,6 @@ static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 
 static int apci2032_reset(struct comedi_device *dev)
 {
-	struct addi_private *devpriv = dev->private;
-
-	devpriv->b_DigitalOutputRegister = 0;
 	ui_Type = 0;
 	outl(0x0, dev->iobase + APCI2032_DO_REG);
 	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
@@ -225,17 +213,11 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
 	dev->board_name = dev->driver->driver_name;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
@@ -282,14 +264,11 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 static void apci2032_detach(struct comedi_device *dev)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	struct addi_private *devpriv = dev->private;
 
-	if (devpriv) {
-		if (dev->iobase)
-			apci2032_reset(dev);
-		if (dev->irq)
-			free_irq(dev->irq, dev);
-	}
+	if (dev->iobase)
+		apci2032_reset(dev);
+	if (dev->irq)
+		free_irq(dev->irq, dev);
 	if (pcidev) {
 		if (dev->iobase)
 			comedi_pci_disable(pcidev);

commit 7b5dd1cc988cf34341319c81bb0c7ddc21a2f8ee
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:19:25 2012 -0700

    staging: comedi: addi_apci_2032: fix i_APCI2032_ReadWatchdog()
    
    This function is used by the watchdog subdevice to read the status of
    the watchdog. Rename the CamelCase function to apci2032_wdog_insn_read
    and fix the function to return the status value insn->n times like
    the comedi core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index b77a84a48c0d..537e02999907 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -156,12 +156,16 @@ static int i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int i_APCI2032_ReadWatchdog(struct comedi_device *dev,
+static int apci1516_wdog_insn_read(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	data[0] = inl(dev->iobase + APCI2032_WDOG_STATUS_REG) & 0x1;
+	int i;
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = inl(dev->iobase + APCI2032_WDOG_STATUS_REG);
+
 	return insn->n;
 }
 
@@ -268,7 +272,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s->len_chanlist = 1;
 	s->range_table = &range_digital;
 	s->insn_write = i_APCI2032_StartStopWriteWatchdog;
-	s->insn_read = i_APCI2032_ReadWatchdog;
+	s->insn_read = apci1516_wdog_insn_read;
 	s->insn_config = i_APCI2032_ConfigWatchdog;
 
 	apci2032_reset(dev);

commit 7180eb30deee6c05b8924348a7ac7d4deefcf56e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:19:07 2012 -0700

    staging: comedi: addi_apci_2032: cleanup register map defines
    
    Cleanup the defines a bit and add the missing information for the
    bits in the registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 8c87a55485a6..b77a84a48c0d 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -37,23 +37,24 @@
 /*
  * PCI bar 1 I/O Register map
  */
-#define APCI2032_DIGITAL_OP				0
-#define APCI2032_DIGITAL_OP_RW				0
-#define APCI2032_DIGITAL_OP_INTERRUPT			4
-#define APCI2032_DIGITAL_OP_INTERRUPT_STATUS		8
-#define APCI2032_DIGITAL_OP_IRQ				12
-
-#define APCI2032_DIGITAL_OP_VCC_INTERRUPT_ENABLE	0x1
-#define APCI2032_DIGITAL_OP_VCC_INTERRUPT_DISABLE	0xfffffffe
-#define APCI2032_DIGITAL_OP_CC_INTERRUPT_ENABLE		0x2
-#define APCI2032_DIGITAL_OP_CC_INTERRUPT_DISABLE	0xfffffffd
-
-#define APCI2032_DIGITAL_OP_WATCHDOG			16
-#define APCI2032_TCW_RELOAD_VALUE			4
-#define APCI2032_TCW_TIMEBASE				8
-#define APCI2032_TCW_PROG				12
-#define APCI2032_TCW_TRIG_STATUS			16
-#define APCI2032_TCW_IRQ				20
+#define APCI2032_DO_REG			0x00
+#define APCI2032_INT_CTRL_REG		0x04
+#define APCI2032_INT_CTRL_VCC_ENA	(1 << 0)
+#define APCI2032_INT_CTRL_CC_ENA	(1 << 1)
+#define APCI2032_INT_STATUS_REG		0x08
+#define APCI2032_INT_STATUS_VCC		(1 << 0)
+#define APCI2032_INT_STATUS_CC		(1 << 1)
+#define APCI2032_STATUS_REG		0x0c
+#define APCI2032_STATUS_IRQ		(1 << 0)
+#define APCI2032_WDOG_REG		0x10
+#define APCI2032_WDOG_RELOAD_REG	0x14
+#define APCI2032_WDOG_TIMEBASE		0x18
+#define APCI2032_WDOG_CTRL_REG		0x1c
+#define APCI2032_WDOG_CTRL_ENABLE	(1 << 0)
+#define APCI2032_WDOG_CTRL_SW_TRIG	(1 << 9)
+#define APCI2032_WDOG_STATUS_REG	0x20
+#define APCI2032_WDOG_STATUS_ENABLED	(1 << 0)
+#define APCI2032_WDOG_STATUS_SW_TRIG	(1 << 1)
 
 static unsigned int ui_InterruptData, ui_Type;
 
@@ -71,28 +72,26 @@ static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			/* if  ( (data[0]!=0) && (data[0]!=1) ) */
-	if (data[0]) {
+	}
+
+	if (data[0])
 		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			/*  if  (data[0]) */
-	else {
+	else
 		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			/* else if  (data[0]) */
-
-	if (data[1] == ADDIDATA_ENABLE) {
-		ul_Command = ul_Command | 0x1;
-	}			/* if  (data[1] == ADDIDATA_ENABLE) */
-	else {
-		ul_Command = ul_Command & 0xFFFFFFFE;
-	}			/* elseif  (data[1] == ADDIDATA_ENABLE) */
-	if (data[2] == ADDIDATA_ENABLE) {
-		ul_Command = ul_Command | 0x2;
-	}			/* if  (data[2] == ADDIDATA_ENABLE) */
-	else {
-		ul_Command = ul_Command & 0xFFFFFFFD;
-	}			/* elseif  (data[2] == ADDIDATA_ENABLE) */
-	outl(ul_Command, dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
-	ui_InterruptData = inl(dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
+
+	if (data[1] == ADDIDATA_ENABLE)
+		ul_Command |= APCI2032_INT_CTRL_VCC_ENA;
+	else
+		ul_Command &= ~APCI2032_INT_CTRL_VCC_ENA;
+
+	if (data[2] == ADDIDATA_ENABLE)
+		ul_Command |= APCI2032_INT_CTRL_CC_ENA;
+	else
+		ul_Command &= ~APCI2032_INT_CTRL_CC_ENA;
+
+	outl(ul_Command, dev->iobase + APCI2032_INT_CTRL_REG);
+	ui_InterruptData = inl(dev->iobase + APCI2032_INT_CTRL_REG);
+
 	return insn->n;
 }
 
@@ -104,12 +103,12 @@ static int apci2032_do_insn_bits(struct comedi_device *dev,
 	unsigned int mask = data[0];
 	unsigned int bits = data[1];
 
-	s->state = inl(dev->iobase + APCI2032_DIGITAL_OP_RW);
+	s->state = inl(dev->iobase + APCI2032_DO_REG);
 	if (mask) {
 		s->state &= ~mask;
 		s->state |= (bits & mask);
 
-		outl(s->state, dev->iobase + APCI2032_DIGITAL_OP);
+		outl(s->state, dev->iobase + APCI2032_DO_REG);
 	}
 
 	data[1] = s->state;
@@ -124,13 +123,9 @@ static int i_APCI2032_ConfigWatchdog(struct comedi_device *dev,
 {
 	if (data[0] == 0) {
 		/* Disable the watchdog */
-		outl(0x0,
-			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
-			APCI2032_TCW_PROG);
+		outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
 		/* Loading the Reload value */
-		outl(data[1],
-			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
-			APCI2032_TCW_RELOAD_VALUE);
+		outl(data[1], dev->iobase + APCI2032_WDOG_RELOAD_REG);
 	} else {
 		printk("\nThe input parameters are wrong\n");
 		return -EINVAL;
@@ -146,17 +141,13 @@ static int i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev,
 {
 	switch (data[0]) {
 	case 0:		/* stop the watchdog */
-		outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	/* disable the watchdog */
+		outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
 		break;
 	case 1:		/* start the watchdog */
-		outl(0x0001,
-			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
-			APCI2032_TCW_PROG);
+		outl(0x0001, dev->iobase + APCI2032_WDOG_CTRL_REG);
 		break;
 	case 2:		/* Software trigger */
-		outl(0x0201,
-			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
-			APCI2032_TCW_PROG);
+		outl(0x0201, dev->iobase + APCI2032_WDOG_CTRL_REG);
 		break;
 	default:
 		printk("\nSpecified functionality does not exist\n");
@@ -170,9 +161,7 @@ static int i_APCI2032_ReadWatchdog(struct comedi_device *dev,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	data[0] =
-		inl(dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
-		APCI2032_TCW_TRIG_STATUS) & 0x1;
+	data[0] = inl(dev->iobase + APCI2032_WDOG_STATUS_REG) & 0x1;
 	return insn->n;
 }
 
@@ -184,39 +173,28 @@ static int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev,
 	*data = ui_Type;
 	return insn->n;
 }
+
 static void v_APCI2032_Interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct addi_private *devpriv = dev->private;
 	unsigned int ui_DO;
 
-	ui_DO = inl(dev->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	/* Check if VCC OR CC interrupt has occurred. */
+	/* Check if VCC OR CC interrupt has occurred */
+	ui_DO = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;
 
 	if (ui_DO == 0) {
 		printk("\nInterrupt from unKnown source\n");
 	}			/*  if(ui_DO==0) */
 	if (ui_DO) {
 		/*  Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt. */
-		ui_Type =
-			inl(dev->iobase +
-			APCI2032_DIGITAL_OP_INTERRUPT_STATUS) & 0x3;
-		outl(0x0,
-			dev->iobase + APCI2032_DIGITAL_OP +
-			APCI2032_DIGITAL_OP_INTERRUPT);
-		if (ui_Type == 1) {
-			/* Sends signal to user space */
-			send_sig(SIGIO, devpriv->tsk_Current, 0);
-		}		/*  if (ui_Type==1) */
-		else {
-			if (ui_Type == 2) {
-				/*  Sends signal to user space */
-				send_sig(SIGIO, devpriv->tsk_Current, 0);
-			}	/* if (ui_Type==2) */
-		}		/* else if (ui_Type==1) */
-	}			/* if(ui_DO) */
-
-	return;
+		ui_Type = inl(dev->iobase + APCI2032_INT_STATUS_REG);
+		ui_Type &= (APCI2032_INT_STATUS_VCC | APCI2032_INT_STATUS_CC);
+		outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
 
+		if (ui_Type)
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+	}
 }
 
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
@@ -231,10 +209,10 @@ static int apci2032_reset(struct comedi_device *dev)
 
 	devpriv->b_DigitalOutputRegister = 0;
 	ui_Type = 0;
-	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP);
-	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
-	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);
-	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);
+	outl(0x0, dev->iobase + APCI2032_DO_REG);
+	outl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);
+	outl(0x0, dev->iobase + APCI2032_WDOG_CTRL_REG);
+	outl(0x0, dev->iobase + APCI2032_WDOG_RELOAD_REG);
 
 	return 0;
 }

commit d02178b7fb1f2545ebe1004dc8f1f4436a9d37c1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:18:51 2012 -0700

    staging: comedi: addi_apci_2032: merge in hwdrv_apci2032.c
    
    Merge the code from hwdrv_apci2032.c into the driver and delete the
    now unused file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 26f6e0072ed0..8c87a55485a6 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,9 +1,223 @@
+/*
+ * addi_apci_2032.c
+ * Copyright (C) 2004,2005  ADDI-DATA GmbH for the source code of this module.
+ * Project manager: Eric Stolz
+ *
+ *	ADDI-DATA GmbH
+ *	Dieselstrasse 3
+ *	D-77833 Ottersweier
+ *	Tel: +19(0)7223/9493-0
+ *	Fax: +49(0)7223/9493-92
+ *	http://www.addi-data.com
+ *	info@addi-data.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * You should also find the complete GPL in the COPYING file accompanying
+ * this source code.
+ */
+
 #include "../comedidev.h"
 #include "comedi_fc.h"
 
 #include "addi-data/addi_common.h"
 
-#include "addi-data/hwdrv_apci2032.c"
+/*
+ * PCI bar 1 I/O Register map
+ */
+#define APCI2032_DIGITAL_OP				0
+#define APCI2032_DIGITAL_OP_RW				0
+#define APCI2032_DIGITAL_OP_INTERRUPT			4
+#define APCI2032_DIGITAL_OP_INTERRUPT_STATUS		8
+#define APCI2032_DIGITAL_OP_IRQ				12
+
+#define APCI2032_DIGITAL_OP_VCC_INTERRUPT_ENABLE	0x1
+#define APCI2032_DIGITAL_OP_VCC_INTERRUPT_DISABLE	0xfffffffe
+#define APCI2032_DIGITAL_OP_CC_INTERRUPT_ENABLE		0x2
+#define APCI2032_DIGITAL_OP_CC_INTERRUPT_DISABLE	0xfffffffd
+
+#define APCI2032_DIGITAL_OP_WATCHDOG			16
+#define APCI2032_TCW_RELOAD_VALUE			4
+#define APCI2032_TCW_TIMEBASE				8
+#define APCI2032_TCW_PROG				12
+#define APCI2032_TCW_TRIG_STATUS			16
+#define APCI2032_TCW_IRQ				20
+
+static unsigned int ui_InterruptData, ui_Type;
+
+static int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev,
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data)
+{
+	struct addi_private *devpriv = dev->private;
+	unsigned int ul_Command = 0;
+
+	devpriv->tsk_Current = current;
+
+	if ((data[0] != 0) && (data[0] != 1)) {
+		comedi_error(dev,
+			"Not a valid Data !!! ,Data should be 1 or 0\n");
+		return -EINVAL;
+	}			/* if  ( (data[0]!=0) && (data[0]!=1) ) */
+	if (data[0]) {
+		devpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;
+	}			/*  if  (data[0]) */
+	else {
+		devpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;
+	}			/* else if  (data[0]) */
+
+	if (data[1] == ADDIDATA_ENABLE) {
+		ul_Command = ul_Command | 0x1;
+	}			/* if  (data[1] == ADDIDATA_ENABLE) */
+	else {
+		ul_Command = ul_Command & 0xFFFFFFFE;
+	}			/* elseif  (data[1] == ADDIDATA_ENABLE) */
+	if (data[2] == ADDIDATA_ENABLE) {
+		ul_Command = ul_Command | 0x2;
+	}			/* if  (data[2] == ADDIDATA_ENABLE) */
+	else {
+		ul_Command = ul_Command & 0xFFFFFFFD;
+	}			/* elseif  (data[2] == ADDIDATA_ENABLE) */
+	outl(ul_Command, dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
+	ui_InterruptData = inl(dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
+	return insn->n;
+}
+
+static int apci2032_do_insn_bits(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
+
+	s->state = inl(dev->iobase + APCI2032_DIGITAL_OP_RW);
+	if (mask) {
+		s->state &= ~mask;
+		s->state |= (bits & mask);
+
+		outl(s->state, dev->iobase + APCI2032_DIGITAL_OP);
+	}
+
+	data[1] = s->state;
+
+	return insn->n;
+}
+
+static int i_APCI2032_ConfigWatchdog(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
+{
+	if (data[0] == 0) {
+		/* Disable the watchdog */
+		outl(0x0,
+			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
+			APCI2032_TCW_PROG);
+		/* Loading the Reload value */
+		outl(data[1],
+			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
+			APCI2032_TCW_RELOAD_VALUE);
+	} else {
+		printk("\nThe input parameters are wrong\n");
+		return -EINVAL;
+	}
+
+	return insn->n;
+}
+
+static int i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev,
+					     struct comedi_subdevice *s,
+					     struct comedi_insn *insn,
+					     unsigned int *data)
+{
+	switch (data[0]) {
+	case 0:		/* stop the watchdog */
+		outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);	/* disable the watchdog */
+		break;
+	case 1:		/* start the watchdog */
+		outl(0x0001,
+			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
+			APCI2032_TCW_PROG);
+		break;
+	case 2:		/* Software trigger */
+		outl(0x0201,
+			dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
+			APCI2032_TCW_PROG);
+		break;
+	default:
+		printk("\nSpecified functionality does not exist\n");
+		return -EINVAL;
+	}
+	return insn->n;
+}
+
+static int i_APCI2032_ReadWatchdog(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data)
+{
+	data[0] =
+		inl(dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG +
+		APCI2032_TCW_TRIG_STATUS) & 0x1;
+	return insn->n;
+}
+
+static int i_APCI2032_ReadInterruptStatus(struct comedi_device *dev,
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data)
+{
+	*data = ui_Type;
+	return insn->n;
+}
+static void v_APCI2032_Interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	struct addi_private *devpriv = dev->private;
+	unsigned int ui_DO;
+
+	ui_DO = inl(dev->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	/* Check if VCC OR CC interrupt has occurred. */
+
+	if (ui_DO == 0) {
+		printk("\nInterrupt from unKnown source\n");
+	}			/*  if(ui_DO==0) */
+	if (ui_DO) {
+		/*  Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt. */
+		ui_Type =
+			inl(dev->iobase +
+			APCI2032_DIGITAL_OP_INTERRUPT_STATUS) & 0x3;
+		outl(0x0,
+			dev->iobase + APCI2032_DIGITAL_OP +
+			APCI2032_DIGITAL_OP_INTERRUPT);
+		if (ui_Type == 1) {
+			/* Sends signal to user space */
+			send_sig(SIGIO, devpriv->tsk_Current, 0);
+		}		/*  if (ui_Type==1) */
+		else {
+			if (ui_Type == 2) {
+				/*  Sends signal to user space */
+				send_sig(SIGIO, devpriv->tsk_Current, 0);
+			}	/* if (ui_Type==2) */
+		}		/* else if (ui_Type==1) */
+	}			/* if(ui_DO) */
+
+	return;
+
+}
 
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {

commit 61034e002d8ad10d2265d33168d1dc721375869f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:18:35 2012 -0700

    staging: comedi: addi_apci_2032: cleanup the s->subdev_flags
    
    The flags SDF_GROUND and SDF_COMMON only have meaning for analog
    input/output subdevices. Remove these flags from the digital
    output and timer subdevices in this driver.
    
    The digital output subdevice does not need the SDF_READABLE flag.
    Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 93ff8300fed8..26f6e0072ed0 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -59,8 +59,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	/* Initialize the digital output subdevice */
 	s = &dev->subdevices[0];
 	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags =
-		SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 32;
 	s->maxdata = 1;
 	s->range_table = &range_digital;
@@ -71,7 +70,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[1];
 	s->type = COMEDI_SUBD_TIMER;
-	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+	s->subdev_flags = SDF_WRITEABLE;
 	s->n_chan = 1;
 	s->maxdata = 0;
 	s->len_chanlist = 1;

commit c0c3c7dfc1fd5c970b9893e68796314e8551124f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:18:19 2012 -0700

    staging: comedi: addi_apci_2032: remove boardinfo
    
    This driver only supports a single board type. Remove the boardinfo
    and just use the information directly where used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 84e6b4fa52d7..93ff8300fed8 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -5,30 +5,9 @@
 
 #include "addi-data/hwdrv_apci2032.c"
 
-static const struct addi_board apci2032_boardtypes[] = {
-	{
-		.pc_DriverName		= "apci2032",
-		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
-		.i_DeviceId		= 0x1004,
-		.i_NbrDoChannel		= 32,
-		.i_DoMaxdata		= 0xffffffff,
-		.i_Timer		= 1,
-		.interrupt		= v_APCI2032_Interrupt,
-		.do_config		= i_APCI2032_ConfigDigitalOutput,
-		.do_bits		= apci2032_do_insn_bits,
-		.do_read		= i_APCI2032_ReadInterruptStatus,
-		.timer_config		= i_APCI2032_ConfigWatchdog,
-		.timer_write		= i_APCI2032_StartStopWriteWatchdog,
-		.timer_read		= i_APCI2032_ReadWatchdog,
-	},
-};
-
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
-	struct comedi_device *dev = d;
-	const struct addi_board *this_board = comedi_board(dev);
-
-	this_board->interrupt(irq, d);
+	v_APCI2032_Interrupt(irq, d);
 	return IRQ_RETVAL(1);
 }
 
@@ -46,37 +25,15 @@ static int apci2032_reset(struct comedi_device *dev)
 	return 0;
 }
 
-static const void *addi_find_boardinfo(struct comedi_device *dev,
-				       struct pci_dev *pcidev)
-{
-	const void *p = dev->driver->board_name;
-	const struct addi_board *this_board;
-	int i;
-
-	for (i = 0; i < dev->driver->num_names; i++) {
-		this_board = p;
-		if (this_board->i_VendorId == pcidev->vendor &&
-		    this_board->i_DeviceId == pcidev->device)
-			return this_board;
-		p += dev->driver->offset;
-	}
-	return NULL;
-}
-
 static int apci2032_auto_attach(struct comedi_device *dev,
 				unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct addi_board *this_board;
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
 
-	this_board = addi_find_boardinfo(dev, pcidev);
-	if (!this_board)
-		return -ENODEV;
-	dev->board_ptr = this_board;
-	dev->board_name = this_board->pc_DriverName;
+	dev->board_name = dev->driver->driver_name;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -101,42 +58,27 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/* Initialize the digital output subdevice */
 	s = &dev->subdevices[0];
-	if (this_board->i_NbrDoChannel) {
-		s->type = COMEDI_SUBD_DO;
-		s->subdev_flags =
-			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = this_board->i_NbrDoChannel;
-		s->maxdata = this_board->i_DoMaxdata;
-		s->len_chanlist = this_board->i_NbrDoChannel;
-		s->range_table = &range_digital;
-		s->io_bits = 0xf;	/* all bits output */
-
-		/* insn_config - for digital output memory */
-		s->insn_config = this_board->do_config;
-		s->insn_write = this_board->do_write;
-		s->insn_bits = this_board->do_bits;
-		s->insn_read = this_board->do_read;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags =
+		SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan = 32;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_config = i_APCI2032_ConfigDigitalOutput;
+	s->insn_bits = apci2032_do_insn_bits;
+	s->insn_read = i_APCI2032_ReadInterruptStatus;
 
 	/* Initialize the watchdog subdevice */
 	s = &dev->subdevices[1];
-	if (this_board->i_Timer) {
-		s->type = COMEDI_SUBD_TIMER;
-		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = 1;
-		s->maxdata = 0;
-		s->len_chanlist = 1;
-		s->range_table = &range_digital;
-
-		s->insn_write = this_board->timer_write;
-		s->insn_read = this_board->timer_read;
-		s->insn_config = this_board->timer_config;
-		s->insn_bits = this_board->timer_bits;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_TIMER;
+	s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+	s->n_chan = 1;
+	s->maxdata = 0;
+	s->len_chanlist = 1;
+	s->range_table = &range_digital;
+	s->insn_write = i_APCI2032_StartStopWriteWatchdog;
+	s->insn_read = i_APCI2032_ReadWatchdog;
+	s->insn_config = i_APCI2032_ConfigWatchdog;
 
 	apci2032_reset(dev);
 	return 0;
@@ -164,9 +106,6 @@ static struct comedi_driver apci2032_driver = {
 	.module		= THIS_MODULE,
 	.auto_attach	= apci2032_auto_attach,
 	.detach		= apci2032_detach,
-	.num_names	= ARRAY_SIZE(apci2032_boardtypes),
-	.board_name	= &apci2032_boardtypes[0].pc_DriverName,
-	.offset		= sizeof(struct addi_board),
 };
 
 static int apci2032_pci_probe(struct pci_dev *dev,

commit 0c33bdd01abf1d6722792b2022b974116151a572
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:18:03 2012 -0700

    staging: comedi: addi_apci_2032: only allocate needed subdevices
    
    The addi-data "common" code always allocated 7 subdevices. This driver
    only requires 2. Change the allocation and remove the unused subdevices.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 9b0c402bed0f..84e6b4fa52d7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -70,7 +70,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	const struct addi_board *this_board;
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
-	int ret, n_subdevices;
+	int ret;
 
 	this_board = addi_find_boardinfo(dev, pcidev);
 	if (!this_board)
@@ -95,25 +95,12 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	n_subdevices = 7;
-	ret = comedi_alloc_subdevices(dev, n_subdevices);
+	ret = comedi_alloc_subdevices(dev, 2);
 	if (ret)
 		return ret;
 
-	/*  Allocate and Initialise AI Subdevice Structures */
+	/* Initialize the digital output subdevice */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/*  Allocate and Initialise AO Subdevice Structures */
-	s = &dev->subdevices[1];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/*  Allocate and Initialise DI Subdevice Structures */
-	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/*  Allocate and Initialise DO Subdevice Structures */
-	s = &dev->subdevices[3];
 	if (this_board->i_NbrDoChannel) {
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags =
@@ -133,8 +120,8 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  Allocate and Initialise Timer Subdevice Structures */
-	s = &dev->subdevices[4];
+	/* Initialize the watchdog subdevice */
+	s = &dev->subdevices[1];
 	if (this_board->i_Timer) {
 		s->type = COMEDI_SUBD_TIMER;
 		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
@@ -151,14 +138,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/*  Allocate and Initialise TTL */
-	s = &dev->subdevices[5];
-	s->type = COMEDI_SUBD_UNUSED;
-
-	/* EEPROM */
-	s = &dev->subdevices[6];
-	s->type = COMEDI_SUBD_UNUSED;
-
 	apci2032_reset(dev);
 	return 0;
 }

commit 490555966e77f7e3e8ccbe70629a149451b56a3c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:17:47 2012 -0700

    staging: comedi: addi_apci_2032: remove use of devpriv->s_EeParameters
    
    This driver no longer reads the eeprom to find the board specific data,
    all the necessary data is in the boardinfo. Use the boardinfo directly
    instead of passing through devpriv->s_EeParameters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 57c592532cbd..9b0c402bed0f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -88,23 +88,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 		return ret;
 	dev->iobase = pci_resource_start(pcidev, 1);
 
-	/* Initialize parameters that can be overridden in EEPROM */
-	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;
-	devpriv->s_EeParameters.i_NbrAoChannel = this_board->i_NbrAoChannel;
-	devpriv->s_EeParameters.i_AiMaxdata = this_board->i_AiMaxdata;
-	devpriv->s_EeParameters.i_AoMaxdata = this_board->i_AoMaxdata;
-	devpriv->s_EeParameters.i_NbrDiChannel = this_board->i_NbrDiChannel;
-	devpriv->s_EeParameters.i_NbrDoChannel = this_board->i_NbrDoChannel;
-	devpriv->s_EeParameters.i_DoMaxdata = this_board->i_DoMaxdata;
-	devpriv->s_EeParameters.i_Dma = this_board->i_Dma;
-	devpriv->s_EeParameters.i_Timer = this_board->i_Timer;
-	devpriv->s_EeParameters.ui_MinAcquisitiontimeNs =
-		this_board->ui_MinAcquisitiontimeNs;
-	devpriv->s_EeParameters.ui_MinDelaytimeNs =
-		this_board->ui_MinDelaytimeNs;
-
-	/* ## */
-
 	if (pcidev->irq > 0) {
 		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
 				  dev->board_name, dev);
@@ -131,14 +114,13 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[3];
-	if (devpriv->s_EeParameters.i_NbrDoChannel) {
+	if (this_board->i_NbrDoChannel) {
 		s->type = COMEDI_SUBD_DO;
 		s->subdev_flags =
 			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrDoChannel;
-		s->maxdata = devpriv->s_EeParameters.i_DoMaxdata;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrDoChannel;
+		s->n_chan = this_board->i_NbrDoChannel;
+		s->maxdata = this_board->i_DoMaxdata;
+		s->len_chanlist = this_board->i_NbrDoChannel;
 		s->range_table = &range_digital;
 		s->io_bits = 0xf;	/* all bits output */
 
@@ -153,7 +135,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise Timer Subdevice Structures */
 	s = &dev->subdevices[4];
-	if (devpriv->s_EeParameters.i_Timer) {
+	if (this_board->i_Timer) {
 		s->type = COMEDI_SUBD_TIMER;
 		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
 		s->n_chan = 1;

commit ff5eb17ef48738dcc3348d765134a915c9d5091d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:17:30 2012 -0700

    staging: comedi: addi_apci_2032: don't read the unused PCI bars
    
    This driver only uses PCI bar 1 (dev->iobase), doon't bother reading
    the unused PCI bars.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index c498a8c914a4..57c592532cbd 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -86,11 +86,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
-
 	dev->iobase = pci_resource_start(pcidev, 1);
-	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
-	devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
-	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);
 
 	/* Initialize parameters that can be overridden in EEPROM */
 	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;

commit f5f760e1d3bf641dacc64240a593267cab554a7a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:17:15 2012 -0700

    staging: comedi: addi_apci_2032: remove devpriv->iobase usage
    
    The iobase address stored in devpriv->iobase is also stored in dev->iobase.
    Use that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index aae04d402da4..c498a8c914a4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -38,10 +38,10 @@ static int apci2032_reset(struct comedi_device *dev)
 
 	devpriv->b_DigitalOutputRegister = 0;
 	ui_Type = 0;
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP);
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);
-	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);
+	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP);
+	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
+	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);
+	outl(0x0, dev->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);
 
 	return 0;
 }
@@ -88,7 +88,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	dev->iobase = pci_resource_start(pcidev, 1);
-	devpriv->iobase = dev->iobase;
 	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
 	devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
 	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);

commit dba18c58e0e116b7185277385e087041c52f2afd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:17:00 2012 -0700

    staging: comedi: addi_apci_2032: remove unnecessary info from boardinfo
    
    The i_IorangeBase[012], i_PCIEeprom, and pc_EepromChip data in the
    boardinfo was only needed to work out the usage of the PCI bars.
    This is no longer needed so remove the data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index e0b307cc41a4..aae04d402da4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -10,10 +10,6 @@ static const struct addi_board apci2032_boardtypes[] = {
 		.pc_DriverName		= "apci2032",
 		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
 		.i_DeviceId		= 0x1004,
-		.i_IorangeBase0		= 4,
-		.i_IorangeBase1		= APCI2032_ADDRESS_RANGE,
-		.i_PCIEeprom		= ADDIDATA_EEPROM,
-		.pc_EepromChip		= ADDIDATA_93C76,
 		.i_NbrDoChannel		= 32,
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,

commit 70ff406599a5debfa6e5ef243e5e093f63a9ed69
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:16:45 2012 -0700

    staging: comedi: addi_apci_2032: simplify the PCI bar reading
    
    The board supported by this driver has a 93c76 eeprom. Knowing this
    information allows simplifying the code that reads the PCI bars to
    get the iobase address.
    
    Also, since the 'dw_AiBase' is not ioremap'ed we can remove the iounmap
    in the detach.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 5e2cf0dec8cb..e0b307cc41a4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -91,24 +91,10 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	if (!this_board->pc_EepromChip ||
-	    strcmp(this_board->pc_EepromChip, ADDIDATA_9054)) {
-		/* board does not have an eeprom or is not ADDIDATA_9054 */
-		if (this_board->i_IorangeBase1)
-			dev->iobase = pci_resource_start(pcidev, 1);
-		else
-			dev->iobase = pci_resource_start(pcidev, 0);
-
-		devpriv->iobase = dev->iobase;
-		devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
-		devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
-	} else {
-		/* board has an ADDIDATA_9054 eeprom */
-		dev->iobase = pci_resource_start(pcidev, 2);
-		devpriv->iobase = pci_resource_start(pcidev, 2);
-		devpriv->dw_AiBase = ioremap(pci_resource_start(pcidev, 3),
-					     this_board->i_IorangeBase3);
-	}
+	dev->iobase = pci_resource_start(pcidev, 1);
+	devpriv->iobase = dev->iobase;
+	devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
+	devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
 	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);
 
 	/* Initialize parameters that can be overridden in EEPROM */
@@ -214,8 +200,6 @@ static void apci2032_detach(struct comedi_device *dev)
 			apci2032_reset(dev);
 		if (dev->irq)
 			free_irq(dev->irq, dev);
-		if (devpriv->dw_AiBase)
-			iounmap(devpriv->dw_AiBase);
 	}
 	if (pcidev) {
 		if (dev->iobase)

commit 791c9792ff2d12a02f0ab1c47fd7f7a94828b05b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:16:27 2012 -0700

    staging: comedi: addi_apci_2032: absorb i_APCI2032_Reset()
    
    This is the only 'reset' function used by the driver, remove it
    from the boardinfo and absorb the code from hwdrv_apci2032.c into
    the driver.
    
    Rename the CamelCase function i_ADDI_Reset() to apci2032_reset().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index bd79c28e385c..5e2cf0dec8cb 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -18,7 +18,6 @@ static const struct addi_board apci2032_boardtypes[] = {
 		.i_DoMaxdata		= 0xffffffff,
 		.i_Timer		= 1,
 		.interrupt		= v_APCI2032_Interrupt,
-		.reset			= i_APCI2032_Reset,
 		.do_config		= i_APCI2032_ConfigDigitalOutput,
 		.do_bits		= apci2032_do_insn_bits,
 		.do_read		= i_APCI2032_ReadInterruptStatus,
@@ -37,11 +36,17 @@ static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 	return IRQ_RETVAL(1);
 }
 
-static int i_ADDI_Reset(struct comedi_device *dev)
+static int apci2032_reset(struct comedi_device *dev)
 {
-	const struct addi_board *this_board = comedi_board(dev);
+	struct addi_private *devpriv = dev->private;
+
+	devpriv->b_DigitalOutputRegister = 0;
+	ui_Type = 0;
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP);
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);
+	outl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);
 
-	this_board->reset(dev);
 	return 0;
 }
 
@@ -195,7 +200,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[6];
 	s->type = COMEDI_SUBD_UNUSED;
 
-	i_ADDI_Reset(dev);
+	apci2032_reset(dev);
 	return 0;
 }
 
@@ -206,7 +211,7 @@ static void apci2032_detach(struct comedi_device *dev)
 
 	if (devpriv) {
 		if (dev->iobase)
-			i_ADDI_Reset(dev);
+			apci2032_reset(dev);
 		if (dev->irq)
 			free_irq(dev->irq, dev);
 		if (devpriv->dw_AiBase)

commit 6f92e11a24f413032495953f99cabcd57c53eacc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:16:10 2012 -0700

    staging: comedi: addi_apci_2032: remove unnecessary include
    
    This include is no longer needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index f9d90b593d31..bd79c28e385c 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,6 +1,5 @@
 #include "../comedidev.h"
 #include "comedi_fc.h"
-#include "amcc_s5933.h"
 
 #include "addi-data/addi_common.h"
 

commit 64b42f5e4aacb3a4df8da25237e68efc7c56a0e1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:15:45 2012 -0700

    staging: comedi: addi_apci_2032: remove eeprom support code
    
    Reading the eeprom on the board supported by this driver is not
    necessary. All the information required is in the boardinfo.
    
    Remove the eeprom support code since it's not really interesting
    or useful.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index cd50f663c1f7..f9d90b593d31 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -4,7 +4,6 @@
 
 #include "addi-data/addi_common.h"
 
-#include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
 
 static const struct addi_board apci2032_boardtypes[] = {
@@ -30,23 +29,6 @@ static const struct addi_board apci2032_boardtypes[] = {
 	},
 };
 
-static int i_ADDIDATA_InsnReadEeprom(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data)
-{
-	const struct addi_board *this_board = comedi_board(dev);
-	struct addi_private *devpriv = dev->private;
-	unsigned short w_Address = CR_CHAN(insn->chanspec);
-	unsigned short w_Data;
-
-	w_Data = addi_eeprom_readw(devpriv->i_IobaseAmcc,
-		this_board->pc_EepromChip, 2 * w_Address);
-	data[0] = w_Data;
-
-	return insn->n;
-}
-
 static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -89,7 +71,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	struct addi_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret, n_subdevices;
-	unsigned int dw_Dummy;
 
 	this_board = addi_find_boardinfo(dev, pcidev);
 	if (!this_board)
@@ -150,23 +131,6 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 			dev->irq = pcidev->irq;
 	}
 
-	/*  Read eepeom and fill addi_board Structure */
-
-	if (this_board->i_PCIEeprom) {
-		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
-			/*  Set 3 wait stait */
-			if (!(strcmp(dev->board_name, "apci035"))) {
-				outl(0x80808082, devpriv->i_IobaseAmcc + 0x60);
-			} else {
-				outl(0x83838383, devpriv->i_IobaseAmcc + 0x60);
-			}
-			/*  Enable the interrupt for the controller */
-			dw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);
-			outl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);
-		}
-		addi_eeprom_read_info(dev, pci_resource_start(pcidev, 0));
-	}
-
 	n_subdevices = 7;
 	ret = comedi_alloc_subdevices(dev, n_subdevices);
 	if (ret)
@@ -230,15 +194,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/* EEPROM */
 	s = &dev->subdevices[6];
-	if (this_board->i_PCIEeprom) {
-		s->type = COMEDI_SUBD_MEMORY;
-		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-		s->n_chan = 256;
-		s->maxdata = 0xffff;
-		s->insn_read = i_ADDIDATA_InsnReadEeprom;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
 
 	i_ADDI_Reset(dev);
 	return 0;

commit 3583c53bd5066e14364a246d6f119245134192ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:15:28 2012 -0700

    staging: comedi: addi_apci_2032: board does not have analog inputs
    
    The board supported by this driver does not have analog inputs. Remove
    the subdevice init for it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 96b3ccff8df8..cd50f663c1f7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -174,39 +174,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise AI Subdevice Structures */
 	s = &dev->subdevices[0];
-	if ((devpriv->s_EeParameters.i_NbrAiChannel)
-		|| (this_board->i_NbrAiChannelDiff)) {
-		dev->read_subdev = s;
-		s->type = COMEDI_SUBD_AI;
-		s->subdev_flags =
-			SDF_READABLE | SDF_COMMON | SDF_GROUND
-			| SDF_DIFF;
-		if (devpriv->s_EeParameters.i_NbrAiChannel) {
-			s->n_chan =
-				devpriv->s_EeParameters.i_NbrAiChannel;
-			devpriv->b_SingelDiff = 0;
-		} else {
-			s->n_chan = this_board->i_NbrAiChannelDiff;
-			devpriv->b_SingelDiff = 1;
-		}
-		s->maxdata = devpriv->s_EeParameters.i_AiMaxdata;
-		s->len_chanlist = this_board->i_AiChannelList;
-		s->range_table = this_board->pr_AiRangelist;
-
-		/* Set the initialisation flag */
-		devpriv->b_AiInitialisation = 1;
-
-		s->insn_config = this_board->ai_config;
-		s->insn_read = this_board->ai_read;
-		s->insn_write = this_board->ai_write;
-		s->insn_bits = this_board->ai_bits;
-		s->do_cmdtest = this_board->ai_cmdtest;
-		s->do_cmd = this_board->ai_cmd;
-		s->cancel = this_board->ai_cancel;
-
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
 
 	/*  Allocate and Initialise AO Subdevice Structures */
 	s = &dev->subdevices[1];

commit 977b6944aae619c218dd424498d4cfedabdda1d4
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:15:05 2012 -0700

    staging: comedi: addi_apci_2032: board does not have analog outputs
    
    The board supported by this driver does not have analog outputs. Remove
    the subdevice init for it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 9f44e7b68da3..96b3ccff8df8 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -210,19 +210,8 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise AO Subdevice Structures */
 	s = &dev->subdevices[1];
-	if (devpriv->s_EeParameters.i_NbrAoChannel) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrAoChannel;
-		s->maxdata = devpriv->s_EeParameters.i_AoMaxdata;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrAoChannel;
-		s->range_table = this_board->pr_AoRangelist;
-		s->insn_config = this_board->ao_config;
-		s->insn_write = this_board->ao_write;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
+
 	/*  Allocate and Initialise DI Subdevice Structures */
 	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_UNUSED;

commit 0cbbbbb9f7044175457962fcf4c14de8df82775b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:14:48 2012 -0700

    staging: comedi: addi_apci_2032: board does not have digital inputs
    
    The board supported by this driver does not have digital inputs. Remove
    the subdevice init for it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 451c390aab11..9f44e7b68da3 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -225,22 +225,8 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 	}
 	/*  Allocate and Initialise DI Subdevice Structures */
 	s = &dev->subdevices[2];
-	if (devpriv->s_EeParameters.i_NbrDiChannel) {
-		s->type = COMEDI_SUBD_DI;
-		s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = devpriv->s_EeParameters.i_NbrDiChannel;
-		s->maxdata = 1;
-		s->len_chanlist =
-			devpriv->s_EeParameters.i_NbrDiChannel;
-		s->range_table = &range_digital;
-		s->io_bits = 0;	/* all bits input */
-		s->insn_config = this_board->di_config;
-		s->insn_read = this_board->di_read;
-		s->insn_write = this_board->di_write;
-		s->insn_bits = this_board->di_bits;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
+
 	/*  Allocate and Initialise DO Subdevice Structures */
 	s = &dev->subdevices[3];
 	if (devpriv->s_EeParameters.i_NbrDoChannel) {

commit 84987a16cae8986b54efa51a6a86533ebb511a68
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:14:31 2012 -0700

    staging: comedi: addi_apci_2032: board does not have ttl i/o
    
    The board supported by this driver does not have ttl i/o. Remove the
    subdevice init for it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index d467ecf399e7..451c390aab11 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -4,10 +4,6 @@
 
 #include "addi-data/addi_common.h"
 
-#ifndef COMEDI_SUBD_TTLIO
-#define COMEDI_SUBD_TTLIO   11	/* Digital Input Output But TTL */
-#endif
-
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
 
@@ -287,22 +283,7 @@ static int apci2032_auto_attach(struct comedi_device *dev,
 
 	/*  Allocate and Initialise TTL */
 	s = &dev->subdevices[5];
-	if (this_board->i_NbrTTLChannel) {
-		s->type = COMEDI_SUBD_TTLIO;
-		s->subdev_flags =
-			SDF_WRITEABLE | SDF_READABLE | SDF_GROUND | SDF_COMMON;
-		s->n_chan = this_board->i_NbrTTLChannel;
-		s->maxdata = 1;
-		s->io_bits = 0;	/* all bits input */
-		s->len_chanlist = this_board->i_NbrTTLChannel;
-		s->range_table = &range_digital;
-		s->insn_config = this_board->ttl_config;
-		s->insn_bits = this_board->ttl_bits;
-		s->insn_read = this_board->ttl_read;
-		s->insn_write = this_board->ttl_write;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_UNUSED;
 
 	/* EEPROM */
 	s = &dev->subdevices[6];

commit 25adf2ccf68814fade52f70ed2888b65db1e5156
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Nov 29 18:14:13 2012 -0700

    staging: comedi: addi_apci_2032: separate from addi_common.c
    
    This driver is for a simple 32 channel digital output board. Using the
    addi-data "common" code introduces a lot of bloat.
    
    Copy the code in addi_common.c to this driver and remove the #include
    that caused addi_common.c to be compiled with this driver. This will
    allow removing the bloat.
    
    Rename the attach_pci and detach functions so they have namespace
    associated with this driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 459e90013ea7..d467ecf399e7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -4,9 +4,12 @@
 
 #include "addi-data/addi_common.h"
 
+#ifndef COMEDI_SUBD_TTLIO
+#define COMEDI_SUBD_TTLIO   11	/* Digital Input Output But TTL */
+#endif
+
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
-#include "addi-data/addi_common.c"
 
 static const struct addi_board apci2032_boardtypes[] = {
 	{
@@ -31,11 +34,316 @@ static const struct addi_board apci2032_boardtypes[] = {
 	},
 };
 
+static int i_ADDIDATA_InsnReadEeprom(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
+{
+	const struct addi_board *this_board = comedi_board(dev);
+	struct addi_private *devpriv = dev->private;
+	unsigned short w_Address = CR_CHAN(insn->chanspec);
+	unsigned short w_Data;
+
+	w_Data = addi_eeprom_readw(devpriv->i_IobaseAmcc,
+		this_board->pc_EepromChip, 2 * w_Address);
+	data[0] = w_Data;
+
+	return insn->n;
+}
+
+static irqreturn_t v_ADDI_Interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	const struct addi_board *this_board = comedi_board(dev);
+
+	this_board->interrupt(irq, d);
+	return IRQ_RETVAL(1);
+}
+
+static int i_ADDI_Reset(struct comedi_device *dev)
+{
+	const struct addi_board *this_board = comedi_board(dev);
+
+	this_board->reset(dev);
+	return 0;
+}
+
+static const void *addi_find_boardinfo(struct comedi_device *dev,
+				       struct pci_dev *pcidev)
+{
+	const void *p = dev->driver->board_name;
+	const struct addi_board *this_board;
+	int i;
+
+	for (i = 0; i < dev->driver->num_names; i++) {
+		this_board = p;
+		if (this_board->i_VendorId == pcidev->vendor &&
+		    this_board->i_DeviceId == pcidev->device)
+			return this_board;
+		p += dev->driver->offset;
+	}
+	return NULL;
+}
+
+static int apci2032_auto_attach(struct comedi_device *dev,
+				unsigned long context_unused)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	const struct addi_board *this_board;
+	struct addi_private *devpriv;
+	struct comedi_subdevice *s;
+	int ret, n_subdevices;
+	unsigned int dw_Dummy;
+
+	this_board = addi_find_boardinfo(dev, pcidev);
+	if (!this_board)
+		return -ENODEV;
+	dev->board_ptr = this_board;
+	dev->board_name = this_board->pc_DriverName;
+
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	ret = comedi_pci_enable(pcidev, dev->board_name);
+	if (ret)
+		return ret;
+
+	if (!this_board->pc_EepromChip ||
+	    strcmp(this_board->pc_EepromChip, ADDIDATA_9054)) {
+		/* board does not have an eeprom or is not ADDIDATA_9054 */
+		if (this_board->i_IorangeBase1)
+			dev->iobase = pci_resource_start(pcidev, 1);
+		else
+			dev->iobase = pci_resource_start(pcidev, 0);
+
+		devpriv->iobase = dev->iobase;
+		devpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);
+		devpriv->i_IobaseAddon = pci_resource_start(pcidev, 2);
+	} else {
+		/* board has an ADDIDATA_9054 eeprom */
+		dev->iobase = pci_resource_start(pcidev, 2);
+		devpriv->iobase = pci_resource_start(pcidev, 2);
+		devpriv->dw_AiBase = ioremap(pci_resource_start(pcidev, 3),
+					     this_board->i_IorangeBase3);
+	}
+	devpriv->i_IobaseReserved = pci_resource_start(pcidev, 3);
+
+	/* Initialize parameters that can be overridden in EEPROM */
+	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;
+	devpriv->s_EeParameters.i_NbrAoChannel = this_board->i_NbrAoChannel;
+	devpriv->s_EeParameters.i_AiMaxdata = this_board->i_AiMaxdata;
+	devpriv->s_EeParameters.i_AoMaxdata = this_board->i_AoMaxdata;
+	devpriv->s_EeParameters.i_NbrDiChannel = this_board->i_NbrDiChannel;
+	devpriv->s_EeParameters.i_NbrDoChannel = this_board->i_NbrDoChannel;
+	devpriv->s_EeParameters.i_DoMaxdata = this_board->i_DoMaxdata;
+	devpriv->s_EeParameters.i_Dma = this_board->i_Dma;
+	devpriv->s_EeParameters.i_Timer = this_board->i_Timer;
+	devpriv->s_EeParameters.ui_MinAcquisitiontimeNs =
+		this_board->ui_MinAcquisitiontimeNs;
+	devpriv->s_EeParameters.ui_MinDelaytimeNs =
+		this_board->ui_MinDelaytimeNs;
+
+	/* ## */
+
+	if (pcidev->irq > 0) {
+		ret = request_irq(pcidev->irq, v_ADDI_Interrupt, IRQF_SHARED,
+				  dev->board_name, dev);
+		if (ret == 0)
+			dev->irq = pcidev->irq;
+	}
+
+	/*  Read eepeom and fill addi_board Structure */
+
+	if (this_board->i_PCIEeprom) {
+		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
+			/*  Set 3 wait stait */
+			if (!(strcmp(dev->board_name, "apci035"))) {
+				outl(0x80808082, devpriv->i_IobaseAmcc + 0x60);
+			} else {
+				outl(0x83838383, devpriv->i_IobaseAmcc + 0x60);
+			}
+			/*  Enable the interrupt for the controller */
+			dw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);
+			outl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);
+		}
+		addi_eeprom_read_info(dev, pci_resource_start(pcidev, 0));
+	}
+
+	n_subdevices = 7;
+	ret = comedi_alloc_subdevices(dev, n_subdevices);
+	if (ret)
+		return ret;
+
+	/*  Allocate and Initialise AI Subdevice Structures */
+	s = &dev->subdevices[0];
+	if ((devpriv->s_EeParameters.i_NbrAiChannel)
+		|| (this_board->i_NbrAiChannelDiff)) {
+		dev->read_subdev = s;
+		s->type = COMEDI_SUBD_AI;
+		s->subdev_flags =
+			SDF_READABLE | SDF_COMMON | SDF_GROUND
+			| SDF_DIFF;
+		if (devpriv->s_EeParameters.i_NbrAiChannel) {
+			s->n_chan =
+				devpriv->s_EeParameters.i_NbrAiChannel;
+			devpriv->b_SingelDiff = 0;
+		} else {
+			s->n_chan = this_board->i_NbrAiChannelDiff;
+			devpriv->b_SingelDiff = 1;
+		}
+		s->maxdata = devpriv->s_EeParameters.i_AiMaxdata;
+		s->len_chanlist = this_board->i_AiChannelList;
+		s->range_table = this_board->pr_AiRangelist;
+
+		/* Set the initialisation flag */
+		devpriv->b_AiInitialisation = 1;
+
+		s->insn_config = this_board->ai_config;
+		s->insn_read = this_board->ai_read;
+		s->insn_write = this_board->ai_write;
+		s->insn_bits = this_board->ai_bits;
+		s->do_cmdtest = this_board->ai_cmdtest;
+		s->do_cmd = this_board->ai_cmd;
+		s->cancel = this_board->ai_cancel;
+
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise AO Subdevice Structures */
+	s = &dev->subdevices[1];
+	if (devpriv->s_EeParameters.i_NbrAoChannel) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrAoChannel;
+		s->maxdata = devpriv->s_EeParameters.i_AoMaxdata;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrAoChannel;
+		s->range_table = this_board->pr_AoRangelist;
+		s->insn_config = this_board->ao_config;
+		s->insn_write = this_board->ao_write;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	/*  Allocate and Initialise DI Subdevice Structures */
+	s = &dev->subdevices[2];
+	if (devpriv->s_EeParameters.i_NbrDiChannel) {
+		s->type = COMEDI_SUBD_DI;
+		s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrDiChannel;
+		s->maxdata = 1;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrDiChannel;
+		s->range_table = &range_digital;
+		s->io_bits = 0;	/* all bits input */
+		s->insn_config = this_board->di_config;
+		s->insn_read = this_board->di_read;
+		s->insn_write = this_board->di_write;
+		s->insn_bits = this_board->di_bits;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+	/*  Allocate and Initialise DO Subdevice Structures */
+	s = &dev->subdevices[3];
+	if (devpriv->s_EeParameters.i_NbrDoChannel) {
+		s->type = COMEDI_SUBD_DO;
+		s->subdev_flags =
+			SDF_READABLE | SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = devpriv->s_EeParameters.i_NbrDoChannel;
+		s->maxdata = devpriv->s_EeParameters.i_DoMaxdata;
+		s->len_chanlist =
+			devpriv->s_EeParameters.i_NbrDoChannel;
+		s->range_table = &range_digital;
+		s->io_bits = 0xf;	/* all bits output */
+
+		/* insn_config - for digital output memory */
+		s->insn_config = this_board->do_config;
+		s->insn_write = this_board->do_write;
+		s->insn_bits = this_board->do_bits;
+		s->insn_read = this_board->do_read;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise Timer Subdevice Structures */
+	s = &dev->subdevices[4];
+	if (devpriv->s_EeParameters.i_Timer) {
+		s->type = COMEDI_SUBD_TIMER;
+		s->subdev_flags = SDF_WRITEABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = 1;
+		s->maxdata = 0;
+		s->len_chanlist = 1;
+		s->range_table = &range_digital;
+
+		s->insn_write = this_board->timer_write;
+		s->insn_read = this_board->timer_read;
+		s->insn_config = this_board->timer_config;
+		s->insn_bits = this_board->timer_bits;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/*  Allocate and Initialise TTL */
+	s = &dev->subdevices[5];
+	if (this_board->i_NbrTTLChannel) {
+		s->type = COMEDI_SUBD_TTLIO;
+		s->subdev_flags =
+			SDF_WRITEABLE | SDF_READABLE | SDF_GROUND | SDF_COMMON;
+		s->n_chan = this_board->i_NbrTTLChannel;
+		s->maxdata = 1;
+		s->io_bits = 0;	/* all bits input */
+		s->len_chanlist = this_board->i_NbrTTLChannel;
+		s->range_table = &range_digital;
+		s->insn_config = this_board->ttl_config;
+		s->insn_bits = this_board->ttl_bits;
+		s->insn_read = this_board->ttl_read;
+		s->insn_write = this_board->ttl_write;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* EEPROM */
+	s = &dev->subdevices[6];
+	if (this_board->i_PCIEeprom) {
+		s->type = COMEDI_SUBD_MEMORY;
+		s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+		s->n_chan = 256;
+		s->maxdata = 0xffff;
+		s->insn_read = i_ADDIDATA_InsnReadEeprom;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	i_ADDI_Reset(dev);
+	return 0;
+}
+
+static void apci2032_detach(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	struct addi_private *devpriv = dev->private;
+
+	if (devpriv) {
+		if (dev->iobase)
+			i_ADDI_Reset(dev);
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+		if (devpriv->dw_AiBase)
+			iounmap(devpriv->dw_AiBase);
+	}
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+	}
+}
+
 static struct comedi_driver apci2032_driver = {
 	.driver_name	= "addi_apci_2032",
 	.module		= THIS_MODULE,
-	.auto_attach	= addi_auto_attach,
-	.detach		= i_ADDI_Detach,
+	.auto_attach	= apci2032_auto_attach,
+	.detach		= apci2032_detach,
 	.num_names	= ARRAY_SIZE(apci2032_boardtypes),
 	.board_name	= &apci2032_boardtypes[0].pc_DriverName,
 	.offset		= sizeof(struct addi_board),

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index f60720546e32..459e90013ea7 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -47,7 +47,7 @@ static int apci2032_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &apci2032_driver);
 }
 
-static void __devexit apci2032_pci_remove(struct pci_dev *dev)
+static void apci2032_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index a80bf018b762..f60720546e32 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -41,7 +41,7 @@ static struct comedi_driver apci2032_driver = {
 	.offset		= sizeof(struct addi_board),
 };
 
-static int __devinit apci2032_pci_probe(struct pci_dev *dev,
+static int apci2032_pci_probe(struct pci_dev *dev,
 					const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &apci2032_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 7758de3146e9..a80bf018b762 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -62,7 +62,7 @@ static struct pci_driver apci2032_pci_driver = {
 	.name		= "addi_apci_2032",
 	.id_table	= apci2032_pci_table,
 	.probe		= apci2032_pci_probe,
-	.remove		= __devexit_p(apci2032_pci_remove),
+	.remove		= apci2032_pci_remove,
 };
 module_comedi_pci_driver(apci2032_driver, apci2032_pci_driver);
 

commit 92cba8f3b42e1cb8211b64e91618102ecc8f0a6d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 6 11:16:42 2012 -0700

    staging: comedi: addi-data: use auto_attach instead of attach_pci
    
    Change the addi-data drivers that use the "common" code so they
    attach using the generic 'auto_attach' method instead the pci
    specific 'attach_pci' method. The 'attach_pci' is deprecated and
    is going to be removed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 9766c240d809..7758de3146e9 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -34,7 +34,7 @@ static const struct addi_board apci2032_boardtypes[] = {
 static struct comedi_driver apci2032_driver = {
 	.driver_name	= "addi_apci_2032",
 	.module		= THIS_MODULE,
-	.attach_pci	= addi_attach_pci,
+	.auto_attach	= addi_auto_attach,
 	.detach		= i_ADDI_Detach,
 	.num_names	= ARRAY_SIZE(apci2032_boardtypes),
 	.board_name	= &apci2032_boardtypes[0].pc_DriverName,

commit 06bd743ff823e47da504a4a322e7a0dd02a11197
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 6 10:08:07 2012 -0700

    staging: comedi: addi_apci_2032: fix digital output 'insn_bits' function
    
    This driver does not follow the comedi API. The digital output 'insn_bits'
    function is passed a mask value in data[0] indicating which output bits in
    data[1] are changing. The function is then supposed to update the outputs
    accordingly and then return the current state of the outputs in data[1].
    
    Currently this driver uses the 'insn_write' function to update either a
    single or all the output channels. And it uses the 'insn_bits' function
    to read either a single or all the output channel states.
    
    Fix the 'insn_bits' function so it works like the comedi core expects. The
    core can then use the function to emulate the 'insn_read' and 'insn_write'
    functions for individual channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 92650480cd3a..9766c240d809 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -23,8 +23,7 @@ static const struct addi_board apci2032_boardtypes[] = {
 		.interrupt		= v_APCI2032_Interrupt,
 		.reset			= i_APCI2032_Reset,
 		.do_config		= i_APCI2032_ConfigDigitalOutput,
-		.do_write		= i_APCI2032_WriteDigitalOutput,
-		.do_bits		= i_APCI2032_ReadDigitalOutput,
+		.do_bits		= apci2032_do_insn_bits,
 		.do_read		= i_APCI2032_ReadInterruptStatus,
 		.timer_config		= i_APCI2032_ConfigWatchdog,
 		.timer_write		= i_APCI2032_StartStopWriteWatchdog,

commit bf36f012c7ddaff083bb0ef187feddf4d85507a0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 31 16:58:40 2012 -0700

    staging: comedi: addi-data: remove addi_amcc_s5933.h
    
    Now that the PCI bus walking has been removed from the addi-data
    drivers, the only differenced between addi_amcc_s9533.h and the
    standard comedi amcc_s5933.h is the additional defines for the
    apci3120 "ADDON RELATED ADDITIONS". Move those defines to
    hwdrv_apci3120.c.
    
    Modify all the addi-data drivers to then include the standard
    comedi amcc_s5933.h header and delete the duplicate in addi-data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index fd415248fb27..92650480cd3a 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,8 +1,8 @@
 #include "../comedidev.h"
 #include "comedi_fc.h"
+#include "amcc_s5933.h"
 
 #include "addi-data/addi_common.h"
-#include "addi-data/addi_amcc_s5933.h"
 
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"

commit 41be28db534330192bbbec9783e6d43d4432a7fb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 31 16:57:37 2012 -0700

    staging: comedi: addi-data: use attach_pci callback
    
    Use the comedi pci auto config mechanism to attach the addi-data
    drivers. This allows removing all the PCI bus walking code.
    
    Add a function, addi_find_boardinfo(), to find the driver specific
    boardinfo. Since this function is currently in the common code we
    have to use the pointer to the boardinfo that is stored in the
    comedi_driver pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 32214198a902..fd415248fb27 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -35,7 +35,7 @@ static const struct addi_board apci2032_boardtypes[] = {
 static struct comedi_driver apci2032_driver = {
 	.driver_name	= "addi_apci_2032",
 	.module		= THIS_MODULE,
-	.attach		= i_ADDI_Attach,
+	.attach_pci	= addi_attach_pci,
 	.detach		= i_ADDI_Detach,
 	.num_names	= ARRAY_SIZE(apci2032_boardtypes),
 	.board_name	= &apci2032_boardtypes[0].pc_DriverName,

commit 20a22b706b8ee37d1a2282f2c9bf7f2c73a5a7a5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 30 18:06:33 2012 -0700

    staging: comedi: addi_apci_*: add module_comedi_pci_driver()
    
    Pull the module init code out of addi_common.c and add it to
    each addi-data driver. Rename the data and functions so they
    have namespace associated with the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index b587bbca062b..32214198a902 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -4,12 +4,11 @@
 #include "addi-data/addi_common.h"
 #include "addi-data/addi_amcc_s5933.h"
 
-#define ADDIDATA_DRIVER_NAME	"addi_apci_2032"
-
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
+#include "addi-data/addi_common.c"
 
-static const struct addi_board boardtypes[] = {
+static const struct addi_board apci2032_boardtypes[] = {
 	{
 		.pc_DriverName		= "apci2032",
 		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
@@ -33,13 +32,40 @@ static const struct addi_board boardtypes[] = {
 	},
 };
 
-static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
+static struct comedi_driver apci2032_driver = {
+	.driver_name	= "addi_apci_2032",
+	.module		= THIS_MODULE,
+	.attach		= i_ADDI_Attach,
+	.detach		= i_ADDI_Detach,
+	.num_names	= ARRAY_SIZE(apci2032_boardtypes),
+	.board_name	= &apci2032_boardtypes[0].pc_DriverName,
+	.offset		= sizeof(struct addi_board),
+};
+
+static int __devinit apci2032_pci_probe(struct pci_dev *dev,
+					const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, &apci2032_driver);
+}
+
+static void __devexit apci2032_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(apci2032_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },
 	{ 0 }
 };
-MODULE_DEVICE_TABLE(pci, addi_apci_tbl);
+MODULE_DEVICE_TABLE(pci, apci2032_pci_table);
 
-#include "addi-data/addi_common.c"
+static struct pci_driver apci2032_pci_driver = {
+	.name		= "addi_apci_2032",
+	.id_table	= apci2032_pci_table,
+	.probe		= apci2032_pci_probe,
+	.remove		= __devexit_p(apci2032_pci_remove),
+};
+module_comedi_pci_driver(apci2032_driver, apci2032_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit c33ef61ff9f731efa4a630a9566a4cdf8945f4af
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 30 18:06:13 2012 -0700

    staging: comedi: addi_apci_*: remove unneeded CONFIG_APCI_* defines
    
    These defines were needed for the #ifdef'ery that used to exist
    in addi_common.c. Since that has been removed these are no longer
    used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 8dddb65f13bd..b587bbca062b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -4,8 +4,6 @@
 #include "addi-data/addi_common.h"
 #include "addi-data/addi_amcc_s5933.h"
 
-#define CONFIG_APCI_2032 1
-
 #define ADDIDATA_DRIVER_NAME	"addi_apci_2032"
 
 #include "addi-data/addi_eeprom.c"

commit c0a053b8b24d72413a82a16a41f635e6040ccf34
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:36 2012 -0700

    staging: comedi: addi-data: remove the boardinfo #ifdef'ery
    
    Move the boardinfo for each addi-data driver from addi_common.c to
    the individual driver files. This removes the need #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index bc86d66df19f..8dddb65f13bd 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -11,6 +11,30 @@
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
 
+static const struct addi_board boardtypes[] = {
+	{
+		.pc_DriverName		= "apci2032",
+		.i_VendorId		= PCI_VENDOR_ID_ADDIDATA,
+		.i_DeviceId		= 0x1004,
+		.i_IorangeBase0		= 4,
+		.i_IorangeBase1		= APCI2032_ADDRESS_RANGE,
+		.i_PCIEeprom		= ADDIDATA_EEPROM,
+		.pc_EepromChip		= ADDIDATA_93C76,
+		.i_NbrDoChannel		= 32,
+		.i_DoMaxdata		= 0xffffffff,
+		.i_Timer		= 1,
+		.interrupt		= v_APCI2032_Interrupt,
+		.reset			= i_APCI2032_Reset,
+		.do_config		= i_APCI2032_ConfigDigitalOutput,
+		.do_write		= i_APCI2032_WriteDigitalOutput,
+		.do_bits		= i_APCI2032_ReadDigitalOutput,
+		.do_read		= i_APCI2032_ReadInterruptStatus,
+		.timer_config		= i_APCI2032_ConfigWatchdog,
+		.timer_write		= i_APCI2032_StartStopWriteWatchdog,
+		.timer_read		= i_APCI2032_ReadWatchdog,
+	},
+};
+
 static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },
 	{ 0 }

commit 317285d71acccbda2fbab7e53d6b33c52a151a32
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:20 2012 -0700

    staging: comedi: addi-data: remove the MODULE_DEVICE_TABLE #ifdef'ery
    
    Move the MODULE_DEVICE_TABLE for each addi-data driver from addi_common.c
    to the individual driver files. This removes the need #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 7733758b756f..bc86d66df19f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -10,6 +10,13 @@
 
 #include "addi-data/addi_eeprom.c"
 #include "addi-data/hwdrv_apci2032.c"
+
+static DEFINE_PCI_DEVICE_TABLE(addi_apci_tbl) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE(pci, addi_apci_tbl);
+
 #include "addi-data/addi_common.c"
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit bf6a1578c10a4f3ef94a3c744267f18f9c3642bd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:52:03 2012 -0700

    staging: comedi: addi-data: remove the addi-data #include ifdef'ery
    
    Move the addi-data specific #include's from addi_common.h to the
    individual driver files.
    
    The apci-1710, apci-3200, and apci-3300 drivers still have floating
    point code in them and are currently disabled in the Kconfig and
    Makefile. For now, move the fpu_{begin,end} functions from addi_common.c
    to the main driver file so we can get rid of the #ifdef'ery.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 07446d5d82c0..7733758b756f 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -8,6 +8,8 @@
 
 #define ADDIDATA_DRIVER_NAME	"addi_apci_2032"
 
+#include "addi-data/addi_eeprom.c"
+#include "addi-data/hwdrv_apci2032.c"
 #include "addi-data/addi_common.c"
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit 3d41c44370a9a1e78e53c9997289347ec97d46ee
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 29 16:51:33 2012 -0700

    staging: comedi: addi-data: move the main #include's to the drivers
    
    The addi-data drivers are all built by the main driver files including
    addi-data/addi_common.c. That file then includes other files depending
    on what driver is being compiled. This is makes the code quite messy
    and hard to follow.
    
    Start cleaning it up by removing the unneeded #include's in addi_common.c
    and moving the some of the comedi #include's into the individual driver
    files.
    
    This is the first step in getting rid of the #ifdef'ery in addi_common.c.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 073a8a56dbe4..07446d5d82c0 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,3 +1,9 @@
+#include "../comedidev.h"
+#include "comedi_fc.h"
+
+#include "addi-data/addi_common.h"
+#include "addi-data/addi_amcc_s5933.h"
+
 #define CONFIG_APCI_2032 1
 
 #define ADDIDATA_DRIVER_NAME	"addi_apci_2032"

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index f67da94119e8..073a8a56dbe4 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -3,3 +3,7 @@
 #define ADDIDATA_DRIVER_NAME	"addi_apci_2032"
 
 #include "addi-data/addi_common.c"
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 6d8b0f5be5108f6a3fc922ca4acfbf10e14d6cd0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 15:11:57 2010 +0100

    Staging: comedi: Give the addi_apci_* drivers different driver names
    
    It is not currently possible for more than one of the addi_apci_*
    drivers to register themselves with comedi at once because they all use
    the same comedi driver name "addi_common".  Give them different names.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
index 5108ea2a3924..f67da94119e8 100644
--- a/drivers/staging/comedi/drivers/addi_apci_2032.c
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -1,3 +1,5 @@
 #define CONFIG_APCI_2032 1
 
+#define ADDIDATA_DRIVER_NAME	"addi_apci_2032"
+
 #include "addi-data/addi_common.c"

commit c995fe9475e062bab6f5a45ed28cd2d3d955ef43
Author: ADDI-DATA GmbH <info@addi-data.com>
Date:   Thu Feb 12 15:14:18 2009 -0800

    Staging: comedi: add addi-data drivers
    
    This adds the addi-data family of comedi drivers to the staging tree
    
    From: ADDI-DATA GmbH <info@addi-data.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/addi_apci_2032.c b/drivers/staging/comedi/drivers/addi_apci_2032.c
new file mode 100644
index 000000000000..5108ea2a3924
--- /dev/null
+++ b/drivers/staging/comedi/drivers/addi_apci_2032.c
@@ -0,0 +1,3 @@
+#define CONFIG_APCI_2032 1
+
+#include "addi-data/addi_common.c"
