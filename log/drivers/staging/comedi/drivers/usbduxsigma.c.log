commit d247ceda6ae65968bda1bf7a26b54a257a414c7a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Aug 15 11:53:14 2019 +0100

    staging: comedi: usbduxsigma: remove redundant assignment to variable fx2delay
    
    Variable fx2delay is being initialized with a value that is never read
    and fx2delay is being re-assigned a little later on. The assignment is
    redundant and hence can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20190815105314.5756-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 3cc40d2544be..54d7605e909f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1074,7 +1074,7 @@ static int usbduxsigma_pwm_period(struct comedi_device *dev,
 				  unsigned int period)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
-	int fx2delay = 255;
+	int fx2delay;
 
 	if (period < MIN_PWM_PERIOD)
 		return -EAGAIN;

commit 2cd0869672426171541330ecd7a39761a40b06a6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Apr 17 16:55:12 2019 +0100

    staging: comedi: usbduxsigma: Call mutex_destroy() on private mutex
    
    `usbduxsigma_detach()` is the Comedi "detach" handler for the
    usbduxsigma driver.  When it is called, the private data for the device
    is about to be freed.  The private date contains a mutex `devpriv->mut`
    that was initialized when the private data was allocated.  Call
    `mutex_destroy()` to mark it as invalid.
    
    The calls to `mutex_lock()` and `mutex_unlock()` in
    `usbduxsigma_detach()` are probably not required, especially as the
    mutex is about to be destroyed, but leave them alone for now.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index af5605a875e2..3cc40d2544be 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1577,6 +1577,8 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usbduxsigma_free_usb_buffers(dev);
 
 	mutex_unlock(&devpriv->mut);
+
+	mutex_destroy(&devpriv->mut);
 }
 
 static struct comedi_driver usbduxsigma_driver = {

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 4ff8e7a87460..af5605a875e2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2,16 +2,6 @@
 /*
  * usbduxsigma.c
  * Copyright (C) 2011-2015 Bernd Porr, mail@berndporr.me.uk
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 456e9f13becb..4ff8e7a87460 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * usbduxsigma.c
  * Copyright (C) 2011-2015 Bernd Porr, mail@berndporr.me.uk

commit 4e719935ea07eae2b9674c9578e8941601e4380d
Author: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
Date:   Fri Oct 2 22:04:22 2015 +0200

    Staging: comedi: Use mutex instead of semaphore in usbduxsigma.c
    
    Replace binary semaphore with mutex because mutex gives better
    performance.
    This change is safe because the thread that decrements the value of semaphore
    is also the one that increments it, and acts like a mutex where owner of the
    lock is the only one that can release the lock.
    
    Signed-off-by: Ksenija Stanojevic <ksenija.stanojevic@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d49147bc2786..456e9f13becb 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -173,7 +173,7 @@ struct usbduxsigma_private {
 	unsigned int ai_interval;
 	/* commands */
 	u8 *dux_commands;
-	struct semaphore sem;
+	struct mutex mut;
 };
 
 static void usbduxsigma_unlink_urbs(struct urb **urbs, int num_urbs)
@@ -199,10 +199,10 @@ static int usbduxsigma_ai_cancel(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	/* unlink only if it is really running */
 	usbduxsigma_ai_stop(dev, devpriv->ai_cmd_running);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -325,10 +325,10 @@ static int usbduxsigma_ao_cancel(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	/* unlink only if it is really running */
 	usbduxsigma_ao_stop(dev, devpriv->ao_cmd_running);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -609,19 +609,19 @@ static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	if (!devpriv->ai_cmd_running) {
 		devpriv->ai_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,
 					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	}
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 1;
 }
@@ -638,7 +638,7 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	if (devpriv->high_speed) {
 		/*
@@ -673,7 +673,7 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 
 	ret = usbbuxsigma_send_cmd(dev, USBBUXSIGMA_AD_CMD);
 	if (ret < 0) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return ret;
 	}
 
@@ -686,7 +686,7 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			devpriv->ai_cmd_running = 0;
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->async->inttrig = NULL;
@@ -694,7 +694,7 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 		s->async->inttrig = usbduxsigma_ai_inttrig;
 	}
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -712,9 +712,9 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	if (devpriv->ai_cmd_running) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return -EBUSY;
 	}
 
@@ -731,7 +731,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	/* adc commands */
 	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 	if (ret < 0) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return ret;
 	}
 
@@ -740,7 +740,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 
 		ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 		if (ret < 0) {
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 
@@ -750,7 +750,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		val &= 0x00ffffff;	/* strip status byte */
 		data[i] = comedi_offset_munge(s, val);
 	}
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return insn->n;
 }
@@ -763,9 +763,9 @@ static int usbduxsigma_ao_insn_read(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	ret = comedi_readback_insn_read(dev, s, insn, data);
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -780,9 +780,9 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	if (devpriv->ao_cmd_running) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return -EBUSY;
 	}
 
@@ -792,12 +792,12 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 		devpriv->dux_commands[3] = chan;	/* channel number */
 		ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DA_CMD);
 		if (ret < 0) {
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->readback[chan] = data[i];
 	}
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return insn->n;
 }
@@ -813,19 +813,19 @@ static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 	if (!devpriv->ao_cmd_running) {
 		devpriv->ao_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,
 					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			devpriv->ao_cmd_running = 0;
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	}
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 1;
 }
@@ -856,7 +856,7 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err) {
-		up(&devpriv->sem);
+		mutex_unlock(&devpriv->mut);
 		return 1;
 	}
 
@@ -905,7 +905,7 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	/*
 	 * For now, only "scan" timing is supported.  A future version may
@@ -924,7 +924,7 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			devpriv->ao_cmd_running = 0;
-			up(&devpriv->sem);
+			mutex_unlock(&devpriv->mut);
 			return ret;
 		}
 		s->async->inttrig = NULL;
@@ -932,7 +932,7 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 		s->async->inttrig = usbduxsigma_ao_inttrig;
 	}
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return 0;
 }
@@ -963,7 +963,7 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	int ret;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	comedi_dio_update_state(s, data);
 
@@ -990,7 +990,7 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 	ret = insn->n;
 
 done:
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 
 	return ret;
 }
@@ -1462,7 +1462,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	if (!devpriv)
 		return -ENOMEM;
 
-	sema_init(&devpriv->sem, 1);
+	mutex_init(&devpriv->mut);
 
 	usb_set_intfdata(intf, devpriv);
 
@@ -1576,7 +1576,7 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	if (!devpriv)
 		return;
 
-	down(&devpriv->sem);
+	mutex_lock(&devpriv->mut);
 
 	/* force unlink all urbs */
 	usbduxsigma_ai_stop(dev, 1);
@@ -1585,7 +1585,7 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 
 	usbduxsigma_free_usb_buffers(dev);
 
-	up(&devpriv->sem);
+	mutex_unlock(&devpriv->mut);
 }
 
 static struct comedi_driver usbduxsigma_driver = {

commit d3f1e38830f7201d901aa456050d00be1931b248
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 11:39:42 2015 -0700

    staging: comedi: usbduxsigma: use comedi_offset_munge()
    
    Use the comedi_offset_munge() helper to convert the hardware two's
    complement values to the offset binary format expected by comedi.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 8b4cafe53d9b..d49147bc2786 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -230,8 +230,7 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				val = be32_to_cpu(devpriv->in_buf[i + 1]);
 				val &= 0x00ffffff; /* strip status byte */
-				val ^= 0x00800000; /* convert to unsigned */
-
+				val = comedi_offset_munge(s, val);
 				if (!comedi_buf_write_samples(s, &val, 1))
 					return;
 			}
@@ -749,9 +748,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		val = be32_to_cpu(get_unaligned((__be32
 						 *)(devpriv->insn_buf + 1)));
 		val &= 0x00ffffff;	/* strip status byte */
-		val ^= 0x00800000;	/* convert to unsigned */
-
-		data[i] = val;
+		data[i] = comedi_offset_munge(s, val);
 	}
 	up(&devpriv->sem);
 
@@ -1219,6 +1216,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 
 static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 {
+	struct comedi_subdevice *s = dev->read_subdev;
 	struct usbduxsigma_private *devpriv = dev->private;
 	u8 sysred;
 	u32 val;
@@ -1263,9 +1261,8 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 	/* 32 bits big endian from the A/D converter */
 	val = be32_to_cpu(get_unaligned((__be32 *)(devpriv->insn_buf + 1)));
 	val &= 0x00ffffff;	/* strip status byte */
-	val ^= 0x00800000;	/* convert to unsigned */
 
-	return (int)val;
+	return (int)comedi_offset_munge(s, val);
 }
 
 static int usbduxsigma_firmware_upload(struct comedi_device *dev,

commit c20d199492b48402cef24a9bab599bc10e0d2a3c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 11:39:41 2015 -0700

    staging: comedi: usbduxsigma: tidy up block comments
    
    Merge the two comments and format it in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b3487106d827..8b4cafe53d9b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -223,11 +223,11 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 		if (devpriv->ai_counter == 0) {
 			devpriv->ai_counter = devpriv->ai_timer;
 
-			/* get the data from the USB bus
-			   and hand it over to comedi */
+			/*
+			 * Get the data from the USB bus and hand it over
+			 * to comedi. Note, first byte is the DIO state.
+			 */
 			for (i = 0; i < cmd->chanlist_len; i++) {
-				/* transfer data,
-				   note first byte is the DIO state */
 				val = be32_to_cpu(devpriv->in_buf[i + 1]);
 				val &= 0x00ffffff; /* strip status byte */
 				val ^= 0x00800000; /* convert to unsigned */

commit ef9a6bdfea3fa9686dbadf0a79502eff005c141a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 11:39:40 2015 -0700

    staging: comedi: usbduxsigma: use prefered kernel types
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a33b2cbe1fb5..b3487106d827 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -75,7 +75,7 @@
 #define NUMCHANNELS 16
 
 /* Size of one A/D value */
-#define SIZEADIN          ((sizeof(uint32_t)))
+#define SIZEADIN          ((sizeof(u32)))
 
 /*
  * Size of the async input-buffer IN BYTES, the DIO state is transmitted
@@ -90,7 +90,7 @@
 #define NUMOUTCHANNELS    8
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(uint8_t) + sizeof(uint16_t)))
+#define SIZEDAOUT          ((sizeof(u8) + sizeof(uint16_t)))
 
 /*
  * Size of the output-buffer in bytes
@@ -150,13 +150,13 @@ struct usbduxsigma_private {
 	/* PWM period */
 	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	uint8_t pwm_delay;
+	u8 pwm_delay;
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
 	__be32 *in_buf;
 	/* input buffer for single insn */
-	uint8_t *insn_buf;
+	u8 *insn_buf;
 
 	unsigned high_speed:1;
 	unsigned ai_cmd_running:1;
@@ -172,7 +172,7 @@ struct usbduxsigma_private {
 	/* interval in frames/uframes */
 	unsigned int ai_interval;
 	/* commands */
-	uint8_t *dux_commands;
+	u8 *dux_commands;
 	struct semaphore sem;
 };
 
@@ -214,7 +214,7 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint32_t val;
+	u32 val;
 	int ret;
 	int i;
 
@@ -341,7 +341,7 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	uint8_t *datap;
+	u8 *datap;
 	int ret;
 	int i;
 
@@ -553,8 +553,7 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
  * range is the range value from comedi
  */
 static void create_adc_command(unsigned int chan,
-			       uint8_t *muxsg0,
-			       uint8_t *muxsg1)
+			       u8 *muxsg0, u8 *muxsg1)
 {
 	if (chan < 8)
 		(*muxsg0) = (*muxsg0) | (1 << chan);
@@ -634,9 +633,9 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int len = cmd->chanlist_len;
-	uint8_t muxsg0 = 0;
-	uint8_t muxsg1 = 0;
-	uint8_t sysred = 0;
+	u8 muxsg0 = 0;
+	u8 muxsg1 = 0;
+	u8 sysred = 0;
 	int ret;
 	int i;
 
@@ -708,9 +707,9 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	uint8_t muxsg0 = 0;
-	uint8_t muxsg1 = 0;
-	uint8_t sysred = 0;
+	u8 muxsg0 = 0;
+	u8 muxsg1 = 0;
+	u8 sysred = 0;
 	int ret;
 	int i;
 
@@ -738,7 +737,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		uint32_t val;
+		u32 val;
 
 		ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 		if (ret < 0) {
@@ -1221,8 +1220,8 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
-	uint8_t sysred;
-	uint32_t val;
+	u8 sysred;
+	u32 val;
 	int ret;
 
 	switch (chan) {
@@ -1274,8 +1273,8 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 				       unsigned long context)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
-	uint8_t *buf;
-	uint8_t *tmp;
+	u8 *buf;
+	u8 *tmp;
 	int ret;
 
 	if (!data)

commit 11f32ad360bf0447e4f97cb1dc2d020247a59f1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 14 11:39:39 2015 -0700

    staging: comedi: usbduxsigma: add missing spaces
    
    Add some missing space to quiet the checkpatch.pl issues about:
    
    CHECK: spaces preferred around that '/' (ctx:VxV)
    CHECK: spaces preferred around that '+' (ctx:VxV)
    CHECK: spaces preferred around that '*' (ctx:VxV)
    CHECK: spaces preferred around that '-' (ctx:VxV)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 649cf47184a4..a33b2cbe1fb5 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -66,10 +66,10 @@
 #define USBDUXSUB_CPUCS 0xE600
 
 /* 300Hz max frequ under PWM */
-#define MIN_PWM_PERIOD  ((long)(1E9/300))
+#define MIN_PWM_PERIOD  ((long)(1E9 / 300))
 
 /* Default PWM frequency */
-#define PWM_DEFAULT_PERIOD ((long)(1E9/100))
+#define PWM_DEFAULT_PERIOD ((long)(1E9 / 100))
 
 /* Number of channels (16 AD and offset)*/
 #define NUMCHANNELS 16
@@ -81,7 +81,7 @@
  * Size of the async input-buffer IN BYTES, the DIO state is transmitted
  * as the first byte.
  */
-#define SIZEINBUF         (((NUMCHANNELS+1)*SIZEADIN))
+#define SIZEINBUF         (((NUMCHANNELS + 1) * SIZEADIN))
 
 /* 16 bytes. */
 #define SIZEINSNBUF       16
@@ -90,20 +90,20 @@
 #define NUMOUTCHANNELS    8
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(uint16_t)))
+#define SIZEDAOUT          ((sizeof(uint8_t) + sizeof(uint16_t)))
 
 /*
  * Size of the output-buffer in bytes
  * Actually only the first 4 triplets are used but for the
  * high speed mode we need to pad it to 8 (microframes).
  */
-#define SIZEOUTBUF         ((8*SIZEDAOUT))
+#define SIZEOUTBUF         ((8 * SIZEDAOUT))
 
 /*
  * Size of the buffer for the dux commands: just now max size is determined
  * by the analogue out + command byte + panic bytes...
  */
-#define SIZEOFDUXBUFFER    ((8*SIZEDAOUT+2))
+#define SIZEOFDUXBUFFER    ((8 * SIZEDAOUT + 2))
 
 /* Number of in-URBs which receive the data: min=2 */
 #define NUMOFINBUFFERSFULL     5
@@ -228,7 +228,7 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 			for (i = 0; i < cmd->chanlist_len; i++) {
 				/* transfer data,
 				   note first byte is the DIO state */
-				val = be32_to_cpu(devpriv->in_buf[i+1]);
+				val = be32_to_cpu(devpriv->in_buf[i + 1]);
 				val &= 0x00ffffff; /* strip status byte */
 				val ^= 0x00800000; /* convert to unsigned */
 
@@ -559,7 +559,7 @@ static void create_adc_command(unsigned int chan,
 	if (chan < 8)
 		(*muxsg0) = (*muxsg0) | (1 << chan);
 	else if (chan < 16)
-		(*muxsg1) = (*muxsg1) | (1 << (chan-8));
+		(*muxsg1) = (*muxsg1) | (1 << (chan - 8));
 }
 
 static int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)

commit ed2c2e060b6c3cd5fc42993011aa41c765ff1b2f
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:47:02 2015 +0100

    staging: comedi: usbduxsigma: round down AO scan_begin_arg at step 4.
    
    The return value of the `cmdtest` handler for a subdevice checks the
    prospective new command in various steps and returns the step number at
    which any problem was detected, or 0 if no problem was detected.  It is
    allowed to modify the command in various ways at each step.  Corrections
    for out-of-range values are generally made at step 3, and minor
    adjustments such as rounding are generally made at step 4.
    
    The `cmdtest` handler for the AO subdevice (`usbduxsigma_ao_cmdtest()`)
    currently range checks the timings at step 3.  Since the running command
    will round down the timings, add code to round them down at step 4.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 9f43e01b58c5..649cf47184a4 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -839,6 +839,7 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 				  struct comedi_cmd *cmd)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int tmp;
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -890,6 +891,14 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
+	/* Step 4: fix up any arguments */
+
+	tmp = rounddown(cmd->scan_begin_arg, 1000000);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+
+	if (err)
+		return 4;
+
 	return 0;
 }
 

commit 57befc33af0243e9b3835d46ab836406256f5dd4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:47:01 2015 +0100

    staging: comedi: usbduxsigma: remove unused "convert" timing for AO
    
    The `cmdtest` and `cmd` handlers for the AO subdevice
    (`usbduxsigma_ao_cmdtest()` and `usbduxsigma_ao_cmd()`) support "scan"
    timing of commands with all channels updated every "scan" period.  There
    is some disabled code to use "convert" timing in high speed mode.  That
    would allow channels to be updated sequentially every "convert" period.
    Since that code is incomplete and currently disabled, remove it to
    simplify the existing code.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 535cf01bca07..9f43e01b58c5 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -840,28 +840,20 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 	int err = 0;
-	int high_speed;
-	unsigned int flags;
-
-	/* high speed conversions are not used yet */
-	high_speed = 0;		/* (devpriv->high_speed) */
 
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	if (high_speed) {
-		/*
-		 * start immediately a new scan
-		 * the sampling rate is set by the coversion rate
-		 */
-		flags = TRIG_FOLLOW;
-	} else {
-		/* start a new scan (output at once) with a timer */
-		flags = TRIG_TIMER;
-	}
-	err |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);
-
+	/*
+	 * For now, always use "scan" timing with all channels updated at once
+	 * (cmd->scan_begin_src == TRIG_TIMER, cmd->convert_src == TRIG_NOW).
+	 *
+	 * In a future version, "convert" timing with channels updated
+	 * indivually may be supported in high speed mode
+	 * (cmd->scan_begin_src == TRIG_FOLLOW, cmd->convert_src == TRIG_TIMER).
+	 */
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
 	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
 	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
@@ -885,17 +877,7 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
-						    1000000);
-	}
-
-	/* not used now, is for later use */
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 125000);
+	err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
@@ -920,19 +902,13 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		/*
-		 * timing of the conversion itself: every 125 us
-		 * at high speed (not used yet)
-		 */
-		devpriv->ao_timer = cmd->convert_arg / 125000;
-	} else {
-		/*
-		 * timing of the scan: every 1ms
-		 * we get all channels at once
-		 */
-		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
-	}
+	/*
+	 * For now, only "scan" timing is supported.  A future version may
+	 * support "convert" timing in high speed mode.
+	 *
+	 * Timing of the scan: every 1ms all channels updated at once.
+	 */
+	devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
 
 	devpriv->ao_counter = devpriv->ao_timer;
 

commit 333e40aee3f2d0457e2cbadc742619a6f449b2e7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:47:00 2015 +0100

    staging: comedi: usbduxsigma: round down AI scan_begin_arg at step 4.
    
    The return value of the `cmdtest` handler for a subdevice checks the
    prospective new command in various steps and returns the step number at
    which any problem was detected, or 0 if no problem was detected.  It is
    allowed to modify the command in various ways at each step.  Corrections
    for out-of-range values are generally made at step 3, and minor
    adjustments such as rounding are generally made at step 4.
    
    The `cmdtest` handler for the AI subdevice (`usbduxsigma_ai_cmdtest()`)
    currently modifies `cmd->scan_begin_arg` to bring it into range and
    round it down at step 3.  Move the rounding down part to step 4 to
    follow the usual Comedi convention.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index fdc880a4adaf..535cf01bca07 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -519,17 +519,12 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 		 */
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
 						    (125000 * interval));
-
-		tmp = (cmd->scan_begin_arg / 125000) * 125000;
 	} else {
 		/* full speed */
 		/* 1kHz scans every USB frame */
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
 						    1000000);
-
-		tmp = (cmd->scan_begin_arg / 1000000) * 1000000;
 	}
-	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);
@@ -542,6 +537,14 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
+	/* Step 4: fix up any arguments */
+
+	tmp = rounddown(cmd->scan_begin_arg, high_speed ? 125000 : 1000000);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+
+	if (err)
+		return 4;
+
 	return 0;
 }
 

commit 12e1e6960130673aabbbe7f094c4690b00618881
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:46:59 2015 +0100

    staging: comedi: usbduxsigma: remove AI scan_begin_src == TRIG_FOLLOW
    
    The AI subdevice `cmdtest` handler `usbduxsigma_ai_cmdtest()` ensures
    that `cmd->scan_begin_src == TRIG_TIMER` by the end of step 2 of the
    command checking code, so assume that this is the case for step 3
    onwards and remove the redundant code.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index dcb7f3037dea..fdc880a4adaf 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -482,6 +482,7 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	int high_speed = devpriv->high_speed;
 	int interval = usbduxsigma_chans_to_interval(cmd->chanlist_len);
+	unsigned int tmp;
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
@@ -509,36 +510,26 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	if (high_speed) {
+		/*
+		 * In high speed mode microframes are possible.
+		 * However, during one microframe we can roughly
+		 * sample two channels. Thus, the more channels
+		 * are in the channel list the more time we need.
+		 */
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    (125000 * interval));
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		unsigned int tmp;
-
-		if (high_speed) {
-			/*
-			 * In high speed mode microframes are possible.
-			 * However, during one microframe we can roughly
-			 * sample two channels. Thus, the more channels
-			 * are in the channel list the more time we need.
-			 */
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    (1000000 / 8 *
-							     interval));
-
-			tmp = (cmd->scan_begin_arg / 125000) * 125000;
-		} else {
-			/* full speed */
-			/* 1kHz scans every USB frame */
-			err |= comedi_check_trigger_arg_min(&cmd->
-							    scan_begin_arg,
-							    1000000);
-
-			tmp = (cmd->scan_begin_arg / 1000000) * 1000000;
-		}
-		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+		tmp = (cmd->scan_begin_arg / 125000) * 125000;
+	} else {
+		/* full speed */
+		/* 1kHz scans every USB frame */
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    1000000);
+
+		tmp = (cmd->scan_begin_arg / 1000000) * 1000000;
 	}
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);

commit c04a1f17803e0d3eeada586ca34a6b436959bc20
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:46:58 2015 +0100

    staging: comedi: usbduxsigma: don't clobber ao_timer in command test
    
    `devpriv->ao_timer` is used while an asynchronous command is running on
    the AO subdevice.  It also gets modified by the subdevice's `cmdtest`
    handler for checking new asynchronous commands,
    `usbduxsigma_ao_cmdtest()`, which is not correct as it's allowed to
    check new commands while an old command is still running.  Fix it by
    moving the code which sets up `devpriv->ao_timer` into the subdevice's
    `cmd` handler, `usbduxsigma_ao_cmd()`.
    
    Note that the removed code in `usbduxsigma_ao_cmdtest()` checked that
    `devpriv->ao_timer` did not end up less that 1, but that could not
    happen due because `cmd->scan_begin_arg` or `cmd->convert_arg` had
    already been range-checked.
    
    Also note that we tested the `high_speed` variable in the old code, but
    that is currently always 0 and means that we always use "scan" timing
    (`cmd->scan_begin_src == TRIG_TIMER` and `cmd->convert_src == TRIG_NOW`)
    and never "convert" (individual sample) timing (`cmd->scan_begin_src ==
    TRIG_FOLLOW` and `cmd->convert_src == TRIG_TIMER`).  The moved code
    tests `cmd->convert_src` instead to decide whether "scan" or "convert"
    timing is being used, although currently only "scan" timing is
    supported.
    
    Fixes: fb1ef622e7a3 ("staging: comedi: usbduxsigma: tidy up analog output command support")
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: <stable@vger.kernel.org> # 3.19 onwards
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2d684747a639..dcb7f3037dea 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -914,25 +914,6 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* Step 4: fix up any arguments */
-
-	/* we count in timer steps */
-	if (high_speed) {
-		/* timing of the conversion itself: every 125 us */
-		devpriv->ao_timer = cmd->convert_arg / 125000;
-	} else {
-		/*
-		 * timing of the scan: every 1ms
-		 * we get all channels at once
-		 */
-		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
-	}
-	if (devpriv->ao_timer < 1)
-		err |= -EINVAL;
-
-	if (err)
-		return 4;
-
 	return 0;
 }
 
@@ -945,6 +926,20 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 
+	if (cmd->convert_src == TRIG_TIMER) {
+		/*
+		 * timing of the conversion itself: every 125 us
+		 * at high speed (not used yet)
+		 */
+		devpriv->ao_timer = cmd->convert_arg / 125000;
+	} else {
+		/*
+		 * timing of the scan: every 1ms
+		 * we get all channels at once
+		 */
+		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
+	}
+
 	devpriv->ao_counter = devpriv->ao_timer;
 
 	if (cmd->start_src == TRIG_NOW) {

commit 423b24c37dd5794a674c74b0ed56392003a69891
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Jul 23 16:46:57 2015 +0100

    staging: comedi: usbduxsigma: don't clobber ai_timer in command test
    
    `devpriv->ai_timer` is used while an asynchronous command is running on
    the AI subdevice.  It also gets modified by the subdevice's `cmdtest`
    handler for checking new asynchronous commands
    (`usbduxsigma_ai_cmdtest()`), which is not correct as it's allowed to
    check new commands while an old command is still running.  Fix it by
    moving the code which sets up `devpriv->ai_timer` and
    `devpriv->ai_interval` into the subdevice's `cmd` handler,
    `usbduxsigma_ai_cmd()`.
    
    Note that the removed code in `usbduxsigma_ai_cmdtest()` checked that
    `devpriv->ai_timer` did not end up less than than 1, but that could not
    happen because `cmd->scan_begin_arg` had already been checked to be at
    least the minimum required value (at least when `cmd->scan_begin_src ==
    TRIG_TIMER`, which had also been checked to be the case).
    
    Fixes: b986be8527c7 ("staging: comedi: usbduxsigma: tidy up analog input command support)
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: <stable@vger.kernel.org> # 3.19 onwards
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 51846adf8340..2d684747a639 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -551,27 +551,6 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* Step 4: fix up any arguments */
-
-	if (high_speed) {
-		/*
-		 * every 2 channels get a time window of 125us. Thus, if we
-		 * sample all 16 channels we need 1ms. If we sample only one
-		 * channel we need only 125us
-		 */
-		devpriv->ai_interval = interval;
-		devpriv->ai_timer = cmd->scan_begin_arg / (125000 * interval);
-	} else {
-		/* interval always 1ms */
-		devpriv->ai_interval = 1;
-		devpriv->ai_timer = cmd->scan_begin_arg / 1000000;
-	}
-	if (devpriv->ai_timer < 1)
-		err |= -EINVAL;
-
-	if (err)
-		return 4;
-
 	return 0;
 }
 
@@ -669,6 +648,22 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 
+	if (devpriv->high_speed) {
+		/*
+		 * every 2 channels get a time window of 125us. Thus, if we
+		 * sample all 16 channels we need 1ms. If we sample only one
+		 * channel we need only 125us
+		 */
+		unsigned int interval = usbduxsigma_chans_to_interval(len);
+
+		devpriv->ai_interval = interval;
+		devpriv->ai_timer = cmd->scan_begin_arg / (125000 * interval);
+	} else {
+		/* interval always 1ms */
+		devpriv->ai_interval = 1;
+		devpriv->ai_timer = cmd->scan_begin_arg / 1000000;
+	}
+
 	for (i = 0; i < len; i++) {
 		unsigned int chan  = CR_CHAN(cmd->chanlist[i]);
 

commit d5a372df8661113b8aa36f4eb29d4b969d1d3db4
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Wed Jul 22 18:46:39 2015 +0100

    staging/comedi/drivers/usbduxsigma.c: added support for ehci drivers
    
    urb->interval is deprecated and thus I've changed the driver
    that it now always assumes interval=1 which means every frame
    in USB 1.1 and every uframe in USB 2.0. However we still need
    to have different sampling rates which are still multiples
    of the interval which is now transmitted to the firmware.
    The firmware transmits either zero length packets or none every (u)frame.
    This is checked in the completion handler and any packet
    at zero length is discarded so that comedi again sees the data
    coming in at the interval specified. This also then gives the ADC
    the necessary time to convert. For example 16 channels require
    about 700us and in this period no packet could be transmitted.
    In this case this is padded up to 1ms so that we have then 7 zero
    length packets and one packet with the ADC data.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2c27eb2bc2f5..51846adf8340 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,6 +1,6 @@
 /*
  * usbduxsigma.c
- * Copyright (C) 2011-2014 Bernd Porr, mail@berndporr.me.uk
+ * Copyright (C) 2011-2015 Bernd Porr, mail@berndporr.me.uk
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,7 +18,7 @@
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
  * Devices: [ITL] USB-DUX-SIGMA (usbduxsigma)
  * Author: Bernd Porr <mail@berndporr.me.uk>
- * Updated: 10 Oct 2014
+ * Updated: 20 July 2015
  * Status: stable
  */
 
@@ -39,6 +39,7 @@
  *   0.4: fixed D/A voltage range
  *   0.5: various bug fixes, health check at startup
  *   0.6: corrected wrong input range
+ *   0.7: rewrite code that urb->interval is always 1
  */
 
 #include <linux/kernel.h>
@@ -122,7 +123,7 @@
 #define RETRIES 10
 
 /* bulk transfer commands to usbduxsigma */
-#define USBBUXSIGMA_AD_CMD		0
+#define USBBUXSIGMA_AD_CMD		9
 #define USBDUXSIGMA_DA_CMD		1
 #define USBDUXSIGMA_DIO_CFG_CMD		2
 #define USBDUXSIGMA_DIO_BITS_CMD	3
@@ -217,24 +218,28 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	devpriv->ai_counter--;
-	if (devpriv->ai_counter == 0) {
-		devpriv->ai_counter = devpriv->ai_timer;
-
-		/* get the data from the USB bus and hand it over to comedi */
-		for (i = 0; i < cmd->chanlist_len; i++) {
-			/* transfer data, note first byte is the DIO state */
-			val = be32_to_cpu(devpriv->in_buf[i+1]);
-			val &= 0x00ffffff;	/* strip status byte */
-			val ^= 0x00800000;	/* convert to unsigned */
+	if ((urb->actual_length > 0) && (urb->status != -EXDEV)) {
+		devpriv->ai_counter--;
+		if (devpriv->ai_counter == 0) {
+			devpriv->ai_counter = devpriv->ai_timer;
+
+			/* get the data from the USB bus
+			   and hand it over to comedi */
+			for (i = 0; i < cmd->chanlist_len; i++) {
+				/* transfer data,
+				   note first byte is the DIO state */
+				val = be32_to_cpu(devpriv->in_buf[i+1]);
+				val &= 0x00ffffff; /* strip status byte */
+				val ^= 0x00800000; /* convert to unsigned */
+
+				if (!comedi_buf_write_samples(s, &val, 1))
+					return;
+			}
 
-			if (!comedi_buf_write_samples(s, &val, 1))
-				return;
+			if (cmd->stop_src == TRIG_COUNT &&
+			    async->scans_done >= cmd->stop_arg)
+				async->events |= COMEDI_CB_EOA;
 		}
-
-		if (cmd->stop_src == TRIG_COUNT &&
-		    async->scans_done >= cmd->stop_arg)
-			async->events |= COMEDI_CB_EOA;
 	}
 
 	/* if command is still running, resubmit urb */
@@ -374,10 +379,7 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 		urb->transfer_buffer_length = SIZEOUTBUF;
 		urb->dev = comedi_to_usb_dev(dev);
 		urb->status = 0;
-		if (devpriv->high_speed)
-			urb->interval = 8;	/* uframes */
-		else
-			urb->interval = 1;	/* frames */
+		urb->interval = 1;	/* (u)frames */
 		urb->number_of_packets = 1;
 		urb->iso_frame_desc[0].offset = 0;
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
@@ -441,7 +443,6 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 				   int input_urb)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
-	struct usbduxsigma_private *devpriv = dev->private;
 	struct urb *urb;
 	int ret;
 	int i;
@@ -452,7 +453,7 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 
 		/* in case of a resubmission after an unlink... */
 		if (input_urb)
-			urb->interval = devpriv->ai_interval;
+			urb->interval = 1;
 		urb->context = dev;
 		urb->dev = usb;
 		urb->status = 0;
@@ -674,13 +675,14 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 		create_adc_command(chan, &muxsg0, &muxsg1);
 	}
 
-	devpriv->dux_commands[1] = len;  /* num channels per time step */
-	devpriv->dux_commands[2] = 0x12; /* CONFIG0 */
-	devpriv->dux_commands[3] = 0x03; /* CONFIG1: 23kHz sample, delay 0us */
-	devpriv->dux_commands[4] = 0x00; /* CONFIG3: diff. channels off */
-	devpriv->dux_commands[5] = muxsg0;
-	devpriv->dux_commands[6] = muxsg1;
-	devpriv->dux_commands[7] = sysred;
+	devpriv->dux_commands[1] = devpriv->ai_interval;
+	devpriv->dux_commands[2] = len;  /* num channels per time step */
+	devpriv->dux_commands[3] = 0x12; /* CONFIG0 */
+	devpriv->dux_commands[4] = 0x03; /* CONFIG1: 23kHz sample, delay 0us */
+	devpriv->dux_commands[5] = 0x00; /* CONFIG3: diff. channels off */
+	devpriv->dux_commands[6] = muxsg0;
+	devpriv->dux_commands[7] = muxsg1;
+	devpriv->dux_commands[8] = sysred;
 
 	ret = usbbuxsigma_send_cmd(dev, USBBUXSIGMA_AD_CMD);
 	if (ret < 0) {
@@ -1427,10 +1429,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		urb->transfer_buffer_length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].offset = 0;
 		urb->iso_frame_desc[0].length = SIZEOUTBUF;
-		if (devpriv->high_speed)
-			urb->interval = 8;	/* uframes */
-		else
-			urb->interval = 1;	/* frames */
+		urb->interval = 1;	/* (u)frames */
 	}
 
 	if (devpriv->pwm_buf_sz) {

commit e73063c5407b6ffe09dc0f7c11970113bf55e6fc
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Wed Jul 22 18:45:55 2015 +0100

    staging/comedi/drivers/usbduxsigma.c: updated address details
    
    Changed my e-mail address to mail@berndporr.me.uk. The old one
    is no longer used.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index eaa9add491df..2c27eb2bc2f5 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1653,7 +1653,7 @@ static struct usb_driver usbduxsigma_usb_driver = {
 };
 module_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);
 
-MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
-MODULE_DESCRIPTION("Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com");
+MODULE_AUTHOR("Bernd Porr, mail@berndporr.me.uk");
+MODULE_DESCRIPTION("Stirling/ITL USB-DUX SIGMA -- mail@berndporr.me.uk");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(FIRMWARE);

commit 8a8626b4f83a66bd219964127b1bfad75ff55615
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:39 2015 +0000

    staging: comedi: usbduxsigma: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f50cf8a8dada..eaa9add491df 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -49,7 +49,6 @@
 #include <linux/compiler.h>
 #include <asm/unaligned.h>
 
-#include "comedi_fc.h"
 #include "../comedi_usb.h"
 
 /* timeout for the USB-transfer in ms*/
@@ -486,19 +485,19 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -507,10 +506,10 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		unsigned int tmp;
@@ -522,27 +521,31 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 			 * sample two channels. Thus, the more channels
 			 * are in the channel list the more time we need.
 			 */
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						(1000000 / 8 * interval));
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    (1000000 / 8 *
+							     interval));
 
 			tmp = (cmd->scan_begin_arg / 125000) * 125000;
 		} else {
 			/* full speed */
 			/* 1kHz scans every USB frame */
-			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 1000000);
+			err |= comedi_check_trigger_arg_min(&cmd->
+							    scan_begin_arg,
+							    1000000);
 
 			tmp = (cmd->scan_begin_arg / 1000000) * 1000000;
 		}
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -854,7 +857,7 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
 	if (high_speed) {
 		/*
@@ -866,11 +869,11 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 		/* start a new scan (output at once) with a timer */
 		flags = TRIG_TIMER;
 	}
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);
 
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err) {
 		up(&devpriv->sem);
@@ -879,8 +882,8 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -889,25 +892,27 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 1000000);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    1000000);
+	}
 
 	/* not used now, is for later use */
 	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 125000);
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 125000);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit ce82410c76374be44a4dbd60b906e896a5e20687
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Fri Mar 6 22:01:38 2015 +0300

    Staging: comedi: clean dev_err logging
    
    This patch removes  __func__ from dev_err. dev_err includes information about:
    (devcice, driver, specific instance of device, etc) in the log printout.
    This was done using Coccinelle, with the following semantic patch:
    
    @a@
    expression E, R;
    expression  msg;
    @@
    
    dev_err(E, msg, __func__, R);
    
    @script:python b@
    e << a.msg;
    y;
    @@
    
    if(e.find("%s: ") == True):
            m = e.replace("%s: ", "", 1);
            coccinelle.y = m;
    elif(e.find("%s ") == True):
            m = e.replace("%s ", "", 1);
            coccinelle.y = m;
    elif(e.find("%s:") == True):
            m = e.replace("%s:", "", 1);
            coccinelle.y = m;
    else:
            m = e.replace("%s", "",1);
            coccinelle.y = m;
    
    @c@
    expression a.E, a.msg, a.R;
    identifier  b.y;
    @@
    
    - dev_err(E, msg, __func__, R);
    + dev_err(E, y, R);
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 394969b7458c..f50cf8a8dada 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -243,9 +243,8 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 		urb->dev = comedi_to_usb_dev(dev);
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
-			dev_err(dev->class_dev,
-				"%s: urb resubmit failed (%d)\n",
-				__func__, ret);
+			dev_err(dev->class_dev, "urb resubmit failed (%d)\n",
+				ret);
 			if (ret == -EL2NSYNC)
 				dev_err(dev->class_dev,
 					"buggy USB host controller or bug in IRQ handler\n");
@@ -292,8 +291,8 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 
 	default:
 		/* a real error */
-		dev_err(dev->class_dev, "%s: non-zero urb status (%d)\n",
-			__func__, urb->status);
+		dev_err(dev->class_dev, "non-zero urb status (%d)\n",
+			urb->status);
 		async->events |= COMEDI_CB_ERROR;
 		break;
 	}
@@ -386,9 +385,8 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 		urb->iso_frame_desc[0].status = 0;
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
-			dev_err(dev->class_dev,
-				"%s: urb resubmit failed (%d)\n",
-				__func__, ret);
+			dev_err(dev->class_dev, "urb resubmit failed (%d)\n",
+				ret);
 			if (ret == -EL2NSYNC)
 				dev_err(dev->class_dev,
 					"buggy USB host controller or bug in IRQ handler\n");
@@ -423,8 +421,8 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 
 	default:
 		/* a real error */
-		dev_err(dev->class_dev, "%s: non-zero urb status (%d)\n",
-			__func__, urb->status);
+		dev_err(dev->class_dev, "non-zero urb status (%d)\n",
+			urb->status);
 		async->events |= COMEDI_CB_ERROR;
 		break;
 	}
@@ -1071,9 +1069,8 @@ static void usbduxsigma_pwm_urb_complete(struct urb *urb)
 	default:
 		/* a real error */
 		if (devpriv->pwm_cmd_running) {
-			dev_err(dev->class_dev,
-				"%s: non-zero urb status (%d)\n",
-				__func__, urb->status);
+			dev_err(dev->class_dev, "non-zero urb status (%d)\n",
+				urb->status);
 			usbduxsigma_pwm_stop(dev, 0);	/* w/o unlink */
 		}
 		return;
@@ -1087,8 +1084,7 @@ static void usbduxsigma_pwm_urb_complete(struct urb *urb)
 	urb->status = 0;
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
 	if (ret < 0) {
-		dev_err(dev->class_dev, "%s: urb resubmit failed (%d)\n",
-			__func__, ret);
+		dev_err(dev->class_dev, "urb resubmit failed (%d)\n", ret);
 		if (ret == -EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");

commit 3caef5a4cac9d7c27d7362be63e799c199111a62
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Thu Jan 29 23:50:09 2015 +0100

    staging: comedi: drivers: usbduxsigma: Removed variables that is never used
    
    Variable was assigned a value that was never used.
    I have also removed all the code that thereby serves no purpose.
    
    This was found using a static code analysis program called cppcheck
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 378c44923c57..394969b7458c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -214,7 +214,6 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int dio_state;
 	uint32_t val;
 	int ret;
 	int i;
@@ -223,9 +222,6 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 	if (devpriv->ai_counter == 0) {
 		devpriv->ai_counter = devpriv->ai_timer;
 
-		/* get the state of the dio pins to allow external trigger */
-		dio_state = be32_to_cpu(devpriv->in_buf[0]);
-
 		/* get the data from the USB bus and hand it over to comedi */
 		for (i = 0; i < cmd->chanlist_len; i++) {
 			/* transfer data, note first byte is the DIO state */

commit bf98d732d7eb3c89dfcf4716e6824363d559ebe5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 27 17:49:07 2015 +0000

    staging: comedi: usbduxsigma: include new "comedi_usb.h" header
    
    Include the new "../comedi_usb.h" header instead of <linux/usb.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 17e5a81e3f19..378c44923c57 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -45,13 +45,12 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/input.h>
-#include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
 #include <asm/unaligned.h>
 
 #include "comedi_fc.h"
-#include "../comedidev.h"
+#include "../comedi_usb.h"
 
 /* timeout for the USB-transfer in ms*/
 #define BULK_TIMEOUT 1000

commit 2d3c50bb0e80a10515a0e40d59f8c34fa5c2f0c9
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:55:12 2015 +0000

    staging: comedi: usbduxsigma: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Also change "USB-DUX" to "USB-DUX-SIGMA" to distinguish it from the
    other USB-DUX models.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index dc19435b6520..17e5a81e3f19 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -16,7 +16,7 @@
 /*
  * Driver: usbduxsigma
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
- * Devices: (ITL) USB-DUX [usbduxsigma]
+ * Devices: [ITL] USB-DUX-SIGMA (usbduxsigma)
  * Author: Bernd Porr <mail@berndporr.me.uk>
  * Updated: 10 Oct 2014
  * Status: stable

commit 29ee9fbaa1bfa2e89fc7b5774f18d22bc20dd574
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:07 2014 -0700

    staging: comedi: usbduxsigma: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'ai_sample_count' and use the comedi_async
    'scans_done' member to detect the analog input end-of-acquisition.
    
    Move the EOA check so it happens after adding the samples from the current
    urb to the async buffer. This prevents the unnecessary resubmit of the urb
    when the EOA occurs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 31b280656a1a..dc19435b6520 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -164,8 +164,6 @@ struct usbduxsigma_private {
 	unsigned ao_cmd_running:1;
 	unsigned pwm_cmd_running:1;
 
-	/* number of samples to acquire */
-	int ai_sample_count;
 	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
@@ -226,14 +224,6 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 	if (devpriv->ai_counter == 0) {
 		devpriv->ai_counter = devpriv->ai_timer;
 
-		if (cmd->stop_src == TRIG_COUNT) {
-			devpriv->ai_sample_count--;
-			if (devpriv->ai_sample_count < 0) {
-				async->events |= COMEDI_CB_EOA;
-				return;
-			}
-		}
-
 		/* get the state of the dio pins to allow external trigger */
 		dio_state = be32_to_cpu(devpriv->in_buf[0]);
 
@@ -247,6 +237,10 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 			if (!comedi_buf_write_samples(s, &val, 1))
 				return;
 		}
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg)
+			async->events |= COMEDI_CB_EOA;
 	}
 
 	/* if command is still running, resubmit urb */
@@ -578,14 +572,6 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 	if (devpriv->ai_timer < 1)
 		err |= -EINVAL;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* data arrives as one packet */
-		devpriv->ai_sample_count = cmd->stop_arg;
-	} else {
-		/* continuous acquisition */
-		devpriv->ai_sample_count = 0;
-	}
-
 	if (err)
 		return 4;
 

commit 4b8ffac3859155b1f3c5ded5aeda41fedfe5555e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:21:06 2014 -0700

    staging: comedi: usbduxsigma: use comedi_async 'scans_done' to detect AO EOA
    
    Remove the private data member 'ao_sample_count' and use the comedi_async
    'scans_done' member to detect the analog output end-of-acquisition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 9ee6e0a78578..31b280656a1a 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -166,7 +166,6 @@ struct usbduxsigma_private {
 
 	/* number of samples to acquire */
 	int ai_sample_count;
-	int ao_sample_count;
 	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
@@ -358,12 +357,10 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 	if (devpriv->ao_counter == 0) {
 		devpriv->ao_counter = devpriv->ao_timer;
 
-		if (cmd->stop_src == TRIG_COUNT) {
-			devpriv->ao_sample_count--;
-			if (devpriv->ao_sample_count < 0) {
-				async->events |= COMEDI_CB_EOA;
-				return;
-			}
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg) {
+			async->events |= COMEDI_CB_EOA;
+			return;
 		}
 
 		/* transmit data to the USB bus */
@@ -952,25 +949,6 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 	if (devpriv->ao_timer < 1)
 		err |= -EINVAL;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continuous, use counter */
-		if (high_speed) {
-			/* high speed also scans everything at once */
-			devpriv->ao_sample_count = cmd->stop_arg *
-						   cmd->scan_end_arg;
-		} else {
-			/*
-			 * There's no scan as the scan has been
-			 * handled inside the FX2. Data arrives as
-			 * one packet.
-			 */
-			devpriv->ao_sample_count = cmd->stop_arg;
-		}
-	} else {
-		/* continuous acquisition */
-		devpriv->ao_sample_count = 0;
-	}
-
 	if (err)
 		return 4;
 

commit a7d3de75cf00574f8d360d51d0e1beb3c561cc89
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:21:54 2014 -0700

    staging: comedi: drivers do not need to reset the async->cur_chan
    
    The comedi core calls comedi_buf_reset() before starting an async command
    (*do_cmd) and after returning a subdevice to an idle state (*cancel).
    
    The drivers do not need to reset the async->cur_chan in those functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 7b7698c3ccd2..9ee6e0a78578 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -689,8 +689,6 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
 	for (i = 0; i < len; i++) {
 		unsigned int chan  = CR_CHAN(cmd->chanlist[i]);
 
@@ -988,9 +986,6 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
-
 	devpriv->ao_counter = devpriv->ao_timer;
 
 	if (cmd->start_src == TRIG_NOW) {

commit 504d0239f624a8cd65a2dbbcee6230014ada43d5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:44 2014 -0700

    staging: comedi: usbduxsigma: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the sample to the async buffer.
    That function will determining the number of bytes to add based on the
    bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index de3fb41b1886..7b7698c3ccd2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -245,8 +245,7 @@ static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
 			val &= 0x00ffffff;	/* strip status byte */
 			val ^= 0x00800000;	/* convert to unsigned */
 
-			if (!cfc_write_array_to_buffer(s, &val,
-						       sizeof(uint32_t)))
+			if (!comedi_buf_write_samples(s, &val, 1))
 				return;
 		}
 	}

commit e463fbe419b70744c7126ec198c6d6e2cffa5c87
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:46 2014 -0700

    staging: comedi: usbduxsigma: use comedi_buf_read_samples()
    
    Use comedi_buf_read_samples() to read the analog output samples from
    the async buffer. That function will set the COMEDI_CB_BLOCK event
    when samples are read from the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 1d12cc6c1ade..de3fb41b1886 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -374,7 +374,7 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
-			if (!comedi_buf_get(s, &val)) {
+			if (!comedi_buf_read_samples(s, &val, 1)) {
 				dev_err(dev->class_dev, "buffer underflow\n");
 				async->events |= COMEDI_CB_OVERFLOW;
 				return;
@@ -384,7 +384,6 @@ static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
 			*datap++ = chan;
 			s->readback[chan] = val;
 		}
-		async->events |= COMEDI_CB_BLOCK;
 	}
 
 	/* if command is still running, resubmit urb */

commit bcbb0c47c73dc19f19b78e849545cb4b030e94dd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 14 12:14:41 2014 -0700

    staging: comedi: usbduxsigma: introduce usbduxsigma_ai_handle_urb()
    
    Factor the urb handling and resubmit out of the analog input urb
    completion handler and tidy it up. This allows a common exit path
    to be used in the completion handler to stop the async command and
    handle the events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 985c6f08c56e..1d12cc6c1ade 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -211,23 +211,80 @@ static int usbduxsigma_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void usbduxsigma_ai_urb_complete(struct urb *urb)
+static void usbduxsigma_ai_handle_urb(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct urb *urb)
 {
-	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int dio_state;
 	uint32_t val;
 	int ret;
 	int i;
 
-	/* first we test if something unusual has just happened */
+	devpriv->ai_counter--;
+	if (devpriv->ai_counter == 0) {
+		devpriv->ai_counter = devpriv->ai_timer;
+
+		if (cmd->stop_src == TRIG_COUNT) {
+			devpriv->ai_sample_count--;
+			if (devpriv->ai_sample_count < 0) {
+				async->events |= COMEDI_CB_EOA;
+				return;
+			}
+		}
+
+		/* get the state of the dio pins to allow external trigger */
+		dio_state = be32_to_cpu(devpriv->in_buf[0]);
+
+		/* get the data from the USB bus and hand it over to comedi */
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			/* transfer data, note first byte is the DIO state */
+			val = be32_to_cpu(devpriv->in_buf[i+1]);
+			val &= 0x00ffffff;	/* strip status byte */
+			val ^= 0x00800000;	/* convert to unsigned */
+
+			if (!cfc_write_array_to_buffer(s, &val,
+						       sizeof(uint32_t)))
+				return;
+		}
+	}
+
+	/* if command is still running, resubmit urb */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		urb->dev = comedi_to_usb_dev(dev);
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
+			dev_err(dev->class_dev,
+				"%s: urb resubmit failed (%d)\n",
+				__func__, ret);
+			if (ret == -EL2NSYNC)
+				dev_err(dev->class_dev,
+					"buggy USB host controller or bug in IRQ handler\n");
+			async->events |= COMEDI_CB_ERROR;
+		}
+	}
+}
+
+static void usbduxsigma_ai_urb_complete(struct urb *urb)
+{
+	struct comedi_device *dev = urb->context;
+	struct usbduxsigma_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_async *async = s->async;
+
+	/* exit if not running a command, do not resubmit urb */
+	if (!devpriv->ai_cmd_running)
+		return;
+
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
 		memcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);
+		usbduxsigma_ai_handle_urb(dev, s, urb);
 		break;
+
 	case -EILSEQ:
 		/*
 		 * error in the ISOchronous data
@@ -235,7 +292,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 		 * and recycle the last data byte
 		 */
 		dev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");
-
+		usbduxsigma_ai_handle_urb(dev, s, urb);
 		break;
 
 	case -ECONNRESET:
@@ -243,86 +300,24 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
 		/* happens after an unlink command */
-		if (devpriv->ai_cmd_running) {
-			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
-			/* we are still running a command, tell comedi */
-			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
-			comedi_event(dev, s);
-		}
-		return;
+		async->events |= COMEDI_CB_ERROR;
+		break;
 
 	default:
-		/*
-		 * a real error on the bus
-		 * pass error to comedi if we are really running a command
-		 */
-		if (devpriv->ai_cmd_running) {
-			dev_err(dev->class_dev,
-				"%s: non-zero urb status (%d)\n",
-				__func__, urb->status);
-			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
-			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
-			comedi_event(dev, s);
-		}
-		return;
-	}
-
-	if (unlikely(!devpriv->ai_cmd_running))
-		return;
-
-	urb->dev = comedi_to_usb_dev(dev);
-
-	ret = usb_submit_urb(urb, GFP_ATOMIC);
-	if (unlikely(ret < 0)) {
-		dev_err(dev->class_dev, "%s: urb resubmit failed (%d)\n",
-			__func__, ret);
-		if (ret == -EL2NSYNC)
-			dev_err(dev->class_dev,
-				"buggy USB host controller or bug in IRQ handler\n");
-		usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
-		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
-		comedi_event(dev, s);
-		return;
-	}
-
-	/* get the state of the dio pins to allow external trigger */
-	dio_state = be32_to_cpu(devpriv->in_buf[0]);
-
-	devpriv->ai_counter--;
-	if (likely(devpriv->ai_counter > 0))
-		return;
-
-	/* timer zero, transfer measurements to comedi */
-	devpriv->ai_counter = devpriv->ai_timer;
-
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continuous, fixed number of samples */
-		devpriv->ai_sample_count--;
-		if (devpriv->ai_sample_count < 0) {
-			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
-			/* acquistion is over, tell comedi */
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
-			return;
-		}
+		/* a real error */
+		dev_err(dev->class_dev, "%s: non-zero urb status (%d)\n",
+			__func__, urb->status);
+		async->events |= COMEDI_CB_ERROR;
+		break;
 	}
 
-	/* get the data from the USB bus and hand it over to comedi */
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		/* transfer data, note first byte is the DIO state */
-		val = be32_to_cpu(devpriv->in_buf[i+1]);
-		val &= 0x00ffffff;	/* strip status byte */
-		val ^= 0x00800000;	/* convert to unsigned */
+	/*
+	 * comedi_handle_events() cannot be used in this driver. The (*cancel)
+	 * operation would unlink the urb.
+	 */
+	if (async->events & COMEDI_CB_CANCEL_MASK)
+		usbduxsigma_ai_stop(dev, 0);
 
-		ret = cfc_write_array_to_buffer(s, &val, sizeof(uint32_t));
-		if (unlikely(ret == 0)) {
-			/* buffer overflow */
-			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
-			return;
-		}
-	}
-	/* tell comedi that data is there */
-	s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
 	comedi_event(dev, s);
 }
 

commit 7a5dfb212010e017b8bbc91f8df196258f790f90
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 14 12:14:40 2014 -0700

    staging: comedi: usbduxsigma: introduce usbduxsigma_ao_handle_urb()
    
    Factor the urb handling and resubmit out of the analog output urb
    completion handler and tidy it up. This allows a common exit path
    to be used in the completion handler to stop the async command and
    handle the events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a869e38c777b..985c6f08c56e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -349,62 +349,25 @@ static int usbduxsigma_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void usbduxsigma_ao_urb_complete(struct urb *urb)
+static void usbduxsigma_ao_handle_urb(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct urb *urb)
 {
-	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->write_subdev;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	uint8_t *datap;
 	int ret;
 	int i;
 
-	switch (urb->status) {
-	case 0:
-		/* success */
-		break;
-
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-	case -ECONNABORTED:
-		/* happens after an unlink command */
-		if (devpriv->ao_cmd_running) {
-			usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(dev, s);
-		}
-		return;
-
-	default:
-		/* a real error */
-		if (devpriv->ao_cmd_running) {
-			dev_err(dev->class_dev,
-				"%s: non-zero urb status (%d)\n",
-				__func__, urb->status);
-			usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
-			s->async->events |= (COMEDI_CB_ERROR | COMEDI_CB_EOA);
-			comedi_event(dev, s);
-		}
-		return;
-	}
-
-	if (!devpriv->ao_cmd_running)
-		return;
-
 	devpriv->ao_counter--;
-	if ((int)devpriv->ao_counter <= 0) {
-		/* timer zero, transfer from comedi */
+	if (devpriv->ao_counter == 0) {
 		devpriv->ao_counter = devpriv->ao_timer;
 
 		if (cmd->stop_src == TRIG_COUNT) {
-			/* not continuous, fixed number of samples */
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
-				usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
-				/* acquistion is over, tell comedi */
-				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(dev, s);
+				async->events |= COMEDI_CB_EOA;
 				return;
 			}
 		}
@@ -416,44 +379,85 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
-			ret = comedi_buf_get(s, &val);
-			if (ret < 0) {
+			if (!comedi_buf_get(s, &val)) {
 				dev_err(dev->class_dev, "buffer underflow\n");
-				s->async->events |= (COMEDI_CB_EOA |
-						     COMEDI_CB_OVERFLOW);
+				async->events |= COMEDI_CB_OVERFLOW;
+				return;
 			}
+
 			*datap++ = val;
 			*datap++ = chan;
 			s->readback[chan] = val;
-
-			s->async->events |= COMEDI_CB_BLOCK;
-			comedi_event(dev, s);
 		}
+		async->events |= COMEDI_CB_BLOCK;
 	}
 
-	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = comedi_to_usb_dev(dev);
-	urb->status = 0;
-	if (devpriv->high_speed)
-		urb->interval = 8;	/* uframes */
-	else
-		urb->interval = 1;	/* frames */
-	urb->number_of_packets = 1;
-	urb->iso_frame_desc[0].offset = 0;
-	urb->iso_frame_desc[0].length = SIZEOUTBUF;
-	urb->iso_frame_desc[0].status = 0;
-	ret = usb_submit_urb(urb, GFP_ATOMIC);
-	if (ret < 0) {
-		dev_err(dev->class_dev,
-			"%s: urb resubmit failed (%d)\n",
-			__func__, ret);
-		if (ret == -EL2NSYNC)
+	/* if command is still running, resubmit urb */
+	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->dev = comedi_to_usb_dev(dev);
+		urb->status = 0;
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
+		urb->number_of_packets = 1;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].status = 0;
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
 			dev_err(dev->class_dev,
-				"buggy USB host controller or bug in IRQ handler\n");
-		usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
-		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
-		comedi_event(dev, s);
+				"%s: urb resubmit failed (%d)\n",
+				__func__, ret);
+			if (ret == -EL2NSYNC)
+				dev_err(dev->class_dev,
+					"buggy USB host controller or bug in IRQ handler\n");
+			async->events |= COMEDI_CB_ERROR;
+		}
+	}
+}
+
+static void usbduxsigma_ao_urb_complete(struct urb *urb)
+{
+	struct comedi_device *dev = urb->context;
+	struct usbduxsigma_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->write_subdev;
+	struct comedi_async *async = s->async;
+
+	/* exit if not running a command, do not resubmit urb */
+	if (!devpriv->ao_cmd_running)
+		return;
+
+	switch (urb->status) {
+	case 0:
+		usbduxsigma_ao_handle_urb(dev, s, urb);
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		/* happens after an unlink command */
+		async->events |= COMEDI_CB_ERROR;
+		break;
+
+	default:
+		/* a real error */
+		dev_err(dev->class_dev, "%s: non-zero urb status (%d)\n",
+			__func__, urb->status);
+		async->events |= COMEDI_CB_ERROR;
+		break;
 	}
+
+	/*
+	 * comedi_handle_events() cannot be used in this driver. The (*cancel)
+	 * operation would unlink the urb.
+	 */
+	if (async->events & COMEDI_CB_CANCEL_MASK)
+		usbduxsigma_ao_stop(dev, 0);
+
+	comedi_event(dev, s);
 }
 
 static int usbduxsigma_submit_urbs(struct comedi_device *dev,

commit a3f8c58d6ad69949ba2724b0992b6f2bff94a9a3
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Fri Oct 10 20:32:42 2014 +0100

    staging: comedi: usbduxsigma: updated contact details and status
    
    I've updated my contact details of the driver. I've also tested it
    thoroughly and it works perfectly. I've changed the status to stable.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ebd68e365bac..a869e38c777b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,6 +1,6 @@
 /*
  * usbduxsigma.c
- * Copyright (C) 2011 Bernd Porr, Bernd.Porr@f2s.com
+ * Copyright (C) 2011-2014 Bernd Porr, mail@berndporr.me.uk
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -17,9 +17,9 @@
  * Driver: usbduxsigma
  * Description: University of Stirling USB DAQ & INCITE Technology Limited
  * Devices: (ITL) USB-DUX [usbduxsigma]
- * Author: Bernd Porr <BerndPorr@f2s.com>
- * Updated: 8 Nov 2011
- * Status: testing
+ * Author: Bernd Porr <mail@berndporr.me.uk>
+ * Updated: 10 Oct 2014
+ * Status: stable
  */
 
 /*

commit aaa0c2f77bee1f0834d549e9ca937fb2ecb6cda1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:16:06 2014 -0700

    staging: comedi: usbduxsigma: prevent "empty acquisition" async commands
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0 for both the analog input and output async commands. The (*do_cmd) for
    both subdevices sets up and starts the command without handling the "empty
    acquisition". This results in the interrupt functions trying to transfer 0 data
    samples.
    
    Validate that the cmd->stop_arg is >= 1 in the (*do_cmdtest) to prevent the
    "empty acquisition".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5bad11857496..ebd68e365bac 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -558,12 +558,10 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;
@@ -935,12 +933,10 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;

commit a80f58c96d6dd8c7bf7ec33ca695c4fa6b956862
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Sun Aug 31 14:45:00 2014 -0500

    staging: comedi: usbduxsigma: fix more sparse endianness warnings
    
    Sparse shows a couple of warnings like:
    
    drivers/staging/comedi/drivers/usbduxsigma.c:787:23: warning: cast to restricted __be32
    
    Looking at the indicated lines shows that the issue is caused by an
    incorrect cast to uint32_t instead of __be32.  Fix this cast.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5dbab04d0ff9..5bad11857496 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -784,7 +784,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		}
 
 		/* 32 bits big endian from the A/D converter */
-		val = be32_to_cpu(get_unaligned((uint32_t
+		val = be32_to_cpu(get_unaligned((__be32
 						 *)(devpriv->insn_buf + 1)));
 		val &= 0x00ffffff;	/* strip status byte */
 		val ^= 0x00800000;	/* convert to unsigned */
@@ -1343,7 +1343,7 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 		return ret;
 
 	/* 32 bits big endian from the A/D converter */
-	val = be32_to_cpu(get_unaligned((uint32_t *)(devpriv->insn_buf + 1)));
+	val = be32_to_cpu(get_unaligned((__be32 *)(devpriv->insn_buf + 1)));
 	val &= 0x00ffffff;	/* strip status byte */
 	val ^= 0x00800000;	/* convert to unsigned */
 

commit b83d9fae0dd0557b75f22edf9da5c4bd7bcf73b2
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Fri Aug 29 20:40:55 2014 -0500

    staging: comedi: usbduxsigma: fix sparse endianness warnings
    
    Sparse has many warnings like:
    
    drivers/staging/comedi/drivers/usbduxsigma.c:293:21: warning: cast to
    restricted __be32
    
    on lines on which devpriv->in_buf is passed to be32_to_cpu().  This
    suggests that this variable should actually be of type __be32.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index fad099d5c58b..5dbab04d0ff9 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -155,7 +155,7 @@ struct usbduxsigma_private {
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	uint32_t *in_buf;
+	__be32 *in_buf;
 	/* input buffer for single insn */
 	uint8_t *insn_buf;
 

commit 58d10f32c4044a44ddf1e4762eeb72a1ac3fb3d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:17 2014 -0700

    staging: comedi: usbduxsigma: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a418be0aa822..fad099d5c58b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -75,8 +75,6 @@
 /* Number of channels (16 AD and offset)*/
 #define NUMCHANNELS 16
 
-#define USBDUXSIGMA_NUM_AO_CHAN		4
-
 /* Size of one A/D value */
 #define SIZEADIN          ((sizeof(uint32_t)))
 
@@ -161,8 +159,6 @@ struct usbduxsigma_private {
 	/* input buffer for single insn */
 	uint8_t *insn_buf;
 
-	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
-
 	unsigned high_speed:1;
 	unsigned ai_cmd_running:1;
 	unsigned ao_cmd_running:1;
@@ -428,7 +424,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 			}
 			*datap++ = val;
 			*datap++ = chan;
-			devpriv->ao_readback[chan] = val;
+			s->readback[chan] = val;
 
 			s->async->events |= COMEDI_CB_BLOCK;
 			comedi_event(dev, s);
@@ -806,15 +802,13 @@ static int usbduxsigma_ao_insn_read(struct comedi_device *dev,
 				    unsigned int *data)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
+	int ret;
 
 	down(&devpriv->sem);
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
+	ret = comedi_readback_insn_read(dev, s, insn, data);
 	up(&devpriv->sem);
 
-	return insn->n;
+	return ret;
 }
 
 static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
@@ -842,7 +836,7 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 			up(&devpriv->sem);
 			return ret;
 		}
-		devpriv->ao_readback[chan] = data[i];
+		s->readback[chan] = data[i];
 	}
 	up(&devpriv->sem);
 
@@ -1611,7 +1605,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	dev->write_subdev = s;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= USBDUXSIGMA_NUM_AO_CHAN;
+	s->n_chan	= 4;
 	s->len_chanlist	= s->n_chan;
 	s->maxdata	= 0x00ff;
 	s->range_table	= &range_unipolar2_5;
@@ -1621,6 +1615,10 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	s->do_cmd	= usbduxsigma_ao_cmd;
 	s->cancel	= usbduxsigma_ao_cancel;
 
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
 	s->type		= COMEDI_SUBD_DIO;

commit d77ac2c487a37da53e9dd4554a0d6ff1a210fdeb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:46 2014 -0700

    staging: comedi: usbduxsigma: fix kcalloc 'size' argument
    
    This code wants to allocate two arrays of struct urb pointers not two
    arrays of struct urb objects. The size argument for both kcalloc calls
    should be sizeof(urb) not sizeof(*urb).
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index da33b8c38d2e..a418be0aa822 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1437,10 +1437,8 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
 	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
-				   GFP_KERNEL);
-	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
-				   GFP_KERNEL);
+	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(urb), GFP_KERNEL);
+	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(urb), GFP_KERNEL);
 	if (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||
 	    !devpriv->ai_urbs || !devpriv->ao_urbs)
 		return -ENOMEM;

commit 3f15f7ccfca183d16e2a47f3a2920d118d7588b8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:45 2014 -0700

    staging: comedi: usbduxsigma: fix errno (EL2NSYNC) check
    
    These should both be checking the -errno.
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 94a09c16de8b..da33b8c38d2e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -451,7 +451,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 		dev_err(dev->class_dev,
 			"%s: urb resubmit failed (%d)\n",
 			__func__, ret);
-		if (ret == EL2NSYNC)
+		if (ret == -EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");
 		usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
@@ -1148,7 +1148,7 @@ static void usbduxsigma_pwm_urb_complete(struct urb *urb)
 	if (ret < 0) {
 		dev_err(dev->class_dev, "%s: urb resubmit failed (%d)\n",
 			__func__, ret);
-		if (ret == EL2NSYNC)
+		if (ret == -EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");
 		usbduxsigma_pwm_stop(dev, 0);	/* w/o unlink */

commit 182157e1e5c66e6e647a4f1be99a6c674008e20b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:36 2014 -0700

    staging: comedi: usbduxsigma: checkpatch.pl cleanup (else not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e869af4784c6..94a09c16de8b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1176,13 +1176,13 @@ static int usbduxsigma_pwm_period(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	int fx2delay = 255;
 
-	if (period < MIN_PWM_PERIOD) {
+	if (period < MIN_PWM_PERIOD)
 		return -EAGAIN;
-	} else {
-		fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
-		if (fx2delay > 255)
-			return -EAGAIN;
-	}
+
+	fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
+	if (fx2delay > 255)
+		return -EAGAIN;
+
 	devpriv->pwm_delay = fx2delay;
 	devpriv->pwm_period = period;
 	return 0;

commit 30c760c1e68b49e11a22ea0febe161e5eeb49530
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Tue Jul 1 22:14:42 2014 +0100

    staging: comedi: usbduxsigma: fixing rounding error in the range struct
    
    The AD converter on the usbsigma turns vref (2.5V/2) into the
    binary value 0x780000. However the full scale range goes up to
    0x800000 so that vref/2 needs to be upscaled by 0x800000/0x780000
    which is 1.06bar. In the driver it's been 1.06 without the infinite
    6666. I've put the fraction in the code so that the compiler can
    calculate the most precise scaling value by itself.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ccc3ef7ba55c..e869af4784c6 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -136,7 +136,7 @@
 
 static const struct comedi_lrange usbduxsigma_ai_range = {
 	1, {
-		BIP_RANGE(2.65 / 2.0)
+		BIP_RANGE(2.5 * 0x800000 / 0x780000 / 2.0)
 	}
 };
 

commit c2ccd69aba484ce6d8cfd174a5831a3eb547f2e9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:54 2014 -0700

    staging: comedi: usbduxsigma: use comedi_cmd pointer
    
    Use the local variable to access the comedi_cmd as a pointer instead
    of getting to it from the comedi_subdevice pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 13f5644ff3b6..ccc3ef7ba55c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -312,7 +312,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	}
 
 	/* get the data from the USB bus and hand it over to comedi */
-	for (i = 0; i < s->async->cmd.chanlist_len; i++) {
+	for (i = 0; i < cmd->chanlist_len; i++) {
 		/* transfer data, note first byte is the DIO state */
 		val = be32_to_cpu(devpriv->in_buf[i+1]);
 		val &= 0x00ffffff;	/* strip status byte */

commit d54e5e6bc5de032641486843a0df41ac3f7167ed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:44 2014 -0700

    staging: comedi: usbduxsigma: remove 'ao_chanlist' from private data
    
    This member of the private data is just a copy of the channels from
    the cmd->chanlist. Remove the member and just use the cmd->chanlist
    directly.
    
    Remove the unneeded 'len' local variable in usbduxsigma_ao_urb_complete().
    This is just the cmd->chanlist_len.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 6394f8b2f954..13f5644ff3b6 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -161,7 +161,6 @@ struct usbduxsigma_private {
 	/* input buffer for single insn */
 	uint8_t *insn_buf;
 
-	uint8_t ao_chanlist[USBDUXSIGMA_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
 
 	unsigned high_speed:1;
@@ -361,7 +360,6 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	uint8_t *datap;
-	int len;
 	int ret;
 	int i;
 
@@ -417,10 +415,9 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 
 		/* transmit data to the USB bus */
 		datap = urb->transfer_buffer;
-		len = s->async->cmd.chanlist_len;
-		*datap++ = len;
-		for (i = 0; i < len; i++) {
-			unsigned int chan = devpriv->ao_chanlist[i];
+		*datap++ = cmd->chanlist_len;
+		for (i = 0; i < cmd->chanlist_len; i++) {
+			unsigned int chan = CR_CHAN(cmd->chanlist[i]);
 			unsigned short val;
 
 			ret = comedi_buf_get(s, &val);
@@ -1001,14 +998,11 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
-	int i;
 
 	down(&devpriv->sem);
 
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
-	for (i = 0; i < cmd->chanlist_len; ++i)
-		devpriv->ao_chanlist[i] = CR_CHAN(cmd->chanlist[i]);
 
 	devpriv->ao_counter = devpriv->ao_timer;
 

commit 1b81dbc29b9a1ac6cb5c58217c181b675e91220c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:41 2014 -0700

    staging: comedi: usbduxsigma: remove 'ao_continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 05fb52e44b87..6394f8b2f954 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -167,7 +167,6 @@ struct usbduxsigma_private {
 	unsigned high_speed:1;
 	unsigned ai_cmd_running:1;
 	unsigned ao_cmd_running:1;
-	unsigned ao_continuous:1;
 	unsigned pwm_cmd_running:1;
 
 	/* number of samples to acquire */
@@ -360,6 +359,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	uint8_t *datap;
 	int len;
 	int ret;
@@ -403,7 +403,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 		/* timer zero, transfer from comedi */
 		devpriv->ao_counter = devpriv->ao_timer;
 
-		if (!devpriv->ao_continuous) {
+		if (cmd->stop_src == TRIG_COUNT) {
 			/* not continuous, fixed number of samples */
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
@@ -984,10 +984,8 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 			 */
 			devpriv->ao_sample_count = cmd->stop_arg;
 		}
-		devpriv->ao_continuous = 0;
 	} else {
 		/* continuous acquisition */
-		devpriv->ao_continuous = 1;
 		devpriv->ao_sample_count = 0;
 	}
 

commit fee5ba92cd5b00df49b19d4b014f5ff30bb67419
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:40 2014 -0700

    staging: comedi: usbduxsigma: remove 'ai_continuous' from private data
    
    This member of the private data can be determined from the cmd->stop_src.
    Do that instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 52b8b8fb9ee4..05fb52e44b87 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -166,7 +166,6 @@ struct usbduxsigma_private {
 
 	unsigned high_speed:1;
 	unsigned ai_cmd_running:1;
-	unsigned ai_continuous:1;
 	unsigned ao_cmd_running:1;
 	unsigned ao_continuous:1;
 	unsigned pwm_cmd_running:1;
@@ -223,6 +222,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int dio_state;
 	uint32_t val;
 	int ret;
@@ -301,7 +301,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	/* timer zero, transfer measurements to comedi */
 	devpriv->ai_counter = devpriv->ai_timer;
 
-	if (!devpriv->ai_continuous) {
+	if (cmd->stop_src == TRIG_COUNT) {
 		/* not continuous, fixed number of samples */
 		devpriv->ai_sample_count--;
 		if (devpriv->ai_sample_count < 0) {
@@ -596,10 +596,8 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* data arrives as one packet */
 		devpriv->ai_sample_count = cmd->stop_arg;
-		devpriv->ai_continuous = 0;
 	} else {
 		/* continuous acquisition */
-		devpriv->ai_continuous = 1;
 		devpriv->ai_sample_count = 0;
 	}
 

commit 458c13e935d9f33fffb099e49ecb53c67ddd1a21
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:00 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_get()
    
    Change the parameters of `comedi_buf_get()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function gets a sample value from the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b57c974e5cb6..52b8b8fb9ee4 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -423,7 +423,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 			unsigned int chan = devpriv->ao_chanlist[i];
 			unsigned short val;
 
-			ret = comedi_buf_get(s->async, &val);
+			ret = comedi_buf_get(s, &val);
 			if (ret < 0) {
 				dev_err(dev->class_dev, "buffer underflow\n");
 				s->async->events |= (COMEDI_CB_EOA |

commit b9b5b74eb3e3dc91bb7dc994dd2271b102a104cc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:08 2014 -0700

    staging: comedi: usbduxsigma: fix the ai/ao cmd->start_arg use for TRIG_INT
    
    For both ai and ao commands this driver supports a cmd->start_src of
    TRIG_NOW or TRIG_INT. The cmd->start_arg is trivially validated for
    both sources to be 0.
    
    For a TRIG_INT source, the cmd->start_arg is actually the valid
    trig_num that is used by the async (*inttrig) callback.
    
    Refactor the (*inttrig) functions so that the cmd->start_arg is used
    to check the trig_num instead of the open coded values.
    
    For aesthetics, remove some unnecessary comments in the (*do_cmd)
    functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 88c60b6020c4..b57c974e5cb6 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -663,12 +663,13 @@ static int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)
 
 static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  unsigned int trignum)
+				  unsigned int trig_num)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	down(&devpriv->sem);
@@ -738,7 +739,6 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 		}
 		s->async->inttrig = NULL;
 	} else {	/* TRIG_INT */
-		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ai_inttrig;
 	}
 
@@ -856,12 +856,13 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 
 static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  unsigned int trignum)
+				  unsigned int trig_num)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
-	if (trignum != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	down(&devpriv->sem);
@@ -1027,7 +1028,6 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 		}
 		s->async->inttrig = NULL;
 	} else {	/* TRIG_INT */
-		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ao_inttrig;
 	}
 

commit 791771e4e0587652e193ac8920e14911045a1dc8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Jan 21 17:39:05 2014 +0000

    staging: comedi: usbduxsigma: fix unaligned dereferences
    
    There are a couple of dereferences such as `*(uint32_t
    *)(devpriv->insn_buf + 1)` that are unaligned as `devpriv->insn_buf` is
    of type `uint8_t *`.  This works on x86 architecture but may not be
    supported on other architectures.  Call `get_unalign()` to perform the
    unaligned dereferences.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Bernd Porr <mail@berndporr.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 3beeb1254152..88c60b6020c4 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -48,6 +48,7 @@
 #include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
+#include <asm/unaligned.h>
 
 #include "comedi_fc.h"
 #include "../comedidev.h"
@@ -792,7 +793,8 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		}
 
 		/* 32 bits big endian from the A/D converter */
-		val = be32_to_cpu(*((uint32_t *)((devpriv->insn_buf) + 1)));
+		val = be32_to_cpu(get_unaligned((uint32_t
+						 *)(devpriv->insn_buf + 1)));
 		val &= 0x00ffffff;	/* strip status byte */
 		val ^= 0x00800000;	/* convert to unsigned */
 
@@ -1357,7 +1359,7 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 		return ret;
 
 	/* 32 bits big endian from the A/D converter */
-	val = be32_to_cpu(*((uint32_t *)((devpriv->insn_buf)+1)));
+	val = be32_to_cpu(get_unaligned((uint32_t *)(devpriv->insn_buf + 1)));
 	val &= 0x00ffffff;	/* strip status byte */
 	val ^= 0x00800000;	/* convert to unsigned */
 

commit 2783980525df12b9c49e8b4baaff06abc7f2f8f2
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Tue Jan 7 21:43:43 2014 +0000

    staging: comedi: usbduxsigma: removing unneccesay attached info
    
    Comedi core now reports that a device has been attached so that
    the driver itself won't need to do it any longer. The driver now
    just outputs the offset of the ADC converter which is a soft indicator
    of the health of the board and also the user can grep this value
    from the kernel log easier for debugging purposes.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ff521b3a07d0..3beeb1254152 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1661,7 +1661,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 		return offset;
 	}
 
-	dev_info(dev->class_dev, "attached, ADC_zero = %x\n", offset);
+	dev_info(dev->class_dev, "ADC_zero = %x\n", offset);
 
 	return 0;
 }

commit 7a45ae6edf808821a9799eccd9043177463aa05f
Author: Bernd Porr <mail@berndporr.me.uk>
Date:   Tue Jan 7 21:43:10 2014 +0000

    staging: comedi: usbduxsigma: return failure of auto attach
    
    The function usbduxsigma_getstatusinfo() returns a negative
    value in case there has been a communication error with
    the board. This should always work and if this communication
    fails then there is something seriously wrong with the board.
    This is now returned to the caller so that it can
    terminte the auto attachement. The return command also prevents
    printing out the offset value in case of a fault.
    
    Signed-off-by: Bernd Porr <mail@berndporr.me.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 194c686c5a42..ff521b3a07d0 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1655,9 +1655,11 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	}
 
 	offset = usbduxsigma_getstatusinfo(dev, 0);
-	if (offset < 0)
+	if (offset < 0) {
 		dev_err(dev->class_dev,
-			"Communication to USBDUXSIGMA failed! Check firmware and cabling\n");
+			"Communication to USBDUXSIGMA failed! Check firmware and cabling.\n");
+		return offset;
+	}
 
 	dev_info(dev->class_dev, "attached, ADC_zero = %x\n", offset);
 

commit 885a947e5b08953ebd5fce88be89a0399a7ab918
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Dec 10 15:23:48 2013 -0500

    staging: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a5363ded3668..194c686c5a42 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -43,7 +43,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/input.h>
 #include <linux/usb.h>

commit f1d376beae3376ce59470d23d05c57a64c7127ea
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:38 2013 +0100

    staging: comedi: usbduxsigma: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Use unsigned types consistently for handling comedi sample data and also
    for the USB data buffers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5618e61893da..a5363ded3668 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -78,7 +78,7 @@
 #define USBDUXSIGMA_NUM_AO_CHAN		4
 
 /* Size of one A/D value */
-#define SIZEADIN          ((sizeof(int32_t)))
+#define SIZEADIN          ((sizeof(uint32_t)))
 
 /*
  * Size of the async input-buffer IN BYTES, the DIO state is transmitted
@@ -93,7 +93,7 @@
 #define NUMOUTCHANNELS    8
 
 /* size of one value for the D/A converter: channel and value */
-#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(int16_t)))
+#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(uint16_t)))
 
 /*
  * Size of the output-buffer in bytes
@@ -157,11 +157,11 @@ struct usbduxsigma_private {
 	/* size of the PWM buffer which holds the bit pattern */
 	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	int32_t *in_buf;
+	uint32_t *in_buf;
 	/* input buffer for single insn */
-	int8_t *insn_buf;
+	uint8_t *insn_buf;
 
-	int8_t ao_chanlist[USBDUXSIGMA_NUM_AO_CHAN];
+	uint8_t ao_chanlist[USBDUXSIGMA_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
 
 	unsigned high_speed:1;
@@ -224,7 +224,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int dio_state;
-	int32_t val;
+	uint32_t val;
 	int ret;
 	int i;
 
@@ -421,7 +421,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 		*datap++ = len;
 		for (i = 0; i < len; i++) {
 			unsigned int chan = devpriv->ao_chanlist[i];
-			short val;
+			unsigned short val;
 
 			ret = comedi_buf_get(s->async, &val);
 			if (ret < 0) {
@@ -784,7 +784,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		int32_t val;
+		uint32_t val;
 
 		ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 		if (ret < 0) {
@@ -793,7 +793,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		}
 
 		/* 32 bits big endian from the A/D converter */
-		val = be32_to_cpu(*((int32_t *)((devpriv->insn_buf) + 1)));
+		val = be32_to_cpu(*((uint32_t *)((devpriv->insn_buf) + 1)));
 		val &= 0x00ffffff;	/* strip status byte */
 		val ^= 0x00800000;	/* convert to unsigned */
 
@@ -1358,7 +1358,7 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 		return ret;
 
 	/* 32 bits big endian from the A/D converter */
-	val = be32_to_cpu(*((int32_t *)((devpriv->insn_buf)+1)));
+	val = be32_to_cpu(*((uint32_t *)((devpriv->insn_buf)+1)));
 	val &= 0x00ffffff;	/* strip status byte */
 	val ^= 0x00800000;	/* convert to unsigned */
 

commit 77e9487bdbb7770b359aaa09e964fda57227ad97
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:38 2013 -0700

    staging: comedi: usbdux drivers: use comedi_dio_update_state()
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state.
    
    These drivers always need to update the hardware in order to update
    the i/o configuration regardless of if the state has changed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index c47f4087568f..5618e61893da 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1059,15 +1059,13 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 				     unsigned int *data)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
-	unsigned int mask = data[0];
-	unsigned int bits = data[1];
 	int ret;
 
 	down(&devpriv->sem);
 
-	s->state &= ~mask;
-	s->state |= (bits & mask);
+	comedi_dio_update_state(s, data);
 
+	/* Always update the hardware. See the (*insn_config). */
 	devpriv->dux_commands[1] = s->io_bits & 0xff;
 	devpriv->dux_commands[4] = s->state & 0xff;
 	devpriv->dux_commands[2] = (s->io_bits >> 8) & 0xff;

commit ddf62f2c7bd041d35095b525ab33e3a3e0829aaa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:32:33 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for simple cases
    
    Convert the drivers with simple, per channel programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these pass a 'mask' of '0' to comedi_dio_insn_config() this causes
    the per channel mask to be used to configure the i/o direction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index fca89c367a68..c47f4087568f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1040,23 +1040,11 @@ static int usbduxsigma_dio_insn_config(struct comedi_device *dev,
 				       struct comedi_insn *insn,
 				       unsigned int *data)
 {
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int mask = 1 << chan;
+	int ret;
 
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= mask;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~mask;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
+	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
+	if (ret)
+		return ret;
 
 	/*
 	 * We don't tell the firmware here as it would take 8 frames

commit 259ed07b6c391b10fd8ed8d3afe38c5b04bb7904
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:48:50 2013 -0700

    staging: comedi: usbduxsigma: absorb usbduxsigma_attach_common() into caller
    
    This function is only called by usbduxsigma_auto_attach(). Absorb it
    and refactor the code a bit to match the usbdux driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 60815a3ec540..fca89c367a68 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1379,90 +1379,6 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 	return (int)val;
 }
 
-static int usbduxsigma_attach_common(struct comedi_device *dev)
-{
-	struct usbduxsigma_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int n_subdevs;
-	int offset;
-	int ret;
-
-	down(&devpriv->sem);
-
-	if (devpriv->high_speed)
-		n_subdevs = 4;	/* with pwm */
-	else
-		n_subdevs = 3;	/* without pwm */
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
-	if (ret) {
-		up(&devpriv->sem);
-		return ret;
-	}
-
-	/* Analog Input subdevice */
-	s = &dev->subdevices[0];
-	dev->read_subdev = s;
-	s->type		= COMEDI_SUBD_AI;
-	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ | SDF_LSAMPL;
-	s->n_chan	= NUMCHANNELS;
-	s->len_chanlist	= NUMCHANNELS;
-	s->maxdata	= 0x00ffffff;
-	s->range_table	= &usbduxsigma_ai_range;
-	s->insn_read	= usbduxsigma_ai_insn_read;
-	s->do_cmdtest	= usbduxsigma_ai_cmdtest;
-	s->do_cmd	= usbduxsigma_ai_cmd;
-	s->cancel	= usbduxsigma_ai_cancel;
-
-	/* Analog Output subdevice */
-	s = &dev->subdevices[1];
-	dev->write_subdev = s;
-	s->type		= COMEDI_SUBD_AO;
-	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= USBDUXSIGMA_NUM_AO_CHAN;
-	s->len_chanlist	= s->n_chan;
-	s->maxdata	= 0x00ff;
-	s->range_table	= &range_unipolar2_5;
-	s->insn_write	= usbduxsigma_ao_insn_write;
-	s->insn_read	= usbduxsigma_ao_insn_read;
-	s->do_cmdtest	= usbduxsigma_ao_cmdtest;
-	s->do_cmd	= usbduxsigma_ao_cmd;
-	s->cancel	= usbduxsigma_ao_cancel;
-
-	/* Digital I/O subdevice */
-	s = &dev->subdevices[2];
-	s->type		= COMEDI_SUBD_DIO;
-	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
-	s->n_chan	= 24;
-	s->maxdata	= 1;
-	s->range_table	= &range_digital;
-	s->insn_bits	= usbduxsigma_dio_insn_bits;
-	s->insn_config	= usbduxsigma_dio_insn_config;
-
-	if (devpriv->high_speed) {
-		/* Timer / pwm subdevice */
-		s = &dev->subdevices[3];
-		s->type		= COMEDI_SUBD_PWM;
-		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan	= 8;
-		s->maxdata	= devpriv->pwm_buf_sz;
-		s->insn_write	= usbduxsigma_pwm_write;
-		s->insn_config	= usbduxsigma_pwm_config;
-
-		usbduxsigma_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
-	}
-
-	up(&devpriv->sem);
-
-	offset = usbduxsigma_getstatusinfo(dev, 0);
-	if (offset < 0)
-		dev_err(dev->class_dev,
-			"Communication to USBDUXSIGMA failed! Check firmware and cabling\n");
-
-	dev_info(dev->class_dev, "attached, ADC_zero = %x\n", offset);
-
-	return 0;
-}
-
 static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 				       const u8 *data, size_t size,
 				       unsigned long context)
@@ -1657,6 +1573,8 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *devpriv;
+	struct comedi_subdevice *s;
+	int offset;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -1664,17 +1582,9 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 
 	sema_init(&devpriv->sem, 1);
-	usb_set_intfdata(intf, devpriv);
 
-	ret = usb_set_interface(usb,
-				intf->altsetting->desc.bInterfaceNumber, 3);
-	if (ret < 0) {
-		dev_err(dev->class_dev,
-			"could not set alternate setting 3 in high speed\n");
-		return -ENODEV;
-	}
+	usb_set_intfdata(intf, devpriv);
 
-	/* test if it is high speed (USB 2.0) */
 	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
 	if (devpriv->high_speed) {
 		devpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;
@@ -1683,19 +1593,90 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	} else {
 		devpriv->n_ai_urbs = NUMOFINBUFFERSFULL;
 		devpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;
-		devpriv->pwm_buf_sz = 0;
 	}
 
 	ret = usbduxsigma_alloc_usb_buffers(dev);
 	if (ret)
 		return ret;
 
+	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
+	ret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,
+				3);
+	if (ret < 0) {
+		dev_err(dev->class_dev,
+			"could not set alternate setting 3 in high speed\n");
+		return ret;
+	}
+
 	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
 				   usbduxsigma_firmware_upload, 0);
 	if (ret)
 		return ret;
 
-	return usbduxsigma_attach_common(dev);
+	ret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 4 : 3);
+	if (ret)
+		return ret;
+
+	/* Analog Input subdevice */
+	s = &dev->subdevices[0];
+	dev->read_subdev = s;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ | SDF_LSAMPL;
+	s->n_chan	= NUMCHANNELS;
+	s->len_chanlist	= NUMCHANNELS;
+	s->maxdata	= 0x00ffffff;
+	s->range_table	= &usbduxsigma_ai_range;
+	s->insn_read	= usbduxsigma_ai_insn_read;
+	s->do_cmdtest	= usbduxsigma_ai_cmdtest;
+	s->do_cmd	= usbduxsigma_ai_cmd;
+	s->cancel	= usbduxsigma_ai_cancel;
+
+	/* Analog Output subdevice */
+	s = &dev->subdevices[1];
+	dev->write_subdev = s;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	s->n_chan	= USBDUXSIGMA_NUM_AO_CHAN;
+	s->len_chanlist	= s->n_chan;
+	s->maxdata	= 0x00ff;
+	s->range_table	= &range_unipolar2_5;
+	s->insn_write	= usbduxsigma_ao_insn_write;
+	s->insn_read	= usbduxsigma_ao_insn_read;
+	s->do_cmdtest	= usbduxsigma_ao_cmdtest;
+	s->do_cmd	= usbduxsigma_ao_cmd;
+	s->cancel	= usbduxsigma_ao_cancel;
+
+	/* Digital I/O subdevice */
+	s = &dev->subdevices[2];
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 24;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= usbduxsigma_dio_insn_bits;
+	s->insn_config	= usbduxsigma_dio_insn_config;
+
+	if (devpriv->high_speed) {
+		/* Timer / pwm subdevice */
+		s = &dev->subdevices[3];
+		s->type		= COMEDI_SUBD_PWM;
+		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan	= 8;
+		s->maxdata	= devpriv->pwm_buf_sz;
+		s->insn_write	= usbduxsigma_pwm_write;
+		s->insn_config	= usbduxsigma_pwm_config;
+
+		usbduxsigma_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+
+	offset = usbduxsigma_getstatusinfo(dev, 0);
+	if (offset < 0)
+		dev_err(dev->class_dev,
+			"Communication to USBDUXSIGMA failed! Check firmware and cabling\n");
+
+	dev_info(dev->class_dev, "attached, ADC_zero = %x\n", offset);
+
+	return 0;
 }
 
 static void usbduxsigma_detach(struct comedi_device *dev)

commit 1da439008e972ad3dfceca8a9ff4950db20f3528
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:47:44 2013 -0700

    staging: comedi: usbduxsigma: always clear the usb intfdata in (*detach)
    
    Make sure the usb intfdata is always cleared when the device is
    detached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 636209458a66..60815a3ec540 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1703,11 +1703,11 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
 
+	usb_set_intfdata(intf, NULL);
+
 	if (!devpriv)
 		return;
 
-	usb_set_intfdata(intf, NULL);
-
 	down(&devpriv->sem);
 
 	/* force unlink all urbs */

commit 71d7e1ee2c5505ffd2055eb36ab983e9cb52d5b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:47:26 2013 -0700

    staging: comedi: usbduxsigma: move urb unlink into usbduxsigma_detach()
    
    For aesthetics, move the final force unlink of the urbs from
    usbduxsigma_free_usb_buffers() to usbduxsigma_detach().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 68a3cd2bb173..636209458a66 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1621,11 +1621,6 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 	struct urb *urb;
 	int i;
 
-	/* force unlink all urbs */
-	usbduxsigma_ai_stop(dev, 1);
-	usbduxsigma_ao_stop(dev, 1);
-	usbduxsigma_pwm_stop(dev, 1);
-
 	urb = devpriv->pwm_urb;
 	if (urb) {
 		kfree(urb->transfer_buffer);
@@ -1714,7 +1709,14 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usb_set_intfdata(intf, NULL);
 
 	down(&devpriv->sem);
+
+	/* force unlink all urbs */
+	usbduxsigma_ai_stop(dev, 1);
+	usbduxsigma_ao_stop(dev, 1);
+	usbduxsigma_pwm_stop(dev, 1);
+
 	usbduxsigma_free_usb_buffers(dev);
+
 	up(&devpriv->sem);
 }
 

commit 1c379e94b38d5e575643212e6890de6a3380e6fe
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:47:06 2013 -0700

    staging: comedi: usbduxsigma: init 'pwm_buf_sz' in usbduxsigma_auto_attach()
    
    Initialize this variable with then_ai_urbs and n_ao_urbs in the
    attach. Then usbduxsigma_alloc_usb_buffers() can just check the
    variable to determine if the urb needs to be allocated.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index df563953fc26..68a3cd2bb173 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1600,19 +1600,16 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 			urb->interval = 1;	/* frames */
 	}
 
-	if (devpriv->high_speed) {
-		/* max bulk ep size in high speed */
-		devpriv->pwm_buf_sz = 512;
+	if (devpriv->pwm_buf_sz) {
 		urb = usb_alloc_urb(0, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
 		devpriv->pwm_urb = urb;
-		urb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz, GFP_KERNEL);
+
+		urb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,
+					       GFP_KERNEL);
 		if (!urb->transfer_buffer)
 			return -ENOMEM;
-	} else {
-		devpriv->pwm_urb = NULL;
-		devpriv->pwm_buf_sz = 0;
 	}
 
 	return 0;
@@ -1687,9 +1684,11 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	if (devpriv->high_speed) {
 		devpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;
 		devpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;
+		devpriv->pwm_buf_sz = 512;
 	} else {
 		devpriv->n_ai_urbs = NUMOFINBUFFERSFULL;
 		devpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;
+		devpriv->pwm_buf_sz = 0;
 	}
 
 	ret = usbduxsigma_alloc_usb_buffers(dev);

commit 315a276da9952f481edc2396deab455173dbaea8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:46:46 2013 -0700

    staging: comedi: usbduxsigma: 'dac_commands' does not need to be kzalloc()'d
    
    The 'dac_commands' buffer is used to pass the ao channel list from
    usbduxsigma_ao_cmd() to the urb callback, usbduxsigma_ao_urb_complete().
    This buffer does not need to be allocated.
    
    Change it into a simple array of the correct size. Rename the variable
    to 'ao_chanlist' to clarify what it actually is.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 660eec28540f..df563953fc26 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -161,6 +161,7 @@ struct usbduxsigma_private {
 	/* input buffer for single insn */
 	int8_t *insn_buf;
 
+	int8_t ao_chanlist[USBDUXSIGMA_NUM_AO_CHAN];
 	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
 
 	unsigned high_speed:1;
@@ -181,8 +182,6 @@ struct usbduxsigma_private {
 	unsigned int ao_counter;
 	/* interval in frames/uframes */
 	unsigned int ai_interval;
-	/* D/A commands */
-	uint8_t *dac_commands;
 	/* commands */
 	uint8_t *dux_commands;
 	struct semaphore sem;
@@ -421,7 +420,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 		len = s->async->cmd.chanlist_len;
 		*datap++ = len;
 		for (i = 0; i < len; i++) {
-			unsigned int chan = devpriv->dac_commands[i];
+			unsigned int chan = devpriv->ao_chanlist[i];
 			short val;
 
 			ret = comedi_buf_get(s->async, &val);
@@ -1011,7 +1010,7 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i)
-		devpriv->dac_commands[i] = CR_CHAN(cmd->chanlist[i]);
+		devpriv->ao_chanlist[i] = CR_CHAN(cmd->chanlist[i]);
 
 	devpriv->ao_counter = devpriv->ao_timer;
 
@@ -1542,7 +1541,6 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 	struct urb *urb;
 	int i;
 
-	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
 	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
@@ -1550,8 +1548,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 				   GFP_KERNEL);
 	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
 				   GFP_KERNEL);
-	if (!devpriv->dac_commands || !devpriv->dux_commands ||
-	    !devpriv->in_buf || !devpriv->insn_buf ||
+	if (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||
 	    !devpriv->ai_urbs || !devpriv->ao_urbs)
 		return -ENOMEM;
 
@@ -1660,7 +1657,6 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 	kfree(devpriv->insn_buf);
 	kfree(devpriv->in_buf);
 	kfree(devpriv->dux_commands);
-	kfree(devpriv->dac_commands);
 }
 
 static int usbduxsigma_auto_attach(struct comedi_device *dev,

commit aa25b91304bbca0c79c6b1d736236cd2f817ca03
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:46:07 2013 -0700

    staging: comedi: usbduxsigma: return void from usbduxsigma_pwm_pattern()
    
    This function never fails and currently returns '1' so that the
    usbduxsigma_pwm_write() function returns to proper value (insn->n).
    
    It's also called by usbduxsigma_pwm_config() which also returns the
    '1' value. The proper return code for this function should be '0' to
    indicate success.
    
    Change the return type of the function to void and just have the
    callers return the proper values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ca6d9528f8cb..660eec28540f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1238,11 +1238,11 @@ static int usbduxsigma_pwm_start(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxsigma_pwm_pattern(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   unsigned int chan,
-				   unsigned int value,
-				   unsigned int sign)
+static void usbduxsigma_pwm_pattern(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    unsigned int chan,
+				    unsigned int value,
+				    unsigned int sign)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 	char pwm_mask = (1 << chan);	/* DIO bit for the PWM data */
@@ -1263,7 +1263,6 @@ static int usbduxsigma_pwm_pattern(struct comedi_device *dev,
 			c |= sgn_mask;
 		*buf++ = c;
 	}
-	return 1;
 }
 
 static int usbduxsigma_pwm_write(struct comedi_device *dev,
@@ -1284,7 +1283,9 @@ static int usbduxsigma_pwm_write(struct comedi_device *dev,
 	 * The sign is set via a special INSN only, this gives us 8 bits
 	 * for normal operation, sign is 0 by default.
 	 */
-	return usbduxsigma_pwm_pattern(dev, s, chan, data[0], 0);
+	usbduxsigma_pwm_pattern(dev, s, chan, data[0], 0);
+
+	return insn->n;
 }
 
 static int usbduxsigma_pwm_config(struct comedi_device *dev,
@@ -1319,8 +1320,8 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 		 * data[1] = value
 		 * data[2] = sign (for a relay)
 		 */
-		return usbduxsigma_pwm_pattern(dev, s, chan,
-					       data[1], (data[2] != 0));
+		usbduxsigma_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));
+		return 0;
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
 		/* values are not kept in this driver, nothing to return */
 		return -EINVAL;

commit b509a76aff183e5b12858da6feaf4f896cf2af09
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:43:55 2013 -0700

    staging: comedi: usbduxsigma: remove the usb endpoint defines
    
    The endpoint defines are each only used in one place and don't help
    clarify the code. Remove the defines and just open code the values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b31e400faf45..ca6d9528f8cb 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -66,13 +66,6 @@
 /* internal addresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
 
-/* USB endpoints */
-#define USBDUXSIGMA_CMD_OUT_EP		1	/* command output */
-#define USBDUXSIGMA_ISO_OUT_EP		2	/* analog output ISO/IRQ */
-#define USBDUXSIGMA_PWM_OUT_EP		4	/* pwm output */
-#define USBDUXSIGMA_ISO_IN_EP		6	/* analog input ISO/IRQ */
-#define USBDUXSIGMA_CMD_IN_EP		8	/* command input */
-
 /* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
 
@@ -639,7 +632,7 @@ static int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)
 
 	devpriv->dux_commands[0] = cmd_type;
 
-	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, USBDUXSIGMA_CMD_OUT_EP),
+	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),
 			    devpriv->dux_commands, SIZEOFDUXBUFFER,
 			    &nsent, BULK_TIMEOUT);
 }
@@ -653,8 +646,7 @@ static int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		ret = usb_bulk_msg(usb,
-				   usb_rcvbulkpipe(usb, USBDUXSIGMA_CMD_IN_EP),
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),
 				   devpriv->insn_buf, SIZEINSNBUF,
 				   &nrec, BULK_TIMEOUT);
 		if (ret < 0)
@@ -1194,8 +1186,7 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 	struct urb *urb = devpriv->pwm_urb;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(urb,
-			  usb, usb_sndbulkpipe(usb, USBDUXSIGMA_PWM_OUT_EP),
+	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),
 			  urb->transfer_buffer, devpriv->pwm_buf_sz,
 			  usbduxsigma_pwm_urb_complete, dev);
 
@@ -1573,7 +1564,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(usb, USBDUXSIGMA_ISO_IN_EP);
+		urb->pipe = usb_rcvisocpipe(usb, 6);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
@@ -1595,7 +1586,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(usb, USBDUXSIGMA_ISO_OUT_EP);
+		urb->pipe = usb_sndisocpipe(usb, 2);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)

commit e0bc079c669a9b6f438f8801da5fc04947323b45
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 29 17:43:36 2013 -0700

    staging: comedi: usbduxsigma: generalize the ai/ao usb_kill_urb()
    
    Generalize a helper function to replace for() loops in usbduxsigma_{ai,ao}_stop()
    that call usb_kill_urb() to unlink all the urbs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 1af235407eb4..b31e400faf45 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -195,18 +195,20 @@ struct usbduxsigma_private {
 	struct semaphore sem;
 };
 
+static void usbduxsigma_unlink_urbs(struct urb **urbs, int num_urbs)
+{
+	int i;
+
+	for (i = 0; i < num_urbs; i++)
+		usb_kill_urb(urbs[i]);
+}
+
 static void usbduxsigma_ai_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
-	if (do_unlink) {
-		int i;
-
-		for (i = 0; i < devpriv->n_ai_urbs; i++) {
-			if (devpriv->ai_urbs[i])
-				usb_kill_urb(devpriv->ai_urbs[i]);
-		}
-	}
+	if (do_unlink && devpriv->ai_urbs)
+		usbduxsigma_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);
 
 	devpriv->ai_cmd_running = 0;
 }
@@ -342,14 +344,8 @@ static void usbduxsigma_ao_stop(struct comedi_device *dev, int do_unlink)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
-	if (do_unlink) {
-		int i;
-
-		for (i = 0; i < devpriv->n_ao_urbs; i++) {
-			if (devpriv->ao_urbs[i])
-				usb_kill_urb(devpriv->ao_urbs[i]);
-		}
-	}
+	if (do_unlink && devpriv->ao_urbs)
+		usbduxsigma_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);
 
 	devpriv->ao_cmd_running = 0;
 }

commit 9c922a9076afd9e483bc17d768ed813d2f76f7cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 25 16:21:13 2013 -0700

    staging: comedi: usbduxsigma: set *_cmd_running flags before submitting urbs
    
    As pointed out by Ian Abbott, the *_cmd_running flags should be set
    before submitting the urbs. There is a possible race condition where
    an urb could complete and the flag is checked in the completion
    routine before it's set.
    
    Reported-by: Ian Abbott <abbotti@mev.co.uk>
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 40eeb8c68306..1af235407eb4 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -686,13 +686,14 @@ static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	if (!devpriv->ai_cmd_running) {
+		devpriv->ai_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,
 					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
+			devpriv->ai_cmd_running = 0;
 			up(&devpriv->sem);
 			return ret;
 		}
-		devpriv->ai_cmd_running = 1;
 		s->async->inttrig = NULL;
 	}
 	up(&devpriv->sem);
@@ -740,14 +741,15 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
+		devpriv->ai_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,
 					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
+			devpriv->ai_cmd_running = 0;
 			up(&devpriv->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
-		devpriv->ai_cmd_running = 1;
 	} else {	/* TRIG_INT */
 		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ai_inttrig;
@@ -876,13 +878,14 @@ static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	if (!devpriv->ao_cmd_running) {
+		devpriv->ao_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,
 					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
+			devpriv->ao_cmd_running = 0;
 			up(&devpriv->sem);
 			return ret;
 		}
-		devpriv->ao_cmd_running = 1;
 		s->async->inttrig = NULL;
 	}
 	up(&devpriv->sem);
@@ -1026,14 +1029,15 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
+		devpriv->ao_cmd_running = 1;
 		ret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,
 					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
+			devpriv->ao_cmd_running = 0;
 			up(&devpriv->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
-		devpriv->ao_cmd_running = 1;
 	} else {	/* TRIG_INT */
 		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ao_inttrig;
@@ -1237,10 +1241,12 @@ static int usbduxsigma_pwm_start(struct comedi_device *dev,
 
 	memset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);
 
+	devpriv->pwm_cmd_running = 1;
 	ret = usbduxsigma_submit_pwm_urb(dev);
-	if (ret < 0)
+	if (ret < 0) {
+		devpriv->pwm_cmd_running = 0;
 		return ret;
-	devpriv->pwm_cmd_running = 1;
+	}
 
 	return 0;
 }

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 898c3c450406..40eeb8c68306 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1677,10 +1677,9 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
 	usb_set_intfdata(intf, devpriv);

commit 31de28ab35cfd955dbd3495378486df5769aed73
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:09:45 2013 -0700

    staging: comedi: usbduxsigma: tidy up the multi-line comments
    
    Modify the multi-line comments to follow the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b42ef8cdf7a4..898c3c450406 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,25 +1,27 @@
 /*
-   comedi/drivers/usbdux.c
-   Copyright (C) 2011 Bernd Porr, Bernd.Porr@f2s.com
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+ * usbduxsigma.c
+ * Copyright (C) 2011 Bernd Porr, Bernd.Porr@f2s.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
+
 /*
-Driver: usbduxsigma
-Description: University of Stirling USB DAQ & INCITE Technology Limited
-Devices: [ITL] USB-DUX (usbduxsigma.o)
-Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 8 Nov 2011
-Status: testing
-*/
+ * Driver: usbduxsigma
+ * Description: University of Stirling USB DAQ & INCITE Technology Limited
+ * Devices: (ITL) USB-DUX [usbduxsigma]
+ * Author: Bernd Porr <BerndPorr@f2s.com>
+ * Updated: 8 Nov 2011
+ * Status: testing
+ */
+
 /*
  * I must give credit here to Chris Baugher who
  * wrote the driver for AT-MIO-16d. I used some parts of this

commit 57ded31567b623e23c5467b9b6da1443258a4704
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:09:25 2013 -0700

    staging: comedi: usbduxsigma: remove a space before tab
    
    checkpatch.pl reports:
    
    WARNING: please, no space before tabs
    +^Ihigh_speed = 0; ^I/* (devpriv->high_speed) */$
    
    Remove the space to avoid the warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a5883be7b48b..b42ef8cdf7a4 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -898,7 +898,7 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 	unsigned int flags;
 
 	/* high speed conversions are not used yet */
-	high_speed = 0; 	/* (devpriv->high_speed) */
+	high_speed = 0;		/* (devpriv->high_speed) */
 
 	/* Step 1 : check if triggers are trivially valid */
 

commit fffe8239f51342f2c7ef7aa0f56bf6f210be258b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:09:08 2013 -0700

    staging: comedi: usbduxsigma: tidy up chanToInterval()
    
    Rename the function to have namespace associated with the driver.
    Rename the CamelCase parameter 'nChannels' to avoid the checkpatch.pl
    warning.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e070477ce532..a5883be7b48b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -502,16 +502,13 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 	return 0;
 }
 
-static int chanToInterval(int nChannels)
+static int usbduxsigma_chans_to_interval(int num_chan)
 {
-	if (nChannels <= 2)
-		/* 4kHz */
-		return 2;
-	if (nChannels <= 8)
-		/* 2kHz */
-		return 4;
-	/* 1kHz */
-	return 8;
+	if (num_chan <= 2)
+		return 2;	/* 4kHz */
+	if (num_chan <= 8)
+		return 4;	/* 2kHz */
+	return 8;		/* 1kHz */
 }
 
 static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
@@ -520,7 +517,7 @@ static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 	int high_speed = devpriv->high_speed;
-	int interval = chanToInterval(cmd->chanlist_len);
+	int interval = usbduxsigma_chans_to_interval(cmd->chanlist_len);
 	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */

commit 7333d50b8adbb162b511950f8ba90900c99940e0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:08:51 2013 -0700

    staging: comedi: usbduxsigma: add missing spaces reported by checkpatch.pl
    
    checkpatch.pl reports:
    
    ERROR: space required after that ',' (ctx:VxV)
    +               dev_dbg(dev->class_dev,"CRC error in ISO IN stream\n");
                                          ^
    
    ERROR: spaces required around that '=' (ctx:VxW)
    +       struct usbduxsigma_private *devpriv= dev->private;
                                               ^
    Add the missing spaces to avoid the error.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ee2b0ba9ba7c..e070477ce532 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -244,7 +244,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 		 * we don't copy the data into the transfer buffer
 		 * and recycle the last data byte
 		 */
-		dev_dbg(dev->class_dev,"CRC error in ISO IN stream\n");
+		dev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");
 
 		break;
 
@@ -679,7 +679,7 @@ static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  unsigned int trignum)
 {
-	struct usbduxsigma_private *devpriv= dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	int ret;
 
 	if (trignum != 0)

commit aae2f26713b5ce60c378c84f2723eef06270c56d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:08:33 2013 -0700

    staging: comedi: usbduxsigma: rename CamelCase vars in private data
    
    Rename the CamelCase variables in the private data to avoid the
    checkpatch.pl warning.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 34a63695f55e..ee2b0ba9ba7c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -147,24 +147,24 @@ static const struct comedi_lrange usbduxsigma_ai_range = {
 
 struct usbduxsigma_private {
 	/* actual number of in-buffers */
-	int numOfInBuffers;
+	int n_ai_urbs;
 	/* actual number of out-buffers */
-	int numOfOutBuffers;
+	int n_ao_urbs;
 	/* ISO-transfer handling: buffers */
-	struct urb **urbIn;
-	struct urb **urbOut;
+	struct urb **ai_urbs;
+	struct urb **ao_urbs;
 	/* pwm-transfer handling */
-	struct urb *urbPwm;
+	struct urb *pwm_urb;
 	/* PWM period */
-	unsigned int pwmPeriod;
+	unsigned int pwm_period;
 	/* PWM internal delay for the GPIF in the FX2 */
-	uint8_t pwmDelay;
+	uint8_t pwm_delay;
 	/* size of the PWM buffer which holds the bit pattern */
-	int sizePwmBuf;
+	int pwm_buf_sz;
 	/* input buffer for the ISO-transfer */
-	int32_t *inBuffer;
+	int32_t *in_buf;
 	/* input buffer for single insn */
-	int8_t *insnBuffer;
+	int8_t *insn_buf;
 
 	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
 
@@ -200,9 +200,9 @@ static void usbduxsigma_ai_stop(struct comedi_device *dev, int do_unlink)
 	if (do_unlink) {
 		int i;
 
-		for (i = 0; i < devpriv->numOfInBuffers; i++) {
-			if (devpriv->urbIn[i])
-				usb_kill_urb(devpriv->urbIn[i]);
+		for (i = 0; i < devpriv->n_ai_urbs; i++) {
+			if (devpriv->ai_urbs[i])
+				usb_kill_urb(devpriv->ai_urbs[i]);
 		}
 	}
 
@@ -236,7 +236,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
-		memcpy(devpriv->inBuffer, urb->transfer_buffer, SIZEINBUF);
+		memcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
 		/*
@@ -296,7 +296,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	}
 
 	/* get the state of the dio pins to allow external trigger */
-	dio_state = be32_to_cpu(devpriv->inBuffer[0]);
+	dio_state = be32_to_cpu(devpriv->in_buf[0]);
 
 	devpriv->ai_counter--;
 	if (likely(devpriv->ai_counter > 0))
@@ -320,7 +320,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	/* get the data from the USB bus and hand it over to comedi */
 	for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 		/* transfer data, note first byte is the DIO state */
-		val = be32_to_cpu(devpriv->inBuffer[i+1]);
+		val = be32_to_cpu(devpriv->in_buf[i+1]);
 		val &= 0x00ffffff;	/* strip status byte */
 		val ^= 0x00800000;	/* convert to unsigned */
 
@@ -343,9 +343,9 @@ static void usbduxsigma_ao_stop(struct comedi_device *dev, int do_unlink)
 	if (do_unlink) {
 		int i;
 
-		for (i = 0; i < devpriv->numOfOutBuffers; i++) {
-			if (devpriv->urbOut[i])
-				usb_kill_urb(devpriv->urbOut[i]);
+		for (i = 0; i < devpriv->n_ao_urbs; i++) {
+			if (devpriv->ao_urbs[i])
+				usb_kill_urb(devpriv->ao_urbs[i]);
 		}
 	}
 
@@ -660,12 +660,12 @@ static int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)
 	for (i = 0; i < RETRIES; i++) {
 		ret = usb_bulk_msg(usb,
 				   usb_rcvbulkpipe(usb, USBDUXSIGMA_CMD_IN_EP),
-				   devpriv->insnBuffer, SIZEINSNBUF,
+				   devpriv->insn_buf, SIZEINSNBUF,
 				   &nrec, BULK_TIMEOUT);
 		if (ret < 0)
 			return ret;
 
-		if (devpriv->insnBuffer[0] == command)
+		if (devpriv->insn_buf[0] == command)
 			return 0;
 	}
 	/*
@@ -687,8 +687,8 @@ static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	if (!devpriv->ai_cmd_running) {
-		ret = usbduxsigma_submit_urbs(dev, devpriv->urbIn,
-					      devpriv->numOfInBuffers, 1);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,
+					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -741,8 +741,8 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		ret = usbduxsigma_submit_urbs(dev, devpriv->urbIn,
-					      devpriv->numOfInBuffers, 1);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,
+					      devpriv->n_ai_urbs, 1);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -805,7 +805,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 		}
 
 		/* 32 bits big endian from the A/D converter */
-		val = be32_to_cpu(*((int32_t *)((devpriv->insnBuffer) + 1)));
+		val = be32_to_cpu(*((int32_t *)((devpriv->insn_buf) + 1)));
 		val &= 0x00ffffff;	/* strip status byte */
 		val ^= 0x00800000;	/* convert to unsigned */
 
@@ -877,8 +877,8 @@ static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	if (!devpriv->ao_cmd_running) {
-		ret = usbduxsigma_submit_urbs(dev, devpriv->urbOut,
-					      devpriv->numOfOutBuffers, 0);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,
+					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -1027,8 +1027,8 @@ static int usbduxsigma_ao_cmd(struct comedi_device *dev,
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		ret = usbduxsigma_submit_urbs(dev, devpriv->urbOut,
-					      devpriv->numOfOutBuffers, 0);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,
+					      devpriv->n_ao_urbs, 0);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -1104,9 +1104,9 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 	if (ret < 0)
 		goto done;
 
-	s->state = devpriv->insnBuffer[1] |
-		   (devpriv->insnBuffer[2] << 8) |
-		   (devpriv->insnBuffer[3] << 16);
+	s->state = devpriv->insn_buf[1] |
+		   (devpriv->insn_buf[2] << 8) |
+		   (devpriv->insn_buf[3] << 16);
 
 	data[1] = s->state;
 	ret = insn->n;
@@ -1122,8 +1122,8 @@ static void usbduxsigma_pwm_stop(struct comedi_device *dev, int do_unlink)
 	struct usbduxsigma_private *devpriv = dev->private;
 
 	if (do_unlink) {
-		if (devpriv->urbPwm)
-			usb_kill_urb(devpriv->urbPwm);
+		if (devpriv->pwm_urb)
+			usb_kill_urb(devpriv->pwm_urb);
 	}
 
 	devpriv->pwm_cmd_running = 0;
@@ -1174,7 +1174,7 @@ static void usbduxsigma_pwm_urb_complete(struct urb *urb)
 	if (!devpriv->pwm_cmd_running)
 		return;
 
-	urb->transfer_buffer_length = devpriv->sizePwmBuf;
+	urb->transfer_buffer_length = devpriv->pwm_buf_sz;
 	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1192,12 +1192,12 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
-	struct urb *urb = devpriv->urbPwm;
+	struct urb *urb = devpriv->pwm_urb;
 
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(urb,
 			  usb, usb_sndbulkpipe(usb, USBDUXSIGMA_PWM_OUT_EP),
-			  urb->transfer_buffer, devpriv->sizePwmBuf,
+			  urb->transfer_buffer, devpriv->pwm_buf_sz,
 			  usbduxsigma_pwm_urb_complete, dev);
 
 	return usb_submit_urb(urb, GFP_ATOMIC);
@@ -1217,8 +1217,8 @@ static int usbduxsigma_pwm_period(struct comedi_device *dev,
 		if (fx2delay > 255)
 			return -EAGAIN;
 	}
-	devpriv->pwmDelay = fx2delay;
-	devpriv->pwmPeriod = period;
+	devpriv->pwm_delay = fx2delay;
+	devpriv->pwm_period = period;
 	return 0;
 }
 
@@ -1231,12 +1231,12 @@ static int usbduxsigma_pwm_start(struct comedi_device *dev,
 	if (devpriv->pwm_cmd_running)
 		return 0;
 
-	devpriv->dux_commands[1] = devpriv->pwmDelay;
+	devpriv->dux_commands[1] = devpriv->pwm_delay;
 	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_ON_CMD);
 	if (ret < 0)
 		return ret;
 
-	memset(devpriv->urbPwm->transfer_buffer, 0, devpriv->sizePwmBuf);
+	memset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);
 
 	ret = usbduxsigma_submit_pwm_urb(dev);
 	if (ret < 0)
@@ -1255,8 +1255,8 @@ static int usbduxsigma_pwm_pattern(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 	char pwm_mask = (1 << chan);	/* DIO bit for the PWM data */
 	char sgn_mask = (16 << chan);	/* DIO bit for the sign */
-	char *buf = (char *)(devpriv->urbPwm->transfer_buffer);
-	int szbuf = devpriv->sizePwmBuf;
+	char *buf = (char *)(devpriv->pwm_urb->transfer_buffer);
+	int szbuf = devpriv->pwm_buf_sz;
 	int i;
 
 	for (i = 0; i < szbuf; i++) {
@@ -1320,7 +1320,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 	case INSN_CONFIG_PWM_SET_PERIOD:
 		return usbduxsigma_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
-		data[1] = devpriv->pwmPeriod;
+		data[1] = devpriv->pwm_period;
 		return 0;
 	case INSN_CONFIG_PWM_SET_H_BRIDGE:
 		/*
@@ -1380,7 +1380,7 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 		return ret;
 
 	/* 32 bits big endian from the A/D converter */
-	val = be32_to_cpu(*((int32_t *)((devpriv->insnBuffer)+1)));
+	val = be32_to_cpu(*((int32_t *)((devpriv->insn_buf)+1)));
 	val &= 0x00ffffff;	/* strip status byte */
 	val ^= 0x00800000;	/* convert to unsigned */
 
@@ -1452,7 +1452,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		s->type		= COMEDI_SUBD_PWM;
 		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan	= 8;
-		s->maxdata	= devpriv->sizePwmBuf;
+		s->maxdata	= devpriv->pwm_buf_sz;
 		s->insn_write	= usbduxsigma_pwm_write;
 		s->insn_config	= usbduxsigma_pwm_config;
 
@@ -1551,23 +1551,23 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 
 	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	devpriv->inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	devpriv->insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	devpriv->urbIn = kcalloc(devpriv->numOfInBuffers, sizeof(*urb),
-				 GFP_KERNEL);
-	devpriv->urbOut = kcalloc(devpriv->numOfOutBuffers, sizeof(*urb),
-				  GFP_KERNEL);
+	devpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);
+	devpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	devpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(*urb),
+				   GFP_KERNEL);
+	devpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(*urb),
+				   GFP_KERNEL);
 	if (!devpriv->dac_commands || !devpriv->dux_commands ||
-	    !devpriv->inBuffer || !devpriv->insnBuffer ||
-	    !devpriv->urbIn || !devpriv->urbOut)
+	    !devpriv->in_buf || !devpriv->insn_buf ||
+	    !devpriv->ai_urbs || !devpriv->ao_urbs)
 		return -ENOMEM;
 
-	for (i = 0; i < devpriv->numOfInBuffers; i++) {
+	for (i = 0; i < devpriv->n_ai_urbs; i++) {
 		/* one frame: 1ms */
 		urb = usb_alloc_urb(1, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urbIn[i] = urb;
+		devpriv->ai_urbs[i] = urb;
 		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
@@ -1584,12 +1584,12 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		urb->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
-	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
+	for (i = 0; i < devpriv->n_ao_urbs; i++) {
 		/* one frame: 1ms */
 		urb = usb_alloc_urb(1, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urbOut[i] = urb;
+		devpriv->ao_urbs[i] = urb;
 		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
@@ -1612,17 +1612,17 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 
 	if (devpriv->high_speed) {
 		/* max bulk ep size in high speed */
-		devpriv->sizePwmBuf = 512;
+		devpriv->pwm_buf_sz = 512;
 		urb = usb_alloc_urb(0, GFP_KERNEL);
 		if (!urb)
 			return -ENOMEM;
-		devpriv->urbPwm = urb;
-		urb->transfer_buffer = kzalloc(devpriv->sizePwmBuf, GFP_KERNEL);
+		devpriv->pwm_urb = urb;
+		urb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz, GFP_KERNEL);
 		if (!urb->transfer_buffer)
 			return -ENOMEM;
 	} else {
-		devpriv->urbPwm = NULL;
-		devpriv->sizePwmBuf = 0;
+		devpriv->pwm_urb = NULL;
+		devpriv->pwm_buf_sz = 0;
 	}
 
 	return 0;
@@ -1639,33 +1639,33 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 	usbduxsigma_ao_stop(dev, 1);
 	usbduxsigma_pwm_stop(dev, 1);
 
-	urb = devpriv->urbPwm;
+	urb = devpriv->pwm_urb;
 	if (urb) {
 		kfree(urb->transfer_buffer);
 		usb_free_urb(urb);
 	}
-	if (devpriv->urbOut) {
-		for (i = 0; i < devpriv->numOfOutBuffers; i++) {
-			urb = devpriv->urbOut[i];
+	if (devpriv->ao_urbs) {
+		for (i = 0; i < devpriv->n_ao_urbs; i++) {
+			urb = devpriv->ao_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
 				usb_free_urb(urb);
 			}
 		}
-		kfree(devpriv->urbOut);
+		kfree(devpriv->ao_urbs);
 	}
-	if (devpriv->urbIn) {
-		for (i = 0; i < devpriv->numOfInBuffers; i++) {
-			urb = devpriv->urbIn[i];
+	if (devpriv->ai_urbs) {
+		for (i = 0; i < devpriv->n_ai_urbs; i++) {
+			urb = devpriv->ai_urbs[i];
 			if (urb) {
 				kfree(urb->transfer_buffer);
 				usb_free_urb(urb);
 			}
 		}
-		kfree(devpriv->urbIn);
+		kfree(devpriv->ai_urbs);
 	}
-	kfree(devpriv->insnBuffer);
-	kfree(devpriv->inBuffer);
+	kfree(devpriv->insn_buf);
+	kfree(devpriv->in_buf);
 	kfree(devpriv->dux_commands);
 	kfree(devpriv->dac_commands);
 }
@@ -1697,11 +1697,11 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	/* test if it is high speed (USB 2.0) */
 	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
 	if (devpriv->high_speed) {
-		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
-		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+		devpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;
+		devpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;
 	} else {
-		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
-		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+		devpriv->n_ai_urbs = NUMOFINBUFFERSFULL;
+		devpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;
 	}
 
 	ret = usbduxsigma_alloc_usb_buffers(dev);

commit 396b588579ad51b2b219622642efcfdef5c7a87c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:08:14 2013 -0700

    staging: comedi: usbduxsigma: remove some unused defines
    
    These defines are not used in the driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 801119172e49..34a63695f55e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -64,16 +64,6 @@ Status: testing
 /* internal addresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
 
-/*
- * the minor device number, major is 180 only for debugging purposes and to
- * upload special firmware (programming the eeprom etc) which is not
- * compatible with the comedi framwork
- */
-#define USBDUXSUB_MINOR 32
-
-/* max lenghth of the transfer-buffer for software upload */
-#define TB_LEN 0x2000
-
 /* USB endpoints */
 #define USBDUXSIGMA_CMD_OUT_EP		1	/* command output */
 #define USBDUXSIGMA_ISO_OUT_EP		2	/* analog output ISO/IRQ */

commit 526f55a9ae583e2459301dc11c01e12599c6f264
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:07:53 2013 -0700

    staging: comedi: usbduxsigma: tidy up the usb endpoint defines
    
    Rename the defines so they have namespace associated with the driver.
    Tidy up the defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 63583835f272..801119172e49 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -74,20 +74,12 @@ Status: testing
 /* max lenghth of the transfer-buffer for software upload */
 #define TB_LEN 0x2000
 
-/* Input endpoint number: ISO/IRQ */
-#define ISOINEP           6
-
-/* Output endpoint number: ISO/IRQ */
-#define ISOOUTEP          2
-
-/* This EP sends DUX commands to USBDUX */
-#define COMMAND_OUT_EP     1
-
-/* This EP receives the DUX commands from USBDUX */
-#define COMMAND_IN_EP        8
-
-/* Output endpoint for PWM */
-#define PWM_EP         4
+/* USB endpoints */
+#define USBDUXSIGMA_CMD_OUT_EP		1	/* command output */
+#define USBDUXSIGMA_ISO_OUT_EP		2	/* analog output ISO/IRQ */
+#define USBDUXSIGMA_PWM_OUT_EP		4	/* pwm output */
+#define USBDUXSIGMA_ISO_IN_EP		6	/* analog input ISO/IRQ */
+#define USBDUXSIGMA_CMD_IN_EP		8	/* command input */
 
 /* 300Hz max frequ under PWM */
 #define MIN_PWM_PERIOD  ((long)(1E9/300))
@@ -662,7 +654,7 @@ static int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)
 
 	devpriv->dux_commands[0] = cmd_type;
 
-	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, COMMAND_OUT_EP),
+	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, USBDUXSIGMA_CMD_OUT_EP),
 			    devpriv->dux_commands, SIZEOFDUXBUFFER,
 			    &nsent, BULK_TIMEOUT);
 }
@@ -676,7 +668,8 @@ static int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, COMMAND_IN_EP),
+		ret = usb_bulk_msg(usb,
+				   usb_rcvbulkpipe(usb, USBDUXSIGMA_CMD_IN_EP),
 				   devpriv->insnBuffer, SIZEINSNBUF,
 				   &nrec, BULK_TIMEOUT);
 		if (ret < 0)
@@ -1212,7 +1205,8 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 	struct urb *urb = devpriv->urbPwm;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
+	usb_fill_bulk_urb(urb,
+			  usb, usb_sndbulkpipe(usb, USBDUXSIGMA_PWM_OUT_EP),
 			  urb->transfer_buffer, devpriv->sizePwmBuf,
 			  usbduxsigma_pwm_urb_complete, dev);
 
@@ -1588,7 +1582,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
+		urb->pipe = usb_rcvisocpipe(usb, USBDUXSIGMA_ISO_IN_EP);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
@@ -1610,7 +1604,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
 		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
+		urb->pipe = usb_sndisocpipe(usb, USBDUXSIGMA_ISO_OUT_EP);
 		urb->transfer_flags = URB_ISO_ASAP;
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)

commit c2cf0cd9239010780cc879b5cdfbde89b16232b3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:07:35 2013 -0700

    staging: comedi: usbduxsigma: cleanup comedi_lrange table
    
    Rename the table so it has namespace associated with the driver.
    Tidy up the whitespace of the table.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 8938305a88ce..63583835f272 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -157,12 +157,10 @@ Status: testing
 #define USBDUXSIGMA_PWM_ON_CMD		7
 #define USBDUXSIGMA_PWM_OFF_CMD		8
 
-/**************************************************/
-/* comedi constants */
-static const struct comedi_lrange range_usbdux_ai_range = { 1, {
-								BIP_RANGE
-								(2.65/2.0)
-								}
+static const struct comedi_lrange usbduxsigma_ai_range = {
+	1, {
+		BIP_RANGE(2.65 / 2.0)
+	}
 };
 
 struct usbduxsigma_private {
@@ -1433,7 +1431,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->n_chan	= NUMCHANNELS;
 	s->len_chanlist	= NUMCHANNELS;
 	s->maxdata	= 0x00ffffff;
-	s->range_table	= &range_usbdux_ai_range;
+	s->range_table	= &usbduxsigma_ai_range;
 	s->insn_read	= usbduxsigma_ai_insn_read;
 	s->do_cmdtest	= usbduxsigma_ai_cmdtest;
 	s->do_cmd	= usbduxsigma_ai_cmd;

commit 3b081a436bed27b137411c6f5c1e6097eb518d16
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:07:14 2013 -0700

    staging: comedi: usbduxsigma: rename usbdux_{ai,ao}_stop() functions
    
    Rename the functions so they have namespace associated with the driver.
    
    For aesthetic reasons, pass the comedi_device pointer instead of the
    private data pointer as the first parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 64d27a660869..8938305a88ce 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -213,8 +213,10 @@ struct usbduxsigma_private {
 	struct semaphore sem;
 };
 
-static void usbdux_ai_stop(struct usbduxsigma_private *devpriv, int do_unlink)
+static void usbduxsigma_ai_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbduxsigma_private *devpriv = dev->private;
+
 	if (do_unlink) {
 		int i;
 
@@ -234,7 +236,7 @@ static int usbduxsigma_ai_cancel(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
-	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
+	usbduxsigma_ai_stop(dev, devpriv->ai_cmd_running);
 	up(&devpriv->sem);
 
 	return 0;
@@ -272,7 +274,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	case -ECONNABORTED:
 		/* happens after an unlink command */
 		if (devpriv->ai_cmd_running) {
-			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
 			/* we are still running a command, tell comedi */
 			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
 			comedi_event(dev, s);
@@ -288,7 +290,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 			dev_err(dev->class_dev,
 				"%s: non-zero urb status (%d)\n",
 				__func__, urb->status);
-			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
 			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
 			comedi_event(dev, s);
 		}
@@ -307,7 +309,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 		if (ret == -EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");
-		usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+		usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
 		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
 		comedi_event(dev, s);
 		return;
@@ -327,7 +329,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 		/* not continuous, fixed number of samples */
 		devpriv->ai_sample_count--;
 		if (devpriv->ai_sample_count < 0) {
-			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
 			/* acquistion is over, tell comedi */
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
@@ -345,7 +347,7 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 		ret = cfc_write_array_to_buffer(s, &val, sizeof(uint32_t));
 		if (unlikely(ret == 0)) {
 			/* buffer overflow */
-			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ai_stop(dev, 0);	/* w/o unlink */
 			return;
 		}
 	}
@@ -354,8 +356,10 @@ static void usbduxsigma_ai_urb_complete(struct urb *urb)
 	comedi_event(dev, s);
 }
 
-static void usbdux_ao_stop(struct usbduxsigma_private *devpriv, int do_unlink)
+static void usbduxsigma_ao_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbduxsigma_private *devpriv = dev->private;
+
 	if (do_unlink) {
 		int i;
 
@@ -375,7 +379,7 @@ static int usbduxsigma_ao_cancel(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
-	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
+	usbduxsigma_ao_stop(dev, devpriv->ao_cmd_running);
 	up(&devpriv->sem);
 
 	return 0;
@@ -402,7 +406,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 	case -ECONNABORTED:
 		/* happens after an unlink command */
 		if (devpriv->ao_cmd_running) {
-			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
 			s->async->events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
 		}
@@ -414,7 +418,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 			dev_err(dev->class_dev,
 				"%s: non-zero urb status (%d)\n",
 				__func__, urb->status);
-			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
 			s->async->events |= (COMEDI_CB_ERROR | COMEDI_CB_EOA);
 			comedi_event(dev, s);
 		}
@@ -433,7 +437,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 			/* not continuous, fixed number of samples */
 			devpriv->ao_sample_count--;
 			if (devpriv->ao_sample_count < 0) {
-				usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+				usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
 				/* acquistion is over, tell comedi */
 				s->async->events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
@@ -483,7 +487,7 @@ static void usbduxsigma_ao_urb_complete(struct urb *urb)
 		if (ret == EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");
-		usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+		usbduxsigma_ao_stop(dev, 0);	/* w/o unlink */
 		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
 		comedi_event(dev, s);
 	}
@@ -1649,8 +1653,8 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 	int i;
 
 	/* force unlink all urbs */
-	usbdux_ai_stop(devpriv, 1);
-	usbdux_ao_stop(devpriv, 1);
+	usbduxsigma_ai_stop(dev, 1);
+	usbduxsigma_ao_stop(dev, 1);
 	usbduxsigma_pwm_stop(dev, 1);
 
 	urb = devpriv->urbPwm;

commit cca5bf1065da1605dce39ff1df898e1d056df04a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:06:55 2013 -0700

    staging: comedi: usbduxsigma: rename the (*cancel) functions
    
    Rename these functions so they have namespace associated with the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index cb54149d1502..64d27a660869 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -227,8 +227,8 @@ static void usbdux_ai_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 	devpriv->ai_cmd_running = 0;
 }
 
-static int usbdux_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
+static int usbduxsigma_ai_cancel(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
@@ -368,8 +368,8 @@ static void usbdux_ao_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 	devpriv->ao_cmd_running = 0;
 }
 
-static int usbdux_ao_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
+static int usbduxsigma_ao_cancel(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
@@ -1433,7 +1433,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->insn_read	= usbduxsigma_ai_insn_read;
 	s->do_cmdtest	= usbduxsigma_ai_cmdtest;
 	s->do_cmd	= usbduxsigma_ai_cmd;
-	s->cancel	= usbdux_ai_cancel;
+	s->cancel	= usbduxsigma_ai_cancel;
 
 	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
@@ -1448,7 +1448,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->insn_read	= usbduxsigma_ao_insn_read;
 	s->do_cmdtest	= usbduxsigma_ao_cmdtest;
 	s->do_cmd	= usbduxsigma_ao_cmd;
-	s->cancel	= usbdux_ao_cancel;
+	s->cancel	= usbduxsigma_ao_cancel;
 
 	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];

commit 702cd2dd4efb76ff37005a0990b33e4969819410
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:06:37 2013 -0700

    staging: comedi: usbduxsigma: rename the urb completion handlers
    
    Rename these functions so they have namespace associated with the
    driver and their use is aparent.
    
    Also, rename the #defines used for the bulk transfer commands and
    move them up with the other defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 85fad3c16ed3..cb54149d1502 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -240,7 +240,7 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void usbduxsub_ai_IsocIrq(struct urb *urb)
+static void usbduxsigma_ai_urb_complete(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -381,7 +381,7 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void usbduxsub_ao_IsocIrq(struct urb *urb)
+static void usbduxsigma_ao_urb_complete(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -1155,7 +1155,7 @@ static int usbduxsigma_pwm_cancel(struct comedi_device *dev,
 	return usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_OFF_CMD);
 }
 
-static void usbduxsigma_pwm_irq(struct urb *urb)
+static void usbduxsigma_pwm_urb_complete(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -1212,7 +1212,7 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
 			  urb->transfer_buffer, devpriv->sizePwmBuf,
-			  usbduxsigma_pwm_irq, dev);
+			  usbduxsigma_pwm_urb_complete, dev);
 
 	return usb_submit_urb(urb, GFP_ATOMIC);
 }
@@ -1591,7 +1591,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
 			return -ENOMEM;
-		urb->complete = usbduxsub_ai_IsocIrq;
+		urb->complete = usbduxsigma_ai_urb_complete;
 		urb->number_of_packets = 1;
 		urb->transfer_buffer_length = SIZEINBUF;
 		urb->iso_frame_desc[0].offset = 0;
@@ -1613,7 +1613,7 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!urb->transfer_buffer)
 			return -ENOMEM;
-		urb->complete = usbduxsub_ao_IsocIrq;
+		urb->complete = usbduxsigma_ao_urb_complete;
 		urb->number_of_packets = 1;
 		urb->transfer_buffer_length = SIZEOUTBUF;
 		urb->iso_frame_desc[0].offset = 0;

commit 2bdd6d234acab1d9661e2e2bc2a9ceba11979b9b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:06:18 2013 -0700

    staging: comedi: usbduxsigma: rename {send,receive}_dux_commands()
    
    Rename these functions so they have namespace associated with the
    driver.
    
    Also, rename the #defines used for the bulk transfer commands and
    move them up with the other defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index aa0090c55f60..85fad3c16ed3 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -148,6 +148,15 @@ Status: testing
 /* number of retries to get the right dux command */
 #define RETRIES 10
 
+/* bulk transfer commands to usbduxsigma */
+#define USBBUXSIGMA_AD_CMD		0
+#define USBDUXSIGMA_DA_CMD		1
+#define USBDUXSIGMA_DIO_CFG_CMD		2
+#define USBDUXSIGMA_DIO_BITS_CMD	3
+#define USBDUXSIGMA_SINGLE_AD_CMD	4
+#define USBDUXSIGMA_PWM_ON_CMD		7
+#define USBDUXSIGMA_PWM_OFF_CMD		8
+
 /**************************************************/
 /* comedi constants */
 static const struct comedi_lrange range_usbdux_ai_range = { 1, {
@@ -643,18 +652,7 @@ static void create_adc_command(unsigned int chan,
 		(*muxsg1) = (*muxsg1) | (1 << (chan-8));
 }
 
-
-/* bulk transfers to usbdux */
-
-#define SENDADCOMMANDS            0
-#define SENDDACOMMANDS            1
-#define SENDDIOCONFIGCOMMAND      2
-#define SENDDIOBITSCOMMAND        3
-#define SENDSINGLEAD              4
-#define SENDPWMON                 7
-#define SENDPWMOFF                8
-
-static int send_dux_commands(struct comedi_device *dev, int cmd_type)
+static int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -667,7 +665,7 @@ static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 			    &nsent, BULK_TIMEOUT);
 }
 
-static int receive_dux_commands(struct comedi_device *dev, int command)
+static int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -748,7 +746,7 @@ static int usbduxsigma_ai_cmd(struct comedi_device *dev,
 	devpriv->dux_commands[6] = muxsg1;
 	devpriv->dux_commands[7] = sysred;
 
-	ret = send_dux_commands(dev, SENDADCOMMANDS);
+	ret = usbbuxsigma_send_cmd(dev, USBBUXSIGMA_AD_CMD);
 	if (ret < 0) {
 		up(&devpriv->sem);
 		return ret;
@@ -806,7 +804,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	devpriv->dux_commands[6] = sysred;
 
 	/* adc commands */
-	ret = send_dux_commands(dev, SENDSINGLEAD);
+	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 	if (ret < 0) {
 		up(&devpriv->sem);
 		return ret;
@@ -815,7 +813,7 @@ static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
 	for (i = 0; i < insn->n; i++) {
 		int32_t val;
 
-		ret = receive_dux_commands(dev, SENDSINGLEAD);
+		ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -870,7 +868,7 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 		devpriv->dux_commands[1] = 1;		/* num channels */
 		devpriv->dux_commands[2] = data[i];	/* value */
 		devpriv->dux_commands[3] = chan;	/* channel number */
-		ret = send_dux_commands(dev, SENDDACOMMANDS);
+		ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DA_CMD);
 		if (ret < 0) {
 			up(&devpriv->sem);
 			return ret;
@@ -1114,10 +1112,10 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 	devpriv->dux_commands[3] = (s->io_bits >> 16) & 0xff;
 	devpriv->dux_commands[6] = (s->state >> 16) & 0xff;
 
-	ret = send_dux_commands(dev, SENDDIOBITSCOMMAND);
+	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);
 	if (ret < 0)
 		goto done;
-	ret = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
+	ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);
 	if (ret < 0)
 		goto done;
 
@@ -1154,7 +1152,7 @@ static int usbduxsigma_pwm_cancel(struct comedi_device *dev,
 	/* unlink only if it is really running */
 	usbduxsigma_pwm_stop(dev, devpriv->pwm_cmd_running);
 
-	return send_dux_commands(dev, SENDPWMOFF);
+	return usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_OFF_CMD);
 }
 
 static void usbduxsigma_pwm_irq(struct urb *urb)
@@ -1248,7 +1246,7 @@ static int usbduxsigma_pwm_start(struct comedi_device *dev,
 		return 0;
 
 	devpriv->dux_commands[1] = devpriv->pwmDelay;
-	ret = send_dux_commands(dev, SENDPWMON);
+	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_ON_CMD);
 	if (ret < 0)
 		return ret;
 
@@ -1387,11 +1385,11 @@ static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 	devpriv->dux_commands[4] = 0;
 	devpriv->dux_commands[5] = 0;
 	devpriv->dux_commands[6] = sysred;
-	ret = send_dux_commands(dev, SENDSINGLEAD);
+	ret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 	if (ret < 0)
 		return ret;
 
-	ret = receive_dux_commands(dev, SENDSINGLEAD);
+	ret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);
 	if (ret < 0)
 		return ret;
 

commit dd64d1efdab83d0c702a27ee7893c5df492cfe1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:05:59 2013 -0700

    staging: comedi: usbduxsigma: check for invalid 'ao_timer' in all cases
    
    Make sure to check that the 'ao_timer' value is valid for both the
    high speed and low speed cases in usbduxsigma_ao_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ed5085a70807..aa0090c55f60 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -994,9 +994,9 @@ static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
 		 * we get all channels at once
 		 */
 		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
-		if (devpriv->ao_timer < 1)
-			err |= -EINVAL;
 	}
+	if (devpriv->ao_timer < 1)
+		err |= -EINVAL;
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* not continuous, use counter */

commit b986be8527c7a9a84025689d5e85bc03300bb091
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:05:38 2013 -0700

    staging: comedi: usbduxsigma: tidy up analog input command support
    
    Rename the (*do_cmdtest) and (*do_cmd) functions so they have namespace
    associated with the driver. Rename the local variable used for the
    private data pointer.
    
    Move all the command argument initialization and testing into the
    (*do_cmdtest) function. That function is always called by the comedi
    core before the (*do_cmd) function. The only thing the (*do_cmd) function
    should have to do is setup the channel list, send the command to start
    the analog input sampling, initialize the counter for the conversion,
    then either read the acquisition data (submit the urbs) or set the
    trigger to read the data later.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ce2e40f258c2..ed5085a70807 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -521,13 +521,14 @@ static int chanToInterval(int nChannels)
 	return 8;
 }
 
-static int usbdux_ai_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_cmd *cmd)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int err = 0, i;
-	unsigned int tmpTimer;
+	struct usbduxsigma_private *devpriv = dev->private;
+	int high_speed = devpriv->high_speed;
+	int interval = chanToInterval(cmd->chanlist_len);
+	int err = 0;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -558,34 +559,28 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (this_usbduxsub->high_speed) {
+		unsigned int tmp;
+
+		if (high_speed) {
 			/*
 			 * In high speed mode microframes are possible.
 			 * However, during one microframe we can roughly
 			 * sample two channels. Thus, the more channels
 			 * are in the channel list the more time we need.
 			 */
-			i = chanToInterval(cmd->chanlist_len);
 			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-							 (1000000 / 8 * i));
-			/* now calc the real sampling rate with all the
-			 * rounding errors */
-			tmpTimer =
-			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
-			    125000;
+						(1000000 / 8 * interval));
+
+			tmp = (cmd->scan_begin_arg / 125000) * 125000;
 		} else {
 			/* full speed */
 			/* 1kHz scans every USB frame */
 			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
 							 1000000);
-			/*
-			 * calc the real sampling rate with the rounding errors
-			 */
-			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
-						   1000000)) * 1000000;
+
+			tmp = (cmd->scan_begin_arg / 1000000) * 1000000;
 		}
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
-						tmpTimer);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);
 	}
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
@@ -600,6 +595,37 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
+	/* Step 4: fix up any arguments */
+
+	if (high_speed) {
+		/*
+		 * every 2 channels get a time window of 125us. Thus, if we
+		 * sample all 16 channels we need 1ms. If we sample only one
+		 * channel we need only 125us
+		 */
+		devpriv->ai_interval = interval;
+		devpriv->ai_timer = cmd->scan_begin_arg / (125000 * interval);
+	} else {
+		/* interval always 1ms */
+		devpriv->ai_interval = 1;
+		devpriv->ai_timer = cmd->scan_begin_arg / 1000000;
+	}
+	if (devpriv->ai_timer < 1)
+		err |= -EINVAL;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* data arrives as one packet */
+		devpriv->ai_sample_count = cmd->stop_arg;
+		devpriv->ai_continuous = 0;
+	} else {
+		/* continuous acquisition */
+		devpriv->ai_continuous = 1;
+		devpriv->ai_sample_count = 0;
+	}
+
+	if (err)
+		return 4;
+
 	return 0;
 }
 
@@ -692,102 +718,61 @@ static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int usbduxsigma_ai_cmd(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int chan;
-	int i, ret;
-	int result;
+	unsigned int len = cmd->chanlist_len;
 	uint8_t muxsg0 = 0;
 	uint8_t muxsg1 = 0;
 	uint8_t sysred = 0;
+	int ret;
+	int i;
+
+	down(&devpriv->sem);
 
-	/* block other CPUs from starting an ai_cmd */
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ai_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return -EBUSY;
-	}
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
+	for (i = 0; i < len; i++) {
+		unsigned int chan  = CR_CHAN(cmd->chanlist[i]);
 
-	/* first the number of channels per time step */
-	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
-
-	/* CONFIG0 */
-	this_usbduxsub->dux_commands[2] = 0x12;
-
-	/* CONFIG1: 23kHz sampling rate, delay = 0us,  */
-	this_usbduxsub->dux_commands[3] = 0x03;
-
-	/* CONFIG3: differential channels off */
-	this_usbduxsub->dux_commands[4] = 0x00;
-
-	for (i = 0; i < cmd->chanlist_len; i++) {
-		chan = CR_CHAN(cmd->chanlist[i]);
 		create_adc_command(chan, &muxsg0, &muxsg1);
 	}
-	this_usbduxsub->dux_commands[5] = muxsg0;
-	this_usbduxsub->dux_commands[6] = muxsg1;
-	this_usbduxsub->dux_commands[7] = sysred;
-
-	result = send_dux_commands(dev, SENDADCOMMANDS);
-	if (result < 0) {
-		up(&this_usbduxsub->sem);
-		return result;
-	}
 
-	if (this_usbduxsub->high_speed) {
-		/*
-		 * every 2 channels get a time window of 125us. Thus, if we
-		 * sample all 16 channels we need 1ms. If we sample only one
-		 * channel we need only 125us
-		 */
-		this_usbduxsub->ai_interval =
-			chanToInterval(cmd->chanlist_len);
-		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
-							  (this_usbduxsub->
-							   ai_interval));
-	} else {
-		/* interval always 1ms */
-		this_usbduxsub->ai_interval = 1;
-		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
-	}
-	if (this_usbduxsub->ai_timer < 1) {
-		up(&this_usbduxsub->sem);
-		return -EINVAL;
-	}
-	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+	devpriv->dux_commands[1] = len;  /* num channels per time step */
+	devpriv->dux_commands[2] = 0x12; /* CONFIG0 */
+	devpriv->dux_commands[3] = 0x03; /* CONFIG1: 23kHz sample, delay 0us */
+	devpriv->dux_commands[4] = 0x00; /* CONFIG3: diff. channels off */
+	devpriv->dux_commands[5] = muxsg0;
+	devpriv->dux_commands[6] = muxsg1;
+	devpriv->dux_commands[7] = sysred;
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* data arrives as one packet */
-		this_usbduxsub->ai_sample_count = cmd->stop_arg;
-		this_usbduxsub->ai_continuous = 0;
-	} else {
-		/* continuous acquisition */
-		this_usbduxsub->ai_continuous = 1;
-		this_usbduxsub->ai_sample_count = 0;
+	ret = send_dux_commands(dev, SENDADCOMMANDS);
+	if (ret < 0) {
+		up(&devpriv->sem);
+		return ret;
 	}
 
+	devpriv->ai_counter = devpriv->ai_timer;
+
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbIn,
-					      this_usbduxsub->numOfInBuffers,
-					      1);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->urbIn,
+					      devpriv->numOfInBuffers, 1);
 		if (ret < 0) {
-			up(&this_usbduxsub->sem);
+			up(&devpriv->sem);
 			return ret;
 		}
-		this_usbduxsub->ai_cmd_running = 1;
 		s->async->inttrig = NULL;
-	} else {
-		/* TRIG_INT */
-		/* don't enable the acquision operation */
-		/* wait for an internal signal */
+		devpriv->ai_cmd_running = 1;
+	} else {	/* TRIG_INT */
+		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ai_inttrig;
 	}
-	up(&this_usbduxsub->sem);
+
+	up(&devpriv->sem);
+
 	return 0;
 }
 
@@ -1448,8 +1433,8 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->maxdata	= 0x00ffffff;
 	s->range_table	= &range_usbdux_ai_range;
 	s->insn_read	= usbduxsigma_ai_insn_read;
-	s->do_cmdtest	= usbdux_ai_cmdtest;
-	s->do_cmd	= usbdux_ai_cmd;
+	s->do_cmdtest	= usbduxsigma_ai_cmdtest;
+	s->do_cmd	= usbduxsigma_ai_cmd;
 	s->cancel	= usbdux_ai_cancel;
 
 	/* Analog Output subdevice */

commit c5db3b755ccf6bf046b5b5fa1b94cee1cf609bd8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:05:19 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_ai_insn_read()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Return -EBUSY if an asynchronous command is running and the read cannot
    be completed.
    
    Propagate the errno if the receive_dux_command() fails.
    
    Tidy up the function to make it more concise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 28b4b7a6031f..ce2e40f258c2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -791,67 +791,61 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/* Mode 0 is used to get a single conversion on demand */
-static int usbdux_ai_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_ai_insn_read(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int i;
-	int32_t one = 0;
-	int chan;
-	int err;
+	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	uint8_t muxsg0 = 0;
 	uint8_t muxsg1 = 0;
 	uint8_t sysred = 0;
+	int ret;
+	int i;
 
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ai_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return 0;
+	down(&devpriv->sem);
+	if (devpriv->ai_cmd_running) {
+		up(&devpriv->sem);
+		return -EBUSY;
 	}
 
-	/* sample one channel */
-	/* CONFIG0: chopper on */
-	this_usbduxsub->dux_commands[1] = 0x16;
-
-	/* CONFIG1: 2kHz sampling rate */
-	this_usbduxsub->dux_commands[2] = 0x80;
-
-	/* CONFIG3: differential channels off */
-	this_usbduxsub->dux_commands[3] = 0x00;
-
-	chan = CR_CHAN(insn->chanspec);
 	create_adc_command(chan, &muxsg0, &muxsg1);
 
-	this_usbduxsub->dux_commands[4] = muxsg0;
-	this_usbduxsub->dux_commands[5] = muxsg1;
-	this_usbduxsub->dux_commands[6] = sysred;
+	/* Mode 0 is used to get a single conversion on demand */
+	devpriv->dux_commands[1] = 0x16; /* CONFIG0: chopper on */
+	devpriv->dux_commands[2] = 0x80; /* CONFIG1: 2kHz sampling rate */
+	devpriv->dux_commands[3] = 0x00; /* CONFIG3: diff. channels off */
+	devpriv->dux_commands[4] = muxsg0;
+	devpriv->dux_commands[5] = muxsg1;
+	devpriv->dux_commands[6] = sysred;
 
 	/* adc commands */
-	err = send_dux_commands(dev, SENDSINGLEAD);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
+	ret = send_dux_commands(dev, SENDSINGLEAD);
+	if (ret < 0) {
+		up(&devpriv->sem);
+		return ret;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		err = receive_dux_commands(dev, SENDSINGLEAD);
-		if (err < 0) {
-			up(&this_usbduxsub->sem);
-			return 0;
+		int32_t val;
+
+		ret = receive_dux_commands(dev, SENDSINGLEAD);
+		if (ret < 0) {
+			up(&devpriv->sem);
+			return ret;
 		}
+
 		/* 32 bits big endian from the A/D converter */
-		one = be32_to_cpu(*((int32_t *)
-				    ((this_usbduxsub->insnBuffer)+1)));
-		/* mask out the status byte */
-		one = one & 0x00ffffff;
-		/* turn it into an unsigned integer */
-		one = one ^ 0x00800000;
-		data[i] = one;
+		val = be32_to_cpu(*((int32_t *)((devpriv->insnBuffer) + 1)));
+		val &= 0x00ffffff;	/* strip status byte */
+		val ^= 0x00800000;	/* convert to unsigned */
+
+		data[i] = val;
 	}
-	up(&this_usbduxsub->sem);
-	return i;
+	up(&devpriv->sem);
+
+	return insn->n;
 }
 
 static int usbduxsigma_ao_insn_read(struct comedi_device *dev,
@@ -1453,7 +1447,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->len_chanlist	= NUMCHANNELS;
 	s->maxdata	= 0x00ffffff;
 	s->range_table	= &range_usbdux_ai_range;
-	s->insn_read	= usbdux_ai_insn_read;
+	s->insn_read	= usbduxsigma_ai_insn_read;
 	s->do_cmdtest	= usbdux_ai_cmdtest;
 	s->do_cmd	= usbdux_ai_cmd;
 	s->cancel	= usbdux_ai_cancel;

commit 44d3fcaece73f8a60369cb609f4b81a2270c8e0c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:04:53 2013 -0700

    staging: comedi: usbduxsigma: cleanup the private data 'outBuffer'
    
    This buffer is used to cache the analog output values that are written
    to the analog output channels. Currently it only caches the single
    writes to the channels using the (*insn_write) callback. The async
    command writes are not cached. The buffer is also being kzalloc'ed
    during the attach of the driver to a size much larger that required.
    
    Rename the CamelCase buffer and change it to an array in the private
    data of the correct size to cache the analog output channel values.
    
    Modify the analog output urb callback so it updates the cached values
    with those used for the asynchronous command to allow readback after
    the command completes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index c3a895f626bf..28b4b7a6031f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -98,6 +98,8 @@ Status: testing
 /* Number of channels (16 AD and offset)*/
 #define NUMCHANNELS 16
 
+#define USBDUXSIGMA_NUM_AO_CHAN		4
+
 /* Size of one A/D value */
 #define SIZEADIN          ((sizeof(int32_t)))
 
@@ -174,8 +176,8 @@ struct usbduxsigma_private {
 	int32_t *inBuffer;
 	/* input buffer for single insn */
 	int8_t *insnBuffer;
-	/* output buffer for single DA outputs */
-	int16_t *outBuffer;
+
+	unsigned int ao_readback[USBDUXSIGMA_NUM_AO_CHAN];
 
 	unsigned high_speed:1;
 	unsigned ai_cmd_running:1;
@@ -435,11 +437,9 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		len = s->async->cmd.chanlist_len;
 		*datap++ = len;
 		for (i = 0; i < len; i++) {
+			unsigned int chan = devpriv->dac_commands[i];
 			short val;
 
-			if (i >= NUMOUTCHANNELS)
-				break;
-
 			ret = comedi_buf_get(s->async, &val);
 			if (ret < 0) {
 				dev_err(dev->class_dev, "buffer underflow\n");
@@ -447,7 +447,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 						     COMEDI_CB_OVERFLOW);
 			}
 			*datap++ = val;
-			*datap++ = devpriv->dac_commands[i];
+			*datap++ = chan;
+			devpriv->ao_readback[chan] = val;
 
 			s->async->events |= COMEDI_CB_BLOCK;
 			comedi_event(dev, s);
@@ -864,7 +865,7 @@ static int usbduxsigma_ao_insn_read(struct comedi_device *dev,
 
 	down(&devpriv->sem);
 	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->outBuffer[chan];
+		data[i] = devpriv->ao_readback[chan];
 	up(&devpriv->sem);
 
 	return insn->n;
@@ -895,7 +896,7 @@ static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
 			up(&devpriv->sem);
 			return ret;
 		}
-		devpriv->outBuffer[chan] = data[i];
+		devpriv->ao_readback[chan] = data[i];
 	}
 	up(&devpriv->sem);
 
@@ -1462,8 +1463,8 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	dev->write_subdev = s;
 	s->type		= COMEDI_SUBD_AO;
 	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	s->n_chan	= 4;
-	s->len_chanlist	= 4;
+	s->n_chan	= USBDUXSIGMA_NUM_AO_CHAN;
+	s->len_chanlist	= s->n_chan;
 	s->maxdata	= 0x00ff;
 	s->range_table	= &range_unipolar2_5;
 	s->insn_write	= usbduxsigma_ao_insn_write;
@@ -1589,14 +1590,13 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	devpriv->inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 	devpriv->insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	devpriv->outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 	devpriv->urbIn = kcalloc(devpriv->numOfInBuffers, sizeof(*urb),
 				 GFP_KERNEL);
 	devpriv->urbOut = kcalloc(devpriv->numOfOutBuffers, sizeof(*urb),
 				  GFP_KERNEL);
 	if (!devpriv->dac_commands || !devpriv->dux_commands ||
 	    !devpriv->inBuffer || !devpriv->insnBuffer ||
-	    !devpriv->outBuffer || !devpriv->urbIn || !devpriv->urbOut)
+	    !devpriv->urbIn || !devpriv->urbOut)
 		return -ENOMEM;
 
 	for (i = 0; i < devpriv->numOfInBuffers; i++) {
@@ -1701,7 +1701,6 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 		}
 		kfree(devpriv->urbIn);
 	}
-	kfree(devpriv->outBuffer);
 	kfree(devpriv->insnBuffer);
 	kfree(devpriv->inBuffer);
 	kfree(devpriv->dux_commands);

commit 2dd87acb1a38a317320be75ca49f53491fa6f577
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:04:31 2013 -0700

    staging: comedi: usbduxsigma: tidy up analog output (*insn_{read, write})
    
    Rename the functions so they have namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Return -EBUSY from the (*insn_write) function if an asynchronous command
    is running that the write cannot be completed.
    
    Don't save the cached value of the analog output for readback unless
    the command to set it is successful.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5e33553e99bc..c3a895f626bf 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -853,55 +853,53 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	return i;
 }
 
-/************************************/
-/* analog out */
-
-static int usbdux_ao_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_ao_insn_read(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
-	int chan = CR_CHAN(insn->chanspec);
 
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 	for (i = 0; i < insn->n; i++)
-		data[i] = this_usbduxsub->outBuffer[chan];
+		data[i] = devpriv->outBuffer[chan];
+	up(&devpriv->sem);
 
-	up(&this_usbduxsub->sem);
-	return i;
+	return insn->n;
 }
 
-static int usbdux_ao_insn_write(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_ao_insn_write(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int i, err;
-	int chan = CR_CHAN(insn->chanspec);
+	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int ret;
+	int i;
 
-	down(&this_usbduxsub->sem);
-	if (this_usbduxsub->ao_cmd_running) {
-		up(&this_usbduxsub->sem);
-		return 0;
+	down(&devpriv->sem);
+	if (devpriv->ao_cmd_running) {
+		up(&devpriv->sem);
+		return -EBUSY;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		/* number of channels: 1 */
-		this_usbduxsub->dux_commands[1] = 1;
-		/* channel number */
-		this_usbduxsub->dux_commands[2] = data[i];
-		this_usbduxsub->outBuffer[chan] = data[i];
-		this_usbduxsub->dux_commands[3] = chan;
-		err = send_dux_commands(dev, SENDDACOMMANDS);
-		if (err < 0) {
-			up(&this_usbduxsub->sem);
-			return err;
+		devpriv->dux_commands[1] = 1;		/* num channels */
+		devpriv->dux_commands[2] = data[i];	/* value */
+		devpriv->dux_commands[3] = chan;	/* channel number */
+		ret = send_dux_commands(dev, SENDDACOMMANDS);
+		if (ret < 0) {
+			up(&devpriv->sem);
+			return ret;
 		}
+		devpriv->outBuffer[chan] = data[i];
 	}
-	up(&this_usbduxsub->sem);
+	up(&devpriv->sem);
 
-	return i;
+	return insn->n;
 }
 
 static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
@@ -1468,8 +1466,8 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->len_chanlist	= 4;
 	s->maxdata	= 0x00ff;
 	s->range_table	= &range_unipolar2_5;
-	s->insn_write	= usbdux_ao_insn_write;
-	s->insn_read	= usbdux_ao_insn_read;
+	s->insn_write	= usbduxsigma_ao_insn_write;
+	s->insn_read	= usbduxsigma_ao_insn_read;
 	s->do_cmdtest	= usbduxsigma_ao_cmdtest;
 	s->do_cmd	= usbduxsigma_ao_cmd;
 	s->cancel	= usbdux_ao_cancel;

commit fb1ef622e7a398bb22127eed0684c8cc42650986
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:04:11 2013 -0700

    staging: comedi: usbduxsigma: tidy up analog output command support
    
    Rename the (*do_cmdtest) and (*do_cmd) functions so they have namespace
    associated with the driver. Rename the local variable used for the
    private data pointer.
    
    Move all the command argument initialization and testing into the
    (*do_cmdtest) function. That function is always called by the comedi
    core before the (*do_cmd) function. The only thing the (*do_cmd) function
    should have to do is setup the channel list, initialize the counter for
    the conversion, then either start the conversion (submit the urbs) or
    set the trigger to start the conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 9a5f7ef1590a..5e33553e99bc 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -930,18 +930,23 @@ static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
 	return 1;
 }
 
-static int usbdux_ao_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_cmd *cmd)
+static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_cmd *cmd)
 {
+	struct usbduxsigma_private *devpriv = dev->private;
 	int err = 0;
+	int high_speed;
 	unsigned int flags;
 
+	/* high speed conversions are not used yet */
+	high_speed = 0; 	/* (devpriv->high_speed) */
+
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	if (0) {		/* (this_usbduxsub->high_speed) */
+	if (high_speed) {
 		/*
 		 * start immediately a new scan
 		 * the sampling rate is set by the coversion rate
@@ -957,8 +962,10 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
 	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
-	if (err)
+	if (err) {
+		up(&devpriv->sem);
 		return 1;
+	}
 
 	/* Step 2a : make sure trigger sources are unique */
 
@@ -997,81 +1004,83 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	return 0;
-}
-
-static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int chan, gain;
-	int i, ret;
+	/* Step 4: fix up any arguments */
 
-	down(&this_usbduxsub->sem);
-	/* set current channel of the running acquisition to zero */
-	s->async->cur_chan = 0;
-	for (i = 0; i < cmd->chanlist_len; ++i) {
-		chan = CR_CHAN(cmd->chanlist[i]);
-		gain = CR_RANGE(cmd->chanlist[i]);
-		this_usbduxsub->dac_commands[i] = chan;
-	}
-
-	/* we count in steps of 1ms (125us) */
-	/* 125us mode not used yet */
-	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* 125us */
+	/* we count in timer steps */
+	if (high_speed) {
 		/* timing of the conversion itself: every 125 us */
-		this_usbduxsub->ao_timer = cmd->convert_arg / 125000;
+		devpriv->ao_timer = cmd->convert_arg / 125000;
 	} else {
-		/* 1ms */
-		/* timing of the scan: we get all channels at once */
-		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
-		if (this_usbduxsub->ao_timer < 1) {
-			up(&this_usbduxsub->sem);
-			return -EINVAL;
-		}
+		/*
+		 * timing of the scan: every 1ms
+		 * we get all channels at once
+		 */
+		devpriv->ao_timer = cmd->scan_begin_arg / 1000000;
+		if (devpriv->ao_timer < 1)
+			err |= -EINVAL;
 	}
-	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continuous */
-		/* counter */
-		/* high speed also scans everything at once */
-		if (0) {	/* (this_usbduxsub->high_speed) */
-			this_usbduxsub->ao_sample_count =
-			    (cmd->stop_arg) * (cmd->scan_end_arg);
+		/* not continuous, use counter */
+		if (high_speed) {
+			/* high speed also scans everything at once */
+			devpriv->ao_sample_count = cmd->stop_arg *
+						   cmd->scan_end_arg;
 		} else {
-			/* there's no scan as the scan has been */
-			/* perf inside the FX2 */
-			/* data arrives as one packet */
-			this_usbduxsub->ao_sample_count = cmd->stop_arg;
+			/*
+			 * There's no scan as the scan has been
+			 * handled inside the FX2. Data arrives as
+			 * one packet.
+			 */
+			devpriv->ao_sample_count = cmd->stop_arg;
 		}
-		this_usbduxsub->ao_continuous = 0;
+		devpriv->ao_continuous = 0;
 	} else {
 		/* continuous acquisition */
-		this_usbduxsub->ao_continuous = 1;
-		this_usbduxsub->ao_sample_count = 0;
+		devpriv->ao_continuous = 1;
+		devpriv->ao_sample_count = 0;
 	}
 
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+static int usbduxsigma_ao_cmd(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
+{
+	struct usbduxsigma_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	int ret;
+	int i;
+
+	down(&devpriv->sem);
+
+	/* set current channel of the running acquisition to zero */
+	s->async->cur_chan = 0;
+	for (i = 0; i < cmd->chanlist_len; ++i)
+		devpriv->dac_commands[i] = CR_CHAN(cmd->chanlist[i]);
+
+	devpriv->ao_counter = devpriv->ao_timer;
+
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbOut,
-					      this_usbduxsub->numOfOutBuffers,
-					      0);
+		ret = usbduxsigma_submit_urbs(dev, devpriv->urbOut,
+					      devpriv->numOfOutBuffers, 0);
 		if (ret < 0) {
-			up(&this_usbduxsub->sem);
+			up(&devpriv->sem);
 			return ret;
 		}
-		this_usbduxsub->ao_cmd_running = 1;
 		s->async->inttrig = NULL;
-	} else {
-		/* TRIG_INT */
-		/* submit the urbs later */
-		/* wait for an internal signal */
+		devpriv->ao_cmd_running = 1;
+	} else {	/* TRIG_INT */
+		/* wait for an internal signal and submit the urbs later */
 		s->async->inttrig = usbduxsigma_ao_inttrig;
 	}
 
-	up(&this_usbduxsub->sem);
+	up(&devpriv->sem);
+
 	return 0;
 }
 
@@ -1461,8 +1470,8 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->range_table	= &range_unipolar2_5;
 	s->insn_write	= usbdux_ao_insn_write;
 	s->insn_read	= usbdux_ao_insn_read;
-	s->do_cmdtest	= usbdux_ao_cmdtest;
-	s->do_cmd	= usbdux_ao_cmd;
+	s->do_cmdtest	= usbduxsigma_ao_cmdtest;
+	s->do_cmd	= usbduxsigma_ao_cmd;
 	s->cancel	= usbdux_ao_cancel;
 
 	/* Digital I/O subdevice */

commit 8cd6f5ebb618d5ae1017e6cfae330cf27002b205
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:03:45 2013 -0700

    staging: comedi: usbduxsigma: rename usbdux_pwm_stop()
    
    Rename the function so it has namespace associated with the driver.
    
    For aesthetic reasons, pass the comedi_device pointer instead of the
    private data pointer as the first parameter.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e4a80fc65170..9a5f7ef1590a 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1147,8 +1147,10 @@ static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
 	return ret;
 }
 
-static void usbdux_pwm_stop(struct usbduxsigma_private *devpriv, int do_unlink)
+static void usbduxsigma_pwm_stop(struct comedi_device *dev, int do_unlink)
 {
+	struct usbduxsigma_private *devpriv = dev->private;
+
 	if (do_unlink) {
 		if (devpriv->urbPwm)
 			usb_kill_urb(devpriv->urbPwm);
@@ -1163,7 +1165,7 @@ static int usbduxsigma_pwm_cancel(struct comedi_device *dev,
 	struct usbduxsigma_private *devpriv = dev->private;
 
 	/* unlink only if it is really running */
-	usbdux_pwm_stop(devpriv, devpriv->pwm_cmd_running);
+	usbduxsigma_pwm_stop(dev, devpriv->pwm_cmd_running);
 
 	return send_dux_commands(dev, SENDPWMOFF);
 }
@@ -1185,7 +1187,7 @@ static void usbduxsigma_pwm_irq(struct urb *urb)
 	case -ECONNABORTED:
 		/* happens after an unlink command */
 		if (devpriv->pwm_cmd_running)
-			usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_pwm_stop(dev, 0);	/* w/o unlink */
 		return;
 
 	default:
@@ -1194,7 +1196,7 @@ static void usbduxsigma_pwm_irq(struct urb *urb)
 			dev_err(dev->class_dev,
 				"%s: non-zero urb status (%d)\n",
 				__func__, urb->status);
-			usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
+			usbduxsigma_pwm_stop(dev, 0);	/* w/o unlink */
 		}
 		return;
 	}
@@ -1212,7 +1214,7 @@ static void usbduxsigma_pwm_irq(struct urb *urb)
 		if (ret == EL2NSYNC)
 			dev_err(dev->class_dev,
 				"buggy USB host controller or bug in IRQ handler\n");
-		usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
+		usbduxsigma_pwm_stop(dev, 0);	/* w/o unlink */
 	}
 }
 
@@ -1665,7 +1667,7 @@ static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
 	/* force unlink all urbs */
 	usbdux_ai_stop(devpriv, 1);
 	usbdux_ao_stop(devpriv, 1);
-	usbdux_pwm_stop(devpriv, 1);
+	usbduxsigma_pwm_stop(dev, 1);
 
 	urb = devpriv->urbPwm;
 	if (urb) {

commit fd245192b1ddae96a4bcf430fe26b4130a72f1f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:03:26 2013 -0700

    staging: comedi: usbduxsigma: rename usbdux_pwm_cancel()
    
    Rename the function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 79f714c7c305..e4a80fc65170 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1157,8 +1157,8 @@ static void usbdux_pwm_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 	devpriv->pwm_cmd_running = 0;
 }
 
-static int usbdux_pwm_cancel(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
+static int usbduxsigma_pwm_cancel(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
 
@@ -1340,7 +1340,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 			return -EINVAL;
 		return usbduxsigma_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
-		return usbdux_pwm_cancel(dev, s);
+		return usbduxsigma_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
 		data[1] = devpriv->pwm_cmd_running;
 		return 0;

commit aff4dd068c9fdd7836522945e18e75a58b6bbd15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:03:06 2013 -0700

    staging: comedi: usbduxsigma: rename usbdux_pwm_irq()
    
    Rename the function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 493898068bd6..79f714c7c305 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1168,7 +1168,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	return send_dux_commands(dev, SENDPWMOFF);
 }
 
-static void usbduxsub_pwm_irq(struct urb *urb)
+static void usbduxsigma_pwm_irq(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -1225,7 +1225,7 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
 			  urb->transfer_buffer, devpriv->sizePwmBuf,
-			  usbduxsub_pwm_irq, dev);
+			  usbduxsigma_pwm_irq, dev);
 
 	return usb_submit_urb(urb, GFP_ATOMIC);
 }

commit 440b2168ae23d4e5fe34183dfcd94f59f6c9fa2f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:02:45 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_pwm_period()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Modify the fx2delay calculation to remove the floating point values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d955e85bdde0..493898068bd6 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1230,21 +1230,22 @@ static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 	return usb_submit_urb(urb, GFP_ATOMIC);
 }
 
-static int usbdux_pwm_period(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int period)
+static int usbduxsigma_pwm_period(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  unsigned int period)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
 		return -EAGAIN;
 	} else {
-		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
+		fx2delay = (period / (6 * 512 * 1000 / 33)) - 6;
 		if (fx2delay > 255)
 			return -EAGAIN;
 	}
-	this_usbduxsub->pwmDelay = fx2delay;
-	this_usbduxsub->pwmPeriod = period;
+	devpriv->pwmDelay = fx2delay;
+	devpriv->pwmPeriod = period;
 	return 0;
 }
 
@@ -1344,7 +1345,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 		data[1] = devpriv->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
-		return usbdux_pwm_period(dev, s, data[1]);
+		return usbduxsigma_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
 		data[1] = devpriv->pwmPeriod;
 		return 0;
@@ -1482,7 +1483,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		s->insn_write	= usbduxsigma_pwm_write;
 		s->insn_config	= usbduxsigma_pwm_config;
 
-		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+		usbduxsigma_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
 
 	up(&devpriv->sem);

commit cf9b463401886c4f70ae7ea3c2a7d2ff0cb4e3ea
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:02:25 2013 -0700

    staging: comedi: usbduxsigma: change private data flags to bit fields
    
    Change the type of all the true/false flags in the private data to
    bit fields.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ae56bcb5c81a..d955e85bdde0 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -176,16 +176,14 @@ struct usbduxsigma_private {
 	int8_t *insnBuffer;
 	/* output buffer for single DA outputs */
 	int16_t *outBuffer;
-	/* is it USB_SPEED_HIGH or not? */
-	short int high_speed;
-	/* asynchronous command is running */
-	short int ai_cmd_running;
-	short int ao_cmd_running;
-	/* pwm is running */
-	short int pwm_cmd_running;
-	/* continuous acquisition */
-	short int ai_continuous;
-	short int ao_continuous;
+
+	unsigned high_speed:1;
+	unsigned ai_cmd_running:1;
+	unsigned ai_continuous:1;
+	unsigned ao_cmd_running:1;
+	unsigned ao_continuous:1;
+	unsigned pwm_cmd_running:1;
+
 	/* number of samples to acquire */
 	int ai_sample_count;
 	int ao_sample_count;

commit 92ba10e1a1b48ecbee90e139bc1d27a1350ebd7f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:01:56 2013 -0700

    staging: comedi: usbduxsigma: remove 'interface' from the private data
    
    This back pointer to the usb_interface is not used, remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e705907c7587..ae56bcb5c81a 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -176,8 +176,6 @@ struct usbduxsigma_private {
 	int8_t *insnBuffer;
 	/* output buffer for single DA outputs */
 	int16_t *outBuffer;
-	/* interface structure in 2.6 */
-	struct usb_interface *interface;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -1716,7 +1714,6 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
-	devpriv->interface = intf;
 	usb_set_intfdata(intf, devpriv);
 
 	ret = usb_set_interface(usb,

commit 38f4e4215353d430f8413d35807b3d5b444d6aba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:01:18 2013 -0700

    staging: comedi: usbduxsigma: remove some dev_{level} noise
    
    Remove the dev_err() and dev_dbg() messages that are just kernel
    noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index bf65103c40a8..e705907c7587 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -709,9 +709,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-			"ai_cmd not possible. Another ai_cmd is running.\n",
-			dev->minor);
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
@@ -761,10 +758,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
 	}
 	if (this_usbduxsub->ai_timer < 1) {
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: ai_cmd: "
-			"timer=%d, scan_begin_arg=%d. "
-			"Not properly tested by cmdtest?\n", dev->minor,
-			this_usbduxsub->ai_timer, cmd->scan_begin_arg);
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
@@ -817,9 +810,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ai_insn_read not possible. "
-			"Async Command is running.\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
@@ -896,18 +886,11 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ao_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_insn_write: "
-			"ERROR: asynchronous ao_cmd is running\n", dev->minor);
 		up(&this_usbduxsub->sem);
 		return 0;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
-			dev->minor, chan, i, data[i]);
-
 		/* number of channels: 1 */
 		this_usbduxsub->dux_commands[1] = 1;
 		/* channel number */
@@ -1035,9 +1018,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		chan = CR_CHAN(cmd->chanlist[i]);
 		gain = CR_RANGE(cmd->chanlist[i]);
 		this_usbduxsub->dac_commands[i] = chan;
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: dac command for ch %d is %x\n",
-			dev->minor, i, this_usbduxsub->dac_commands[i]);
 	}
 
 	/* we count in steps of 1ms (125us) */
@@ -1050,21 +1030,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* 1ms */
 		/* timing of the scan: we get all channels at once */
 		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: scan_begin_src=%d, scan_begin_arg=%d, "
-			"convert_src=%d, convert_arg=%d\n", dev->minor,
-			cmd->scan_begin_src, cmd->scan_begin_arg,
-			cmd->convert_src, cmd->convert_arg);
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_timer=%d (ms)\n",
-			dev->minor, this_usbduxsub->ao_timer);
 		if (this_usbduxsub->ao_timer < 1) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux: ao_timer=%d, "
-				"scan_begin_arg=%d. "
-				"Not properly tested by cmdtest?\n",
-				dev->minor, this_usbduxsub->ao_timer,
-				cmd->scan_begin_arg);
 			up(&this_usbduxsub->sem);
 			return -EINVAL;
 		}
@@ -1275,18 +1241,11 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: illegal period setting for pwm.\n",
-			dev->minor);
 		return -EAGAIN;
 	} else {
 		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
-		if (fx2delay > 255) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: period %d for pwm is too low.\n",
-				dev->minor, period);
+		if (fx2delay > 255)
 			return -EAGAIN;
-		}
 	}
 	this_usbduxsub->pwmDelay = fx2delay;
 	this_usbduxsub->pwmPeriod = period;

commit 62f85edb3d695361705c36395d084b52f7e4f795
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:00:56 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_dio_insn_config()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    Add a local variable for the channel mask.
    
    Remove the unnecessary comments and clean up the multi-line comment
    at the end.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 1ead4ede8ec5..bf65103c40a8 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1113,34 +1113,33 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int usbdux_dio_insn_config(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_dio_insn_config(struct comedi_device *dev,
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
-	int chan = CR_CHAN(insn->chanspec);
-
-	/* The input or output configuration of each digital line is
-	 * configured by a special insn_config instruction.  chanspec
-	 * contains the channel to be changed, and data[0] contains the
-	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int mask = 1 << chan;
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= 1 << chan;	/* 1 means Out */
+		s->io_bits |= mask;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~(1 << chan);
+		s->io_bits &= ~mask;
 		break;
 	case INSN_CONFIG_DIO_QUERY:
-		data[1] =
-		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		break;
 	default:
 		return -EINVAL;
 		break;
 	}
-	/* we don't tell the firmware here as it would take 8 frames */
-	/* to submit the information. We do it in the insn_bits. */
+
+	/*
+	 * We don't tell the firmware here as it would take 8 frames
+	 * to submit the information. We do it in the (*insn_bits).
+	 */
 	return insn->n;
 }
 
@@ -1516,7 +1515,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
 	s->insn_bits	= usbduxsigma_dio_insn_bits;
-	s->insn_config	= usbdux_dio_insn_config;
+	s->insn_config	= usbduxsigma_dio_insn_config;
 
 	if (devpriv->high_speed) {
 		/* Timer / pwm subdevice */

commit 77a52e69cb3e80dca0122acfaaa51bdbcb5dad5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 13:00:36 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_dio_insn_bits()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    Remove the unnecessary casts.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 44043c5127b1..1ead4ede8ec5 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1144,49 +1144,46 @@ static int usbdux_dio_insn_config(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int usbdux_dio_insn_bits(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
+static int usbduxsigma_dio_insn_bits(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int err;
+	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int mask = data[0];
+	unsigned int bits = data[1];
+	int ret;
 
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
-	s->state &= ~data[0];
-	s->state |= data[0] & data[1];
-	/* The commands are 8 bits wide */
-	this_usbduxsub->dux_commands[1] = (s->io_bits) & 0x000000FF;
-	this_usbduxsub->dux_commands[4] = (s->state) & 0x000000FF;
-	this_usbduxsub->dux_commands[2] = ((s->io_bits) & 0x0000FF00) >> 8;
-	this_usbduxsub->dux_commands[5] = ((s->state) & 0x0000FF00) >> 8;
-	this_usbduxsub->dux_commands[3] = ((s->io_bits) & 0x00FF0000) >> 16;
-	this_usbduxsub->dux_commands[6] = ((s->state) & 0x00FF0000) >> 16;
-
-	/* This command also tells the firmware to return */
-	/* the digital input lines */
-	err = send_dux_commands(dev, SENDDIOBITSCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
-	err = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
-	if (err < 0) {
-		up(&this_usbduxsub->sem);
-		return err;
-	}
+	s->state &= ~mask;
+	s->state |= (bits & mask);
 
-	data[1] = (((unsigned int)(this_usbduxsub->insnBuffer[1]))&0xff) |
-		((((unsigned int)(this_usbduxsub->insnBuffer[2]))&0xff) << 8) |
-		((((unsigned int)(this_usbduxsub->insnBuffer[3]))&0xff) << 16);
+	devpriv->dux_commands[1] = s->io_bits & 0xff;
+	devpriv->dux_commands[4] = s->state & 0xff;
+	devpriv->dux_commands[2] = (s->io_bits >> 8) & 0xff;
+	devpriv->dux_commands[5] = (s->state >> 8) & 0xff;
+	devpriv->dux_commands[3] = (s->io_bits >> 16) & 0xff;
+	devpriv->dux_commands[6] = (s->state >> 16) & 0xff;
 
-	s->state = data[1];
+	ret = send_dux_commands(dev, SENDDIOBITSCOMMAND);
+	if (ret < 0)
+		goto done;
+	ret = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
+	if (ret < 0)
+		goto done;
 
-	up(&this_usbduxsub->sem);
-	return insn->n;
+	s->state = devpriv->insnBuffer[1] |
+		   (devpriv->insnBuffer[2] << 8) |
+		   (devpriv->insnBuffer[3] << 16);
+
+	data[1] = s->state;
+	ret = insn->n;
+
+done:
+	up(&devpriv->sem);
+
+	return ret;
 }
 
 static void usbdux_pwm_stop(struct usbduxsigma_private *devpriv, int do_unlink)
@@ -1518,7 +1515,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->n_chan	= 24;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
-	s->insn_bits	= usbdux_dio_insn_bits;
+	s->insn_bits	= usbduxsigma_dio_insn_bits;
 	s->insn_config	= usbdux_dio_insn_config;
 
 	if (devpriv->high_speed) {

commit a65b091554965e292b5b10977ecffacff74d8908
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:59:24 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_pwm_start()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Remove the unnecessary cast of the pwm delay.
    
    Use memset to initialize the buffer instead of the for loop.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e0358daab2a0..44043c5127b1 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1297,31 +1297,26 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	return 0;
 }
 
-/* is called from insn so there's no need to do all the sanity checks */
-static int usbdux_pwm_start(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
+static int usbduxsigma_pwm_start(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int ret, i;
+	struct usbduxsigma_private *devpriv = dev->private;
+	int ret;
 
-	if (this_usbduxsub->pwm_cmd_running) {
-		/* already running */
+	if (devpriv->pwm_cmd_running)
 		return 0;
-	}
 
-	this_usbduxsub->dux_commands[1] = ((uint8_t) this_usbduxsub->pwmDelay);
+	devpriv->dux_commands[1] = devpriv->pwmDelay;
 	ret = send_dux_commands(dev, SENDPWMON);
 	if (ret < 0)
 		return ret;
 
-	/* initialise the buffer */
-	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
-		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
+	memset(devpriv->urbPwm->transfer_buffer, 0, devpriv->sizePwmBuf);
 
 	ret = usbduxsigma_submit_pwm_urb(dev);
 	if (ret < 0)
 		return ret;
-	this_usbduxsub->pwm_cmd_running = 1;
+	devpriv->pwm_cmd_running = 1;
 
 	return 0;
 }
@@ -1391,7 +1386,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 		 */
 		if (data[1] != 0)
 			return -EINVAL;
-		return usbdux_pwm_start(dev, s);
+		return usbduxsigma_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:

commit ab58a6e35d5f2bbbdd54095df642bcc364e8e3a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:58:43 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_pwm_pattern()
    
    Rename the function so it has namespace associated with the driver.
    
    Tidy up the function to make it more concise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 52f75a4b48e1..e0358daab2a0 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1326,42 +1326,30 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	return 0;
 }
 
-/* generates the bit pattern for PWM with the optional sign bit */
-static int usbdux_pwm_pattern(struct comedi_device *dev,
-			      struct comedi_subdevice *s, int channel,
-			      unsigned int value, unsigned int sign)
+static int usbduxsigma_pwm_pattern(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int chan,
+				   unsigned int value,
+				   unsigned int sign)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	int i, szbuf;
-	char *pBuf;
-	char pwm_mask;
-	char sgn_mask;
-	char c;
-
-	/* this is the DIO bit which carries the PWM data */
-	pwm_mask = (1 << channel);
-	/* this is the DIO bit which carries the optional direction bit */
-	sgn_mask = (16 << channel);
-	/* this is the buffer which will be filled with the with bit */
-	/* pattern for one period */
-	szbuf = this_usbduxsub->sizePwmBuf;
-	pBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);
+	struct usbduxsigma_private *devpriv = dev->private;
+	char pwm_mask = (1 << chan);	/* DIO bit for the PWM data */
+	char sgn_mask = (16 << chan);	/* DIO bit for the sign */
+	char *buf = (char *)(devpriv->urbPwm->transfer_buffer);
+	int szbuf = devpriv->sizePwmBuf;
+	int i;
+
 	for (i = 0; i < szbuf; i++) {
-		c = *pBuf;
-		/* reset bits */
-		c = c & (~pwm_mask);
-		/* set the bit as long as the index is lower than the value */
+		char c = *buf;
+
+		c &= ~pwm_mask;
 		if (i < value)
-			c = c | pwm_mask;
-		/* set the optional sign bit for a relay */
-		if (!sign) {
-			/* positive value */
-			c = c & (~sgn_mask);
-		} else {
-			/* negative value */
-			c = c | sgn_mask;
-		}
-		*(pBuf++) = c;
+			c |= pwm_mask;
+		if (!sign)
+			c &= ~sgn_mask;
+		else
+			c |= sgn_mask;
+		*buf++ = c;
 	}
 	return 1;
 }
@@ -1384,7 +1372,7 @@ static int usbduxsigma_pwm_write(struct comedi_device *dev,
 	 * The sign is set via a special INSN only, this gives us 8 bits
 	 * for normal operation, sign is 0 by default.
 	 */
-	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
+	return usbduxsigma_pwm_pattern(dev, s, chan, data[0], 0);
 }
 
 static int usbduxsigma_pwm_config(struct comedi_device *dev,
@@ -1393,6 +1381,7 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 				  unsigned int *data)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
@@ -1418,8 +1407,8 @@ static int usbduxsigma_pwm_config(struct comedi_device *dev,
 		 * data[1] = value
 		 * data[2] = sign (for a relay)
 		 */
-		return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
-					  data[1], (data[2] != 0));
+		return usbduxsigma_pwm_pattern(dev, s, chan,
+					       data[1], (data[2] != 0));
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
 		/* values are not kept in this driver, nothing to return */
 		return -EINVAL;

commit 4ced8c641ef5b0160edfb994c7001e64e4354fe8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:58:23 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_pwm_write()
    
    Rename the function so it has namespace associated with the driver.
    
    Tidy up the comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 83d7b61e1c90..52f75a4b48e1 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1366,24 +1366,25 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 	return 1;
 }
 
-static int usbdux_pwm_write(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_pwm_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
-	if ((insn->n) != 1) {
-		/*
-		 * doesn't make sense to have more than one value here because
-		 * it would just overwrite the PWM buffer a couple of times
-		 */
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
+	/*
+	 * It doesn't make sense to support more than one value here
+	 * because it would just overwrite the PWM buffer.
+	 */
+	if (insn->n != 1)
 		return -EINVAL;
-	}
 
 	/*
-	 * the sign is set via a special INSN only, this gives us 8 bits for
-	 * normal operation
-	 * relay sign 0 by default
+	 * The sign is set via a special INSN only, this gives us 8 bits
+	 * for normal operation, sign is 0 by default.
 	 */
-	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
+	return usbdux_pwm_pattern(dev, s, chan, data[0], 0);
 }
 
 static int usbduxsigma_pwm_config(struct comedi_device *dev,
@@ -1543,7 +1544,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan	= 8;
 		s->maxdata	= devpriv->sizePwmBuf;
-		s->insn_write	= usbdux_pwm_write;
+		s->insn_write	= usbduxsigma_pwm_write;
 		s->insn_config	= usbduxsigma_pwm_config;
 
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);

commit 92f687ba5efdd1a15f23fb62da85663518e1afed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:58:04 2013 -0700

    staging: comedi: usbduxsigma: remove usbdux_pwm_read()
    
    The comment says its not needed, just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f96e0a77194b..83d7b61e1c90 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1386,14 +1386,6 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
 }
 
-static int usbdux_pwm_read(struct comedi_device *x1,
-			   struct comedi_subdevice *x2, struct comedi_insn *x3,
-			   unsigned int *x4)
-{
-	/* not needed */
-	return -EINVAL;
-};
-
 static int usbduxsigma_pwm_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn,
@@ -1552,7 +1544,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		s->n_chan	= 8;
 		s->maxdata	= devpriv->sizePwmBuf;
 		s->insn_write	= usbdux_pwm_write;
-		s->insn_read	= usbdux_pwm_read;
 		s->insn_config	= usbduxsigma_pwm_config;
 
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);

commit 8939787fe0e0c02b7331b2f67503f18435ebd208
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:57:45 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsigma_pwm_config()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Remove some unnecessary comments and tidy up the comment about the
    parameters for the INSN_CONFIG_PWM_SET_H_BRIDGE instruction.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 81c79d2ca508..f96e0a77194b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1394,15 +1394,15 @@ static int usbdux_pwm_read(struct comedi_device *x1,
 	return -EINVAL;
 };
 
-/* switches on/off PWM */
-static int usbdux_pwm_config(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int usbduxsigma_pwm_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
+
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
-		/* switch it on */
 		/*
 		 * if not zero the PWM is limited to a certain time which is
 		 * not supported here
@@ -1413,27 +1413,20 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	case INSN_CONFIG_DISARM:
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
-		/*
-		 * to check if the USB transmission has failed or in case PWM
-		 * was limited to n cycles to check if it has terminated
-		 */
-		data[1] = this_usbduxsub->pwm_cmd_running;
+		data[1] = devpriv->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
-		data[1] = this_usbduxsub->pwmPeriod;
+		data[1] = devpriv->pwmPeriod;
 		return 0;
 	case INSN_CONFIG_PWM_SET_H_BRIDGE:
-		/* value in the first byte and the sign in the second for a
-		   relay */
-		return usbdux_pwm_pattern(dev, s,
-					  /* the channel number */
-					  CR_CHAN(insn->chanspec),
-					  /* actual PWM data */
-					  data[1],
-					  /* just a sign */
-					  (data[2] != 0));
+		/*
+		 * data[1] = value
+		 * data[2] = sign (for a relay)
+		 */
+		return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec),
+					  data[1], (data[2] != 0));
 	case INSN_CONFIG_PWM_GET_H_BRIDGE:
 		/* values are not kept in this driver, nothing to return */
 		return -EINVAL;
@@ -1560,7 +1553,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		s->maxdata	= devpriv->sizePwmBuf;
 		s->insn_write	= usbdux_pwm_write;
 		s->insn_read	= usbdux_pwm_read;
-		s->insn_config	= usbdux_pwm_config;
+		s->insn_config	= usbduxsigma_pwm_config;
 
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}

commit 46c878080bcdf2c6c173c12f67801bb425a7c2bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:57:25 2013 -0700

    staging: comedi: usbduxsigma: move usbduxsigma_firmware_upload()
    
    For aesthetics, move this function near its caller. Also, move the
    FIRMWARE_MAX_LEN define so its with the other firmware constants
    and fix the whitespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 76431ee9f9bc..81c79d2ca508 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -55,10 +55,11 @@ Status: testing
 #define BULK_TIMEOUT 1000
 
 /* constants for "firmware" upload and download */
-#define FIRMWARE "usbduxsigma_firmware.bin"
-#define USBDUXSUB_FIRMWARE 0xA0
-#define VENDOR_DIR_IN  0xC0
-#define VENDOR_DIR_OUT 0x40
+#define FIRMWARE		"usbduxsigma_firmware.bin"
+#define FIRMWARE_MAX_LEN	0x4000
+#define USBDUXSUB_FIRMWARE	0xa0
+#define VENDOR_DIR_IN		0xc0
+#define VENDOR_DIR_OUT		0x40
 
 /* internal addresses of the 8051 processor */
 #define USBDUXSUB_CPUCS 0xE600
@@ -482,80 +483,6 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 }
 
-/* the FX2LP has twice as much as the standard FX2 */
-#define FIRMWARE_MAX_LEN 0x4000
-
-static int usbduxsigma_firmware_upload(struct comedi_device *dev,
-				       const u8 *data, size_t size,
-				       unsigned long context)
-{
-	struct usb_device *usb = comedi_to_usb_dev(dev);
-	uint8_t *buf;
-	uint8_t *tmp;
-	int ret;
-
-	if (!data)
-		return 0;
-
-	if (size > FIRMWARE_MAX_LEN) {
-		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
-		return -ENOMEM;
-	}
-
-	/* we generate a local buffer for the firmware */
-	buf = kmemdup(data, size, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	/* we need a malloc'ed buffer for usb_control_msg() */
-	tmp = kmalloc(1, GFP_KERNEL);
-	if (!tmp) {
-		kfree(buf);
-		return -ENOMEM;
-	}
-
-	/* stop the current firmware on the device */
-	*tmp = 1;	/* 7f92 to one */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      USBDUXSUB_CPUCS, 0x0000,
-			      tmp, 1,
-			      BULK_TIMEOUT);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "can not stop firmware\n");
-		goto done;
-	}
-
-	/* upload the new firmware to the device */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      0, 0x0000,
-			      buf, size,
-			      BULK_TIMEOUT);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "firmware upload failed\n");
-		goto done;
-	}
-
-	/* start the new firmware on the device */
-	*tmp = 0;	/* 7f92 to zero */
-	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
-			      USBDUXSUB_FIRMWARE,
-			      VENDOR_DIR_OUT,
-			      USBDUXSUB_CPUCS, 0x0000,
-			      tmp, 1,
-			      BULK_TIMEOUT);
-	if (ret < 0)
-		dev_err(dev->class_dev, "can not start firmware\n");
-
-done:
-	kfree(tmp);
-	kfree(buf);
-	return ret;
-}
-
 static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 				   struct urb **urbs, int num_urbs,
 				   int input_urb)
@@ -1650,6 +1577,77 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	return 0;
 }
 
+static int usbduxsigma_firmware_upload(struct comedi_device *dev,
+				       const u8 *data, size_t size,
+				       unsigned long context)
+{
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	uint8_t *buf;
+	uint8_t *tmp;
+	int ret;
+
+	if (!data)
+		return 0;
+
+	if (size > FIRMWARE_MAX_LEN) {
+		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
+		return -ENOMEM;
+	}
+
+	/* we generate a local buffer for the firmware */
+	buf = kmemdup(data, size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* we need a malloc'ed buffer for usb_control_msg() */
+	tmp = kmalloc(1, GFP_KERNEL);
+	if (!tmp) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	/* stop the current firmware on the device */
+	*tmp = 1;	/* 7f92 to one */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0) {
+		dev_err(dev->class_dev, "can not stop firmware\n");
+		goto done;
+	}
+
+	/* upload the new firmware to the device */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      0, 0x0000,
+			      buf, size,
+			      BULK_TIMEOUT);
+	if (ret < 0) {
+		dev_err(dev->class_dev, "firmware upload failed\n");
+		goto done;
+	}
+
+	/* start the new firmware on the device */
+	*tmp = 0;	/* 7f92 to zero */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0)
+		dev_err(dev->class_dev, "can not start firmware\n");
+
+done:
+	kfree(tmp);
+	kfree(buf);
+	return ret;
+}
+
 static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);

commit 5f1d72ecfbf5d4a2c8ed12d9a4da97ecd239c02d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:56:59 2013 -0700

    staging: comedi: usbduxsigma: remove an extra ';'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 3217b4c9f480..76431ee9f9bc 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1852,7 +1852,7 @@ static struct comedi_driver usbduxsigma_driver = {
 static int usbduxsigma_usb_probe(struct usb_interface *intf,
 				 const struct usb_device_id *id)
 {
-	return comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);;
+	return comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);
 }
 
 static const struct usb_device_id usbduxsigma_usb_table[] = {

commit e0b12e6e9af16257f9c9c47ef999d84513b2f3f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:56:36 2013 -0700

    staging: comedi: usbduxsigma: tidy up tidy_up()
    
    Rename the function so it has namespace associated with the driver.
    
    For aesthetic reasons, move the function so it's near the one that
    allocates the usb buffers.
    
    Tidy up the function so it frees the buffers in the opposite order
    they were allocated. Also remove the = NULL for all the buffers,
    the driver is being detached so the comedi core will kfree the
    private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f85a477865dc..3217b4c9f480 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1514,62 +1514,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	return -EINVAL;
 }
 
-/* end of PWM */
-/*****************************************************************/
-
-static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
-{
-	int i;
-
-	/* force unlink all urbs */
-	usbdux_ai_stop(usbduxsub_tmp, 1);
-	usbdux_ao_stop(usbduxsub_tmp, 1);
-	usbdux_pwm_stop(usbduxsub_tmp, 1);
-
-	if (usbduxsub_tmp->urbIn) {
-		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
-			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
-			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
-			usb_free_urb(usbduxsub_tmp->urbIn[i]);
-			usbduxsub_tmp->urbIn[i] = NULL;
-		}
-		kfree(usbduxsub_tmp->urbIn);
-		usbduxsub_tmp->urbIn = NULL;
-	}
-	if (usbduxsub_tmp->urbOut) {
-		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
-				kfree(usbduxsub_tmp->
-				      urbOut[i]->transfer_buffer);
-				usbduxsub_tmp->urbOut[i]->transfer_buffer =
-				    NULL;
-			}
-			if (usbduxsub_tmp->urbOut[i]) {
-				usb_free_urb(usbduxsub_tmp->urbOut[i]);
-				usbduxsub_tmp->urbOut[i] = NULL;
-			}
-		}
-		kfree(usbduxsub_tmp->urbOut);
-		usbduxsub_tmp->urbOut = NULL;
-	}
-	if (usbduxsub_tmp->urbPwm) {
-		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
-		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
-		usb_free_urb(usbduxsub_tmp->urbPwm);
-		usbduxsub_tmp->urbPwm = NULL;
-	}
-	kfree(usbduxsub_tmp->inBuffer);
-	usbduxsub_tmp->inBuffer = NULL;
-	kfree(usbduxsub_tmp->insnBuffer);
-	usbduxsub_tmp->insnBuffer = NULL;
-	kfree(usbduxsub_tmp->outBuffer);
-	usbduxsub_tmp->outBuffer = NULL;
-	kfree(usbduxsub_tmp->dac_commands);
-	usbduxsub_tmp->dac_commands = NULL;
-	kfree(usbduxsub_tmp->dux_commands);
-	usbduxsub_tmp->dux_commands = NULL;
-}
-
 static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -1793,6 +1737,49 @@ static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 	return 0;
 }
 
+static void usbduxsigma_free_usb_buffers(struct comedi_device *dev)
+{
+	struct usbduxsigma_private *devpriv = dev->private;
+	struct urb *urb;
+	int i;
+
+	/* force unlink all urbs */
+	usbdux_ai_stop(devpriv, 1);
+	usbdux_ao_stop(devpriv, 1);
+	usbdux_pwm_stop(devpriv, 1);
+
+	urb = devpriv->urbPwm;
+	if (urb) {
+		kfree(urb->transfer_buffer);
+		usb_free_urb(urb);
+	}
+	if (devpriv->urbOut) {
+		for (i = 0; i < devpriv->numOfOutBuffers; i++) {
+			urb = devpriv->urbOut[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				usb_free_urb(urb);
+			}
+		}
+		kfree(devpriv->urbOut);
+	}
+	if (devpriv->urbIn) {
+		for (i = 0; i < devpriv->numOfInBuffers; i++) {
+			urb = devpriv->urbIn[i];
+			if (urb) {
+				kfree(urb->transfer_buffer);
+				usb_free_urb(urb);
+			}
+		}
+		kfree(devpriv->urbIn);
+	}
+	kfree(devpriv->outBuffer);
+	kfree(devpriv->insnBuffer);
+	kfree(devpriv->inBuffer);
+	kfree(devpriv->dux_commands);
+	kfree(devpriv->dac_commands);
+}
+
 static int usbduxsigma_auto_attach(struct comedi_device *dev,
 				   unsigned long context_unused)
 {
@@ -1851,7 +1838,7 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usb_set_intfdata(intf, NULL);
 
 	down(&devpriv->sem);
-	tidy_up(devpriv);
+	usbduxsigma_free_usb_buffers(dev);
 	up(&devpriv->sem);
 }
 

commit 988f5541dbae1f28e0e317f04963aa0c0068520e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:56:12 2013 -0700

    staging: comedi: usbduxsigma: kill all urbs before freeing them
    
    For aesthetic reasons, kill all the urbs before freeing them.
    Also, remove a redundant killing of the ai and ao urbs in the
    (*detach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 30ada7d8d935..f85a477865dc 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1521,9 +1521,12 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 {
 	int i;
 
+	/* force unlink all urbs */
+	usbdux_ai_stop(usbduxsub_tmp, 1);
+	usbdux_ao_stop(usbduxsub_tmp, 1);
+	usbdux_pwm_stop(usbduxsub_tmp, 1);
+
 	if (usbduxsub_tmp->urbIn) {
-		/* force unlink all urbs */
-		usbdux_ai_stop(usbduxsub_tmp, 1);
 		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
 			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
 			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
@@ -1534,8 +1537,6 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 		usbduxsub_tmp->urbIn = NULL;
 	}
 	if (usbduxsub_tmp->urbOut) {
-		/* force unlink all urbs */
-		usbdux_ao_stop(usbduxsub_tmp, 1);
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
 				kfree(usbduxsub_tmp->
@@ -1552,8 +1553,6 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 		usbduxsub_tmp->urbOut = NULL;
 	}
 	if (usbduxsub_tmp->urbPwm) {
-		/* force unlink urb */
-		usbdux_pwm_stop(usbduxsub_tmp, 1);
 		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
 		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
 		usb_free_urb(usbduxsub_tmp->urbPwm);
@@ -1849,10 +1848,6 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	if (!devpriv)
 		return;
 
-	/* stop any running commands */
-	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
-	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
-
 	usb_set_intfdata(intf, NULL);
 
 	down(&devpriv->sem);

commit 137beb77c7ce3326f78622f8a309b3c8752b0e62
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:55:48 2013 -0700

    staging: comedi: usbduxsigma: move usb_set_intfdata(intf, NULL) to (*detach)
    
    For aesthetic reasons, move the clearing of the interface data to
    the (*detach) since its set in the (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b879965565ad..30ada7d8d935 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1521,10 +1521,6 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 {
 	int i;
 
-	/* shows the usb subsystem that the driver is down */
-	if (usbduxsub_tmp->interface)
-		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
-
 	if (usbduxsub_tmp->urbIn) {
 		/* force unlink all urbs */
 		usbdux_ai_stop(usbduxsub_tmp, 1);
@@ -1847,6 +1843,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 
 static void usbduxsigma_detach(struct comedi_device *dev)
 {
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
 
 	if (!devpriv)
@@ -1856,6 +1853,8 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
 	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
 
+	usb_set_intfdata(intf, NULL);
+
 	down(&devpriv->sem);
 	tidy_up(devpriv);
 	up(&devpriv->sem);

commit 1fc56e86e49c93e426937377fc485734a81870da
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:55:28 2013 -0700

    staging: comedi: usbduxsigma: remove tidy_up() from (*auto_attach)
    
    Comedi drivers do not need to cleanup allocations during the
    (*auto_attach). If the (*auto_attach) fails the (*detach) will
    automatically be called to handle the cleanup.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index bdbcc4843c2f..b879965565ad 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1834,10 +1834,8 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	}
 
 	ret = usbduxsigma_alloc_usb_buffers(dev);
-	if (ret) {
-		tidy_up(devpriv);
+	if (ret)
 		return ret;
-	}
 
 	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
 				   usbduxsigma_firmware_upload, 0);

commit 9838f532dc714011f236039e91f8d8654b3b4cc7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:55:08 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_getstatusinfo()
    
    Rename the function so it has namespace associated with the driver.
    
    Move the function closer to its only caller and tidy it up a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2764f9b5ad71..bdbcc4843c2f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -940,76 +940,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	return i;
 }
 
-
-
-
-static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
-{
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-	uint8_t sysred = 0;
-	uint32_t one;
-	int err;
-
-	if (this_usbduxsub->ai_cmd_running) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: status read not possible. "
-			"Async Command is running.\n", dev->minor);
-		return 0;
-	}
-
-	/* CONFIG0 */
-	this_usbduxsub->dux_commands[1] = 0x12;
-
-	/* CONFIG1: 2kHz sampling rate */
-	this_usbduxsub->dux_commands[2] = 0x80;
-
-	/* CONFIG3: differential channels off */
-	this_usbduxsub->dux_commands[3] = 0x00;
-
-	if (chan == 1) {
-		/* ADC offset */
-		sysred = sysred | 1;
-	} else if (chan == 2) {
-		/* VCC */
-		sysred = sysred | 4;
-	} else if (chan == 3) {
-		/* temperature */
-		sysred = sysred | 8;
-	} else if (chan == 4) {
-		/* gain */
-		sysred = sysred | 16;
-	} else if (chan == 5) {
-		/* ref */
-		sysred = sysred | 32;
-	}
-
-	this_usbduxsub->dux_commands[4] = 0;
-	this_usbduxsub->dux_commands[5] = 0;
-	this_usbduxsub->dux_commands[6] = sysred;
-
-	/* adc commands */
-	err = send_dux_commands(dev, SENDSINGLEAD);
-	if (err < 0)
-		return err;
-
-	err = receive_dux_commands(dev, SENDSINGLEAD);
-	if (err < 0)
-		return err;
-
-	/* 32 bits big endian from the A/D converter */
-	one = be32_to_cpu(*((int32_t *)((this_usbduxsub->insnBuffer)+1)));
-	/* mask out the status byte */
-	one = one & 0x00ffffff;
-	one = one ^ 0x00800000;
-
-	return (int)one;
-}
-
-
-
-
-
-
 /************************************/
 /* analog out */
 
@@ -1645,6 +1575,57 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 	usbduxsub_tmp->dux_commands = NULL;
 }
 
+static int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)
+{
+	struct usbduxsigma_private *devpriv = dev->private;
+	uint8_t sysred;
+	uint32_t val;
+	int ret;
+
+	switch (chan) {
+	default:
+	case 0:
+		sysred = 0;		/* ADC zero */
+		break;
+	case 1:
+		sysred = 1;		/* ADC offset */
+		break;
+	case 2:
+		sysred = 4;		/* VCC */
+		break;
+	case 3:
+		sysred = 8;		/* temperature */
+		break;
+	case 4:
+		sysred = 16;		/* gain */
+		break;
+	case 5:
+		sysred =  32;		/* ref */
+		break;
+	}
+
+	devpriv->dux_commands[1] = 0x12; /* CONFIG0 */
+	devpriv->dux_commands[2] = 0x80; /* CONFIG1: 2kHz sampling rate */
+	devpriv->dux_commands[3] = 0x00; /* CONFIG3: diff. channels off */
+	devpriv->dux_commands[4] = 0;
+	devpriv->dux_commands[5] = 0;
+	devpriv->dux_commands[6] = sysred;
+	ret = send_dux_commands(dev, SENDSINGLEAD);
+	if (ret < 0)
+		return ret;
+
+	ret = receive_dux_commands(dev, SENDSINGLEAD);
+	if (ret < 0)
+		return ret;
+
+	/* 32 bits big endian from the A/D converter */
+	val = be32_to_cpu(*((int32_t *)((devpriv->insnBuffer)+1)));
+	val &= 0x00ffffff;	/* strip status byte */
+	val ^= 0x00800000;	/* convert to unsigned */
+
+	return (int)val;
+}
+
 static int usbduxsigma_attach_common(struct comedi_device *dev)
 {
 	struct usbduxsigma_private *devpriv = dev->private;
@@ -1720,7 +1701,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 
 	up(&devpriv->sem);
 
-	offset = usbdux_getstatusinfo(dev, 0);
+	offset = usbduxsigma_getstatusinfo(dev, 0);
 	if (offset < 0)
 		dev_err(dev->class_dev,
 			"Communication to USBDUXSIGMA failed! Check firmware and cabling\n");

commit 78f48506f5314f73580ccdd721d2326100621734
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:54:49 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsigma_attach_common()
    
    Rename the local variable used for the comedi_device private data.
    
    Remove all the unnecessary comments and add some whitespace to the
    subdevice init.
    
    Use dev->class_dev for the dev_{level} messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 46eda57ad8fa..2764f9b5ad71 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1647,108 +1647,86 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 
 static int usbduxsigma_attach_common(struct comedi_device *dev)
 {
-	struct usbduxsigma_private *uds = dev->private;
-	int ret;
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	int n_subdevs;
 	int offset;
+	int ret;
 
-	down(&uds->sem);
+	down(&devpriv->sem);
 
-	/* set number of subdevices */
-	if (uds->high_speed)
+	if (devpriv->high_speed)
 		n_subdevs = 4;	/* with pwm */
 	else
 		n_subdevs = 3;	/* without pwm */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret) {
-		up(&uds->sem);
+		up(&devpriv->sem);
 		return ret;
 	}
-	/* the first subdevice is the A/D converter */
+
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	/* the URBs get the comedi subdevice */
-	/* which is responsible for reading */
-	/* this is the subdevice which reads data */
 	dev->read_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground, 32 bit wide data! */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND |
-		SDF_CMD_READ | SDF_LSAMPL;
-	/* 16 A/D channels */
-	s->n_chan = NUMCHANNELS;
-	/* length of the channellist */
-	s->len_chanlist = NUMCHANNELS;
-	/* callback functions */
-	s->insn_read = usbdux_ai_insn_read;
-	s->do_cmdtest = usbdux_ai_cmdtest;
-	s->do_cmd = usbdux_ai_cmd;
-	s->cancel = usbdux_ai_cancel;
-	/* max value from the A/D converter (24bit) */
-	s->maxdata = 0x00FFFFFF;
-	/* range table to convert to physical units */
-	s->range_table = (&range_usbdux_ai_range);
-	/* analog output subdevice */
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_CMD_READ | SDF_LSAMPL;
+	s->n_chan	= NUMCHANNELS;
+	s->len_chanlist	= NUMCHANNELS;
+	s->maxdata	= 0x00ffffff;
+	s->range_table	= &range_usbdux_ai_range;
+	s->insn_read	= usbdux_ai_insn_read;
+	s->do_cmdtest	= usbdux_ai_cmdtest;
+	s->do_cmd	= usbdux_ai_cmd;
+	s->cancel	= usbdux_ai_cancel;
+
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	/* analog out */
-	s->type = COMEDI_SUBD_AO;
-	/* backward pointer */
 	dev->write_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* are writable */
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	/* 4 channels */
-	s->n_chan = 4;
-	/* length of the channellist */
-	s->len_chanlist = 4;
-	/* 8 bit resolution */
-	s->maxdata = 0x00ff;
-	/* unipolar range */
-	s->range_table = &range_unipolar2_5;
-	/* callback */
-	s->do_cmdtest = usbdux_ao_cmdtest;
-	s->do_cmd = usbdux_ao_cmd;
-	s->cancel = usbdux_ao_cancel;
-	s->insn_read = usbdux_ao_insn_read;
-	s->insn_write = usbdux_ao_insn_write;
-	/* digital I/O subdevice */
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	s->n_chan	= 4;
+	s->len_chanlist	= 4;
+	s->maxdata	= 0x00ff;
+	s->range_table	= &range_unipolar2_5;
+	s->insn_write	= usbdux_ao_insn_write;
+	s->insn_read	= usbdux_ao_insn_read;
+	s->do_cmdtest	= usbdux_ao_cmdtest;
+	s->do_cmd	= usbdux_ao_cmd;
+	s->cancel	= usbdux_ao_cancel;
+
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	/* 8 external and 16 internal channels */
-	s->n_chan = 24;
-	s->maxdata = 1;
-	s->range_table = (&range_digital);
-	s->insn_bits = usbdux_dio_insn_bits;
-	s->insn_config = usbdux_dio_insn_config;
-	/* we don't use it */
-	s->private = NULL;
-	if (uds->high_speed) {
-		/* timer / pwm subdevice */
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 24;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= usbdux_dio_insn_bits;
+	s->insn_config	= usbdux_dio_insn_config;
+
+	if (devpriv->high_speed) {
+		/* Timer / pwm subdevice */
 		s = &dev->subdevices[3];
-		s->type = COMEDI_SUBD_PWM;
-		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan = 8;
-		/* this defines the max duty cycle resolution */
-		s->maxdata = uds->sizePwmBuf;
-		s->insn_write = usbdux_pwm_write;
-		s->insn_read = usbdux_pwm_read;
-		s->insn_config = usbdux_pwm_config;
+		s->type		= COMEDI_SUBD_PWM;
+		s->subdev_flags	= SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan	= 8;
+		s->maxdata	= devpriv->sizePwmBuf;
+		s->insn_write	= usbdux_pwm_write;
+		s->insn_read	= usbdux_pwm_read;
+		s->insn_config	= usbdux_pwm_config;
+
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
-	up(&uds->sem);
+
+	up(&devpriv->sem);
+
 	offset = usbdux_getstatusinfo(dev, 0);
 	if (offset < 0)
-		dev_err(&uds->interface->dev,
-			"Communication to USBDUXSIGMA failed! Check firmware and cabling.");
-	dev_info(&uds->interface->dev,
-		 "comedi%d: attached, ADC_zero = %x\n", dev->minor, offset);
+		dev_err(dev->class_dev,
+			"Communication to USBDUXSIGMA failed! Check firmware and cabling\n");
+
+	dev_info(dev->class_dev, "attached, ADC_zero = %x\n", offset);
+
 	return 0;
 }
 

commit af87e188902141f3ec9e485a97f568e86b2b2363
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:54:25 2013 -0700

    staging: comedi: usbduxsigma: remove SUBDEV_* defines
    
    The SUBDEV_* defines are only used during the (*auto_attach). Remove
    the defines and just open code the values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e9dfbb3e7de3..46eda57ad8fa 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -142,18 +142,6 @@ Status: testing
 /* must have more buffers due to buggy USB ctr */
 #define NUMOFOUTBUFFERSHIGH    10
 
-/* Analogue in subdevice */
-#define SUBDEV_AD             0
-
-/* Analogue out subdevice */
-#define SUBDEV_DA             1
-
-/* Digital I/O */
-#define SUBDEV_DIO            2
-
-/* timer aka pwm output */
-#define SUBDEV_PWM            3
-
 /* number of retries to get the right dux command */
 #define RETRIES 10
 
@@ -1678,7 +1666,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 		return ret;
 	}
 	/* the first subdevice is the A/D converter */
-	s = &dev->subdevices[SUBDEV_AD];
+	s = &dev->subdevices[0];
 	/* the URBs get the comedi subdevice */
 	/* which is responsible for reading */
 	/* this is the subdevice which reads data */
@@ -1705,7 +1693,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	/* range table to convert to physical units */
 	s->range_table = (&range_usbdux_ai_range);
 	/* analog output subdevice */
-	s = &dev->subdevices[SUBDEV_DA];
+	s = &dev->subdevices[1];
 	/* analog out */
 	s->type = COMEDI_SUBD_AO;
 	/* backward pointer */
@@ -1730,7 +1718,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->insn_read = usbdux_ao_insn_read;
 	s->insn_write = usbdux_ao_insn_write;
 	/* digital I/O subdevice */
-	s = &dev->subdevices[SUBDEV_DIO];
+	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 	/* 8 external and 16 internal channels */
@@ -1743,7 +1731,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	s->private = NULL;
 	if (uds->high_speed) {
 		/* timer / pwm subdevice */
-		s = &dev->subdevices[SUBDEV_PWM];
+		s = &dev->subdevices[3];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;

commit 982d255b3e5d5945b91a84b019841736bcee96dc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:54:06 2013 -0700

    staging: comedi: usbduxsigma: remove unnecessary check in usbdux_ao_cmd()
    
    The comedi core verifies that the command chanlist_len is valid for
    the subdevice based on the len_chanlist that was setup during the
    attach. There is no need to recheck it in the (*cmd) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index dab1a3cf3fcd..e9dfbb3e7de3 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1189,12 +1189,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
 		gain = CR_RANGE(cmd->chanlist[i]);
-		if (i >= NUMOUTCHANNELS) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: %s: channel list too long\n",
-				dev->minor, __func__);
-			break;
-		}
 		this_usbduxsub->dac_commands[i] = chan;
 		dev_dbg(&this_usbduxsub->interface->dev,
 			"comedi%d: dac command for ch %d is %x\n",

commit 01a4303d392841cca293fc3895e3f4985c5365d6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:53:46 2013 -0700

    staging: comedi: usbduxsigma: remove unnecessary check in usbdux_ai_cmd()
    
    The comedi core verifies that the command chanlist_len is valid for
    the subdevice based on the len_chanlist that was setup during the
    attach. There is no need to recheck it in the (*cmd) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 7fcf30cad8ac..dab1a3cf3fcd 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -818,12 +818,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		chan = CR_CHAN(cmd->chanlist[i]);
 		create_adc_command(chan, &muxsg0, &muxsg1);
-		if (i >= NUMCHANNELS) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: channel list too long\n",
-				dev->minor);
-			break;
-		}
 	}
 	this_usbduxsub->dux_commands[5] = muxsg0;
 	this_usbduxsub->dux_commands[6] = muxsg1;

commit 8eea6dbd7359aaf517d35201e27642a9785a691b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:53:23 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_ai_inttrig()
    
    Rename the function so it has namespace associated with the driver.
    Rename the local variable used for the private data pointer.
    
    Remove the dev_err() messages, they are just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5cdba42e4a6c..7fcf30cad8ac 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -754,36 +754,29 @@ static int receive_dux_commands(struct comedi_device *dev, int command)
 	return -EFAULT;
 }
 
-static int usbdux_ai_inttrig(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int trignum)
+static int usbduxsigma_ai_inttrig(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  unsigned int trignum)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv= dev->private;
 	int ret;
 
-	down(&this_usbduxsub->sem);
-	if (trignum != 0) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
-			dev->minor);
-		up(&this_usbduxsub->sem);
+	if (trignum != 0)
 		return -EINVAL;
-	}
-	if (!this_usbduxsub->ai_cmd_running) {
-		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbIn,
-					      this_usbduxsub->numOfInBuffers,
-					      1);
+
+	down(&devpriv->sem);
+	if (!devpriv->ai_cmd_running) {
+		ret = usbduxsigma_submit_urbs(dev, devpriv->urbIn,
+					      devpriv->numOfInBuffers, 1);
 		if (ret < 0) {
-			up(&this_usbduxsub->sem);
+			up(&devpriv->sem);
 			return ret;
 		}
-		this_usbduxsub->ai_cmd_running = 1;
+		devpriv->ai_cmd_running = 1;
 		s->async->inttrig = NULL;
-	} else {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ai_inttrig but acqu is already running\n",
-			dev->minor);
 	}
-	up(&this_usbduxsub->sem);
+	up(&devpriv->sem);
+
 	return 1;
 }
 
@@ -893,7 +886,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* TRIG_INT */
 		/* don't enable the acquision operation */
 		/* wait for an internal signal */
-		s->async->inttrig = usbdux_ai_inttrig;
+		s->async->inttrig = usbduxsigma_ai_inttrig;
 	}
 	up(&this_usbduxsub->sem);
 	return 0;

commit 2d4462d28a014456e5b364106c1be4624e656d58
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:52:59 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbdux_ao_inttrig()
    
    Rename the function so it has namespace associated with the driver.
    
    Rename the local variable used for the private data pointer.
    
    Remove the dev_err() messages, they are just added noise.
    
    Refactor the code to remove the goto.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e331ef596ef3..5cdba42e4a6c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1093,37 +1093,30 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	return i;
 }
 
-static int usbdux_ao_inttrig(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int trignum)
+static int usbduxsigma_ao_inttrig(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  unsigned int trignum)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	int ret;
 
-	down(&this_usbduxsub->sem);
-	if (trignum != 0) {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
-			dev->minor);
-		ret = -EINVAL;
-		goto out;
-	}
-	if (!(this_usbduxsub->ao_cmd_running)) {
-		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbOut,
-					      this_usbduxsub->numOfOutBuffers,
-					      0);
-		if (ret < 0)
-			goto out;
-		this_usbduxsub->ao_cmd_running = 1;
+	if (trignum != 0)
+		return -EINVAL;
+
+	down(&devpriv->sem);
+	if (!devpriv->ao_cmd_running) {
+		ret = usbduxsigma_submit_urbs(dev, devpriv->urbOut,
+					      devpriv->numOfOutBuffers, 0);
+		if (ret < 0) {
+			up(&devpriv->sem);
+			return ret;
+		}
+		devpriv->ao_cmd_running = 1;
 		s->async->inttrig = NULL;
-	} else {
-		dev_err(&this_usbduxsub->interface->dev,
-			"comedi%d: ao_inttrig but acqu is already running.\n",
-			dev->minor);
 	}
-	ret = 1;
-out:
-	up(&this_usbduxsub->sem);
-	return ret;
+	up(&devpriv->sem);
+
+	return 1;
 }
 
 static int usbdux_ao_cmdtest(struct comedi_device *dev,
@@ -1287,7 +1280,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* TRIG_INT */
 		/* submit the urbs later */
 		/* wait for an internal signal */
-		s->async->inttrig = usbdux_ao_inttrig;
+		s->async->inttrig = usbduxsigma_ao_inttrig;
 	}
 
 	up(&this_usbduxsub->sem);

commit edd2d33ee88cc8b1b2cd65baa4381a1c1a5ca747
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:52:37 2013 -0700

    staging: comedi: usbduxsigma: remove private data sanity checks
    
    The comedi functions in this driver can only be called if the
    (*auto_attach) successfull kzalloc'ed the private data and set
    dev->private. The extra sanity checks are not needed. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 6c9f67ccbb5c..e331ef596ef3 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -759,8 +759,6 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 {
 	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int ret;
-	if (!this_usbduxsub)
-		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
 	if (trignum != 0) {
@@ -800,9 +798,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	uint8_t muxsg1 = 0;
 	uint8_t sysred = 0;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
@@ -918,9 +913,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	uint8_t muxsg1 = 0;
 	uint8_t sysred = 0;
 
-	if (!this_usbduxsub)
-		return 0;
-
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
@@ -983,9 +975,6 @@ static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
 	uint32_t one;
 	int err;
 
-	if (!this_usbduxsub)
-		return 0;
-
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: status read not possible. "
@@ -1057,9 +1046,6 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	down(&this_usbduxsub->sem);
 	for (i = 0; i < insn->n; i++)
 		data[i] = this_usbduxsub->outBuffer[chan];
@@ -1076,9 +1062,6 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	down(&this_usbduxsub->sem);
 	if (this_usbduxsub->ao_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
@@ -1116,9 +1099,6 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int ret;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	down(&this_usbduxsub->sem);
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
@@ -1150,13 +1130,9 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int err = 0;
 	unsigned int flags;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1227,9 +1203,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned int chan, gain;
 	int i, ret;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	down(&this_usbduxsub->sem);
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
@@ -1360,9 +1333,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int err;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	down(&this_usbduxsub->sem);
 
 	/* The insn data is a mask in data[0] and the new data
@@ -1549,9 +1519,6 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 	char sgn_mask;
 	char c;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	/* this is the DIO bit which carries the PWM data */
 	pwm_mask = (1 << channel);
 	/* this is the DIO bit which carries the optional direction bit */
@@ -1584,11 +1551,6 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsigma_private *this_usbduxsub = dev->private;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
-
 	if ((insn->n) != 1) {
 		/*
 		 * doesn't make sense to have more than one value here because
@@ -1667,9 +1629,6 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 {
 	int i;
 
-	if (!usbduxsub_tmp)
-		return;
-
 	/* shows the usb subsystem that the driver is down */
 	if (usbduxsub_tmp->interface)
 		usb_set_intfdata(usbduxsub_tmp->interface, NULL);

commit 2a8cdc6861557f3ed67e8dbef667fb3ccc61e459
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:52:17 2013 -0700

    staging: comedi: usbduxsigma: tidy up firmware upload error messages
    
    Use dev->class_dev for all dev_{level} messages.
    
    Remove the unnecessary error message for a kmemdup() failure.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 88224d6579ab..6c9f67ccbb5c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -502,7 +502,6 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 				       unsigned long context)
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
-	struct usbduxsigma_private *usbduxsub = dev->private;
 	uint8_t *buf;
 	uint8_t *tmp;
 	int ret;
@@ -511,18 +510,14 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 		return 0;
 
 	if (size > FIRMWARE_MAX_LEN) {
-		dev_err(&usbduxsub->interface->dev,
-			"usbduxsigma firmware binary it too large for FX2.\n");
+		dev_err(dev->class_dev, "firmware binary too large for FX2\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
 	buf = kmemdup(data, size, GFP_KERNEL);
-	if (!buf) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: mem alloc for firmware failed\n");
+	if (!buf)
 		return -ENOMEM;
-	}
 
 	/* we need a malloc'ed buffer for usb_control_msg() */
 	tmp = kmalloc(1, GFP_KERNEL);
@@ -540,8 +535,7 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 			      tmp, 1,
 			      BULK_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: can not stop firmware\n");
+		dev_err(dev->class_dev, "can not stop firmware\n");
 		goto done;
 	}
 
@@ -553,8 +547,7 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 			      buf, size,
 			      BULK_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: firmware upload failed\n");
+		dev_err(dev->class_dev, "firmware upload failed\n");
 		goto done;
 	}
 
@@ -567,8 +560,7 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 			      tmp, 1,
 			      BULK_TIMEOUT);
 	if (ret < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: can not start firmware\n");
+		dev_err(dev->class_dev, "can not start firmware\n");
 
 done:
 	kfree(tmp);

commit a59a28a32fdfe011ce5045f2a5a207f634d84b2c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:51:56 2013 -0700

    staging: comedi: usbduxsigma: remove 'usbdev' from the private data
    
    This back pointer to the usb_device is not needed in the private data.
    Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 6a34b673cf92..88224d6579ab 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -166,8 +166,6 @@ static const struct comedi_lrange range_usbdux_ai_range = { 1, {
 };
 
 struct usbduxsigma_private {
-	/* pointer to the usb-device */
-	struct usb_device *usbdev;
 	/* actual number of in-buffers */
 	int numOfInBuffers;
 	/* actual number of out-buffers */
@@ -304,7 +302,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	if (unlikely(!devpriv->ai_cmd_running))
 		return;
 
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
 	if (unlikely(ret < 0)) {
@@ -472,7 +470,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 
 	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	if (devpriv->high_speed)
 		urb->interval = 8;	/* uframes */
@@ -503,8 +501,8 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 				       const u8 *data, size_t size,
 				       unsigned long context)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *usbduxsub = dev->private;
-	struct usb_device *usb = usbduxsub->usbdev;
 	uint8_t *buf;
 	uint8_t *tmp;
 	int ret;
@@ -582,6 +580,7 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 				   struct urb **urbs, int num_urbs,
 				   int input_urb)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxsigma_private *devpriv = dev->private;
 	struct urb *urb;
 	int ret;
@@ -595,7 +594,7 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 		if (input_urb)
 			urb->interval = devpriv->ai_interval;
 		urb->context = dev;
-		urb->dev = devpriv->usbdev;
+		urb->dev = usb;
 		urb->status = 0;
 		urb->transfer_flags = URB_ISO_ASAP;
 
@@ -725,30 +724,29 @@ static void create_adc_command(unsigned int chan,
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(struct usbduxsigma_private *devpriv,
-			     int cmd_type)
+static int send_dux_commands(struct comedi_device *dev, int cmd_type)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbduxsigma_private *devpriv = dev->private;
 	int nsent;
 
 	devpriv->dux_commands[0] = cmd_type;
 
-	return usb_bulk_msg(devpriv->usbdev,
-			    usb_sndbulkpipe(devpriv->usbdev, COMMAND_OUT_EP),
+	return usb_bulk_msg(usb, usb_sndbulkpipe(usb, COMMAND_OUT_EP),
 			    devpriv->dux_commands, SIZEOFDUXBUFFER,
 			    &nsent, BULK_TIMEOUT);
 }
 
-static int receive_dux_commands(struct usbduxsigma_private *devpriv,
-				int command)
+static int receive_dux_commands(struct comedi_device *dev, int command)
 {
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbduxsigma_private *devpriv = dev->private;
 	int nrec;
 	int ret;
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		ret = usb_bulk_msg(devpriv->usbdev,
-				   usb_rcvbulkpipe(devpriv->usbdev,
-						   COMMAND_IN_EP),
+		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, COMMAND_IN_EP),
 				   devpriv->insnBuffer, SIZEINSNBUF,
 				   &nrec, BULK_TIMEOUT);
 		if (ret < 0)
@@ -851,7 +849,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	this_usbduxsub->dux_commands[6] = muxsg1;
 	this_usbduxsub->dux_commands[7] = sysred;
 
-	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
+	result = send_dux_commands(dev, SENDADCOMMANDS);
 	if (result < 0) {
 		up(&this_usbduxsub->sem);
 		return result;
@@ -958,14 +956,14 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	this_usbduxsub->dux_commands[6] = sysred;
 
 	/* adc commands */
-	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	err = send_dux_commands(dev, SENDSINGLEAD);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
 
 	for (i = 0; i < insn->n; i++) {
-		err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+		err = receive_dux_commands(dev, SENDSINGLEAD);
 		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return 0;
@@ -1034,11 +1032,11 @@ static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
 	this_usbduxsub->dux_commands[6] = sysred;
 
 	/* adc commands */
-	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	err = send_dux_commands(dev, SENDSINGLEAD);
 	if (err < 0)
 		return err;
 
-	err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	err = receive_dux_commands(dev, SENDSINGLEAD);
 	if (err < 0)
 		return err;
 
@@ -1109,7 +1107,7 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		this_usbduxsub->dux_commands[2] = data[i];
 		this_usbduxsub->outBuffer[chan] = data[i];
 		this_usbduxsub->dux_commands[3] = chan;
-		err = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);
+		err = send_dux_commands(dev, SENDDACOMMANDS);
 		if (err < 0) {
 			up(&this_usbduxsub->sem);
 			return err;
@@ -1389,12 +1387,12 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 
 	/* This command also tells the firmware to return */
 	/* the digital input lines */
-	err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	err = send_dux_commands(dev, SENDDIOBITSCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
 	}
-	err = receive_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	err = receive_dux_commands(dev, SENDDIOBITSCOMMAND);
 	if (err < 0) {
 		up(&this_usbduxsub->sem);
 		return err;
@@ -1428,7 +1426,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	/* unlink only if it is really running */
 	usbdux_pwm_stop(devpriv, devpriv->pwm_cmd_running);
 
-	return send_dux_commands(devpriv, SENDPWMOFF);
+	return send_dux_commands(dev, SENDPWMOFF);
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)
@@ -1466,7 +1464,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 		return;
 
 	urb->transfer_buffer_length = devpriv->sizePwmBuf;
-	urb->dev = devpriv->usbdev;
+	urb->dev = comedi_to_usb_dev(dev);
 	urb->status = 0;
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
 	if (ret < 0) {
@@ -1531,7 +1529,7 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	}
 
 	this_usbduxsub->dux_commands[1] = ((uint8_t) this_usbduxsub->pwmDelay);
-	ret = send_dux_commands(this_usbduxsub, SENDPWMON);
+	ret = send_dux_commands(dev, SENDPWMON);
 	if (ret < 0)
 		return ret;
 
@@ -1841,9 +1839,10 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	return 0;
 }
 
-static int usbduxsigma_alloc_usb_buffers(struct usbduxsigma_private *devpriv)
+static int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)
 {
-	struct usb_device *usb = devpriv->usbdev;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct urb *urb;
 	int i;
 
@@ -1941,7 +1940,6 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	dev->private = devpriv;
 
 	sema_init(&devpriv->sem, 1);
-	devpriv->usbdev = usb;
 	devpriv->interface = intf;
 	usb_set_intfdata(intf, devpriv);
 
@@ -1963,7 +1961,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 	}
 
-	ret = usbduxsigma_alloc_usb_buffers(devpriv);
+	ret = usbduxsigma_alloc_usb_buffers(dev);
 	if (ret) {
 		tidy_up(devpriv);
 		return ret;

commit f62024e5aed00c61518a10fe10cc0343fb01f5ba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:51:37 2013 -0700

    staging: comedi: usbduxsigma: remove 'comedidev' from the private data
    
    This back pointer to the comedi_device is not needed in the private
    data. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 106dbef36ae8..6a34b673cf92 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -191,8 +191,6 @@ struct usbduxsigma_private {
 	int16_t *outBuffer;
 	/* interface structure in 2.6 */
 	struct usb_interface *interface;
-	/* comedi device for the interrupt context */
-	struct comedi_device *comedidev;
 	/* is it USB_SPEED_HIGH or not? */
 	short int high_speed;
 	/* asynchronous command is running */
@@ -412,7 +410,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		if (devpriv->ao_cmd_running) {
 			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(devpriv->comedidev, s);
+			comedi_event(dev, s);
 		}
 		return;
 
@@ -424,7 +422,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 				__func__, urb->status);
 			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
 			s->async->events |= (COMEDI_CB_ERROR | COMEDI_CB_EOA);
-			comedi_event(devpriv->comedidev, s);
+			comedi_event(dev, s);
 		}
 		return;
 	}
@@ -444,7 +442,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 				usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
 				/* acquistion is over, tell comedi */
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(devpriv->comedidev, s);
+				comedi_event(dev, s);
 				return;
 			}
 		}
@@ -1745,8 +1743,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev)
 	int offset;
 
 	down(&uds->sem);
-	/* pointer back to the corresponding comedi device */
-	uds->comedidev = dev;
 
 	/* set number of subdevices */
 	if (uds->high_speed)
@@ -1993,7 +1989,6 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
 
 	down(&devpriv->sem);
-	devpriv->comedidev = NULL;
 	tidy_up(devpriv);
 	up(&devpriv->sem);
 }

commit 6028f4c01c2e5626f5279acca7ddbdc2125474a0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:51:14 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsub_submit_PwmURBs()
    
    Rename the CamelCase function.
    
    Pass the comedi_device pointer instead of the private data pointer
    to the function.
    
    Use a couple local variables to tidy up the function.
    
    Remove the dev_err() message when usb_submit_urb() fails, its just
    added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 3d8f17a7a257..106dbef36ae8 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1481,29 +1481,18 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_PwmURBs(struct usbduxsigma_private *usbduxsub)
+static int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)
 {
-	int errFlag;
-
-	if (!usbduxsub)
-		return -EFAULT;
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbduxsigma_private *devpriv = dev->private;
+	struct urb *urb = devpriv->urbPwm;
 
 	/* in case of a resubmission after an unlink... */
-	usb_fill_bulk_urb(usbduxsub->urbPwm,
-			  usbduxsub->usbdev,
-			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
-			  usbduxsub->urbPwm->transfer_buffer,
-			  usbduxsub->sizePwmBuf, usbduxsub_pwm_irq,
-			  usbduxsub->comedidev);
-
-	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
-	if (errFlag) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: usbduxsigma: pwm: usb_submit_urb error %d\n",
-			errFlag);
-		return errFlag;
-	}
-	return 0;
+	usb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, PWM_EP),
+			  urb->transfer_buffer, devpriv->sizePwmBuf,
+			  usbduxsub_pwm_irq, dev);
+
+	return usb_submit_urb(urb, GFP_ATOMIC);
 }
 
 static int usbdux_pwm_period(struct comedi_device *dev,
@@ -1552,12 +1541,11 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
 		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
 
-	this_usbduxsub->pwm_cmd_running = 1;
-	ret = usbduxsub_submit_PwmURBs(this_usbduxsub);
-	if (ret < 0) {
-		this_usbduxsub->pwm_cmd_running = 0;
+	ret = usbduxsigma_submit_pwm_urb(dev);
+	if (ret < 0)
 		return ret;
-	}
+	this_usbduxsub->pwm_cmd_running = 1;
+
 	return 0;
 }
 

commit 125a77fcf5836b25720b3076b988b3efa58982bf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:50:51 2013 -0700

    staging: comedi: usbduxsigma: tidy up receive_dux_commands()
    
    Rename the variable used for the private data pointer.
    
    Remove dev_err() when usb_blk_msg() fails, it's just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index cbe8e14a4c50..3d8f17a7a257 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -740,32 +740,29 @@ static int send_dux_commands(struct usbduxsigma_private *devpriv,
 			    &nsent, BULK_TIMEOUT);
 }
 
-static int receive_dux_commands(struct usbduxsigma_private *this_usbduxsub,
+static int receive_dux_commands(struct usbduxsigma_private *devpriv,
 				int command)
 {
-	int result = (-EFAULT);
 	int nrec;
+	int ret;
 	int i;
 
 	for (i = 0; i < RETRIES; i++) {
-		result = usb_bulk_msg(this_usbduxsub->usbdev,
-				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
-						      COMMAND_IN_EP),
-				      this_usbduxsub->insnBuffer, SIZEINSNBUF,
-				      &nrec, BULK_TIMEOUT);
-		if (result < 0) {
-			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-				"insn: USB error %d "
-				"while receiving DUX command"
-				"\n", this_usbduxsub->comedidev->minor,
-				result);
-			return result;
-		}
-		if (this_usbduxsub->insnBuffer[0] == command)
-			return result;
+		ret = usb_bulk_msg(devpriv->usbdev,
+				   usb_rcvbulkpipe(devpriv->usbdev,
+						   COMMAND_IN_EP),
+				   devpriv->insnBuffer, SIZEINSNBUF,
+				   &nrec, BULK_TIMEOUT);
+		if (ret < 0)
+			return ret;
+
+		if (devpriv->insnBuffer[0] == command)
+			return 0;
 	}
-	/* this is only reached if the data has been requested a couple of
-	 * times */
+	/*
+	 * This is only reached if the data has been requested a
+	 * couple of times and the command was not received.
+	 */
 	return -EFAULT;
 }
 

commit 502f9a3f76637cdc9a6397c81dfe601d69de530f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:50:31 2013 -0700

    staging: comedi: usbduxsigma: tidy up send_dux_commands()
    
    Rename the variable used for the private data pointer.
    
    Remove dev_err() when usb_blk_msg() fails, it's just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 937bcd3f86bf..cbe8e14a4c50 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -727,23 +727,17 @@ static void create_adc_command(unsigned int chan,
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(struct usbduxsigma_private *this_usbduxsub,
+static int send_dux_commands(struct usbduxsigma_private *devpriv,
 			     int cmd_type)
 {
-	int result, nsent;
-
-	this_usbduxsub->dux_commands[0] = cmd_type;
-	result = usb_bulk_msg(this_usbduxsub->usbdev,
-			      usb_sndbulkpipe(this_usbduxsub->usbdev,
-					      COMMAND_OUT_EP),
-			      this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
-			      &nsent, BULK_TIMEOUT);
-	if (result < 0)
-		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
-			"could not transmit dux_command to the usb-device, "
-			"err=%d\n", this_usbduxsub->comedidev->minor, result);
+	int nsent;
+
+	devpriv->dux_commands[0] = cmd_type;
 
-	return result;
+	return usb_bulk_msg(devpriv->usbdev,
+			    usb_sndbulkpipe(devpriv->usbdev, COMMAND_OUT_EP),
+			    devpriv->dux_commands, SIZEOFDUXBUFFER,
+			    &nsent, BULK_TIMEOUT);
 }
 
 static int receive_dux_commands(struct usbduxsigma_private *this_usbduxsub,

commit 160343e52c064431ce1672da5482b687c2c6385a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:50:08 2013 -0700

    staging: comedi: usbduxsigma: remove NOISY_DUX_DEBUGBUG
    
    This define enables a bunch of printk debug in send_dux_commands().
    This is just noise used for development debuging. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 24bbda5b6fcc..937bcd3f86bf 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -39,9 +39,6 @@ Status: testing
  *   0.6: corrected wrong input range
  */
 
-/* generates loads of debug info */
-/* #define NOISY_DUX_DEBUGBUG */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -736,13 +733,6 @@ static int send_dux_commands(struct usbduxsigma_private *this_usbduxsub,
 	int result, nsent;
 
 	this_usbduxsub->dux_commands[0] = cmd_type;
-#ifdef NOISY_DUX_DEBUGBUG
-	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
-	       this_usbduxsub->comedidev->minor);
-	for (result = 0; result < SIZEOFDUXBUFFER; result++)
-		printk(" %02x", this_usbduxsub->dux_commands[result]);
-	printk("\n");
-#endif
 	result = usb_bulk_msg(this_usbduxsub->usbdev,
 			      usb_sndbulkpipe(this_usbduxsub->usbdev,
 					      COMMAND_OUT_EP),

commit 1823fcbfad82f6b5ceae6ca002e0b6a78b2fe6a9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:49:50 2013 -0700

    staging: comedi: usbduxsigma: push usb (*probe) into comedi (*auto_attach)
    
    The usb_driver (*probe) already calls comedi_usb_auto_config(), which
    will call the comedi_driver (*auto_attach). Move the bulk of the (*probe)
    to the (*auto_attach).
    
    This allows the comedi_device private data to be kzalloc'ed and the static
    array used to pass the private data from the usb_driver to the comedi_driver
    can be removed along with the static semaphore that protected it.
    
    We can also drop a couple variables from the private data since they no
    longer are used or needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 56fc95df4b59..24bbda5b6fcc 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -145,9 +145,6 @@ Status: testing
 /* must have more buffers due to buggy USB ctr */
 #define NUMOFOUTBUFFERSHIGH    10
 
-/* Total number of usbdux devices */
-#define NUMUSBDUX             16
-
 /* Analogue in subdevice */
 #define SUBDEV_AD             0
 
@@ -172,10 +169,6 @@ static const struct comedi_lrange range_usbdux_ai_range = { 1, {
 };
 
 struct usbduxsigma_private {
-	/* attached? */
-	int attached;
-	/* is it associated with a subdevice? */
-	int probed;
 	/* pointer to the usb-device */
 	struct usb_device *usbdev;
 	/* actual number of in-buffers */
@@ -199,8 +192,6 @@ struct usbduxsigma_private {
 	int8_t *insnBuffer;
 	/* output buffer for single DA outputs */
 	int16_t *outBuffer;
-	/* interface number */
-	int ifnum;
 	/* interface structure in 2.6 */
 	struct usb_interface *interface;
 	/* comedi device for the interrupt context */
@@ -233,17 +224,6 @@ struct usbduxsigma_private {
 	struct semaphore sem;
 };
 
-/*
- * The pointer to the private usb-data of the driver is also the private data
- * for the comedi-device.  This has to be global as the usb subsystem needs
- * global variables. The other reason is that this structure must be there
- * _before_ any comedi command is issued. The usb subsystem must be initialised
- * before comedi can access it.
- */
-static struct usbduxsigma_private usbduxsub[NUMUSBDUX];
-
-static DEFINE_SEMAPHORE(start_stop_sem);
-
 static void usbdux_ai_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 {
 	if (do_unlink) {
@@ -1737,8 +1717,6 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 	if (usbduxsub_tmp->interface)
 		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
 
-	usbduxsub_tmp->probed = 0;
-
 	if (usbduxsub_tmp->urbIn) {
 		/* force unlink all urbs */
 		usbdux_ai_stop(usbduxsub_tmp, 1);
@@ -1789,9 +1767,9 @@ static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 	usbduxsub_tmp->dux_commands = NULL;
 }
 
-static int usbduxsigma_attach_common(struct comedi_device *dev,
-				     struct usbduxsigma_private *uds)
+static int usbduxsigma_attach_common(struct comedi_device *dev)
 {
+	struct usbduxsigma_private *uds = dev->private;
 	int ret;
 	struct comedi_subdevice *s;
 	int n_subdevs;
@@ -1811,8 +1789,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 		up(&uds->sem);
 		return ret;
 	}
-	/* private structure is also simply the usb-structure */
-	dev->private = uds;
 	/* the first subdevice is the A/D converter */
 	s = &dev->subdevices[SUBDEV_AD];
 	/* the URBs get the comedi subdevice */
@@ -1890,8 +1866,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 		s->insn_config = usbdux_pwm_config;
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
-	/* finally decide that it's attached */
-	uds->attached = 1;
 	up(&uds->sem);
 	offset = usbdux_getstatusinfo(dev, 0);
 	if (offset < 0)
@@ -1991,34 +1965,51 @@ static int usbduxsigma_alloc_usb_buffers(struct usbduxsigma_private *devpriv)
 static int usbduxsigma_auto_attach(struct comedi_device *dev,
 				   unsigned long context_unused)
 {
-	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
-	struct usbduxsigma_private *uds = usb_get_intfdata(uinterf);
-	struct usb_device *usb = uds->usbdev;
+	struct usb_interface *intf = comedi_to_usb_interface(dev);
+	struct usb_device *usb = comedi_to_usb_dev(dev);
+	struct usbduxsigma_private *devpriv;
 	int ret;
 
-	dev->private = uds;	/* This is temporary... */
-	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
-				   usbduxsigma_firmware_upload, 0);
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
+
+	sema_init(&devpriv->sem, 1);
+	devpriv->usbdev = usb;
+	devpriv->interface = intf;
+	usb_set_intfdata(intf, devpriv);
+
+	ret = usb_set_interface(usb,
+				intf->altsetting->desc.bInterfaceNumber, 3);
 	if (ret < 0) {
-		dev->private = NULL;
+		dev_err(dev->class_dev,
+			"could not set alternate setting 3 in high speed\n");
+		return -ENODEV;
+	}
+
+	/* test if it is high speed (USB 2.0) */
+	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
+	if (devpriv->high_speed) {
+		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
+		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+	} else {
+		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
+		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+	}
+
+	ret = usbduxsigma_alloc_usb_buffers(devpriv);
+	if (ret) {
+		tidy_up(devpriv);
 		return ret;
 	}
 
-	dev->private = NULL;
+	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+				   usbduxsigma_firmware_upload, 0);
+	if (ret)
+		return ret;
 
-	down(&start_stop_sem);
-	if (!uds) {
-		dev_err(dev->class_dev,
-			"usbduxsigma: error: auto_attach failed, not connected\n");
-		ret = -ENODEV;
-	} else if (uds->attached) {
-		dev_err(dev->class_dev,
-		       "usbduxsigma: error: auto_attach failed, already attached\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxsigma_attach_common(dev, uds);
-	up(&start_stop_sem);
-	return ret;
+	return usbduxsigma_attach_common(dev);
 }
 
 static void usbduxsigma_detach(struct comedi_device *dev)
@@ -2032,14 +2023,10 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
 	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
 
-	down(&start_stop_sem);
 	down(&devpriv->sem);
-	dev->private = NULL;
-	devpriv->attached = 0;
 	devpriv->comedidev = NULL;
 	tidy_up(devpriv);
 	up(&devpriv->sem);
-	up(&start_stop_sem);
 }
 
 static struct comedi_driver usbduxsigma_driver = {
@@ -2052,66 +2039,6 @@ static struct comedi_driver usbduxsigma_driver = {
 static int usbduxsigma_usb_probe(struct usb_interface *intf,
 				 const struct usb_device_id *id)
 {
-	struct usb_device *usb = interface_to_usbdev(intf);
-	struct device *dev = &intf->dev;
-	struct usbduxsigma_private *devpriv = NULL;
-	int ret;
-	int i;
-
-	down(&start_stop_sem);
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if (!usbduxsub[i].probed) {
-			devpriv = &usbduxsub[i];
-			break;
-		}
-	}
-
-	if (!devpriv) {
-		dev_err(dev, "Too many usbduxsigma-devices connected.\n");
-		up(&start_stop_sem);
-		return -EMFILE;
-	}
-
-	sema_init(&devpriv->sem, 1);
-	devpriv->usbdev = usb;
-	devpriv->interface = intf;
-	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
-	usb_set_intfdata(intf, devpriv);
-
-	ret = usb_set_interface(usb, devpriv->ifnum, 3);
-	if (ret < 0) {
-		dev_err(dev,
-			"could not set alternate setting 3 in high speed\n");
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENODEV;
-	}
-
-	/* test if it is high speed (USB 2.0) */
-	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
-	if (devpriv->high_speed) {
-		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
-		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
-	} else {
-		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
-		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
-	}
-
-	ret = usbduxsigma_alloc_usb_buffers(devpriv);
-	if (ret) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return ret;
-	}
-
-	devpriv->ai_cmd_running = 0;
-	devpriv->ao_cmd_running = 0;
-	devpriv->pwm_cmd_running = 0;
-
-	/* we've reached the bottom of the function */
-	devpriv->probed = 1;
-	up(&start_stop_sem);
-
 	return comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);;
 }
 

commit 9319d4ab4424f1e3671ecb6f296558112972daed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:49:26 2013 -0700

    staging: comedi: usbduxsigma: push usb (*disconnect) into comedi (*detach)
    
    The usb_driver (*disconnect) already calls comedi_usb_auto_unconfig(), which
    will call the comedi_driver (*detach). Move the other operations in the
    (*disconnect) into the (*detach). The comedi_usb_auto_unconfig() can then
    be used directly for the (*disconnect).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5cd9455bdf37..56fc95df4b59 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2023,15 +2023,23 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 
 static void usbduxsigma_detach(struct comedi_device *dev)
 {
-	struct usbduxsigma_private *usb = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 
-	if (usb) {
-		down(&usb->sem);
-		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
-		up(&usb->sem);
-	}
+	if (!devpriv)
+		return;
+
+	/* stop any running commands */
+	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
+	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
+
+	down(&start_stop_sem);
+	down(&devpriv->sem);
+	dev->private = NULL;
+	devpriv->attached = 0;
+	devpriv->comedidev = NULL;
+	tidy_up(devpriv);
+	up(&devpriv->sem);
+	up(&start_stop_sem);
 }
 
 static struct comedi_driver usbduxsigma_driver = {
@@ -2107,34 +2115,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *intf,
 	return comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);;
 }
 
-static void usbduxsigma_usb_disconnect(struct usb_interface *intf)
-{
-	struct usbduxsigma_private *usbduxsub_tmp = usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-	if (!usbduxsub_tmp) {
-		dev_err(&intf->dev,
-			"comedi_: disconnect called with null pointer.\n");
-		return;
-	}
-	if (usbduxsub_tmp->usbdev != udev) {
-		dev_err(&intf->dev, "comedi_: BUG! wrong ptr!\n");
-		return;
-	}
-	if (usbduxsub_tmp->ai_cmd_running)
-		/* we are still running a command */
-		usbdux_ai_stop(usbduxsub_tmp, 1);
-	if (usbduxsub_tmp->ao_cmd_running)
-		/* we are still running a command */
-		usbdux_ao_stop(usbduxsub_tmp, 1);
-	comedi_usb_auto_unconfig(intf);
-	down(&start_stop_sem);
-	down(&usbduxsub_tmp->sem);
-	tidy_up(usbduxsub_tmp);
-	up(&usbduxsub_tmp->sem);
-	up(&start_stop_sem);
-}
-
 static const struct usb_device_id usbduxsigma_usb_table[] = {
 	{ USB_DEVICE(0x13d8, 0x0020) },
 	{ USB_DEVICE(0x13d8, 0x0021) },
@@ -2146,7 +2126,7 @@ MODULE_DEVICE_TABLE(usb, usbduxsigma_usb_table);
 static struct usb_driver usbduxsigma_usb_driver = {
 	.name		= "usbduxsigma",
 	.probe		= usbduxsigma_usb_probe,
-	.disconnect	= usbduxsigma_usb_disconnect,
+	.disconnect	= comedi_usb_auto_unconfig,
 	.id_table	= usbduxsigma_usb_table,
 };
 module_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);

commit 65989c030bbca96be45ed137f6384dbd46030d10
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:49:02 2013 -0700

    staging: comedi: usbduxsigma: factor usb buffer allocation out of (*probe)
    
    To make pushing the usb_driver (*probe) into the comedi_driver (*auto_attach)
    cleaner, factor the usb buffer allocation out of the (*probe). This also
    cleans up the failure paths in the (*probe).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d719a2c25f54..5cd9455bdf37 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1902,6 +1902,92 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
+static int usbduxsigma_alloc_usb_buffers(struct usbduxsigma_private *devpriv)
+{
+	struct usb_device *usb = devpriv->usbdev;
+	struct urb *urb;
+	int i;
+
+	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	devpriv->inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	devpriv->insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	devpriv->outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	devpriv->urbIn = kcalloc(devpriv->numOfInBuffers, sizeof(*urb),
+				 GFP_KERNEL);
+	devpriv->urbOut = kcalloc(devpriv->numOfOutBuffers, sizeof(*urb),
+				  GFP_KERNEL);
+	if (!devpriv->dac_commands || !devpriv->dux_commands ||
+	    !devpriv->inBuffer || !devpriv->insnBuffer ||
+	    !devpriv->outBuffer || !devpriv->urbIn || !devpriv->urbOut)
+		return -ENOMEM;
+
+	for (i = 0; i < devpriv->numOfInBuffers; i++) {
+		/* one frame: 1ms */
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urbIn[i] = urb;
+		urb->dev = usb;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		urb->context = NULL;
+		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+		urb->complete = usbduxsub_ai_IsocIrq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEINBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEINBUF;
+	}
+
+	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
+		/* one frame: 1ms */
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urbOut[i] = urb;
+		urb->dev = usb;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		urb->context = NULL;
+		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+		urb->complete = usbduxsub_ao_IsocIrq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
+	}
+
+	if (devpriv->high_speed) {
+		/* max bulk ep size in high speed */
+		devpriv->sizePwmBuf = 512;
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+		devpriv->urbPwm = urb;
+		urb->transfer_buffer = kzalloc(devpriv->sizePwmBuf, GFP_KERNEL);
+		if (!urb->transfer_buffer)
+			return -ENOMEM;
+	} else {
+		devpriv->urbPwm = NULL;
+		devpriv->sizePwmBuf = 0;
+	}
+
+	return 0;
+}
+
 static int usbduxsigma_auto_attach(struct comedi_device *dev,
 				   unsigned long context_unused)
 {
@@ -1961,7 +2047,7 @@ static int usbduxsigma_usb_probe(struct usb_interface *intf,
 	struct usb_device *usb = interface_to_usbdev(intf);
 	struct device *dev = &intf->dev;
 	struct usbduxsigma_private *devpriv = NULL;
-	struct urb *urb;
+	int ret;
 	int i;
 
 	down(&start_stop_sem);
@@ -1984,158 +2070,30 @@ static int usbduxsigma_usb_probe(struct usb_interface *intf,
 	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
 	usb_set_intfdata(intf, devpriv);
 
-	/* test if it is high speed (USB 2.0) */
-	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
-
-	/* create space for the commands of the DA converter */
-	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
-	if (!devpriv->dac_commands) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the commands going to the usb device */
-	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!devpriv->dux_commands) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the in buffer and set it to zero */
-	devpriv->inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->inBuffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space of the instruction buffer */
-	devpriv->insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!devpriv->insnBuffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* create space for the outbuffer */
-	devpriv->outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!devpriv->outBuffer) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	i = usb_set_interface(usb, devpriv->ifnum, 3);
-	if (i < 0) {
+	ret = usb_set_interface(usb, devpriv->ifnum, 3);
+	if (ret < 0) {
 		dev_err(dev,
 			"could not set alternate setting 3 in high speed\n");
 		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
-	if (devpriv->high_speed)
-		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
-	else
-		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
-
-	devpriv->urbIn = kcalloc(devpriv->numOfInBuffers, sizeof(*urb),
-				 GFP_KERNEL);
-	if (!devpriv->urbIn) {
-		tidy_up(devpriv);
-		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	for (i = 0; i < devpriv->numOfInBuffers; i++) {
-		/* one frame: 1ms */
-		urb = usb_alloc_urb(1, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urbIn[i] = urb;
-		urb->dev = usb;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
-		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		urb->complete = usbduxsub_ai_IsocIrq;
-		urb->number_of_packets = 1;
-		urb->transfer_buffer_length = SIZEINBUF;
-		urb->iso_frame_desc[0].offset = 0;
-		urb->iso_frame_desc[0].length = SIZEINBUF;
-	}
 
-	/* out */
-	if (devpriv->high_speed)
+	/* test if it is high speed (USB 2.0) */
+	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
+	if (devpriv->high_speed) {
+		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
 		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
-	else
+	} else {
+		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
 		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+	}
 
-	devpriv->urbOut = kcalloc(devpriv->numOfOutBuffers, sizeof(*urb),
-				  GFP_KERNEL);
-	if (!devpriv->urbOut) {
+	ret = usbduxsigma_alloc_usb_buffers(devpriv);
+	if (ret) {
 		tidy_up(devpriv);
 		up(&start_stop_sem);
-		return -ENOMEM;
-	}
-	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
-		/* one frame: 1ms */
-		urb = usb_alloc_urb(1, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urbOut[i] = urb;
-		urb->dev = usb;
-		/* will be filled later with a pointer to the comedi-device */
-		/* and ONLY then the urb should be submitted */
-		urb->context = NULL;
-		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
-		urb->transfer_flags = URB_ISO_ASAP;
-		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		urb->complete = usbduxsub_ao_IsocIrq;
-		urb->number_of_packets = 1;
-		urb->transfer_buffer_length = SIZEOUTBUF;
-		urb->iso_frame_desc[0].offset = 0;
-		urb->iso_frame_desc[0].length = SIZEOUTBUF;
-		if (devpriv->high_speed)
-			urb->interval = 8;	/* uframes */
-		else
-			urb->interval = 1;	/* frames */
-	}
-
-	/* pwm */
-	if (devpriv->high_speed) {
-		/* max bulk ep size in high speed */
-		devpriv->sizePwmBuf = 512;
-		urb = usb_alloc_urb(0, GFP_KERNEL);
-		if (!urb) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-		devpriv->urbPwm = urb;
-		urb->transfer_buffer = kzalloc(devpriv->sizePwmBuf, GFP_KERNEL);
-		if (!urb->transfer_buffer) {
-			tidy_up(devpriv);
-			up(&start_stop_sem);
-			return -ENOMEM;
-		}
-	} else {
-		devpriv->urbPwm = NULL;
-		devpriv->sizePwmBuf = 0;
+		return ret;
 	}
 
 	devpriv->ai_cmd_running = 0;

commit 902add47dec8379e36e03d41d7f9877855514ccd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:48:41 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsigma_usb_probe()
    
    For aesthetic reasons, rename some of the variables to the "norm" used
    in comedi drivers.
    
    Use a local variable for the pointer to the private data instead of
    accessing the static array directly. Also use a local variable to
    setup the urbs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a5a2ac33f63b..d719a2c25f54 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1955,224 +1955,198 @@ static struct comedi_driver usbduxsigma_driver = {
 	.detach		= usbduxsigma_detach,
 };
 
-static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
+static int usbduxsigma_usb_probe(struct usb_interface *intf,
 				 const struct usb_device_id *id)
 {
-	struct usb_device *udev = interface_to_usbdev(uinterf);
-	struct device *dev = &uinterf->dev;
+	struct usb_device *usb = interface_to_usbdev(intf);
+	struct device *dev = &intf->dev;
+	struct usbduxsigma_private *devpriv = NULL;
+	struct urb *urb;
 	int i;
-	int index;
 
 	down(&start_stop_sem);
-	/* look for a free place in the usbdux array */
-	index = -1;
 	for (i = 0; i < NUMUSBDUX; i++) {
-		if (!(usbduxsub[i].probed)) {
-			index = i;
+		if (!usbduxsub[i].probed) {
+			devpriv = &usbduxsub[i];
 			break;
 		}
 	}
 
-	/* no more space */
-	if (index == -1) {
+	if (!devpriv) {
 		dev_err(dev, "Too many usbduxsigma-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
 
-	sema_init(&(usbduxsub[index].sem), 1);
-	/* save a pointer to the usb device */
-	usbduxsub[index].usbdev = udev;
-
-	/* save the interface itself */
-	usbduxsub[index].interface = uinterf;
-	/* get the interface number from the interface */
-	usbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	/* hand the private data over to the usb subsystem */
-	/* will be needed for disconnect */
-	usb_set_intfdata(uinterf, &(usbduxsub[index]));
+	sema_init(&devpriv->sem, 1);
+	devpriv->usbdev = usb;
+	devpriv->interface = intf;
+	devpriv->ifnum = intf->altsetting->desc.bInterfaceNumber;
+	usb_set_intfdata(intf, devpriv);
 
 	/* test if it is high speed (USB 2.0) */
-	usbduxsub[index].high_speed =
-	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+	devpriv->high_speed = (usb->speed == USB_SPEED_HIGH);
 
 	/* create space for the commands of the DA converter */
-	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
-	if (!usbduxsub[index].dac_commands) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	if (!devpriv->dac_commands) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the commands going to the usb device */
-	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
-	if (!usbduxsub[index].dux_commands) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!devpriv->dux_commands) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the in buffer and set it to zero */
-	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].inBuffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!devpriv->inBuffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space of the instruction buffer */
-	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].insnBuffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insnBuffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* create space for the outbuffer */
-	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
-	if (!(usbduxsub[index].outBuffer)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!devpriv->outBuffer) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
-	i = usb_set_interface(usbduxsub[index].usbdev,
-			      usbduxsub[index].ifnum, 3);
+	i = usb_set_interface(usb, devpriv->ifnum, 3);
 	if (i < 0) {
-		dev_err(dev, "comedi_: usbduxsigma%d: "
-			"could not set alternate setting 3 in high speed.\n",
-			index);
-		tidy_up(&(usbduxsub[index]));
+		dev_err(dev,
+			"could not set alternate setting 3 in high speed\n");
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
-	if (usbduxsub[index].high_speed)
-		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
+	if (devpriv->high_speed)
+		devpriv->numOfInBuffers = NUMOFINBUFFERSHIGH;
 	else
-		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
+		devpriv->numOfInBuffers = NUMOFINBUFFERSFULL;
 
-	usbduxsub[index].urbIn = kcalloc(usbduxsub[index].numOfInBuffers,
-					 sizeof(struct urb *),
-					 GFP_KERNEL);
-	if (!(usbduxsub[index].urbIn)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->urbIn = kcalloc(devpriv->numOfInBuffers, sizeof(*urb),
+				 GFP_KERNEL);
+	if (!devpriv->urbIn) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
+	for (i = 0; i < devpriv->numOfInBuffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbIn[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urbIn[i] == NULL) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"Could not alloc. urb(%d)\n", index, i);
-			tidy_up(&(usbduxsub[index]));
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
+		devpriv->urbIn[i] = urb;
+		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urbIn[i]->context = NULL;
-		usbduxsub[index].urbIn[i]->pipe =
-		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
-		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urbIn[i]->transfer_buffer =
-		    kzalloc(SIZEINBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		urb->context = NULL;
+		urb->pipe = usb_rcvisocpipe(usb, ISOINEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;
-		usbduxsub[index].urbIn[i]->number_of_packets = 1;
-		usbduxsub[index].urbIn[i]->transfer_buffer_length = SIZEINBUF;
-		usbduxsub[index].urbIn[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urbIn[i]->iso_frame_desc[0].length =
-			SIZEINBUF;
+		urb->complete = usbduxsub_ai_IsocIrq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEINBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEINBUF;
 	}
 
 	/* out */
-	if (usbduxsub[index].high_speed)
-		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+	if (devpriv->high_speed)
+		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
 	else
-		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+		devpriv->numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 
-	usbduxsub[index].urbOut = kcalloc(usbduxsub[index].numOfOutBuffers,
-					  sizeof(struct urb *), GFP_KERNEL);
-	if (!(usbduxsub[index].urbOut)) {
-		tidy_up(&(usbduxsub[index]));
+	devpriv->urbOut = kcalloc(devpriv->numOfOutBuffers, sizeof(*urb),
+				  GFP_KERNEL);
+	if (!devpriv->urbOut) {
+		tidy_up(devpriv);
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
+	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
 		/* one frame: 1ms */
-		usbduxsub[index].urbOut[i] = usb_alloc_urb(1, GFP_KERNEL);
-		if (usbduxsub[index].urbOut[i] == NULL) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"Could not alloc. urb(%d)\n", index, i);
-			tidy_up(&(usbduxsub[index]));
+		urb = usb_alloc_urb(1, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
+		devpriv->urbOut[i] = urb;
+		urb->dev = usb;
 		/* will be filled later with a pointer to the comedi-device */
 		/* and ONLY then the urb should be submitted */
-		usbduxsub[index].urbOut[i]->context = NULL;
-		usbduxsub[index].urbOut[i]->pipe =
-		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
-		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
-		usbduxsub[index].urbOut[i]->transfer_buffer =
-		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
-		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		urb->context = NULL;
+		urb->pipe = usb_sndisocpipe(usb, ISOOUTEP);
+		urb->transfer_flags = URB_ISO_ASAP;
+		urb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;
-		usbduxsub[index].urbOut[i]->number_of_packets = 1;
-		usbduxsub[index].urbOut[i]->transfer_buffer_length =
-			SIZEOUTBUF;
-		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
-		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
-		    SIZEOUTBUF;
-		if (usbduxsub[index].high_speed) {
-			/* uframes */
-			usbduxsub[index].urbOut[i]->interval = 8;
-		} else {
-			/* frames */
-			usbduxsub[index].urbOut[i]->interval = 1;
-		}
+		urb->complete = usbduxsub_ao_IsocIrq;
+		urb->number_of_packets = 1;
+		urb->transfer_buffer_length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		if (devpriv->high_speed)
+			urb->interval = 8;	/* uframes */
+		else
+			urb->interval = 1;	/* frames */
 	}
 
 	/* pwm */
-	if (usbduxsub[index].high_speed) {
+	if (devpriv->high_speed) {
 		/* max bulk ep size in high speed */
-		usbduxsub[index].sizePwmBuf = 512;
-		usbduxsub[index].urbPwm = usb_alloc_urb(0, GFP_KERNEL);
-		if (usbduxsub[index].urbPwm == NULL) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"Could not alloc. pwm urb\n", index);
-			tidy_up(&(usbduxsub[index]));
+		devpriv->sizePwmBuf = 512;
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
-		usbduxsub[index].urbPwm->transfer_buffer =
-		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
-		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
-			tidy_up(&(usbduxsub[index]));
+		devpriv->urbPwm = urb;
+		urb->transfer_buffer = kzalloc(devpriv->sizePwmBuf, GFP_KERNEL);
+		if (!urb->transfer_buffer) {
+			tidy_up(devpriv);
 			up(&start_stop_sem);
 			return -ENOMEM;
 		}
 	} else {
-		usbduxsub[index].urbPwm = NULL;
-		usbduxsub[index].sizePwmBuf = 0;
+		devpriv->urbPwm = NULL;
+		devpriv->sizePwmBuf = 0;
 	}
 
-	usbduxsub[index].ai_cmd_running = 0;
-	usbduxsub[index].ao_cmd_running = 0;
-	usbduxsub[index].pwm_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
+	devpriv->ao_cmd_running = 0;
+	devpriv->pwm_cmd_running = 0;
 
 	/* we've reached the bottom of the function */
-	usbduxsub[index].probed = 1;
+	devpriv->probed = 1;
 	up(&start_stop_sem);
 
-	return comedi_usb_auto_config(uinterf, &usbduxsigma_driver, 0);;
+	return comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);;
 }
 
 static void usbduxsigma_usb_disconnect(struct usb_interface *intf)

commit eead8c6633669b01f1a5c7b45f64102f2b615864
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:48:12 2013 -0700

    staging: comedi: usbduxsigma: rename the private data struct
    
    For aesthetic reasons, rename the struct used for the comedi_device
    private data from usbduxsub to usbduxsigma_private.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f3dce88691d8..a5a2ac33f63b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -171,15 +171,7 @@ static const struct comedi_lrange range_usbdux_ai_range = { 1, {
 								}
 };
 
-/*
- * private structure of one subdevice
- */
-
-/*
- * This is the structure which holds all the data of
- * this driver one sub device just now: A/D
- */
-struct usbduxsub {
+struct usbduxsigma_private {
 	/* attached? */
 	int attached;
 	/* is it associated with a subdevice? */
@@ -248,11 +240,11 @@ struct usbduxsub {
  * _before_ any comedi command is issued. The usb subsystem must be initialised
  * before comedi can access it.
  */
-static struct usbduxsub usbduxsub[NUMUSBDUX];
+static struct usbduxsigma_private usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_ai_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 {
 	if (do_unlink) {
 		int i;
@@ -269,7 +261,7 @@ static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
 static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
@@ -282,7 +274,7 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 static void usbduxsub_ai_IsocIrq(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int dio_state;
 	int32_t val;
@@ -393,7 +385,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(dev, s);
 }
 
-static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_ao_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 {
 	if (do_unlink) {
 		int i;
@@ -410,7 +402,7 @@ static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
 static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 
 	down(&devpriv->sem);
 	/* unlink only if it is really running */
@@ -423,7 +415,7 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 static void usbduxsub_ao_IsocIrq(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	uint8_t *datap;
 	int len;
@@ -536,7 +528,7 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 				       const u8 *data, size_t size,
 				       unsigned long context)
 {
-	struct usbduxsub *usbduxsub = dev->private;
+	struct usbduxsigma_private *usbduxsub = dev->private;
 	struct usb_device *usb = usbduxsub->usbdev;
 	uint8_t *buf;
 	uint8_t *tmp;
@@ -615,7 +607,7 @@ static int usbduxsigma_submit_urbs(struct comedi_device *dev,
 				   struct urb **urbs, int num_urbs,
 				   int input_urb)
 {
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	struct urb *urb;
 	int ret;
 	int i;
@@ -655,7 +647,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int err = 0, i;
 	unsigned int tmpTimer;
 
@@ -758,7 +750,8 @@ static void create_adc_command(unsigned int chan,
 #define SENDPWMON                 7
 #define SENDPWMOFF                8
 
-static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
+static int send_dux_commands(struct usbduxsigma_private *this_usbduxsub,
+			     int cmd_type)
 {
 	int result, nsent;
 
@@ -783,7 +776,8 @@ static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
 	return result;
 }
 
-static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
+static int receive_dux_commands(struct usbduxsigma_private *this_usbduxsub,
+				int command)
 {
 	int result = (-EFAULT);
 	int nrec;
@@ -814,8 +808,8 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 static int usbdux_ai_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int trignum)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
 	if (!this_usbduxsub)
 		return -EFAULT;
 
@@ -848,10 +842,10 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 
 static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan;
 	int i, ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
 	int result;
 	uint8_t muxsg0 = 0;
 	uint8_t muxsg1 = 0;
@@ -966,11 +960,11 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int i;
 	int32_t one = 0;
 	int chan;
 	int err;
-	struct usbduxsub *this_usbduxsub = dev->private;
 	uint8_t muxsg0 = 0;
 	uint8_t muxsg1 = 0;
 	uint8_t sysred = 0;
@@ -1035,7 +1029,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 
 static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	uint8_t sysred = 0;
 	uint32_t one;
 	int err;
@@ -1110,9 +1104,9 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
-	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1129,9 +1123,9 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int i, err;
 	int chan = CR_CHAN(insn->chanspec);
-	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1170,8 +1164,8 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 static int usbdux_ao_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int trignum)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1207,7 +1201,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int err = 0;
 	unsigned int flags;
 
@@ -1279,10 +1273,10 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 
 static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain;
 	int i, ret;
-	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1414,8 +1408,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int err;
 
 	if (!this_usbduxsub)
@@ -1458,7 +1451,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_pwm_stop(struct usbduxsigma_private *devpriv, int do_unlink)
 {
 	if (do_unlink) {
 		if (devpriv->urbPwm)
@@ -1471,7 +1464,7 @@ static void usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
 static int usbdux_pwm_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 
 	/* unlink only if it is really running */
 	usbdux_pwm_stop(devpriv, devpriv->pwm_cmd_running);
@@ -1482,7 +1475,7 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
 	struct comedi_device *dev = urb->context;
-	struct usbduxsub *devpriv = dev->private;
+	struct usbduxsigma_private *devpriv = dev->private;
 	int ret;
 
 	switch (urb->status) {
@@ -1527,7 +1520,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
+static int usbduxsub_submit_PwmURBs(struct usbduxsigma_private *usbduxsub)
 {
 	int errFlag;
 
@@ -1555,7 +1548,7 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 static int usbdux_pwm_period(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int period)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int fx2delay = 255;
 
 	if (period < MIN_PWM_PERIOD) {
@@ -1581,8 +1574,8 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 static int usbdux_pwm_start(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int ret, i;
-	struct usbduxsub *this_usbduxsub = dev->private;
 
 	if (this_usbduxsub->pwm_cmd_running) {
 		/* already running */
@@ -1612,7 +1605,7 @@ static int usbdux_pwm_pattern(struct comedi_device *dev,
 			      struct comedi_subdevice *s, int channel,
 			      unsigned int value, unsigned int sign)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	int i, szbuf;
 	char *pBuf;
 	char pwm_mask;
@@ -1654,7 +1647,7 @@ static int usbdux_pwm_write(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1688,7 +1681,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsigma_private *this_usbduxsub = dev->private;
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 		/* switch it on */
@@ -1733,7 +1726,7 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 /* end of PWM */
 /*****************************************************************/
 
-static void tidy_up(struct usbduxsub *usbduxsub_tmp)
+static void tidy_up(struct usbduxsigma_private *usbduxsub_tmp)
 {
 	int i;
 
@@ -1797,7 +1790,7 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 }
 
 static int usbduxsigma_attach_common(struct comedi_device *dev,
-				     struct usbduxsub *uds)
+				     struct usbduxsigma_private *uds)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -1913,7 +1906,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 				   unsigned long context_unused)
 {
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
-	struct usbduxsub *uds = usb_get_intfdata(uinterf);
+	struct usbduxsigma_private *uds = usb_get_intfdata(uinterf);
 	struct usb_device *usb = uds->usbdev;
 	int ret;
 
@@ -1944,7 +1937,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 
 static void usbduxsigma_detach(struct comedi_device *dev)
 {
-	struct usbduxsub *usb = dev->private;
+	struct usbduxsigma_private *usb = dev->private;
 
 	if (usb) {
 		down(&usb->sem);
@@ -2184,7 +2177,7 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 
 static void usbduxsigma_usb_disconnect(struct usb_interface *intf)
 {
-	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
+	struct usbduxsigma_private *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
 
 	if (!usbduxsub_tmp) {

commit 7fb13b543687a19de4d44a205bc1e39c9d71a2f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:47:48 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsub_pwm_irq()
    
    Rename the local variables to follow the "norm" for comedi drivers.
    The comedi_subdevice is not used in this function. Remove that local
    variable.
    
    Use dev->class_dev for any dev_{level} messages.
    
    Remove the extra check of 'pwm_cmd_running' before submitting the urb.
    This flag was previously checked.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d705b07e2d5c..f3dce88691d8 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1481,19 +1481,9 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 
 static void usbduxsub_pwm_irq(struct urb *urb)
 {
+	struct comedi_device *dev = urb->context;
+	struct usbduxsub *devpriv = dev->private;
 	int ret;
-	struct usbduxsub *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-
-	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
-
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
-	this_usbduxsub = this_comedidev->private;
-
-	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -1504,47 +1494,36 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		/*
-		 * after an unlink command, unplug, ... etc
-		 * no unlink needed here. Already shutting down.
-		 */
-		if (this_usbduxsub->pwm_cmd_running)
-			usbdux_pwm_stop(this_usbduxsub, 0);
-
+		/* happens after an unlink command */
+		if (devpriv->pwm_cmd_running)
+			usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
 		return;
 
 	default:
 		/* a real error */
-		if (this_usbduxsub->pwm_cmd_running) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi_: Non-zero urb status received in "
-				"pwm intr context: %d\n", urb->status);
-			usbdux_pwm_stop(this_usbduxsub, 0);
+		if (devpriv->pwm_cmd_running) {
+			dev_err(dev->class_dev,
+				"%s: non-zero urb status (%d)\n",
+				__func__, urb->status);
+			usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
 		}
 		return;
 	}
 
-	/* are we actually running? */
-	if (!(this_usbduxsub->pwm_cmd_running))
+	if (!devpriv->pwm_cmd_running)
 		return;
 
-	urb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;
-	urb->dev = this_usbduxsub->usbdev;
+	urb->transfer_buffer_length = devpriv->sizePwmBuf;
+	urb->dev = devpriv->usbdev;
 	urb->status = 0;
-	if (this_usbduxsub->pwm_cmd_running) {
-		ret = usb_submit_urb(urb, GFP_ATOMIC);
-		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi_: pwm urb resubm failed in int-cont. "
-				"ret=%d", ret);
-			if (ret == EL2NSYNC)
-				dev_err(&this_usbduxsub->interface->dev,
-					"buggy USB host controller or bug in "
-					"IRQ handling!\n");
-
-			/* don't do an unlink here */
-			usbdux_pwm_stop(this_usbduxsub, 0);
-		}
+	ret = usb_submit_urb(urb, GFP_ATOMIC);
+	if (ret < 0) {
+		dev_err(dev->class_dev, "%s: urb resubmit failed (%d)\n",
+			__func__, ret);
+		if (ret == EL2NSYNC)
+			dev_err(dev->class_dev,
+				"buggy USB host controller or bug in IRQ handler\n");
+		usbdux_pwm_stop(devpriv, 0);	/* w/o unlink */
 	}
 }
 

commit 990a049d8b527a3cdb90905306919fc1f38e6fd7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:47:19 2013 -0700

    staging: comedi: usbduxsigma: remove 'probed' checks in comedi functions
    
    The 'probed' flag in the private data is used by the usb_driver (*probe)
    function to find a free entry in the static usbduxsub array to use for
    the comedi_device private data. The (*probe) sets this flag before it
    hands off the probe to the comedi_driver (*auto_attach). The 'probed'
    flag is cleared in tidy_up() are part of the usb_driver (*disconnect),
    which calls the comedi_driver (*detach).
    
    The 'probed' flag will always be set if the comedi_driver (*auto_attach)
    completes successfully. The extra sanity checks in the comedi functions
    are not needed. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2046444ad31a..d705b07e2d5c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -659,9 +659,6 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	int err = 0, i;
 	unsigned int tmpTimer;
 
-	if (!(this_usbduxsub->probed))
-		return -ENODEV;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -823,10 +820,6 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
@@ -869,11 +862,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
-
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
 			"ai_cmd not possible. Another ai_cmd is running.\n",
@@ -991,10 +979,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 		return 0;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ai_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: ai_insn_read not possible. "
@@ -1134,10 +1118,6 @@ static int usbdux_ao_insn_read(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	for (i = 0; i < insn->n; i++)
 		data[i] = this_usbduxsub->outBuffer[chan];
 
@@ -1157,10 +1137,6 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	if (this_usbduxsub->ao_cmd_running) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: ao_insn_write: "
@@ -1201,11 +1177,6 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-
-	if (!(this_usbduxsub->probed)) {
-		ret = -ENODEV;
-		goto out;
-	}
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
@@ -1243,9 +1214,6 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	if (!(this_usbduxsub->probed))
-		return -ENODEV;
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1320,11 +1288,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
-
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
@@ -1460,11 +1423,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 
 	down(&this_usbduxsub->sem);
 
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
-
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 	s->state &= ~data[0];
@@ -1991,7 +1949,7 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	if (!uds || !uds->probed) {
+	if (!uds) {
 		dev_err(dev->class_dev,
 			"usbduxsigma: error: auto_attach failed, not connected\n");
 		ret = -ENODEV;

commit de0a1e971f86e529bd0e1d6f3ac33bbc9830272f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:46:40 2013 -0700

    staging: comedi: usbduxsigma: generalize the usb_submit_urb functions
    
    Generalize a helper function to replace usbduxsub_submit_{In,Out}URBs().
    
    In the callers, set the 'a[io]_cmd_running' flag after the urbs have been
    successfully submitted. This removes the need to clear the flag if the
    submit fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ec485de95767..2046444ad31a 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -611,38 +611,30 @@ static int usbduxsigma_firmware_upload(struct comedi_device *dev,
 	return ret;
 }
 
-static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
+static int usbduxsigma_submit_urbs(struct comedi_device *dev,
+				   struct urb **urbs, int num_urbs,
+				   int input_urb)
 {
-	int i, errFlag;
+	struct usbduxsub *devpriv = dev->private;
+	struct urb *urb;
+	int ret;
+	int i;
 
 	/* Submit all URBs and start the transfer on the bus */
-	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
-		/* in case of a resubmission after an unlink... */
-		usbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;
-		usbduxsub->urbIn[i]->context = usbduxsub->comedidev;
-		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urbIn[i]->status = 0;
-		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
-		errFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);
-		if (errFlag)
-			return errFlag;
-	}
-	return 0;
-}
-
-static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
-{
-	int i, errFlag;
+	for (i = 0; i < num_urbs; i++) {
+		urb = urbs[i];
 
-	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
 		/* in case of a resubmission after an unlink... */
-		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
-		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
-		usbduxsub->urbOut[i]->status = 0;
-		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
-		errFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);
-		if (errFlag)
-			return errFlag;
+		if (input_urb)
+			urb->interval = devpriv->ai_interval;
+		urb->context = dev;
+		urb->dev = devpriv->usbdev;
+		urb->status = 0;
+		urb->transfer_flags = URB_ISO_ASAP;
+
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret)
+			return ret;
 	}
 	return 0;
 }
@@ -842,17 +834,15 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		up(&this_usbduxsub->sem);
 		return -EINVAL;
 	}
-	if (!(this_usbduxsub->ai_cmd_running)) {
-		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+	if (!this_usbduxsub->ai_cmd_running) {
+		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbIn,
+					      this_usbduxsub->numOfInBuffers,
+					      1);
 		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux_ai_inttrig: "
-				"urbSubmit: err=%d\n", dev->minor, ret);
-			this_usbduxsub->ai_cmd_running = 0;
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
+		this_usbduxsub->ai_cmd_running = 1;
 		s->async->inttrig = NULL;
 	} else {
 		dev_err(&this_usbduxsub->interface->dev,
@@ -964,14 +954,14 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		this_usbduxsub->ai_cmd_running = 1;
-		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbIn,
+					      this_usbduxsub->numOfInBuffers,
+					      1);
 		if (ret < 0) {
-			this_usbduxsub->ai_cmd_running = 0;
-			/* fixme: unlink here?? */
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
+		this_usbduxsub->ai_cmd_running = 1;
 		s->async->inttrig = NULL;
 	} else {
 		/* TRIG_INT */
@@ -1224,15 +1214,12 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		goto out;
 	}
 	if (!(this_usbduxsub->ao_cmd_running)) {
-		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
-		if (ret < 0) {
-			dev_err(&this_usbduxsub->interface->dev,
-				"comedi%d: usbdux_ao_inttrig: submitURB: "
-				"err=%d\n", dev->minor, ret);
-			this_usbduxsub->ao_cmd_running = 0;
+		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbOut,
+					      this_usbduxsub->numOfOutBuffers,
+					      0);
+		if (ret < 0)
 			goto out;
-		}
+		this_usbduxsub->ao_cmd_running = 1;
 		s->async->inttrig = NULL;
 	} else {
 		dev_err(&this_usbduxsub->interface->dev,
@@ -1408,14 +1395,14 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->start_src == TRIG_NOW) {
 		/* enable this acquisition operation */
-		this_usbduxsub->ao_cmd_running = 1;
-		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		ret = usbduxsigma_submit_urbs(dev, this_usbduxsub->urbOut,
+					      this_usbduxsub->numOfOutBuffers,
+					      0);
 		if (ret < 0) {
-			this_usbduxsub->ao_cmd_running = 0;
-			/* fixme: unlink here?? */
 			up(&this_usbduxsub->sem);
 			return ret;
 		}
+		this_usbduxsub->ao_cmd_running = 1;
 		s->async->inttrig = NULL;
 	} else {
 		/* TRIG_INT */

commit 91fe97f3a34f4c13993655c241a4edc90216e74f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:46:17 2013 -0700

    staging: comedi: usbduxsigma: remove dev_{level} messages in submit urbs functions
    
    The usbduxsub_submit_{In,Out}URBs() functions have a couple development
    debug messages that are just added noise. Remove them.
    
    Also, the sanity check of 'usbduxsub', the comedi_device private data, is
    not necessary. The callers have already validated it. Remove the checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 9a96af70780e..ec485de95767 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -615,9 +615,6 @@ static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
 {
 	int i, errFlag;
 
-	if (!usbduxsub)
-		return -EFAULT;
-
 	/* Submit all URBs and start the transfer on the bus */
 	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
 		/* in case of a resubmission after an unlink... */
@@ -626,19 +623,9 @@ static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
 		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urbIn[i]->status = 0;
 		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",
-			usbduxsub->comedidev->minor, i,
-			(usbduxsub->urbIn[i]->context),
-			(usbduxsub->urbIn[i]->dev),
-			(usbduxsub->urbIn[i]->interval));
 		errFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);
-		if (errFlag) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ai: usb_submit_urb(%d) error %d\n",
-				i, errFlag);
+		if (errFlag)
 			return errFlag;
-		}
 	}
 	return 0;
 }
@@ -647,24 +634,15 @@ static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
 {
 	int i, errFlag;
 
-	if (!usbduxsub)
-		return -EFAULT;
-
 	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
-		dev_dbg(&usbduxsub->interface->dev,
-			"comedi_: submitting out-urb[%d]\n", i);
 		/* in case of a resubmission after an unlink... */
 		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
 		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
 		usbduxsub->urbOut[i]->status = 0;
 		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
 		errFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);
-		if (errFlag) {
-			dev_err(&usbduxsub->interface->dev,
-				"comedi_: ao: usb_submit_urb(%d) error %d\n",
-				i, errFlag);
+		if (errFlag)
 			return errFlag;
-		}
 	}
 	return 0;
 }

commit 641b78f3674fcf2f77aaf295ab2a96c3d9d7d3cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:45:51 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsub_ao_IsocIrq()
    
    Rename the local variables to follow the "norm" for comedi drivers.
    The comedi_subdevice for this function is the dev->write_subdev that
    was initialized during the (*auto_attach), use that instead of
    directly accessing the comedi_device subdevices array.
    
    Use dev->class_dev for any dev_{level} messages.
    
    Remove the extra check of 'ao_cmd_running' before submitting the urb.
    This flag was previously checked and if the command is aborted due to
    an usbdux_ao_stop() before reaching this point the function will exit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 169d1f8e7118..9a96af70780e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -422,18 +422,13 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 
 static void usbduxsub_ao_IsocIrq(struct urb *urb)
 {
-	int i, ret;
+	struct comedi_device *dev = urb->context;
+	struct usbduxsub *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->write_subdev;
 	uint8_t *datap;
-	struct usbduxsub *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-
-	/* the context variable points to the subdevice */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
-	this_usbduxsub = this_comedidev->private;
-
-	s = &this_comedidev->subdevices[SUBDEV_DA];
+	int len;
+	int ret;
+	int i;
 
 	switch (urb->status) {
 	case 0:
@@ -444,112 +439,93 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		/* after an unlink command, unplug, ... etc */
-		/* no unlink needed here. Already shutting down. */
-		if (this_usbduxsub->ao_cmd_running) {
+		/* happens after an unlink command */
+		if (devpriv->ao_cmd_running) {
+			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
-			usbdux_ao_stop(this_usbduxsub, 0);
+			comedi_event(devpriv->comedidev, s);
 		}
 		return;
 
 	default:
 		/* a real error */
-		if (this_usbduxsub->ao_cmd_running) {
-			dev_err(&urb->dev->dev,
-				"comedi_: Non-zero urb status received in ao "
-				"intr context: %d\n", urb->status);
-			s->async->events |= COMEDI_CB_ERROR;
-			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
-			/* we do an unlink if we are in the high speed mode */
-			usbdux_ao_stop(this_usbduxsub, 0);
+		if (devpriv->ao_cmd_running) {
+			dev_err(dev->class_dev,
+				"%s: non-zero urb status (%d)\n",
+				__func__, urb->status);
+			usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+			s->async->events |= (COMEDI_CB_ERROR | COMEDI_CB_EOA);
+			comedi_event(devpriv->comedidev, s);
 		}
 		return;
 	}
 
-	/* are we actually running? */
-	if (!(this_usbduxsub->ao_cmd_running))
+	if (!devpriv->ao_cmd_running)
 		return;
 
-	/* normal operation: executing a command in this subdevice */
-	this_usbduxsub->ao_counter--;
-	if ((int)this_usbduxsub->ao_counter <= 0) {
-		/* timer zero */
-		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
-
-		/* handle non continuous acquisition */
-		if (!(this_usbduxsub->ao_continuous)) {
-			/* fixed number of samples */
-			this_usbduxsub->ao_sample_count--;
-			if (this_usbduxsub->ao_sample_count < 0) {
-				/* all samples transmitted */
-				usbdux_ao_stop(this_usbduxsub, 0);
+	devpriv->ao_counter--;
+	if ((int)devpriv->ao_counter <= 0) {
+		/* timer zero, transfer from comedi */
+		devpriv->ao_counter = devpriv->ao_timer;
+
+		if (!devpriv->ao_continuous) {
+			/* not continuous, fixed number of samples */
+			devpriv->ao_sample_count--;
+			if (devpriv->ao_sample_count < 0) {
+				usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+				/* acquistion is over, tell comedi */
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(this_usbduxsub->comedidev, s);
-				/* no resubmit of the urb */
+				comedi_event(devpriv->comedidev, s);
 				return;
 			}
 		}
+
 		/* transmit data to the USB bus */
-		((uint8_t *) (urb->transfer_buffer))[0] =
-		    s->async->cmd.chanlist_len;
-		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
-			short temp;
+		datap = urb->transfer_buffer;
+		len = s->async->cmd.chanlist_len;
+		*datap++ = len;
+		for (i = 0; i < len; i++) {
+			short val;
+
 			if (i >= NUMOUTCHANNELS)
 				break;
 
-			/* pointer to the DA */
-			datap =
-			    (&(((uint8_t *) urb->transfer_buffer)[i * 2 + 1]));
-			/* get the data from comedi */
-			ret = comedi_buf_get(s->async, &temp);
-			datap[0] = temp;
-			datap[1] = this_usbduxsub->dac_commands[i];
-			/* printk("data[0]=%x, data[1]=%x, data[2]=%x\n", */
-			/* datap[0],datap[1],datap[2]); */
+			ret = comedi_buf_get(s->async, &val);
 			if (ret < 0) {
-				dev_err(&urb->dev->dev,
-					"comedi: buffer underflow\n");
-				s->async->events |= COMEDI_CB_EOA;
-				s->async->events |= COMEDI_CB_OVERFLOW;
+				dev_err(dev->class_dev, "buffer underflow\n");
+				s->async->events |= (COMEDI_CB_EOA |
+						     COMEDI_CB_OVERFLOW);
 			}
-			/* transmit data to comedi */
+			*datap++ = val;
+			*datap++ = devpriv->dac_commands[i];
+
 			s->async->events |= COMEDI_CB_BLOCK;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 		}
 	}
+
 	urb->transfer_buffer_length = SIZEOUTBUF;
-	urb->dev = this_usbduxsub->usbdev;
+	urb->dev = devpriv->usbdev;
 	urb->status = 0;
-	if (this_usbduxsub->ao_cmd_running) {
-		if (this_usbduxsub->high_speed) {
-			/* uframes */
-			urb->interval = 8;
-		} else {
-			/* frames */
-			urb->interval = 1;
-		}
-		urb->number_of_packets = 1;
-		urb->iso_frame_desc[0].offset = 0;
-		urb->iso_frame_desc[0].length = SIZEOUTBUF;
-		urb->iso_frame_desc[0].status = 0;
-		ret = usb_submit_urb(urb, GFP_ATOMIC);
-		if (ret < 0) {
-			dev_err(&urb->dev->dev,
-				"comedi_: ao urb resubm failed in int-cont. "
-				"ret=%d", ret);
-			if (ret == EL2NSYNC)
-				dev_err(&urb->dev->dev,
-					"buggy USB host controller or bug in "
-					"IRQ handling!\n");
-
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
-			/* don't do an unlink here */
-			usbdux_ao_stop(this_usbduxsub, 0);
-		}
+	if (devpriv->high_speed)
+		urb->interval = 8;	/* uframes */
+	else
+		urb->interval = 1;	/* frames */
+	urb->number_of_packets = 1;
+	urb->iso_frame_desc[0].offset = 0;
+	urb->iso_frame_desc[0].length = SIZEOUTBUF;
+	urb->iso_frame_desc[0].status = 0;
+	ret = usb_submit_urb(urb, GFP_ATOMIC);
+	if (ret < 0) {
+		dev_err(dev->class_dev,
+			"%s: urb resubmit failed (%d)\n",
+			__func__, ret);
+		if (ret == EL2NSYNC)
+			dev_err(dev->class_dev,
+				"buggy USB host controller or bug in IRQ handler\n");
+		usbdux_ao_stop(devpriv, 0);	/* w/o unlink */
+		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
+		comedi_event(dev, s);
 	}
 }
 

commit 147b25a3cc9c95597bbccf0559663932d31972b9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:45:16 2013 -0700

    staging: comedi: usbduxsigma: tidy up usbduxsub_ai_IsocIrq()
    
    Rename the local variables to follow the "norm" for comedi drivers.
    The comedi_subdevice for this function is the dev->read_subdev that
    was initialized during the (*auto_attach), use that instead of
    directly accessing the comedi_device subdevices array.
    
    Use dev->class_dev for any dev_{level} messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 08710bfdc4e9..169d1f8e7118 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -279,37 +279,29 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/* analogue IN - interrupt service routine */
 static void usbduxsub_ai_IsocIrq(struct urb *urb)
 {
-	int i, err, n;
-	struct usbduxsub *this_usbduxsub;
-	struct comedi_device *this_comedidev;
-	struct comedi_subdevice *s;
-	int32_t v;
+	struct comedi_device *dev = urb->context;
+	struct usbduxsub *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
 	unsigned int dio_state;
-
-	/* the context variable points to the comedi device */
-	this_comedidev = urb->context;
-	/* the private structure of the subdevice is struct usbduxsub */
-	this_usbduxsub = this_comedidev->private;
-	/* subdevice which is the AD converter */
-	s = &this_comedidev->subdevices[SUBDEV_AD];
+	int32_t val;
+	int ret;
+	int i;
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
 		/* copy the result in the transfer buffer */
-		memcpy(this_usbduxsub->inBuffer,
-		       urb->transfer_buffer, SIZEINBUF);
+		memcpy(devpriv->inBuffer, urb->transfer_buffer, SIZEINBUF);
 		break;
 	case -EILSEQ:
-		/* error in the ISOchronous data */
-		/* we don't copy the data into the transfer buffer */
-		/* and recycle the last data byte */
-		dev_dbg(&urb->dev->dev,
-			"comedi%d: usbdux: CRC error in ISO IN stream.\n",
-			this_usbduxsub->comedidev->minor);
+		/*
+		 * error in the ISOchronous data
+		 * we don't copy the data into the transfer buffer
+		 * and recycle the last data byte
+		 */
+		dev_dbg(dev->class_dev,"CRC error in ISO IN stream\n");
 
 		break;
 
@@ -318,110 +310,87 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
 		/* happens after an unlink command */
-		if (this_usbduxsub->ai_cmd_running) {
-			/* we are still running a command */
-			/* tell this comedi */
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
-			/* stop the transfer w/o unlink */
-			usbdux_ai_stop(this_usbduxsub, 0);
+		if (devpriv->ai_cmd_running) {
+			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			/* we are still running a command, tell comedi */
+			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
+			comedi_event(dev, s);
 		}
 		return;
 
 	default:
-		/* a real error on the bus */
-		/* pass error to comedi if we are really running a command */
-		if (this_usbduxsub->ai_cmd_running) {
-			dev_err(&urb->dev->dev,
-				"Non-zero urb status received in ai intr "
-				"context: %d\n", urb->status);
-			s->async->events |= COMEDI_CB_EOA;
-			s->async->events |= COMEDI_CB_ERROR;
-			comedi_event(this_usbduxsub->comedidev, s);
-			/* don't do an unlink here */
-			usbdux_ai_stop(this_usbduxsub, 0);
-		}
-		return;
-	}
-
-	/*
-	 * at this point we are reasonably sure that nothing dodgy has happened
-	 * are we running a command?
-	 */
-	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
 		/*
-		 * not running a command, do not continue execution if no
-		 * asynchronous command is running in particular not resubmit
+		 * a real error on the bus
+		 * pass error to comedi if we are really running a command
 		 */
+		if (devpriv->ai_cmd_running) {
+			dev_err(dev->class_dev,
+				"%s: non-zero urb status (%d)\n",
+				__func__, urb->status);
+			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
+			comedi_event(dev, s);
+		}
 		return;
 	}
 
-	urb->dev = this_usbduxsub->usbdev;
+	if (unlikely(!devpriv->ai_cmd_running))
+		return;
 
-	/* resubmit the urb */
-	err = usb_submit_urb(urb, GFP_ATOMIC);
-	if (unlikely(err < 0)) {
-		dev_err(&urb->dev->dev,
-			"comedi_: urb resubmit failed in int-context!"
-			"err=%d\n",
-			err);
-		if (err == -EL2NSYNC)
-			dev_err(&urb->dev->dev,
-				"buggy USB host controller or bug in IRQ "
-				"handler!\n");
-		s->async->events |= COMEDI_CB_EOA;
-		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxsub->comedidev, s);
-		/* don't do an unlink here */
-		usbdux_ai_stop(this_usbduxsub, 0);
+	urb->dev = devpriv->usbdev;
+
+	ret = usb_submit_urb(urb, GFP_ATOMIC);
+	if (unlikely(ret < 0)) {
+		dev_err(dev->class_dev, "%s: urb resubmit failed (%d)\n",
+			__func__, ret);
+		if (ret == -EL2NSYNC)
+			dev_err(dev->class_dev,
+				"buggy USB host controller or bug in IRQ handler\n");
+		usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+		s->async->events |= (COMEDI_CB_EOA | COMEDI_CB_ERROR);
+		comedi_event(dev, s);
 		return;
 	}
 
 	/* get the state of the dio pins to allow external trigger */
-	dio_state = be32_to_cpu(this_usbduxsub->inBuffer[0]);
+	dio_state = be32_to_cpu(devpriv->inBuffer[0]);
 
-	this_usbduxsub->ai_counter--;
-	if (likely(this_usbduxsub->ai_counter > 0))
+	devpriv->ai_counter--;
+	if (likely(devpriv->ai_counter > 0))
 		return;
 
 	/* timer zero, transfer measurements to comedi */
-	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+	devpriv->ai_counter = devpriv->ai_timer;
 
-	/* test, if we transmit only a fixed number of samples */
-	if (!(this_usbduxsub->ai_continuous)) {
+	if (!devpriv->ai_continuous) {
 		/* not continuous, fixed number of samples */
-		this_usbduxsub->ai_sample_count--;
-		/* all samples received? */
-		if (this_usbduxsub->ai_sample_count < 0) {
-			/* prevent a resubmit next time */
-			usbdux_ai_stop(this_usbduxsub, 0);
-			/* say comedi that the acquistion is over */
+		devpriv->ai_sample_count--;
+		if (devpriv->ai_sample_count < 0) {
+			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
+			/* acquistion is over, tell comedi */
 			s->async->events |= COMEDI_CB_EOA;
-			comedi_event(this_usbduxsub->comedidev, s);
+			comedi_event(dev, s);
 			return;
 		}
 	}
+
 	/* get the data from the USB bus and hand it over to comedi */
-	n = s->async->cmd.chanlist_len;
-	for (i = 0; i < n; i++) {
+	for (i = 0; i < s->async->cmd.chanlist_len; i++) {
 		/* transfer data, note first byte is the DIO state */
-		v = be32_to_cpu(this_usbduxsub->inBuffer[i+1]);
-		/* strip status byte */
-		v = v & 0x00ffffff;
-		/* convert to unsigned */
-		v = v ^ 0x00800000;
-		/* write the byte to the buffer */
-		err = cfc_write_array_to_buffer(s, &v, sizeof(uint32_t));
-		if (unlikely(err == 0)) {
+		val = be32_to_cpu(devpriv->inBuffer[i+1]);
+		val &= 0x00ffffff;	/* strip status byte */
+		val ^= 0x00800000;	/* convert to unsigned */
+
+		ret = cfc_write_array_to_buffer(s, &val, sizeof(uint32_t));
+		if (unlikely(ret == 0)) {
 			/* buffer overflow */
-			usbdux_ai_stop(this_usbduxsub, 0);
+			usbdux_ai_stop(devpriv, 0);	/* w/o unlink */
 			return;
 		}
 	}
 	/* tell comedi that data is there */
-	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
-	comedi_event(this_usbduxsub->comedidev, s);
+	s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	comedi_event(dev, s);
 }
 
 static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)

commit f31260f9c85f140e0e3fbff6406cd3e05c88907d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:44:39 2013 -0700

    staging: comedi: usbduxsigma: absorb usbduxsub_unlink_PwmURBs() into caller
    
    This function is only called by usbdux_pwm_stop(). Absorb it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2c8f78b19078..08710bfdc4e9 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1590,16 +1590,12 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void usbduxsub_unlink_PwmURBs(struct usbduxsub *devpriv)
-{
-	if (devpriv->urbPwm)
-		usb_kill_urb(devpriv->urbPwm);
-}
-
 static void usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (do_unlink)
-		usbduxsub_unlink_PwmURBs(devpriv);
+	if (do_unlink) {
+		if (devpriv->urbPwm)
+			usb_kill_urb(devpriv->urbPwm);
+	}
 
 	devpriv->pwm_cmd_running = 0;
 }

commit 7bcc313186b55f2e9e5a786c40b8c5c589a24d5b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:44:17 2013 -0700

    staging: comedi: usbduxsigma: use usbdux_pwm_stop() to force unlink urb
    
    In tidy_up(), instead of duplicating the code in usbdux_pwm_stop() to
    unlink the pwm urb, just use usbdux_pwm_stop(). Since that function calls
    usb_kill_urb() and clears the 'pwm_cmd_running' flag, we can also remove
    the redundant code in tidy_up().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 161c91274549..2c8f78b19078 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1934,13 +1934,10 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 		usbduxsub_tmp->urbOut = NULL;
 	}
 	if (usbduxsub_tmp->urbPwm) {
-		if (usbduxsub_tmp->pwm_cmd_running) {
-			usbduxsub_tmp->pwm_cmd_running = 0;
-			usbduxsub_unlink_PwmURBs(usbduxsub_tmp);
-		}
+		/* force unlink urb */
+		usbdux_pwm_stop(usbduxsub_tmp, 1);
 		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
 		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
-		usb_kill_urb(usbduxsub_tmp->urbPwm);
 		usb_free_urb(usbduxsub_tmp->urbPwm);
 		usbduxsub_tmp->urbPwm = NULL;
 	}
@@ -1954,7 +1951,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->dac_commands = NULL;
 	kfree(usbduxsub_tmp->dux_commands);
 	usbduxsub_tmp->dux_commands = NULL;
-	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
 static int usbduxsigma_attach_common(struct comedi_device *dev,

commit 0c32b57e77106406c202a1e5e73b985d950db196
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:43:57 2013 -0700

    staging: comedi: usbduxsigma: absorb usbduxsub_unlink_OutURBs() into caller
    
    This function is only called by usbdux_ao_stop(). Absorb it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5f7e19d9ec88..161c91274549 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -424,20 +424,16 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static void usbduxsub_unlink_OutURBs(struct usbduxsub *devpriv)
+static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	int i;
+	if (do_unlink) {
+		int i;
 
-	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
-		if (devpriv->urbOut[i])
-			usb_kill_urb(devpriv->urbOut[i]);
+		for (i = 0; i < devpriv->numOfOutBuffers; i++) {
+			if (devpriv->urbOut[i])
+				usb_kill_urb(devpriv->urbOut[i]);
+		}
 	}
-}
-
-static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
-{
-	if (do_unlink)
-		usbduxsub_unlink_OutURBs(devpriv);
 
 	devpriv->ao_cmd_running = 0;
 }

commit dc29c6fa5e5b3f18b29a4c552ea4f67376ebf2cd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:43:35 2013 -0700

    staging: comedi: usbduxsigma: use usbdux_ao_stop() to force unlink all urbs
    
    In tidy_up(), instead of duplicating the code in usbdux_ao_stop() to unlink
    all the output urbs, just use usbdux_ao_stop(). Since that function calls
    usb_kill_urb() for all the urbs and clears the 'ao_cmd_running' flag, we
    can also remove the redundant code in tidy_up().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 4d941408cd75..5f7e19d9ec88 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1920,10 +1920,8 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 		usbduxsub_tmp->urbIn = NULL;
 	}
 	if (usbduxsub_tmp->urbOut) {
-		if (usbduxsub_tmp->ao_cmd_running) {
-			usbduxsub_tmp->ao_cmd_running = 0;
-			usbduxsub_unlink_OutURBs(usbduxsub_tmp);
-		}
+		/* force unlink all urbs */
+		usbdux_ao_stop(usbduxsub_tmp, 1);
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
 				kfree(usbduxsub_tmp->
@@ -1932,7 +1930,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 				    NULL;
 			}
 			if (usbduxsub_tmp->urbOut[i]) {
-				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
 				usb_free_urb(usbduxsub_tmp->urbOut[i]);
 				usbduxsub_tmp->urbOut[i] = NULL;
 			}
@@ -1961,7 +1958,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->dac_commands = NULL;
 	kfree(usbduxsub_tmp->dux_commands);
 	usbduxsub_tmp->dux_commands = NULL;
-	usbduxsub_tmp->ao_cmd_running = 0;
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 

commit 705a8f720154eea0c8f9801f6a9b30bbf5d7ca25
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:43:07 2013 -0700

    staging: comedi: usbduxsigma: absorb usbduxsub_unlink_InURBs() into caller
    
    This function is only called by usbdux_ai_stop(). Absorb it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2add3efb4df1..4d941408cd75 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -252,20 +252,16 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static void usbduxsub_unlink_InURBs(struct usbduxsub *devpriv)
+static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	int i;
+	if (do_unlink) {
+		int i;
 
-	for (i = 0; i < devpriv->numOfInBuffers; i++) {
-		if (devpriv->urbIn[i])
-			usb_kill_urb(devpriv->urbIn[i]);
+		for (i = 0; i < devpriv->numOfInBuffers; i++) {
+			if (devpriv->urbIn[i])
+				usb_kill_urb(devpriv->urbIn[i]);
+		}
 	}
-}
-
-static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
-{
-	if (do_unlink)
-		usbduxsub_unlink_InURBs(devpriv);
 
 	devpriv->ai_cmd_running = 0;
 }

commit c61454e19ab327f769221f1752b59322853d8716
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:42:42 2013 -0700

    staging: comedi: usbduxsigma: use usbdux_ai_stop() to force unlink all urbs
    
    In tidy_up(), instead of duplicating the code in usbdux_ai_stop() to unlink
    all the input urbs, just use usbdux_ai_stop(). Since that function calls
    usb_kill_urb() for all the urbs and clears the 'ai_cmd_running' flag, we
    can also remove the redundant code in tidy_up().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index eca29e4d7d35..2add3efb4df1 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1912,14 +1912,11 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->probed = 0;
 
 	if (usbduxsub_tmp->urbIn) {
-		if (usbduxsub_tmp->ai_cmd_running) {
-			usbduxsub_tmp->ai_cmd_running = 0;
-			usbduxsub_unlink_InURBs(usbduxsub_tmp);
-		}
+		/* force unlink all urbs */
+		usbdux_ai_stop(usbduxsub_tmp, 1);
 		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
 			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
 			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
-			usb_kill_urb(usbduxsub_tmp->urbIn[i]);
 			usb_free_urb(usbduxsub_tmp->urbIn[i]);
 			usbduxsub_tmp->urbIn[i] = NULL;
 		}
@@ -1968,7 +1965,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->dac_commands = NULL;
 	kfree(usbduxsub_tmp->dux_commands);
 	usbduxsub_tmp->dux_commands = NULL;
-	usbduxsub_tmp->ai_cmd_running = 0;
 	usbduxsub_tmp->ao_cmd_running = 0;
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }

commit eac456c82376f6592b2fb8dd6f76d230bf24476e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:42:01 2013 -0700

    staging: comedi: usbduxsigma: cleanup the (*cancel) functions
    
    The (*cancel) functions can only be called by the comedi core it the
    (*auto_attach) completed successfully. That function sets the comedi_device
    'private' variable before initializing the callbacks so the sanity checks
    are unnecessary. Remove them.
    
    Also, rename the 'this_usbduxsub' local variable to 'devpriv' as this is
    more common in comedi drivers.
    
    Remove the unnecessary comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index c0e2f9e4e5e2..eca29e4d7d35 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -270,25 +270,15 @@ static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
 	devpriv->ai_cmd_running = 0;
 }
 
-/*
- * This will cancel a running acquisition operation.
- * This is called by comedi but never from inside the driver.
- */
 static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub;
-
-	/* force unlink of all urbs */
-	this_usbduxsub = dev->private;
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbduxsub *devpriv = dev->private;
 
-	/* prevent other CPUs from submitting new commands just now */
-	down(&this_usbduxsub->sem);
-	/* unlink only if the urb really has been submitted */
-	usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
-	up(&this_usbduxsub->sem);
+	down(&devpriv->sem);
+	/* unlink only if it is really running */
+	usbdux_ai_stop(devpriv, devpriv->ai_cmd_running);
+	up(&devpriv->sem);
 
 	return 0;
 }
@@ -456,20 +446,15 @@ static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
 	devpriv->ao_cmd_running = 0;
 }
 
-/* force unlink, is called by comedi */
 static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
+	struct usbduxsub *devpriv = dev->private;
 
-	if (!this_usbduxsub)
-		return -EFAULT;
-
-	/* prevent other CPUs from submitting a command just now */
-	down(&this_usbduxsub->sem);
+	down(&devpriv->sem);
 	/* unlink only if it is really running */
-	usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
-	up(&this_usbduxsub->sem);
+	usbdux_ao_stop(devpriv, devpriv->ao_cmd_running);
+	up(&devpriv->sem);
 
 	return 0;
 }
@@ -1627,19 +1612,15 @@ static void usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
 	devpriv->pwm_cmd_running = 0;
 }
 
-/* force unlink - is called by comedi */
 static int usbdux_pwm_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
-	struct usbduxsub *this_usbduxsub = dev->private;
-
-	if (!this_usbduxsub)
-		return -EFAULT;
+	struct usbduxsub *devpriv = dev->private;
 
 	/* unlink only if it is really running */
-	usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
+	usbdux_pwm_stop(devpriv, devpriv->pwm_cmd_running);
 
-	return send_dux_commands(this_usbduxsub, SENDPWMOFF);
+	return send_dux_commands(devpriv, SENDPWMOFF);
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)

commit 00fbd2851428f2fa8cf0aaff6832f21fe4856c9c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:41:27 2013 -0700

    staging: comedi: usbduxsigma: remove check of 'probed' in (*cancel) functions
    
    The comedi_device private data variable 'probed' is set after the usb_driver
    has completed its (*probe) before calling comedi_usb_auto_config(). That
    function calls the comedi_driver (*auto_attach) which will set the
    comedi_device 'private' variable and initialize the subdevices.
    
    The subdevice (*cancel) functions can only be called after the (*auto_attach)
    has completed successfully so the sanity checks of 'probed' are unnecessary.
    Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 68b2d048739c..c0e2f9e4e5e2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -286,10 +286,6 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	/* unlink only if the urb really has been submitted */
 	usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
 	up(&this_usbduxsub->sem);
@@ -471,10 +467,6 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 
 	/* prevent other CPUs from submitting a command just now */
 	down(&this_usbduxsub->sem);
-	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
-	}
 	/* unlink only if it is really running */
 	usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
 	up(&this_usbduxsub->sem);

commit 05d4c6f6289fdd9df7fd875ddf361af876419796
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:40:45 2013 -0700

    staging: comedi: usbduxsigma: change return type of the stop functions
    
    The usbdux_pwm_cancel() function is the only caller that does not validate
    the comedi_device private data before calling the stop function. Move the
    validation test to that function and remove the unnecessary sanity checks.
    
    Since the stop functions always succeed, change the return type to void.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 59f461df675d..68b2d048739c 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -262,17 +262,12 @@ static void usbduxsub_unlink_InURBs(struct usbduxsub *devpriv)
 	}
 }
 
-static int usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!devpriv)
-		return -EFAULT;
-
 	if (do_unlink)
 		usbduxsub_unlink_InURBs(devpriv);
 
 	devpriv->ai_cmd_running = 0;
-
-	return 0;
 }
 
 /*
@@ -283,7 +278,6 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub;
-	int res = 0;
 
 	/* force unlink of all urbs */
 	this_usbduxsub = dev->private;
@@ -297,9 +291,10 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 		return -ENODEV;
 	}
 	/* unlink only if the urb really has been submitted */
-	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
+	usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
 	up(&this_usbduxsub->sem);
-	return res;
+
+	return 0;
 }
 
 /* analogue IN - interrupt service routine */
@@ -457,17 +452,12 @@ static void usbduxsub_unlink_OutURBs(struct usbduxsub *devpriv)
 	}
 }
 
-static int usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!devpriv)
-		return -EFAULT;
-
 	if (do_unlink)
 		usbduxsub_unlink_OutURBs(devpriv);
 
 	devpriv->ao_cmd_running = 0;
-
-	return 0;
 }
 
 /* force unlink, is called by comedi */
@@ -475,7 +465,6 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
-	int res = 0;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -487,9 +476,10 @@ static int usbdux_ao_cancel(struct comedi_device *dev,
 		return -ENODEV;
 	}
 	/* unlink only if it is really running */
-	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
+	usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
 	up(&this_usbduxsub->sem);
-	return res;
+
+	return 0;
 }
 
 static void usbduxsub_ao_IsocIrq(struct urb *urb)
@@ -1637,17 +1627,12 @@ static void usbduxsub_unlink_PwmURBs(struct usbduxsub *devpriv)
 		usb_kill_urb(devpriv->urbPwm);
 }
 
-static int usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
+static void usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!devpriv)
-		return -EFAULT;
-
 	if (do_unlink)
 		usbduxsub_unlink_PwmURBs(devpriv);
 
 	devpriv->pwm_cmd_running = 0;
-
-	return 0;
 }
 
 /* force unlink - is called by comedi */
@@ -1655,16 +1640,14 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct usbduxsub *this_usbduxsub = dev->private;
-	int res = 0;
 
-	/* unlink only if it is really running */
-	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
+	if (!this_usbduxsub)
+		return -EFAULT;
 
-	res = send_dux_commands(this_usbduxsub, SENDPWMOFF);
-	if (res < 0)
-		return res;
+	/* unlink only if it is really running */
+	usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
-	return res;
+	return send_dux_commands(this_usbduxsub, SENDPWMOFF);
 }
 
 static void usbduxsub_pwm_irq(struct urb *urb)

commit 19d61fd2509ee41784af13eac1c04fba30b2d487
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:40:10 2013 -0700

    staging: comedi: usbduxsigma: cleanup the stop functions
    
    The 'this_usbduxsub' parameter is actually the comedi_device private data,
    rename it to 'devpriv' which is more common in comedi drivers.
    
    Remove the unnecessary pr_err() noise in usbdux_ai_stop().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e28457205f94..59f461df675d 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -262,17 +262,15 @@ static void usbduxsub_unlink_InURBs(struct usbduxsub *devpriv)
 	}
 }
 
-static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_ai_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!this_usbduxsub) {
-		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+	if (!devpriv)
 		return -EFAULT;
-	}
 
 	if (do_unlink)
-		usbduxsub_unlink_InURBs(this_usbduxsub);
+		usbduxsub_unlink_InURBs(devpriv);
 
-	this_usbduxsub->ai_cmd_running = 0;
+	devpriv->ai_cmd_running = 0;
 
 	return 0;
 }
@@ -459,15 +457,15 @@ static void usbduxsub_unlink_OutURBs(struct usbduxsub *devpriv)
 	}
 }
 
-static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_ao_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!this_usbduxsub)
+	if (!devpriv)
 		return -EFAULT;
 
 	if (do_unlink)
-		usbduxsub_unlink_OutURBs(this_usbduxsub);
+		usbduxsub_unlink_OutURBs(devpriv);
 
-	this_usbduxsub->ao_cmd_running = 0;
+	devpriv->ao_cmd_running = 0;
 
 	return 0;
 }
@@ -1639,15 +1637,15 @@ static void usbduxsub_unlink_PwmURBs(struct usbduxsub *devpriv)
 		usb_kill_urb(devpriv->urbPwm);
 }
 
-static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+static int usbdux_pwm_stop(struct usbduxsub *devpriv, int do_unlink)
 {
-	if (!this_usbduxsub)
+	if (!devpriv)
 		return -EFAULT;
 
 	if (do_unlink)
-		usbduxsub_unlink_PwmURBs(this_usbduxsub);
+		usbduxsub_unlink_PwmURBs(devpriv);
 
-	this_usbduxsub->pwm_cmd_running = 0;
+	devpriv->pwm_cmd_running = 0;
 
 	return 0;
 }

commit 1c3032a4e98ee85073c7acf801cc5de721ed1acf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:39:41 2013 -0700

    staging: comedi: usbduxsigma: cleanup the unlink urb functions
    
    These functions always return success. Change them to just return void.
    
    The 'usbduxsub_tmp', which is actually the comedi_device private data, is
    already validated by the callers. Remove the unnecessary validation and
    rename the 'usbduxsub_tmp' parameter to 'devpriv' which is more common in
    comedi drivers.
    
    Remove the unnecessary comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 049a3e2e42b7..e28457205f94 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -252,49 +252,29 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-/*
- * Stops the data acquision
- * It should be safe to call this function from any context
- */
-static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)
+static void usbduxsub_unlink_InURBs(struct usbduxsub *devpriv)
 {
-	int i = 0;
-	int err = 0;
+	int i;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
-		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
-			if (usbduxsub_tmp->urbIn[i]) {
-				/* We wait here until all transfers have been
-				 * cancelled. */
-				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
-			}
-		}
+	for (i = 0; i < devpriv->numOfInBuffers; i++) {
+		if (devpriv->urbIn[i])
+			usb_kill_urb(devpriv->urbIn[i]);
 	}
-	return err;
 }
 
-/*
- * This will stop a running acquisition operation
- * Is called from within this driver from both the
- * interrupt context and from comedi
- */
 static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
-	int ret = 0;
-
 	if (!this_usbduxsub) {
 		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
 		return -EFAULT;
 	}
 
-	if (do_unlink) {
-		/* stop aquistion */
-		ret = usbduxsub_unlink_InURBs(this_usbduxsub);
-	}
+	if (do_unlink)
+		usbduxsub_unlink_InURBs(this_usbduxsub);
 
 	this_usbduxsub->ai_cmd_running = 0;
 
-	return ret;
+	return 0;
 }
 
 /*
@@ -469,36 +449,27 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	comedi_event(this_usbduxsub->comedidev, s);
 }
 
-static int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)
+static void usbduxsub_unlink_OutURBs(struct usbduxsub *devpriv)
 {
-	int i = 0;
-	int err = 0;
+	int i;
 
-	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
-		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
-			if (usbduxsub_tmp->urbOut[i])
-				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-		}
+	for (i = 0; i < devpriv->numOfOutBuffers; i++) {
+		if (devpriv->urbOut[i])
+			usb_kill_urb(devpriv->urbOut[i]);
 	}
-	return err;
 }
 
-/* This will cancel a running acquisition operation
- * in any context.
- */
 static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
-	int ret = 0;
-
 	if (!this_usbduxsub)
 		return -EFAULT;
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
+		usbduxsub_unlink_OutURBs(this_usbduxsub);
 
 	this_usbduxsub->ao_cmd_running = 0;
 
-	return ret;
+	return 0;
 }
 
 /* force unlink, is called by comedi */
@@ -1662,36 +1633,23 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/***********************************/
-/* PWM */
-
-static int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)
+static void usbduxsub_unlink_PwmURBs(struct usbduxsub *devpriv)
 {
-	int err = 0;
-
-	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
-		if (usbduxsub_tmp->urbPwm)
-			usb_kill_urb(usbduxsub_tmp->urbPwm);
-	}
-	return err;
+	if (devpriv->urbPwm)
+		usb_kill_urb(devpriv->urbPwm);
 }
 
-/* This cancels a running acquisition operation
- * in any context.
- */
 static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 {
-	int ret = 0;
-
 	if (!this_usbduxsub)
 		return -EFAULT;
 
 	if (do_unlink)
-		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
+		usbduxsub_unlink_PwmURBs(this_usbduxsub);
 
 	this_usbduxsub->pwm_cmd_running = 0;
 
-	return ret;
+	return 0;
 }
 
 /* force unlink - is called by comedi */

commit 956ddbcd89f2b335e7aaae8d7692f71f0e6b2ebf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:39:11 2013 -0700

    staging: comedi: usbduxsigma: remove unlink urb debug messages
    
    Remove the dev_dbg() messages in all the unlink urb functions. The 'err'
    is always 0 (success) so these messages are just added noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 2c9cdf5954dd..049a3e2e42b7 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -268,9 +268,6 @@ static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)
 				 * cancelled. */
 				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
 			}
-			dev_dbg(&usbduxsub_tmp->interface->dev,
-				"comedi: usbdux: unlinked InURB %d, err=%d\n",
-				i, err);
 		}
 	}
 	return err;
@@ -481,10 +478,6 @@ static int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)
 		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
 			if (usbduxsub_tmp->urbOut[i])
 				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
-
-			dev_dbg(&usbduxsub_tmp->interface->dev,
-				"comedi: usbdux: unlinked OutURB %d: res=%d\n",
-				i, err);
 		}
 	}
 	return err;
@@ -1679,8 +1672,6 @@ static int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)
 	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
 		if (usbduxsub_tmp->urbPwm)
 			usb_kill_urb(usbduxsub_tmp->urbPwm);
-		dev_dbg(&usbduxsub_tmp->interface->dev,
-			"comedi: unlinked PwmURB: res=%d\n", err);
 	}
 	return err;
 }

commit ee13dd31294dad56df70c6010745e192343cbf15
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu May 23 12:38:43 2013 -0700

    staging: comedi: usbduxsigma: remove function trace noise
    
    Remove all the dev_{level} function trace noise in the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 5663197702a2..2c9cdf5954dd 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -289,7 +289,6 @@ static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
 		return -EFAULT;
 	}
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");
 
 	if (do_unlink) {
 		/* stop aquistion */
@@ -316,8 +315,6 @@ static int usbdux_ai_cancel(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_cancel\n");
-
 	/* prevent other CPUs from submitting new commands just now */
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
@@ -502,7 +499,6 @@ static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 
 	if (!this_usbduxsub)
 		return -EFAULT;
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");
 
 	if (do_unlink)
 		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
@@ -979,10 +975,6 @@ static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
 	}
 	/* this is only reached if the data has been requested a couple of
 	 * times */
-	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
-		"wrong data returned from firmware: want %d, got %d.\n",
-		this_usbduxsub->comedidev->minor, command,
-		this_usbduxsub->insnBuffer[0]);
 	return -EFAULT;
 }
 
@@ -999,9 +991,6 @@ static int usbdux_ai_inttrig(struct comedi_device *dev,
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_inttrig\n", dev->minor);
-
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
@@ -1044,9 +1033,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_cmd\n", dev->minor);
-
 	/* block other CPUs from starting an ai_cmd */
 	down(&this_usbduxsub->sem);
 
@@ -1090,10 +1076,6 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	this_usbduxsub->dux_commands[6] = muxsg1;
 	this_usbduxsub->dux_commands[7] = sysred;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi %d: sending commands to the usb device: size=%u\n",
-		dev->minor, NUMCHANNELS);
-
 	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
 	if (result < 0) {
 		up(&this_usbduxsub->sem);
@@ -1174,10 +1156,6 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return 0;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
-		dev->minor, insn->n, insn->subdev);
-
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1344,9 +1322,6 @@ static int usbdux_ao_insn_write(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: ao_insn_write\n", dev->minor);
-
 	down(&this_usbduxsub->sem);
 	if (!(this_usbduxsub->probed)) {
 		up(&this_usbduxsub->sem);
@@ -1440,9 +1415,6 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -1521,8 +1493,6 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		up(&this_usbduxsub->sem);
 		return -ENODEV;
 	}
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: %s\n", dev->minor, __func__);
 
 	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
@@ -1725,7 +1695,6 @@ static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);
 	if (do_unlink)
 		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
 
@@ -1744,9 +1713,6 @@ static int usbdux_pwm_cancel(struct comedi_device *dev,
 	/* unlink only if it is really running */
 	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi %d: sending pwm off command to the usb device.\n",
-		dev->minor);
 	res = send_dux_commands(this_usbduxsub, SENDPWMOFF);
 	if (res < 0)
 		return res;
@@ -1830,8 +1796,6 @@ static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
 	if (!usbduxsub)
 		return -EFAULT;
 
-	dev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");
-
 	/* in case of a resubmission after an unlink... */
 	usb_fill_bulk_urb(usbduxsub->urbPwm,
 			  usbduxsub->usbdev,
@@ -1872,8 +1836,6 @@ static int usbdux_pwm_period(struct comedi_device *dev,
 	}
 	this_usbduxsub->pwmDelay = fx2delay;
 	this_usbduxsub->pwmPeriod = period;
-	dev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",
-		__func__, period, fx2delay);
 	return 0;
 }
 
@@ -1884,9 +1846,6 @@ static int usbdux_pwm_start(struct comedi_device *dev,
 	int ret, i;
 	struct usbduxsub *this_usbduxsub = dev->private;
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
-		dev->minor, __func__);
-
 	if (this_usbduxsub->pwm_cmd_running) {
 		/* already running */
 		return 0;
@@ -1995,8 +1954,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 	switch (data[0]) {
 	case INSN_CONFIG_ARM:
 		/* switch it on */
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: pwm on\n", dev->minor, __func__);
 		/*
 		 * if not zero the PWM is limited to a certain time which is
 		 * not supported here
@@ -2005,8 +1962,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 			return -EINVAL;
 		return usbdux_pwm_start(dev, s);
 	case INSN_CONFIG_DISARM:
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: pwm off\n", dev->minor, __func__);
 		return usbdux_pwm_cancel(dev, s);
 	case INSN_CONFIG_GET_PWM_STATUS:
 		/*
@@ -2016,9 +1971,6 @@ static int usbdux_pwm_config(struct comedi_device *dev,
 		data[1] = this_usbduxsub->pwm_cmd_running;
 		return 0;
 	case INSN_CONFIG_PWM_SET_PERIOD:
-		dev_dbg(&this_usbduxsub->interface->dev,
-			"comedi%d: %s: setting period\n", dev->minor,
-			__func__);
 		return usbdux_pwm_period(dev, s, data[1]);
 	case INSN_CONFIG_PWM_GET_PERIOD:
 		data[1] = this_usbduxsub->pwmPeriod;
@@ -2049,7 +2001,6 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 
 	if (!usbduxsub_tmp)
 		return;
-	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi_: tiding up\n");
 
 	/* shows the usb subsystem that the driver is down */
 	if (usbduxsub_tmp->interface)
@@ -2293,9 +2244,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	int i;
 	int index;
 
-	dev_dbg(dev, "comedi_: usbdux_: "
-		"finding a free structure for the usb-device\n");
-
 	down(&start_stop_sem);
 	/* look for a free place in the usbdux array */
 	index = -1;
@@ -2312,8 +2260,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
-	dev_dbg(dev, "comedi_: usbdux: "
-		"usbduxsub[%d] is ready to connect to comedi.\n", index);
 
 	sema_init(&(usbduxsub[index].sem), 1);
 	/* save a pointer to the usb device */
@@ -2327,8 +2273,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* will be needed for disconnect */
 	usb_set_intfdata(uinterf, &(usbduxsub[index]));
 
-	dev_dbg(dev, "comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
-
 	/* test if it is high speed (USB 2.0) */
 	usbduxsub[index].high_speed =
 	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
@@ -2538,7 +2482,6 @@ static void usbduxsigma_usb_disconnect(struct usb_interface *intf)
 	tidy_up(usbduxsub_tmp);
 	up(&usbduxsub_tmp->sem);
 	up(&start_stop_sem);
-	dev_info(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
 static const struct usb_device_id usbduxsigma_usb_table[] = {

commit fb62a3f133e305b8b3b74b48c5a79330574cc892
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:32:29 2013 -0700

    staging: comedi: usbduxsigma: use comedi_load_firmware()
    
    Use comedi_load_firmware() instead of duplicating the code in a
    private function.
    
    Also, rename firmwareUpload() to have namespace associated with
    the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 26357b9cbcd5..5663197702a2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -50,7 +50,7 @@ Status: testing
 #include <linux/usb.h>
 #include <linux/fcntl.h>
 #include <linux/compiler.h>
-#include <linux/firmware.h>
+
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
@@ -670,9 +670,11 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 /* the FX2LP has twice as much as the standard FX2 */
 #define FIRMWARE_MAX_LEN 0x4000
 
-static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 *data, int size)
+static int usbduxsigma_firmware_upload(struct comedi_device *dev,
+				       const u8 *data, size_t size,
+				       unsigned long context)
 {
+	struct usbduxsub *usbduxsub = dev->private;
 	struct usb_device *usb = usbduxsub->usbdev;
 	uint8_t *buf;
 	uint8_t *tmp;
@@ -2236,16 +2238,15 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
 	struct usbduxsub *uds = usb_get_intfdata(uinterf);
 	struct usb_device *usb = uds->usbdev;
-	const struct firmware *fw;
 	int ret;
 
-	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
-	if (ret == 0) {
-		ret = firmwareUpload(uds, fw->data, fw->size);
-		release_firmware(fw);
-	}
-	if (ret < 0)
+	dev->private = uds;	/* This is temporary... */
+	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
+				   usbduxsigma_firmware_upload, 0);
+	if (ret < 0) {
+		dev->private = NULL;
 		return ret;
+	}
 
 	dev->private = NULL;
 

commit 0b2372897b0c23ee3f34656f3daf04e59c7f186b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:32:01 2013 -0700

    staging: comedi: usbduxsigma: move firmware request/upload into (*auto_attach)
    
    The last step the usb_driver (*probe) does before handing off to the
    comedi_driver (*auto_attach) is requesting and uploading the firmware.
    
    Move the request/upload into the (*auto_attach) so we can use the
    comedi_load_firmware() helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 15c5bd1a16f8..26357b9cbcd5 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2234,12 +2234,22 @@ static int usbduxsigma_auto_attach(struct comedi_device *dev,
 				   unsigned long context_unused)
 {
 	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
+	struct usbduxsub *uds = usb_get_intfdata(uinterf);
+	struct usb_device *usb = uds->usbdev;
+	const struct firmware *fw;
 	int ret;
-	struct usbduxsub *uds;
+
+	ret = request_firmware(&fw, FIRMWARE, &usb->dev);
+	if (ret == 0) {
+		ret = firmwareUpload(uds, fw->data, fw->size);
+		release_firmware(fw);
+	}
+	if (ret < 0)
+		return ret;
 
 	dev->private = NULL;
+
 	down(&start_stop_sem);
-	uds = usb_get_intfdata(uinterf);
 	if (!uds || !uds->probed) {
 		dev_err(dev->class_dev,
 			"usbduxsigma: error: auto_attach failed, not connected\n");
@@ -2279,10 +2289,8 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
-	const struct firmware *fw;
 	int i;
 	int index;
-	int ret;
 
 	dev_dbg(dev, "comedi_: usbdux_: "
 		"finding a free structure for the usb-device\n");
@@ -2500,16 +2508,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 
-	ret = request_firmware(&fw, FIRMWARE, &udev->dev);
-	if (ret == 0) {
-		ret = firmwareUpload(&usbduxsub[index], fw->data, fw->size);
-		release_firmware(fw);
-	}
-	if (ret) {
-		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
-		return ret;
-	}
-
 	return comedi_usb_auto_config(uinterf, &usbduxsigma_driver, 0);;
 }
 

commit 1cf35b51bea0201fd4552b3d83aaef4dcecf5187
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:31:32 2013 -0700

    staging: comedi: usbduxsigma: consolidate the firmware upload
    
    Absorb the usbduxsub_stop(), usbduxsub_upload(), and usbduxsub_start()
    functions into firmwareUpload().
    
    Each of them just do a usb_control_msg() to the device and output
    an error message if it fails. A similar message is also output by
    firmware_upload() so the extra messages are redundant.
    
    We can also share the malloc'ed local buffer needed for the
    usb_control_msg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f8102f506b57..15c5bd1a16f8 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -667,156 +667,84 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	}
 }
 
-static int usbduxsub_start(struct usbduxsub *usbduxsub)
-{
-	int errcode = 0;
-	uint8_t *local_transfer_buffer;
-
-	local_transfer_buffer = kmalloc(16, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to zero */
-	local_transfer_buffer[0] = 0;
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  /* create a pipe for a control transfer */
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* bRequest, "Firmware" */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* Value */
-				  USBDUXSUB_CPUCS,
-				  /* Index */
-				  0x0000,
-				  /* address of the transfer buffer */
-				  local_transfer_buffer,
-				  /* Length */
-				  1,
-				  /* Timeout */
-				  BULK_TIMEOUT);
-	if (errcode < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: control msg failed (start)\n");
-
-	kfree(local_transfer_buffer);
-	return errcode;
-}
-
-static int usbduxsub_stop(struct usbduxsub *usbduxsub)
-{
-	int errcode = 0;
-	uint8_t *local_transfer_buffer;
-
-	local_transfer_buffer = kmalloc(16, GFP_KERNEL);
-	if (!local_transfer_buffer)
-		return -ENOMEM;
-
-	/* 7f92 to one */
-	local_transfer_buffer[0] = 1;
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* bRequest, "Firmware" */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* Value */
-				  USBDUXSUB_CPUCS,
-				  /* Index */
-				  0x0000, local_transfer_buffer,
-				  /* Length */
-				  1,
-				  /* Timeout */
-				  BULK_TIMEOUT);
-	if (errcode < 0)
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: control msg failed (stop)\n");
-
-	kfree(local_transfer_buffer);
-	return errcode;
-}
-
-static int usbduxsub_upload(struct usbduxsub *usbduxsub,
-			    uint8_t *local_transfer_buffer,
-			    unsigned int startAddr, unsigned int len)
-{
-	int errcode;
-
-	errcode = usb_control_msg(usbduxsub->usbdev,
-				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
-				  /* brequest, firmware */
-				  USBDUXSUB_FIRMWARE,
-				  /* bmRequestType */
-				  VENDOR_DIR_OUT,
-				  /* value */
-				  startAddr,
-				  /* index */
-				  0x0000,
-				  /* our local safe buffer */
-				  local_transfer_buffer,
-				  /* length */
-				  len,
-				  /* timeout */
-				  BULK_TIMEOUT);
-	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
-	if (errcode < 0) {
-		dev_err(&usbduxsub->interface->dev,
-			"comedi_: upload failed\n");
-		return errcode;
-	}
-	return 0;
-}
-
 /* the FX2LP has twice as much as the standard FX2 */
 #define FIRMWARE_MAX_LEN 0x4000
 
 static int firmwareUpload(struct usbduxsub *usbduxsub,
-			  const u8 *firmwareBinary, int sizeFirmware)
+			  const u8 *data, int size)
 {
+	struct usb_device *usb = usbduxsub->usbdev;
+	uint8_t *buf;
+	uint8_t *tmp;
 	int ret;
-	uint8_t *fwBuf;
 
-	if (!firmwareBinary)
+	if (!data)
 		return 0;
 
-	if (sizeFirmware > FIRMWARE_MAX_LEN) {
+	if (size > FIRMWARE_MAX_LEN) {
 		dev_err(&usbduxsub->interface->dev,
 			"usbduxsigma firmware binary it too large for FX2.\n");
 		return -ENOMEM;
 	}
 
 	/* we generate a local buffer for the firmware */
-	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
-	if (!fwBuf) {
+	buf = kmemdup(data, size, GFP_KERNEL);
+	if (!buf) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: mem alloc for firmware failed\n");
 		return -ENOMEM;
 	}
 
-	ret = usbduxsub_stop(usbduxsub);
+	/* we need a malloc'ed buffer for usb_control_msg() */
+	tmp = kmalloc(1, GFP_KERNEL);
+	if (!tmp) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	/* stop the current firmware on the device */
+	*tmp = 1;	/* 7f92 to one */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not stop firmware\n");
-		kfree(fwBuf);
-		return ret;
+		goto done;
 	}
 
-	ret = usbduxsub_upload(usbduxsub, fwBuf, 0, sizeFirmware);
+	/* upload the new firmware to the device */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      0, 0x0000,
+			      buf, size,
+			      BULK_TIMEOUT);
 	if (ret < 0) {
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: firmware upload failed\n");
-		kfree(fwBuf);
-		return ret;
+		goto done;
 	}
-	ret = usbduxsub_start(usbduxsub);
-	if (ret < 0) {
+
+	/* start the new firmware on the device */
+	*tmp = 0;	/* 7f92 to zero */
+	ret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),
+			      USBDUXSUB_FIRMWARE,
+			      VENDOR_DIR_OUT,
+			      USBDUXSUB_CPUCS, 0x0000,
+			      tmp, 1,
+			      BULK_TIMEOUT);
+	if (ret < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: can not start firmware\n");
-		kfree(fwBuf);
-		return ret;
-	}
-	kfree(fwBuf);
-	return 0;
+
+done:
+	kfree(tmp);
+	kfree(buf);
+	return ret;
 }
 
 static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)

commit 41327b3e7344dadf8391549216db4e81deb32b22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon May 20 14:31:05 2013 -0700

    staging: comedi: usbduxsigma: request firmware synchronously
    
    Change the request_firmware_nowait() to a request_firmware() so
    that the usb_driver (*probe) can continue with the comedi_driver
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d34663fbab61..f8102f506b57 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2346,40 +2346,12 @@ static struct comedi_driver usbduxsigma_driver = {
 	.detach		= usbduxsigma_detach,
 };
 
-static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
-						     void *context)
-{
-	struct usbduxsub *usbduxsub_tmp = context;
-	struct usb_interface *uinterf = usbduxsub_tmp->interface;
-	int ret;
-
-	if (fw == NULL) {
-		dev_err(&uinterf->dev,
-			"Firmware complete handler without firmware!\n");
-		return;
-	}
-
-	/*
-	 * we need to upload the firmware here because fw will be
-	 * freed once we've left this function
-	 */
-	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
-
-	if (ret) {
-		dev_err(&uinterf->dev,
-			"Could not upload firmware (err=%d)\n", ret);
-		goto out;
-	}
-	comedi_usb_auto_config(uinterf, &usbduxsigma_driver, 0);
-out:
-	release_firmware(fw);
-}
-
 static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 				 const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
+	const struct firmware *fw;
 	int i;
 	int index;
 	int ret;
@@ -2600,23 +2572,17 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	usbduxsub[index].probed = 1;
 	up(&start_stop_sem);
 
-	ret = request_firmware_nowait(THIS_MODULE,
-				      FW_ACTION_HOTPLUG,
-				      FIRMWARE,
-				      &udev->dev,
-				      GFP_KERNEL,
-				      usbduxsub + index,
-				      usbdux_firmware_request_complete_handler
-				      );
-
+	ret = request_firmware(&fw, FIRMWARE, &udev->dev);
+	if (ret == 0) {
+		ret = firmwareUpload(&usbduxsub[index], fw->data, fw->size);
+		release_firmware(fw);
+	}
 	if (ret) {
 		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
 		return ret;
 	}
 
-	dev_info(dev, "comedi_: successfully initialised.\n");
-	/* success */
-	return 0;
+	return comedi_usb_auto_config(uinterf, &usbduxsigma_driver, 0);;
 }
 
 static void usbduxsigma_usb_disconnect(struct usb_interface *intf)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d3bc1b9910a7..d34663fbab61 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -11,11 +11,6 @@
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
  */
 /*
 Driver: usbduxsigma

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 1c2bfb4423e3..d3bc1b9910a7 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2205,7 +2205,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	down(&uds->sem);
 	/* pointer back to the corresponding comedi device */
 	uds->comedidev = dev;
-	dev->board_name = "usbduxsigma";
+
 	/* set number of subdevices */
 	if (uds->high_speed)
 		n_subdevs = 4;	/* with pwm */

commit ebde53ec1a5501b506d6f6756f98cbf11d5944ad
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 3 13:39:54 2013 -0700

    staging: comedi: usbduxsigma: use comedi provided range_unipolar2_5
    
    Remove the private range, range_usbdux_ao_range, in this driver and use
    the comedi provided range_unipolar2_5 instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 656135ef3972..1c2bfb4423e3 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -176,12 +176,6 @@ static const struct comedi_lrange range_usbdux_ai_range = { 1, {
 								}
 };
 
-static const struct comedi_lrange range_usbdux_ao_range = { 1, {
-								UNI_RANGE
-								(2.5),
-							       }
-};
-
 /*
  * private structure of one subdevice
  */
@@ -2269,7 +2263,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	/* 8 bit resolution */
 	s->maxdata = 0x00ff;
 	/* unipolar range */
-	s->range_table = (&range_usbdux_ao_range);
+	s->range_table = &range_unipolar2_5;
 	/* callback */
 	s->do_cmdtest = usbdux_ao_cmdtest;
 	s->do_cmd = usbdux_ao_cmd;

commit c45bb8cb72136bf23d18926113bff04c8cc90813
Merge: a14592896023 a937536b868b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 18 09:34:14 2013 -0700

    Merge 3.9-rc3 into staging-next
    
    This resolves the merge error due to removing the ccg staging driver,
    and picks up the other staging driver fixes that went into 3.9-rc3.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 20ce161d2f53af092fe8dabfef6fb0d7af846c43
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Mar 7 23:48:40 2013 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typos in staging/comedi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d066351a71b2..cfbfeeb40ffe 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1369,7 +1369,7 @@ static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
 
 	/* 32 bits big endian from the A/D converter */
 	one = be32_to_cpu(*((int32_t *)((this_usbduxsub->insnBuffer)+1)));
-	/* mask out the staus byte */
+	/* mask out the status byte */
 	one = one & 0x00ffffff;
 	one = one ^ 0x00800000;
 

commit b5ae11463a67a5e468dd67482ab2308994da9b2b
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Thu Feb 21 22:07:08 2013 -0800

    staging: comedi: drivers: usbduxsigma.c: fix DMA buffers on stack
    
    This patch fixes an instance of DMA buffer on stack(being passed to
    usb_control_msg)for the USB-DUXsigma Board driver. Found using smatch.
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index d066351a71b2..a728c8fc32a2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -681,7 +681,11 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 static int usbduxsub_start(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
-	uint8_t local_transfer_buffer[16];
+	uint8_t *local_transfer_buffer;
+
+	local_transfer_buffer = kmalloc(16, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to zero */
 	local_transfer_buffer[0] = 0;
@@ -702,19 +706,22 @@ static int usbduxsub_start(struct usbduxsub *usbduxsub)
 				  1,
 				  /* Timeout */
 				  BULK_TIMEOUT);
-	if (errcode < 0) {
+	if (errcode < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (start)\n");
-		return errcode;
-	}
-	return 0;
+
+	kfree(local_transfer_buffer);
+	return errcode;
 }
 
 static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 {
 	int errcode = 0;
+	uint8_t *local_transfer_buffer;
 
-	uint8_t local_transfer_buffer[16];
+	local_transfer_buffer = kmalloc(16, GFP_KERNEL);
+	if (!local_transfer_buffer)
+		return -ENOMEM;
 
 	/* 7f92 to one */
 	local_transfer_buffer[0] = 1;
@@ -732,12 +739,12 @@ static int usbduxsub_stop(struct usbduxsub *usbduxsub)
 				  1,
 				  /* Timeout */
 				  BULK_TIMEOUT);
-	if (errcode < 0) {
+	if (errcode < 0)
 		dev_err(&usbduxsub->interface->dev,
 			"comedi_: control msg failed (stop)\n");
-		return errcode;
-	}
-	return 0;
+
+	kfree(local_transfer_buffer);
+	return errcode;
 }
 
 static int usbduxsub_upload(struct usbduxsub *usbduxsub,

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index dc6b0174ad71..d066351a71b2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2431,8 +2431,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* create space for the commands of the DA converter */
 	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
 	if (!usbduxsub[index].dac_commands) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"error alloc space for dac commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2440,8 +2438,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* create space for the commands going to the usb device */
 	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
 	if (!usbduxsub[index].dux_commands) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"error alloc space for dux commands\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2449,8 +2445,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* create space for the in buffer and set it to zero */
 	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].inBuffer)) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"could not alloc space for inBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2458,8 +2452,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* create space of the instruction buffer */
 	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].insnBuffer)) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"could not alloc space for insnBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2467,8 +2459,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	/* create space for the outbuffer */
 	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
 	if (!(usbduxsub[index].outBuffer)) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"could not alloc space for outBuffer\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2489,12 +2479,10 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	else
 		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
 
-	usbduxsub[index].urbIn =
-	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
-		    GFP_KERNEL);
+	usbduxsub[index].urbIn = kcalloc(usbduxsub[index].numOfInBuffers,
+					 sizeof(struct urb *),
+					 GFP_KERNEL);
 	if (!(usbduxsub[index].urbIn)) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"Could not alloc. urbIn array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2519,8 +2507,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbIn[i]->transfer_buffer =
 		    kzalloc(SIZEINBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2539,12 +2525,9 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 	else
 		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
 
-	usbduxsub[index].urbOut =
-	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
-		    GFP_KERNEL);
+	usbduxsub[index].urbOut = kcalloc(usbduxsub[index].numOfOutBuffers,
+					  sizeof(struct urb *), GFP_KERNEL);
 	if (!(usbduxsub[index].urbOut)) {
-		dev_err(dev, "comedi_: usbduxsigma: "
-			"Could not alloc. urbOut array\n");
 		tidy_up(&(usbduxsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
@@ -2569,8 +2552,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbOut[i]->transfer_buffer =
 		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
 		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"could not alloc. transb.\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;
@@ -2606,8 +2587,6 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 		usbduxsub[index].urbPwm->transfer_buffer =
 		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
 		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
-			dev_err(dev, "comedi_: usbduxsigma%d: "
-				"could not alloc. transb. for pwm\n", index);
 			tidy_up(&(usbduxsub[index]));
 			up(&start_stop_sem);
 			return -ENOMEM;

commit 55ab4f641a3bfbdb7c59b80e194c7242234bbb1f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Feb 5 17:23:40 2013 -0700

    staging: comedi: comedi_usb: allow comedi usb drivers to pass a 'context'
    
    Allow the comedi usb drivers to pass a 'context' from their (*probe)
    functions to the comedi core's comedi_usb_auto_config(). This 'context'
    is then passed to comedi_auto_config() and then to the comedi_driver's
    (*auto_attach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index cdd279b1f61e..dc6b0174ad71 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2374,7 +2374,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(uinterf, &usbduxsigma_driver);
+	comedi_usb_auto_config(uinterf, &usbduxsigma_driver, 0);
 out:
 	release_firmware(fw);
 }

commit 7ec265905acdc6b24ce3b604a99dec690c7ab46a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 18:00:21 2012 -0700

    staging: comedi: usbduxsigma: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of usbdux_{ai,ao}_cmdtest().
    
    Also, remove some debug noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 972017069e5e..cdd279b1f61e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -904,9 +904,6 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
 
-	dev_dbg(&this_usbduxsub->interface->dev,
-		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
-
 	/* Step 1 : check if triggers are trivially valid */
 
 	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
@@ -928,19 +925,12 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (this_usbduxsub->high_speed) {
@@ -951,51 +941,35 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			 * are in the channel list the more time we need.
 			 */
 			i = chanToInterval(cmd->chanlist_len);
-			if (cmd->scan_begin_arg < (1000000 / 8 * i)) {
-				cmd->scan_begin_arg = 1000000 / 8 * i;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 (1000000 / 8 * i));
 			/* now calc the real sampling rate with all the
 			 * rounding errors */
 			tmpTimer =
 			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
 			    125000;
-			if (cmd->scan_begin_arg != tmpTimer) {
-				cmd->scan_begin_arg = tmpTimer;
-				err++;
-			}
 		} else {
 			/* full speed */
 			/* 1kHz scans every USB frame */
-			if (cmd->scan_begin_arg < 1000000) {
-				cmd->scan_begin_arg = 1000000;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+							 1000000);
 			/*
 			 * calc the real sampling rate with the rounding errors
 			 */
 			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
 						   1000000)) * 1000000;
-			if (cmd->scan_begin_arg != tmpTimer) {
-				cmd->scan_begin_arg = tmpTimer;
-				err++;
-			}
 		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
+						tmpTimer);
 	}
-	/* the same argument */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)
@@ -1576,57 +1550,30 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src == TRIG_FOLLOW)	/* internal trigger */
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 1000000);
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		/* timer */
-		if (cmd->scan_begin_arg < 1000000) {
-			cmd->scan_begin_arg = 1000000;
-			err++;
-		}
-	}
 	/* not used now, is for later use */
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < 125000) {
-			cmd->convert_arg = 125000;
-			err++;
-		}
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 125000);
 
-	/* the same argument */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
 	} else {
 		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
-	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: err=%d, "
-		"scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, "
-		"convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src,
-		cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
-
 	if (err)
 		return 3;
 

commit 807e65b0a818cd9b1604144af379bcabd24d4b85
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:03 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_usb
    
    Change the usbdux, usbduxfast and usbduxsigma drivers to use the new
    `auto_attach()` method instead of the `attach_usb()` method.  I plan to
    remove the `attach_usb()` and `attach_pci()` methods from `struct
    comedi_driver` once nothing is using them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b1694121f845..972017069e5e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2359,9 +2359,10 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxsigma_attach_usb(struct comedi_device *dev,
-				  struct usb_interface *uinterf)
+static int usbduxsigma_auto_attach(struct comedi_device *dev,
+				   unsigned long context_unused)
 {
+	struct usb_interface *uinterf = comedi_to_usb_interface(dev);
 	int ret;
 	struct usbduxsub *uds;
 
@@ -2370,11 +2371,11 @@ static int usbduxsigma_attach_usb(struct comedi_device *dev,
 	uds = usb_get_intfdata(uinterf);
 	if (!uds || !uds->probed) {
 		dev_err(dev->class_dev,
-			"usbduxsigma: error: attach_usb failed, not connected\n");
+			"usbduxsigma: error: auto_attach failed, not connected\n");
 		ret = -ENODEV;
 	} else if (uds->attached) {
 		dev_err(dev->class_dev,
-		       "usbduxsigma: error: attach_usb failed, already attached\n");
+		       "usbduxsigma: error: auto_attach failed, already attached\n");
 		ret = -ENODEV;
 	} else
 		ret = usbduxsigma_attach_common(dev, uds);
@@ -2398,7 +2399,7 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 static struct comedi_driver usbduxsigma_driver = {
 	.driver_name	= "usbduxsigma",
 	.module		= THIS_MODULE,
-	.attach_usb	= usbduxsigma_attach_usb,
+	.auto_attach	= usbduxsigma_auto_attach,
 	.detach		= usbduxsigma_detach,
 };
 

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index b4ab83f1215f..b1694121f845 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -897,9 +897,9 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	int err = 0, tmp, i;
-	unsigned int tmpTimer;
 	struct usbduxsub *this_usbduxsub = dev->private;
+	int err = 0, i;
+	unsigned int tmpTimer;
 
 	if (!(this_usbduxsub->probed))
 		return -ENODEV;
@@ -907,51 +907,23 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
 
-	/* make sure triggers are valid */
-	/* Only immediate triggers are allowed */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	/* trigger should happen timed */
-	tmp = cmd->scan_begin_src;
-	/* start a new _scan_ with a timer */
-	cmd->scan_begin_src &= TRIG_TIMER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	/* scanning is continuous */
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	/* issue a trigger when scan is finished and start a new scan */
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	/* trigger at the end of count events or not, stop condition or not */
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique and mutually compatible
-	 * note that mutual compatibility is not an issue here
-	 */
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_TIMER)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -1558,8 +1530,9 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	int err = 0, tmp;
 	struct usbduxsub *this_usbduxsub = dev->private;
+	int err = 0;
+	unsigned int flags;
 
 	if (!this_usbduxsub)
 		return -EFAULT;
@@ -1570,63 +1543,35 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
 
-	/* make sure triggers are valid */
-	/* Only immediate triggers are allowed */
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
+
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
 
-	/* trigger should happen timed */
-	tmp = cmd->scan_begin_src;
-	/* just now we scan also in the high speed mode every frame */
-	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* start immediately a new scan */
-		/* the sampling rate is set by the coversion rate */
-		cmd->scan_begin_src &= TRIG_FOLLOW;
+		/*
+		 * start immediately a new scan
+		 * the sampling rate is set by the coversion rate
+		 */
+		flags = TRIG_FOLLOW;
 	} else {
 		/* start a new scan (output at once) with a timer */
-		cmd->scan_begin_src &= TRIG_TIMER;
+		flags = TRIG_TIMER;
 	}
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	/* scanning is continuous */
-	tmp = cmd->convert_src;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, flags);
 
-	/* all conversion events happen simultaneously */
-	cmd->convert_src &= TRIG_NOW;
-
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	/* issue a trigger when scan is finished and start a new scan */
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	/* trigger at the end of count events or not, stop condition or not */
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources
-	 * are unique and mutually compatible
-	 * note that mutual compatibility is not an issue here
-	 */
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_TIMER)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 453443f32fd8d5fb3da702aa02901297dd4ad51f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 16:20:38 2012 -0700

    staging: comedi: usbduxsigma: remove usbduxsigma_attach
    
    This driver originally used the 'attach' method in order to get
    the firmware for the device from the comedi_config utility. It
    now uses request_firmware_nowait() in the usb_driver probe to
    get this firmware.
    
    Since this driver has an 'attach_usb' method in the comedi_driver,
    the 'attach' method can be removed because it is now optional.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 034f5dfc05f8..b4ab83f1215f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2301,10 +2301,8 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
-/* common part of attach and attach_usb */
 static int usbduxsigma_attach_common(struct comedi_device *dev,
-				     struct usbduxsub *uds,
-				     void *aux_data, int aux_len)
+				     struct usbduxsub *uds)
 {
 	int ret;
 	struct comedi_subdevice *s;
@@ -2314,9 +2312,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	down(&uds->sem);
 	/* pointer back to the corresponding comedi device */
 	uds->comedidev = dev;
-	/* trying to upload the firmware into the FX2 */
-	if (aux_data)
-		firmwareUpload(uds, aux_data, aux_len);
 	dev->board_name = "usbduxsigma";
 	/* set number of subdevices */
 	if (uds->high_speed)
@@ -2419,47 +2414,6 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	return 0;
 }
 
-/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
-static int usbduxsigma_attach(struct comedi_device *dev,
-			      struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
-	if (index < 0) {
-		dev_err(dev->class_dev,
-			"usbduxsigma: error: attach failed, dev not connected to the usb bus.\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxsigma_attach_common(dev, &usbduxsub[index],
-						aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
 static int usbduxsigma_attach_usb(struct comedi_device *dev,
 				  struct usb_interface *uinterf)
 {
@@ -2478,7 +2432,7 @@ static int usbduxsigma_attach_usb(struct comedi_device *dev,
 		       "usbduxsigma: error: attach_usb failed, already attached\n");
 		ret = -ENODEV;
 	} else
-		ret = usbduxsigma_attach_common(dev, uds, NULL, 0);
+		ret = usbduxsigma_attach_common(dev, uds);
 	up(&start_stop_sem);
 	return ret;
 }
@@ -2499,9 +2453,8 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 static struct comedi_driver usbduxsigma_driver = {
 	.driver_name	= "usbduxsigma",
 	.module		= THIS_MODULE,
-	.attach		= usbduxsigma_attach,
-	.detach		= usbduxsigma_detach,
 	.attach_usb	= usbduxsigma_attach_usb,
+	.detach		= usbduxsigma_detach,
 };
 
 static void usbdux_firmware_request_complete_handler(const struct firmware *fw,

commit ae4498216be8ed2ecd1508a72458a01e6976185a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:58:51 2012 -0700

    staging: comedi: usbduxsigma: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f54ab8c2fcfd..034f5dfc05f8 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -356,7 +356,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 	/* subdevice which is the AD converter */
-	s = this_comedidev->subdevices + SUBDEV_AD;
+	s = &this_comedidev->subdevices[SUBDEV_AD];
 
 	/* first we test if something unusual has just happened */
 	switch (urb->status) {
@@ -558,7 +558,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
-	s = this_comedidev->subdevices + SUBDEV_DA;
+	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -1950,7 +1950,7 @@ static void usbduxsub_pwm_irq(struct urb *urb)
 	/* the private structure of the subdevice is struct usbduxsub */
 	this_usbduxsub = this_comedidev->private;
 
-	s = this_comedidev->subdevices + SUBDEV_DA;
+	s = &this_comedidev->subdevices[SUBDEV_DA];
 
 	switch (urb->status) {
 	case 0:
@@ -2331,7 +2331,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	/* private structure is also simply the usb-structure */
 	dev->private = uds;
 	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
+	s = &dev->subdevices[SUBDEV_AD];
 	/* the URBs get the comedi subdevice */
 	/* which is responsible for reading */
 	/* this is the subdevice which reads data */
@@ -2358,7 +2358,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	/* range table to convert to physical units */
 	s->range_table = (&range_usbdux_ai_range);
 	/* analog output subdevice */
-	s = dev->subdevices + SUBDEV_DA;
+	s = &dev->subdevices[SUBDEV_DA];
 	/* analog out */
 	s->type = COMEDI_SUBD_AO;
 	/* backward pointer */
@@ -2383,7 +2383,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	s->insn_read = usbdux_ao_insn_read;
 	s->insn_write = usbdux_ao_insn_write;
 	/* digital I/O subdevice */
-	s = dev->subdevices + SUBDEV_DIO;
+	s = &dev->subdevices[SUBDEV_DIO];
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 	/* 8 external and 16 internal channels */
@@ -2396,7 +2396,7 @@ static int usbduxsigma_attach_common(struct comedi_device *dev,
 	s->private = NULL;
 	if (uds->high_speed) {
 		/* timer / pwm subdevice */
-		s = dev->subdevices + SUBDEV_PWM;
+		s = &dev->subdevices[SUBDEV_PWM];
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;

commit a1d95cfc07d637e024027101a691dad5b0eef27a
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Thu Aug 16 11:19:11 2012 -0600

    staging: comedi: usbduxsigma: Declare MODULE_FIRMWARE usage
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Bernd Porr <berndporr@f2s.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 543e604791e2..f54ab8c2fcfd 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -63,6 +63,7 @@ Status: testing
 #define BULK_TIMEOUT 1000
 
 /* constants for "firmware" upload and download */
+#define FIRMWARE "usbduxsigma_firmware.bin"
 #define USBDUXSUB_FIRMWARE 0xA0
 #define VENDOR_DIR_IN  0xC0
 #define VENDOR_DIR_OUT 0x40
@@ -2780,7 +2781,7 @@ static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
 
 	ret = request_firmware_nowait(THIS_MODULE,
 				      FW_ACTION_HOTPLUG,
-				      "usbduxsigma_firmware.bin",
+				      FIRMWARE,
 				      &udev->dev,
 				      GFP_KERNEL,
 				      usbduxsub + index,
@@ -2845,3 +2846,4 @@ module_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);
 MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
 MODULE_DESCRIPTION("Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(FIRMWARE);

commit 933045a221acab3b17f4e6e5c1c12d6bf87d68ec
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 22 10:14:59 2012 +0300

    staging: comedi: double unlock in usbduxsigma_attach()
    
    There was a double unlock introduced in 60ff461067 ("staging: comedi:
    usbduxsigma: use attach_usb() hook").
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 8da8c1cbb60a..543e604791e2 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2450,7 +2450,6 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	if (index < 0) {
 		dev_err(dev->class_dev,
 			"usbduxsigma: error: attach failed, dev not connected to the usb bus.\n");
-		up(&start_stop_sem);
 		ret = -ENODEV;
 	} else
 		ret = usbduxsigma_attach_common(dev, &usbduxsub[index],

commit ab5455ae2d920b227afbf2f870f3253fc699b132
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:02:15 2012 -0700

    staging: comedi: usbduxsigma: refactor init code
    
    Refactor the usb driver probe/disconnect and comedi driver attach/
    detach to follow the style of the other comedi driver types to
    improve maintainability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e4308823cf68..8da8c1cbb60a 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,6 +1,3 @@
-#define DRIVER_VERSION "v0.6"
-#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
-#define DRIVER_DESC "Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com"
 /*
    comedi/drivers/usbdux.c
    Copyright (C) 2011 Bernd Porr, Bernd.Porr@f2s.com
@@ -62,8 +59,6 @@ Status: testing
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
-#define BOARDNAME "usbduxsigma"
-
 /* timeout for the USB-transfer in ms*/
 #define BULK_TIMEOUT 1000
 
@@ -267,8 +262,6 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver usbduxsigma_driver;	/* see below for initializer */
-
 /*
  * Stops the data acquision
  * It should be safe to call this function from any context
@@ -2307,6 +2300,210 @@ static void tidy_up(struct usbduxsub *usbduxsub_tmp)
 	usbduxsub_tmp->pwm_cmd_running = 0;
 }
 
+/* common part of attach and attach_usb */
+static int usbduxsigma_attach_common(struct comedi_device *dev,
+				     struct usbduxsub *uds,
+				     void *aux_data, int aux_len)
+{
+	int ret;
+	struct comedi_subdevice *s;
+	int n_subdevs;
+	int offset;
+
+	down(&uds->sem);
+	/* pointer back to the corresponding comedi device */
+	uds->comedidev = dev;
+	/* trying to upload the firmware into the FX2 */
+	if (aux_data)
+		firmwareUpload(uds, aux_data, aux_len);
+	dev->board_name = "usbduxsigma";
+	/* set number of subdevices */
+	if (uds->high_speed)
+		n_subdevs = 4;	/* with pwm */
+	else
+		n_subdevs = 3;	/* without pwm */
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
+	if (ret) {
+		up(&uds->sem);
+		return ret;
+	}
+	/* private structure is also simply the usb-structure */
+	dev->private = uds;
+	/* the first subdevice is the A/D converter */
+	s = dev->subdevices + SUBDEV_AD;
+	/* the URBs get the comedi subdevice */
+	/* which is responsible for reading */
+	/* this is the subdevice which reads data */
+	dev->read_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* analog input */
+	s->type = COMEDI_SUBD_AI;
+	/* readable and ref is to ground, 32 bit wide data! */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND |
+		SDF_CMD_READ | SDF_LSAMPL;
+	/* 16 A/D channels */
+	s->n_chan = NUMCHANNELS;
+	/* length of the channellist */
+	s->len_chanlist = NUMCHANNELS;
+	/* callback functions */
+	s->insn_read = usbdux_ai_insn_read;
+	s->do_cmdtest = usbdux_ai_cmdtest;
+	s->do_cmd = usbdux_ai_cmd;
+	s->cancel = usbdux_ai_cancel;
+	/* max value from the A/D converter (24bit) */
+	s->maxdata = 0x00FFFFFF;
+	/* range table to convert to physical units */
+	s->range_table = (&range_usbdux_ai_range);
+	/* analog output subdevice */
+	s = dev->subdevices + SUBDEV_DA;
+	/* analog out */
+	s->type = COMEDI_SUBD_AO;
+	/* backward pointer */
+	dev->write_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* are writable */
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	/* 4 channels */
+	s->n_chan = 4;
+	/* length of the channellist */
+	s->len_chanlist = 4;
+	/* 8 bit resolution */
+	s->maxdata = 0x00ff;
+	/* unipolar range */
+	s->range_table = (&range_usbdux_ao_range);
+	/* callback */
+	s->do_cmdtest = usbdux_ao_cmdtest;
+	s->do_cmd = usbdux_ao_cmd;
+	s->cancel = usbdux_ao_cancel;
+	s->insn_read = usbdux_ao_insn_read;
+	s->insn_write = usbdux_ao_insn_write;
+	/* digital I/O subdevice */
+	s = dev->subdevices + SUBDEV_DIO;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	/* 8 external and 16 internal channels */
+	s->n_chan = 24;
+	s->maxdata = 1;
+	s->range_table = (&range_digital);
+	s->insn_bits = usbdux_dio_insn_bits;
+	s->insn_config = usbdux_dio_insn_config;
+	/* we don't use it */
+	s->private = NULL;
+	if (uds->high_speed) {
+		/* timer / pwm subdevice */
+		s = dev->subdevices + SUBDEV_PWM;
+		s->type = COMEDI_SUBD_PWM;
+		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan = 8;
+		/* this defines the max duty cycle resolution */
+		s->maxdata = uds->sizePwmBuf;
+		s->insn_write = usbdux_pwm_write;
+		s->insn_read = usbdux_pwm_read;
+		s->insn_config = usbdux_pwm_config;
+		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+	/* finally decide that it's attached */
+	uds->attached = 1;
+	up(&uds->sem);
+	offset = usbdux_getstatusinfo(dev, 0);
+	if (offset < 0)
+		dev_err(&uds->interface->dev,
+			"Communication to USBDUXSIGMA failed! Check firmware and cabling.");
+	dev_info(&uds->interface->dev,
+		 "comedi%d: attached, ADC_zero = %x\n", dev->minor, offset);
+	return 0;
+}
+
+/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
+static int usbduxsigma_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
+
+	dev->private = NULL;
+
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
+
+	down(&start_stop_sem);
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+	if (index < 0) {
+		dev_err(dev->class_dev,
+			"usbduxsigma: error: attach failed, dev not connected to the usb bus.\n");
+		up(&start_stop_sem);
+		ret = -ENODEV;
+	} else
+		ret = usbduxsigma_attach_common(dev, &usbduxsub[index],
+						aux_data, aux_len);
+	up(&start_stop_sem);
+	return ret;
+}
+
+/* is called from comedi_usb_auto_config() */
+static int usbduxsigma_attach_usb(struct comedi_device *dev,
+				  struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxsub *uds;
+
+	dev->private = NULL;
+	down(&start_stop_sem);
+	uds = usb_get_intfdata(uinterf);
+	if (!uds || !uds->probed) {
+		dev_err(dev->class_dev,
+			"usbduxsigma: error: attach_usb failed, not connected\n");
+		ret = -ENODEV;
+	} else if (uds->attached) {
+		dev_err(dev->class_dev,
+		       "usbduxsigma: error: attach_usb failed, already attached\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxsigma_attach_common(dev, uds, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
+}
+
+static void usbduxsigma_detach(struct comedi_device *dev)
+{
+	struct usbduxsub *usb = dev->private;
+
+	if (usb) {
+		down(&usb->sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&usb->sem);
+	}
+}
+
+static struct comedi_driver usbduxsigma_driver = {
+	.driver_name	= "usbduxsigma",
+	.module		= THIS_MODULE,
+	.attach		= usbduxsigma_attach,
+	.detach		= usbduxsigma_detach,
+	.attach_usb	= usbduxsigma_attach_usb,
+};
+
 static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 						     void *context)
 {
@@ -2336,9 +2533,8 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	release_firmware(fw);
 }
 
-/* allocate memory for the urbs and initialise them */
-static int usbduxsigma_probe(struct usb_interface *uinterf,
-			   const struct usb_device_id *id)
+static int usbduxsigma_usb_probe(struct usb_interface *uinterf,
+				 const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(uinterf);
 	struct device *dev = &uinterf->dev;
@@ -2602,7 +2798,7 @@ static int usbduxsigma_probe(struct usb_interface *uinterf,
 	return 0;
 }
 
-static void usbduxsigma_disconnect(struct usb_interface *intf)
+static void usbduxsigma_usb_disconnect(struct usb_interface *intf)
 {
 	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
@@ -2631,230 +2827,22 @@ static void usbduxsigma_disconnect(struct usb_interface *intf)
 	dev_info(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
-/* common part of attach and attach_usb */
-static int usbduxsigma_attach_common(struct comedi_device *dev,
-				     struct usbduxsub *uds,
-				     void *aux_data, int aux_len)
-{
-	int ret;
-	struct comedi_subdevice *s;
-	int n_subdevs;
-	int offset;
-
-	down(&uds->sem);
-	/* pointer back to the corresponding comedi device */
-	uds->comedidev = dev;
-	/* trying to upload the firmware into the FX2 */
-	if (aux_data)
-		firmwareUpload(uds, aux_data, aux_len);
-	dev->board_name = BOARDNAME;
-	/* set number of subdevices */
-	if (uds->high_speed)
-		n_subdevs = 4;	/* with pwm */
-	else
-		n_subdevs = 3;	/* without pwm */
-	ret = comedi_alloc_subdevices(dev, n_subdevs);
-	if (ret) {
-		up(&uds->sem);
-		return ret;
-	}
-	/* private structure is also simply the usb-structure */
-	dev->private = uds;
-	/* the first subdevice is the A/D converter */
-	s = dev->subdevices + SUBDEV_AD;
-	/* the URBs get the comedi subdevice */
-	/* which is responsible for reading */
-	/* this is the subdevice which reads data */
-	dev->read_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* analog input */
-	s->type = COMEDI_SUBD_AI;
-	/* readable and ref is to ground, 32 bit wide data! */
-	s->subdev_flags = SDF_READABLE | SDF_GROUND |
-		SDF_CMD_READ | SDF_LSAMPL;
-	/* 16 A/D channels */
-	s->n_chan = NUMCHANNELS;
-	/* length of the channellist */
-	s->len_chanlist = NUMCHANNELS;
-	/* callback functions */
-	s->insn_read = usbdux_ai_insn_read;
-	s->do_cmdtest = usbdux_ai_cmdtest;
-	s->do_cmd = usbdux_ai_cmd;
-	s->cancel = usbdux_ai_cancel;
-	/* max value from the A/D converter (24bit) */
-	s->maxdata = 0x00FFFFFF;
-	/* range table to convert to physical units */
-	s->range_table = (&range_usbdux_ai_range);
-	/* analog output subdevice */
-	s = dev->subdevices + SUBDEV_DA;
-	/* analog out */
-	s->type = COMEDI_SUBD_AO;
-	/* backward pointer */
-	dev->write_subdev = s;
-	/* the subdevice receives as private structure the */
-	/* usb-structure */
-	s->private = NULL;
-	/* are writable */
-	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
-	/* 4 channels */
-	s->n_chan = 4;
-	/* length of the channellist */
-	s->len_chanlist = 4;
-	/* 8 bit resolution */
-	s->maxdata = 0x00ff;
-	/* unipolar range */
-	s->range_table = (&range_usbdux_ao_range);
-	/* callback */
-	s->do_cmdtest = usbdux_ao_cmdtest;
-	s->do_cmd = usbdux_ao_cmd;
-	s->cancel = usbdux_ao_cancel;
-	s->insn_read = usbdux_ao_insn_read;
-	s->insn_write = usbdux_ao_insn_write;
-	/* digital I/O subdevice */
-	s = dev->subdevices + SUBDEV_DIO;
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	/* 8 external and 16 internal channels */
-	s->n_chan = 24;
-	s->maxdata = 1;
-	s->range_table = (&range_digital);
-	s->insn_bits = usbdux_dio_insn_bits;
-	s->insn_config = usbdux_dio_insn_config;
-	/* we don't use it */
-	s->private = NULL;
-	if (uds->high_speed) {
-		/* timer / pwm subdevice */
-		s = dev->subdevices + SUBDEV_PWM;
-		s->type = COMEDI_SUBD_PWM;
-		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
-		s->n_chan = 8;
-		/* this defines the max duty cycle resolution */
-		s->maxdata = uds->sizePwmBuf;
-		s->insn_write = usbdux_pwm_write;
-		s->insn_read = usbdux_pwm_read;
-		s->insn_config = usbdux_pwm_config;
-		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
-	}
-	/* finally decide that it's attached */
-	uds->attached = 1;
-	up(&uds->sem);
-	offset = usbdux_getstatusinfo(dev, 0);
-	if (offset < 0)
-		dev_err(&uds->interface->dev,
-			"Communication to USBDUXSIGMA failed! Check firmware and cabling.");
-	dev_info(&uds->interface->dev,
-		 "comedi%d: attached, ADC_zero = %x\n", dev->minor, offset);
-	return 0;
-}
-
-/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
-static int usbduxsigma_attach(struct comedi_device *dev,
-			      struct comedi_devconfig *it)
-{
-	int ret;
-	int index;
-	int i;
-	void *aux_data;
-	int aux_len;
-
-	dev->private = NULL;
-
-	aux_data = comedi_aux_data(it->options, 0);
-	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
-	if (aux_data == NULL)
-		aux_len = 0;
-	else if (aux_len == 0)
-		aux_data = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
-	if (index < 0) {
-		dev_err(dev->class_dev,
-			"usbduxsigma: error: attach failed, dev not connected to the usb bus.\n");
-		up(&start_stop_sem);
-		ret = -ENODEV;
-	} else
-		ret = usbduxsigma_attach_common(dev, &usbduxsub[index],
-						aux_data, aux_len);
-	up(&start_stop_sem);
-	return ret;
-}
-
-/* is called from comedi_usb_auto_config() */
-static int usbduxsigma_attach_usb(struct comedi_device *dev,
-				  struct usb_interface *uinterf)
-{
-	int ret;
-	struct usbduxsub *uds;
-
-	dev->private = NULL;
-	down(&start_stop_sem);
-	uds = usb_get_intfdata(uinterf);
-	if (!uds || !uds->probed) {
-		dev_err(dev->class_dev,
-			"usbduxsigma: error: attach_usb failed, not connected\n");
-		ret = -ENODEV;
-	} else if (uds->attached) {
-		dev_err(dev->class_dev,
-		       "usbduxsigma: error: attach_usb failed, already attached\n");
-		ret = -ENODEV;
-	} else
-		ret = usbduxsigma_attach_common(dev, uds, NULL, 0);
-	up(&start_stop_sem);
-	return ret;
-}
-
-static void usbduxsigma_detach(struct comedi_device *dev)
-{
-	struct usbduxsub *usb = dev->private;
-
-	if (usb) {
-		down(&usb->sem);
-		dev->private = NULL;
-		usb->attached = 0;
-		usb->comedidev = NULL;
-		up(&usb->sem);
-	}
-}
-
-/* main driver struct */
-static struct comedi_driver usbduxsigma_driver = {
-	.driver_name	= "usbduxsigma",
-	.module		= THIS_MODULE,
-	.attach		= usbduxsigma_attach,
-	.detach		= usbduxsigma_detach,
-	.attach_usb	= usbduxsigma_attach_usb,
+static const struct usb_device_id usbduxsigma_usb_table[] = {
+	{ USB_DEVICE(0x13d8, 0x0020) },
+	{ USB_DEVICE(0x13d8, 0x0021) },
+	{ USB_DEVICE(0x13d8, 0x0022) },
+	{ }
 };
+MODULE_DEVICE_TABLE(usb, usbduxsigma_usb_table);
 
-/* Table with the USB-devices */
-static const struct usb_device_id usbduxsigma_table[] = {
-	{USB_DEVICE(0x13d8, 0x0020)},
-	{USB_DEVICE(0x13d8, 0x0021)},
-	{USB_DEVICE(0x13d8, 0x0022)},
-	{}			/* Terminating entry */
-};
-
-MODULE_DEVICE_TABLE(usb, usbduxsigma_table);
-
-/* The usbduxsub-driver */
 static struct usb_driver usbduxsigma_usb_driver = {
-	.name		= BOARDNAME,
-	.probe		= usbduxsigma_probe,
-	.disconnect	= usbduxsigma_disconnect,
-	.id_table	= usbduxsigma_table,
+	.name		= "usbduxsigma",
+	.probe		= usbduxsigma_usb_probe,
+	.disconnect	= usbduxsigma_usb_disconnect,
+	.id_table	= usbduxsigma_usb_table,
 };
 module_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);
 
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
+MODULE_DESCRIPTION("Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com");
 MODULE_LICENSE("GPL");

commit b7418f4524a830747a16f41b728075dca6e2cca3
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 20 12:01:27 2012 -0700

    staging: comedi: usbduxsigma: use module_comedi_usb_driver()
    
    Use the module_comedi_usb_driver helper macro to initialize this
    module. Rename the driver structs to follow the pattern of the
    other comedi driver types and add some whitespace to improve
    readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 28f41e9cf682..e4308823cf68 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -267,7 +267,7 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
-static struct comedi_driver driver_usbduxsigma;	/* see below for initializer */
+static struct comedi_driver usbduxsigma_driver;	/* see below for initializer */
 
 /*
  * Stops the data acquision
@@ -2331,7 +2331,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(uinterf, &driver_usbduxsigma);
+	comedi_usb_auto_config(uinterf, &usbduxsigma_driver);
 out:
 	release_firmware(fw);
 }
@@ -2828,12 +2828,12 @@ static void usbduxsigma_detach(struct comedi_device *dev)
 }
 
 /* main driver struct */
-static struct comedi_driver driver_usbduxsigma = {
-	.driver_name = "usbduxsigma",
-	.module = THIS_MODULE,
-	.attach = usbduxsigma_attach,
-	.detach = usbduxsigma_detach,
-	.attach_usb = usbduxsigma_attach_usb,
+static struct comedi_driver usbduxsigma_driver = {
+	.driver_name	= "usbduxsigma",
+	.module		= THIS_MODULE,
+	.attach		= usbduxsigma_attach,
+	.detach		= usbduxsigma_detach,
+	.attach_usb	= usbduxsigma_attach_usb,
 };
 
 /* Table with the USB-devices */
@@ -2847,34 +2847,13 @@ static const struct usb_device_id usbduxsigma_table[] = {
 MODULE_DEVICE_TABLE(usb, usbduxsigma_table);
 
 /* The usbduxsub-driver */
-static struct usb_driver usbduxsigma_driver = {
-	.name = BOARDNAME,
-	.probe = usbduxsigma_probe,
-	.disconnect = usbduxsigma_disconnect,
-	.id_table = usbduxsigma_table,
+static struct usb_driver usbduxsigma_usb_driver = {
+	.name		= BOARDNAME,
+	.probe		= usbduxsigma_probe,
+	.disconnect	= usbduxsigma_disconnect,
+	.id_table	= usbduxsigma_table,
 };
-
-/* Can't use the nice macro as I have also to initialise the USB */
-/* subsystem: */
-/* registering the usb-system _and_ the comedi-driver */
-static int __init init_usbduxsigma(void)
-{
-	printk(KERN_INFO KBUILD_MODNAME ": "
-	       DRIVER_VERSION ":" DRIVER_DESC "\n");
-	usb_register(&usbduxsigma_driver);
-	comedi_driver_register(&driver_usbduxsigma);
-	return 0;
-}
-
-/* deregistering the comedi driver and the usb-subsystem */
-static void __exit exit_usbduxsigma(void)
-{
-	comedi_driver_unregister(&driver_usbduxsigma);
-	usb_deregister(&usbduxsigma_driver);
-}
-
-module_init(init_usbduxsigma);
-module_exit(exit_usbduxsigma);
+module_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a93cc5df2093..28f41e9cf682 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1884,7 +1884,7 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	s->state = data[1];
 
 	up(&this_usbduxsub->sem);
-	return 2;
+	return insn->n;
 }
 
 /***********************************/

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 699deb16fa38..a93cc5df2093 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1845,9 +1845,6 @@ static int usbdux_dio_insn_bits(struct comedi_device *dev,
 	if (!this_usbduxsub)
 		return -EFAULT;
 
-	if (insn->n != 2)
-		return -EINVAL;
-
 	down(&this_usbduxsub->sem);
 
 	if (!(this_usbduxsub->probed)) {

commit 60ff46106744220506841c45f82576b9b56cf22e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 16:35:54 2012 +0100

    staging: comedi: usbduxsigma: use attach_usb() hook
    
    Change the usbduxsigma driver to use the new attach_usb() hook in struct
    comedi_driver to auto-configure probed USB devices after the firmware is
    loaded.
    
    Move the release of the driver's static 'start_stop_sem' semaphore in
    usbduxsigma_attach() to occur a bit later for convenience, otherwise the
    new usbduxsigma_attach_common() would need to be split in two.  I don't
    think the slight delay in releasing the semaphore matters too much; it's
    only used in the USB probe and disconnect functions and when attaching
    and detaching comedi devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 502a40948ebd..699deb16fa38 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2634,72 +2634,35 @@ static void usbduxsigma_disconnect(struct usb_interface *intf)
 	dev_info(&intf->dev, "comedi_: disconnected from the usb\n");
 }
 
-/* is called when comedi-config is called */
-static int usbduxsigma_attach(struct comedi_device *dev,
-			      struct comedi_devconfig *it)
+/* common part of attach and attach_usb */
+static int usbduxsigma_attach_common(struct comedi_device *dev,
+				     struct usbduxsub *uds,
+				     void *aux_data, int aux_len)
 {
 	int ret;
-	int index;
-	int i;
-	struct usbduxsub *udev;
+	struct comedi_subdevice *s;
 	int n_subdevs;
-
 	int offset;
 
-	struct comedi_subdevice *s = NULL;
-	dev->private = NULL;
-
-	down(&start_stop_sem);
-	/* find a valid device which has been detected by the probe function of
-	 * the usb */
-	index = -1;
-	for (i = 0; i < NUMUSBDUX; i++) {
-		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
-			index = i;
-			break;
-		}
-	}
-
-	if (index < 0) {
-		printk(KERN_ERR "comedi%d: usbduxsigma: error: attach failed,"
-		       "dev not connected to the usb bus.\n", dev->minor);
-		up(&start_stop_sem);
-		return -ENODEV;
-	}
-
-	udev = &usbduxsub[index];
-	down(&udev->sem);
+	down(&uds->sem);
 	/* pointer back to the corresponding comedi device */
-	udev->comedidev = dev;
-
+	uds->comedidev = dev;
 	/* trying to upload the firmware into the FX2 */
-	if (comedi_aux_data(it->options, 0) &&
-	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
-		firmwareUpload(udev, comedi_aux_data(it->options, 0),
-			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
-	}
-
+	if (aux_data)
+		firmwareUpload(uds, aux_data, aux_len);
 	dev->board_name = BOARDNAME;
-
 	/* set number of subdevices */
-	if (udev->high_speed) {
-		/* with pwm */
-		n_subdevs = 4;
-	} else {
-		/* without pwm */
-		n_subdevs = 3;
-	}
-
+	if (uds->high_speed)
+		n_subdevs = 4;	/* with pwm */
+	else
+		n_subdevs = 3;	/* without pwm */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret) {
-		up(&udev->sem);
-		up(&start_stop_sem);
+		up(&uds->sem);
 		return ret;
 	}
-
 	/* private structure is also simply the usb-structure */
-	dev->private = udev;
-
+	dev->private = uds;
 	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
 	/* the URBs get the comedi subdevice */
@@ -2727,8 +2690,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	s->maxdata = 0x00FFFFFF;
 	/* range table to convert to physical units */
 	s->range_table = (&range_usbdux_ai_range);
-
-	/* analog out */
+	/* analog output subdevice */
 	s = dev->subdevices + SUBDEV_DA;
 	/* analog out */
 	s->type = COMEDI_SUBD_AO;
@@ -2753,8 +2715,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	s->cancel = usbdux_ao_cancel;
 	s->insn_read = usbdux_ao_insn_read;
 	s->insn_write = usbdux_ao_insn_write;
-
-	/* digital I/O */
+	/* digital I/O subdevice */
 	s = dev->subdevices + SUBDEV_DIO;
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
@@ -2766,37 +2727,94 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	s->insn_config = usbdux_dio_insn_config;
 	/* we don't use it */
 	s->private = NULL;
-
-	if (udev->high_speed) {
-		/* timer / pwm */
+	if (uds->high_speed) {
+		/* timer / pwm subdevice */
 		s = dev->subdevices + SUBDEV_PWM;
 		s->type = COMEDI_SUBD_PWM;
 		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
 		s->n_chan = 8;
 		/* this defines the max duty cycle resolution */
-		s->maxdata = udev->sizePwmBuf;
+		s->maxdata = uds->sizePwmBuf;
 		s->insn_write = usbdux_pwm_write;
 		s->insn_read = usbdux_pwm_read;
 		s->insn_config = usbdux_pwm_config;
 		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
 	}
 	/* finally decide that it's attached */
-	udev->attached = 1;
+	uds->attached = 1;
+	up(&uds->sem);
+	offset = usbdux_getstatusinfo(dev, 0);
+	if (offset < 0)
+		dev_err(&uds->interface->dev,
+			"Communication to USBDUXSIGMA failed! Check firmware and cabling.");
+	dev_info(&uds->interface->dev,
+		 "comedi%d: attached, ADC_zero = %x\n", dev->minor, offset);
+	return 0;
+}
 
-	up(&udev->sem);
+/* is called for COMEDI_DEVCONFIG ioctl (when comedi_config is run) */
+static int usbduxsigma_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	void *aux_data;
+	int aux_len;
 
-	up(&start_stop_sem);
+	dev->private = NULL;
 
-	offset = usbdux_getstatusinfo(dev, 0);
-	if (offset < 0)
-		dev_err(&udev->interface->dev,
-			"Communication to USBDUXSIGMA failed!"
-			"Check firmware and cabling.");
+	aux_data = comedi_aux_data(it->options, 0);
+	aux_len = it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH];
+	if (aux_data == NULL)
+		aux_len = 0;
+	else if (aux_len == 0)
+		aux_data = NULL;
 
-	dev_info(&udev->interface->dev,
-		 "comedi%d: attached, ADC_zero = %x", dev->minor, offset);
+	down(&start_stop_sem);
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+	if (index < 0) {
+		dev_err(dev->class_dev,
+			"usbduxsigma: error: attach failed, dev not connected to the usb bus.\n");
+		up(&start_stop_sem);
+		ret = -ENODEV;
+	} else
+		ret = usbduxsigma_attach_common(dev, &usbduxsub[index],
+						aux_data, aux_len);
+	up(&start_stop_sem);
+	return ret;
+}
 
-	return 0;
+/* is called from comedi_usb_auto_config() */
+static int usbduxsigma_attach_usb(struct comedi_device *dev,
+				  struct usb_interface *uinterf)
+{
+	int ret;
+	struct usbduxsub *uds;
+
+	dev->private = NULL;
+	down(&start_stop_sem);
+	uds = usb_get_intfdata(uinterf);
+	if (!uds || !uds->probed) {
+		dev_err(dev->class_dev,
+			"usbduxsigma: error: attach_usb failed, not connected\n");
+		ret = -ENODEV;
+	} else if (uds->attached) {
+		dev_err(dev->class_dev,
+		       "usbduxsigma: error: attach_usb failed, already attached\n");
+		ret = -ENODEV;
+	} else
+		ret = usbduxsigma_attach_common(dev, uds, NULL, 0);
+	up(&start_stop_sem);
+	return ret;
 }
 
 static void usbduxsigma_detach(struct comedi_device *dev)
@@ -2818,6 +2836,7 @@ static struct comedi_driver driver_usbduxsigma = {
 	.module = THIS_MODULE,
 	.attach = usbduxsigma_attach,
 	.detach = usbduxsigma_detach,
+	.attach_usb = usbduxsigma_attach_usb,
 };
 
 /* Table with the USB-devices */

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f23fad957e5e..502a40948ebd 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2691,7 +2691,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	}
 
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
-	if (ret < 0) {
+	if (ret) {
 		up(&udev->sem);
 		up(&start_stop_sem);
 		return ret;

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f37e96c80b91..f23fad957e5e 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2690,7 +2690,6 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 		n_subdevs = 3;
 	}
 
-	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
 		up(&udev->sem);

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 87c613e88892..f37e96c80b91 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2693,8 +2693,6 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	/* allocate space for the subdevices */
 	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
-		dev_err(&udev->interface->dev,
-			"comedi%d: no space for subdev\n", dev->minor);
 		up(&udev->sem);
 		up(&start_stop_sem);
 		return ret;

commit fba1d0faf726b442ab8771d5e9fbaf5f5a4c624c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:27 2012 -0700

    staging: comedi: only set dev->n_subdevices when kcalloc succeedes
    
    It's possible for the kcalloc in comedi_alloc_subdevices to fail.
    Only set the dev->n_subdevices variable if the allocation is
    successful.
    
    Since the core sets dev->n_subdevices, remove all the places in the
    drivers where this variable was getting set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 00faf4ad6ffb..87c613e88892 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2642,6 +2642,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	int index;
 	int i;
 	struct usbduxsub *udev;
+	int n_subdevs;
 
 	int offset;
 
@@ -2683,14 +2684,14 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	/* set number of subdevices */
 	if (udev->high_speed) {
 		/* with pwm */
-		dev->n_subdevices = 4;
+		n_subdevs = 4;
 	} else {
 		/* without pwm */
-		dev->n_subdevices = 3;
+		n_subdevs = 3;
 	}
 
 	/* allocate space for the subdevices */
-	ret = comedi_alloc_subdevices(dev, dev->n_subdevices);
+	ret = comedi_alloc_subdevices(dev, n_subdevs);
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: no space for subdev\n", dev->minor);

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 441ccef4c110..00faf4ad6ffb 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2690,7 +2690,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	}
 
 	/* allocate space for the subdevices */
-	ret = alloc_subdevices(dev, dev->n_subdevices);
+	ret = comedi_alloc_subdevices(dev, dev->n_subdevices);
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: no space for subdev\n", dev->minor);

commit bc04bec0e0c982dfc90e206ea51f19bd650ccee2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun May 27 01:45:19 2012 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typo in comments within staging/comedi.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 465afbdf4069..441ccef4c110 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1358,7 +1358,7 @@ static int usbdux_ai_insn_read(struct comedi_device *dev,
 		/* 32 bits big endian from the A/D converter */
 		one = be32_to_cpu(*((int32_t *)
 				    ((this_usbduxsub->insnBuffer)+1)));
-		/* mask out the staus byte */
+		/* mask out the status byte */
 		one = one & 0x00ffffff;
 		/* turn it into an unsigned integer */
 		one = one ^ 0x00800000;

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f21bb0dd9167..465afbdf4069 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2801,37 +2801,17 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	return 0;
 }
 
-static int usbduxsigma_detach(struct comedi_device *dev)
+static void usbduxsigma_detach(struct comedi_device *dev)
 {
-	struct usbduxsub *usbduxsub_tmp;
+	struct usbduxsub *usb = dev->private;
 
-	if (!dev) {
-		printk(KERN_ERR
-		       "comedi? usbduxsigma detach: dev=NULL\n");
-		return -EFAULT;
-	}
-
-	usbduxsub_tmp = dev->private;
-	if (!usbduxsub_tmp) {
-		printk(KERN_ERR
-		       "comedi?: usbduxsigma detach: private=NULL\n");
-		return -EFAULT;
+	if (usb) {
+		down(&usb->sem);
+		dev->private = NULL;
+		usb->attached = 0;
+		usb->comedidev = NULL;
+		up(&usb->sem);
 	}
-
-	dev_dbg(&usbduxsub_tmp->interface->dev,
-		"comedi%d: detach usb device\n",
-		dev->minor);
-
-	down(&usbduxsub_tmp->sem);
-	/* Don't allow detach to free the private structure */
-	/* It's one entry of of usbduxsub[] */
-	dev->private = NULL;
-	usbduxsub_tmp->attached = 0;
-	usbduxsub_tmp->comedidev = NULL;
-	dev_info(&usbduxsub_tmp->interface->dev,
-		"comedi%d: successfully detached.\n", dev->minor);
-	up(&usbduxsub_tmp->sem);
-	return 0;
 }
 
 /* main driver struct */

commit d8b6ca0850c558f21989d468801ad1414b1372c4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:59 2012 +0100

    staging: comedi: pass usb interface to comedi_usb_auto_config
    
    The comedi_usb_auto_config() and comedi_usb_auto_unconfig() functions
    currently take a 'struct usb_device *'.  It makes more sense to pass a
    'struct usb_interface *' to allow for composite USB devices.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index e59d1c093095..f21bb0dd9167 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2314,11 +2314,11 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 						     void *context)
 {
 	struct usbduxsub *usbduxsub_tmp = context;
-	struct usb_device *usbdev = usbduxsub_tmp->usbdev;
+	struct usb_interface *uinterf = usbduxsub_tmp->interface;
 	int ret;
 
 	if (fw == NULL) {
-		dev_err(&usbdev->dev,
+		dev_err(&uinterf->dev,
 			"Firmware complete handler without firmware!\n");
 		return;
 	}
@@ -2330,11 +2330,11 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
 
 	if (ret) {
-		dev_err(&usbdev->dev,
+		dev_err(&uinterf->dev,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(usbdev, &driver_usbduxsigma);
+	comedi_usb_auto_config(uinterf, &driver_usbduxsigma);
 out:
 	release_firmware(fw);
 }
@@ -2625,7 +2625,7 @@ static void usbduxsigma_disconnect(struct usb_interface *intf)
 	if (usbduxsub_tmp->ao_cmd_running)
 		/* we are still running a command */
 		usbdux_ao_stop(usbduxsub_tmp, 1);
-	comedi_usb_auto_unconfig(udev);
+	comedi_usb_auto_unconfig(intf);
 	down(&start_stop_sem);
 	down(&usbduxsub_tmp->sem);
 	tidy_up(usbduxsub_tmp);

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index 63c9b6dbc317..e59d1c093095 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -267,6 +267,8 @@ static struct usbduxsub usbduxsub[NUMUSBDUX];
 
 static DEFINE_SEMAPHORE(start_stop_sem);
 
+static struct comedi_driver driver_usbduxsigma;	/* see below for initializer */
+
 /*
  * Stops the data acquision
  * It should be safe to call this function from any context
@@ -2332,7 +2334,7 @@ static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
 			"Could not upload firmware (err=%d)\n", ret);
 		goto out;
 	}
-	comedi_usb_auto_config(usbdev, BOARDNAME);
+	comedi_usb_auto_config(usbdev, &driver_usbduxsigma);
 out:
 	release_firmware(fw);
 }

commit 3ee0206b5e359aed4dd4f31834bac1d6ac657b5f
Author: Alexandru Guduleasa <alexandru.guduleasa@gmail.com>
Date:   Fri Mar 9 22:29:01 2012 +0200

    staging/comedi/drivers fix spelling errors
    
    Fix the following spelling errors:
    inital -> initial
    continous -> continuous
    aquisition -> acquisition
    aquisitions -> acquisitions
    immidiately -> immediately
    
    Signed-off-by: Alexandru Guduleasa <alexandru.guduleasa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index ca6bcf8b0231..63c9b6dbc317 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -39,7 +39,7 @@ Status: testing
  *
  *
  * Revision history:
- *   0.1: inital version
+ *   0.1: initial version
  *   0.2: all basic functions implemented, digital I/O only for one port
  *   0.3: proper vendor ID and driver name
  *   0.4: fixed D/A voltage range
@@ -235,16 +235,16 @@ struct usbduxsub {
 	short int ao_cmd_running;
 	/* pwm is running */
 	short int pwm_cmd_running;
-	/* continous aquisition */
-	short int ai_continous;
-	short int ao_continous;
+	/* continuous acquisition */
+	short int ai_continuous;
+	short int ao_continuous;
 	/* number of samples to acquire */
 	int ai_sample_count;
 	int ao_sample_count;
 	/* time between samples in units of the timer */
 	unsigned int ai_timer;
 	unsigned int ao_timer;
-	/* counter between aquisitions */
+	/* counter between acquisitions */
 	unsigned int ai_counter;
 	unsigned int ao_counter;
 	/* interval in frames/uframes */
@@ -455,8 +455,8 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
 
 	/* test, if we transmit only a fixed number of samples */
-	if (!(this_usbduxsub->ai_continous)) {
-		/* not continous, fixed number of samples */
+	if (!(this_usbduxsub->ai_continuous)) {
+		/* not continuous, fixed number of samples */
 		this_usbduxsub->ai_sample_count--;
 		/* all samples received? */
 		if (this_usbduxsub->ai_sample_count < 0) {
@@ -607,8 +607,8 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		/* timer zero */
 		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
-		/* handle non continous aquisition */
-		if (!(this_usbduxsub->ao_continous)) {
+		/* handle non continuous acquisition */
+		if (!(this_usbduxsub->ao_continuous)) {
 			/* fixed number of samples */
 			this_usbduxsub->ao_sample_count--;
 			if (this_usbduxsub->ao_sample_count < 0) {
@@ -925,7 +925,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 	cmd->convert_src &= TRIG_NOW;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -1193,7 +1193,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
 	/* first the number of channels per time step */
@@ -1261,10 +1261,10 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* data arrives as one packet */
 		this_usbduxsub->ai_sample_count = cmd->stop_arg;
-		this_usbduxsub->ai_continous = 0;
+		this_usbduxsub->ai_continuous = 0;
 	} else {
-		/* continous aquisition */
-		this_usbduxsub->ai_continous = 1;
+		/* continuous acquisition */
+		this_usbduxsub->ai_continuous = 1;
 		this_usbduxsub->ai_sample_count = 0;
 	}
 
@@ -1586,7 +1586,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	/* just now we scan also in the high speed mode every frame */
 	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* start immidiately a new scan */
+		/* start immediately a new scan */
 		/* the sampling rate is set by the coversion rate */
 		cmd->scan_begin_src &= TRIG_FOLLOW;
 	} else {
@@ -1596,7 +1596,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 
 	/* all conversion events happen simultaneously */
@@ -1710,7 +1710,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: %s\n", dev->minor, __func__);
 
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
@@ -1759,7 +1759,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continous */
+		/* not continuous */
 		/* counter */
 		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
@@ -1771,10 +1771,10 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			/* data arrives as one packet */
 			this_usbduxsub->ao_sample_count = cmd->stop_arg;
 		}
-		this_usbduxsub->ao_continous = 0;
+		this_usbduxsub->ao_continuous = 0;
 	} else {
-		/* continous aquisition */
-		this_usbduxsub->ao_continous = 1;
+		/* continuous acquisition */
+		this_usbduxsub->ao_continuous = 1;
 		this_usbduxsub->ao_sample_count = 0;
 	}
 

commit 407f3fd8faf80f77c47ebda7501c6a8698d2f3a6
Merge: dc47ce90c3a8 1d06825b0ede
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Dec 9 19:01:27 2011 -0800

    Merge 3.2-rc5 into staging-next
    
    This resolves the conflict in the
    drivers/staging/iio/industrialio-core.c file due to two different
    changes made to resolve the same problem.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 2f30866fbf0dd3b1d5ea87ebab2a96222d1cebe9
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Nov 30 11:42:58 2011 +0300

    Staging: comedi: unlock on error in usbduxsigma_attach()
    
    We should release the udev->sem lock before returning.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index f4025b60cd3f..4500b80eee6b 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -2691,6 +2691,7 @@ static int usbduxsigma_attach(struct comedi_device *dev,
 	if (ret < 0) {
 		dev_err(&udev->interface->dev,
 			"comedi%d: no space for subdev\n", dev->minor);
+		up(&udev->sem);
 		up(&start_stop_sem);
 		return ret;
 	}

commit d6610a502738e23aab5418e82c024be201e13f02
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Nov 30 11:42:21 2011 +0300

    Staging: comedi: unlock on error in usbdux_ao_inttrig()
    
    If we had an invalid trignum (anything other than zero is invalid) then
    we returned without unlocking.  I've modified this function to just have
    one return point.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a8fea9a91733..f4025b60cd3f 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1523,15 +1523,17 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 		return -EFAULT;
 
 	down(&this_usbduxsub->sem);
+
 	if (!(this_usbduxsub->probed)) {
-		up(&this_usbduxsub->sem);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto out;
 	}
 	if (trignum != 0) {
 		dev_err(&this_usbduxsub->interface->dev,
 			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
 			dev->minor);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
 	}
 	if (!(this_usbduxsub->ao_cmd_running)) {
 		this_usbduxsub->ao_cmd_running = 1;
@@ -1541,8 +1543,7 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 				"comedi%d: usbdux_ao_inttrig: submitURB: "
 				"err=%d\n", dev->minor, ret);
 			this_usbduxsub->ao_cmd_running = 0;
-			up(&this_usbduxsub->sem);
-			return ret;
+			goto out;
 		}
 		s->async->inttrig = NULL;
 	} else {
@@ -1550,8 +1551,10 @@ static int usbdux_ao_inttrig(struct comedi_device *dev,
 			"comedi%d: ao_inttrig but acqu is already running.\n",
 			dev->minor);
 	}
+	ret = 1;
+out:
 	up(&this_usbduxsub->sem);
-	return 1;
+	return ret;
 }
 
 static int usbdux_ao_cmdtest(struct comedi_device *dev,

commit 8b78607fc4a26c2e26c4a614ff0bbd3380abc402
Author: Bernd Porr <berndporr@f2s.com>
Date:   Tue Nov 8 21:21:37 2011 +0000

    staging: comedi: usbduxsigma: Fixed wrong range for the analogue channel.
    
    It's actually +/-2.65V/2 and not +/-2.65V.
    
    Signed-off-by: Bernd Porr <berndporr@f2s.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
index a8fea9a91733..6144afb8cbaa 100644
--- a/drivers/staging/comedi/drivers/usbduxsigma.c
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -1,4 +1,4 @@
-#define DRIVER_VERSION "v0.5"
+#define DRIVER_VERSION "v0.6"
 #define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
 #define DRIVER_DESC "Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com"
 /*
@@ -25,7 +25,7 @@ Driver: usbduxsigma
 Description: University of Stirling USB DAQ & INCITE Technology Limited
 Devices: [ITL] USB-DUX (usbduxsigma.o)
 Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 21 Jul 2011
+Updated: 8 Nov 2011
 Status: testing
 */
 /*
@@ -44,6 +44,7 @@ Status: testing
  *   0.3: proper vendor ID and driver name
  *   0.4: fixed D/A voltage range
  *   0.5: various bug fixes, health check at startup
+ *   0.6: corrected wrong input range
  */
 
 /* generates loads of debug info */
@@ -175,7 +176,7 @@ Status: testing
 /* comedi constants */
 static const struct comedi_lrange range_usbdux_ai_range = { 1, {
 								BIP_RANGE
-								(2.65)
+								(2.65/2.0)
 								}
 };
 

commit dd89e20d7e9d507b3122de2f79661b5fc2c2198e
Author: Bernd Porr <berndporr@f2s.com>
Date:   Sat Jul 30 11:15:02 2011 +0100

    staging: comedi: new driver usbduxsigma
    
    This adds a new driver file usbduxsigma which is the driver for
    a new board by ITL. The driver has been tested and is working fine.
    
    Signed-off-by: Bernd Porr <berndporr@f2s.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c
new file mode 100644
index 000000000000..a8fea9a91733
--- /dev/null
+++ b/drivers/staging/comedi/drivers/usbduxsigma.c
@@ -0,0 +1,2880 @@
+#define DRIVER_VERSION "v0.5"
+#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
+#define DRIVER_DESC "Stirling/ITL USB-DUX SIGMA -- Bernd.Porr@f2s.com"
+/*
+   comedi/drivers/usbdux.c
+   Copyright (C) 2011 Bernd Porr, Bernd.Porr@f2s.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+ */
+/*
+Driver: usbduxsigma
+Description: University of Stirling USB DAQ & INCITE Technology Limited
+Devices: [ITL] USB-DUX (usbduxsigma.o)
+Author: Bernd Porr <BerndPorr@f2s.com>
+Updated: 21 Jul 2011
+Status: testing
+*/
+/*
+ * I must give credit here to Chris Baugher who
+ * wrote the driver for AT-MIO-16d. I used some parts of this
+ * driver. I also must give credits to David Brownell
+ * who supported me with the USB development.
+ *
+ * Note: the raw data from the A/D converter is 24 bit big endian
+ * anything else is little endian to/from the dux board
+ *
+ *
+ * Revision history:
+ *   0.1: inital version
+ *   0.2: all basic functions implemented, digital I/O only for one port
+ *   0.3: proper vendor ID and driver name
+ *   0.4: fixed D/A voltage range
+ *   0.5: various bug fixes, health check at startup
+ */
+
+/* generates loads of debug info */
+/* #define NOISY_DUX_DEBUGBUG */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/fcntl.h>
+#include <linux/compiler.h>
+#include <linux/firmware.h>
+#include "comedi_fc.h"
+#include "../comedidev.h"
+
+#define BOARDNAME "usbduxsigma"
+
+/* timeout for the USB-transfer in ms*/
+#define BULK_TIMEOUT 1000
+
+/* constants for "firmware" upload and download */
+#define USBDUXSUB_FIRMWARE 0xA0
+#define VENDOR_DIR_IN  0xC0
+#define VENDOR_DIR_OUT 0x40
+
+/* internal addresses of the 8051 processor */
+#define USBDUXSUB_CPUCS 0xE600
+
+/*
+ * the minor device number, major is 180 only for debugging purposes and to
+ * upload special firmware (programming the eeprom etc) which is not
+ * compatible with the comedi framwork
+ */
+#define USBDUXSUB_MINOR 32
+
+/* max lenghth of the transfer-buffer for software upload */
+#define TB_LEN 0x2000
+
+/* Input endpoint number: ISO/IRQ */
+#define ISOINEP           6
+
+/* Output endpoint number: ISO/IRQ */
+#define ISOOUTEP          2
+
+/* This EP sends DUX commands to USBDUX */
+#define COMMAND_OUT_EP     1
+
+/* This EP receives the DUX commands from USBDUX */
+#define COMMAND_IN_EP        8
+
+/* Output endpoint for PWM */
+#define PWM_EP         4
+
+/* 300Hz max frequ under PWM */
+#define MIN_PWM_PERIOD  ((long)(1E9/300))
+
+/* Default PWM frequency */
+#define PWM_DEFAULT_PERIOD ((long)(1E9/100))
+
+/* Number of channels (16 AD and offset)*/
+#define NUMCHANNELS 16
+
+/* Size of one A/D value */
+#define SIZEADIN          ((sizeof(int32_t)))
+
+/*
+ * Size of the async input-buffer IN BYTES, the DIO state is transmitted
+ * as the first byte.
+ */
+#define SIZEINBUF         (((NUMCHANNELS+1)*SIZEADIN))
+
+/* 16 bytes. */
+#define SIZEINSNBUF       16
+
+/* Number of DA channels */
+#define NUMOUTCHANNELS    8
+
+/* size of one value for the D/A converter: channel and value */
+#define SIZEDAOUT          ((sizeof(uint8_t)+sizeof(int16_t)))
+
+/*
+ * Size of the output-buffer in bytes
+ * Actually only the first 4 triplets are used but for the
+ * high speed mode we need to pad it to 8 (microframes).
+ */
+#define SIZEOUTBUF         ((8*SIZEDAOUT))
+
+/*
+ * Size of the buffer for the dux commands: just now max size is determined
+ * by the analogue out + command byte + panic bytes...
+ */
+#define SIZEOFDUXBUFFER    ((8*SIZEDAOUT+2))
+
+/* Number of in-URBs which receive the data: min=2 */
+#define NUMOFINBUFFERSFULL     5
+
+/* Number of out-URBs which send the data: min=2 */
+#define NUMOFOUTBUFFERSFULL    5
+
+/* Number of in-URBs which receive the data: min=5 */
+/* must have more buffers due to buggy USB ctr */
+#define NUMOFINBUFFERSHIGH     10
+
+/* Number of out-URBs which send the data: min=5 */
+/* must have more buffers due to buggy USB ctr */
+#define NUMOFOUTBUFFERSHIGH    10
+
+/* Total number of usbdux devices */
+#define NUMUSBDUX             16
+
+/* Analogue in subdevice */
+#define SUBDEV_AD             0
+
+/* Analogue out subdevice */
+#define SUBDEV_DA             1
+
+/* Digital I/O */
+#define SUBDEV_DIO            2
+
+/* timer aka pwm output */
+#define SUBDEV_PWM            3
+
+/* number of retries to get the right dux command */
+#define RETRIES 10
+
+/**************************************************/
+/* comedi constants */
+static const struct comedi_lrange range_usbdux_ai_range = { 1, {
+								BIP_RANGE
+								(2.65)
+								}
+};
+
+static const struct comedi_lrange range_usbdux_ao_range = { 1, {
+								UNI_RANGE
+								(2.5),
+							       }
+};
+
+/*
+ * private structure of one subdevice
+ */
+
+/*
+ * This is the structure which holds all the data of
+ * this driver one sub device just now: A/D
+ */
+struct usbduxsub {
+	/* attached? */
+	int attached;
+	/* is it associated with a subdevice? */
+	int probed;
+	/* pointer to the usb-device */
+	struct usb_device *usbdev;
+	/* actual number of in-buffers */
+	int numOfInBuffers;
+	/* actual number of out-buffers */
+	int numOfOutBuffers;
+	/* ISO-transfer handling: buffers */
+	struct urb **urbIn;
+	struct urb **urbOut;
+	/* pwm-transfer handling */
+	struct urb *urbPwm;
+	/* PWM period */
+	unsigned int pwmPeriod;
+	/* PWM internal delay for the GPIF in the FX2 */
+	uint8_t pwmDelay;
+	/* size of the PWM buffer which holds the bit pattern */
+	int sizePwmBuf;
+	/* input buffer for the ISO-transfer */
+	int32_t *inBuffer;
+	/* input buffer for single insn */
+	int8_t *insnBuffer;
+	/* output buffer for single DA outputs */
+	int16_t *outBuffer;
+	/* interface number */
+	int ifnum;
+	/* interface structure in 2.6 */
+	struct usb_interface *interface;
+	/* comedi device for the interrupt context */
+	struct comedi_device *comedidev;
+	/* is it USB_SPEED_HIGH or not? */
+	short int high_speed;
+	/* asynchronous command is running */
+	short int ai_cmd_running;
+	short int ao_cmd_running;
+	/* pwm is running */
+	short int pwm_cmd_running;
+	/* continous aquisition */
+	short int ai_continous;
+	short int ao_continous;
+	/* number of samples to acquire */
+	int ai_sample_count;
+	int ao_sample_count;
+	/* time between samples in units of the timer */
+	unsigned int ai_timer;
+	unsigned int ao_timer;
+	/* counter between aquisitions */
+	unsigned int ai_counter;
+	unsigned int ao_counter;
+	/* interval in frames/uframes */
+	unsigned int ai_interval;
+	/* D/A commands */
+	uint8_t *dac_commands;
+	/* commands */
+	uint8_t *dux_commands;
+	struct semaphore sem;
+};
+
+/*
+ * The pointer to the private usb-data of the driver is also the private data
+ * for the comedi-device.  This has to be global as the usb subsystem needs
+ * global variables. The other reason is that this structure must be there
+ * _before_ any comedi command is issued. The usb subsystem must be initialised
+ * before comedi can access it.
+ */
+static struct usbduxsub usbduxsub[NUMUSBDUX];
+
+static DEFINE_SEMAPHORE(start_stop_sem);
+
+/*
+ * Stops the data acquision
+ * It should be safe to call this function from any context
+ */
+static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)
+{
+	int i = 0;
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbIn) {
+		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
+			if (usbduxsub_tmp->urbIn[i]) {
+				/* We wait here until all transfers have been
+				 * cancelled. */
+				usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+			}
+			dev_dbg(&usbduxsub_tmp->interface->dev,
+				"comedi: usbdux: unlinked InURB %d, err=%d\n",
+				i, err);
+		}
+	}
+	return err;
+}
+
+/*
+ * This will stop a running acquisition operation
+ * Is called from within this driver from both the
+ * interrupt context and from comedi
+ */
+static int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub) {
+		pr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");
+		return -EFAULT;
+	}
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");
+
+	if (do_unlink) {
+		/* stop aquistion */
+		ret = usbduxsub_unlink_InURBs(this_usbduxsub);
+	}
+
+	this_usbduxsub->ai_cmd_running = 0;
+
+	return ret;
+}
+
+/*
+ * This will cancel a running acquisition operation.
+ * This is called by comedi but never from inside the driver.
+ */
+static int usbdux_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	struct usbduxsub *this_usbduxsub;
+	int res = 0;
+
+	/* force unlink of all urbs */
+	this_usbduxsub = dev->private;
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_cancel\n");
+
+	/* prevent other CPUs from submitting new commands just now */
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	/* unlink only if the urb really has been submitted */
+	res = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);
+	up(&this_usbduxsub->sem);
+	return res;
+}
+
+/* analogue IN - interrupt service routine */
+static void usbduxsub_ai_IsocIrq(struct urb *urb)
+{
+	int i, err, n;
+	struct usbduxsub *this_usbduxsub;
+	struct comedi_device *this_comedidev;
+	struct comedi_subdevice *s;
+	int32_t v;
+	unsigned int dio_state;
+
+	/* the context variable points to the comedi device */
+	this_comedidev = urb->context;
+	/* the private structure of the subdevice is struct usbduxsub */
+	this_usbduxsub = this_comedidev->private;
+	/* subdevice which is the AD converter */
+	s = this_comedidev->subdevices + SUBDEV_AD;
+
+	/* first we test if something unusual has just happened */
+	switch (urb->status) {
+	case 0:
+		/* copy the result in the transfer buffer */
+		memcpy(this_usbduxsub->inBuffer,
+		       urb->transfer_buffer, SIZEINBUF);
+		break;
+	case -EILSEQ:
+		/* error in the ISOchronous data */
+		/* we don't copy the data into the transfer buffer */
+		/* and recycle the last data byte */
+		dev_dbg(&urb->dev->dev,
+			"comedi%d: usbdux: CRC error in ISO IN stream.\n",
+			this_usbduxsub->comedidev->minor);
+
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		/* happens after an unlink command */
+		if (this_usbduxsub->ai_cmd_running) {
+			/* we are still running a command */
+			/* tell this comedi */
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			/* stop the transfer w/o unlink */
+			usbdux_ai_stop(this_usbduxsub, 0);
+		}
+		return;
+
+	default:
+		/* a real error on the bus */
+		/* pass error to comedi if we are really running a command */
+		if (this_usbduxsub->ai_cmd_running) {
+			dev_err(&urb->dev->dev,
+				"Non-zero urb status received in ai intr "
+				"context: %d\n", urb->status);
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			/* don't do an unlink here */
+			usbdux_ai_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	/*
+	 * at this point we are reasonably sure that nothing dodgy has happened
+	 * are we running a command?
+	 */
+	if (unlikely((!(this_usbduxsub->ai_cmd_running)))) {
+		/*
+		 * not running a command, do not continue execution if no
+		 * asynchronous command is running in particular not resubmit
+		 */
+		return;
+	}
+
+	urb->dev = this_usbduxsub->usbdev;
+
+	/* resubmit the urb */
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (unlikely(err < 0)) {
+		dev_err(&urb->dev->dev,
+			"comedi_: urb resubmit failed in int-context!"
+			"err=%d\n",
+			err);
+		if (err == -EL2NSYNC)
+			dev_err(&urb->dev->dev,
+				"buggy USB host controller or bug in IRQ "
+				"handler!\n");
+		s->async->events |= COMEDI_CB_EOA;
+		s->async->events |= COMEDI_CB_ERROR;
+		comedi_event(this_usbduxsub->comedidev, s);
+		/* don't do an unlink here */
+		usbdux_ai_stop(this_usbduxsub, 0);
+		return;
+	}
+
+	/* get the state of the dio pins to allow external trigger */
+	dio_state = be32_to_cpu(this_usbduxsub->inBuffer[0]);
+
+	this_usbduxsub->ai_counter--;
+	if (likely(this_usbduxsub->ai_counter > 0))
+		return;
+
+	/* timer zero, transfer measurements to comedi */
+	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+
+	/* test, if we transmit only a fixed number of samples */
+	if (!(this_usbduxsub->ai_continous)) {
+		/* not continous, fixed number of samples */
+		this_usbduxsub->ai_sample_count--;
+		/* all samples received? */
+		if (this_usbduxsub->ai_sample_count < 0) {
+			/* prevent a resubmit next time */
+			usbdux_ai_stop(this_usbduxsub, 0);
+			/* say comedi that the acquistion is over */
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			return;
+		}
+	}
+	/* get the data from the USB bus and hand it over to comedi */
+	n = s->async->cmd.chanlist_len;
+	for (i = 0; i < n; i++) {
+		/* transfer data, note first byte is the DIO state */
+		v = be32_to_cpu(this_usbduxsub->inBuffer[i+1]);
+		/* strip status byte */
+		v = v & 0x00ffffff;
+		/* convert to unsigned */
+		v = v ^ 0x00800000;
+		/* write the byte to the buffer */
+		err = cfc_write_array_to_buffer(s, &v, sizeof(uint32_t));
+		if (unlikely(err == 0)) {
+			/* buffer overflow */
+			usbdux_ai_stop(this_usbduxsub, 0);
+			return;
+		}
+	}
+	/* tell comedi that data is there */
+	s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;
+	comedi_event(this_usbduxsub->comedidev, s);
+}
+
+static int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)
+{
+	int i = 0;
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbOut) {
+		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
+			if (usbduxsub_tmp->urbOut[i])
+				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
+
+			dev_dbg(&usbduxsub_tmp->interface->dev,
+				"comedi: usbdux: unlinked OutURB %d: res=%d\n",
+				i, err);
+		}
+	}
+	return err;
+}
+
+/* This will cancel a running acquisition operation
+ * in any context.
+ */
+static int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");
+
+	if (do_unlink)
+		ret = usbduxsub_unlink_OutURBs(this_usbduxsub);
+
+	this_usbduxsub->ao_cmd_running = 0;
+
+	return ret;
+}
+
+/* force unlink, is called by comedi */
+static int usbdux_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int res = 0;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	/* prevent other CPUs from submitting a command just now */
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	/* unlink only if it is really running */
+	res = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);
+	up(&this_usbduxsub->sem);
+	return res;
+}
+
+static void usbduxsub_ao_IsocIrq(struct urb *urb)
+{
+	int i, ret;
+	uint8_t *datap;
+	struct usbduxsub *this_usbduxsub;
+	struct comedi_device *this_comedidev;
+	struct comedi_subdevice *s;
+
+	/* the context variable points to the subdevice */
+	this_comedidev = urb->context;
+	/* the private structure of the subdevice is struct usbduxsub */
+	this_usbduxsub = this_comedidev->private;
+
+	s = this_comedidev->subdevices + SUBDEV_DA;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		/* after an unlink command, unplug, ... etc */
+		/* no unlink needed here. Already shutting down. */
+		if (this_usbduxsub->ao_cmd_running) {
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+		return;
+
+	default:
+		/* a real error */
+		if (this_usbduxsub->ao_cmd_running) {
+			dev_err(&urb->dev->dev,
+				"comedi_: Non-zero urb status received in ao "
+				"intr context: %d\n", urb->status);
+			s->async->events |= COMEDI_CB_ERROR;
+			s->async->events |= COMEDI_CB_EOA;
+			comedi_event(this_usbduxsub->comedidev, s);
+			/* we do an unlink if we are in the high speed mode */
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	/* are we actually running? */
+	if (!(this_usbduxsub->ao_cmd_running))
+		return;
+
+	/* normal operation: executing a command in this subdevice */
+	this_usbduxsub->ao_counter--;
+	if ((int)this_usbduxsub->ao_counter <= 0) {
+		/* timer zero */
+		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+
+		/* handle non continous aquisition */
+		if (!(this_usbduxsub->ao_continous)) {
+			/* fixed number of samples */
+			this_usbduxsub->ao_sample_count--;
+			if (this_usbduxsub->ao_sample_count < 0) {
+				/* all samples transmitted */
+				usbdux_ao_stop(this_usbduxsub, 0);
+				s->async->events |= COMEDI_CB_EOA;
+				comedi_event(this_usbduxsub->comedidev, s);
+				/* no resubmit of the urb */
+				return;
+			}
+		}
+		/* transmit data to the USB bus */
+		((uint8_t *) (urb->transfer_buffer))[0] =
+		    s->async->cmd.chanlist_len;
+		for (i = 0; i < s->async->cmd.chanlist_len; i++) {
+			short temp;
+			if (i >= NUMOUTCHANNELS)
+				break;
+
+			/* pointer to the DA */
+			datap =
+			    (&(((uint8_t *) urb->transfer_buffer)[i * 2 + 1]));
+			/* get the data from comedi */
+			ret = comedi_buf_get(s->async, &temp);
+			datap[0] = temp;
+			datap[1] = this_usbduxsub->dac_commands[i];
+			/* printk("data[0]=%x, data[1]=%x, data[2]=%x\n", */
+			/* datap[0],datap[1],datap[2]); */
+			if (ret < 0) {
+				dev_err(&urb->dev->dev,
+					"comedi: buffer underflow\n");
+				s->async->events |= COMEDI_CB_EOA;
+				s->async->events |= COMEDI_CB_OVERFLOW;
+			}
+			/* transmit data to comedi */
+			s->async->events |= COMEDI_CB_BLOCK;
+			comedi_event(this_usbduxsub->comedidev, s);
+		}
+	}
+	urb->transfer_buffer_length = SIZEOUTBUF;
+	urb->dev = this_usbduxsub->usbdev;
+	urb->status = 0;
+	if (this_usbduxsub->ao_cmd_running) {
+		if (this_usbduxsub->high_speed) {
+			/* uframes */
+			urb->interval = 8;
+		} else {
+			/* frames */
+			urb->interval = 1;
+		}
+		urb->number_of_packets = 1;
+		urb->iso_frame_desc[0].offset = 0;
+		urb->iso_frame_desc[0].length = SIZEOUTBUF;
+		urb->iso_frame_desc[0].status = 0;
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
+			dev_err(&urb->dev->dev,
+				"comedi_: ao urb resubm failed in int-cont. "
+				"ret=%d", ret);
+			if (ret == EL2NSYNC)
+				dev_err(&urb->dev->dev,
+					"buggy USB host controller or bug in "
+					"IRQ handling!\n");
+
+			s->async->events |= COMEDI_CB_EOA;
+			s->async->events |= COMEDI_CB_ERROR;
+			comedi_event(this_usbduxsub->comedidev, s);
+			/* don't do an unlink here */
+			usbdux_ao_stop(this_usbduxsub, 0);
+		}
+	}
+}
+
+static int usbduxsub_start(struct usbduxsub *usbduxsub)
+{
+	int errcode = 0;
+	uint8_t local_transfer_buffer[16];
+
+	/* 7f92 to zero */
+	local_transfer_buffer[0] = 0;
+	errcode = usb_control_msg(usbduxsub->usbdev,
+				  /* create a pipe for a control transfer */
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* bRequest, "Firmware" */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* Value */
+				  USBDUXSUB_CPUCS,
+				  /* Index */
+				  0x0000,
+				  /* address of the transfer buffer */
+				  local_transfer_buffer,
+				  /* Length */
+				  1,
+				  /* Timeout */
+				  BULK_TIMEOUT);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: control msg failed (start)\n");
+		return errcode;
+	}
+	return 0;
+}
+
+static int usbduxsub_stop(struct usbduxsub *usbduxsub)
+{
+	int errcode = 0;
+
+	uint8_t local_transfer_buffer[16];
+
+	/* 7f92 to one */
+	local_transfer_buffer[0] = 1;
+	errcode = usb_control_msg(usbduxsub->usbdev,
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* bRequest, "Firmware" */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* Value */
+				  USBDUXSUB_CPUCS,
+				  /* Index */
+				  0x0000, local_transfer_buffer,
+				  /* Length */
+				  1,
+				  /* Timeout */
+				  BULK_TIMEOUT);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: control msg failed (stop)\n");
+		return errcode;
+	}
+	return 0;
+}
+
+static int usbduxsub_upload(struct usbduxsub *usbduxsub,
+			    uint8_t *local_transfer_buffer,
+			    unsigned int startAddr, unsigned int len)
+{
+	int errcode;
+
+	errcode = usb_control_msg(usbduxsub->usbdev,
+				  usb_sndctrlpipe(usbduxsub->usbdev, 0),
+				  /* brequest, firmware */
+				  USBDUXSUB_FIRMWARE,
+				  /* bmRequestType */
+				  VENDOR_DIR_OUT,
+				  /* value */
+				  startAddr,
+				  /* index */
+				  0x0000,
+				  /* our local safe buffer */
+				  local_transfer_buffer,
+				  /* length */
+				  len,
+				  /* timeout */
+				  BULK_TIMEOUT);
+	dev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);
+	if (errcode < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: upload failed\n");
+		return errcode;
+	}
+	return 0;
+}
+
+/* the FX2LP has twice as much as the standard FX2 */
+#define FIRMWARE_MAX_LEN 0x4000
+
+static int firmwareUpload(struct usbduxsub *usbduxsub,
+			  const u8 *firmwareBinary, int sizeFirmware)
+{
+	int ret;
+	uint8_t *fwBuf;
+
+	if (!firmwareBinary)
+		return 0;
+
+	if (sizeFirmware > FIRMWARE_MAX_LEN) {
+		dev_err(&usbduxsub->interface->dev,
+			"usbduxsigma firmware binary it too large for FX2.\n");
+		return -ENOMEM;
+	}
+
+	/* we generate a local buffer for the firmware */
+	fwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);
+	if (!fwBuf) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: mem alloc for firmware failed\n");
+		return -ENOMEM;
+	}
+
+	ret = usbduxsub_stop(usbduxsub);
+	if (ret < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: can not stop firmware\n");
+		kfree(fwBuf);
+		return ret;
+	}
+
+	ret = usbduxsub_upload(usbduxsub, fwBuf, 0, sizeFirmware);
+	if (ret < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: firmware upload failed\n");
+		kfree(fwBuf);
+		return ret;
+	}
+	ret = usbduxsub_start(usbduxsub);
+	if (ret < 0) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: can not start firmware\n");
+		kfree(fwBuf);
+		return ret;
+	}
+	kfree(fwBuf);
+	return 0;
+}
+
+static int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)
+{
+	int i, errFlag;
+
+	if (!usbduxsub)
+		return -EFAULT;
+
+	/* Submit all URBs and start the transfer on the bus */
+	for (i = 0; i < usbduxsub->numOfInBuffers; i++) {
+		/* in case of a resubmission after an unlink... */
+		usbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;
+		usbduxsub->urbIn[i]->context = usbduxsub->comedidev;
+		usbduxsub->urbIn[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urbIn[i]->status = 0;
+		usbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",
+			usbduxsub->comedidev->minor, i,
+			(usbduxsub->urbIn[i]->context),
+			(usbduxsub->urbIn[i]->dev),
+			(usbduxsub->urbIn[i]->interval));
+		errFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);
+		if (errFlag) {
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: ai: usb_submit_urb(%d) error %d\n",
+				i, errFlag);
+			return errFlag;
+		}
+	}
+	return 0;
+}
+
+static int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)
+{
+	int i, errFlag;
+
+	if (!usbduxsub)
+		return -EFAULT;
+
+	for (i = 0; i < usbduxsub->numOfOutBuffers; i++) {
+		dev_dbg(&usbduxsub->interface->dev,
+			"comedi_: submitting out-urb[%d]\n", i);
+		/* in case of a resubmission after an unlink... */
+		usbduxsub->urbOut[i]->context = usbduxsub->comedidev;
+		usbduxsub->urbOut[i]->dev = usbduxsub->usbdev;
+		usbduxsub->urbOut[i]->status = 0;
+		usbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;
+		errFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);
+		if (errFlag) {
+			dev_err(&usbduxsub->interface->dev,
+				"comedi_: ao: usb_submit_urb(%d) error %d\n",
+				i, errFlag);
+			return errFlag;
+		}
+	}
+	return 0;
+}
+
+static int chanToInterval(int nChannels)
+{
+	if (nChannels <= 2)
+		/* 4kHz */
+		return 2;
+	if (nChannels <= 8)
+		/* 2kHz */
+		return 4;
+	/* 1kHz */
+	return 8;
+}
+
+static int usbdux_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd)
+{
+	int err = 0, tmp, i;
+	unsigned int tmpTimer;
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!(this_usbduxsub->probed))
+		return -ENODEV;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_cmdtest\n", dev->minor);
+
+	/* make sure triggers are valid */
+	/* Only immediate triggers are allowed */
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	/* trigger should happen timed */
+	tmp = cmd->scan_begin_src;
+	/* start a new _scan_ with a timer */
+	cmd->scan_begin_src &= TRIG_TIMER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	/* scanning is continous */
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	/* issue a trigger when scan is finished and start a new scan */
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	/* trigger at the end of count events or not, stop condition or not */
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/*
+	 * step 2: make sure trigger sources are unique and mutually compatible
+	 * note that mutual compatibility is not an issue here
+	 */
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (this_usbduxsub->high_speed) {
+			/*
+			 * In high speed mode microframes are possible.
+			 * However, during one microframe we can roughly
+			 * sample two channels. Thus, the more channels
+			 * are in the channel list the more time we need.
+			 */
+			i = chanToInterval(cmd->chanlist_len);
+			if (cmd->scan_begin_arg < (1000000 / 8 * i)) {
+				cmd->scan_begin_arg = 1000000 / 8 * i;
+				err++;
+			}
+			/* now calc the real sampling rate with all the
+			 * rounding errors */
+			tmpTimer =
+			    ((unsigned int)(cmd->scan_begin_arg / 125000)) *
+			    125000;
+			if (cmd->scan_begin_arg != tmpTimer) {
+				cmd->scan_begin_arg = tmpTimer;
+				err++;
+			}
+		} else {
+			/* full speed */
+			/* 1kHz scans every USB frame */
+			if (cmd->scan_begin_arg < 1000000) {
+				cmd->scan_begin_arg = 1000000;
+				err++;
+			}
+			/*
+			 * calc the real sampling rate with the rounding errors
+			 */
+			tmpTimer = ((unsigned int)(cmd->scan_begin_arg /
+						   1000000)) * 1000000;
+			if (cmd->scan_begin_arg != tmpTimer) {
+				cmd->scan_begin_arg = tmpTimer;
+				err++;
+			}
+		}
+	}
+	/* the same argument */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	return 0;
+}
+
+/*
+ * creates the ADC command for the MAX1271
+ * range is the range value from comedi
+ */
+static void create_adc_command(unsigned int chan,
+			       uint8_t *muxsg0,
+			       uint8_t *muxsg1)
+{
+	if (chan < 8)
+		(*muxsg0) = (*muxsg0) | (1 << chan);
+	else if (chan < 16)
+		(*muxsg1) = (*muxsg1) | (1 << (chan-8));
+}
+
+
+/* bulk transfers to usbdux */
+
+#define SENDADCOMMANDS            0
+#define SENDDACOMMANDS            1
+#define SENDDIOCONFIGCOMMAND      2
+#define SENDDIOBITSCOMMAND        3
+#define SENDSINGLEAD              4
+#define SENDPWMON                 7
+#define SENDPWMOFF                8
+
+static int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)
+{
+	int result, nsent;
+
+	this_usbduxsub->dux_commands[0] = cmd_type;
+#ifdef NOISY_DUX_DEBUGBUG
+	printk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",
+	       this_usbduxsub->comedidev->minor);
+	for (result = 0; result < SIZEOFDUXBUFFER; result++)
+		printk(" %02x", this_usbduxsub->dux_commands[result]);
+	printk("\n");
+#endif
+	result = usb_bulk_msg(this_usbduxsub->usbdev,
+			      usb_sndbulkpipe(this_usbduxsub->usbdev,
+					      COMMAND_OUT_EP),
+			      this_usbduxsub->dux_commands, SIZEOFDUXBUFFER,
+			      &nsent, BULK_TIMEOUT);
+	if (result < 0)
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+			"could not transmit dux_command to the usb-device, "
+			"err=%d\n", this_usbduxsub->comedidev->minor, result);
+
+	return result;
+}
+
+static int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)
+{
+	int result = (-EFAULT);
+	int nrec;
+	int i;
+
+	for (i = 0; i < RETRIES; i++) {
+		result = usb_bulk_msg(this_usbduxsub->usbdev,
+				      usb_rcvbulkpipe(this_usbduxsub->usbdev,
+						      COMMAND_IN_EP),
+				      this_usbduxsub->insnBuffer, SIZEINSNBUF,
+				      &nrec, BULK_TIMEOUT);
+		if (result < 0) {
+			dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+				"insn: USB error %d "
+				"while receiving DUX command"
+				"\n", this_usbduxsub->comedidev->minor,
+				result);
+			return result;
+		}
+		if (this_usbduxsub->insnBuffer[0] == command)
+			return result;
+	}
+	/* this is only reached if the data has been requested a couple of
+	 * times */
+	dev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "
+		"wrong data returned from firmware: want %d, got %d.\n",
+		this_usbduxsub->comedidev->minor, command,
+		this_usbduxsub->insnBuffer[0]);
+	return -EFAULT;
+}
+
+static int usbdux_ai_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
+{
+	int ret;
+	struct usbduxsub *this_usbduxsub = dev->private;
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_inttrig\n", dev->minor);
+
+	if (trignum != 0) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: usbdux_ai_inttrig: invalid trignum\n",
+			dev->minor);
+		up(&this_usbduxsub->sem);
+		return -EINVAL;
+	}
+	if (!(this_usbduxsub->ai_cmd_running)) {
+		this_usbduxsub->ai_cmd_running = 1;
+		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		if (ret < 0) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux_ai_inttrig: "
+				"urbSubmit: err=%d\n", dev->minor, ret);
+			this_usbduxsub->ai_cmd_running = 0;
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ai_inttrig but acqu is already running\n",
+			dev->minor);
+	}
+	up(&this_usbduxsub->sem);
+	return 1;
+}
+
+static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int chan;
+	int i, ret;
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int result;
+	uint8_t muxsg0 = 0;
+	uint8_t muxsg1 = 0;
+	uint8_t sysred = 0;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ai_cmd\n", dev->minor);
+
+	/* block other CPUs from starting an ai_cmd */
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ai_cmd_running) {
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: "
+			"ai_cmd not possible. Another ai_cmd is running.\n",
+			dev->minor);
+		up(&this_usbduxsub->sem);
+		return -EBUSY;
+	}
+	/* set current channel of the running aquisition to zero */
+	s->async->cur_chan = 0;
+
+	/* first the number of channels per time step */
+	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
+
+	/* CONFIG0 */
+	this_usbduxsub->dux_commands[2] = 0x12;
+
+	/* CONFIG1: 23kHz sampling rate, delay = 0us,  */
+	this_usbduxsub->dux_commands[3] = 0x03;
+
+	/* CONFIG3: differential channels off */
+	this_usbduxsub->dux_commands[4] = 0x00;
+
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		chan = CR_CHAN(cmd->chanlist[i]);
+		create_adc_command(chan, &muxsg0, &muxsg1);
+		if (i >= NUMCHANNELS) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: channel list too long\n",
+				dev->minor);
+			break;
+		}
+	}
+	this_usbduxsub->dux_commands[5] = muxsg0;
+	this_usbduxsub->dux_commands[6] = muxsg1;
+	this_usbduxsub->dux_commands[7] = sysred;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi %d: sending commands to the usb device: size=%u\n",
+		dev->minor, NUMCHANNELS);
+
+	result = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);
+	if (result < 0) {
+		up(&this_usbduxsub->sem);
+		return result;
+	}
+
+	if (this_usbduxsub->high_speed) {
+		/*
+		 * every 2 channels get a time window of 125us. Thus, if we
+		 * sample all 16 channels we need 1ms. If we sample only one
+		 * channel we need only 125us
+		 */
+		this_usbduxsub->ai_interval =
+			chanToInterval(cmd->chanlist_len);
+		this_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *
+							  (this_usbduxsub->
+							   ai_interval));
+	} else {
+		/* interval always 1ms */
+		this_usbduxsub->ai_interval = 1;
+		this_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;
+	}
+	if (this_usbduxsub->ai_timer < 1) {
+		dev_err(&this_usbduxsub->interface->dev, "comedi%d: ai_cmd: "
+			"timer=%d, scan_begin_arg=%d. "
+			"Not properly tested by cmdtest?\n", dev->minor,
+			this_usbduxsub->ai_timer, cmd->scan_begin_arg);
+		up(&this_usbduxsub->sem);
+		return -EINVAL;
+	}
+	this_usbduxsub->ai_counter = this_usbduxsub->ai_timer;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* data arrives as one packet */
+		this_usbduxsub->ai_sample_count = cmd->stop_arg;
+		this_usbduxsub->ai_continous = 0;
+	} else {
+		/* continous aquisition */
+		this_usbduxsub->ai_continous = 1;
+		this_usbduxsub->ai_sample_count = 0;
+	}
+
+	if (cmd->start_src == TRIG_NOW) {
+		/* enable this acquisition operation */
+		this_usbduxsub->ai_cmd_running = 1;
+		ret = usbduxsub_submit_InURBs(this_usbduxsub);
+		if (ret < 0) {
+			this_usbduxsub->ai_cmd_running = 0;
+			/* fixme: unlink here?? */
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		/* TRIG_INT */
+		/* don't enable the acquision operation */
+		/* wait for an internal signal */
+		s->async->inttrig = usbdux_ai_inttrig;
+	}
+	up(&this_usbduxsub->sem);
+	return 0;
+}
+
+/* Mode 0 is used to get a single conversion on demand */
+static int usbdux_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
+{
+	int i;
+	int32_t one = 0;
+	int chan;
+	int err;
+	struct usbduxsub *this_usbduxsub = dev->private;
+	uint8_t muxsg0 = 0;
+	uint8_t muxsg1 = 0;
+	uint8_t sysred = 0;
+
+	if (!this_usbduxsub)
+		return 0;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
+		dev->minor, insn->n, insn->subdev);
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ai_cmd_running) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ai_insn_read not possible. "
+			"Async Command is running.\n", dev->minor);
+		up(&this_usbduxsub->sem);
+		return 0;
+	}
+
+	/* sample one channel */
+	/* CONFIG0: chopper on */
+	this_usbduxsub->dux_commands[1] = 0x16;
+
+	/* CONFIG1: 2kHz sampling rate */
+	this_usbduxsub->dux_commands[2] = 0x80;
+
+	/* CONFIG3: differential channels off */
+	this_usbduxsub->dux_commands[3] = 0x00;
+
+	chan = CR_CHAN(insn->chanspec);
+	create_adc_command(chan, &muxsg0, &muxsg1);
+
+	this_usbduxsub->dux_commands[4] = muxsg0;
+	this_usbduxsub->dux_commands[5] = muxsg1;
+	this_usbduxsub->dux_commands[6] = sysred;
+
+	/* adc commands */
+	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	if (err < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	for (i = 0; i < insn->n; i++) {
+		err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+		if (err < 0) {
+			up(&this_usbduxsub->sem);
+			return 0;
+		}
+		/* 32 bits big endian from the A/D converter */
+		one = be32_to_cpu(*((int32_t *)
+				    ((this_usbduxsub->insnBuffer)+1)));
+		/* mask out the staus byte */
+		one = one & 0x00ffffff;
+		/* turn it into an unsigned integer */
+		one = one ^ 0x00800000;
+		data[i] = one;
+	}
+	up(&this_usbduxsub->sem);
+	return i;
+}
+
+
+
+
+static int usbdux_getstatusinfo(struct comedi_device *dev, int chan)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	uint8_t sysred = 0;
+	uint32_t one;
+	int err;
+
+	if (!this_usbduxsub)
+		return 0;
+
+	if (this_usbduxsub->ai_cmd_running) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: status read not possible. "
+			"Async Command is running.\n", dev->minor);
+		return 0;
+	}
+
+	/* CONFIG0 */
+	this_usbduxsub->dux_commands[1] = 0x12;
+
+	/* CONFIG1: 2kHz sampling rate */
+	this_usbduxsub->dux_commands[2] = 0x80;
+
+	/* CONFIG3: differential channels off */
+	this_usbduxsub->dux_commands[3] = 0x00;
+
+	if (chan == 1) {
+		/* ADC offset */
+		sysred = sysred | 1;
+	} else if (chan == 2) {
+		/* VCC */
+		sysred = sysred | 4;
+	} else if (chan == 3) {
+		/* temperature */
+		sysred = sysred | 8;
+	} else if (chan == 4) {
+		/* gain */
+		sysred = sysred | 16;
+	} else if (chan == 5) {
+		/* ref */
+		sysred = sysred | 32;
+	}
+
+	this_usbduxsub->dux_commands[4] = 0;
+	this_usbduxsub->dux_commands[5] = 0;
+	this_usbduxsub->dux_commands[6] = sysred;
+
+	/* adc commands */
+	err = send_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	if (err < 0)
+		return err;
+
+	err = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);
+	if (err < 0)
+		return err;
+
+	/* 32 bits big endian from the A/D converter */
+	one = be32_to_cpu(*((int32_t *)((this_usbduxsub->insnBuffer)+1)));
+	/* mask out the staus byte */
+	one = one & 0x00ffffff;
+	one = one ^ 0x00800000;
+
+	return (int)one;
+}
+
+
+
+
+
+
+/************************************/
+/* analog out */
+
+static int usbdux_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	for (i = 0; i < insn->n; i++)
+		data[i] = this_usbduxsub->outBuffer[chan];
+
+	up(&this_usbduxsub->sem);
+	return i;
+}
+
+static int usbdux_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
+{
+	int i, err;
+	int chan = CR_CHAN(insn->chanspec);
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: ao_insn_write\n", dev->minor);
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (this_usbduxsub->ao_cmd_running) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_insn_write: "
+			"ERROR: asynchronous ao_cmd is running\n", dev->minor);
+		up(&this_usbduxsub->sem);
+		return 0;
+	}
+
+	for (i = 0; i < insn->n; i++) {
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",
+			dev->minor, chan, i, data[i]);
+
+		/* number of channels: 1 */
+		this_usbduxsub->dux_commands[1] = 1;
+		/* channel number */
+		this_usbduxsub->dux_commands[2] = data[i];
+		this_usbduxsub->outBuffer[chan] = data[i];
+		this_usbduxsub->dux_commands[3] = chan;
+		err = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);
+		if (err < 0) {
+			up(&this_usbduxsub->sem);
+			return err;
+		}
+	}
+	up(&this_usbduxsub->sem);
+
+	return i;
+}
+
+static int usbdux_ao_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int trignum)
+{
+	int ret;
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	if (trignum != 0) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: usbdux_ao_inttrig: invalid trignum\n",
+			dev->minor);
+		return -EINVAL;
+	}
+	if (!(this_usbduxsub->ao_cmd_running)) {
+		this_usbduxsub->ao_cmd_running = 1;
+		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		if (ret < 0) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux_ao_inttrig: submitURB: "
+				"err=%d\n", dev->minor, ret);
+			this_usbduxsub->ao_cmd_running = 0;
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_inttrig but acqu is already running.\n",
+			dev->minor);
+	}
+	up(&this_usbduxsub->sem);
+	return 1;
+}
+
+static int usbdux_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd)
+{
+	int err = 0, tmp;
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	if (!(this_usbduxsub->probed))
+		return -ENODEV;
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: usbdux_ao_cmdtest\n", dev->minor);
+
+	/* make sure triggers are valid */
+	/* Only immediate triggers are allowed */
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	/* trigger should happen timed */
+	tmp = cmd->scan_begin_src;
+	/* just now we scan also in the high speed mode every frame */
+	/* this is due to ehci driver limitations */
+	if (0) {		/* (this_usbduxsub->high_speed) */
+		/* start immidiately a new scan */
+		/* the sampling rate is set by the coversion rate */
+		cmd->scan_begin_src &= TRIG_FOLLOW;
+	} else {
+		/* start a new scan (output at once) with a timer */
+		cmd->scan_begin_src &= TRIG_TIMER;
+	}
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	/* scanning is continous */
+	tmp = cmd->convert_src;
+
+	/* all conversion events happen simultaneously */
+	cmd->convert_src &= TRIG_NOW;
+
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	/* issue a trigger when scan is finished and start a new scan */
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	/* trigger at the end of count events or not, stop condition or not */
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/*
+	 * step 2: make sure trigger sources
+	 * are unique and mutually compatible
+	 * note that mutual compatibility is not an issue here
+	 */
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_TIMER)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* timer */
+		if (cmd->scan_begin_arg < 1000000) {
+			cmd->scan_begin_arg = 1000000;
+			err++;
+		}
+	}
+	/* not used now, is for later use */
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < 125000) {
+			cmd->convert_arg = 125000;
+			err++;
+		}
+	}
+
+	/* the same argument */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: err=%d, "
+		"scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, "
+		"convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src,
+		cmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);
+
+	if (err)
+		return 3;
+
+	return 0;
+}
+
+static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+{
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int chan, gain;
+	int i, ret;
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	down(&this_usbduxsub->sem);
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi%d: %s\n", dev->minor, __func__);
+
+	/* set current channel of the running aquisition to zero */
+	s->async->cur_chan = 0;
+	for (i = 0; i < cmd->chanlist_len; ++i) {
+		chan = CR_CHAN(cmd->chanlist[i]);
+		gain = CR_RANGE(cmd->chanlist[i]);
+		if (i >= NUMOUTCHANNELS) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: %s: channel list too long\n",
+				dev->minor, __func__);
+			break;
+		}
+		this_usbduxsub->dac_commands[i] = chan;
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: dac command for ch %d is %x\n",
+			dev->minor, i, this_usbduxsub->dac_commands[i]);
+	}
+
+	/* we count in steps of 1ms (125us) */
+	/* 125us mode not used yet */
+	if (0) {		/* (this_usbduxsub->high_speed) */
+		/* 125us */
+		/* timing of the conversion itself: every 125 us */
+		this_usbduxsub->ao_timer = cmd->convert_arg / 125000;
+	} else {
+		/* 1ms */
+		/* timing of the scan: we get all channels at once */
+		this_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: scan_begin_src=%d, scan_begin_arg=%d, "
+			"convert_src=%d, convert_arg=%d\n", dev->minor,
+			cmd->scan_begin_src, cmd->scan_begin_arg,
+			cmd->convert_src, cmd->convert_arg);
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: ao_timer=%d (ms)\n",
+			dev->minor, this_usbduxsub->ao_timer);
+		if (this_usbduxsub->ao_timer < 1) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: usbdux: ao_timer=%d, "
+				"scan_begin_arg=%d. "
+				"Not properly tested by cmdtest?\n",
+				dev->minor, this_usbduxsub->ao_timer,
+				cmd->scan_begin_arg);
+			up(&this_usbduxsub->sem);
+			return -EINVAL;
+		}
+	}
+	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* not continous */
+		/* counter */
+		/* high speed also scans everything at once */
+		if (0) {	/* (this_usbduxsub->high_speed) */
+			this_usbduxsub->ao_sample_count =
+			    (cmd->stop_arg) * (cmd->scan_end_arg);
+		} else {
+			/* there's no scan as the scan has been */
+			/* perf inside the FX2 */
+			/* data arrives as one packet */
+			this_usbduxsub->ao_sample_count = cmd->stop_arg;
+		}
+		this_usbduxsub->ao_continous = 0;
+	} else {
+		/* continous aquisition */
+		this_usbduxsub->ao_continous = 1;
+		this_usbduxsub->ao_sample_count = 0;
+	}
+
+	if (cmd->start_src == TRIG_NOW) {
+		/* enable this acquisition operation */
+		this_usbduxsub->ao_cmd_running = 1;
+		ret = usbduxsub_submit_OutURBs(this_usbduxsub);
+		if (ret < 0) {
+			this_usbduxsub->ao_cmd_running = 0;
+			/* fixme: unlink here?? */
+			up(&this_usbduxsub->sem);
+			return ret;
+		}
+		s->async->inttrig = NULL;
+	} else {
+		/* TRIG_INT */
+		/* submit the urbs later */
+		/* wait for an internal signal */
+		s->async->inttrig = usbdux_ao_inttrig;
+	}
+
+	up(&this_usbduxsub->sem);
+	return 0;
+}
+
+static int usbdux_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
+{
+	int chan = CR_CHAN(insn->chanspec);
+
+	/* The input or output configuration of each digital line is
+	 * configured by a special insn_config instruction.  chanspec
+	 * contains the channel to be changed, and data[0] contains the
+	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= 1 << chan;	/* 1 means Out */
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~(1 << chan);
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] =
+		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	/* we don't tell the firmware here as it would take 8 frames */
+	/* to submit the information. We do it in the insn_bits. */
+	return insn->n;
+}
+
+static int usbdux_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
+{
+
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int err;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	if (insn->n != 2)
+		return -EINVAL;
+
+	down(&this_usbduxsub->sem);
+
+	if (!(this_usbduxsub->probed)) {
+		up(&this_usbduxsub->sem);
+		return -ENODEV;
+	}
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+	s->state &= ~data[0];
+	s->state |= data[0] & data[1];
+	/* The commands are 8 bits wide */
+	this_usbduxsub->dux_commands[1] = (s->io_bits) & 0x000000FF;
+	this_usbduxsub->dux_commands[4] = (s->state) & 0x000000FF;
+	this_usbduxsub->dux_commands[2] = ((s->io_bits) & 0x0000FF00) >> 8;
+	this_usbduxsub->dux_commands[5] = ((s->state) & 0x0000FF00) >> 8;
+	this_usbduxsub->dux_commands[3] = ((s->io_bits) & 0x00FF0000) >> 16;
+	this_usbduxsub->dux_commands[6] = ((s->state) & 0x00FF0000) >> 16;
+
+	/* This command also tells the firmware to return */
+	/* the digital input lines */
+	err = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	if (err < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+	err = receive_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);
+	if (err < 0) {
+		up(&this_usbduxsub->sem);
+		return err;
+	}
+
+	data[1] = (((unsigned int)(this_usbduxsub->insnBuffer[1]))&0xff) |
+		((((unsigned int)(this_usbduxsub->insnBuffer[2]))&0xff) << 8) |
+		((((unsigned int)(this_usbduxsub->insnBuffer[3]))&0xff) << 16);
+
+	s->state = data[1];
+
+	up(&this_usbduxsub->sem);
+	return 2;
+}
+
+/***********************************/
+/* PWM */
+
+static int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)
+{
+	int err = 0;
+
+	if (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {
+		if (usbduxsub_tmp->urbPwm)
+			usb_kill_urb(usbduxsub_tmp->urbPwm);
+		dev_dbg(&usbduxsub_tmp->interface->dev,
+			"comedi: unlinked PwmURB: res=%d\n", err);
+	}
+	return err;
+}
+
+/* This cancels a running acquisition operation
+ * in any context.
+ */
+static int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)
+{
+	int ret = 0;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);
+	if (do_unlink)
+		ret = usbduxsub_unlink_PwmURBs(this_usbduxsub);
+
+	this_usbduxsub->pwm_cmd_running = 0;
+
+	return ret;
+}
+
+/* force unlink - is called by comedi */
+static int usbdux_pwm_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int res = 0;
+
+	/* unlink only if it is really running */
+	res = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);
+
+	dev_dbg(&this_usbduxsub->interface->dev,
+		"comedi %d: sending pwm off command to the usb device.\n",
+		dev->minor);
+	res = send_dux_commands(this_usbduxsub, SENDPWMOFF);
+	if (res < 0)
+		return res;
+
+	return res;
+}
+
+static void usbduxsub_pwm_irq(struct urb *urb)
+{
+	int ret;
+	struct usbduxsub *this_usbduxsub;
+	struct comedi_device *this_comedidev;
+	struct comedi_subdevice *s;
+
+	/* printk(KERN_DEBUG "PWM: IRQ\n"); */
+
+	/* the context variable points to the subdevice */
+	this_comedidev = urb->context;
+	/* the private structure of the subdevice is struct usbduxsub */
+	this_usbduxsub = this_comedidev->private;
+
+	s = this_comedidev->subdevices + SUBDEV_DA;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -ECONNABORTED:
+		/*
+		 * after an unlink command, unplug, ... etc
+		 * no unlink needed here. Already shutting down.
+		 */
+		if (this_usbduxsub->pwm_cmd_running)
+			usbdux_pwm_stop(this_usbduxsub, 0);
+
+		return;
+
+	default:
+		/* a real error */
+		if (this_usbduxsub->pwm_cmd_running) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi_: Non-zero urb status received in "
+				"pwm intr context: %d\n", urb->status);
+			usbdux_pwm_stop(this_usbduxsub, 0);
+		}
+		return;
+	}
+
+	/* are we actually running? */
+	if (!(this_usbduxsub->pwm_cmd_running))
+		return;
+
+	urb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;
+	urb->dev = this_usbduxsub->usbdev;
+	urb->status = 0;
+	if (this_usbduxsub->pwm_cmd_running) {
+		ret = usb_submit_urb(urb, GFP_ATOMIC);
+		if (ret < 0) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi_: pwm urb resubm failed in int-cont. "
+				"ret=%d", ret);
+			if (ret == EL2NSYNC)
+				dev_err(&this_usbduxsub->interface->dev,
+					"buggy USB host controller or bug in "
+					"IRQ handling!\n");
+
+			/* don't do an unlink here */
+			usbdux_pwm_stop(this_usbduxsub, 0);
+		}
+	}
+}
+
+static int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)
+{
+	int errFlag;
+
+	if (!usbduxsub)
+		return -EFAULT;
+
+	dev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");
+
+	/* in case of a resubmission after an unlink... */
+	usb_fill_bulk_urb(usbduxsub->urbPwm,
+			  usbduxsub->usbdev,
+			  usb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),
+			  usbduxsub->urbPwm->transfer_buffer,
+			  usbduxsub->sizePwmBuf, usbduxsub_pwm_irq,
+			  usbduxsub->comedidev);
+
+	errFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);
+	if (errFlag) {
+		dev_err(&usbduxsub->interface->dev,
+			"comedi_: usbduxsigma: pwm: usb_submit_urb error %d\n",
+			errFlag);
+		return errFlag;
+	}
+	return 0;
+}
+
+static int usbdux_pwm_period(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int period)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int fx2delay = 255;
+
+	if (period < MIN_PWM_PERIOD) {
+		dev_err(&this_usbduxsub->interface->dev,
+			"comedi%d: illegal period setting for pwm.\n",
+			dev->minor);
+		return -EAGAIN;
+	} else {
+		fx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;
+		if (fx2delay > 255) {
+			dev_err(&this_usbduxsub->interface->dev,
+				"comedi%d: period %d for pwm is too low.\n",
+				dev->minor, period);
+			return -EAGAIN;
+		}
+	}
+	this_usbduxsub->pwmDelay = fx2delay;
+	this_usbduxsub->pwmPeriod = period;
+	dev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",
+		__func__, period, fx2delay);
+	return 0;
+}
+
+/* is called from insn so there's no need to do all the sanity checks */
+static int usbdux_pwm_start(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	int ret, i;
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	dev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",
+		dev->minor, __func__);
+
+	if (this_usbduxsub->pwm_cmd_running) {
+		/* already running */
+		return 0;
+	}
+
+	this_usbduxsub->dux_commands[1] = ((uint8_t) this_usbduxsub->pwmDelay);
+	ret = send_dux_commands(this_usbduxsub, SENDPWMON);
+	if (ret < 0)
+		return ret;
+
+	/* initialise the buffer */
+	for (i = 0; i < this_usbduxsub->sizePwmBuf; i++)
+		((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;
+
+	this_usbduxsub->pwm_cmd_running = 1;
+	ret = usbduxsub_submit_PwmURBs(this_usbduxsub);
+	if (ret < 0) {
+		this_usbduxsub->pwm_cmd_running = 0;
+		return ret;
+	}
+	return 0;
+}
+
+/* generates the bit pattern for PWM with the optional sign bit */
+static int usbdux_pwm_pattern(struct comedi_device *dev,
+			      struct comedi_subdevice *s, int channel,
+			      unsigned int value, unsigned int sign)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	int i, szbuf;
+	char *pBuf;
+	char pwm_mask;
+	char sgn_mask;
+	char c;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	/* this is the DIO bit which carries the PWM data */
+	pwm_mask = (1 << channel);
+	/* this is the DIO bit which carries the optional direction bit */
+	sgn_mask = (16 << channel);
+	/* this is the buffer which will be filled with the with bit */
+	/* pattern for one period */
+	szbuf = this_usbduxsub->sizePwmBuf;
+	pBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);
+	for (i = 0; i < szbuf; i++) {
+		c = *pBuf;
+		/* reset bits */
+		c = c & (~pwm_mask);
+		/* set the bit as long as the index is lower than the value */
+		if (i < value)
+			c = c | pwm_mask;
+		/* set the optional sign bit for a relay */
+		if (!sign) {
+			/* positive value */
+			c = c & (~sgn_mask);
+		} else {
+			/* negative value */
+			c = c | sgn_mask;
+		}
+		*(pBuf++) = c;
+	}
+	return 1;
+}
+
+static int usbdux_pwm_write(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+
+	if (!this_usbduxsub)
+		return -EFAULT;
+
+	if ((insn->n) != 1) {
+		/*
+		 * doesn't make sense to have more than one value here because
+		 * it would just overwrite the PWM buffer a couple of times
+		 */
+		return -EINVAL;
+	}
+
+	/*
+	 * the sign is set via a special INSN only, this gives us 8 bits for
+	 * normal operation
+	 * relay sign 0 by default
+	 */
+	return usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);
+}
+
+static int usbdux_pwm_read(struct comedi_device *x1,
+			   struct comedi_subdevice *x2, struct comedi_insn *x3,
+			   unsigned int *x4)
+{
+	/* not needed */
+	return -EINVAL;
+};
+
+/* switches on/off PWM */
+static int usbdux_pwm_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	struct usbduxsub *this_usbduxsub = dev->private;
+	switch (data[0]) {
+	case INSN_CONFIG_ARM:
+		/* switch it on */
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: pwm on\n", dev->minor, __func__);
+		/*
+		 * if not zero the PWM is limited to a certain time which is
+		 * not supported here
+		 */
+		if (data[1] != 0)
+			return -EINVAL;
+		return usbdux_pwm_start(dev, s);
+	case INSN_CONFIG_DISARM:
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: pwm off\n", dev->minor, __func__);
+		return usbdux_pwm_cancel(dev, s);
+	case INSN_CONFIG_GET_PWM_STATUS:
+		/*
+		 * to check if the USB transmission has failed or in case PWM
+		 * was limited to n cycles to check if it has terminated
+		 */
+		data[1] = this_usbduxsub->pwm_cmd_running;
+		return 0;
+	case INSN_CONFIG_PWM_SET_PERIOD:
+		dev_dbg(&this_usbduxsub->interface->dev,
+			"comedi%d: %s: setting period\n", dev->minor,
+			__func__);
+		return usbdux_pwm_period(dev, s, data[1]);
+	case INSN_CONFIG_PWM_GET_PERIOD:
+		data[1] = this_usbduxsub->pwmPeriod;
+		return 0;
+	case INSN_CONFIG_PWM_SET_H_BRIDGE:
+		/* value in the first byte and the sign in the second for a
+		   relay */
+		return usbdux_pwm_pattern(dev, s,
+					  /* the channel number */
+					  CR_CHAN(insn->chanspec),
+					  /* actual PWM data */
+					  data[1],
+					  /* just a sign */
+					  (data[2] != 0));
+	case INSN_CONFIG_PWM_GET_H_BRIDGE:
+		/* values are not kept in this driver, nothing to return */
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+/* end of PWM */
+/*****************************************************************/
+
+static void tidy_up(struct usbduxsub *usbduxsub_tmp)
+{
+	int i;
+
+	if (!usbduxsub_tmp)
+		return;
+	dev_dbg(&usbduxsub_tmp->interface->dev, "comedi_: tiding up\n");
+
+	/* shows the usb subsystem that the driver is down */
+	if (usbduxsub_tmp->interface)
+		usb_set_intfdata(usbduxsub_tmp->interface, NULL);
+
+	usbduxsub_tmp->probed = 0;
+
+	if (usbduxsub_tmp->urbIn) {
+		if (usbduxsub_tmp->ai_cmd_running) {
+			usbduxsub_tmp->ai_cmd_running = 0;
+			usbduxsub_unlink_InURBs(usbduxsub_tmp);
+		}
+		for (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {
+			kfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);
+			usbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;
+			usb_kill_urb(usbduxsub_tmp->urbIn[i]);
+			usb_free_urb(usbduxsub_tmp->urbIn[i]);
+			usbduxsub_tmp->urbIn[i] = NULL;
+		}
+		kfree(usbduxsub_tmp->urbIn);
+		usbduxsub_tmp->urbIn = NULL;
+	}
+	if (usbduxsub_tmp->urbOut) {
+		if (usbduxsub_tmp->ao_cmd_running) {
+			usbduxsub_tmp->ao_cmd_running = 0;
+			usbduxsub_unlink_OutURBs(usbduxsub_tmp);
+		}
+		for (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {
+			if (usbduxsub_tmp->urbOut[i]->transfer_buffer) {
+				kfree(usbduxsub_tmp->
+				      urbOut[i]->transfer_buffer);
+				usbduxsub_tmp->urbOut[i]->transfer_buffer =
+				    NULL;
+			}
+			if (usbduxsub_tmp->urbOut[i]) {
+				usb_kill_urb(usbduxsub_tmp->urbOut[i]);
+				usb_free_urb(usbduxsub_tmp->urbOut[i]);
+				usbduxsub_tmp->urbOut[i] = NULL;
+			}
+		}
+		kfree(usbduxsub_tmp->urbOut);
+		usbduxsub_tmp->urbOut = NULL;
+	}
+	if (usbduxsub_tmp->urbPwm) {
+		if (usbduxsub_tmp->pwm_cmd_running) {
+			usbduxsub_tmp->pwm_cmd_running = 0;
+			usbduxsub_unlink_PwmURBs(usbduxsub_tmp);
+		}
+		kfree(usbduxsub_tmp->urbPwm->transfer_buffer);
+		usbduxsub_tmp->urbPwm->transfer_buffer = NULL;
+		usb_kill_urb(usbduxsub_tmp->urbPwm);
+		usb_free_urb(usbduxsub_tmp->urbPwm);
+		usbduxsub_tmp->urbPwm = NULL;
+	}
+	kfree(usbduxsub_tmp->inBuffer);
+	usbduxsub_tmp->inBuffer = NULL;
+	kfree(usbduxsub_tmp->insnBuffer);
+	usbduxsub_tmp->insnBuffer = NULL;
+	kfree(usbduxsub_tmp->outBuffer);
+	usbduxsub_tmp->outBuffer = NULL;
+	kfree(usbduxsub_tmp->dac_commands);
+	usbduxsub_tmp->dac_commands = NULL;
+	kfree(usbduxsub_tmp->dux_commands);
+	usbduxsub_tmp->dux_commands = NULL;
+	usbduxsub_tmp->ai_cmd_running = 0;
+	usbduxsub_tmp->ao_cmd_running = 0;
+	usbduxsub_tmp->pwm_cmd_running = 0;
+}
+
+static void usbdux_firmware_request_complete_handler(const struct firmware *fw,
+						     void *context)
+{
+	struct usbduxsub *usbduxsub_tmp = context;
+	struct usb_device *usbdev = usbduxsub_tmp->usbdev;
+	int ret;
+
+	if (fw == NULL) {
+		dev_err(&usbdev->dev,
+			"Firmware complete handler without firmware!\n");
+		return;
+	}
+
+	/*
+	 * we need to upload the firmware here because fw will be
+	 * freed once we've left this function
+	 */
+	ret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);
+
+	if (ret) {
+		dev_err(&usbdev->dev,
+			"Could not upload firmware (err=%d)\n", ret);
+		goto out;
+	}
+	comedi_usb_auto_config(usbdev, BOARDNAME);
+out:
+	release_firmware(fw);
+}
+
+/* allocate memory for the urbs and initialise them */
+static int usbduxsigma_probe(struct usb_interface *uinterf,
+			   const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(uinterf);
+	struct device *dev = &uinterf->dev;
+	int i;
+	int index;
+	int ret;
+
+	dev_dbg(dev, "comedi_: usbdux_: "
+		"finding a free structure for the usb-device\n");
+
+	down(&start_stop_sem);
+	/* look for a free place in the usbdux array */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if (!(usbduxsub[i].probed)) {
+			index = i;
+			break;
+		}
+	}
+
+	/* no more space */
+	if (index == -1) {
+		dev_err(dev, "Too many usbduxsigma-devices connected.\n");
+		up(&start_stop_sem);
+		return -EMFILE;
+	}
+	dev_dbg(dev, "comedi_: usbdux: "
+		"usbduxsub[%d] is ready to connect to comedi.\n", index);
+
+	sema_init(&(usbduxsub[index].sem), 1);
+	/* save a pointer to the usb device */
+	usbduxsub[index].usbdev = udev;
+
+	/* save the interface itself */
+	usbduxsub[index].interface = uinterf;
+	/* get the interface number from the interface */
+	usbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
+	/* hand the private data over to the usb subsystem */
+	/* will be needed for disconnect */
+	usb_set_intfdata(uinterf, &(usbduxsub[index]));
+
+	dev_dbg(dev, "comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);
+
+	/* test if it is high speed (USB 2.0) */
+	usbduxsub[index].high_speed =
+	    (usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);
+
+	/* create space for the commands of the DA converter */
+	usbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);
+	if (!usbduxsub[index].dac_commands) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"error alloc space for dac commands\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	/* create space for the commands going to the usb device */
+	usbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);
+	if (!usbduxsub[index].dux_commands) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"error alloc space for dux commands\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	/* create space for the in buffer and set it to zero */
+	usbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].inBuffer)) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"could not alloc space for inBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	/* create space of the instruction buffer */
+	usbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].insnBuffer)) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"could not alloc space for insnBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	/* create space for the outbuffer */
+	usbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);
+	if (!(usbduxsub[index].outBuffer)) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"could not alloc space for outBuffer\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	/* setting to alternate setting 3: enabling iso ep and bulk ep. */
+	i = usb_set_interface(usbduxsub[index].usbdev,
+			      usbduxsub[index].ifnum, 3);
+	if (i < 0) {
+		dev_err(dev, "comedi_: usbduxsigma%d: "
+			"could not set alternate setting 3 in high speed.\n",
+			index);
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENODEV;
+	}
+	if (usbduxsub[index].high_speed)
+		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;
+	else
+		usbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;
+
+	usbduxsub[index].urbIn =
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,
+		    GFP_KERNEL);
+	if (!(usbduxsub[index].urbIn)) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"Could not alloc. urbIn array\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	for (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {
+		/* one frame: 1ms */
+		usbduxsub[index].urbIn[i] = usb_alloc_urb(1, GFP_KERNEL);
+		if (usbduxsub[index].urbIn[i] == NULL) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"Could not alloc. urb(%d)\n", index, i);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+		usbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		usbduxsub[index].urbIn[i]->context = NULL;
+		usbduxsub[index].urbIn[i]->pipe =
+		    usb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);
+		usbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urbIn[i]->transfer_buffer =
+		    kzalloc(SIZEINBUF, GFP_KERNEL);
+		if (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"could not alloc. transb.\n", index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+		usbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;
+		usbduxsub[index].urbIn[i]->number_of_packets = 1;
+		usbduxsub[index].urbIn[i]->transfer_buffer_length = SIZEINBUF;
+		usbduxsub[index].urbIn[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urbIn[i]->iso_frame_desc[0].length =
+			SIZEINBUF;
+	}
+
+	/* out */
+	if (usbduxsub[index].high_speed)
+		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;
+	else
+		usbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;
+
+	usbduxsub[index].urbOut =
+	    kzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,
+		    GFP_KERNEL);
+	if (!(usbduxsub[index].urbOut)) {
+		dev_err(dev, "comedi_: usbduxsigma: "
+			"Could not alloc. urbOut array\n");
+		tidy_up(&(usbduxsub[index]));
+		up(&start_stop_sem);
+		return -ENOMEM;
+	}
+	for (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {
+		/* one frame: 1ms */
+		usbduxsub[index].urbOut[i] = usb_alloc_urb(1, GFP_KERNEL);
+		if (usbduxsub[index].urbOut[i] == NULL) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"Could not alloc. urb(%d)\n", index, i);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+		usbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;
+		/* will be filled later with a pointer to the comedi-device */
+		/* and ONLY then the urb should be submitted */
+		usbduxsub[index].urbOut[i]->context = NULL;
+		usbduxsub[index].urbOut[i]->pipe =
+		    usb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);
+		usbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;
+		usbduxsub[index].urbOut[i]->transfer_buffer =
+		    kzalloc(SIZEOUTBUF, GFP_KERNEL);
+		if (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"could not alloc. transb.\n", index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+		usbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;
+		usbduxsub[index].urbOut[i]->number_of_packets = 1;
+		usbduxsub[index].urbOut[i]->transfer_buffer_length =
+			SIZEOUTBUF;
+		usbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;
+		usbduxsub[index].urbOut[i]->iso_frame_desc[0].length =
+		    SIZEOUTBUF;
+		if (usbduxsub[index].high_speed) {
+			/* uframes */
+			usbduxsub[index].urbOut[i]->interval = 8;
+		} else {
+			/* frames */
+			usbduxsub[index].urbOut[i]->interval = 1;
+		}
+	}
+
+	/* pwm */
+	if (usbduxsub[index].high_speed) {
+		/* max bulk ep size in high speed */
+		usbduxsub[index].sizePwmBuf = 512;
+		usbduxsub[index].urbPwm = usb_alloc_urb(0, GFP_KERNEL);
+		if (usbduxsub[index].urbPwm == NULL) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"Could not alloc. pwm urb\n", index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+		usbduxsub[index].urbPwm->transfer_buffer =
+		    kzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);
+		if (!(usbduxsub[index].urbPwm->transfer_buffer)) {
+			dev_err(dev, "comedi_: usbduxsigma%d: "
+				"could not alloc. transb. for pwm\n", index);
+			tidy_up(&(usbduxsub[index]));
+			up(&start_stop_sem);
+			return -ENOMEM;
+		}
+	} else {
+		usbduxsub[index].urbPwm = NULL;
+		usbduxsub[index].sizePwmBuf = 0;
+	}
+
+	usbduxsub[index].ai_cmd_running = 0;
+	usbduxsub[index].ao_cmd_running = 0;
+	usbduxsub[index].pwm_cmd_running = 0;
+
+	/* we've reached the bottom of the function */
+	usbduxsub[index].probed = 1;
+	up(&start_stop_sem);
+
+	ret = request_firmware_nowait(THIS_MODULE,
+				      FW_ACTION_HOTPLUG,
+				      "usbduxsigma_firmware.bin",
+				      &udev->dev,
+				      GFP_KERNEL,
+				      usbduxsub + index,
+				      usbdux_firmware_request_complete_handler
+				      );
+
+	if (ret) {
+		dev_err(dev, "Could not load firmware (err=%d)\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "comedi_: successfully initialised.\n");
+	/* success */
+	return 0;
+}
+
+static void usbduxsigma_disconnect(struct usb_interface *intf)
+{
+	struct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	if (!usbduxsub_tmp) {
+		dev_err(&intf->dev,
+			"comedi_: disconnect called with null pointer.\n");
+		return;
+	}
+	if (usbduxsub_tmp->usbdev != udev) {
+		dev_err(&intf->dev, "comedi_: BUG! wrong ptr!\n");
+		return;
+	}
+	if (usbduxsub_tmp->ai_cmd_running)
+		/* we are still running a command */
+		usbdux_ai_stop(usbduxsub_tmp, 1);
+	if (usbduxsub_tmp->ao_cmd_running)
+		/* we are still running a command */
+		usbdux_ao_stop(usbduxsub_tmp, 1);
+	comedi_usb_auto_unconfig(udev);
+	down(&start_stop_sem);
+	down(&usbduxsub_tmp->sem);
+	tidy_up(usbduxsub_tmp);
+	up(&usbduxsub_tmp->sem);
+	up(&start_stop_sem);
+	dev_info(&intf->dev, "comedi_: disconnected from the usb\n");
+}
+
+/* is called when comedi-config is called */
+static int usbduxsigma_attach(struct comedi_device *dev,
+			      struct comedi_devconfig *it)
+{
+	int ret;
+	int index;
+	int i;
+	struct usbduxsub *udev;
+
+	int offset;
+
+	struct comedi_subdevice *s = NULL;
+	dev->private = NULL;
+
+	down(&start_stop_sem);
+	/* find a valid device which has been detected by the probe function of
+	 * the usb */
+	index = -1;
+	for (i = 0; i < NUMUSBDUX; i++) {
+		if ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {
+			index = i;
+			break;
+		}
+	}
+
+	if (index < 0) {
+		printk(KERN_ERR "comedi%d: usbduxsigma: error: attach failed,"
+		       "dev not connected to the usb bus.\n", dev->minor);
+		up(&start_stop_sem);
+		return -ENODEV;
+	}
+
+	udev = &usbduxsub[index];
+	down(&udev->sem);
+	/* pointer back to the corresponding comedi device */
+	udev->comedidev = dev;
+
+	/* trying to upload the firmware into the FX2 */
+	if (comedi_aux_data(it->options, 0) &&
+	    it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
+		firmwareUpload(udev, comedi_aux_data(it->options, 0),
+			       it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);
+	}
+
+	dev->board_name = BOARDNAME;
+
+	/* set number of subdevices */
+	if (udev->high_speed) {
+		/* with pwm */
+		dev->n_subdevices = 4;
+	} else {
+		/* without pwm */
+		dev->n_subdevices = 3;
+	}
+
+	/* allocate space for the subdevices */
+	ret = alloc_subdevices(dev, dev->n_subdevices);
+	if (ret < 0) {
+		dev_err(&udev->interface->dev,
+			"comedi%d: no space for subdev\n", dev->minor);
+		up(&start_stop_sem);
+		return ret;
+	}
+
+	/* private structure is also simply the usb-structure */
+	dev->private = udev;
+
+	/* the first subdevice is the A/D converter */
+	s = dev->subdevices + SUBDEV_AD;
+	/* the URBs get the comedi subdevice */
+	/* which is responsible for reading */
+	/* this is the subdevice which reads data */
+	dev->read_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* analog input */
+	s->type = COMEDI_SUBD_AI;
+	/* readable and ref is to ground, 32 bit wide data! */
+	s->subdev_flags = SDF_READABLE | SDF_GROUND |
+		SDF_CMD_READ | SDF_LSAMPL;
+	/* 16 A/D channels */
+	s->n_chan = NUMCHANNELS;
+	/* length of the channellist */
+	s->len_chanlist = NUMCHANNELS;
+	/* callback functions */
+	s->insn_read = usbdux_ai_insn_read;
+	s->do_cmdtest = usbdux_ai_cmdtest;
+	s->do_cmd = usbdux_ai_cmd;
+	s->cancel = usbdux_ai_cancel;
+	/* max value from the A/D converter (24bit) */
+	s->maxdata = 0x00FFFFFF;
+	/* range table to convert to physical units */
+	s->range_table = (&range_usbdux_ai_range);
+
+	/* analog out */
+	s = dev->subdevices + SUBDEV_DA;
+	/* analog out */
+	s->type = COMEDI_SUBD_AO;
+	/* backward pointer */
+	dev->write_subdev = s;
+	/* the subdevice receives as private structure the */
+	/* usb-structure */
+	s->private = NULL;
+	/* are writable */
+	s->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;
+	/* 4 channels */
+	s->n_chan = 4;
+	/* length of the channellist */
+	s->len_chanlist = 4;
+	/* 8 bit resolution */
+	s->maxdata = 0x00ff;
+	/* unipolar range */
+	s->range_table = (&range_usbdux_ao_range);
+	/* callback */
+	s->do_cmdtest = usbdux_ao_cmdtest;
+	s->do_cmd = usbdux_ao_cmd;
+	s->cancel = usbdux_ao_cancel;
+	s->insn_read = usbdux_ao_insn_read;
+	s->insn_write = usbdux_ao_insn_write;
+
+	/* digital I/O */
+	s = dev->subdevices + SUBDEV_DIO;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	/* 8 external and 16 internal channels */
+	s->n_chan = 24;
+	s->maxdata = 1;
+	s->range_table = (&range_digital);
+	s->insn_bits = usbdux_dio_insn_bits;
+	s->insn_config = usbdux_dio_insn_config;
+	/* we don't use it */
+	s->private = NULL;
+
+	if (udev->high_speed) {
+		/* timer / pwm */
+		s = dev->subdevices + SUBDEV_PWM;
+		s->type = COMEDI_SUBD_PWM;
+		s->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;
+		s->n_chan = 8;
+		/* this defines the max duty cycle resolution */
+		s->maxdata = udev->sizePwmBuf;
+		s->insn_write = usbdux_pwm_write;
+		s->insn_read = usbdux_pwm_read;
+		s->insn_config = usbdux_pwm_config;
+		usbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);
+	}
+	/* finally decide that it's attached */
+	udev->attached = 1;
+
+	up(&udev->sem);
+
+	up(&start_stop_sem);
+
+	offset = usbdux_getstatusinfo(dev, 0);
+	if (offset < 0)
+		dev_err(&udev->interface->dev,
+			"Communication to USBDUXSIGMA failed!"
+			"Check firmware and cabling.");
+
+	dev_info(&udev->interface->dev,
+		 "comedi%d: attached, ADC_zero = %x", dev->minor, offset);
+
+	return 0;
+}
+
+static int usbduxsigma_detach(struct comedi_device *dev)
+{
+	struct usbduxsub *usbduxsub_tmp;
+
+	if (!dev) {
+		printk(KERN_ERR
+		       "comedi? usbduxsigma detach: dev=NULL\n");
+		return -EFAULT;
+	}
+
+	usbduxsub_tmp = dev->private;
+	if (!usbduxsub_tmp) {
+		printk(KERN_ERR
+		       "comedi?: usbduxsigma detach: private=NULL\n");
+		return -EFAULT;
+	}
+
+	dev_dbg(&usbduxsub_tmp->interface->dev,
+		"comedi%d: detach usb device\n",
+		dev->minor);
+
+	down(&usbduxsub_tmp->sem);
+	/* Don't allow detach to free the private structure */
+	/* It's one entry of of usbduxsub[] */
+	dev->private = NULL;
+	usbduxsub_tmp->attached = 0;
+	usbduxsub_tmp->comedidev = NULL;
+	dev_info(&usbduxsub_tmp->interface->dev,
+		"comedi%d: successfully detached.\n", dev->minor);
+	up(&usbduxsub_tmp->sem);
+	return 0;
+}
+
+/* main driver struct */
+static struct comedi_driver driver_usbduxsigma = {
+	.driver_name = "usbduxsigma",
+	.module = THIS_MODULE,
+	.attach = usbduxsigma_attach,
+	.detach = usbduxsigma_detach,
+};
+
+/* Table with the USB-devices */
+static const struct usb_device_id usbduxsigma_table[] = {
+	{USB_DEVICE(0x13d8, 0x0020)},
+	{USB_DEVICE(0x13d8, 0x0021)},
+	{USB_DEVICE(0x13d8, 0x0022)},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, usbduxsigma_table);
+
+/* The usbduxsub-driver */
+static struct usb_driver usbduxsigma_driver = {
+	.name = BOARDNAME,
+	.probe = usbduxsigma_probe,
+	.disconnect = usbduxsigma_disconnect,
+	.id_table = usbduxsigma_table,
+};
+
+/* Can't use the nice macro as I have also to initialise the USB */
+/* subsystem: */
+/* registering the usb-system _and_ the comedi-driver */
+static int __init init_usbduxsigma(void)
+{
+	printk(KERN_INFO KBUILD_MODNAME ": "
+	       DRIVER_VERSION ":" DRIVER_DESC "\n");
+	usb_register(&usbduxsigma_driver);
+	comedi_driver_register(&driver_usbduxsigma);
+	return 0;
+}
+
+/* deregistering the comedi driver and the usb-subsystem */
+static void __exit exit_usbduxsigma(void)
+{
+	comedi_driver_unregister(&driver_usbduxsigma);
+	usb_deregister(&usbduxsigma_driver);
+}
+
+module_init(init_usbduxsigma);
+module_exit(exit_usbduxsigma);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
