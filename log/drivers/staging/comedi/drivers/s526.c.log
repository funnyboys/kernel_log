commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 3f867418953c..5d567ae78f28 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e226275972c0..3f867418953c 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * s526.c
  * Sensoray s526 Comedi driver

commit 0cb7e343dec26a896d954419022c5ff1510d5aea
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Oct 12 11:16:37 2017 -0500

    staging: comedi: s526: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index c80527db9c19..e226275972c0 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -408,9 +408,8 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		 */
 		if ((data[1] <= data[0]) || !data[0])
 			return -EINVAL;
-
-		/* Fall thru to write the PULSE_WIDTH */
-
+		/* to write the PULSE_WIDTH */
+		/* fall through */
 	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
 	case INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR:
 		s526_gpct_write(dev, chan, data[0]);

commit e5417e49965a47f690fe33ab5b27011c86ef89b5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 19 14:49:08 2015 +0000

    staging: comedi: s526: add macros for counter control reg values
    
    The driver writes a couple of literal values to the counter
    control/status register, 0x8000 to reset the counter, and 0x4000 to load
    the counter from preload register 0.  Add a bunch of macros to define
    these values and other values for the register, based on the Sensoray
    526 manual.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index a8165dfe6f5f..c80527db9c19 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -139,7 +139,36 @@
 #define S526_GPCT_MODE_PR_SELECT_MASK	S526_GPCT_MODE_PR_SELECT(0x1)
 #define S526_GPCT_MODE_PR_SELECT_PR0	S526_GPCT_MODE_PR_SELECT(0)
 #define S526_GPCT_MODE_PR_SELECT_PR1	S526_GPCT_MODE_PR_SELECT(1)
+/* Control/Status - R = readable, W = writeable, C = write 1 to clear */
 #define S526_GPCT_CTRL_REG(x)	(0x18 + ((x) * 8))
+#define S526_GPCT_CTRL_EV_STATUS(x)	((x) << 0)		/* RC */
+#define S526_GPCT_CTRL_EV_STATUS_MASK	S526_GPCT_EV_STATUS(0xf)
+#define S526_GPCT_CTRL_EV_STATUS_NONE	S526_GPCT_EV_STATUS(0)
+/* these 4 bits can be OR'ed */
+#define S526_GPCT_CTRL_EV_STATUS_ECAP	S526_GPCT_EV_STATUS(0x1)
+#define S526_GPCT_CTRL_EV_STATUS_ICAPN	S526_GPCT_EV_STATUS(0x2)
+#define S526_GPCT_CTRL_EV_STATUS_ICAPP	S526_GPCT_EV_STATUS(0x4)
+#define S526_GPCT_CTRL_EV_STATUS_RCAP	S526_GPCT_EV_STATUS(0x8)
+#define S526_GPCT_CTRL_COUT_STATUS	BIT(4)			/* R */
+#define S526_GPCT_CTRL_INDEX_STATUS	BIT(5)			/* R */
+#define S525_GPCT_CTRL_INTEN(x)		((x) << 6)		/* W */
+#define S525_GPCT_CTRL_INTEN_MASK	S526_GPCT_CTRL_INTEN(0xf)
+#define S525_GPCT_CTRL_INTEN_NONE	S526_GPCT_CTRL_INTEN(0)
+/* these 4 bits can be OR'ed */
+#define S525_GPCT_CTRL_INTEN_ERROR	S526_GPCT_CTRL_INTEN(0x1)
+#define S525_GPCT_CTRL_INTEN_IXFALL	S526_GPCT_CTRL_INTEN(0x2)
+#define S525_GPCT_CTRL_INTEN_IXRISE	S526_GPCT_CTRL_INTEN(0x4)
+#define S525_GPCT_CTRL_INTEN_RO		S526_GPCT_CTRL_INTEN(0x8)
+#define S525_GPCT_CTRL_LATCH_SEL(x)	((x) << 10)		/* W */
+#define S525_GPCT_CTRL_LATCH_SEL_MASK	S526_GPCT_CTRL_LATCH_SEL(0x7)
+#define S525_GPCT_CTRL_LATCH_SEL_NONE	S526_GPCT_CTRL_LATCH_SEL(0)
+/* these 3 bits can be OR'ed */
+#define S525_GPCT_CTRL_LATCH_SEL_IXFALL	S526_GPCT_CTRL_LATCH_SEL(0x1)
+#define S525_GPCT_CTRL_LATCH_SEL_IXRISE	S526_GPCT_CTRL_LATCH_SEL(0x2)
+#define S525_GPCT_CTRL_LATCH_SEL_ITIMER	S526_GPCT_CTRL_LATCH_SEL(0x4)
+#define S525_GPCT_CTRL_CT_ARM		BIT(13)			/* W */
+#define S525_GPCT_CTRL_CT_LOAD		BIT(14)			/* W */
+#define S526_GPCT_CTRL_CT_RESET		BIT(15)			/* W */
 #define S526_EEPROM_DATA_REG	0x32
 #define S526_EEPROM_CTRL_REG	0x34
 #define S526_EEPROM_CTRL_ADDR(x) (((x) & 0x3f) << 3)
@@ -218,10 +247,12 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		if ((val & S526_GPCT_MODE_AUTOLOAD_MASK) ==
 		    S526_GPCT_MODE_AUTOLOAD_NONE) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
+			outw(S526_GPCT_CTRL_CT_RESET,
+			     dev->iobase + S526_GPCT_CTRL_REG(chan));
 			/*
 			 * Load the counter from PR0
-			 * outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
+			 * outw(S526_GPCT_CTRL_CT_LOAD,
+			 *      dev->iobase + S526_GPCT_CTRL_REG(chan));
 			 */
 		}
 #else
@@ -265,9 +296,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		if ((val & S526_GPCT_MODE_AUTOLOAD_MASK) ==
 		    S526_GPCT_MODE_AUTOLOAD_NONE) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
+			outw(S526_GPCT_CTRL_CT_RESET,
+			     dev->iobase + S526_GPCT_CTRL_REG(chan));
 			/*  Load the counter from PR0 */
-			outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
+			outw(S526_GPCT_CTRL_CT_LOAD,
+			     dev->iobase + S526_GPCT_CTRL_REG(chan));
 		}
 #endif
 		break;

commit 479bd5edab3ca840ba60a89d3172029039ddc2a6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu Nov 19 14:49:07 2015 +0000

    staging: comedi: s526: replace counter mode bitfield struct
    
    The driver uses `struct counter_mode_register_t` to describe the 16-bit
    counter mode register as a sequence of bitfield members.  The struct
    appears as the type of one of the members of `union cmReg`, the other
    member of which is of type `unsigned short`, so the driver can
    manipulate the register value as a whole, or as individual fields.
    Although this is fairly convenient, it's not that conventional.  The
    code also needs to define the bitfield members in ascending or
    descending order of the physical bits, depending on whether bitfields
    are little- or big-endian.
    
    Rip all that out and replace it with a bunch of macros to set and mask
    out bits of the register value, as that's the more conventional way to
    do it.  A bonus is that we get rid of a load of CamelCase definitions in
    the process.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d70c97947627..a8165dfe6f5f 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -37,7 +37,6 @@
 
 #include <linux/module.h>
 #include "../comedidev.h"
-#include <asm/byteorder.h>
 
 /*
  * Register I/O map
@@ -84,6 +83,62 @@
 #define S526_GPCT_LSB_REG(x)	(0x12 + ((x) * 8))
 #define S526_GPCT_MSB_REG(x)	(0x14 + ((x) * 8))
 #define S526_GPCT_MODE_REG(x)	(0x16 + ((x) * 8))
+#define S526_GPCT_MODE_COUT_SRC(x)	((x) << 0)
+#define S526_GPCT_MODE_COUT_SRC_MASK	S526_GPCT_MODE_COUT_SRC(0x1)
+#define S526_GPCT_MODE_COUT_SRC_RCAP	S526_GPCT_MODE_COUT_SRC(0)
+#define S526_GPCT_MODE_COUT_SRC_RTGL	S526_GPCT_MODE_COUT_SRC(1)
+#define S526_GPCT_MODE_COUT_POL(x)	((x) << 1)
+#define S526_GPCT_MODE_COUT_POL_MASK	S526_GPCT_MODE_COUT_POL(0x1)
+#define S526_GPCT_MODE_COUT_POL_NORM	S526_GPCT_MODE_COUT_POL(0)
+#define S526_GPCT_MODE_COUT_POL_INV	S526_GPCT_MODE_COUT_POL(1)
+#define S526_GPCT_MODE_AUTOLOAD(x)	((x) << 2)
+#define S526_GPCT_MODE_AUTOLOAD_MASK	S526_GPCT_MODE_AUTOLOAD(0x7)
+#define S526_GPCT_MODE_AUTOLOAD_NONE	S526_GPCT_MODE_AUTOLOAD(0)
+/* these 3 bits can be OR'ed */
+#define S526_GPCT_MODE_AUTOLOAD_RO	S526_GPCT_MODE_AUTOLOAD(0x1)
+#define S526_GPCT_MODE_AUTOLOAD_IXFALL	S526_GPCT_MODE_AUTOLOAD(0x2)
+#define S526_GPCT_MODE_AUTOLOAD_IXRISE	S526_GPCT_MODE_AUTOLOAD(0x4)
+#define S526_GPCT_MODE_HWCTEN_SRC(x)	((x) << 5)
+#define S526_GPCT_MODE_HWCTEN_SRC_MASK	S526_GPCT_MODE_HWCTEN_SRC(0x3)
+#define S526_GPCT_MODE_HWCTEN_SRC_CEN	S526_GPCT_MODE_HWCTEN_SRC(0)
+#define S526_GPCT_MODE_HWCTEN_SRC_IX	S526_GPCT_MODE_HWCTEN_SRC(1)
+#define S526_GPCT_MODE_HWCTEN_SRC_IXRF	S526_GPCT_MODE_HWCTEN_SRC(2)
+#define S526_GPCT_MODE_HWCTEN_SRC_NRCAP	S526_GPCT_MODE_HWCTEN_SRC(3)
+#define S526_GPCT_MODE_CTEN_CTRL(x)	((x) << 7)
+#define S526_GPCT_MODE_CTEN_CTRL_MASK	S526_GPCT_MODE_CTEN_CTRL(0x3)
+#define S526_GPCT_MODE_CTEN_CTRL_DIS	S526_GPCT_MODE_CTEN_CTRL(0)
+#define S526_GPCT_MODE_CTEN_CTRL_ENA	S526_GPCT_MODE_CTEN_CTRL(1)
+#define S526_GPCT_MODE_CTEN_CTRL_HW	S526_GPCT_MODE_CTEN_CTRL(2)
+#define S526_GPCT_MODE_CTEN_CTRL_INVHW	S526_GPCT_MODE_CTEN_CTRL(3)
+#define S526_GPCT_MODE_CLK_SRC(x)	((x) << 9)
+#define S526_GPCT_MODE_CLK_SRC_MASK	S526_GPCT_MODE_CLK_SRC(0x3)
+/* if count direction control set to quadrature */
+#define S526_GPCT_MODE_CLK_SRC_QUADX1	S526_GPCT_MODE_CLK_SRC(0)
+#define S526_GPCT_MODE_CLK_SRC_QUADX2	S526_GPCT_MODE_CLK_SRC(1)
+#define S526_GPCT_MODE_CLK_SRC_QUADX4	S526_GPCT_MODE_CLK_SRC(2)
+#define S526_GPCT_MODE_CLK_SRC_QUADX4_	S526_GPCT_MODE_CLK_SRC(3)
+/* if count direction control set to software control */
+#define S526_GPCT_MODE_CLK_SRC_ARISE	S526_GPCT_MODE_CLK_SRC(0)
+#define S526_GPCT_MODE_CLK_SRC_AFALL	S526_GPCT_MODE_CLK_SRC(1)
+#define S526_GPCT_MODE_CLK_SRC_INT	S526_GPCT_MODE_CLK_SRC(2)
+#define S526_GPCT_MODE_CLK_SRC_INTHALF	S526_GPCT_MODE_CLK_SRC(3)
+#define S526_GPCT_MODE_CT_DIR(x)	((x) << 11)
+#define S526_GPCT_MODE_CT_DIR_MASK	S526_GPCT_MODE_CT_DIR(0x1)
+/* if count direction control set to software control */
+#define S526_GPCT_MODE_CT_DIR_UP	S526_GPCT_MODE_CT_DIR(0)
+#define S526_GPCT_MODE_CT_DIR_DOWN	S526_GPCT_MODE_CT_DIR(1)
+#define S526_GPCT_MODE_CTDIR_CTRL(x)	((x) << 12)
+#define S526_GPCT_MODE_CTDIR_CTRL_MASK	S526_GPCT_MODE_CTDIR_CTRL(0x1)
+#define S526_GPCT_MODE_CTDIR_CTRL_QUAD	S526_GPCT_MODE_CTDIR_CTRL(0)
+#define S526_GPCT_MODE_CTDIR_CTRL_SOFT	S526_GPCT_MODE_CTDIR_CTRL(1)
+#define S526_GPCT_MODE_LATCH_CTRL(x)	((x) << 13)
+#define S526_GPCT_MODE_LATCH_CTRL_MASK	S526_GPCT_MODE_LATCH_CTRL(0x1)
+#define S526_GPCT_MODE_LATCH_CTRL_READ	S526_GPCT_MODE_LATCH_CTRL(0)
+#define S526_GPCT_MODE_LATCH_CTRL_EVENT	S526_GPCT_MODE_LATCH_CTRL(1)
+#define S526_GPCT_MODE_PR_SELECT(x)	((x) << 14)
+#define S526_GPCT_MODE_PR_SELECT_MASK	S526_GPCT_MODE_PR_SELECT(0x1)
+#define S526_GPCT_MODE_PR_SELECT_PR0	S526_GPCT_MODE_PR_SELECT(0)
+#define S526_GPCT_MODE_PR_SELECT_PR1	S526_GPCT_MODE_PR_SELECT(1)
 #define S526_GPCT_CTRL_REG(x)	(0x18 + ((x) * 8))
 #define S526_EEPROM_DATA_REG	0x32
 #define S526_EEPROM_CTRL_REG	0x34
@@ -92,41 +147,6 @@
 #define S526_EEPROM_CTRL_READ	S526_EEPROM_CTRL(2)
 #define S526_EEPROM_CTRL_START	BIT(0)
 
-struct counter_mode_register_t {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	unsigned short coutSource:1;
-	unsigned short coutPolarity:1;
-	unsigned short autoLoadResetRcap:3;
-	unsigned short hwCtEnableSource:2;
-	unsigned short ctEnableCtrl:2;
-	unsigned short clockSource:2;
-	unsigned short countDir:1;
-	unsigned short countDirCtrl:1;
-	unsigned short outputRegLatchCtrl:1;
-	unsigned short preloadRegSel:1;
-	unsigned short reserved:1;
- #elif defined(__BIG_ENDIAN_BITFIELD)
-	unsigned short reserved:1;
-	unsigned short preloadRegSel:1;
-	unsigned short outputRegLatchCtrl:1;
-	unsigned short countDirCtrl:1;
-	unsigned short countDir:1;
-	unsigned short clockSource:2;
-	unsigned short ctEnableCtrl:2;
-	unsigned short hwCtEnableSource:2;
-	unsigned short autoLoadResetRcap:3;
-	unsigned short coutPolarity:1;
-	unsigned short coutSource:1;
-#else
-#error Unknown bit field order
-#endif
-};
-
-union cmReg {
-	struct counter_mode_register_t reg;
-	unsigned short value;
-};
-
 struct s526_private {
 	unsigned int gpct_config[4];
 	unsigned short ai_ctrl;
@@ -174,7 +194,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int val;
-	union cmReg cmReg;
 
 	/*
 	 * Check what type of Counter the user requested
@@ -192,28 +211,29 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 #if 1
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/*  Reset the counter if it is software preload */
-		if (cmReg.reg.autoLoadResetRcap == 0) {
+		if ((val & S526_GPCT_MODE_AUTOLOAD_MASK) ==
+		    S526_GPCT_MODE_AUTOLOAD_NONE) {
 			/*  Reset the counter */
 			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
-			/* Load the counter from PR0
+			/*
+			 * Load the counter from PR0
 			 * outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 			 */
 		}
 #else
-		/*  0 quadrature, 1 software control */
-		cmReg.reg.countDirCtrl = 0;
+		val = S526_GPCT_MODE_CTDIR_CTRL_QUAD;
 
 		/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */
 		if (data[1] == GPCT_X2)
-			cmReg.reg.clockSource = 1;
+			val |= S526_GPCT_MODE_CLK_SRC_QUADX2;
 		else if (data[1] == GPCT_X4)
-			cmReg.reg.clockSource = 2;
+			val |= S526_GPCT_MODE_CLK_SRC_QUADX4;
 		else
-			cmReg.reg.clockSource = 0;
+			val |= S526_GPCT_MODE_CLK_SRC_QUADX1;
 
 		/*  When to take into account the indexpulse: */
 		/*
@@ -224,13 +244,14 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		 * }
 		 */
 		/*  Take into account the index pulse? */
-		if (data[3] == GPCT_RESET_COUNTER_ON_INDEX)
+		if (data[3] == GPCT_RESET_COUNTER_ON_INDEX) {
 			/*  Auto load with INDEX^ */
-			cmReg.reg.autoLoadResetRcap = 4;
+			val |= S526_GPCT_MODE_AUTOLOAD_IXRISE;
+		}
 
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/*  Load the pre-load register */
 		s526_gpct_write(dev, chan, data[2]);
@@ -241,7 +262,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 			     dev->iobase + S526_GPCT_CTRL_REG(chan));
 
 		/*  Reset the counter if it is software preload */
-		if (cmReg.reg.autoLoadResetRcap == 0) {
+		if ((val & S526_GPCT_MODE_AUTOLOAD_MASK) ==
+		    S526_GPCT_MODE_AUTOLOAD_NONE) {
 			/*  Reset the counter */
 			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 			/*  Load the counter from PR0 */
@@ -261,17 +283,21 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		devpriv->gpct_config[chan] = data[0];
 
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		/* Select PR0 */
+		val &= ~S526_GPCT_MODE_PR_SELECT_MASK;
+		val |= S526_GPCT_MODE_PR_SELECT_PR0;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/* Load the pre-load register 0 */
 		s526_gpct_write(dev, chan, data[2]);
 
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		/* Select PR1 */
+		val &= ~S526_GPCT_MODE_PR_SELECT_MASK;
+		val |= S526_GPCT_MODE_PR_SELECT_PR1;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/* Load the pre-load register 1 */
 		s526_gpct_write(dev, chan, data[3]);
@@ -294,17 +320,21 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		devpriv->gpct_config[chan] = data[0];
 
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		/* Select PR0 */
+		val &= ~S526_GPCT_MODE_PR_SELECT_MASK;
+		val |= S526_GPCT_MODE_PR_SELECT_PR0;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/* Load the pre-load register 0 */
 		s526_gpct_write(dev, chan, data[2]);
 
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xffff;
-		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
+		val = data[1] & 0xffff;
+		/* Select PR1 */
+		val &= ~S526_GPCT_MODE_PR_SELECT_MASK;
+		val |= S526_GPCT_MODE_PR_SELECT_PR1;
+		outw(val, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/* Load the pre-load register 1 */
 		s526_gpct_write(dev, chan, data[3]);

commit a399d81d41e17410ffd7a84af9bd7ec8aafa58a2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:27 2015 -0700

    staging: comedi: s526: fix the block comments
    
    Tidy up the block comments to fix the checkpatch.pl warnings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 43f9c0c3b3fc..d70c97947627 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -176,15 +176,17 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	unsigned int val;
 	union cmReg cmReg;
 
-	/*  Check what type of Counter the user requested, data[0] contains */
-	/*  the Application type */
+	/*
+	 * Check what type of Counter the user requested
+	 * data[0] contains the Application type
+	 */
 	switch (data[0]) {
 	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
 		/*
-		   data[0]: Application Type
-		   data[1]: Counter Mode Register Value
-		   data[2]: Pre-load Register Value
-		   data[3]: Conter Control Register
+		 * data[0]: Application Type
+		 * data[1]: Counter Mode Register Value
+		 * data[2]: Pre-load Register Value
+		 * data[3]: Conter Control Register
 		 */
 		devpriv->gpct_config[chan] = data[0];
 
@@ -214,11 +216,13 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 			cmReg.reg.clockSource = 0;
 
 		/*  When to take into account the indexpulse: */
-		/*if (data[2] == GPCT_IndexPhaseLowLow) {
-		} else if (data[2] == GPCT_IndexPhaseLowHigh) {
-		} else if (data[2] == GPCT_IndexPhaseHighLow) {
-		} else if (data[2] == GPCT_IndexPhaseHighHigh) {
-		}*/
+		/*
+		 * if (data[2] == GPCT_IndexPhaseLowLow) {
+		 * } else if (data[2] == GPCT_IndexPhaseLowHigh) {
+		 * } else if (data[2] == GPCT_IndexPhaseHighLow) {
+		 * } else if (data[2] == GPCT_IndexPhaseHighHigh) {
+		 * }
+		 */
 		/*  Take into account the index pulse? */
 		if (data[3] == GPCT_RESET_COUNTER_ON_INDEX)
 			/*  Auto load with INDEX^ */
@@ -248,11 +252,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 	case INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR:
 		/*
-		   data[0]: Application Type
-		   data[1]: Counter Mode Register Value
-		   data[2]: Pre-load Register 0 Value
-		   data[3]: Pre-load Register 1 Value
-		   data[4]: Conter Control Register
+		 * data[0]: Application Type
+		 * data[1]: Counter Mode Register Value
+		 * data[2]: Pre-load Register 0 Value
+		 * data[3]: Pre-load Register 1 Value
+		 * data[4]: Conter Control Register
 		 */
 		devpriv->gpct_config[chan] = data[0];
 
@@ -281,11 +285,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 	case INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR:
 		/*
-		   data[0]: Application Type
-		   data[1]: Counter Mode Register Value
-		   data[2]: Pre-load Register 0 Value
-		   data[3]: Pre-load Register 1 Value
-		   data[4]: Conter Control Register
+		 * data[0]: Application Type
+		 * data[1]: Counter Mode Register Value
+		 * data[2]: Pre-load Register 0 Value
+		 * data[3]: Pre-load Register 1 Value
+		 * data[4]: Conter Control Register
 		 */
 		devpriv->gpct_config[chan] = data[0];
 
@@ -332,11 +336,12 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->gpct_config[chan]) {
 	case INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR:
-		/* data[0] contains the PULSE_WIDTH
-		   data[1] contains the PULSE_PERIOD
-		   @pre PULSE_PERIOD > PULSE_WIDTH > 0
-		   The above periods must be expressed as a multiple of the
-		   pulse frequency on the selected source
+		/*
+		 * data[0] contains the PULSE_WIDTH
+		 * data[1] contains the PULSE_PERIOD
+		 * @pre PULSE_PERIOD > PULSE_WIDTH > 0
+		 * The above periods must be expressed as a multiple of the
+		 * pulse frequency on the selected source
 		 */
 		if ((data[1] <= data[0]) || !data[0])
 			return -EINVAL;

commit 4f3ed25664073891ae093bfe2fa35480bbd10717
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:26 2015 -0700

    staging: comedi: s526: remove #if 0'ed out code block
    
    This #if 0'ed out code is not necessary. It's actually just a copy
    of the psuedo code in the S526 Hardware Manual that shows an example
    of a counter application. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 801413d7b0c3..43f9c0c3b3fc 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -188,35 +188,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		 */
 		devpriv->gpct_config[chan] = data[0];
 
-#if 0
-		/*  Example of Counter Application */
-		/* One-shot (software trigger) */
-		cmReg.reg.coutSource = 0;	/*  out RCAP */
-		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-		cmReg.reg.autoLoadResetRcap = 0;/*  Auto load disabled */
-		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
-		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
-		cmReg.reg.clockSource = 2;	/*  Internal */
-		cmReg.reg.countDir = 1;	/*  Down */
-		cmReg.reg.countDirCtrl = 1;	/*  Software */
-		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		cmReg.reg.reserved = 0;
-
-		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
-
-		s526_gpct_write(dev, chan, 0x0013c68);
-
-		/*  Reset the counter */
-		outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
-		/*  Load the counter from PR0 */
-		outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
-
-		/*  Reset RCAP (fires one-shot) */
-		outw(0x0008, dev->iobase + S526_GPCT_CTRL_REG(chan));
-
-#endif
-
 #if 1
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;

commit 537dd665e42794886266f50c8379b879d5d99af3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:25 2015 -0700

    staging: comedi: s526: remove unnecessary defines
    
    Remove a couple unused defines,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 7cf6250bdf30..801413d7b0c3 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -39,13 +39,9 @@
 #include "../comedidev.h"
 #include <asm/byteorder.h>
 
-#define S526_START_AI_CONV	0
-#define S526_AI_READ		0
-
-/* Ports */
-#define S526_NUM_PORTS 27
-
-/* registers */
+/*
+ * Register I/O map
+ */
 #define S526_TIMER_REG		0x00
 #define S526_TIMER_LOAD(x)	(((x) & 0xff) << 8)
 #define S526_TIMER_MODE		((x) << 1)

commit 21424e3fa81505f466841eaecaa373f160f44cf4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:24 2015 -0700

    staging: comedi: s526: remove s526_ai_insn_config()
    
    This (*insn_config) does not follow the comedi core API. It also
    would not work as expected.
    
    It appears to be trying to configure the analog input subdevice so
    that the (*insn_read) would read multiple channels (data[0]) and
    optionally enable the 15us delay (data[1]) needed for the multiplexor
    to change channels between samples.
    
    Unfortunately, the comedi core expects (*insn_read) operations to
    return 1 or more samples for a single channel, which is what the
    (*insn_read) in this driver does.
    
    The (*insn_config) is also enabling the analog input end-of-conversion
    interrupt. This isn't needed, and might be a problem since the driver
    does not currently request and interrupt. The enable bit does not
    need to be set for the end-of-conversion to occur in the interrupt
    status register.
    
    Remove the (*insn_config) and modify the (*insn_read) to automatically
    handle the 15us delay when needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 1a5aa3d3a36e..7cf6250bdf30 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -133,7 +133,7 @@ union cmReg {
 
 struct s526_private {
 	unsigned int gpct_config[4];
-	unsigned short ai_config;
+	unsigned short ai_ctrl;
 };
 
 static void s526_gpct_write(struct comedi_device *dev,
@@ -388,36 +388,6 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int s526_ai_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
-{
-	struct s526_private *devpriv = dev->private;
-	int result = -EINVAL;
-
-	if (insn->n < 1)
-		return result;
-
-	result = insn->n;
-
-	/* data[0] : channels was set in relevant bits.
-	   data[1] : delay
-	 */
-	/* COMMENT: abbotti 2008-07-24: I don't know why you'd want to
-	 * enable channels here.  The channel should be enabled in the
-	 * INSN_READ handler. */
-
-	/*  Enable ADC interrupt */
-	outw(S526_INT_AI, dev->iobase + S526_INT_ENA_REG);
-	devpriv->ai_config = (data[0] & 0x3ff) << 5;
-	if (data[1] > 0)
-		devpriv->ai_config |= S526_AI_CTRL_DELAY;/* set the delay */
-
-	devpriv->ai_config |= 0x0001;		/* ADC start bit */
-
-	return result;
-}
-
 static int s526_eoc(struct comedi_device *dev,
 		    struct comedi_subdevice *s,
 		    struct comedi_insn *insn,
@@ -446,17 +416,21 @@ static int s526_ai_insn_read(struct comedi_device *dev,
 	int ret;
 	int i;
 
-	/*
-	 * Set configured delay, enable conversion and read for requested
-	 * channel only, set "ADC start" bit.
-	 */
-	ctrl = (devpriv->ai_config & S526_AI_CTRL_DELAY) |
-	       S526_AI_CTRL_CONV(chan) | S526_AI_CTRL_READ(chan) |
+	ctrl = S526_AI_CTRL_CONV(chan) | S526_AI_CTRL_READ(chan) |
 	       S526_AI_CTRL_START;
+	if (ctrl != devpriv->ai_ctrl) {
+		/*
+		 * The multiplexor needs to change, enable the 15us
+		 * delay for the first sample.
+		 */
+		devpriv->ai_ctrl = ctrl;
+		ctrl |= S526_AI_CTRL_DELAY;
+	}
 
 	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
 		outw(ctrl, dev->iobase + S526_AI_CTRL_REG);
+		ctrl &= ~S526_AI_CTRL_DELAY;
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, s526_eoc, S526_INT_AI);
@@ -590,7 +564,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->range_table	= &range_bipolar10;
 	s->len_chanlist	= 16;
 	s->insn_read	= s526_ai_insn_read;
-	s->insn_config	= s526_ai_insn_config;
 
 	/* Analog Output subdevice */
 	s = &dev->subdevices[2];

commit bf483f1e07d0b292ae5d5fdf94d901fa4415ab38
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:23 2015 -0700

    staging: comedi: s526: tidy up s526_ai_rinsn()
    
    Rename this function to follow the normal naming in comedi drivers.
    
    Use the comedi_offset_munge() helper to munge the hardware two's
    complement data to the comedi offset binary format.
    
    Change the final return to insn->n to clarify the return value without
    the need for the comment.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 152be955f8ab..1a5aa3d3a36e 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -434,15 +434,17 @@ static int s526_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
+static int s526_ai_insn_read(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int ctrl;
-	int n;
-	unsigned int d;
+	unsigned int val;
 	int ret;
+	int i;
 
 	/*
 	 * Set configured delay, enable conversion and read for requested
@@ -452,8 +454,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	       S526_AI_CTRL_CONV(chan) | S526_AI_CTRL_READ(chan) |
 	       S526_AI_CTRL_START;
 
-	/* convert n samples */
-	for (n = 0; n < insn->n; n++) {
+	for (i = 0; i < insn->n; i++) {
 		/* trigger conversion */
 		outw(ctrl, dev->iobase + S526_AI_CTRL_REG);
 
@@ -462,14 +463,11 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (ret)
 			return ret;
 
-		d = inw(dev->iobase + S526_AI_REG);
-
-		/* munge data */
-		data[n] = d ^ 0x8000;
+		val = inw(dev->iobase + S526_AI_REG);
+		data[i] = comedi_offset_munge(s, val);
 	}
 
-	/* return the number of samples read/written */
-	return n;
+	return insn->n;
 }
 
 static int s526_ao_insn_write(struct comedi_device *dev,
@@ -591,7 +589,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata	= 0xffff;
 	s->range_table	= &range_bipolar10;
 	s->len_chanlist	= 16;
-	s->insn_read	= s526_ai_rinsn;
+	s->insn_read	= s526_ai_insn_read;
 	s->insn_config	= s526_ai_insn_config;
 
 	/* Analog Output subdevice */

commit 09c5d6c83ec3bd56ee1ebef8bec42956b32ca7eb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:22 2015 -0700

    staging: comedi: s526: wait for analog output conversions to complete
    
    It's possible for the user to write more than one value to an analog
    output channel with the (*insn_write) operation. Use comedi_timeout()
    to check the interrupt status register to ensure that each data
    conversion is complete before writing the next value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 242db7d9dfb3..152be955f8ab 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -418,16 +418,19 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	return result;
 }
 
-static int s526_ai_eoc(struct comedi_device *dev,
-		       struct comedi_subdevice *s,
-		       struct comedi_insn *insn,
-		       unsigned long context)
+static int s526_eoc(struct comedi_device *dev,
+		    struct comedi_subdevice *s,
+		    struct comedi_insn *insn,
+		    unsigned long context)
 {
 	unsigned int status;
 
 	status = inw(dev->iobase + S526_INT_STATUS_REG);
-	if (status & S526_INT_AI)
+	if (status & context) {
+		/* we got our eoc event, clear it */
+		outw(context, dev->iobase + S526_INT_STATUS_REG);
 		return 0;
+	}
 	return -EBUSY;
 }
 
@@ -455,12 +458,10 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		outw(ctrl, dev->iobase + S526_AI_CTRL_REG);
 
 		/* wait for conversion to end */
-		ret = comedi_timeout(dev, s, insn, s526_ai_eoc, 0);
+		ret = comedi_timeout(dev, s, insn, s526_eoc, S526_INT_AI);
 		if (ret)
 			return ret;
 
-		outw(S526_INT_AI, dev->iobase + S526_INT_STATUS_REG);
-
 		d = inw(dev->iobase + S526_AI_REG);
 
 		/* munge data */
@@ -479,6 +480,7 @@ static int s526_ao_insn_write(struct comedi_device *dev,
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int ctrl = S526_AO_CTRL_CHAN(chan);
 	unsigned int val = s->readback[chan];
+	int ret;
 	int i;
 
 	outw(ctrl, dev->iobase + S526_AO_CTRL_REG);
@@ -488,6 +490,11 @@ static int s526_ao_insn_write(struct comedi_device *dev,
 		val = data[i];
 		outw(val, dev->iobase + S526_AO_REG);
 		outw(ctrl, dev->iobase + S526_AO_CTRL_REG);
+
+		/* wait for conversion to end */
+		ret = comedi_timeout(dev, s, insn, s526_eoc, S526_INT_AO);
+		if (ret)
+			return ret;
 	}
 	s->readback[chan] = val;
 

commit 12911c2d6ae64315edb721cc142cc6d4b20db8b5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:21 2015 -0700

    staging: comedi: s526: tidy up subdevice init
    
    For aesthetics, add some whitespace to the subdevice initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 9ed3edd6ba0c..242db7d9dfb3 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -561,51 +561,54 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
+	/* General-Purpose Counter/Timer (GPCT) */
 	s = &dev->subdevices[0];
-	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
-	s->n_chan = 4;
-	s->maxdata = 0x00ffffff;	/* 24 bit counter */
-	s->insn_read = s526_gpct_rinsn;
-	s->insn_config = s526_gpct_insn_config;
-	s->insn_write = s526_gpct_winsn;
+	s->type		= COMEDI_SUBD_COUNTER;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
+	s->n_chan	= 4;
+	s->maxdata	= 0x00ffffff;
+	s->insn_read	= s526_gpct_rinsn;
+	s->insn_config	= s526_gpct_insn_config;
+	s->insn_write	= s526_gpct_winsn;
 
+	/*
+	 * Analog Input subdevice
+	 * channels 0 to 7 are the regular differential inputs
+	 * channel 8 is "reference 0" (+10V)
+	 * channel 9 is "reference 1" (0V)
+	 */
 	s = &dev->subdevices[1];
-	/* analog input subdevice */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF;
-	/* channels 0 to 7 are the regular differential inputs */
-	/* channel 8 is "reference 0" (+10V), channel 9 is "reference 1" (0V) */
-	s->n_chan = 10;
-	s->maxdata = 0xffff;
-	s->range_table = &range_bipolar10;
-	s->len_chanlist = 16;
-	s->insn_read = s526_ai_rinsn;
-	s->insn_config = s526_ai_insn_config;
-
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_DIFF;
+	s->n_chan	= 10;
+	s->maxdata	= 0xffff;
+	s->range_table	= &range_bipolar10;
+	s->len_chanlist	= 16;
+	s->insn_read	= s526_ai_rinsn;
+	s->insn_config	= s526_ai_insn_config;
+
+	/* Analog Output subdevice */
 	s = &dev->subdevices[2];
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = 4;
-	s->maxdata = 0xffff;
-	s->range_table = &range_bipolar10;
-	s->insn_write = s526_ao_insn_write;
+	s->type		= COMEDI_SUBD_AO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 0xffff;
+	s->range_table	= &range_bipolar10;
+	s->insn_write	= s526_ao_insn_write;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)
 		return ret;
 
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[3];
-	/* digital i/o subdevice */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 8;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = s526_dio_insn_bits;
-	s->insn_config = s526_dio_insn_config;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 8;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= s526_dio_insn_bits;
+	s->insn_config	= s526_dio_insn_config;
 
 	return 0;
 }

commit 2c6b58246de18a9915e5a5804800a7c0a302f8c2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:20 2015 -0700

    staging: comedi: s526: define the eeprom data and control registers
    
    Define these registers and their bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 22724a242005..9ed3edd6ba0c 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -89,9 +89,12 @@
 #define S526_GPCT_MSB_REG(x)	(0x14 + ((x) * 8))
 #define S526_GPCT_MODE_REG(x)	(0x16 + ((x) * 8))
 #define S526_GPCT_CTRL_REG(x)	(0x18 + ((x) * 8))
-
-#define REG_EED 0x32
-#define REG_EEC 0x34
+#define S526_EEPROM_DATA_REG	0x32
+#define S526_EEPROM_CTRL_REG	0x34
+#define S526_EEPROM_CTRL_ADDR(x) (((x) & 0x3f) << 3)
+#define S526_EEPROM_CTRL(x)	(((x) & 0x3) << 1)
+#define S526_EEPROM_CTRL_READ	S526_EEPROM_CTRL(2)
+#define S526_EEPROM_CTRL_START	BIT(0)
 
 struct counter_mode_register_t {
 #if defined(__LITTLE_ENDIAN_BITFIELD)

commit 64fe38f49cb2d1335d077f1b9a387177fea22dac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:19 2015 -0700

    staging: comedi: s526: define the miscellaneous register and bits
    
    Define this register and its bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 0f56a8988ac6..22724a242005 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -83,8 +83,8 @@
 #define S526_INT_AI		BIT(2)
 #define S526_INT_AO		BIT(1)
 #define S526_INT_TIMER		BIT(0)
-#define REG_MSC 0x10
-
+#define S526_MISC_REG		0x10
+#define S526_MISC_LED_OFF	BIT(0)
 #define S526_GPCT_LSB_REG(x)	(0x12 + ((x) * 8))
 #define S526_GPCT_MSB_REG(x)	(0x14 + ((x) * 8))
 #define S526_GPCT_MODE_REG(x)	(0x16 + ((x) * 8))

commit 658441b48c01886217d6119d5cfd5c3278b37ddf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:18 2015 -0700

    staging: comedi: s526: define the digtial I/O control register and bits
    
    Define this register and its bits and remove the magic numbers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 11a661b353ca..0f56a8988ac6 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -67,7 +67,14 @@
 #define S526_AI_CTRL_START	BIT(0)
 #define S526_AO_REG		0x08
 #define S526_AI_REG		0x08
-#define REG_DIO 0x0A
+#define S526_DIO_CTRL_REG	0x0a
+#define S526_DIO_CTRL_DIO3_NEG	BIT(15)	/* irq on DIO3 neg/pos edge */
+#define S526_DIO_CTRL_DIO2_NEG	BIT(14)	/* irq on DIO2 neg/pos edge */
+#define S526_DIO_CTRL_DIO1_NEG	BIT(13)	/* irq on DIO1 neg/pos edge */
+#define S526_DIO_CTRL_DIO0_NEG	BIT(12)	/* irq on DIO0 neg/pos edge */
+#define S526_DIO_CTRL_GRP2_OUT	BIT(11)
+#define S526_DIO_CTRL_GRP1_OUT	BIT(10)
+#define S526_DIO_CTRL_GRP2_NEG	BIT(8)	/* irq on DIO[4-7] neg/pos edge */
 #define S526_INT_ENA_REG	0x0c
 #define S526_INT_STATUS_REG	0x0e
 #define S526_INT_DIO(x)		BIT(8 + ((x) & 0x7))
@@ -490,9 +497,9 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	if (comedi_dio_update_state(s, data))
-		outw(s->state, dev->iobase + REG_DIO);
+		outw(s->state, dev->iobase + S526_DIO_CTRL_REG);
 
-	data[1] = inw(dev->iobase + REG_DIO) & 0xff;
+	data[1] = inw(dev->iobase + S526_DIO_CTRL_REG) & 0xff;
 
 	return insn->n;
 }
@@ -506,6 +513,10 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	unsigned int mask;
 	int ret;
 
+	/*
+	 * Digital I/O can be configured as inputs or outputs in
+	 * groups of 4; DIO group 1 (DIO0-3) and DIO group 2 (DIO4-7).
+	 */
 	if (chan < 4)
 		mask = 0x0f;
 	else
@@ -515,17 +526,16 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* bit 10/11 set the group 1/2's mode */
 	if (s->io_bits & 0x0f)
-		s->state |= (1 << 10);
+		s->state |= S526_DIO_CTRL_GRP1_OUT;
 	else
-		s->state &= ~(1 << 10);
+		s->state &= ~S526_DIO_CTRL_GRP1_OUT;
 	if (s->io_bits & 0xf0)
-		s->state |= (1 << 11);
+		s->state |= S526_DIO_CTRL_GRP2_OUT;
 	else
-		s->state &= ~(1 << 11);
+		s->state &= ~S526_DIO_CTRL_GRP2_OUT;
 
-	outw(s->state, dev->iobase + REG_DIO);
+	outw(s->state, dev->iobase + S526_DIO_CTRL_REG);
 
 	return insn->n;
 }

commit 8a5d6d2ee252dd76305c18f843f82ee7ee376371
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:17 2015 -0700

    staging: comedi: s526: define the interrupt enable/status registers
    
    These registers use the same bit defines. Define both of them and
    the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 5f8a5d3aa9f7..11a661b353ca 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -68,8 +68,14 @@
 #define S526_AO_REG		0x08
 #define S526_AI_REG		0x08
 #define REG_DIO 0x0A
-#define REG_IER 0x0C
-#define REG_ISR 0x0E
+#define S526_INT_ENA_REG	0x0c
+#define S526_INT_STATUS_REG	0x0e
+#define S526_INT_DIO(x)		BIT(8 + ((x) & 0x7))
+#define S526_INT_EEPROM		BIT(7)	/* status only */
+#define S526_INT_CNTR(x)	BIT(3 + (3 - ((x) & 0x3)))
+#define S526_INT_AI		BIT(2)
+#define S526_INT_AO		BIT(1)
+#define S526_INT_TIMER		BIT(0)
 #define REG_MSC 0x10
 
 #define S526_GPCT_LSB_REG(x)	(0x12 + ((x) * 8))
@@ -372,7 +378,6 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	return insn->n;
 }
 
-#define ISR_ADC_DONE 0x4
 static int s526_ai_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
@@ -393,7 +398,7 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	 * INSN_READ handler. */
 
 	/*  Enable ADC interrupt */
-	outw(ISR_ADC_DONE, dev->iobase + REG_IER);
+	outw(S526_INT_AI, dev->iobase + S526_INT_ENA_REG);
 	devpriv->ai_config = (data[0] & 0x3ff) << 5;
 	if (data[1] > 0)
 		devpriv->ai_config |= S526_AI_CTRL_DELAY;/* set the delay */
@@ -410,8 +415,8 @@ static int s526_ai_eoc(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inw(dev->iobase + REG_ISR);
-	if (status & ISR_ADC_DONE)
+	status = inw(dev->iobase + S526_INT_STATUS_REG);
+	if (status & S526_INT_AI)
 		return 0;
 	return -EBUSY;
 }
@@ -444,7 +449,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (ret)
 			return ret;
 
-		outw(ISR_ADC_DONE, dev->iobase + REG_ISR);
+		outw(S526_INT_AI, dev->iobase + S526_INT_STATUS_REG);
 
 		d = inw(dev->iobase + S526_AI_REG);
 

commit 15bccf2e5d7f5d1960c41962b2b628bd1b034ce2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:16 2015 -0700

    staging: comedi: s526: add defines for the ao/ai data register
    
    The same register is used for analog output and input data. Add defines
    for both for added clarity.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index ff576d32753e..5f8a5d3aa9f7 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -65,7 +65,8 @@
 #define S526_AI_CTRL_CONV(x)	(1 << (5 + ((x) & 0x9)))
 #define S526_AI_CTRL_READ(x)	(((x) & 0xf) << 1)
 #define S526_AI_CTRL_START	BIT(0)
-#define REG_ADD 0x08
+#define S526_AO_REG		0x08
+#define S526_AI_REG		0x08
 #define REG_DIO 0x0A
 #define REG_IER 0x0C
 #define REG_ISR 0x0E
@@ -445,8 +446,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		outw(ISR_ADC_DONE, dev->iobase + REG_ISR);
 
-		/* read data */
-		d = inw(dev->iobase + REG_ADD);
+		d = inw(dev->iobase + S526_AI_REG);
 
 		/* munge data */
 		data[n] = d ^ 0x8000;
@@ -471,7 +471,7 @@ static int s526_ao_insn_write(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		val = data[i];
-		outw(val, dev->iobase + REG_ADD);
+		outw(val, dev->iobase + S526_AO_REG);
 		outw(ctrl, dev->iobase + S526_AO_CTRL_REG);
 	}
 	s->readback[chan] = val;

commit fe79b3d0c339f053a04673bff95a50f26f59222f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:15 2015 -0700

    staging: comedi: s526: define the ADC (analog input) control register and bits
    
    Define this register and its bits and remove the magic numbers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e71d850da882..ff576d32753e 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -60,7 +60,11 @@
 #define S526_AO_CTRL_RESET	BIT(3)
 #define S526_AO_CTRL_CHAN(x)	(((x) & 0x3) << 1)
 #define S526_AO_CTRL_START	BIT(0)
-#define REG_ADC 0x06
+#define S526_AI_CTRL_REG	0x06
+#define S526_AI_CTRL_DELAY	BIT(15)
+#define S526_AI_CTRL_CONV(x)	(1 << (5 + ((x) & 0x9)))
+#define S526_AI_CTRL_READ(x)	(((x) & 0xf) << 1)
+#define S526_AI_CTRL_START	BIT(0)
 #define REG_ADD 0x08
 #define REG_DIO 0x0A
 #define REG_IER 0x0C
@@ -391,7 +395,7 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	outw(ISR_ADC_DONE, dev->iobase + REG_IER);
 	devpriv->ai_config = (data[0] & 0x3ff) << 5;
 	if (data[1] > 0)
-		devpriv->ai_config |= 0x8000;	/* set the delay */
+		devpriv->ai_config |= S526_AI_CTRL_DELAY;/* set the delay */
 
 	devpriv->ai_config |= 0x0001;		/* ADC start bit */
 
@@ -416,20 +420,23 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int ctrl;
 	int n;
-	unsigned short value;
 	unsigned int d;
 	int ret;
 
-	/* Set configured delay, enable channel for this channel only,
-	 * select "ADC read" channel, set "ADC start" bit. */
-	value = (devpriv->ai_config & 0x8000) |
-		((1 << 5) << chan) | (chan << 1) | 0x0001;
+	/*
+	 * Set configured delay, enable conversion and read for requested
+	 * channel only, set "ADC start" bit.
+	 */
+	ctrl = (devpriv->ai_config & S526_AI_CTRL_DELAY) |
+	       S526_AI_CTRL_CONV(chan) | S526_AI_CTRL_READ(chan) |
+	       S526_AI_CTRL_START;
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
-		outw(value, dev->iobase + REG_ADC);
+		outw(ctrl, dev->iobase + S526_AI_CTRL_REG);
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, s526_ai_eoc, 0);

commit abbb6489090255290d0bc24f1bf9eeba26b595de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:14 2015 -0700

    staging: comedi: s526: define the DAC (analog output) control register and bits
    
    Define this register and its bits and remove the magic numbers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index df463a22fa7e..e71d850da882 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -56,7 +56,10 @@
 #define S526_WDOG_INVERTED	BIT(4)
 #define S526_WDOG_ENA		BIT(3)
 #define S526_WDOG_INTERVAL(x)	(((x) & 0x7) << 0)
-#define REG_DAC 0x04
+#define S526_AO_CTRL_REG	0x04
+#define S526_AO_CTRL_RESET	BIT(3)
+#define S526_AO_CTRL_CHAN(x)	(((x) & 0x3) << 1)
+#define S526_AO_CTRL_START	BIT(0)
 #define REG_ADC 0x06
 #define REG_ADD 0x08
 #define REG_DIO 0x0A
@@ -452,16 +455,17 @@ static int s526_ao_insn_write(struct comedi_device *dev,
 			      unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int ctrl = S526_AO_CTRL_CHAN(chan);
 	unsigned int val = s->readback[chan];
 	int i;
 
-	outw(chan << 1, dev->iobase + REG_DAC);
+	outw(ctrl, dev->iobase + S526_AO_CTRL_REG);
+	ctrl |= S526_AO_CTRL_START;
 
 	for (i = 0; i < insn->n; i++) {
 		val = data[i];
 		outw(val, dev->iobase + REG_ADD);
-		/* starts the D/A conversion */
-		outw((chan << 1) | 1, dev->iobase + REG_DAC);
+		outw(ctrl, dev->iobase + S526_AO_CTRL_REG);
 	}
 	s->readback[chan] = val;
 

commit 088c1ce04dacc3374335ce8b23666a9f8aa5d85c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:13 2015 -0700

    staging: comedi: s526: define the watchdog timer control register and bits
    
    Define this register and it's bits so that we can possibly support
    it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e329c0470492..df463a22fa7e 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -52,7 +52,10 @@
 #define S526_TIMER_MANUAL	S526_TIMER_MODE(0)
 #define S526_TIMER_AUTO		S526_TIMER_MODE(1)
 #define S526_TIMER_RESTART	BIT(0)
-#define REG_WDC 0x02
+#define S526_WDOG_REG		0x02
+#define S526_WDOG_INVERTED	BIT(4)
+#define S526_WDOG_ENA		BIT(3)
+#define S526_WDOG_INTERVAL(x)	(((x) & 0x7) << 0)
 #define REG_DAC 0x04
 #define REG_ADC 0x06
 #define REG_ADD 0x08

commit 4e04fd32599bb4e0f2574708e5d48f1f78d80761
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:12 2015 -0700

    staging: comedi: s526: define the timer control register and bits
    
    Define this register and it's bits so that we can possibly support
    it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index c011c7005e38..e329c0470492 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -46,7 +46,12 @@
 #define S526_NUM_PORTS 27
 
 /* registers */
-#define REG_TCR 0x00
+#define S526_TIMER_REG		0x00
+#define S526_TIMER_LOAD(x)	(((x) & 0xff) << 8)
+#define S526_TIMER_MODE		((x) << 1)
+#define S526_TIMER_MANUAL	S526_TIMER_MODE(0)
+#define S526_TIMER_AUTO		S526_TIMER_MODE(1)
+#define S526_TIMER_RESTART	BIT(0)
 #define REG_WDC 0x02
 #define REG_DAC 0x04
 #define REG_ADC 0x06

commit 1d0d1c00daff961b130691a64ad2cde6d856d24e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:11 2015 -0700

    staging: comedi: s526: refactor gpct registers
    
    The S526 board has 4 general purpose counter/timers. The current
    defines used for the registers of these devices do not provide much
    clarity in what they are.
    
    Refactor the code to add some clarity.
    
    Replace the current register defines with macros that return the
    correct offset based on the counter 'channel'. Introduce a some helper
    functions to handle reading/writing the LSB/MSB registers so that
    they are always accessed in the correct oreder.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 817ce1509032..c011c7005e38 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -55,22 +55,12 @@
 #define REG_IER 0x0C
 #define REG_ISR 0x0E
 #define REG_MSC 0x10
-#define REG_C0L 0x12
-#define REG_C0H 0x14
-#define REG_C0M 0x16
-#define REG_C0C 0x18
-#define REG_C1L 0x1A
-#define REG_C1H 0x1C
-#define REG_C1M 0x1E
-#define REG_C1C 0x20
-#define REG_C2L 0x22
-#define REG_C2H 0x24
-#define REG_C2M 0x26
-#define REG_C2C 0x28
-#define REG_C3L 0x2A
-#define REG_C3H 0x2C
-#define REG_C3M 0x2E
-#define REG_C3C 0x30
+
+#define S526_GPCT_LSB_REG(x)	(0x12 + ((x) * 8))
+#define S526_GPCT_MSB_REG(x)	(0x14 + ((x) * 8))
+#define S526_GPCT_MODE_REG(x)	(0x16 + ((x) * 8))
+#define S526_GPCT_CTRL_REG(x)	(0x18 + ((x) * 8))
+
 #define REG_EED 0x32
 #define REG_EEC 0x34
 
@@ -114,24 +104,36 @@ struct s526_private {
 	unsigned short ai_config;
 };
 
+static void s526_gpct_write(struct comedi_device *dev,
+			    unsigned int chan, unsigned int val)
+{
+	/* write high word then low word */
+	outw((val >> 16) & 0xffff, dev->iobase + S526_GPCT_MSB_REG(chan));
+	outw(val & 0xffff, dev->iobase + S526_GPCT_LSB_REG(chan));
+}
+
+static unsigned int s526_gpct_read(struct comedi_device *dev,
+				   unsigned int chan)
+{
+	unsigned int val;
+
+	/* read the low word then high word */
+	val = inw(dev->iobase + S526_GPCT_LSB_REG(chan)) & 0xffff;
+	val |= (inw(dev->iobase + S526_GPCT_MSB_REG(chan)) & 0xff) << 16;
+
+	return val;
+}
+
 static int s526_gpct_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s,
 			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned long chan_iobase = dev->iobase + chan * 8;
-	unsigned int lo;
-	unsigned int hi;
 	int i;
 
-	for (i = 0; i < insn->n; i++) {
-		/* Read the low word first */
-		lo = inw(chan_iobase + REG_C0L) & 0xffff;
-		hi = inw(chan_iobase + REG_C0H) & 0xff;
-
-		data[i] = (hi << 16) | lo;
-	}
+	for (i = 0; i < insn->n; i++)
+		data[i] = s526_gpct_read(dev, chan);
 
 	return insn->n;
 }
@@ -143,7 +145,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned long chan_iobase = dev->iobase + chan * 8;
 	unsigned int val;
 	union cmReg cmReg;
 
@@ -174,32 +175,31 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		cmReg.reg.reserved = 0;
 
-		outw(cmReg.value, chan_iobase + REG_C0M);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		outw(0x0001, chan_iobase + REG_C0H);
-		outw(0x3C68, chan_iobase + REG_C0L);
+		s526_gpct_write(dev, chan, 0x0013c68);
 
 		/*  Reset the counter */
-		outw(0x8000, chan_iobase + REG_C0C);
+		outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 		/*  Load the counter from PR0 */
-		outw(0x4000, chan_iobase + REG_C0C);
+		outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 
 		/*  Reset RCAP (fires one-shot) */
-		outw(0x0008, chan_iobase + REG_C0C);
+		outw(0x0008, dev->iobase + S526_GPCT_CTRL_REG(chan));
 
 #endif
 
 #if 1
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
-		outw(cmReg.value, chan_iobase + REG_C0M);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, chan_iobase + REG_C0C);
+			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 			/* Load the counter from PR0
-			 * outw(0x4000, chan_iobase + REG_C0C);
+			 * outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 			 */
 		}
 #else
@@ -227,27 +227,22 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
-		outw(cmReg.value, chan_iobase + REG_C0M);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		/*  Load the pre-load register high word */
-		val = (data[2] >> 16) & 0xffff;
-		outw(val, chan_iobase + REG_C0H);
-
-		/*  Load the pre-load register low word */
-		val = data[2] & 0xffff;
-		outw(val, chan_iobase + REG_C0L);
+		/*  Load the pre-load register */
+		s526_gpct_write(dev, chan, data[2]);
 
 		/*  Write the Counter Control Register */
-		if (data[3]) {
-			val = data[3] & 0xffff;
-			outw(val, chan_iobase + REG_C0C);
-		}
+		if (data[3])
+			outw(data[3] & 0xffff,
+			     dev->iobase + S526_GPCT_CTRL_REG(chan));
+
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, chan_iobase + REG_C0C);
+			outw(0x8000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 			/*  Load the counter from PR0 */
-			outw(0x4000, chan_iobase + REG_C0C);
+			outw(0x4000, dev->iobase + S526_GPCT_CTRL_REG(chan));
 		}
 #endif
 		break;
@@ -265,33 +260,23 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, chan_iobase + REG_C0M);
-
-		/*  Load the pre-load register 0 high word */
-		val = (data[2] >> 16) & 0xffff;
-		outw(val, chan_iobase + REG_C0H);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		/*  Load the pre-load register 0 low word */
-		val = data[2] & 0xffff;
-		outw(val, chan_iobase + REG_C0L);
+		/* Load the pre-load register 0 */
+		s526_gpct_write(dev, chan, data[2]);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, chan_iobase + REG_C0M);
-
-		/*  Load the pre-load register 1 high word */
-		val = (data[3] >> 16) & 0xffff;
-		outw(val, chan_iobase + REG_C0H);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		/*  Load the pre-load register 1 low word */
-		val = data[3] & 0xffff;
-		outw(val, chan_iobase + REG_C0L);
+		/* Load the pre-load register 1 */
+		s526_gpct_write(dev, chan, data[3]);
 
 		/*  Write the Counter Control Register */
 		if (data[4]) {
 			val = data[4] & 0xffff;
-			outw(val, chan_iobase + REG_C0C);
+			outw(val, dev->iobase + S526_GPCT_CTRL_REG(chan));
 		}
 		break;
 
@@ -308,33 +293,23 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, chan_iobase + REG_C0M);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		/*  Load the pre-load register 0 high word */
-		val = (data[2] >> 16) & 0xffff;
-		outw(val, chan_iobase + REG_C0H);
-
-		/*  Load the pre-load register 0 low word */
-		val = data[2] & 0xffff;
-		outw(val, chan_iobase + REG_C0L);
+		/* Load the pre-load register 0 */
+		s526_gpct_write(dev, chan, data[2]);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, chan_iobase + REG_C0M);
-
-		/*  Load the pre-load register 1 high word */
-		val = (data[3] >> 16) & 0xffff;
-		outw(val, chan_iobase + REG_C0H);
+		outw(cmReg.value, dev->iobase + S526_GPCT_MODE_REG(chan));
 
-		/*  Load the pre-load register 1 low word */
-		val = data[3] & 0xffff;
-		outw(val, chan_iobase + REG_C0L);
+		/* Load the pre-load register 1 */
+		s526_gpct_write(dev, chan, data[3]);
 
 		/*  Write the Counter Control Register */
 		if (data[4]) {
 			val = data[4] & 0xffff;
-			outw(val, chan_iobase + REG_C0C);
+			outw(val, dev->iobase + S526_GPCT_CTRL_REG(chan));
 		}
 		break;
 
@@ -352,9 +327,8 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned long chan_iobase = dev->iobase + chan * 8;
 
-	inw(chan_iobase + REG_C0M);	/* Is this read required? */
+	inw(dev->iobase + S526_GPCT_MODE_REG(chan));	/* Is this required? */
 
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->gpct_config[chan]) {
@@ -372,8 +346,7 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 
 	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
 	case INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR:
-		outw((data[0] >> 16) & 0xffff, chan_iobase + REG_C0H);
-		outw(data[0] & 0xffff, chan_iobase + REG_C0L);
+		s526_gpct_write(dev, chan, data[0]);
 		break;
 
 	default:

commit de332b11946f1e5f9d8513828e18701d6cb903d4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 17 16:58:10 2015 -0700

    staging: comedi: s526: tidy up multi-line comments
    
    Format the multi-line comments in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 6f3e8a08e75c..817ce1509032 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -1,40 +1,39 @@
 /*
-    comedi/drivers/s526.c
-    Sensoray s526 Comedi driver
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
-/*
-Driver: s526
-Description: Sensoray 526 driver
-Devices: [Sensoray] 526 (s526)
-Author: Richie
-	Everett Wang <everett.wang@everteq.com>
-Updated: Thu, 14 Sep. 2006
-Status: experimental
-
-Encoder works
-Analog input works
-Analog output works
-PWM output works
-Commands are not supported yet.
-
-Configuration Options:
+ * s526.c
+ * Sensoray s526 Comedi driver
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-comedi_config /dev/comedi0 s526 0x2C0,0x3
-
-*/
+/*
+ * Driver: s526
+ * Description: Sensoray 526 driver
+ * Devices: [Sensoray] 526 (s526)
+ * Author: Richie
+ *	   Everett Wang <everett.wang@everteq.com>
+ * Updated: Thu, 14 Sep. 2006
+ * Status: experimental
+ *
+ * Encoder works
+ * Analog input works
+ * Analog output works
+ * PWM output works
+ * Commands are not supported yet.
+ *
+ * Configuration Options:
+ *   [0] - I/O port base address
+ */
 
 #include <linux/module.h>
 #include "../comedidev.h"

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 75872c6aec2a..6f3e8a08e75c 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -583,7 +583,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = 0xffff;
 	s->range_table = &range_bipolar10;
 	s->insn_write = s526_ao_insn_write;
-	s->insn_read = comedi_readback_insn_read;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 6db4a1f5ebea6ecdd147798df3e0b18cdb39e485
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:07 2014 -0700

    staging: comedi: s526: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    For aesthetics, rename the (*insn_write) function and tidy it up a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 83f7433c2452..75872c6aec2a 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -111,7 +111,6 @@ union cmReg {
 };
 
 struct s526_private {
-	unsigned int ao_readback[2];
 	unsigned int gpct_config[4];
 	unsigned short ai_config;
 };
@@ -467,38 +466,26 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return n;
 }
 
-static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
+static int s526_ao_insn_write(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned short val;
+	unsigned int val = s->readback[chan];
 	int i;
 
-	val = chan << 1;
-	outw(val, dev->iobase + REG_DAC);
+	outw(chan << 1, dev->iobase + REG_DAC);
 
 	for (i = 0; i < insn->n; i++) {
-		outw(data[i], dev->iobase + REG_ADD);
-		devpriv->ao_readback[chan] = data[i];
+		val = data[i];
+		outw(val, dev->iobase + REG_ADD);
 		/* starts the D/A conversion */
-		outw(val + 1, dev->iobase + REG_DAC);
+		outw((chan << 1) | 1, dev->iobase + REG_DAC);
 	}
+	s->readback[chan] = val;
 
-	return i;
-}
-
-static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
-{
-	struct s526_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
-
-	return i;
+	return insn->n;
 }
 
 static int s526_dio_insn_bits(struct comedi_device *dev,
@@ -595,8 +582,12 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan = 4;
 	s->maxdata = 0xffff;
 	s->range_table = &range_bipolar10;
-	s->insn_write = s526_ao_winsn;
-	s->insn_read = s526_ao_rinsn;
+	s->insn_write = s526_ao_insn_write;
+	s->insn_read = comedi_readback_insn_read;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
 
 	s = &dev->subdevices[3];
 	/* digital i/o subdevice */

commit 862755ec07572036b0c69d738b88f89b6beede99
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:22 2014 -0700

    staging: comedi: drivers: remove unnecessary *_SIZE defines
    
    Some of the legacy comedi drivers have a *_SIZE define that is only
    passed to comedi_request_region() to specify the size of the region.
    
    Some of the pnp drivers (pci, etc.) also have a *_SIZE define which
    is unused.
    
    For aesthetics, remove these defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 208567d2cb21..83f7433c2452 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -40,13 +40,10 @@ comedi_config /dev/comedi0 s526 0x2C0,0x3
 #include "../comedidev.h"
 #include <asm/byteorder.h>
 
-#define S526_SIZE 64
-
 #define S526_START_AI_CONV	0
 #define S526_AI_READ		0
 
 /* Ports */
-#define S526_IOSIZE 0x40
 #define S526_NUM_PORTS 27
 
 /* registers */
@@ -556,7 +553,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	int ret;
 
-	ret = comedi_request_region(dev, it->options[0], S526_IOSIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x40);
 	if (ret)
 		return ret;
 

commit ee99bcc75d3bfe260338de6cf632853bc7c1b936
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:27 2014 -0700

    staging: comedi: s526: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 85d2b7a3c125..208567d2cb21 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -345,7 +345,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 	default:
 		return -EINVAL;
-		break;
 	}
 
 	return insn->n;

commit 043fff873dfeac74c977f4f09b6e4a015643d23f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:23 2014 -0700

    staging: comedi: s526: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 0a93afab3dcb..85d2b7a3c125 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -420,15 +420,28 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	return result;
 }
 
+static int s526_ai_eoc(struct comedi_device *dev,
+		       struct comedi_subdevice *s,
+		       struct comedi_insn *insn,
+		       unsigned long context)
+{
+	unsigned int status;
+
+	status = inw(dev->iobase + REG_ISR);
+	if (status & ISR_ADC_DONE)
+		return 0;
+	return -EBUSY;
+}
+
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	int n, i;
+	int n;
 	unsigned short value;
 	unsigned int d;
-	unsigned int status;
+	int ret;
 
 	/* Set configured delay, enable channel for this channel only,
 	 * select "ADC read" channel, set "ADC start" bit. */
@@ -440,17 +453,12 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		/* trigger conversion */
 		outw(value, dev->iobase + REG_ADC);
 
-#define TIMEOUT 100
 		/* wait for conversion to end */
-		for (i = 0; i < TIMEOUT; i++) {
-			status = inw(dev->iobase + REG_ISR);
-			if (status & ISR_ADC_DONE) {
-				outw(ISR_ADC_DONE, dev->iobase + REG_ISR);
-				break;
-			}
-		}
-		if (i == TIMEOUT)
-			return -ETIMEDOUT;
+		ret = comedi_timeout(dev, s, insn, s526_ai_eoc, 0);
+		if (ret)
+			return ret;
+
+		outw(ISR_ADC_DONE, dev->iobase + REG_ISR);
 
 		/* read data */
 		d = inw(dev->iobase + REG_ADD);

commit fb780d213355868b69cc12142635aae5e0ee7c2a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:51 2014 -0700

    staging: comedi: drivers: return '0' for successful attach
    
    The comedi core expects the driver attach functions to return a
    negative errno for failure. Any other value indicates success.
    
    For consistency in the drivers, make sure they all return '0' to
    indicate success.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 9950f59b1192..0a93afab3dcb 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -604,7 +604,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits = s526_dio_insn_bits;
 	s->insn_config = s526_dio_insn_config;
 
-	return 1;
+	return 0;
 }
 
 static struct comedi_driver s526_driver = {

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d629463b85a2..9950f59b1192 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -499,14 +499,11 @@ static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 static int s526_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+			      struct comedi_insn *insn,
+			      unsigned int *data)
 {
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= data[0] & data[1];
-
+	if (comedi_dio_update_state(s, data))
 		outw(s->state, dev->iobase + REG_DIO);
-	}
 
 	data[1] = inw(dev->iobase + REG_DIO) & 0xff;
 

commit 5dacadcca3176e2b1f8db662e503c080484d71fa
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 6 09:33:05 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for complex cases
    
    Convert the drivers with complex, port programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these drivers have some sort of 'port' programmable i/o where multiple
    i/o channels are configured as a group. The 'mask' associated with the group
    is passed to comedi_dio_insn_config() so that all the channels are configured.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 6670b865256b..d629463b85a2 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -515,32 +515,35 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 
 static int s526_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	int group, mask;
+	unsigned int mask;
+	int ret;
+
+	if (chan < 4)
+		mask = 0x0f;
+	else
+		mask = 0xf0;
+
+	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
+	if (ret)
+		return ret;
+
+	/* bit 10/11 set the group 1/2's mode */
+	if (s->io_bits & 0x0f)
+		s->state |= (1 << 10);
+	else
+		s->state &= ~(1 << 10);
+	if (s->io_bits & 0xf0)
+		s->state |= (1 << 11);
+	else
+		s->state &= ~(1 << 11);
 
-	group = chan >> 2;
-	mask = 0xF << (group << 2);
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		/* bit 10/11 set the group 1/2's mode */
-		s->state |= 1 << (group + 10);
-		s->io_bits |= mask;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->state &= ~(1 << (group + 10)); /* 1 is output, 0 is input. */
-		s->io_bits &= ~mask;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-	default:
-		return -EINVAL;
-	}
 	outw(s->state, dev->iobase + REG_DIO);
 
-	return 1;
+	return insn->n;
 }
 
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit 3457bfd6dfb38f7bb66a227fe3473bad4773de06
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 15:14:18 2013 -0700

    Revert "staging: comedi: drivers: use comedi_dio_insn_config() for complex cases"
    
    This reverts commit f21c53945cb95f66faa9636af5f23cb00ba73019.
    
    I applied the wrong patch :(
    
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d629463b85a2..6670b865256b 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -515,35 +515,32 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 
 static int s526_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn,
-				unsigned int *data)
+				struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned int mask;
-	int ret;
-
-	if (chan < 4)
-		mask = 0x0f;
-	else
-		mask = 0xf0;
-
-	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
-	if (ret)
-		return ret;
-
-	/* bit 10/11 set the group 1/2's mode */
-	if (s->io_bits & 0x0f)
-		s->state |= (1 << 10);
-	else
-		s->state &= ~(1 << 10);
-	if (s->io_bits & 0xf0)
-		s->state |= (1 << 11);
-	else
-		s->state &= ~(1 << 11);
+	int group, mask;
 
+	group = chan >> 2;
+	mask = 0xF << (group << 2);
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		/* bit 10/11 set the group 1/2's mode */
+		s->state |= 1 << (group + 10);
+		s->io_bits |= mask;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->state &= ~(1 << (group + 10)); /* 1 is output, 0 is input. */
+		s->io_bits &= ~mask;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+	default:
+		return -EINVAL;
+	}
 	outw(s->state, dev->iobase + REG_DIO);
 
-	return insn->n;
+	return 1;
 }
 
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit f21c53945cb95f66faa9636af5f23cb00ba73019
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 5 15:01:25 2013 -0700

    staging: comedi: drivers: use comedi_dio_insn_config() for complex cases
    
    Convert the drivers with complex, port programmable i/o, to use the
    comedi_dio_insn_config() helper function.
    
    All of these drivers have some sort of 'port' programmable i/o where multiple
    i/o channels are configured as a group. The 'mask' associated with the group
    is passed to comedi_dio_insn_config() so that all the channels are configured.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 6670b865256b..d629463b85a2 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -515,32 +515,35 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 
 static int s526_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	int group, mask;
+	unsigned int mask;
+	int ret;
+
+	if (chan < 4)
+		mask = 0x0f;
+	else
+		mask = 0xf0;
+
+	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
+	if (ret)
+		return ret;
+
+	/* bit 10/11 set the group 1/2's mode */
+	if (s->io_bits & 0x0f)
+		s->state |= (1 << 10);
+	else
+		s->state &= ~(1 << 10);
+	if (s->io_bits & 0xf0)
+		s->state |= (1 << 11);
+	else
+		s->state &= ~(1 << 11);
 
-	group = chan >> 2;
-	mask = 0xF << (group << 2);
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_OUTPUT:
-		/* bit 10/11 set the group 1/2's mode */
-		s->state |= 1 << (group + 10);
-		s->io_bits |= mask;
-		break;
-	case INSN_CONFIG_DIO_INPUT:
-		s->state &= ~(1 << (group + 10)); /* 1 is output, 0 is input. */
-		s->io_bits &= ~mask;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-	default:
-		return -EINVAL;
-	}
 	outw(s->state, dev->iobase + REG_DIO);
 
-	return 1;
+	return insn->n;
 }
 
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 0373a45ec4e7..6670b865256b 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -38,7 +38,6 @@ comedi_config /dev/comedi0 s526 0x2C0,0x3
 
 #include <linux/module.h>
 #include "../comedidev.h"
-#include <linux/ioport.h>
 #include <asm/byteorder.h>
 
 #define S526_SIZE 64

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 24d21eef74f8..0373a45ec4e7 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -36,6 +36,7 @@ comedi_config /dev/comedi0 s526 0x2C0,0x3
 
 */
 
+#include <linux/module.h>
 #include "../comedidev.h"
 #include <linux/ioport.h>
 #include <asm/byteorder.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e1587e58a732..24d21eef74f8 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -553,10 +553,9 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d240ce87bd68..e1587e58a732 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -14,11 +14,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 /*
 Driver: s526

commit 21208519d42404150fef42283a20192ffe08b0af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:33:22 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach() in simple drivers
    
    Use the new comedi_legacy_detach() helper in the (*detach) to release
    the I/O region requested by these drivers.
    
    Since the (*detach) for these drivers only releases the region, remove
    the private (*detach) functions and use comedi_legacy_detach() directly
    for the (*detach).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 0fd4ba1939bd..d240ce87bd68 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -613,17 +613,11 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-static void s526_detach(struct comedi_device *dev)
-{
-	if (dev->iobase > 0)
-		release_region(dev->iobase, S526_IOSIZE);
-}
-
 static struct comedi_driver s526_driver = {
 	.driver_name	= "s526",
 	.module		= THIS_MODULE,
 	.attach		= s526_attach,
-	.detach		= s526_detach,
+	.detach		= comedi_legacy_detach,
 };
 module_comedi_driver(s526_driver);
 

commit 3cbc2810a60bc4c96aa583e1ce8699fb5acf8e90
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:33:04 2013 -0700

    staging: comedi: s526: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the board attach noise as well as the error message when the
    request_region() fails, comedi_request_reqion() will output the error
    message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index b490b47b0bb8..0fd4ba1939bd 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -552,15 +552,11 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct s526_private *devpriv;
 	struct comedi_subdevice *s;
-	int iobase;
 	int ret;
 
-	iobase = it->options[0];
-	if (!iobase || !request_region(iobase, S526_IOSIZE, dev->board_name)) {
-		comedi_error(dev, "I/O port conflict");
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], S526_IOSIZE);
+	if (ret)
+		return ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -614,8 +610,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_bits = s526_dio_insn_bits;
 	s->insn_config = s526_dio_insn_config;
 
-	dev_info(dev->class_dev, "%s attached\n", dev->board_name);
-
 	return 1;
 }
 

commit 5993f3a2692eed3c74c86882155b8703a0060ad5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 8 10:57:35 2013 -0700

    staging: comedi: remove unnecessary dev->board_name initialization
    
    The dev->board_name is now initialized by the comedi core before calling
    the(*attach) or (*auto_attach) function in a driver. As long as the driver
    does no additional probing, it's no longer necessary initialize the board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 39232b359453..b490b47b0bb8 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -555,8 +555,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int iobase;
 	int ret;
 
-	dev->board_name = dev->driver->driver_name;
-
 	iobase = it->options[0];
 	if (!iobase || !request_region(iobase, S526_IOSIZE, dev->board_name)) {
 		comedi_error(dev, "I/O port conflict");

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index a1e256293bd6..39232b359453 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -564,10 +564,10 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	dev->iobase = iobase;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)

commit 67f2021fb1519057b0643d871b2afcd583bcc40d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Sep 24 13:50:48 2012 -0700

    staging: comedi: s526: fix if() check in s526_gpct_winsn()
    
    This if() check was flipped from a test for valid data params
    to a test for invalid params.
    
    As pointed out by Dan Carpenter, the orignal test was:
    
            if ((data[1] > data[0]) && (data[0] > 0)) {
    
    the flipped test should be:
    
            if (data[1] <= data[0]) ...
    
    Add the missing '='.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 4ad6adfcbb9c..a1e256293bd6 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -376,7 +376,7 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   The above periods must be expressed as a multiple of the
 		   pulse frequency on the selected source
 		 */
-		if ((data[1] < data[0]) || !data[0])
+		if ((data[1] <= data[0]) || !data[0])
 			return -EINVAL;
 
 		/* Fall thru to write the PULSE_WIDTH */

commit bda60cbfe252ad5ba7d4df4cc17c0f55e8b54599
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:13:10 2012 -0700

    staging: comedi: s526: rename s526_ai_config
    
    For aesthetic reasons, rename the private data variable
    's526_ai_config' to simply 'ai_config'. Its private data
    and does not need the 's526_' namespace.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e1927cf28e2e..4ad6adfcbb9c 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -121,7 +121,7 @@ union cmReg {
 struct s526_private {
 	unsigned int ao_readback[2];
 	unsigned int gpct_config[4];
-	unsigned short s526_ai_config;
+	unsigned short ai_config;
 };
 
 static int s526_gpct_rinsn(struct comedi_device *dev,
@@ -416,11 +416,11 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 
 	/*  Enable ADC interrupt */
 	outw(ISR_ADC_DONE, dev->iobase + REG_IER);
-	devpriv->s526_ai_config = (data[0] & 0x3FF) << 5;
+	devpriv->ai_config = (data[0] & 0x3ff) << 5;
 	if (data[1] > 0)
-		devpriv->s526_ai_config |= 0x8000;	/* set the delay */
+		devpriv->ai_config |= 0x8000;	/* set the delay */
 
-	devpriv->s526_ai_config |= 0x0001;	/*  ADC start bit. */
+	devpriv->ai_config |= 0x0001;		/* ADC start bit */
 
 	return result;
 }
@@ -437,8 +437,8 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Set configured delay, enable channel for this channel only,
 	 * select "ADC read" channel, set "ADC start" bit. */
-	value = (devpriv->s526_ai_config & 0x8000) |
-	    ((1 << 5) << chan) | (chan << 1) | 0x0001;
+	value = (devpriv->ai_config & 0x8000) |
+		((1 << 5) << chan) | (chan << 1) | 0x0001;
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {

commit 675f98f101fb6d1a694a03961b36997cb407dfae
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:12:54 2012 -0700

    staging: comedi: s526: remove struct s526GPCTConfig
    
    The enum in this struct is used by the driver to know how the
    gpct channels have been configured. Instead of using the private
    enum S526_GPCT_APP_CLASS, we can just use the INSN_CONFIG_* value
    that was passed in data[0] to the s526_gpct_insn_config().
    
    The data array in this struct in never used. It actually could
    cause a BUG since it assumes that the data pointer passed to
    s526_gpct_insn_config() always has 6 values but the comments
    indicate that there are really only 4 or 5.
    
    Remove the s526GPCTConfig struct and associated S526_GPCT_APP_CLASS
    enum and just use and unsigned int array in the private data to
    hold the gpct configuration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 7782061d30e1..e1927cf28e2e 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -118,29 +118,9 @@ union cmReg {
 	unsigned short value;
 };
 
-#define MAX_GPCT_CONFIG_DATA 6
-
-/* Different Application Classes for GPCT Subdevices */
-/* The list is not exhaustive and needs discussion! */
-enum S526_GPCT_APP_CLASS {
-	CountingAndTimeMeasurement,
-	SinglePulseGeneration,
-	PulseTrainGeneration,
-	PositionMeasurement,
-	Miscellaneous
-};
-
-/* Config struct for different GPCT subdevice Application Classes and
-   their options
-*/
-struct s526GPCTConfig {
-	enum S526_GPCT_APP_CLASS app;
-	int data[MAX_GPCT_CONFIG_DATA];
-};
-
 struct s526_private {
 	unsigned int ao_readback[2];
-	struct s526GPCTConfig s526_gpct_config[4];
+	unsigned int gpct_config[4];
 	unsigned short s526_ai_config;
 };
 
@@ -175,12 +155,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned long chan_iobase = dev->iobase + chan * 8;
 	unsigned int val;
-	int i;
 	union cmReg cmReg;
 
-	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++)
-		devpriv->s526_gpct_config[chan].data[i] = data[i];
-
 	/*  Check what type of Counter the user requested, data[0] contains */
 	/*  the Application type */
 	switch (data[0]) {
@@ -191,7 +167,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[2]: Pre-load Register Value
 		   data[3]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[chan].app = PositionMeasurement;
+		devpriv->gpct_config[chan] = data[0];
 
 #if 0
 		/*  Example of Counter Application */
@@ -294,7 +270,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[chan].app = SinglePulseGeneration;
+		devpriv->gpct_config[chan] = data[0];
 
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
@@ -337,7 +313,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[chan].app = PulseTrainGeneration;
+		devpriv->gpct_config[chan] = data[0];
 
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xffff;
@@ -392,25 +368,21 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	inw(chan_iobase + REG_C0M);	/* Is this read required? */
 
 	/*  Check what Application of Counter this channel is configured for */
-	switch (devpriv->s526_gpct_config[chan].app) {
-	case PulseTrainGeneration:
+	switch (devpriv->gpct_config[chan]) {
+	case INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR:
 		/* data[0] contains the PULSE_WIDTH
 		   data[1] contains the PULSE_PERIOD
 		   @pre PULSE_PERIOD > PULSE_WIDTH > 0
 		   The above periods must be expressed as a multiple of the
 		   pulse frequency on the selected source
 		 */
-		if ((data[1] > data[0]) && (data[0] > 0)) {
-			devpriv->s526_gpct_config[chan].data[0] = data[0];
-			devpriv->s526_gpct_config[chan].data[1] = data[1];
-		} else {
+		if ((data[1] < data[0]) || !data[0])
 			return -EINVAL;
-		}
 
 		/* Fall thru to write the PULSE_WIDTH */
 
-	case PositionMeasurement:
-	case SinglePulseGeneration:
+	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
+	case INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR:
 		outw((data[0] >> 16) & 0xffff, chan_iobase + REG_C0H);
 		outw(data[0] & 0xffff, chan_iobase + REG_C0L);
 		break;

commit 5c813bb100431eff1f78d75682ae1fe2d30744b4
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:12:33 2012 -0700

    staging: comedi: s526: cleanup s526_gpct_winsn()
    
    Use a local variable for the iobase of the channel being written.
    This makes the outw() calls a bit cleaner.
    
    Rearrange the switch () so that the actual write to the device
    can be common regardless of the gpct configuration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 66741b689e3a..7782061d30e1 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -381,27 +381,18 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 }
 
 static int s526_gpct_winsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	short value;
-	union cmReg cmReg;
+	unsigned long chan_iobase = dev->iobase + chan * 8;
+
+	inw(chan_iobase + REG_C0M);	/* Is this read required? */
 
-	cmReg.value = inw(dev->iobase + REG_C0M + chan * 8);
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[chan].app) {
-	case PositionMeasurement:
-		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H + chan * 8);
-		outw(0xFFFF & (*data), dev->iobase + REG_C0L + chan * 8);
-		break;
-
-	case SinglePulseGeneration:
-		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H + chan * 8);
-		outw(0xFFFF & (*data), dev->iobase + REG_C0L + chan * 8);
-		break;
-
 	case PulseTrainGeneration:
 		/* data[0] contains the PULSE_WIDTH
 		   data[1] contains the PULSE_PERIOD
@@ -410,22 +401,24 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   pulse frequency on the selected source
 		 */
 		if ((data[1] > data[0]) && (data[0] > 0)) {
-			(devpriv->s526_gpct_config[chan]).data[0] = data[0];
-			(devpriv->s526_gpct_config[chan]).data[1] = data[1];
+			devpriv->s526_gpct_config[chan].data[0] = data[0];
+			devpriv->s526_gpct_config[chan].data[1] = data[1];
 		} else {
 			return -EINVAL;
 		}
 
-		value = (short)((*data >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
-		value = (short)(*data & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		/* Fall thru to write the PULSE_WIDTH */
+
+	case PositionMeasurement:
+	case SinglePulseGeneration:
+		outw((data[0] >> 16) & 0xffff, chan_iobase + REG_C0H);
+		outw(data[0] & 0xffff, chan_iobase + REG_C0L);
 		break;
-	default:		/*  Impossible */
+
+	default:
 		return -EINVAL;
-		break;
 	}
-	/*  return the number of samples written */
+
 	return insn->n;
 }
 

commit 5a5614cb669f9f99bb3e983b3c4987a1eaef852b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:12:17 2012 -0700

    staging: comedi: s526: cleanup s526_gpct_insn_config()
    
    Use a local variable for the iobase of the channel being configured.
    This makes the outw() calls a bit cleaner.
    
    Remove the unnecessary casting of the values being written to
    the channel registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 86b5c7b8030f..66741b689e3a 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -168,12 +168,14 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 
 static int s526_gpct_insn_config(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data)
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned long chan_iobase = dev->iobase + chan * 8;
+	unsigned int val;
 	int i;
-	short value;
 	union cmReg cmReg;
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++)
@@ -206,32 +208,32 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		cmReg.reg.reserved = 0;
 
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
-		outw(0x0001, dev->iobase + REG_C0H + chan * 8);
-		outw(0x3C68, dev->iobase + REG_C0L + chan * 8);
+		outw(0x0001, chan_iobase + REG_C0H);
+		outw(0x3C68, chan_iobase + REG_C0L);
 
 		/*  Reset the counter */
-		outw(0x8000, dev->iobase + REG_C0C + chan * 8);
+		outw(0x8000, chan_iobase + REG_C0C);
 		/*  Load the counter from PR0 */
-		outw(0x4000, dev->iobase + REG_C0C + chan * 8);
+		outw(0x4000, chan_iobase + REG_C0C);
 
 		/*  Reset RCAP (fires one-shot) */
-		outw(0x0008, dev->iobase +  REG_C0C + chan * 8);
+		outw(0x0008, chan_iobase + REG_C0C);
 
 #endif
 
 #if 1
 		/*  Set Counter Mode Register */
-		cmReg.value = data[1] & 0xFFFF;
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		cmReg.value = data[1] & 0xffff;
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + REG_C0C + chan * 8);
+			outw(0x8000, chan_iobase + REG_C0C);
 			/* Load the counter from PR0
-			 * outw(0x4000, dev->iobase + REG_C0C + chan * 8);
+			 * outw(0x4000, chan_iobase + REG_C0C);
 			 */
 		}
 #else
@@ -258,28 +260,28 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 			cmReg.reg.autoLoadResetRcap = 4;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(data[1] & 0xFFFF);
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		cmReg.value = data[1] & 0xffff;
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Load the pre-load register high word */
-		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
+		val = (data[2] >> 16) & 0xffff;
+		outw(val, chan_iobase + REG_C0H);
 
 		/*  Load the pre-load register low word */
-		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		val = data[2] & 0xffff;
+		outw(val, chan_iobase + REG_C0L);
 
 		/*  Write the Counter Control Register */
-		if (data[3] != 0) {
-			value = (short)(data[3] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + chan * 8);
+		if (data[3]) {
+			val = data[3] & 0xffff;
+			outw(val, chan_iobase + REG_C0C);
 		}
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + REG_C0C + chan * 8);
+			outw(0x8000, chan_iobase + REG_C0C);
 			/*  Load the counter from PR0 */
-			outw(0x4000, dev->iobase + REG_C0C + chan * 8);
+			outw(0x4000, chan_iobase + REG_C0C);
 		}
 #endif
 		break;
@@ -295,35 +297,35 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		devpriv->s526_gpct_config[chan].app = SinglePulseGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(data[1] & 0xFFFF);
+		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Load the pre-load register 0 high word */
-		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
+		val = (data[2] >> 16) & 0xffff;
+		outw(val, chan_iobase + REG_C0H);
 
 		/*  Load the pre-load register 0 low word */
-		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		val = data[2] & 0xffff;
+		outw(val, chan_iobase + REG_C0L);
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(data[1] & 0xFFFF);
+		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Load the pre-load register 1 high word */
-		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
+		val = (data[3] >> 16) & 0xffff;
+		outw(val, chan_iobase + REG_C0H);
 
 		/*  Load the pre-load register 1 low word */
-		value = (short)(data[3] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		val = data[3] & 0xffff;
+		outw(val, chan_iobase + REG_C0L);
 
 		/*  Write the Counter Control Register */
-		if (data[4] != 0) {
-			value = (short)(data[4] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + chan * 8);
+		if (data[4]) {
+			val = data[4] & 0xffff;
+			outw(val, chan_iobase + REG_C0C);
 		}
 		break;
 
@@ -338,35 +340,35 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		devpriv->s526_gpct_config[chan].app = PulseTrainGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(data[1] & 0xFFFF);
+		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Load the pre-load register 0 high word */
-		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
+		val = (data[2] >> 16) & 0xffff;
+		outw(val, chan_iobase + REG_C0H);
 
 		/*  Load the pre-load register 0 low word */
-		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		val = data[2] & 0xffff;
+		outw(val, chan_iobase + REG_C0L);
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(data[1] & 0xFFFF);
+		cmReg.value = data[1] & 0xffff;
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
+		outw(cmReg.value, chan_iobase + REG_C0M);
 
 		/*  Load the pre-load register 1 high word */
-		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + chan * 8);
+		val = (data[3] >> 16) & 0xffff;
+		outw(val, chan_iobase + REG_C0H);
 
 		/*  Load the pre-load register 1 low word */
-		value = (short)(data[3] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + chan * 8);
+		val = data[3] & 0xffff;
+		outw(val, chan_iobase + REG_C0L);
 
 		/*  Write the Counter Control Register */
-		if (data[4] != 0) {
-			value = (short)(data[4] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + chan * 8);
+		if (data[4]) {
+			val = data[4] & 0xffff;
+			outw(val, chan_iobase + REG_C0C);
 		}
 		break;
 

commit 2a29edf69807a43ad7594554cea4def755443103
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:12:01 2012 -0700

    staging: comedi: s526: cleanup s526_gpct_rinsn()
    
    Use a local variable for the iobase of the channel being read.
    This makes the inw() calls a bit cleaner.
    
    Move the masking of the read data to make the value stored in
    the data array a bit clearer.
    
    The comedi core expects insn_read functions to return the number
    of insn data values read. For this function, the final value of
    'i' is correct but change the return to 'insn->n' just to make
    it clear.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 574a0b2b698b..86b5c7b8030f 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -145,22 +145,25 @@ struct s526_private {
 };
 
 static int s526_gpct_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   struct comedi_subdevice *s,
+			   struct comedi_insn *insn,
 			   unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	unsigned short datalow;
-	unsigned short datahigh;
+	unsigned long chan_iobase = dev->iobase + chan * 8;
+	unsigned int lo;
+	unsigned int hi;
 	int i;
 
-	/*  Read the low word first */
 	for (i = 0; i < insn->n; i++) {
-		datalow = inw(dev->iobase + REG_C0L + chan * 8);
-		datahigh = inw(dev->iobase + REG_C0H + chan * 8);
-		data[i] = (int)(datahigh & 0x00FF);
-		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
+		/* Read the low word first */
+		lo = inw(chan_iobase + REG_C0L) & 0xffff;
+		hi = inw(chan_iobase + REG_C0H) & 0xff;
+
+		data[i] = (hi << 16) | lo;
 	}
-	return i;
+
+	return insn->n;
 }
 
 static int s526_gpct_insn_config(struct comedi_device *dev,

commit 43a352760e6c1c073c12f6e21d02b789525e677e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:11:37 2012 -0700

    staging: comedi: s526: rename local var used for CR_CHAN() value
    
    Rename the local variable used to hold the unpacked CR_CHAN() value
    to help keep the lines < 80 chars.
    
    Also, since the insn->chanspec variable is an unsigned int, change
    the type of the local variable to match.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 5bd50a9043bd..574a0b2b698b 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -148,15 +148,15 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
-	int i;			/*  counts the Data */
-	int counter_channel = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned short datalow;
 	unsigned short datahigh;
+	int i;
 
 	/*  Read the low word first */
 	for (i = 0; i < insn->n; i++) {
-		datalow = inw(dev->iobase + REG_C0L + counter_channel * 8);
-		datahigh = inw(dev->iobase + REG_C0H + counter_channel * 8);
+		datalow = inw(dev->iobase + REG_C0L + chan * 8);
+		datahigh = inw(dev->iobase + REG_C0H + chan * 8);
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
 	}
@@ -168,13 +168,13 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 				 struct comedi_insn *insn, unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
-	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
 	short value;
 	union cmReg cmReg;
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++)
-		devpriv->s526_gpct_config[subdev_channel].data[i] = data[i];
+		devpriv->s526_gpct_config[chan].data[i] = data[i];
 
 	/*  Check what type of Counter the user requested, data[0] contains */
 	/*  the Application type */
@@ -186,8 +186,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[2]: Pre-load Register Value
 		   data[3]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[subdev_channel].app =
-		    PositionMeasurement;
+		devpriv->s526_gpct_config[chan].app = PositionMeasurement;
 
 #if 0
 		/*  Example of Counter Application */
@@ -204,32 +203,32 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		cmReg.reg.reserved = 0;
 
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
-		outw(0x0001, dev->iobase + REG_C0H + subdev_channel * 8);
-		outw(0x3C68, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(0x0001, dev->iobase + REG_C0H + chan * 8);
+		outw(0x3C68, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Reset the counter */
-		outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
+		outw(0x8000, dev->iobase + REG_C0C + chan * 8);
 		/*  Load the counter from PR0 */
-		outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
+		outw(0x4000, dev->iobase + REG_C0C + chan * 8);
 
 		/*  Reset RCAP (fires one-shot) */
-		outw(0x0008, dev->iobase +  REG_C0C + subdev_channel * 8);
+		outw(0x0008, dev->iobase +  REG_C0C + chan * 8);
 
 #endif
 
 #if 1
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xFFFF;
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(0x8000, dev->iobase + REG_C0C + chan * 8);
 			/* Load the counter from PR0
-			 * outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
+			 * outw(0x4000, dev->iobase + REG_C0C + chan * 8);
 			 */
 		}
 #else
@@ -257,27 +256,27 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Load the pre-load register high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 
 		/*  Load the pre-load register low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[3] != 0) {
 			value = (short)(data[3] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(value, dev->iobase + REG_C0C + chan * 8);
 		}
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(0x8000, dev->iobase + REG_C0C + chan * 8);
 			/*  Load the counter from PR0 */
-			outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(0x4000, dev->iobase + REG_C0C + chan * 8);
 		}
 #endif
 		break;
@@ -290,39 +289,38 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[subdev_channel].app =
-		    SinglePulseGeneration;
+		devpriv->s526_gpct_config[chan].app = SinglePulseGeneration;
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Load the pre-load register 0 high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 
 		/*  Load the pre-load register 0 low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Load the pre-load register 1 high word */
 		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 
 		/*  Load the pre-load register 1 low word */
 		value = (short)(data[3] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[4] != 0) {
 			value = (short)(data[4] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(value, dev->iobase + REG_C0C + chan * 8);
 		}
 		break;
 
@@ -334,39 +332,38 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		devpriv->s526_gpct_config[subdev_channel].app =
-		    PulseTrainGeneration;
+		devpriv->s526_gpct_config[chan].app = PulseTrainGeneration;
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Load the pre-load register 0 high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 
 		/*  Load the pre-load register 0 low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
+		outw(cmReg.value, dev->iobase + REG_C0M + chan * 8);
 
 		/*  Load the pre-load register 1 high word */
 		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 
 		/*  Load the pre-load register 1 low word */
 		value = (short)(data[3] & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[4] != 0) {
 			value = (short)(data[4] & 0xFFFF);
-			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
+			outw(value, dev->iobase + REG_C0C + chan * 8);
 		}
 		break;
 
@@ -383,23 +380,21 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 			   unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
-	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	short value;
 	union cmReg cmReg;
 
-	cmReg.value = inw(dev->iobase + REG_C0M + subdev_channel * 8);
+	cmReg.value = inw(dev->iobase + REG_C0M + chan * 8);
 	/*  Check what Application of Counter this channel is configured for */
-	switch (devpriv->s526_gpct_config[subdev_channel].app) {
+	switch (devpriv->s526_gpct_config[chan].app) {
 	case PositionMeasurement:
-		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
-							     subdev_channel * 8);
-		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H + chan * 8);
+		outw(0xFFFF & (*data), dev->iobase + REG_C0L + chan * 8);
 		break;
 
 	case SinglePulseGeneration:
-		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
-							     subdev_channel * 8);
-		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H + chan * 8);
+		outw(0xFFFF & (*data), dev->iobase + REG_C0L + chan * 8);
 		break;
 
 	case PulseTrainGeneration:
@@ -410,18 +405,16 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   pulse frequency on the selected source
 		 */
 		if ((data[1] > data[0]) && (data[0] > 0)) {
-			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
-			    data[0];
-			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
-			    data[1];
+			(devpriv->s526_gpct_config[chan]).data[0] = data[0];
+			(devpriv->s526_gpct_config[chan]).data[1] = data[1];
 		} else {
 			return -EINVAL;
 		}
 
 		value = (short)((*data >> 16) & 0xFFFF);
-		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0H + chan * 8);
 		value = (short)(*data & 0xFFFF);
-		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
+		outw(value, dev->iobase + REG_C0L + chan * 8);
 		break;
 	default:		/*  Impossible */
 		return -EINVAL;
@@ -466,8 +459,8 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int n, i;
-	int chan = CR_CHAN(insn->chanspec);
 	unsigned short value;
 	unsigned int d;
 	unsigned int status;
@@ -509,9 +502,9 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
-	int i;
-	int chan = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned short val;
+	int i;
 
 	val = chan << 1;
 	outw(val, dev->iobase + REG_DAC);
@@ -530,8 +523,8 @@ static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct s526_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int i;
-	int chan = CR_CHAN(insn->chanspec);
 
 	for (i = 0; i < insn->n; i++)
 		data[i] = devpriv->ao_readback[chan];
@@ -559,7 +552,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	int chan = CR_CHAN(insn->chanspec);
+	unsigned int chan = CR_CHAN(insn->chanspec);
 	int group, mask;
 
 	group = chan >> 2;

commit 3d9083b27a960e10a744b8d35694b70abae9a830
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:11:20 2012 -0700

    staging: comedi: s526: remove boardinfo
    
    This driver only supports one board type and only the "name",
    "gpct_chans", and "have_dio" information is being used anyway.
    
    Just remove the boardinfo to keep the driver simple.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 0f1ef9875ec5..5bd50a9043bd 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -138,30 +138,6 @@ struct s526GPCTConfig {
 	int data[MAX_GPCT_CONFIG_DATA];
 };
 
-struct s526_board {
-	const char *name;
-	int gpct_chans;
-	int gpct_bits;
-	int ad_chans;
-	int ad_bits;
-	int da_chans;
-	int da_bits;
-	int have_dio;
-};
-
-static const struct s526_board s526_boards[] = {
-	{
-	 .name = "s526",
-	 .gpct_chans = 4,
-	 .gpct_bits = 24,
-	 .ad_chans = 8,
-	 .ad_bits = 16,
-	 .da_chans = 4,
-	 .da_bits = 16,
-	 .have_dio = 1,
-	 }
-};
-
 struct s526_private {
 	unsigned int ao_readback[2];
 	struct s526GPCTConfig s526_gpct_config[4];
@@ -611,21 +587,20 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct s526_board *board = comedi_board(dev);
 	struct s526_private *devpriv;
 	struct comedi_subdevice *s;
 	int iobase;
 	int ret;
 
+	dev->board_name = dev->driver->driver_name;
+
 	iobase = it->options[0];
-	if (!iobase || !request_region(iobase, S526_IOSIZE, board->name)) {
+	if (!iobase || !request_region(iobase, S526_IOSIZE, dev->board_name)) {
 		comedi_error(dev, "I/O port conflict");
 		return -EIO;
 	}
 	dev->iobase = iobase;
 
-	dev->board_name = board->name;
-
 	ret = alloc_private(dev, sizeof(*devpriv));
 	if (ret)
 		return ret;
@@ -639,7 +614,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
-	s->n_chan = board->gpct_chans;
+	s->n_chan = 4;
 	s->maxdata = 0x00ffffff;	/* 24 bit counter */
 	s->insn_read = s526_gpct_rinsn;
 	s->insn_config = s526_gpct_insn_config;
@@ -670,17 +645,13 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s = &dev->subdevices[3];
 	/* digital i/o subdevice */
-	if (board->have_dio) {
-		s->type = COMEDI_SUBD_DIO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = 8;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = s526_dio_insn_bits;
-		s->insn_config = s526_dio_insn_config;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 8;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = s526_dio_insn_bits;
+	s->insn_config = s526_dio_insn_config;
 
 	dev_info(dev->class_dev, "%s attached\n", dev->board_name);
 
@@ -698,9 +669,6 @@ static struct comedi_driver s526_driver = {
 	.module		= THIS_MODULE,
 	.attach		= s526_attach,
 	.detach		= s526_detach,
-	.board_name	= &s526_boards[0].name,
-	.offset		= sizeof(struct s526_board),
-	.num_names	= ARRAY_SIZE(s526_boards),
 };
 module_comedi_driver(s526_driver);
 

commit 2c7817891dbc44612ac59a7d627716fae240b3a7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:11:04 2012 -0700

    staging: comedi: s526: remove cut-and-paste comments from skel driver
    
    These comments are not necessary, they are just cut-and-paste from
    the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 1ae250baa79d..0f1ef9875ec5 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -138,11 +138,6 @@ struct s526GPCTConfig {
 	int data[MAX_GPCT_CONFIG_DATA];
 };
 
-/*
- * Board descriptions for two imaginary boards.  Describing the
- * boards in this way is optional, and completely driver-dependent.
- * Some drivers use arrays such as this, other do not.
- */
 struct s526_board {
 	const char *name;
 	int gpct_chans;
@@ -167,11 +162,6 @@ static const struct s526_board s526_boards[] = {
 	 }
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device
-   struct.
-*/
 struct s526_private {
 	unsigned int ao_readback[2];
 	struct s526GPCTConfig s526_gpct_config[4];
@@ -496,10 +486,6 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	return result;
 }
 
-/*
- * "instructions" read/write data in "one-shot" or "software-triggered"
- * mode.
- */
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
@@ -552,30 +538,18 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned short val;
 
 	val = chan << 1;
-/* outw(val, dev->iobase + REG_DAC); */
 	outw(val, dev->iobase + REG_DAC);
 
-	/* Writing a list of values to an AO channel is probably not
-	 * very useful, but that's how the interface is defined. */
 	for (i = 0; i < insn->n; i++) {
-		/* a typical programming sequence */
-		/* write the data to preload register
-		 * outw(data[i], dev->iobase + REG_ADD);
-		 */
-		/* write the data to preload register */
 		outw(data[i], dev->iobase + REG_ADD);
 		devpriv->ao_readback[chan] = data[i];
-/* outw(val + 1, dev->iobase + REG_DAC);  starts the D/A conversion. */
 		/* starts the D/A conversion */
 		outw(val + 1, dev->iobase + REG_DAC);
 	}
 
-	/* return the number of samples read/written */
 	return i;
 }
 
-/* AO subdevices should have a read insn as well as a write insn.
- * Usually this means copying a value stored in devpriv. */
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
@@ -589,30 +563,18 @@ static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	return i;
 }
 
-/* DIO devices are slightly special.  Although it is possible to
- * implement the insn_read/insn_write interface, it is much more
- * useful to applications if you implement the insn_bits interface.
- * This allows packed reading/writing of the DIO channels.  The
- * comedi core can convert between insn_bits and insn_read/write */
 static int s526_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	/* The insn data is a mask in data[0] and the new data
-	 * in data[1], each channel cooresponding to a bit. */
 	if (data[0]) {
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
-		/* Write out the new digital output lines */
+
 		outw(s->state, dev->iobase + REG_DIO);
 	}
 
-	/* on return, data[1] contains the value of the digital
-	 * input and output lines. */
 	data[1] = inw(dev->iobase + REG_DIO) & 0xff;
-	/* or we could just return the software copy of the output values if
-	 * it was a purely digital output subdevice */
-	/* data[1]=s->state & 0xFF; */
 
 	return insn->n;
 }
@@ -624,11 +586,6 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	int chan = CR_CHAN(insn->chanspec);
 	int group, mask;
 
-	/* The input or output configuration of each digital line is
-	 * configured by a special insn_config instruction.  chanspec
-	 * contains the channel to be changed, and data[0] contains the
-	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
-
 	group = chan >> 2;
 	mask = 0xF << (group << 2);
 	switch (data[0]) {
@@ -682,33 +639,22 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
-	/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */
 	s->n_chan = board->gpct_chans;
 	s->maxdata = 0x00ffffff;	/* 24 bit counter */
 	s->insn_read = s526_gpct_rinsn;
 	s->insn_config = s526_gpct_insn_config;
 	s->insn_write = s526_gpct_winsn;
 
-	/* Command are not implemented yet, however they are necessary to
-	   allocate the necessary memory for the comedi_async struct (used
-	   to trigger the GPCT in case of pulsegenerator function */
-	/* s->do_cmd = s526_gpct_cmd; */
-	/* s->do_cmdtest = s526_gpct_cmdtest; */
-	/* s->cancel = s526_gpct_cancel; */
-
 	s = &dev->subdevices[1];
-	/* dev->read_subdev=s; */
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
-	/* we support differential */
 	s->subdev_flags = SDF_READABLE | SDF_DIFF;
 	/* channels 0 to 7 are the regular differential inputs */
 	/* channel 8 is "reference 0" (+10V), channel 9 is "reference 1" (0V) */
 	s->n_chan = 10;
 	s->maxdata = 0xffff;
 	s->range_table = &range_bipolar10;
-	s->len_chanlist = 16;	/* This is the maximum chanlist length that
-				   the board can handle */
+	s->len_chanlist = 16;
 	s->insn_read = s526_ai_rinsn;
 	s->insn_config = s526_ai_insn_config;
 

commit 2a117a92efc0394fd70486a9379b63004c2ebc99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:10:47 2012 -0700

    staging: comedi: s526: remove unused s526_ports array
    
    This array was used to debug dump the registers. The debug
    dump has been removed so this array is no longer needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 362c955389f3..1ae250baa79d 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -83,36 +83,6 @@ comedi_config /dev/comedi0 s526 0x2C0,0x3
 #define REG_EED 0x32
 #define REG_EEC 0x34
 
-static const int s526_ports[] = {
-	REG_TCR,
-	REG_WDC,
-	REG_DAC,
-	REG_ADC,
-	REG_ADD,
-	REG_DIO,
-	REG_IER,
-	REG_ISR,
-	REG_MSC,
-	REG_C0L,
-	REG_C0H,
-	REG_C0M,
-	REG_C0C,
-	REG_C1L,
-	REG_C1H,
-	REG_C1M,
-	REG_C1C,
-	REG_C2L,
-	REG_C2H,
-	REG_C2M,
-	REG_C2C,
-	REG_C3L,
-	REG_C3H,
-	REG_C3M,
-	REG_C3C,
-	REG_EED,
-	REG_EEC
-};
-
 struct counter_mode_register_t {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
 	unsigned short coutSource:1;

commit d160895fe8ef671a4e56be9fab5b2430c296dad7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:10:33 2012 -0700

    staging: comedi: s526: remove printk noise
    
    Remove the function trace printk noise.
    
    Change the final attach message into a simple dev_info.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index f0144d9cdf27..362c955389f3 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -250,7 +250,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[2]: Pre-load Register Value
 		   data[3]: Conter Control Register
 		 */
-		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PositionMeasurement;
 
@@ -355,7 +354,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring SPG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    SinglePulseGeneration;
 
@@ -400,7 +398,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring PTG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PulseTrainGeneration;
 
@@ -438,7 +435,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		break;
 
 	default:
-		printk(KERN_ERR "s526: unsupported GPCT_insn_config\n");
 		return -EINVAL;
 		break;
 	}
@@ -455,21 +451,16 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-	printk(KERN_INFO "s526: GPCT_INSN_WRITE on channel %d\n",
-					subdev_channel);
 	cmReg.value = inw(dev->iobase + REG_C0M + subdev_channel * 8);
-	printk(KERN_INFO "s526: Counter Mode Register: %x\n", cmReg.value);
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[subdev_channel].app) {
 	case PositionMeasurement:
-		printk(KERN_INFO "S526: INSN_WRITE: PM\n");
 		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
 							     subdev_channel * 8);
 		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
 		break;
 
 	case SinglePulseGeneration:
-		printk(KERN_INFO "S526: INSN_WRITE: SPG\n");
 		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
 							     subdev_channel * 8);
 		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
@@ -482,15 +473,12 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   The above periods must be expressed as a multiple of the
 		   pulse frequency on the selected source
 		 */
-		printk(KERN_INFO "S526: INSN_WRITE: PTG\n");
 		if ((data[1] > data[0]) && (data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
 			    data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
 			    data[1];
 		} else {
-			printk(KERN_ERR "s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
-				data[0], data[1]);
 			return -EINVAL;
 		}
 
@@ -500,9 +488,6 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 		break;
 	default:		/*  Impossible */
-		printk
-		    ("s526: INSN_WRITE: Functionality %d not implemented yet\n",
-		     devpriv->s526_gpct_config[subdev_channel].app);
 		return -EINVAL;
 		break;
 	}
@@ -574,13 +559,8 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 				break;
 			}
 		}
-		if (i == TIMEOUT) {
-			/* printk() should be used instead of printk()
-			 * whenever the code can be called from real-time. */
-			printk(KERN_ERR "s526: ADC(0x%04x) timeout\n",
-			       inw(dev->iobase + REG_ISR));
+		if (i == TIMEOUT)
 			return -ETIMEDOUT;
-		}
 
 		/* read data */
 		d = inw(dev->iobase + REG_ADD);
@@ -674,8 +654,6 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	int chan = CR_CHAN(insn->chanspec);
 	int group, mask;
 
-	printk(KERN_INFO "S526 DIO insn_config\n");
-
 	/* The input or output configuration of each digital line is
 	 * configured by a special insn_config instruction.  chanspec
 	 * contains the channel to be changed, and data[0] contains the
@@ -712,8 +690,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int iobase;
 	int ret;
 
-	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
-
 	iobase = it->options[0];
 	if (!iobase || !request_region(iobase, S526_IOSIZE, board->name)) {
 		comedi_error(dev, "I/O port conflict");
@@ -721,8 +697,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	dev->iobase = iobase;
 
-	printk("iobase=0x%lx\n", dev->iobase);
-
 	dev->board_name = board->name;
 
 	ret = alloc_private(dev, sizeof(*devpriv));
@@ -792,7 +766,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	printk(KERN_INFO "attached\n");
+	dev_info(dev->class_dev, "%s attached\n", dev->board_name);
 
 	return 1;
 }

commit 28eb7e8d7649f2497c334d5e6d36e5f4fef13233
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:10:15 2012 -0700

    staging: comedi: s526: remove unreachable code in s526_attach()
    
    The code after the return in this function can never execute.
    Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index f9f0fdaec159..f0144d9cdf27 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -710,11 +710,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct s526_private *devpriv;
 	struct comedi_subdevice *s;
 	int iobase;
-	int i, n;
 	int ret;
-/* short value; */
-/* int subdev_channel = 0; */
-	union cmReg cmReg;
 
 	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
 
@@ -799,90 +795,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(KERN_INFO "attached\n");
 
 	return 1;
-
-#if 0
-	/*  Example of Counter Application */
-	/* One-shot (software trigger) */
-	cmReg.reg.coutSource = 0;	/*  out RCAP */
-	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */
-	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
-	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
-	cmReg.reg.clockSource = 2;	/*  Internal */
-	cmReg.reg.countDir = 1;	/*  Down */
-	cmReg.reg.countDirCtrl = 1;	/*  Software */
-	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-	cmReg.reg.reserved = 0;
-
-	outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
-
-	outw(0x0001, dev->iobase + REG_C0H + subdev_channel * 8);
-	outw(0x3C68, dev->iobase + REG_C0L + subdev_channel * 8);
-
-	/*  Reset the counter */
-	outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
-	/*  Load the counter from PR0 */
-	outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
-	/*  Reset RCAP (fires one-shot) */
-	outw(0x0008, dev->iobase + REG_C0C + subdev_channel * 8);
-
-#else
-
-	/*  Set Counter Mode Register */
-	cmReg.reg.coutSource = 0;	/*  out RCAP */
-	cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
-	cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
-	cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
-	cmReg.reg.clockSource = 3;	/*  x4 */
-	cmReg.reg.countDir = 0;	/*  up */
-	cmReg.reg.countDirCtrl = 0;	/*  quadrature */
-	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-	cmReg.reg.reserved = 0;
-
-	n = 0;
-	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
-		cmReg.value, dev->iobase + REG_C0M + n * 8);
-	outw(cmReg.value, dev->iobase + REG_C0M + n * 8);
-	udelay(1000);
-	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-		inw(dev->iobase + REG_C0M + n * 8));
-
-	/*  Load the pre-load register high word */
-/* value = (short) (0x55); */
-/* outw(value, dev->iobase + REG_C0H + n * 8); */
-
-	/*  Load the pre-load register low word */
-/* value = (short)(0xaa55); */
-/* outw(value, dev->iobase + REG_C0L + n * 8); */
-
-	/*  Write the Counter Control Register */
-/* outw(value, dev->iobase + REG_C0C + 0 * 8); */
-
-	/*  Reset the counter if it is software preload */
-	if (cmReg.reg.autoLoadResetRcap == 0) {
-		/*  Reset the counter */
-		outw(0x8000, dev->iobase + REG_C0C + n * 8);
-		/*  Load the counter from PR0 */
-		outw(0x4000, dev->iobase + REG_C0C + n * 8);
-	}
-
-	outw(cmReg.value, dev->iobase + REG_C0M + n * 8);
-	udelay(1000);
-	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-			inw(dev->iobase + REG_C0M + n * 8));
-
-#endif
-	printk(KERN_INFO "Current registres:\n");
-
-	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk(KERN_INFO "0x%02lx: 0x%04x\n",
-			dev->iobase + s526_ports[i],
-			inw(dev->iobase + s526_ports[i]));
-	}
-	return 1;
 }
 
 static void s526_detach(struct comedi_device *dev)

commit d52f042ce5d64bbc56160e3653de064d380120c7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:09:57 2012 -0700

    staging: comedi: s526: remove unneeded check in s526_gpct_rinsn()
    
    The comedi core validates insn->n before calling this function.
    Remove the unnecessary check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 75e3e58e552a..f9f0fdaec159 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -217,11 +217,6 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 	unsigned short datalow;
 	unsigned short datahigh;
 
-	/*  Check if (n > 0) */
-	if (insn->n <= 0) {
-		printk(KERN_ERR "s526: INSN_READ: n should be > 0\n");
-		return -EINVAL;
-	}
 	/*  Read the low word first */
 	for (i = 0; i < insn->n; i++) {
 		datalow = inw(dev->iobase + REG_C0L + counter_channel * 8);

commit 898143bd1ac1550f3b2b2eaf397b13fc1d1889d1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:09:40 2012 -0700

    staging: comedi: s526: remove commented out debug messages
    
    These messages should be removed from the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 9abbf1b9084f..75e3e58e552a 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -228,8 +228,6 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 		datahigh = inw(dev->iobase + REG_C0H + counter_channel * 8);
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
-		/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n",
-		   counter_channel, data[i], datahigh, datalow); */
 	}
 	return i;
 }
@@ -244,13 +242,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-	/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n",
-						subdev_channel); */
-
-	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
+	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++)
 		devpriv->s526_gpct_config[subdev_channel].data[i] = data[i];
-/* printk("data[%d]=%x\n", i, data[i]); */
-	}
 
 	/*  Check what type of Counter the user requested, data[0] contains */
 	/*  the Application type */
@@ -299,8 +292,6 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 #if 1
 		/*  Set Counter Mode Register */
 		cmReg.value = data[1] & 0xFFFF;
-
-/* printk("s526: Counter Mode register=%x\n", cmReg.value); */
 		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Reset the counter if it is software preload */
@@ -546,7 +537,6 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 
 	/*  Enable ADC interrupt */
 	outw(ISR_ADC_DONE, dev->iobase + REG_IER);
-/* printk("s526: ADC current value: 0x%04x\n", inw(dev->iobase + REG_ADC)); */
 	devpriv->s526_ai_config = (data[0] & 0x3FF) << 5;
 	if (data[1] > 0)
 		devpriv->s526_ai_config |= 0x8000;	/* set the delay */
@@ -579,8 +569,6 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
 		outw(value, dev->iobase + REG_ADC);
-/* printk("s526: Wrote 0x%04x to ADC\n", value); */
-/* printk("s526: ADC reg=0x%04x\n", inw(dev->iobase + REG_ADC)); */
 
 #define TIMEOUT 100
 		/* wait for conversion to end */
@@ -601,7 +589,6 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 
 		/* read data */
 		d = inw(dev->iobase + REG_ADD);
-/* printk("AI[%d]=0x%04x\n", n, (unsigned short)(d & 0xFFFF)); */
 
 		/* munge data */
 		data[n] = d ^ 0x8000;
@@ -619,7 +606,6 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned short val;
 
-/* printk("s526_ao_winsn\n"); */
 	val = chan << 1;
 /* outw(val, dev->iobase + REG_DAC); */
 	outw(val, dev->iobase + REG_DAC);
@@ -746,13 +732,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	printk("iobase=0x%lx\n", dev->iobase);
 
-	/*** make it a little quieter, exw, 8/29/06
-	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02x: 0x%04x\n", dev->iobase + s526_ports[i],
-				inw(dev->iobase + s526_ports[i]));
-	}
-	***/
-
 	dev->board_name = board->name;
 
 	ret = alloc_private(dev, sizeof(*devpriv));

commit 36fe5d265d394ce6889970665abcbc259d92c1cf
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:09:21 2012 -0700

    staging: comedi: s526: remove ADDR_CHAN_REG macro
    
    This macro relies on a local variable having a specific name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 888875ef88b4..9abbf1b9084f 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -197,8 +197,6 @@ static const struct s526_board s526_boards[] = {
 	 }
 };
 
-#define ADDR_CHAN_REG(reg, chan) (dev->iobase + (reg) + (chan) * 8)
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device
@@ -226,8 +224,8 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 	}
 	/*  Read the low word first */
 	for (i = 0; i < insn->n; i++) {
-		datalow = inw(ADDR_CHAN_REG(REG_C0L, counter_channel));
-		datahigh = inw(ADDR_CHAN_REG(REG_C0H, counter_channel));
+		datalow = inw(dev->iobase + REG_C0L + counter_channel * 8);
+		datahigh = inw(dev->iobase + REG_C0H + counter_channel * 8);
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
 		/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n",
@@ -283,18 +281,18 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		cmReg.reg.reserved = 0;
 
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
-		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(0x0001, dev->iobase + REG_C0H + subdev_channel * 8);
+		outw(0x3C68, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Reset the counter */
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
 		/*  Load the counter from PR0 */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
 
 		/*  Reset RCAP (fires one-shot) */
-		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		outw(0x0008, dev->iobase +  REG_C0C + subdev_channel * 8);
 
 #endif
 
@@ -303,14 +301,14 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.value = data[1] & 0xFFFF;
 
 /* printk("s526: Counter Mode register=%x\n", cmReg.value); */
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
 			/* Load the counter from PR0
-			 * outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			 * outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
 			 */
 		}
 #else
@@ -338,27 +336,27 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Load the pre-load register high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 
 		/*  Load the pre-load register low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[3] != 0) {
 			value = (short)(data[3] & 0xFFFF);
-			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
 		}
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
 			/*  Reset the counter */
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
 			/*  Load the counter from PR0 */
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
 		}
 #endif
 		break;
@@ -378,33 +376,33 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Load the pre-load register 0 high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 
 		/*  Load the pre-load register 0 low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Load the pre-load register 1 high word */
 		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 
 		/*  Load the pre-load register 1 low word */
 		value = (short)(data[3] & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[4] != 0) {
 			value = (short)(data[4] & 0xFFFF);
-			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
 		}
 		break;
 
@@ -423,33 +421,33 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Load the pre-load register 0 high word */
 		value = (short)((data[2] >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 
 		/*  Load the pre-load register 0 low word */
 		value = (short)(data[2] & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
-		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+		outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
 		/*  Load the pre-load register 1 high word */
 		value = (short)((data[3] >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 
 		/*  Load the pre-load register 1 low word */
 		value = (short)(data[3] & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 
 		/*  Write the Counter Control Register */
 		if (data[4] != 0) {
 			value = (short)(data[4] & 0xFFFF);
-			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			outw(value, dev->iobase + REG_C0C + subdev_channel * 8);
 		}
 		break;
 
@@ -473,22 +471,22 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 
 	printk(KERN_INFO "s526: GPCT_INSN_WRITE on channel %d\n",
 					subdev_channel);
-	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
+	cmReg.value = inw(dev->iobase + REG_C0M + subdev_channel * 8);
 	printk(KERN_INFO "s526: Counter Mode Register: %x\n", cmReg.value);
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[subdev_channel].app) {
 	case PositionMeasurement:
 		printk(KERN_INFO "S526: INSN_WRITE: PM\n");
-		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-							     subdev_channel));
-		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
+							     subdev_channel * 8);
+		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
 		break;
 
 	case SinglePulseGeneration:
 		printk(KERN_INFO "S526: INSN_WRITE: SPG\n");
-		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-							     subdev_channel));
-		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(0xFFFF & ((*data) >> 16), dev->iobase + REG_C0H +
+							     subdev_channel * 8);
+		outw(0xFFFF & (*data), dev->iobase + REG_C0L + subdev_channel * 8);
 		break;
 
 	case PulseTrainGeneration:
@@ -511,9 +509,9 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		}
 
 		value = (short)((*data >> 16) & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(value, dev->iobase + REG_C0H + subdev_channel * 8);
 		value = (short)(*data & 0xFFFF);
-		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		outw(value, dev->iobase + REG_C0L + subdev_channel * 8);
 		break;
 	default:		/*  Impossible */
 		printk
@@ -843,17 +841,17 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 	cmReg.reg.reserved = 0;
 
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+	outw(cmReg.value, dev->iobase + REG_C0M + subdev_channel * 8);
 
-	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+	outw(0x0001, dev->iobase + REG_C0H + subdev_channel * 8);
+	outw(0x3C68, dev->iobase + REG_C0L + subdev_channel * 8);
 
 	/*  Reset the counter */
-	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	outw(0x8000, dev->iobase + REG_C0C + subdev_channel * 8);
 	/*  Load the counter from PR0 */
-	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	outw(0x4000, dev->iobase + REG_C0C + subdev_channel * 8);
 	/*  Reset RCAP (fires one-shot) */
-	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	outw(0x0008, dev->iobase + REG_C0C + subdev_channel * 8);
 
 #else
 
@@ -872,35 +870,35 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	n = 0;
 	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
-		cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+		cmReg.value, dev->iobase + REG_C0M + n * 8);
+	outw(cmReg.value, dev->iobase + REG_C0M + n * 8);
 	udelay(1000);
 	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-		inw(ADDR_CHAN_REG(REG_C0M, n)));
+		inw(dev->iobase + REG_C0M + n * 8));
 
 	/*  Load the pre-load register high word */
 /* value = (short) (0x55); */
-/* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */
+/* outw(value, dev->iobase + REG_C0H + n * 8); */
 
 	/*  Load the pre-load register low word */
 /* value = (short)(0xaa55); */
-/* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */
+/* outw(value, dev->iobase + REG_C0L + n * 8); */
 
 	/*  Write the Counter Control Register */
-/* outw(value, ADDR_CHAN_REG(REG_C0C, 0)); */
+/* outw(value, dev->iobase + REG_C0C + 0 * 8); */
 
 	/*  Reset the counter if it is software preload */
 	if (cmReg.reg.autoLoadResetRcap == 0) {
 		/*  Reset the counter */
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));
+		outw(0x8000, dev->iobase + REG_C0C + n * 8);
 		/*  Load the counter from PR0 */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));
+		outw(0x4000, dev->iobase + REG_C0C + n * 8);
 	}
 
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	outw(cmReg.value, dev->iobase + REG_C0M + n * 8);
 	udelay(1000);
 	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-			inw(ADDR_CHAN_REG(REG_C0M, n)));
+			inw(dev->iobase + REG_C0M + n * 8));
 
 #endif
 	printk(KERN_INFO "Current registres:\n");

commit 0171e6f5bb193008361bf9668c26d8cffc41e70a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:09:07 2012 -0700

    staging: comedi: s526: remove ADDR_REG macro
    
    This macro relies on a local variable having a specific name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index c89f35227baf..888875ef88b4 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -197,7 +197,6 @@ static const struct s526_board s526_boards[] = {
 	 }
 };
 
-#define ADDR_REG(reg) (dev->iobase + (reg))
 #define ADDR_CHAN_REG(reg, chan) (dev->iobase + (reg) + (chan) * 8)
 
 /* this structure is for data unique to this hardware driver.  If
@@ -548,8 +547,8 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 	 * INSN_READ handler. */
 
 	/*  Enable ADC interrupt */
-	outw(ISR_ADC_DONE, ADDR_REG(REG_IER));
-/* printk("s526: ADC current value: 0x%04x\n", inw(ADDR_REG(REG_ADC))); */
+	outw(ISR_ADC_DONE, dev->iobase + REG_IER);
+/* printk("s526: ADC current value: 0x%04x\n", inw(dev->iobase + REG_ADC)); */
 	devpriv->s526_ai_config = (data[0] & 0x3FF) << 5;
 	if (data[1] > 0)
 		devpriv->s526_ai_config |= 0x8000;	/* set the delay */
@@ -581,16 +580,16 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
-		outw(value, ADDR_REG(REG_ADC));
+		outw(value, dev->iobase + REG_ADC);
 /* printk("s526: Wrote 0x%04x to ADC\n", value); */
-/* printk("s526: ADC reg=0x%04x\n", inw(ADDR_REG(REG_ADC))); */
+/* printk("s526: ADC reg=0x%04x\n", inw(dev->iobase + REG_ADC)); */
 
 #define TIMEOUT 100
 		/* wait for conversion to end */
 		for (i = 0; i < TIMEOUT; i++) {
-			status = inw(ADDR_REG(REG_ISR));
+			status = inw(dev->iobase + REG_ISR);
 			if (status & ISR_ADC_DONE) {
-				outw(ISR_ADC_DONE, ADDR_REG(REG_ISR));
+				outw(ISR_ADC_DONE, dev->iobase + REG_ISR);
 				break;
 			}
 		}
@@ -598,12 +597,12 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
 			printk(KERN_ERR "s526: ADC(0x%04x) timeout\n",
-			       inw(ADDR_REG(REG_ISR)));
+			       inw(dev->iobase + REG_ISR));
 			return -ETIMEDOUT;
 		}
 
 		/* read data */
-		d = inw(ADDR_REG(REG_ADD));
+		d = inw(dev->iobase + REG_ADD);
 /* printk("AI[%d]=0x%04x\n", n, (unsigned short)(d & 0xFFFF)); */
 
 		/* munge data */
@@ -625,7 +624,7 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 /* printk("s526_ao_winsn\n"); */
 	val = chan << 1;
 /* outw(val, dev->iobase + REG_DAC); */
-	outw(val, ADDR_REG(REG_DAC));
+	outw(val, dev->iobase + REG_DAC);
 
 	/* Writing a list of values to an AO channel is probably not
 	 * very useful, but that's how the interface is defined. */
@@ -635,10 +634,11 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		 * outw(data[i], dev->iobase + REG_ADD);
 		 */
 		/* write the data to preload register */
-		outw(data[i], ADDR_REG(REG_ADD));
+		outw(data[i], dev->iobase + REG_ADD);
 		devpriv->ao_readback[chan] = data[i];
 /* outw(val + 1, dev->iobase + REG_DAC);  starts the D/A conversion. */
-		outw(val + 1, ADDR_REG(REG_DAC)); /*starts the D/A conversion.*/
+		/* starts the D/A conversion */
+		outw(val + 1, dev->iobase + REG_DAC);
 	}
 
 	/* return the number of samples read/written */
@@ -675,12 +675,12 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 		s->state &= ~data[0];
 		s->state |= data[0] & data[1];
 		/* Write out the new digital output lines */
-		outw(s->state, ADDR_REG(REG_DIO));
+		outw(s->state, dev->iobase + REG_DIO);
 	}
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF; /* low 8 bits are the data */
+	data[1] = inw(dev->iobase + REG_DIO) & 0xff;
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
 	/* data[1]=s->state & 0xFF; */
@@ -720,7 +720,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	default:
 		return -EINVAL;
 	}
-	outw(s->state, ADDR_REG(REG_DIO));
+	outw(s->state, dev->iobase + REG_DIO);
 
 	return 1;
 }
@@ -750,8 +750,8 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*** make it a little quieter, exw, 8/29/06
 	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]),
-				inw(ADDR_REG(s526_ports[i])));
+		printk("0x%02x: 0x%04x\n", dev->iobase + s526_ports[i],
+				inw(dev->iobase + s526_ports[i]));
 	}
 	***/
 
@@ -907,7 +907,8 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (i = 0; i < S526_NUM_PORTS; i++) {
 		printk(KERN_INFO "0x%02lx: 0x%04x\n",
-			ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
+			dev->iobase + s526_ports[i],
+			inw(dev->iobase + s526_ports[i]));
 	}
 	return 1;
 }

commit 5f2210627f8d3c5f7842b4c20d65d9f81690be49
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:08:52 2012 -0700

    staging: comedi: s526: remove devpriv macro
    
    This macro relies on a local variable having a specific name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 43f5c7d126ca..c89f35227baf 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -211,12 +211,6 @@ struct s526_private {
 	unsigned short s526_ai_config;
 };
 
-/*
- * most drivers define the following macro to make it easy to
- * access the private structure.
- */
-#define devpriv ((struct s526_private *)dev->private)
-
 static int s526_gpct_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
@@ -247,6 +241,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_insn *insn, unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
 	short value;
@@ -472,6 +467,7 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
 	union cmReg cmReg;
@@ -536,6 +532,7 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int result = -EINVAL;
 
 	if (insn->n < 1)
@@ -569,6 +566,7 @@ static int s526_ai_insn_config(struct comedi_device *dev,
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned short value;
@@ -619,6 +617,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned short val;
@@ -651,6 +650,7 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			 struct comedi_insn *insn, unsigned int *data)
 {
+	struct s526_private *devpriv = dev->private;
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -728,6 +728,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct s526_board *board = comedi_board(dev);
+	struct s526_private *devpriv;
 	struct comedi_subdevice *s;
 	int iobase;
 	int i, n;
@@ -756,12 +757,10 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->board_name = board->name;
 
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
-		return -ENOMEM;
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)

commit b2abd982c484ba0e46ea681b0bc6d7baf7c47730
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 19 15:08:35 2012 -0700

    staging: comedi: s526: don't dereference insn->data pointer
    
    The comedi_insn 'data' pointer is a __user pointer that is
    passed into the kernel using an ioctl. The comedi core copies
    this data to kernel space in do_insnlist_ioctl() and then
    passes that kernel data to the drivers as a separate parameter.
    The drivers never need to access the data through the insn->data
    pointer.
    
    This fixes a number of sparse warnings about:
    
      warning: dereference of noderef expression
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index c89bd6cde8bc..43f5c7d126ca 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -256,14 +256,13 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 						subdev_channel); */
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
-		devpriv->s526_gpct_config[subdev_channel].data[i] =
-		    insn->data[i];
-/* printk("data[%d]=%x\n", i, insn->data[i]); */
+		devpriv->s526_gpct_config[subdev_channel].data[i] = data[i];
+/* printk("data[%d]=%x\n", i, data[i]); */
 	}
 
 	/*  Check what type of Counter the user requested, data[0] contains */
 	/*  the Application type */
-	switch (insn->data[0]) {
+	switch (data[0]) {
 	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
 		/*
 		   data[0]: Application Type
@@ -307,7 +306,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 #if 1
 		/*  Set Counter Mode Register */
-		cmReg.value = insn->data[1] & 0xFFFF;
+		cmReg.value = data[1] & 0xFFFF;
 
 /* printk("s526: Counter Mode register=%x\n", cmReg.value); */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
@@ -325,39 +324,39 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.countDirCtrl = 0;
 
 		/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */
-		if (insn->data[1] == GPCT_X2)
+		if (data[1] == GPCT_X2)
 			cmReg.reg.clockSource = 1;
-		else if (insn->data[1] == GPCT_X4)
+		else if (data[1] == GPCT_X4)
 			cmReg.reg.clockSource = 2;
 		else
 			cmReg.reg.clockSource = 0;
 
 		/*  When to take into account the indexpulse: */
-		/*if (insn->data[2] == GPCT_IndexPhaseLowLow) {
-		} else if (insn->data[2] == GPCT_IndexPhaseLowHigh) {
-		} else if (insn->data[2] == GPCT_IndexPhaseHighLow) {
-		} else if (insn->data[2] == GPCT_IndexPhaseHighHigh) {
+		/*if (data[2] == GPCT_IndexPhaseLowLow) {
+		} else if (data[2] == GPCT_IndexPhaseLowHigh) {
+		} else if (data[2] == GPCT_IndexPhaseHighLow) {
+		} else if (data[2] == GPCT_IndexPhaseHighHigh) {
 		}*/
 		/*  Take into account the index pulse? */
-		if (insn->data[3] == GPCT_RESET_COUNTER_ON_INDEX)
+		if (data[3] == GPCT_RESET_COUNTER_ON_INDEX)
 			/*  Auto load with INDEX^ */
 			cmReg.reg.autoLoadResetRcap = 4;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-load register high word */
-		value = (short)((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-load register low word */
-		value = (short)(insn->data[2] & 0xFFFF);
+		value = (short)(data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
-		if (insn->data[3] != 0) {
-			value = (short)(insn->data[3] & 0xFFFF);
+		if (data[3] != 0) {
+			value = (short)(data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		/*  Reset the counter if it is software preload */
@@ -383,34 +382,34 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		    SinglePulseGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-load register 0 high word */
-		value = (short)((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-load register 0 low word */
-		value = (short)(insn->data[2] & 0xFFFF);
+		value = (short)(data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-load register 1 high word */
-		value = (short)((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-load register 1 low word */
-		value = (short)(insn->data[3] & 0xFFFF);
+		value = (short)(data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
-		if (insn->data[4] != 0) {
-			value = (short)(insn->data[4] & 0xFFFF);
+		if (data[4] != 0) {
+			value = (short)(data[4] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -428,34 +427,34 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		    PulseTrainGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-load register 0 high word */
-		value = (short)((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-load register 0 low word */
-		value = (short)(insn->data[2] & 0xFFFF);
+		value = (short)(data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short)(insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-load register 1 high word */
-		value = (short)((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-load register 1 low word */
-		value = (short)(insn->data[3] & 0xFFFF);
+		value = (short)(data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
-		if (insn->data[4] != 0) {
-			value = (short)(insn->data[4] & 0xFFFF);
+		if (data[4] != 0) {
+			value = (short)(data[4] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -505,14 +504,14 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   pulse frequency on the selected source
 		 */
 		printk(KERN_INFO "S526: INSN_WRITE: PTG\n");
-		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
+		if ((data[1] > data[0]) && (data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
-			    insn->data[0];
+			    data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
-			    insn->data[1];
+			    data[1];
 		} else {
 			printk(KERN_ERR "s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
-				insn->data[0], insn->data[1]);
+				data[0], data[1]);
 			return -EINVAL;
 		}
 

commit 97073c05d4b3ec5ba8c4c4b64a6f1005a4e1eb10
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:57:01 2012 -0700

    staging: comedi: s526: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 737a194dfce3..c89bd6cde8bc 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -768,7 +768,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
@@ -786,7 +786,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* s->do_cmdtest = s526_gpct_cmdtest; */
 	/* s->cancel = s526_gpct_cancel; */
 
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	/* dev->read_subdev=s; */
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
@@ -802,7 +802,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_read = s526_ai_rinsn;
 	s->insn_config = s526_ai_insn_config;
 
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	/* analog output subdevice */
 	s->type = COMEDI_SUBD_AO;
 	s->subdev_flags = SDF_WRITABLE;
@@ -812,7 +812,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->insn_write = s526_ao_winsn;
 	s->insn_read = s526_ao_rinsn;
 
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	/* digital i/o subdevice */
 	if (board->have_dio) {
 		s->type = COMEDI_SUBD_DIO;

commit 1226f1ab90902f3aaaa2fdb01497b6ca765da888
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 19:05:55 2012 -0700

    staging: comedi: s526: remove unused variables in the private data
    
    The 'data' and 'pci_dev' variables in the private data are not used.
    They appear to be cut-and-paste from the skel driver. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 358380f3eac5..737a194dfce3 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -206,15 +206,7 @@ static const struct s526_board s526_boards[] = {
    struct.
 */
 struct s526_private {
-
-	int data;
-
-	/* would be useful for a PCI device */
-	struct pci_dev *pci_dev;
-
-	/* Used for AO readback */
 	unsigned int ao_readback[2];
-
 	struct s526GPCTConfig s526_gpct_config[4];
 	unsigned short s526_ai_config;
 };

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index b1dd22423704..358380f3eac5 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -694,7 +694,7 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 	 * it was a purely digital output subdevice */
 	/* data[1]=s->state & 0xFF; */
 
-	return 2;
+	return insn->n;
 }
 
 static int s526_dio_insn_config(struct comedi_device *dev,

commit 520706607befd1f5c20ec14db35d6be45791bc41
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 11:18:25 2012 -0700

    staging: comedi: remove unneeded sanity check in insn_bits functions
    
    The comedi core does the sanity check to make sure that the data length
    the INSN_BITS instruction is 2. There is no need for the drivers to do
    this check. Remove all the sanity checks in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 141bc9e881c9..b1dd22423704 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -678,9 +678,6 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
-	if (insn->n != 2)
-		return -EINVAL;
-
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
 	if (data[0]) {

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 6a30537987c6..141bc9e881c9 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -743,6 +743,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	int iobase;
 	int i, n;
+	int ret;
 /* short value; */
 /* int subdev_channel = 0; */
 	union cmReg cmReg;
@@ -774,8 +775,9 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
 		return -ENOMEM;
 
-	if (comedi_alloc_subdevices(dev, 4) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 4);
+	if (ret)
+		return ret;
 
 	s = dev->subdevices + 0;
 	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index dbbff70dc0ca..6a30537987c6 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -774,10 +774,6 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
 		return -ENOMEM;
 
-/*
- * Allocate the subdevice structures.  alloc_subdevice() is a
- * convenient macro defined in comedidev.h.
- */
 	if (comedi_alloc_subdevices(dev, 4) < 0)
 		return -ENOMEM;
 

commit fba1d0faf726b442ab8771d5e9fbaf5f5a4c624c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:27 2012 -0700

    staging: comedi: only set dev->n_subdevices when kcalloc succeedes
    
    It's possible for the kcalloc in comedi_alloc_subdevices to fail.
    Only set the dev->n_subdevices variable if the allocation is
    successful.
    
    Since the core sets dev->n_subdevices, remove all the places in the
    drivers where this variable was getting set.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 17d581b8ac6f..dbbff70dc0ca 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -778,8 +778,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * Allocate the subdevice structures.  alloc_subdevice() is a
  * convenient macro defined in comedidev.h.
  */
-	dev->n_subdevices = 4;
-	if (comedi_alloc_subdevices(dev, dev->n_subdevices) < 0)
+	if (comedi_alloc_subdevices(dev, 4) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 3c8e9799824e..17d581b8ac6f 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -779,7 +779,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * convenient macro defined in comedidev.h.
  */
 	dev->n_subdevices = 4;
-	if (alloc_subdevices(dev, dev->n_subdevices) < 0)
+	if (comedi_alloc_subdevices(dev, dev->n_subdevices) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit 5254cbe795c3bb9ef28d61a474d707385fc87178
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 18:20:10 2012 -0700

    staging: comedi: remove this_board macro in the s526 driver
    
    The 'thisboard' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 7a56434eb224..3c8e9799824e 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -200,11 +200,6 @@ static const struct s526_board s526_boards[] = {
 #define ADDR_REG(reg) (dev->iobase + (reg))
 #define ADDR_CHAN_REG(reg, chan) (dev->iobase + (reg) + (chan) * 8)
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct s526_board *)dev->board_ptr)
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device
@@ -744,6 +739,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct s526_board *board = comedi_board(dev);
 	struct comedi_subdevice *s;
 	int iobase;
 	int i, n;
@@ -754,7 +750,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
 
 	iobase = it->options[0];
-	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
+	if (!iobase || !request_region(iobase, S526_IOSIZE, board->name)) {
 		comedi_error(dev, "I/O port conflict");
 		return -EIO;
 	}
@@ -769,13 +765,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	***/
 
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_ptr = &s526_boards[0];
-
-	dev->board_name = thisboard->name;
+	dev->board_name = board->name;
 
 /*
  * Allocate the private structure area.  alloc_private() is a
@@ -797,7 +787,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->type = COMEDI_SUBD_COUNTER;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
 	/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */
-	s->n_chan = thisboard->gpct_chans;
+	s->n_chan = board->gpct_chans;
 	s->maxdata = 0x00ffffff;	/* 24 bit counter */
 	s->insn_read = s526_gpct_rinsn;
 	s->insn_config = s526_gpct_insn_config;
@@ -838,7 +828,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s = dev->subdevices + 3;
 	/* digital i/o subdevice */
-	if (thisboard->have_dio) {
+	if (board->have_dio) {
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
 		s->n_chan = 8;

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 3f86ed781d72..7a56434eb224 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -938,14 +938,10 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-static int s526_detach(struct comedi_device *dev)
+static void s526_detach(struct comedi_device *dev)
 {
-	printk(KERN_INFO "comedi%d: s526: remove\n", dev->minor);
-
 	if (dev->iobase > 0)
 		release_region(dev->iobase, S526_IOSIZE);
-
-	return 0;
 }
 
 static struct comedi_driver s526_driver = {

commit 294f930d98be86fb4f34302c718a49719650857f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 3 15:09:40 2012 -0700

    staging: comedi: use module_comedi_driver
    
    Convert the refactored comedi drivers to use the module_comedi_driver()
    macro which makes the code smaller and a bit simpler.
    
    In the process, rename the driver variables from driver_* to *_driver,
    as is more typical with other subsystems, and make sure they are all
    static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index ffe4362819e2..3f86ed781d72 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -948,7 +948,7 @@ static int s526_detach(struct comedi_device *dev)
 	return 0;
 }
 
-static struct comedi_driver driver_s526 = {
+static struct comedi_driver s526_driver = {
 	.driver_name	= "s526",
 	.module		= THIS_MODULE,
 	.attach		= s526_attach,
@@ -957,18 +957,7 @@ static struct comedi_driver driver_s526 = {
 	.offset		= sizeof(struct s526_board),
 	.num_names	= ARRAY_SIZE(s526_boards),
 };
-
-static int __init driver_s526_init_module(void)
-{
-	return comedi_driver_register(&driver_s526);
-}
-module_init(driver_s526_init_module);
-
-static void __exit driver_s526_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_s526);
-}
-module_exit(driver_s526_cleanup_module);
+module_comedi_driver(s526_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit e9a4a7fb4cf632b43f1207395f2ae64ba5a64f65
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 27 14:45:19 2012 -0700

    staging: comedi: refactor s526 driver to remove forward declarations
    
    Move the module_init/module_exit routines and the associated
    struct comedi_driver and other variables to the end of the source.
    This is more typical of how other drivers are written and removes
    the need for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 2b34daedc3d7..ffe4362819e2 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -230,287 +230,6 @@ struct s526_private {
  */
 #define devpriv ((struct s526_private *)dev->private)
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it);
-static int s526_detach(struct comedi_device *dev);
-static struct comedi_driver driver_s526 = {
-	.driver_name = "s526",
-	.module = THIS_MODULE,
-	.attach = s526_attach,
-	.detach = s526_detach,
-/* It is not necessary to implement the following members if you are
- * writing a driver for a ISA PnP or PCI card */
-	/* Most drivers will support multiple types of boards by
-	 * having an array of board structures.  These were defined
-	 * in s526_boards[] above.  Note that the element 'name'
-	 * was first in the structure -- Comedi uses this fact to
-	 * extract the name of the board without knowing any details
-	 * about the structure except for its length.
-	 * When a device is attached (by comedi_config), the name
-	 * of the device is given to Comedi, and Comedi tries to
-	 * match it by going through the list of board names.  If
-	 * there is a match, the address of the pointer is put
-	 * into dev->board_ptr and driver->attach() is called.
-	 *
-	 * Note that these are not necessary if you can determine
-	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
-	 * devices are such boards.
-	 */
-	.board_name = &s526_boards[0].name,
-	.offset = sizeof(struct s526_board),
-	.num_names = ARRAY_SIZE(s526_boards),
-};
-
-static int s526_gpct_rinsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int s526_gpct_insn_config(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_insn *insn, unsigned int *data);
-static int s526_gpct_winsn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int s526_ai_insn_config(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data);
-static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data);
-static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data);
-static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_bits(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_config(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data);
-
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	struct comedi_subdevice *s;
-	int iobase;
-	int i, n;
-/* short value; */
-/* int subdev_channel = 0; */
-	union cmReg cmReg;
-
-	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
-
-	iobase = it->options[0];
-	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
-		comedi_error(dev, "I/O port conflict");
-		return -EIO;
-	}
-	dev->iobase = iobase;
-
-	printk("iobase=0x%lx\n", dev->iobase);
-
-	/*** make it a little quieter, exw, 8/29/06
-	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]),
-				inw(ADDR_REG(s526_ports[i])));
-	}
-	***/
-
-/*
- * Initialize dev->board_name.  Note that we can use the "thisboard"
- * macro now, since we just initialized it in the last line.
- */
-	dev->board_ptr = &s526_boards[0];
-
-	dev->board_name = thisboard->name;
-
-/*
- * Allocate the private structure area.  alloc_private() is a
- * convenient macro defined in comedidev.h.
- */
-	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
-		return -ENOMEM;
-
-/*
- * Allocate the subdevice structures.  alloc_subdevice() is a
- * convenient macro defined in comedidev.h.
- */
-	dev->n_subdevices = 4;
-	if (alloc_subdevices(dev, dev->n_subdevices) < 0)
-		return -ENOMEM;
-
-	s = dev->subdevices + 0;
-	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
-	/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */
-	s->n_chan = thisboard->gpct_chans;
-	s->maxdata = 0x00ffffff;	/* 24 bit counter */
-	s->insn_read = s526_gpct_rinsn;
-	s->insn_config = s526_gpct_insn_config;
-	s->insn_write = s526_gpct_winsn;
-
-	/* Command are not implemented yet, however they are necessary to
-	   allocate the necessary memory for the comedi_async struct (used
-	   to trigger the GPCT in case of pulsegenerator function */
-	/* s->do_cmd = s526_gpct_cmd; */
-	/* s->do_cmdtest = s526_gpct_cmdtest; */
-	/* s->cancel = s526_gpct_cancel; */
-
-	s = dev->subdevices + 1;
-	/* dev->read_subdev=s; */
-	/* analog input subdevice */
-	s->type = COMEDI_SUBD_AI;
-	/* we support differential */
-	s->subdev_flags = SDF_READABLE | SDF_DIFF;
-	/* channels 0 to 7 are the regular differential inputs */
-	/* channel 8 is "reference 0" (+10V), channel 9 is "reference 1" (0V) */
-	s->n_chan = 10;
-	s->maxdata = 0xffff;
-	s->range_table = &range_bipolar10;
-	s->len_chanlist = 16;	/* This is the maximum chanlist length that
-				   the board can handle */
-	s->insn_read = s526_ai_rinsn;
-	s->insn_config = s526_ai_insn_config;
-
-	s = dev->subdevices + 2;
-	/* analog output subdevice */
-	s->type = COMEDI_SUBD_AO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = 4;
-	s->maxdata = 0xffff;
-	s->range_table = &range_bipolar10;
-	s->insn_write = s526_ao_winsn;
-	s->insn_read = s526_ao_rinsn;
-
-	s = dev->subdevices + 3;
-	/* digital i/o subdevice */
-	if (thisboard->have_dio) {
-		s->type = COMEDI_SUBD_DIO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = 8;
-		s->maxdata = 1;
-		s->range_table = &range_digital;
-		s->insn_bits = s526_dio_insn_bits;
-		s->insn_config = s526_dio_insn_config;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	printk(KERN_INFO "attached\n");
-
-	return 1;
-
-#if 0
-	/*  Example of Counter Application */
-	/* One-shot (software trigger) */
-	cmReg.reg.coutSource = 0;	/*  out RCAP */
-	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */
-	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
-	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
-	cmReg.reg.clockSource = 2;	/*  Internal */
-	cmReg.reg.countDir = 1;	/*  Down */
-	cmReg.reg.countDirCtrl = 1;	/*  Software */
-	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-	cmReg.reg.reserved = 0;
-
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
-
-	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
-
-	/*  Reset the counter */
-	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
-	/*  Load the counter from PR0 */
-	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
-	/*  Reset RCAP (fires one-shot) */
-	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
-
-#else
-
-	/*  Set Counter Mode Register */
-	cmReg.reg.coutSource = 0;	/*  out RCAP */
-	cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
-	cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
-	cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
-	cmReg.reg.clockSource = 3;	/*  x4 */
-	cmReg.reg.countDir = 0;	/*  up */
-	cmReg.reg.countDirCtrl = 0;	/*  quadrature */
-	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-	cmReg.reg.reserved = 0;
-
-	n = 0;
-	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
-		cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
-	udelay(1000);
-	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-		inw(ADDR_CHAN_REG(REG_C0M, n)));
-
-	/*  Load the pre-load register high word */
-/* value = (short) (0x55); */
-/* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */
-
-	/*  Load the pre-load register low word */
-/* value = (short)(0xaa55); */
-/* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */
-
-	/*  Write the Counter Control Register */
-/* outw(value, ADDR_CHAN_REG(REG_C0C, 0)); */
-
-	/*  Reset the counter if it is software preload */
-	if (cmReg.reg.autoLoadResetRcap == 0) {
-		/*  Reset the counter */
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));
-		/*  Load the counter from PR0 */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));
-	}
-
-	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
-	udelay(1000);
-	printk(KERN_INFO "Read back mode reg=0x%04x\n",
-			inw(ADDR_CHAN_REG(REG_C0M, n)));
-
-#endif
-	printk(KERN_INFO "Current registres:\n");
-
-	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk(KERN_INFO "0x%02lx: 0x%04x\n",
-			ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
-	}
-	return 1;
-}
-
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int s526_detach(struct comedi_device *dev)
-{
-	printk(KERN_INFO "comedi%d: s526: remove\n", dev->minor);
-
-	if (dev->iobase > 0)
-		release_region(dev->iobase, S526_IOSIZE);
-
-	return 0;
-}
-
 static int s526_gpct_rinsn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
@@ -1023,21 +742,232 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	return 1;
 }
 
+static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	struct comedi_subdevice *s;
+	int iobase;
+	int i, n;
+/* short value; */
+/* int subdev_channel = 0; */
+	union cmReg cmReg;
+
+	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
+
+	iobase = it->options[0];
+	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
+		comedi_error(dev, "I/O port conflict");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	printk("iobase=0x%lx\n", dev->iobase);
+
+	/*** make it a little quieter, exw, 8/29/06
+	for (i = 0; i < S526_NUM_PORTS; i++) {
+		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]),
+				inw(ADDR_REG(s526_ports[i])));
+	}
+	***/
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_ptr = &s526_boards[0];
+
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
+		return -ENOMEM;
+
 /*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
+ * Allocate the subdevice structures.  alloc_subdevice() is a
+ * convenient macro defined in comedidev.h.
  */
+	dev->n_subdevices = 4;
+	if (alloc_subdevices(dev, dev->n_subdevices) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
+	/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */
+	s->n_chan = thisboard->gpct_chans;
+	s->maxdata = 0x00ffffff;	/* 24 bit counter */
+	s->insn_read = s526_gpct_rinsn;
+	s->insn_config = s526_gpct_insn_config;
+	s->insn_write = s526_gpct_winsn;
+
+	/* Command are not implemented yet, however they are necessary to
+	   allocate the necessary memory for the comedi_async struct (used
+	   to trigger the GPCT in case of pulsegenerator function */
+	/* s->do_cmd = s526_gpct_cmd; */
+	/* s->do_cmdtest = s526_gpct_cmdtest; */
+	/* s->cancel = s526_gpct_cancel; */
+
+	s = dev->subdevices + 1;
+	/* dev->read_subdev=s; */
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	/* we support differential */
+	s->subdev_flags = SDF_READABLE | SDF_DIFF;
+	/* channels 0 to 7 are the regular differential inputs */
+	/* channel 8 is "reference 0" (+10V), channel 9 is "reference 1" (0V) */
+	s->n_chan = 10;
+	s->maxdata = 0xffff;
+	s->range_table = &range_bipolar10;
+	s->len_chanlist = 16;	/* This is the maximum chanlist length that
+				   the board can handle */
+	s->insn_read = s526_ai_rinsn;
+	s->insn_config = s526_ai_insn_config;
+
+	s = dev->subdevices + 2;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = 4;
+	s->maxdata = 0xffff;
+	s->range_table = &range_bipolar10;
+	s->insn_write = s526_ao_winsn;
+	s->insn_read = s526_ao_rinsn;
+
+	s = dev->subdevices + 3;
+	/* digital i/o subdevice */
+	if (thisboard->have_dio) {
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->n_chan = 8;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = s526_dio_insn_bits;
+		s->insn_config = s526_dio_insn_config;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	printk(KERN_INFO "attached\n");
+
+	return 1;
+
+#if 0
+	/*  Example of Counter Application */
+	/* One-shot (software trigger) */
+	cmReg.reg.coutSource = 0;	/*  out RCAP */
+	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
+	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */
+	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
+	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
+	cmReg.reg.clockSource = 2;	/*  Internal */
+	cmReg.reg.countDir = 1;	/*  Down */
+	cmReg.reg.countDirCtrl = 1;	/*  Software */
+	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
+	cmReg.reg.reserved = 0;
+
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+	/*  Reset the counter */
+	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Load the counter from PR0 */
+	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Reset RCAP (fires one-shot) */
+	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+
+#else
+
+	/*  Set Counter Mode Register */
+	cmReg.reg.coutSource = 0;	/*  out RCAP */
+	cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
+	cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+	cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
+	cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
+	cmReg.reg.clockSource = 3;	/*  x4 */
+	cmReg.reg.countDir = 0;	/*  up */
+	cmReg.reg.countDirCtrl = 0;	/*  quadrature */
+	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
+	cmReg.reg.reserved = 0;
+
+	n = 0;
+	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
+		cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	udelay(1000);
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+		inw(ADDR_CHAN_REG(REG_C0M, n)));
+
+	/*  Load the pre-load register high word */
+/* value = (short) (0x55); */
+/* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */
+
+	/*  Load the pre-load register low word */
+/* value = (short)(0xaa55); */
+/* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */
+
+	/*  Write the Counter Control Register */
+/* outw(value, ADDR_CHAN_REG(REG_C0C, 0)); */
+
+	/*  Reset the counter if it is software preload */
+	if (cmReg.reg.autoLoadResetRcap == 0) {
+		/*  Reset the counter */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));
+		/*  Load the counter from PR0 */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));
+	}
+
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	udelay(1000);
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+			inw(ADDR_CHAN_REG(REG_C0M, n)));
+
+#endif
+	printk(KERN_INFO "Current registres:\n");
+
+	for (i = 0; i < S526_NUM_PORTS; i++) {
+		printk(KERN_INFO "0x%02lx: 0x%04x\n",
+			ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
+	}
+	return 1;
+}
+
+static int s526_detach(struct comedi_device *dev)
+{
+	printk(KERN_INFO "comedi%d: s526: remove\n", dev->minor);
+
+	if (dev->iobase > 0)
+		release_region(dev->iobase, S526_IOSIZE);
+
+	return 0;
+}
+
+static struct comedi_driver driver_s526 = {
+	.driver_name	= "s526",
+	.module		= THIS_MODULE,
+	.attach		= s526_attach,
+	.detach		= s526_detach,
+	.board_name	= &s526_boards[0].name,
+	.offset		= sizeof(struct s526_board),
+	.num_names	= ARRAY_SIZE(s526_boards),
+};
+
 static int __init driver_s526_init_module(void)
 {
 	return comedi_driver_register(&driver_s526);
 }
+module_init(driver_s526_init_module);
 
 static void __exit driver_s526_cleanup_module(void)
 {
 	comedi_driver_unregister(&driver_s526);
 }
-
-module_init(driver_s526_init_module);
 module_exit(driver_s526_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit c9c62f4e2c9b526c5cbade3f3a61f126e6587c16
Author: Xenofon Foukas <foukas.xenofon@gmail.com>
Date:   Wed Dec 15 19:44:20 2010 +0200

    Staging: comedi: Fix checkpatch.pl issues in file s526.c
    
    This patch fixes the following issues in s526.c:
    
    WARNING: printk() should include KERN_ facility level
    WARNING: line over 80 characters
    ERROR: do not use C99 // comments
    WARNING: space prohibited between function name and open parenthesis '('
    WARNING: braces {} are not necessary for any arm of this statement
    WARNING: suspect code indent for conditional statements (16, 16)
    
    Signed-off-by: Xenofon Foukas <foukas.xenofon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 3607aaee4af6..2b34daedc3d7 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -114,7 +114,7 @@ static const int s526_ports[] = {
 };
 
 struct counter_mode_register_t {
-#if defined (__LITTLE_ENDIAN_BITFIELD)
+#if defined(__LITTLE_ENDIAN_BITFIELD)
 	unsigned short coutSource:1;
 	unsigned short coutPolarity:1;
 	unsigned short autoLoadResetRcap:3;
@@ -207,7 +207,9 @@ static const struct s526_board s526_boards[] = {
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device
+   struct.
+*/
 struct s526_private {
 
 	int data;
@@ -304,7 +306,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 /* int subdev_channel = 0; */
 	union cmReg cmReg;
 
-	printk("comedi%d: s526: ", dev->minor);
+	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
 
 	iobase = it->options[0];
 	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
@@ -317,7 +319,8 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*** make it a little quieter, exw, 8/29/06
 	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
+		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]),
+				inw(ADDR_REG(s526_ports[i])));
 	}
 	***/
 
@@ -402,7 +405,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	printk("attached\n");
+	printk(KERN_INFO "attached\n");
 
 	return 1;
 
@@ -411,7 +414,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* One-shot (software trigger) */
 	cmReg.reg.coutSource = 0;	/*  out RCAP */
 	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 1;	/*  Auto load 0:disabled, 1:enabled */
+	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */
 	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
 	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
 	cmReg.reg.clockSource = 2;	/*  Internal */
@@ -426,10 +429,12 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
-
-	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
+	/*  Reset the counter */
+	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Load the counter from PR0 */
+	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Reset RCAP (fires one-shot) */
+	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
 #else
 
@@ -447,11 +452,12 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	cmReg.reg.reserved = 0;
 
 	n = 0;
-	printk("Mode reg=0x%04x, 0x%04lx\n", cmReg.value, ADDR_CHAN_REG(REG_C0M,
-									n));
+	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
+		cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
-	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+		inw(ADDR_CHAN_REG(REG_C0M, n)));
 
 	/*  Load the pre-load register high word */
 /* value = (short) (0x55); */
@@ -466,20 +472,23 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  Reset the counter if it is software preload */
 	if (cmReg.reg.autoLoadResetRcap == 0) {
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));	/*  Reset the counter */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));	/*  Load the counter from PR0 */
+		/*  Reset the counter */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));
+		/*  Load the counter from PR0 */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));
 	}
 
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
-	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+			inw(ADDR_CHAN_REG(REG_C0M, n)));
 
 #endif
-	printk("Current registres:\n");
+	printk(KERN_INFO "Current registres:\n");
 
 	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02lx: 0x%04x\n", ADDR_REG(s526_ports[i]),
-		       inw(ADDR_REG(s526_ports[i])));
+		printk(KERN_INFO "0x%02lx: 0x%04x\n",
+			ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
 	}
 	return 1;
 }
@@ -494,7 +503,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  */
 static int s526_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: s526: remove\n", dev->minor);
+	printk(KERN_INFO "comedi%d: s526: remove\n", dev->minor);
 
 	if (dev->iobase > 0)
 		release_region(dev->iobase, S526_IOSIZE);
@@ -513,7 +522,7 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 
 	/*  Check if (n > 0) */
 	if (insn->n <= 0) {
-		printk("s526: INSN_READ: n should be > 0\n");
+		printk(KERN_ERR "s526: INSN_READ: n should be > 0\n");
 		return -EINVAL;
 	}
 	/*  Read the low word first */
@@ -522,7 +531,8 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 		datahigh = inw(ADDR_CHAN_REG(REG_C0H, counter_channel));
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
-/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n", counter_channel, data[i], datahigh, datalow); */
+		/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n",
+		   counter_channel, data[i], datahigh, datalow); */
 	}
 	return i;
 }
@@ -536,7 +546,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel); */
+	/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n",
+						subdev_channel); */
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
 		devpriv->s526_gpct_config[subdev_channel].data[i] =
@@ -554,7 +565,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[2]: Pre-load Register Value
 		   data[3]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PositionMeasurement;
 
@@ -563,7 +574,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/* One-shot (software trigger) */
 		cmReg.reg.coutSource = 0;	/*  out RCAP */
 		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+		cmReg.reg.autoLoadResetRcap = 0;/*  Auto load disabled */
 		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
 		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
 		cmReg.reg.clockSource = 2;	/*  Internal */
@@ -578,10 +589,13 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+		/*  Reset the counter */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		/*  Load the counter from PR0 */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
-		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
+		/*  Reset RCAP (fires one-shot) */
+		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
 #endif
 
@@ -594,30 +608,34 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-/* outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));    Load the counter from PR0 */
+			/*  Reset the counter */
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			/* Load the counter from PR0
+			 * outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			 */
 		}
 #else
-		cmReg.reg.countDirCtrl = 0;	/*  0 quadrature, 1 software control */
+		/*  0 quadrature, 1 software control */
+		cmReg.reg.countDirCtrl = 0;
 
 		/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */
-		if (insn->data[1] == GPCT_X2) {
+		if (insn->data[1] == GPCT_X2)
 			cmReg.reg.clockSource = 1;
-		} else if (insn->data[1] == GPCT_X4) {
+		else if (insn->data[1] == GPCT_X4)
 			cmReg.reg.clockSource = 2;
-		} else {
+		else
 			cmReg.reg.clockSource = 0;
-		}
 
 		/*  When to take into account the indexpulse: */
-		if (insn->data[2] == GPCT_IndexPhaseLowLow) {
+		/*if (insn->data[2] == GPCT_IndexPhaseLowLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseLowHigh) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighHigh) {
-		}
+		}*/
 		/*  Take into account the index pulse? */
 		if (insn->data[3] == GPCT_RESET_COUNTER_ON_INDEX)
-			cmReg.reg.autoLoadResetRcap = 4;	/*  Auto load with INDEX^ */
+			/*  Auto load with INDEX^ */
+			cmReg.reg.autoLoadResetRcap = 4;
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(insn->data[1] & 0xFFFF);
@@ -638,8 +656,10 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		}
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+			/*  Reset the counter */
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			/*  Load the counter from PR0 */
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 #endif
 		break;
@@ -652,7 +672,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring SPG\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring SPG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    SinglePulseGeneration;
 
@@ -697,7 +717,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring PTG\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring PTG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PulseTrainGeneration;
 
@@ -735,7 +755,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		break;
 
 	default:
-		printk("s526: unsupported GPCT_insn_config\n");
+		printk(KERN_ERR "s526: unsupported GPCT_insn_config\n");
 		return -EINVAL;
 		break;
 	}
@@ -751,20 +771,21 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
+	printk(KERN_INFO "s526: GPCT_INSN_WRITE on channel %d\n",
+					subdev_channel);
 	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
-	printk("s526: Counter Mode Register: %x\n", cmReg.value);
+	printk(KERN_INFO "s526: Counter Mode Register: %x\n", cmReg.value);
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[subdev_channel].app) {
 	case PositionMeasurement:
-		printk("S526: INSN_WRITE: PM\n");
+		printk(KERN_INFO "S526: INSN_WRITE: PM\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
 							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
 	case SinglePulseGeneration:
-		printk("S526: INSN_WRITE: SPG\n");
+		printk(KERN_INFO "S526: INSN_WRITE: SPG\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
 							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
@@ -777,14 +798,14 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   The above periods must be expressed as a multiple of the
 		   pulse frequency on the selected source
 		 */
-		printk("S526: INSN_WRITE: PTG\n");
+		printk(KERN_INFO "S526: INSN_WRITE: PTG\n");
 		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
 			    insn->data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
 			    insn->data[1];
 		} else {
-			printk("s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
+			printk(KERN_ERR "s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
 				insn->data[0], insn->data[1]);
 			return -EINVAL;
 		}
@@ -873,7 +894,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (i == TIMEOUT) {
 			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			printk("s526: ADC(0x%04x) timeout\n",
+			printk(KERN_ERR "s526: ADC(0x%04x) timeout\n",
 			       inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}
@@ -906,11 +927,14 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	 * very useful, but that's how the interface is defined. */
 	for (i = 0; i < insn->n; i++) {
 		/* a typical programming sequence */
-/* outw(data[i], dev->iobase + REG_ADD);    write the data to preload register */
-		outw(data[i], ADDR_REG(REG_ADD));	/*  write the data to preload register */
+		/* write the data to preload register
+		 * outw(data[i], dev->iobase + REG_ADD);
+		 */
+		/* write the data to preload register */
+		outw(data[i], ADDR_REG(REG_ADD));
 		devpriv->ao_readback[chan] = data[i];
 /* outw(val + 1, dev->iobase + REG_DAC);  starts the D/A conversion. */
-		outw(val + 1, ADDR_REG(REG_DAC));	/*  starts the D/A conversion. */
+		outw(val + 1, ADDR_REG(REG_DAC)); /*starts the D/A conversion.*/
 	}
 
 	/* return the number of samples read/written */
@@ -954,7 +978,7 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	/*  low 8 bits are the data */
+	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF; /* low 8 bits are the data */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
 	/* data[1]=s->state & 0xFF; */
@@ -969,7 +993,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	int chan = CR_CHAN(insn->chanspec);
 	int group, mask;
 
-	printk("S526 DIO insn_config\n");
+	printk(KERN_INFO "S526 DIO insn_config\n");
 
 	/* The input or output configuration of each digital line is
 	 * configured by a special insn_config instruction.  chanspec
@@ -980,11 +1004,12 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	mask = 0xF << (group << 2);
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		s->state |= 1 << (group + 10);  // bit 10/11 set the group 1/2's mode
+		/* bit 10/11 set the group 1/2's mode */
+		s->state |= 1 << (group + 10);
 		s->io_bits |= mask;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		s->state &= ~(1 << (group + 10));// 1 is output, 0 is input.
+		s->state &= ~(1 << (group + 10)); /* 1 is output, 0 is input. */
 		s->io_bits &= ~mask;
 		break;
 	case INSN_CONFIG_DIO_QUERY:

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 8afed1307bdd..3607aaee4af6 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -1002,7 +1002,18 @@ static int s526_dio_insn_config(struct comedi_device *dev,
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver_s526);
+static int __init driver_s526_init_module(void)
+{
+	return comedi_driver_register(&driver_s526);
+}
+
+static void __exit driver_s526_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_s526);
+}
+
+module_init(driver_s526_init_module);
+module_exit(driver_s526_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 07c21e686f27..8afed1307bdd 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -1003,3 +1003,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
  * as necessary.
  */
 COMEDI_INITCLEANUP(driver_s526);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 5044a2c0e0e951afeb4dce87e18e10036635410a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 21 15:48:33 2009 -0400

    Staging: comedi: s526: fixes for pulse generator
    
    Some changes and corrections to handling of
    INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR, and
    INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR, so they interpret insn->data[]
    as per the comments in the code.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 9a8ebbe96999..07c21e686f27 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -453,11 +453,11 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	udelay(1000);
 	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
 
-	/*  Load the pre-laod register high word */
+	/*  Load the pre-load register high word */
 /* value = (short) (0x55); */
 /* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */
 
-	/*  Load the pre-laod register low word */
+	/*  Load the pre-load register low word */
 /* value = (short)(0xaa55); */
 /* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */
 
@@ -587,19 +587,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 #if 1
 		/*  Set Counter Mode Register */
-		cmReg.reg.coutSource = 0;	/*  out RCAP */
-		cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
-		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
-		cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
-		cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
-		cmReg.reg.clockSource = 3;	/*  x4 */
-		cmReg.reg.countDir = 0;	/*  up */
-		cmReg.reg.countDirCtrl = 0;	/*  quadrature */
-		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
-		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
-		cmReg.reg.reserved = 0;
+		cmReg.value = insn->data[1] & 0xFFFF;
 
-		/*  Set Counter Mode Register */
 /* printk("s526: Counter Mode register=%x\n", cmReg.value); */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
@@ -634,11 +623,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		/*  Load the pre-laod register high word */
+		/*  Load the pre-load register high word */
 		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		/*  Load the pre-laod register low word */
+		/*  Load the pre-load register low word */
 		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
@@ -672,11 +661,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		/*  Load the pre-laod register 0 high word */
+		/*  Load the pre-load register 0 high word */
 		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		/*  Load the pre-laod register 0 low word */
+		/*  Load the pre-load register 0 low word */
 		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
@@ -685,17 +674,17 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		/*  Load the pre-laod register 1 high word */
+		/*  Load the pre-load register 1 high word */
 		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		/*  Load the pre-laod register 1 low word */
+		/*  Load the pre-load register 1 low word */
 		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
-		if (insn->data[3] != 0) {
-			value = (short)(insn->data[3] & 0xFFFF);
+		if (insn->data[4] != 0) {
+			value = (short)(insn->data[4] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -717,11 +706,11 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		/*  Load the pre-laod register 0 high word */
+		/*  Load the pre-load register 0 high word */
 		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		/*  Load the pre-laod register 0 low word */
+		/*  Load the pre-load register 0 low word */
 		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
@@ -730,17 +719,17 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		/*  Load the pre-laod register 1 high word */
+		/*  Load the pre-load register 1 high word */
 		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		/*  Load the pre-laod register 1 low word */
+		/*  Load the pre-load register 1 low word */
 		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
-		if (insn->data[3] != 0) {
-			value = (short)(insn->data[3] & 0xFFFF);
+		if (insn->data[4] != 0) {
+			value = (short)(insn->data[4] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -795,9 +784,8 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
 			    insn->data[1];
 		} else {
-			printk("%d \t %d\n", insn->data[1], insn->data[2]);
-			printk
-			    ("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
+			printk("s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
+				insn->data[0], insn->data[1]);
 			return -EINVAL;
 		}
 

commit 2b0318a600989ed85fe020079fa20132f8aebaf3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 21 15:38:34 2009 -0400

    Staging: comedi: s526: Take account of arch's byte order.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index dbde118f2a16..9a8ebbe96999 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -43,6 +43,7 @@ comedi_config /dev/comedi0 s526 0x2C0,0x3
 
 #include "../comedidev.h"
 #include <linux/ioport.h>
+#include <asm/byteorder.h>
 
 #define S526_SIZE 64
 
@@ -113,6 +114,7 @@ static const int s526_ports[] = {
 };
 
 struct counter_mode_register_t {
+#if defined (__LITTLE_ENDIAN_BITFIELD)
 	unsigned short coutSource:1;
 	unsigned short coutPolarity:1;
 	unsigned short autoLoadResetRcap:3;
@@ -124,6 +126,21 @@ struct counter_mode_register_t {
 	unsigned short outputRegLatchCtrl:1;
 	unsigned short preloadRegSel:1;
 	unsigned short reserved:1;
+ #elif defined(__BIG_ENDIAN_BITFIELD)
+	unsigned short reserved:1;
+	unsigned short preloadRegSel:1;
+	unsigned short outputRegLatchCtrl:1;
+	unsigned short countDirCtrl:1;
+	unsigned short countDir:1;
+	unsigned short clockSource:2;
+	unsigned short ctEnableCtrl:2;
+	unsigned short hwCtEnableSource:2;
+	unsigned short autoLoadResetRcap:3;
+	unsigned short coutPolarity:1;
+	unsigned short coutSource:1;
+#else
+#error Unknown bit field order
+#endif
 };
 
 union cmReg {

commit ca98ee7bb4005365ad395b53229e2f6d01ca7cbd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 21 15:35:42 2009 -0400

    Staging: comedi: s526: Get rid of global variable 'cmReg'.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 736441f3c815..dbde118f2a16 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -126,10 +126,10 @@ struct counter_mode_register_t {
 	unsigned short reserved:1;
 };
 
-union {
+union cmReg {
 	struct counter_mode_register_t reg;
 	unsigned short value;
-} cmReg;
+};
 
 #define MAX_GPCT_CONFIG_DATA 6
 
@@ -285,6 +285,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i, n;
 /* short value; */
 /* int subdev_channel = 0; */
+	union cmReg cmReg;
 
 	printk("comedi%d: s526: ", dev->minor);
 
@@ -516,6 +517,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
 	short value;
+	union cmReg cmReg;
 
 /* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel); */
 
@@ -741,6 +743,7 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
+	union cmReg cmReg;
 
 	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
 	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));

commit 10f27014f42f0a4cb32bf45f214fa7ad7c261b1e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 21 15:29:59 2009 -0400

    Staging: comedi: s526: Fix number of channels on DIO subdevice
    
    Correct operation of INSN_CONFIG_DIO_INPUT and INSN_CONFIG_DIO_OUTPUT
    and support INSN_CONFIG_DIO_QUERY.  Thanks to Alessio Margan for some
    testing.
    
    Signed-off-by: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index b89e1ec267c5..736441f3c815 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -375,7 +375,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (thisboard->have_dio) {
 		s->type = COMEDI_SUBD_DIO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-		s->n_chan = 2;
+		s->n_chan = 8;
 		s->maxdata = 1;
 		s->range_table = &range_digital;
 		s->insn_bits = s526_dio_insn_bits;
@@ -949,7 +949,7 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	/*  low 8 bits are the data */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
-	/* data[1]=s->state; */
+	/* data[1]=s->state & 0xFF; */
 
 	return 2;
 }
@@ -959,28 +959,33 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
-	short value;
+	int group, mask;
 
 	printk("S526 DIO insn_config\n");
 
-	if (insn->n != 1)
-		return -EINVAL;
-
-	value = inw(ADDR_REG(REG_DIO));
-
 	/* The input or output configuration of each digital line is
 	 * configured by a special insn_config instruction.  chanspec
 	 * contains the channel to be changed, and data[0] contains the
 	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
 
-	if (data[0] == COMEDI_OUTPUT) {
-		value |= 1 << (chan + 10);	/*  bit 10/11 set the group 1/2's mode */
-		s->io_bits |= (0xF << chan);
-	} else {
-		value &= ~(1 << (chan + 10));	/*  1 is output, 0 is input. */
-		s->io_bits &= ~(0xF << chan);
+	group = chan >> 2;
+	mask = 0xF << (group << 2);
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->state |= 1 << (group + 10);  // bit 10/11 set the group 1/2's mode
+		s->io_bits |= mask;
+		break;
+	case INSN_CONFIG_DIO_INPUT:
+		s->state &= ~(1 << (group + 10));// 1 is output, 0 is input.
+		s->io_bits &= ~mask;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+	default:
+		return -EINVAL;
 	}
-	outw(value, ADDR_REG(REG_DIO));
+	outw(s->state, ADDR_REG(REG_DIO));
 
 	return 1;
 }

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d9509d7a3283..b89e1ec267c5 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -169,15 +169,15 @@ struct s526_board {
 
 static const struct s526_board s526_boards[] = {
 	{
-	.name = "s526",
-	.gpct_chans = 4,
-	.gpct_bits = 24,
-	.ad_chans = 8,
-	.ad_bits = 16,
-	.da_chans = 4,
-	.da_bits = 16,
-	.have_dio = 1,
-		}
+	 .name = "s526",
+	 .gpct_chans = 4,
+	 .gpct_bits = 24,
+	 .ad_chans = 8,
+	 .ad_bits = 16,
+	 .da_chans = 4,
+	 .da_bits = 16,
+	 .have_dio = 1,
+	 }
 };
 
 #define ADDR_REG(reg) (dev->iobase + (reg))
@@ -247,24 +247,30 @@ static struct comedi_driver driver_s526 = {
 	.num_names = ARRAY_SIZE(s526_boards),
 };
 
-static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int s526_gpct_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
+static int s526_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data);
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+			 struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -424,7 +430,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	n = 0;
 	printk("Mode reg=0x%04x, 0x%04lx\n", cmReg.value, ADDR_CHAN_REG(REG_C0M,
-			n));
+									n));
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
 	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
@@ -455,7 +461,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	for (i = 0; i < S526_NUM_PORTS; i++) {
 		printk("0x%02lx: 0x%04x\n", ADDR_REG(s526_ports[i]),
-			inw(ADDR_REG(s526_ports[i])));
+		       inw(ADDR_REG(s526_ports[i])));
 	}
 	return 1;
 }
@@ -478,8 +484,9 @@ static int s526_detach(struct comedi_device *dev)
 	return 0;
 }
 
-static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_rinsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int i;			/*  counts the Data */
 	int counter_channel = CR_CHAN(insn->chanspec);
@@ -502,8 +509,9 @@ static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s
 	return i;
 }
 
-static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_insn_config(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn, unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
@@ -513,7 +521,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
 		devpriv->s526_gpct_config[subdev_channel].data[i] =
-			insn->data[i];
+		    insn->data[i];
 /* printk("data[%d]=%x\n", i, insn->data[i]); */
 	}
 
@@ -529,32 +537,32 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			PositionMeasurement;
+		    PositionMeasurement;
 
 #if 0
-			/*  Example of Counter Application */
-			/* One-shot (software trigger) */
-			cmReg.reg.coutSource		= 0; /*  out RCAP */
-			cmReg.reg.coutPolarity		= 1; /*  Polarity inverted */
-			cmReg.reg.autoLoadResetRcap	= 0; /*  Auto load disabled */
-			cmReg.reg.hwCtEnableSource	= 3; /*  NOT RCAP */
-			cmReg.reg.ctEnableCtrl		= 2; /*  Hardware */
-			cmReg.reg.clockSource		= 2; /*  Internal */
-			cmReg.reg.countDir		= 1; /*  Down */
-			cmReg.reg.countDirCtrl		= 1; /*  Software */
-			cmReg.reg.outputRegLatchCtrl	= 0; /*  latch on read */
-			cmReg.reg.preloadRegSel		= 0; /*  PR0 */
-			cmReg.reg.reserved		= 0;
-
-			outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
-
-			outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-			outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		/*  Example of Counter Application */
+		/* One-shot (software trigger) */
+		cmReg.reg.coutSource = 0;	/*  out RCAP */
+		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
+		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
+		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
+		cmReg.reg.clockSource = 2;	/*  Internal */
+		cmReg.reg.countDir = 1;	/*  Down */
+		cmReg.reg.countDirCtrl = 1;	/*  Software */
+		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
+		cmReg.reg.reserved = 0;
 
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
 
-			outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));  /*  Reset RCAP (fires one-shot) */
+		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
 
 #endif
 
@@ -604,20 +612,20 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 			cmReg.reg.autoLoadResetRcap = 4;	/*  Auto load with INDEX^ */
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		/*  Reset the counter if it is software preload */
@@ -638,37 +646,37 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring SPG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			SinglePulseGeneration;
+		    SinglePulseGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 0 high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 0 low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 1 high word */
-		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 1 low word */
-		value = (short) (insn->data[3] & 0xFFFF);
+		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -683,37 +691,37 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 		 */
 		printk("s526: GPCT_INSN_CONFIG: Configuring PTG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
-			PulseTrainGeneration;
+		    PulseTrainGeneration;
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 0 high word */
-		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short)((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 0 low word */
-		value = (short) (insn->data[2] & 0xFFFF);
+		value = (short)(insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Set Counter Mode Register */
-		cmReg.value = (short) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short)(insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		/*  Load the pre-laod register 1 high word */
-		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short)((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		/*  Load the pre-laod register 1 low word */
-		value = (short) (insn->data[3] & 0xFFFF);
+		value = (short)(insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
-			value = (short) (insn->data[3] & 0xFFFF);
+			value = (short)(insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -727,8 +735,9 @@ static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdev
 	return insn->n;
 }
 
-static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_gpct_winsn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
@@ -741,14 +750,14 @@ static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s
 	case PositionMeasurement:
 		printk("S526: INSN_WRITE: PM\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-				subdev_channel));
+							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
 	case SinglePulseGeneration:
 		printk("S526: INSN_WRITE: SPG\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
-				subdev_channel));
+							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
@@ -762,22 +771,25 @@ static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s
 		printk("S526: INSN_WRITE: PTG\n");
 		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
-				insn->data[0];
+			    insn->data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
-				insn->data[1];
+			    insn->data[1];
 		} else {
 			printk("%d \t %d\n", insn->data[1], insn->data[2]);
-			printk("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
+			printk
+			    ("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
 			return -EINVAL;
 		}
 
-		value = (short) ((*data >> 16) & 0xFFFF);
+		value = (short)((*data >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-		value = (short) (*data & 0xFFFF);
+		value = (short)(*data & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 	default:		/*  Impossible */
-		printk("s526: INSN_WRITE: Functionality %d not implemented yet\n", devpriv->s526_gpct_config[subdev_channel].app);
+		printk
+		    ("s526: INSN_WRITE: Functionality %d not implemented yet\n",
+		     devpriv->s526_gpct_config[subdev_channel].app);
 		return -EINVAL;
 		break;
 	}
@@ -786,8 +798,9 @@ static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s
 }
 
 #define ISR_ADC_DONE 0x4
-static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_ai_insn_config(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int result = -EINVAL;
 
@@ -820,7 +833,7 @@ static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevic
  * mode.
  */
 static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -831,7 +844,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/* Set configured delay, enable channel for this channel only,
 	 * select "ADC read" channel, set "ADC start" bit. */
 	value = (devpriv->s526_ai_config & 0x8000) |
-		((1 << 5) << chan) | (chan << 1) | 0x0001;
+	    ((1 << 5) << chan) | (chan << 1) | 0x0001;
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
@@ -853,7 +866,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
 			printk("s526: ADC(0x%04x) timeout\n",
-				inw(ADDR_REG(REG_ISR)));
+			       inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}
 
@@ -870,7 +883,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -899,7 +912,7 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -915,8 +928,9 @@ static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_dio_insn_bits(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -940,8 +954,9 @@ static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 	return 2;
 }
 
-static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int s526_dio_insn_config(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	short value;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 7a6be1ee8f61..d9509d7a3283 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -850,9 +850,9 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 			}
 		}
 		if (i == TIMEOUT) {
-			/* rt_printk() should be used instead of printk()
+			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			rt_printk("s526: ADC(0x%04x) timeout\n",
+			printk("s526: ADC(0x%04x) timeout\n",
 				inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d9b8f837bfdb..7a6be1ee8f61 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -244,7 +244,7 @@ static struct comedi_driver driver_s526 = {
 	 */
 	.board_name = &s526_boards[0].name,
 	.offset = sizeof(struct s526_board),
-	.num_names = sizeof(s526_boards) / sizeof(struct s526_board),
+	.num_names = ARRAY_SIZE(s526_boards),
 };
 
 static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 54c24a266fbc..d9b8f837bfdb 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -169,14 +169,14 @@ struct s526_board {
 
 static const struct s526_board s526_boards[] = {
 	{
-	      name:	"s526",
-	      gpct_chans:4,
-	      gpct_bits:24,
-	      ad_chans:8,
-	      ad_bits:	16,
-	      da_chans:4,
-	      da_bits:	16,
-	      have_dio:1,
+	.name = "s526",
+	.gpct_chans = 4,
+	.gpct_bits = 24,
+	.ad_chans = 8,
+	.ad_bits = 16,
+	.da_chans = 4,
+	.da_bits = 16,
+	.have_dio = 1,
 		}
 };
 
@@ -220,10 +220,10 @@ struct s526_private {
 static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int s526_detach(struct comedi_device *dev);
 static struct comedi_driver driver_s526 = {
-      driver_name:"s526",
-      module:THIS_MODULE,
-      attach:s526_attach,
-      detach:s526_detach,
+	.driver_name = "s526",
+	.module = THIS_MODULE,
+	.attach = s526_attach,
+	.detach = s526_detach,
 /* It is not necessary to implement the following members if you are
  * writing a driver for a ISA PnP or PCI card */
 	/* Most drivers will support multiple types of boards by
@@ -242,9 +242,9 @@ static struct comedi_driver driver_s526 = {
 	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
 	 * devices are such boards.
 	 */
-      board_name:&s526_boards[0].name,
-      offset:sizeof(struct s526_board),
-      num_names:sizeof(s526_boards) / sizeof(struct s526_board),
+	.board_name = &s526_boards[0].name,
+	.offset = sizeof(struct s526_board),
+	.num_names = sizeof(s526_boards) / sizeof(struct s526_board),
 };
 
 static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e419a7c6943d..54c24a266fbc 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -217,8 +217,8 @@ struct s526_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int s526_detach(struct comedi_device * dev);
+static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int s526_detach(struct comedi_device *dev);
 static struct comedi_driver driver_s526 = {
       driver_name:"s526",
       module:THIS_MODULE,
@@ -247,24 +247,24 @@ static struct comedi_driver driver_s526 = {
       num_names:sizeof(s526_boards) / sizeof(struct s526_board),
 };
 
-static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
+static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -272,7 +272,7 @@ static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdev
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	int iobase;
@@ -468,7 +468,7 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int s526_detach(struct comedi_device * dev)
+static int s526_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: s526: remove\n", dev->minor);
 
@@ -478,8 +478,8 @@ static int s526_detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_gpct_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;			/*  counts the Data */
 	int counter_channel = CR_CHAN(insn->chanspec);
@@ -502,8 +502,8 @@ static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 	return i;
 }
 
-static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_gpct_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
@@ -727,8 +727,8 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 	return insn->n;
 }
 
-static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_gpct_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
@@ -786,8 +786,8 @@ static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 #define ISR_ADC_DONE 0x4
-static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_ai_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int result = -EINVAL;
 
@@ -819,8 +819,8 @@ static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevi
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -869,8 +869,8 @@ static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
 	return n;
 }
 
-static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -898,8 +898,8 @@ static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -915,8 +915,8 @@ static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -940,8 +940,8 @@ static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevic
 	return 2;
 }
 
-static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int s526_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	short value;

commit 232f650253a04b52def9974f47c15f086f7772a5
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:31:27 2009 -0400

    Staging: comedi: remove C99 comments in s526.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index a7b6f711afca..e419a7c6943d 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -277,8 +277,8 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	struct comedi_subdevice *s;
 	int iobase;
 	int i, n;
-//      short value;
-//      int subdev_channel = 0;
+/* short value; */
+/* int subdev_channel = 0; */
 
 	printk("comedi%d: s526: ", dev->minor);
 
@@ -334,12 +334,12 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	/* Command are not implemented yet, however they are necessary to
 	   allocate the necessary memory for the comedi_async struct (used
 	   to trigger the GPCT in case of pulsegenerator function */
-	//s->do_cmd = s526_gpct_cmd;
-	//s->do_cmdtest = s526_gpct_cmdtest;
-	//s->cancel = s526_gpct_cancel;
+	/* s->do_cmd = s526_gpct_cmd; */
+	/* s->do_cmdtest = s526_gpct_cmdtest; */
+	/* s->cancel = s526_gpct_cancel; */
 
 	s = dev->subdevices + 1;
-	//dev->read_subdev=s;
+	/* dev->read_subdev=s; */
 	/* analog input subdevice */
 	s->type = COMEDI_SUBD_AI;
 	/* we support differential */
@@ -383,18 +383,18 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	return 1;
 
 #if 0
-	// Example of Counter Application
-	//One-shot (software trigger)
-	cmReg.reg.coutSource = 0;	// out RCAP
-	cmReg.reg.coutPolarity = 1;	// Polarity inverted
-	cmReg.reg.autoLoadResetRcap = 1;	// Auto load 0:disabled, 1:enabled
-	cmReg.reg.hwCtEnableSource = 3;	// NOT RCAP
-	cmReg.reg.ctEnableCtrl = 2;	// Hardware
-	cmReg.reg.clockSource = 2;	// Internal
-	cmReg.reg.countDir = 1;	// Down
-	cmReg.reg.countDirCtrl = 1;	// Software
-	cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
-	cmReg.reg.preloadRegSel = 0;	// PR0
+	/*  Example of Counter Application */
+	/* One-shot (software trigger) */
+	cmReg.reg.coutSource = 0;	/*  out RCAP */
+	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
+	cmReg.reg.autoLoadResetRcap = 1;	/*  Auto load 0:disabled, 1:enabled */
+	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
+	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
+	cmReg.reg.clockSource = 2;	/*  Internal */
+	cmReg.reg.countDir = 1;	/*  Down */
+	cmReg.reg.countDirCtrl = 1;	/*  Software */
+	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 	cmReg.reg.reserved = 0;
 
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
@@ -402,24 +402,24 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
-	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
 
-	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset RCAP (fires one-shot)
+	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
 
 #else
 
-	// Set Counter Mode Register
-	cmReg.reg.coutSource = 0;	// out RCAP
-	cmReg.reg.coutPolarity = 0;	// Polarity inverted
-	cmReg.reg.autoLoadResetRcap = 0;	// Auto load disabled
-	cmReg.reg.hwCtEnableSource = 2;	// NOT RCAP
-	cmReg.reg.ctEnableCtrl = 1;	// 1: Software,  >1 : Hardware
-	cmReg.reg.clockSource = 3;	// x4
-	cmReg.reg.countDir = 0;	// up
-	cmReg.reg.countDirCtrl = 0;	// quadrature
-	cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
-	cmReg.reg.preloadRegSel = 0;	// PR0
+	/*  Set Counter Mode Register */
+	cmReg.reg.coutSource = 0;	/*  out RCAP */
+	cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
+	cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+	cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
+	cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
+	cmReg.reg.clockSource = 3;	/*  x4 */
+	cmReg.reg.countDir = 0;	/*  up */
+	cmReg.reg.countDirCtrl = 0;	/*  quadrature */
+	cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+	cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 	cmReg.reg.reserved = 0;
 
 	n = 0;
@@ -429,21 +429,21 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 	udelay(1000);
 	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
 
-	// Load the pre-laod register high word
-//                      value = (short) (0x55);
-//                      outw(value, ADDR_CHAN_REG(REG_C0H, n));
+	/*  Load the pre-laod register high word */
+/* value = (short) (0x55); */
+/* outw(value, ADDR_CHAN_REG(REG_C0H, n)); */
 
-	// Load the pre-laod register low word
-//                      value = (short)(0xaa55);
-//                      outw(value, ADDR_CHAN_REG(REG_C0L, n));
+	/*  Load the pre-laod register low word */
+/* value = (short)(0xaa55); */
+/* outw(value, ADDR_CHAN_REG(REG_C0L, n)); */
 
-	// Write the Counter Control Register
-//                      outw(value, ADDR_CHAN_REG(REG_C0C, 0));
+	/*  Write the Counter Control Register */
+/* outw(value, ADDR_CHAN_REG(REG_C0C, 0)); */
 
-	// Reset the counter if it is software preload
+	/*  Reset the counter if it is software preload */
 	if (cmReg.reg.autoLoadResetRcap == 0) {
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));	// Reset the counter
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));	// Load the counter from PR0
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));	/*  Reset the counter */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));	/*  Load the counter from PR0 */
 	}
 
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
@@ -481,23 +481,23 @@ static int s526_detach(struct comedi_device * dev)
 static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	int i;			// counts the Data
+	int i;			/*  counts the Data */
 	int counter_channel = CR_CHAN(insn->chanspec);
 	unsigned short datalow;
 	unsigned short datahigh;
 
-	// Check if (n > 0)
+	/*  Check if (n > 0) */
 	if (insn->n <= 0) {
 		printk("s526: INSN_READ: n should be > 0\n");
 		return -EINVAL;
 	}
-	// Read the low word first
+	/*  Read the low word first */
 	for (i = 0; i < insn->n; i++) {
 		datalow = inw(ADDR_CHAN_REG(REG_C0L, counter_channel));
 		datahigh = inw(ADDR_CHAN_REG(REG_C0H, counter_channel));
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
-//              printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n", counter_channel, data[i], datahigh, datalow);
+/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n", counter_channel, data[i], datahigh, datalow); */
 	}
 	return i;
 }
@@ -505,20 +505,20 @@ static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
+	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	int i;
 	short value;
 
-//        printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel);
+/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel); */
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
 		devpriv->s526_gpct_config[subdev_channel].data[i] =
 			insn->data[i];
-//              printk("data[%d]=%x\n", i, insn->data[i]);
+/* printk("data[%d]=%x\n", i, insn->data[i]); */
 	}
 
-	// Check what type of Counter the user requested, data[0] contains
-	// the Application type
+	/*  Check what type of Counter the user requested, data[0] contains */
+	/*  the Application type */
 	switch (insn->data[0]) {
 	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
 		/*
@@ -531,19 +531,19 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 		devpriv->s526_gpct_config[subdev_channel].app =
 			PositionMeasurement;
 
-/*
-			// Example of Counter Application
-			//One-shot (software trigger)
-			cmReg.reg.coutSource		= 0; // out RCAP
-			cmReg.reg.coutPolarity		= 1; // Polarity inverted
-			cmReg.reg.autoLoadResetRcap	= 0; // Auto load disabled
-			cmReg.reg.hwCtEnableSource	= 3; // NOT RCAP
-			cmReg.reg.ctEnableCtrl		= 2; // Hardware
-			cmReg.reg.clockSource		= 2; // Internal
-			cmReg.reg.countDir		= 1; // Down
-			cmReg.reg.countDirCtrl		= 1; // Software
-			cmReg.reg.outputRegLatchCtrl	= 0; // latch on read
-			cmReg.reg.preloadRegSel		= 0; // PR0
+#if 0
+			/*  Example of Counter Application */
+			/* One-shot (software trigger) */
+			cmReg.reg.coutSource		= 0; /*  out RCAP */
+			cmReg.reg.coutPolarity		= 1; /*  Polarity inverted */
+			cmReg.reg.autoLoadResetRcap	= 0; /*  Auto load disabled */
+			cmReg.reg.hwCtEnableSource	= 3; /*  NOT RCAP */
+			cmReg.reg.ctEnableCtrl		= 2; /*  Hardware */
+			cmReg.reg.clockSource		= 2; /*  Internal */
+			cmReg.reg.countDir		= 1; /*  Down */
+			cmReg.reg.countDirCtrl		= 1; /*  Software */
+			cmReg.reg.outputRegLatchCtrl	= 0; /*  latch on read */
+			cmReg.reg.preloadRegSel		= 0; /*  PR0 */
 			cmReg.reg.reserved		= 0;
 
 			outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
@@ -551,40 +551,40 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 			outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 			outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
 
-			outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));  // Reset RCAP (fires one-shot)
+			outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));  /*  Reset RCAP (fires one-shot) */
 
-*/
+#endif
 
 #if 1
-		// Set Counter Mode Register
-		cmReg.reg.coutSource = 0;	// out RCAP
-		cmReg.reg.coutPolarity = 0;	// Polarity inverted
-		cmReg.reg.autoLoadResetRcap = 0;	// Auto load disabled
-		cmReg.reg.hwCtEnableSource = 2;	// NOT RCAP
-		cmReg.reg.ctEnableCtrl = 1;	// 1: Software,  >1 : Hardware
-		cmReg.reg.clockSource = 3;	// x4
-		cmReg.reg.countDir = 0;	// up
-		cmReg.reg.countDirCtrl = 0;	// quadrature
-		cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
-		cmReg.reg.preloadRegSel = 0;	// PR0
+		/*  Set Counter Mode Register */
+		cmReg.reg.coutSource = 0;	/*  out RCAP */
+		cmReg.reg.coutPolarity = 0;	/*  Polarity inverted */
+		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+		cmReg.reg.hwCtEnableSource = 2;	/*  NOT RCAP */
+		cmReg.reg.ctEnableCtrl = 1;	/*  1: Software,  >1 : Hardware */
+		cmReg.reg.clockSource = 3;	/*  x4 */
+		cmReg.reg.countDir = 0;	/*  up */
+		cmReg.reg.countDirCtrl = 0;	/*  quadrature */
+		cmReg.reg.outputRegLatchCtrl = 0;	/*  latch on read */
+		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		cmReg.reg.reserved = 0;
 
-		// Set Counter Mode Register
-//                      printk("s526: Counter Mode register=%x\n", cmReg.value);
+		/*  Set Counter Mode Register */
+/* printk("s526: Counter Mode register=%x\n", cmReg.value); */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Reset the counter if it is software preload
+		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
-//                              outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));   // Load the counter from PR0
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+/* outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));    Load the counter from PR0 */
 		}
 #else
-		cmReg.reg.countDirCtrl = 0;	// 0 quadrature, 1 software control
+		cmReg.reg.countDirCtrl = 0;	/*  0 quadrature, 1 software control */
 
-		// data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4
+		/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */
 		if (insn->data[1] == GPCT_X2) {
 			cmReg.reg.clockSource = 1;
 		} else if (insn->data[1] == GPCT_X4) {
@@ -593,37 +593,37 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 			cmReg.reg.clockSource = 0;
 		}
 
-		// When to take into account the indexpulse:
+		/*  When to take into account the indexpulse: */
 		if (insn->data[2] == GPCT_IndexPhaseLowLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseLowHigh) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighHigh) {
 		}
-		// Take into account the index pulse?
+		/*  Take into account the index pulse? */
 		if (insn->data[3] == GPCT_RESET_COUNTER_ON_INDEX)
-			cmReg.reg.autoLoadResetRcap = 4;	// Auto load with INDEX^
+			cmReg.reg.autoLoadResetRcap = 4;	/*  Auto load with INDEX^ */
 
-		// Set Counter Mode Register
+		/*  Set Counter Mode Register */
 		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Load the pre-laod register high word
+		/*  Load the pre-laod register high word */
 		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		// Load the pre-laod register low word
+		/*  Load the pre-laod register low word */
 		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		// Write the Counter Control Register
+		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
 			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
-		// Reset the counter if it is software preload
+		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
 		}
 #endif
 		break;
@@ -640,33 +640,33 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 		devpriv->s526_gpct_config[subdev_channel].app =
 			SinglePulseGeneration;
 
-		// Set Counter Mode Register
+		/*  Set Counter Mode Register */
 		cmReg.value = (short) (insn->data[1] & 0xFFFF);
-		cmReg.reg.preloadRegSel = 0;	// PR0
+		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Load the pre-laod register 0 high word
+		/*  Load the pre-laod register 0 high word */
 		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		// Load the pre-laod register 0 low word
+		/*  Load the pre-laod register 0 low word */
 		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		// Set Counter Mode Register
+		/*  Set Counter Mode Register */
 		cmReg.value = (short) (insn->data[1] & 0xFFFF);
-		cmReg.reg.preloadRegSel = 1;	// PR1
+		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Load the pre-laod register 1 high word
+		/*  Load the pre-laod register 1 high word */
 		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		// Load the pre-laod register 1 low word
+		/*  Load the pre-laod register 1 low word */
 		value = (short) (insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		// Write the Counter Control Register
+		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
 			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
@@ -685,33 +685,33 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 		devpriv->s526_gpct_config[subdev_channel].app =
 			PulseTrainGeneration;
 
-		// Set Counter Mode Register
+		/*  Set Counter Mode Register */
 		cmReg.value = (short) (insn->data[1] & 0xFFFF);
-		cmReg.reg.preloadRegSel = 0;	// PR0
+		cmReg.reg.preloadRegSel = 0;	/*  PR0 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Load the pre-laod register 0 high word
+		/*  Load the pre-laod register 0 high word */
 		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		// Load the pre-laod register 0 low word
+		/*  Load the pre-laod register 0 low word */
 		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		// Set Counter Mode Register
+		/*  Set Counter Mode Register */
 		cmReg.value = (short) (insn->data[1] & 0xFFFF);
-		cmReg.reg.preloadRegSel = 1;	// PR1
+		cmReg.reg.preloadRegSel = 1;	/*  PR1 */
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
-		// Load the pre-laod register 1 high word
+		/*  Load the pre-laod register 1 high word */
 		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
-		// Load the pre-laod register 1 low word
+		/*  Load the pre-laod register 1 low word */
 		value = (short) (insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		// Write the Counter Control Register
+		/*  Write the Counter Control Register */
 		if (insn->data[3] != 0) {
 			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
@@ -730,13 +730,13 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
+	int subdev_channel = CR_CHAN(insn->chanspec);	/*  Unpack chanspec */
 	short value;
 
 	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
 	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
 	printk("s526: Counter Mode Register: %x\n", cmReg.value);
-	// Check what Application of Counter this channel is configured for
+	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[subdev_channel].app) {
 	case PositionMeasurement:
 		printk("S526: INSN_WRITE: PM\n");
@@ -776,12 +776,12 @@ static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice *
 		value = (short) (*data & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
-	default:		// Impossible
+	default:		/*  Impossible */
 		printk("s526: INSN_WRITE: Functionality %d not implemented yet\n", devpriv->s526_gpct_config[subdev_channel].app);
 		return -EINVAL;
 		break;
 	}
-	// return the number of samples written
+	/*  return the number of samples written */
 	return insn->n;
 }
 
@@ -803,14 +803,14 @@ static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevi
 	 * enable channels here.  The channel should be enabled in the
 	 * INSN_READ handler. */
 
-	// Enable ADC interrupt
+	/*  Enable ADC interrupt */
 	outw(ISR_ADC_DONE, ADDR_REG(REG_IER));
-//      printk("s526: ADC current value: 0x%04x\n", inw(ADDR_REG(REG_ADC)));
+/* printk("s526: ADC current value: 0x%04x\n", inw(ADDR_REG(REG_ADC))); */
 	devpriv->s526_ai_config = (data[0] & 0x3FF) << 5;
 	if (data[1] > 0)
-		devpriv->s526_ai_config |= 0x8000;	//set the delay
+		devpriv->s526_ai_config |= 0x8000;	/* set the delay */
 
-	devpriv->s526_ai_config |= 0x0001;	// ADC start bit.
+	devpriv->s526_ai_config |= 0x0001;	/*  ADC start bit. */
 
 	return result;
 }
@@ -837,8 +837,8 @@ static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
 		outw(value, ADDR_REG(REG_ADC));
-//              printk("s526: Wrote 0x%04x to ADC\n", value);
-//              printk("s526: ADC reg=0x%04x\n", inw(ADDR_REG(REG_ADC)));
+/* printk("s526: Wrote 0x%04x to ADC\n", value); */
+/* printk("s526: ADC reg=0x%04x\n", inw(ADDR_REG(REG_ADC))); */
 
 #define TIMEOUT 100
 		/* wait for conversion to end */
@@ -859,7 +859,7 @@ static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
 
 		/* read data */
 		d = inw(ADDR_REG(REG_ADD));
-//              printk("AI[%d]=0x%04x\n", n, (unsigned short)(d & 0xFFFF));
+/* printk("AI[%d]=0x%04x\n", n, (unsigned short)(d & 0xFFFF)); */
 
 		/* munge data */
 		data[n] = d ^ 0x8000;
@@ -876,20 +876,20 @@ static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s
 	int chan = CR_CHAN(insn->chanspec);
 	unsigned short val;
 
-//      printk("s526_ao_winsn\n");
+/* printk("s526_ao_winsn\n"); */
 	val = chan << 1;
-//      outw(val, dev->iobase + REG_DAC);
+/* outw(val, dev->iobase + REG_DAC); */
 	outw(val, ADDR_REG(REG_DAC));
 
 	/* Writing a list of values to an AO channel is probably not
 	 * very useful, but that's how the interface is defined. */
 	for (i = 0; i < insn->n; i++) {
 		/* a typical programming sequence */
-//              outw(data[i], dev->iobase + REG_ADD);  // write the data to preload register
-		outw(data[i], ADDR_REG(REG_ADD));	// write the data to preload register
+/* outw(data[i], dev->iobase + REG_ADD);    write the data to preload register */
+		outw(data[i], ADDR_REG(REG_ADD));	/*  write the data to preload register */
 		devpriv->ao_readback[chan] = data[i];
-//              outw(val + 1, dev->iobase + REG_DAC); // starts the D/A conversion.
-		outw(val + 1, ADDR_REG(REG_DAC));	// starts the D/A conversion.
+/* outw(val + 1, dev->iobase + REG_DAC);  starts the D/A conversion. */
+		outw(val + 1, ADDR_REG(REG_DAC));	/*  starts the D/A conversion. */
 	}
 
 	/* return the number of samples read/written */
@@ -932,10 +932,10 @@ static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevic
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	// low 8 bits are the data
+	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	/*  low 8 bits are the data */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
-	//data[1]=s->state;
+	/* data[1]=s->state; */
 
 	return 2;
 }
@@ -959,10 +959,10 @@ static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdev
 	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
 
 	if (data[0] == COMEDI_OUTPUT) {
-		value |= 1 << (chan + 10);	// bit 10/11 set the group 1/2's mode
+		value |= 1 << (chan + 10);	/*  bit 10/11 set the group 1/2's mode */
 		s->io_bits |= (0xF << chan);
 	} else {
-		value &= ~(1 << (chan + 10));	// 1 is output, 0 is input.
+		value &= ~(1 << (chan + 10));	/*  1 is output, 0 is input. */
 		s->io_bits &= ~(0xF << chan);
 	}
 	outw(value, ADDR_REG(REG_DIO));

commit c611ad3313831f1f79b063b282deb4248e283f39
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:20:52 2009 -0400

    Staging: comedi: Remove s526_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 5d98162734b5..a7b6f711afca 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -156,7 +156,7 @@ struct s526GPCTConfig {
  * boards in this way is optional, and completely driver-dependent.
  * Some drivers use arrays such as this, other do not.
  */
-typedef struct s526_board_struct {
+struct s526_board {
 	const char *name;
 	int gpct_chans;
 	int gpct_bits;
@@ -165,9 +165,9 @@ typedef struct s526_board_struct {
 	int da_chans;
 	int da_bits;
 	int have_dio;
-} s526_board;
+};
 
-static const s526_board s526_boards[] = {
+static const struct s526_board s526_boards[] = {
 	{
 	      name:	"s526",
 	      gpct_chans:4,
@@ -186,7 +186,7 @@ static const s526_board s526_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const s526_board *)dev->board_ptr)
+#define thisboard ((const struct s526_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -243,8 +243,8 @@ static struct comedi_driver driver_s526 = {
 	 * devices are such boards.
 	 */
       board_name:&s526_boards[0].name,
-      offset:sizeof(s526_board),
-      num_names:sizeof(s526_boards) / sizeof(s526_board),
+      offset:sizeof(struct s526_board),
+      num_names:sizeof(s526_boards) / sizeof(struct s526_board),
 };
 
 static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,

commit 39f7666080909466c0ed6d5fa48cce3403033ced
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:20:41 2009 -0400

    Staging: comedi: Remove s526_gpct_config_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 939e17f993d9..5d98162734b5 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -146,10 +146,10 @@ enum S526_GPCT_APP_CLASS {
 /* Config struct for different GPCT subdevice Application Classes and
    their options
 */
-typedef struct s526GPCTConfig {
+struct s526GPCTConfig {
 	enum S526_GPCT_APP_CLASS app;
 	int data[MAX_GPCT_CONFIG_DATA];
-} s526_gpct_config_t;
+};
 
 /*
  * Board descriptions for two imaginary boards.  Describing the
@@ -201,7 +201,7 @@ struct s526_private {
 	/* Used for AO readback */
 	unsigned int ao_readback[2];
 
-	s526_gpct_config_t s526_gpct_config[4];
+	struct s526GPCTConfig s526_gpct_config[4];
 	unsigned short s526_ai_config;
 };
 

commit dfb0503e2baf2292da93faae78db4bb98d9f095e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:19:58 2009 -0400

    Staging: comedi: Remove S526_GPCT_APP_CLASS typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d112515feccd..939e17f993d9 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -135,19 +135,19 @@ union {
 
 /* Different Application Classes for GPCT Subdevices */
 /* The list is not exhaustive and needs discussion! */
-typedef enum {
+enum S526_GPCT_APP_CLASS {
 	CountingAndTimeMeasurement,
 	SinglePulseGeneration,
 	PulseTrainGeneration,
 	PositionMeasurement,
 	Miscellaneous
-} S526_GPCT_APP_CLASS;
+};
 
 /* Config struct for different GPCT subdevice Application Classes and
    their options
 */
 typedef struct s526GPCTConfig {
-	S526_GPCT_APP_CLASS app;
+	enum S526_GPCT_APP_CLASS app;
 	int data[MAX_GPCT_CONFIG_DATA];
 } s526_gpct_config_t;
 

commit 6dc1ece008ab4e2bdddec3eca6d326a16b4f9849
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:17:38 2009 -0400

    Staging: comedi: Remove s526_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 08666e637e47..d112515feccd 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -191,7 +191,8 @@ static const s526_board s526_boards[] = {
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct s526_private {
+
 	int data;
 
 	/* would be useful for a PCI device */
@@ -202,12 +203,13 @@ typedef struct {
 
 	s526_gpct_config_t s526_gpct_config[4];
 	unsigned short s526_ai_config;
-} s526_private;
+};
+
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
-#define devpriv ((s526_private *)dev->private)
+#define devpriv ((struct s526_private *)dev->private)
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -307,7 +309,7 @@ static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
  * Allocate the private structure area.  alloc_private() is a
  * convenient macro defined in comedidev.h.
  */
-	if (alloc_private(dev, sizeof(s526_private)) < 0)
+	if (alloc_private(dev, sizeof(struct s526_private)) < 0)
 		return -ENOMEM;
 
 /*

commit 4b1d53f061bd3e622ba44c106e083a30a92eb223
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:07 2009 -0400

    Staging: comedi: Remove counter_mode_register_t typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index e5ee54332e8a..08666e637e47 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -112,7 +112,7 @@ static const int s526_ports[] = {
 	REG_EEC
 };
 
-typedef struct {
+struct counter_mode_register_t {
 	unsigned short coutSource:1;
 	unsigned short coutPolarity:1;
 	unsigned short autoLoadResetRcap:3;
@@ -124,10 +124,10 @@ typedef struct {
 	unsigned short outputRegLatchCtrl:1;
 	unsigned short preloadRegSel:1;
 	unsigned short reserved:1;
-} counter_mode_register_t;
+};
 
 union {
-	counter_mode_register_t reg;
+	struct counter_mode_register_t reg;
 	unsigned short value;
 } cmReg;
 

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index b9b48b2f222d..e5ee54332e8a 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -215,7 +215,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int s526_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int s526_detach(struct comedi_device * dev);
 static struct comedi_driver driver_s526 = {
       driver_name:"s526",
@@ -270,7 +270,7 @@ static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdev
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int s526_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int s526_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	int iobase;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index d3881498e164..b9b48b2f222d 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -246,23 +246,23 @@ static struct comedi_driver driver_s526 = {
 };
 
 static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -477,7 +477,7 @@ static int s526_detach(struct comedi_device * dev)
 }
 
 static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;			// counts the Data
 	int counter_channel = CR_CHAN(insn->chanspec);
@@ -501,7 +501,7 @@ static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
 	int i;
@@ -726,7 +726,7 @@ static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subde
 }
 
 static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
 	short value;
@@ -785,7 +785,7 @@ static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice *
 
 #define ISR_ADC_DONE 0x4
 static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int result = -EINVAL;
 
@@ -818,7 +818,7 @@ static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevi
  * mode.
  */
 static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -868,7 +868,7 @@ static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
 }
 
 static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -897,7 +897,7 @@ static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -914,7 +914,7 @@ static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -939,7 +939,7 @@ static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevic
 }
 
 static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 	short value;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 51ff5a7e5639..d3881498e164 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -210,14 +210,14 @@ typedef struct {
 #define devpriv ((s526_private *)dev->private)
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int s526_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int s526_detach(struct comedi_device * dev);
-static comedi_driver driver_s526 = {
+static struct comedi_driver driver_s526 = {
       driver_name:"s526",
       module:THIS_MODULE,
       attach:s526_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 7e066a0263cc..51ff5a7e5639 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -245,23 +245,23 @@ static comedi_driver driver_s526 = {
       num_names:sizeof(s526_boards) / sizeof(s526_board),
 };
 
-static int s526_gpct_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_gpct_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 /*
@@ -272,7 +272,7 @@ static int s526_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s
  */
 static int s526_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	int iobase;
 	int i, n;
 //      short value;
@@ -476,7 +476,7 @@ static int s526_detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int s526_gpct_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;			// counts the Data
@@ -500,7 +500,7 @@ static int s526_gpct_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int s526_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
@@ -725,7 +725,7 @@ static int s526_gpct_insn_config(struct comedi_device * dev, comedi_subdevice *
 	return insn->n;
 }
 
-static int s526_gpct_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
@@ -784,7 +784,7 @@ static int s526_gpct_winsn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 #define ISR_ADC_DONE 0x4
-static int s526_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int result = -EINVAL;
@@ -817,7 +817,7 @@ static int s526_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int s526_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -867,7 +867,7 @@ static int s526_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s526_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -896,7 +896,7 @@ static int s526_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int s526_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -913,7 +913,7 @@ static int s526_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int s526_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -938,7 +938,7 @@ static int s526_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int s526_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index c9bd985f9932..7e066a0263cc 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -190,7 +190,7 @@ static const s526_board s526_boards[] = {
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 	int data;
 
@@ -215,8 +215,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int s526_attach(comedi_device * dev, comedi_devconfig * it);
-static int s526_detach(comedi_device * dev);
+static int s526_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int s526_detach(struct comedi_device * dev);
 static comedi_driver driver_s526 = {
       driver_name:"s526",
       module:THIS_MODULE,
@@ -245,23 +245,23 @@ static comedi_driver driver_s526 = {
       num_names:sizeof(s526_boards) / sizeof(s526_board),
 };
 
-static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 /*
@@ -270,7 +270,7 @@ static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int s526_attach(comedi_device * dev, comedi_devconfig * it)
+static int s526_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	int iobase;
@@ -466,7 +466,7 @@ static int s526_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int s526_detach(comedi_device * dev)
+static int s526_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: s526: remove\n", dev->minor);
 
@@ -476,7 +476,7 @@ static int s526_detach(comedi_device * dev)
 	return 0;
 }
 
-static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;			// counts the Data
@@ -500,7 +500,7 @@ static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
@@ -725,7 +725,7 @@ static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return insn->n;
 }
 
-static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_gpct_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
@@ -784,7 +784,7 @@ static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 #define ISR_ADC_DONE 0x4
-static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int result = -EINVAL;
@@ -817,7 +817,7 @@ static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -867,7 +867,7 @@ static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -896,7 +896,7 @@ static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int s526_ao_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -913,7 +913,7 @@ static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
@@ -938,7 +938,7 @@ static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int s526_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 20ac48e81514..c9bd985f9932 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -198,7 +198,7 @@ typedef struct {
 	struct pci_dev *pci_dev;
 
 	/* Used for AO readback */
-	lsampl_t ao_readback[2];
+	unsigned int ao_readback[2];
 
 	s526_gpct_config_t s526_gpct_config[4];
 	unsigned short s526_ai_config;
@@ -246,23 +246,23 @@ static comedi_driver driver_s526 = {
 };
 
 static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -275,7 +275,7 @@ static int s526_attach(comedi_device * dev, comedi_devconfig * it)
 	comedi_subdevice *s;
 	int iobase;
 	int i, n;
-//      sampl_t value;
+//      short value;
 //      int subdev_channel = 0;
 
 	printk("comedi%d: s526: ", dev->minor);
@@ -428,11 +428,11 @@ static int s526_attach(comedi_device * dev, comedi_devconfig * it)
 	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
 
 	// Load the pre-laod register high word
-//                      value = (sampl_t) (0x55);
+//                      value = (short) (0x55);
 //                      outw(value, ADDR_CHAN_REG(REG_C0H, n));
 
 	// Load the pre-laod register low word
-//                      value = (sampl_t)(0xaa55);
+//                      value = (short)(0xaa55);
 //                      outw(value, ADDR_CHAN_REG(REG_C0L, n));
 
 	// Write the Counter Control Register
@@ -477,7 +477,7 @@ static int s526_detach(comedi_device * dev)
 }
 
 static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;			// counts the Data
 	int counter_channel = CR_CHAN(insn->chanspec);
@@ -501,11 +501,11 @@ static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
 	int i;
-	sampl_t value;
+	short value;
 
 //        printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel);
 
@@ -602,20 +602,20 @@ static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
 			cmReg.reg.autoLoadResetRcap = 4;	// Auto load with INDEX^
 
 		// Set Counter Mode Register
-		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		// Load the pre-laod register high word
-		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		// Load the pre-laod register low word
-		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		// Write the Counter Control Register
 		if (insn->data[3] != 0) {
-			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		// Reset the counter if it is software preload
@@ -639,34 +639,34 @@ static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
 			SinglePulseGeneration;
 
 		// Set Counter Mode Register
-		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	// PR0
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		// Load the pre-laod register 0 high word
-		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		// Load the pre-laod register 0 low word
-		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		// Set Counter Mode Register
-		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	// PR1
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		// Load the pre-laod register 1 high word
-		value = (sampl_t) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		// Load the pre-laod register 1 low word
-		value = (sampl_t) (insn->data[3] & 0xFFFF);
+		value = (short) (insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		// Write the Counter Control Register
 		if (insn->data[3] != 0) {
-			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -684,34 +684,34 @@ static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
 			PulseTrainGeneration;
 
 		// Set Counter Mode Register
-		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 0;	// PR0
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		// Load the pre-laod register 0 high word
-		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		value = (short) ((insn->data[2] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		// Load the pre-laod register 0 low word
-		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		value = (short) (insn->data[2] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		// Set Counter Mode Register
-		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.value = (short) (insn->data[1] & 0xFFFF);
 		cmReg.reg.preloadRegSel = 1;	// PR1
 		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
 
 		// Load the pre-laod register 1 high word
-		value = (sampl_t) ((insn->data[3] >> 16) & 0xFFFF);
+		value = (short) ((insn->data[3] >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 
 		// Load the pre-laod register 1 low word
-		value = (sampl_t) (insn->data[3] & 0xFFFF);
+		value = (short) (insn->data[3] & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
 		// Write the Counter Control Register
 		if (insn->data[3] != 0) {
-			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			value = (short) (insn->data[3] & 0xFFFF);
 			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 		break;
@@ -726,10 +726,10 @@ static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
-	sampl_t value;
+	short value;
 
 	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
 	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
@@ -769,9 +769,9 @@ static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
 			return -EINVAL;
 		}
 
-		value = (sampl_t) ((*data >> 16) & 0xFFFF);
+		value = (short) ((*data >> 16) & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
-		value = (sampl_t) (*data & 0xFFFF);
+		value = (short) (*data & 0xFFFF);
 		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 	default:		// Impossible
@@ -785,7 +785,7 @@ static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
 
 #define ISR_ADC_DONE 0x4
 static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int result = -EINVAL;
 
@@ -818,7 +818,7 @@ static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
  * mode.
  */
 static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -868,7 +868,7 @@ static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -897,7 +897,7 @@ static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
 static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 	int chan = CR_CHAN(insn->chanspec);
@@ -914,7 +914,7 @@ static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
 static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (insn->n != 2)
 		return -EINVAL;
@@ -939,10 +939,10 @@ static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
-	sampl_t value;
+	short value;
 
 	printk("S526 DIO insn_config\n");
 

commit 0c988d008cedca1d6867def335187e94ccc920c6
Author: Everett Wang <everett.wang@everteq.com>
Date:   Tue Feb 17 16:22:34 2009 -0800

    Staging: comedi: add s526 driver
    
    For Sensoray 526 devices
    
    From: Everett Wang <everett.wang@everteq.com>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
new file mode 100644
index 000000000000..20ac48e81514
--- /dev/null
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -0,0 +1,975 @@
+/*
+    comedi/drivers/s526.c
+    Sensoray s526 Comedi driver
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: s526
+Description: Sensoray 526 driver
+Devices: [Sensoray] 526 (s526)
+Author: Richie
+	Everett Wang <everett.wang@everteq.com>
+Updated: Thu, 14 Sep. 2006
+Status: experimental
+
+Encoder works
+Analog input works
+Analog output works
+PWM output works
+Commands are not supported yet.
+
+Configuration Options:
+
+comedi_config /dev/comedi0 s526 0x2C0,0x3
+
+*/
+
+#include "../comedidev.h"
+#include <linux/ioport.h>
+
+#define S526_SIZE 64
+
+#define S526_START_AI_CONV	0
+#define S526_AI_READ		0
+
+/* Ports */
+#define S526_IOSIZE 0x40
+#define S526_NUM_PORTS 27
+
+/* registers */
+#define REG_TCR 0x00
+#define REG_WDC 0x02
+#define REG_DAC 0x04
+#define REG_ADC 0x06
+#define REG_ADD 0x08
+#define REG_DIO 0x0A
+#define REG_IER 0x0C
+#define REG_ISR 0x0E
+#define REG_MSC 0x10
+#define REG_C0L 0x12
+#define REG_C0H 0x14
+#define REG_C0M 0x16
+#define REG_C0C 0x18
+#define REG_C1L 0x1A
+#define REG_C1H 0x1C
+#define REG_C1M 0x1E
+#define REG_C1C 0x20
+#define REG_C2L 0x22
+#define REG_C2H 0x24
+#define REG_C2M 0x26
+#define REG_C2C 0x28
+#define REG_C3L 0x2A
+#define REG_C3H 0x2C
+#define REG_C3M 0x2E
+#define REG_C3C 0x30
+#define REG_EED 0x32
+#define REG_EEC 0x34
+
+static const int s526_ports[] = {
+	REG_TCR,
+	REG_WDC,
+	REG_DAC,
+	REG_ADC,
+	REG_ADD,
+	REG_DIO,
+	REG_IER,
+	REG_ISR,
+	REG_MSC,
+	REG_C0L,
+	REG_C0H,
+	REG_C0M,
+	REG_C0C,
+	REG_C1L,
+	REG_C1H,
+	REG_C1M,
+	REG_C1C,
+	REG_C2L,
+	REG_C2H,
+	REG_C2M,
+	REG_C2C,
+	REG_C3L,
+	REG_C3H,
+	REG_C3M,
+	REG_C3C,
+	REG_EED,
+	REG_EEC
+};
+
+typedef struct {
+	unsigned short coutSource:1;
+	unsigned short coutPolarity:1;
+	unsigned short autoLoadResetRcap:3;
+	unsigned short hwCtEnableSource:2;
+	unsigned short ctEnableCtrl:2;
+	unsigned short clockSource:2;
+	unsigned short countDir:1;
+	unsigned short countDirCtrl:1;
+	unsigned short outputRegLatchCtrl:1;
+	unsigned short preloadRegSel:1;
+	unsigned short reserved:1;
+} counter_mode_register_t;
+
+union {
+	counter_mode_register_t reg;
+	unsigned short value;
+} cmReg;
+
+#define MAX_GPCT_CONFIG_DATA 6
+
+/* Different Application Classes for GPCT Subdevices */
+/* The list is not exhaustive and needs discussion! */
+typedef enum {
+	CountingAndTimeMeasurement,
+	SinglePulseGeneration,
+	PulseTrainGeneration,
+	PositionMeasurement,
+	Miscellaneous
+} S526_GPCT_APP_CLASS;
+
+/* Config struct for different GPCT subdevice Application Classes and
+   their options
+*/
+typedef struct s526GPCTConfig {
+	S526_GPCT_APP_CLASS app;
+	int data[MAX_GPCT_CONFIG_DATA];
+} s526_gpct_config_t;
+
+/*
+ * Board descriptions for two imaginary boards.  Describing the
+ * boards in this way is optional, and completely driver-dependent.
+ * Some drivers use arrays such as this, other do not.
+ */
+typedef struct s526_board_struct {
+	const char *name;
+	int gpct_chans;
+	int gpct_bits;
+	int ad_chans;
+	int ad_bits;
+	int da_chans;
+	int da_bits;
+	int have_dio;
+} s526_board;
+
+static const s526_board s526_boards[] = {
+	{
+	      name:	"s526",
+	      gpct_chans:4,
+	      gpct_bits:24,
+	      ad_chans:8,
+	      ad_bits:	16,
+	      da_chans:4,
+	      da_bits:	16,
+	      have_dio:1,
+		}
+};
+
+#define ADDR_REG(reg) (dev->iobase + (reg))
+#define ADDR_CHAN_REG(reg, chan) (dev->iobase + (reg) + (chan) * 8)
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const s526_board *)dev->board_ptr)
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+	int data;
+
+	/* would be useful for a PCI device */
+	struct pci_dev *pci_dev;
+
+	/* Used for AO readback */
+	lsampl_t ao_readback[2];
+
+	s526_gpct_config_t s526_gpct_config[4];
+	unsigned short s526_ai_config;
+} s526_private;
+/*
+ * most drivers define the following macro to make it easy to
+ * access the private structure.
+ */
+#define devpriv ((s526_private *)dev->private)
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int s526_attach(comedi_device * dev, comedi_devconfig * it);
+static int s526_detach(comedi_device * dev);
+static comedi_driver driver_s526 = {
+      driver_name:"s526",
+      module:THIS_MODULE,
+      attach:s526_attach,
+      detach:s526_detach,
+/* It is not necessary to implement the following members if you are
+ * writing a driver for a ISA PnP or PCI card */
+	/* Most drivers will support multiple types of boards by
+	 * having an array of board structures.  These were defined
+	 * in s526_boards[] above.  Note that the element 'name'
+	 * was first in the structure -- Comedi uses this fact to
+	 * extract the name of the board without knowing any details
+	 * about the structure except for its length.
+	 * When a device is attached (by comedi_config), the name
+	 * of the device is given to Comedi, and Comedi tries to
+	 * match it by going through the list of board names.  If
+	 * there is a match, the address of the pointer is put
+	 * into dev->board_ptr and driver->attach() is called.
+	 *
+	 * Note that these are not necessary if you can determine
+	 * the type of board in software.  ISA PnP, PCI, and PCMCIA
+	 * devices are such boards.
+	 */
+      board_name:&s526_boards[0].name,
+      offset:sizeof(s526_board),
+      num_names:sizeof(s526_boards) / sizeof(s526_board),
+};
+
+static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int s526_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	int iobase;
+	int i, n;
+//      sampl_t value;
+//      int subdev_channel = 0;
+
+	printk("comedi%d: s526: ", dev->minor);
+
+	iobase = it->options[0];
+	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
+		comedi_error(dev, "I/O port conflict");
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	printk("iobase=0x%lx\n", dev->iobase);
+
+	/*** make it a little quieter, exw, 8/29/06
+	for (i = 0; i < S526_NUM_PORTS; i++) {
+		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
+	}
+	***/
+
+/*
+ * Initialize dev->board_name.  Note that we can use the "thisboard"
+ * macro now, since we just initialized it in the last line.
+ */
+	dev->board_ptr = &s526_boards[0];
+
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the private structure area.  alloc_private() is a
+ * convenient macro defined in comedidev.h.
+ */
+	if (alloc_private(dev, sizeof(s526_private)) < 0)
+		return -ENOMEM;
+
+/*
+ * Allocate the subdevice structures.  alloc_subdevice() is a
+ * convenient macro defined in comedidev.h.
+ */
+	dev->n_subdevices = 4;
+	if (alloc_subdevices(dev, dev->n_subdevices) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* GENERAL-PURPOSE COUNTER/TIME (GPCT) */
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;
+	/* KG: What does SDF_LSAMPL (see multiq3.c) mean? */
+	s->n_chan = thisboard->gpct_chans;
+	s->maxdata = 0x00ffffff;	/* 24 bit counter */
+	s->insn_read = s526_gpct_rinsn;
+	s->insn_config = s526_gpct_insn_config;
+	s->insn_write = s526_gpct_winsn;
+
+	/* Command are not implemented yet, however they are necessary to
+	   allocate the necessary memory for the comedi_async struct (used
+	   to trigger the GPCT in case of pulsegenerator function */
+	//s->do_cmd = s526_gpct_cmd;
+	//s->do_cmdtest = s526_gpct_cmdtest;
+	//s->cancel = s526_gpct_cancel;
+
+	s = dev->subdevices + 1;
+	//dev->read_subdev=s;
+	/* analog input subdevice */
+	s->type = COMEDI_SUBD_AI;
+	/* we support differential */
+	s->subdev_flags = SDF_READABLE | SDF_DIFF;
+	/* channels 0 to 7 are the regular differential inputs */
+	/* channel 8 is "reference 0" (+10V), channel 9 is "reference 1" (0V) */
+	s->n_chan = 10;
+	s->maxdata = 0xffff;
+	s->range_table = &range_bipolar10;
+	s->len_chanlist = 16;	/* This is the maximum chanlist length that
+				   the board can handle */
+	s->insn_read = s526_ai_rinsn;
+	s->insn_config = s526_ai_insn_config;
+
+	s = dev->subdevices + 2;
+	/* analog output subdevice */
+	s->type = COMEDI_SUBD_AO;
+	s->subdev_flags = SDF_WRITABLE;
+	s->n_chan = 4;
+	s->maxdata = 0xffff;
+	s->range_table = &range_bipolar10;
+	s->insn_write = s526_ao_winsn;
+	s->insn_read = s526_ao_rinsn;
+
+	s = dev->subdevices + 3;
+	/* digital i/o subdevice */
+	if (thisboard->have_dio) {
+		s->type = COMEDI_SUBD_DIO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+		s->n_chan = 2;
+		s->maxdata = 1;
+		s->range_table = &range_digital;
+		s->insn_bits = s526_dio_insn_bits;
+		s->insn_config = s526_dio_insn_config;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	printk("attached\n");
+
+	return 1;
+
+#if 0
+	// Example of Counter Application
+	//One-shot (software trigger)
+	cmReg.reg.coutSource = 0;	// out RCAP
+	cmReg.reg.coutPolarity = 1;	// Polarity inverted
+	cmReg.reg.autoLoadResetRcap = 1;	// Auto load 0:disabled, 1:enabled
+	cmReg.reg.hwCtEnableSource = 3;	// NOT RCAP
+	cmReg.reg.ctEnableCtrl = 2;	// Hardware
+	cmReg.reg.clockSource = 2;	// Internal
+	cmReg.reg.countDir = 1;	// Down
+	cmReg.reg.countDirCtrl = 1;	// Software
+	cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
+	cmReg.reg.preloadRegSel = 0;	// PR0
+	cmReg.reg.reserved = 0;
+
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
+	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+
+	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset RCAP (fires one-shot)
+
+#else
+
+	// Set Counter Mode Register
+	cmReg.reg.coutSource = 0;	// out RCAP
+	cmReg.reg.coutPolarity = 0;	// Polarity inverted
+	cmReg.reg.autoLoadResetRcap = 0;	// Auto load disabled
+	cmReg.reg.hwCtEnableSource = 2;	// NOT RCAP
+	cmReg.reg.ctEnableCtrl = 1;	// 1: Software,  >1 : Hardware
+	cmReg.reg.clockSource = 3;	// x4
+	cmReg.reg.countDir = 0;	// up
+	cmReg.reg.countDirCtrl = 0;	// quadrature
+	cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
+	cmReg.reg.preloadRegSel = 0;	// PR0
+	cmReg.reg.reserved = 0;
+
+	n = 0;
+	printk("Mode reg=0x%04x, 0x%04lx\n", cmReg.value, ADDR_CHAN_REG(REG_C0M,
+			n));
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	udelay(1000);
+	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+
+	// Load the pre-laod register high word
+//                      value = (sampl_t) (0x55);
+//                      outw(value, ADDR_CHAN_REG(REG_C0H, n));
+
+	// Load the pre-laod register low word
+//                      value = (sampl_t)(0xaa55);
+//                      outw(value, ADDR_CHAN_REG(REG_C0L, n));
+
+	// Write the Counter Control Register
+//                      outw(value, ADDR_CHAN_REG(REG_C0C, 0));
+
+	// Reset the counter if it is software preload
+	if (cmReg.reg.autoLoadResetRcap == 0) {
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));	// Reset the counter
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));	// Load the counter from PR0
+	}
+
+	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
+	udelay(1000);
+	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+
+#endif
+	printk("Current registres:\n");
+
+	for (i = 0; i < S526_NUM_PORTS; i++) {
+		printk("0x%02lx: 0x%04x\n", ADDR_REG(s526_ports[i]),
+			inw(ADDR_REG(s526_ports[i])));
+	}
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int s526_detach(comedi_device * dev)
+{
+	printk("comedi%d: s526: remove\n", dev->minor);
+
+	if (dev->iobase > 0)
+		release_region(dev->iobase, S526_IOSIZE);
+
+	return 0;
+}
+
+static int s526_gpct_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;			// counts the Data
+	int counter_channel = CR_CHAN(insn->chanspec);
+	unsigned short datalow;
+	unsigned short datahigh;
+
+	// Check if (n > 0)
+	if (insn->n <= 0) {
+		printk("s526: INSN_READ: n should be > 0\n");
+		return -EINVAL;
+	}
+	// Read the low word first
+	for (i = 0; i < insn->n; i++) {
+		datalow = inw(ADDR_CHAN_REG(REG_C0L, counter_channel));
+		datahigh = inw(ADDR_CHAN_REG(REG_C0H, counter_channel));
+		data[i] = (int)(datahigh & 0x00FF);
+		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
+//              printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n", counter_channel, data[i], datahigh, datalow);
+	}
+	return i;
+}
+
+static int s526_gpct_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
+	int i;
+	sampl_t value;
+
+//        printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel);
+
+	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
+		devpriv->s526_gpct_config[subdev_channel].data[i] =
+			insn->data[i];
+//              printk("data[%d]=%x\n", i, insn->data[i]);
+	}
+
+	// Check what type of Counter the user requested, data[0] contains
+	// the Application type
+	switch (insn->data[0]) {
+	case INSN_CONFIG_GPCT_QUADRATURE_ENCODER:
+		/*
+		   data[0]: Application Type
+		   data[1]: Counter Mode Register Value
+		   data[2]: Pre-load Register Value
+		   data[3]: Conter Control Register
+		 */
+		printk("s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
+		devpriv->s526_gpct_config[subdev_channel].app =
+			PositionMeasurement;
+
+/*
+			// Example of Counter Application
+			//One-shot (software trigger)
+			cmReg.reg.coutSource		= 0; // out RCAP
+			cmReg.reg.coutPolarity		= 1; // Polarity inverted
+			cmReg.reg.autoLoadResetRcap	= 0; // Auto load disabled
+			cmReg.reg.hwCtEnableSource	= 3; // NOT RCAP
+			cmReg.reg.ctEnableCtrl		= 2; // Hardware
+			cmReg.reg.clockSource		= 2; // Internal
+			cmReg.reg.countDir		= 1; // Down
+			cmReg.reg.countDirCtrl		= 1; // Software
+			cmReg.reg.outputRegLatchCtrl	= 0; // latch on read
+			cmReg.reg.preloadRegSel		= 0; // PR0
+			cmReg.reg.reserved		= 0;
+
+			outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+			outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+			outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+
+			outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));  // Reset RCAP (fires one-shot)
+
+*/
+
+#if 1
+		// Set Counter Mode Register
+		cmReg.reg.coutSource = 0;	// out RCAP
+		cmReg.reg.coutPolarity = 0;	// Polarity inverted
+		cmReg.reg.autoLoadResetRcap = 0;	// Auto load disabled
+		cmReg.reg.hwCtEnableSource = 2;	// NOT RCAP
+		cmReg.reg.ctEnableCtrl = 1;	// 1: Software,  >1 : Hardware
+		cmReg.reg.clockSource = 3;	// x4
+		cmReg.reg.countDir = 0;	// up
+		cmReg.reg.countDirCtrl = 0;	// quadrature
+		cmReg.reg.outputRegLatchCtrl = 0;	// latch on read
+		cmReg.reg.preloadRegSel = 0;	// PR0
+		cmReg.reg.reserved = 0;
+
+		// Set Counter Mode Register
+//                      printk("s526: Counter Mode register=%x\n", cmReg.value);
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Reset the counter if it is software preload
+		if (cmReg.reg.autoLoadResetRcap == 0) {
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
+//                              outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));   // Load the counter from PR0
+		}
+#else
+		cmReg.reg.countDirCtrl = 0;	// 0 quadrature, 1 software control
+
+		// data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4
+		if (insn->data[1] == GPCT_X2) {
+			cmReg.reg.clockSource = 1;
+		} else if (insn->data[1] == GPCT_X4) {
+			cmReg.reg.clockSource = 2;
+		} else {
+			cmReg.reg.clockSource = 0;
+		}
+
+		// When to take into account the indexpulse:
+		if (insn->data[2] == GPCT_IndexPhaseLowLow) {
+		} else if (insn->data[2] == GPCT_IndexPhaseLowHigh) {
+		} else if (insn->data[2] == GPCT_IndexPhaseHighLow) {
+		} else if (insn->data[2] == GPCT_IndexPhaseHighHigh) {
+		}
+		// Take into account the index pulse?
+		if (insn->data[3] == GPCT_RESET_COUNTER_ON_INDEX)
+			cmReg.reg.autoLoadResetRcap = 4;	// Auto load with INDEX^
+
+		// Set Counter Mode Register
+		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Load the pre-laod register high word
+		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+
+		// Load the pre-laod register low word
+		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		// Write the Counter Control Register
+		if (insn->data[3] != 0) {
+			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		}
+		// Reset the counter if it is software preload
+		if (cmReg.reg.autoLoadResetRcap == 0) {
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Reset the counter
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	// Load the counter from PR0
+		}
+#endif
+		break;
+
+	case INSN_CONFIG_GPCT_SINGLE_PULSE_GENERATOR:
+		/*
+		   data[0]: Application Type
+		   data[1]: Counter Mode Register Value
+		   data[2]: Pre-load Register 0 Value
+		   data[3]: Pre-load Register 1 Value
+		   data[4]: Conter Control Register
+		 */
+		printk("s526: GPCT_INSN_CONFIG: Configuring SPG\n");
+		devpriv->s526_gpct_config[subdev_channel].app =
+			SinglePulseGeneration;
+
+		// Set Counter Mode Register
+		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.reg.preloadRegSel = 0;	// PR0
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Load the pre-laod register 0 high word
+		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+
+		// Load the pre-laod register 0 low word
+		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		// Set Counter Mode Register
+		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.reg.preloadRegSel = 1;	// PR1
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Load the pre-laod register 1 high word
+		value = (sampl_t) ((insn->data[3] >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+
+		// Load the pre-laod register 1 low word
+		value = (sampl_t) (insn->data[3] & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		// Write the Counter Control Register
+		if (insn->data[3] != 0) {
+			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		}
+		break;
+
+	case INSN_CONFIG_GPCT_PULSE_TRAIN_GENERATOR:
+		/*
+		   data[0]: Application Type
+		   data[1]: Counter Mode Register Value
+		   data[2]: Pre-load Register 0 Value
+		   data[3]: Pre-load Register 1 Value
+		   data[4]: Conter Control Register
+		 */
+		printk("s526: GPCT_INSN_CONFIG: Configuring PTG\n");
+		devpriv->s526_gpct_config[subdev_channel].app =
+			PulseTrainGeneration;
+
+		// Set Counter Mode Register
+		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.reg.preloadRegSel = 0;	// PR0
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Load the pre-laod register 0 high word
+		value = (sampl_t) ((insn->data[2] >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+
+		// Load the pre-laod register 0 low word
+		value = (sampl_t) (insn->data[2] & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		// Set Counter Mode Register
+		cmReg.value = (sampl_t) (insn->data[1] & 0xFFFF);
+		cmReg.reg.preloadRegSel = 1;	// PR1
+		outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, subdev_channel));
+
+		// Load the pre-laod register 1 high word
+		value = (sampl_t) ((insn->data[3] >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+
+		// Load the pre-laod register 1 low word
+		value = (sampl_t) (insn->data[3] & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+
+		// Write the Counter Control Register
+		if (insn->data[3] != 0) {
+			value = (sampl_t) (insn->data[3] & 0xFFFF);
+			outw(value, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		}
+		break;
+
+	default:
+		printk("s526: unsupported GPCT_insn_config\n");
+		return -EINVAL;
+		break;
+	}
+
+	return insn->n;
+}
+
+static int s526_gpct_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int subdev_channel = CR_CHAN(insn->chanspec);	// Unpack chanspec
+	sampl_t value;
+
+	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
+	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
+	printk("s526: Counter Mode Register: %x\n", cmReg.value);
+	// Check what Application of Counter this channel is configured for
+	switch (devpriv->s526_gpct_config[subdev_channel].app) {
+	case PositionMeasurement:
+		printk("S526: INSN_WRITE: PM\n");
+		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
+				subdev_channel));
+		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		break;
+
+	case SinglePulseGeneration:
+		printk("S526: INSN_WRITE: SPG\n");
+		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
+				subdev_channel));
+		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		break;
+
+	case PulseTrainGeneration:
+		/* data[0] contains the PULSE_WIDTH
+		   data[1] contains the PULSE_PERIOD
+		   @pre PULSE_PERIOD > PULSE_WIDTH > 0
+		   The above periods must be expressed as a multiple of the
+		   pulse frequency on the selected source
+		 */
+		printk("S526: INSN_WRITE: PTG\n");
+		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
+			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
+				insn->data[0];
+			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
+				insn->data[1];
+		} else {
+			printk("%d \t %d\n", insn->data[1], insn->data[2]);
+			printk("s526: INSN_WRITE: PTG: Problem with Pulse params\n");
+			return -EINVAL;
+		}
+
+		value = (sampl_t) ((*data >> 16) & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0H, subdev_channel));
+		value = (sampl_t) (*data & 0xFFFF);
+		outw(value, ADDR_CHAN_REG(REG_C0L, subdev_channel));
+		break;
+	default:		// Impossible
+		printk("s526: INSN_WRITE: Functionality %d not implemented yet\n", devpriv->s526_gpct_config[subdev_channel].app);
+		return -EINVAL;
+		break;
+	}
+	// return the number of samples written
+	return insn->n;
+}
+
+#define ISR_ADC_DONE 0x4
+static int s526_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int result = -EINVAL;
+
+	if (insn->n < 1)
+		return result;
+
+	result = insn->n;
+
+	/* data[0] : channels was set in relevant bits.
+	   data[1] : delay
+	 */
+	/* COMMENT: abbotti 2008-07-24: I don't know why you'd want to
+	 * enable channels here.  The channel should be enabled in the
+	 * INSN_READ handler. */
+
+	// Enable ADC interrupt
+	outw(ISR_ADC_DONE, ADDR_REG(REG_IER));
+//      printk("s526: ADC current value: 0x%04x\n", inw(ADDR_REG(REG_ADC)));
+	devpriv->s526_ai_config = (data[0] & 0x3FF) << 5;
+	if (data[1] > 0)
+		devpriv->s526_ai_config |= 0x8000;	//set the delay
+
+	devpriv->s526_ai_config |= 0x0001;	// ADC start bit.
+
+	return result;
+}
+
+/*
+ * "instructions" read/write data in "one-shot" or "software-triggered"
+ * mode.
+ */
+static int s526_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, i;
+	int chan = CR_CHAN(insn->chanspec);
+	unsigned short value;
+	unsigned int d;
+	unsigned int status;
+
+	/* Set configured delay, enable channel for this channel only,
+	 * select "ADC read" channel, set "ADC start" bit. */
+	value = (devpriv->s526_ai_config & 0x8000) |
+		((1 << 5) << chan) | (chan << 1) | 0x0001;
+
+	/* convert n samples */
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		outw(value, ADDR_REG(REG_ADC));
+//              printk("s526: Wrote 0x%04x to ADC\n", value);
+//              printk("s526: ADC reg=0x%04x\n", inw(ADDR_REG(REG_ADC)));
+
+#define TIMEOUT 100
+		/* wait for conversion to end */
+		for (i = 0; i < TIMEOUT; i++) {
+			status = inw(ADDR_REG(REG_ISR));
+			if (status & ISR_ADC_DONE) {
+				outw(ISR_ADC_DONE, ADDR_REG(REG_ISR));
+				break;
+			}
+		}
+		if (i == TIMEOUT) {
+			/* rt_printk() should be used instead of printk()
+			 * whenever the code can be called from real-time. */
+			rt_printk("s526: ADC(0x%04x) timeout\n",
+				inw(ADDR_REG(REG_ISR)));
+			return -ETIMEDOUT;
+		}
+
+		/* read data */
+		d = inw(ADDR_REG(REG_ADD));
+//              printk("AI[%d]=0x%04x\n", n, (unsigned short)(d & 0xFFFF));
+
+		/* munge data */
+		data[n] = d ^ 0x8000;
+	}
+
+	/* return the number of samples read/written */
+	return n;
+}
+
+static int s526_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+	unsigned short val;
+
+//      printk("s526_ao_winsn\n");
+	val = chan << 1;
+//      outw(val, dev->iobase + REG_DAC);
+	outw(val, ADDR_REG(REG_DAC));
+
+	/* Writing a list of values to an AO channel is probably not
+	 * very useful, but that's how the interface is defined. */
+	for (i = 0; i < insn->n; i++) {
+		/* a typical programming sequence */
+//              outw(data[i], dev->iobase + REG_ADD);  // write the data to preload register
+		outw(data[i], ADDR_REG(REG_ADD));	// write the data to preload register
+		devpriv->ao_readback[chan] = data[i];
+//              outw(val + 1, dev->iobase + REG_DAC); // starts the D/A conversion.
+		outw(val + 1, ADDR_REG(REG_DAC));	// starts the D/A conversion.
+	}
+
+	/* return the number of samples read/written */
+	return i;
+}
+
+/* AO subdevices should have a read insn as well as a write insn.
+ * Usually this means copying a value stored in devpriv. */
+static int s526_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+	int chan = CR_CHAN(insn->chanspec);
+
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
+
+	return i;
+}
+
+/* DIO devices are slightly special.  Although it is possible to
+ * implement the insn_read/insn_write interface, it is much more
+ * useful to applications if you implement the insn_bits interface.
+ * This allows packed reading/writing of the DIO channels.  The
+ * comedi core can convert between insn_bits and insn_read/write */
+static int s526_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (insn->n != 2)
+		return -EINVAL;
+
+	/* The insn data is a mask in data[0] and the new data
+	 * in data[1], each channel cooresponding to a bit. */
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= data[0] & data[1];
+		/* Write out the new digital output lines */
+		outw(s->state, ADDR_REG(REG_DIO));
+	}
+
+	/* on return, data[1] contains the value of the digital
+	 * input and output lines. */
+	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	// low 8 bits are the data
+	/* or we could just return the software copy of the output values if
+	 * it was a purely digital output subdevice */
+	//data[1]=s->state;
+
+	return 2;
+}
+
+static int s526_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec);
+	sampl_t value;
+
+	printk("S526 DIO insn_config\n");
+
+	if (insn->n != 1)
+		return -EINVAL;
+
+	value = inw(ADDR_REG(REG_DIO));
+
+	/* The input or output configuration of each digital line is
+	 * configured by a special insn_config instruction.  chanspec
+	 * contains the channel to be changed, and data[0] contains the
+	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
+
+	if (data[0] == COMEDI_OUTPUT) {
+		value |= 1 << (chan + 10);	// bit 10/11 set the group 1/2's mode
+		s->io_bits |= (0xF << chan);
+	} else {
+		value &= ~(1 << (chan + 10));	// 1 is output, 0 is input.
+		s->io_bits &= ~(0xF << chan);
+	}
+	outw(value, ADDR_REG(REG_DIO));
+
+	return 1;
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver_s526);
