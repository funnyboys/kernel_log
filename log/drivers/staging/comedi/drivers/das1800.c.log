commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d7fe055ae901..f16aa7e9f4f3 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e0a34c2687a8..d7fe055ae901 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Comedi driver for Keithley DAS-1700/DAS-1800 series boards
  * Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>

commit 098353038bedf133860c5457488a895bd1de00c1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:06 2016 -0700

    staging: comedi: das1800: update the MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something more usefull than the
    generic "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 875b6f504626..e0a34c2687a8 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1369,5 +1369,5 @@ static struct comedi_driver das1800_driver = {
 module_comedi_driver(das1800_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for DAS1800 compatible ISA boards");
 MODULE_LICENSE("GPL");

commit a6b7dbb2be27636e80e4124f157e08b33e451b80
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:05 2016 -0700

    staging: comedi: das1800: allow setting the external trigger polarity
    
    The external pin TGIN can be used to start and/or stop the analog input
    command. Currently the driver only supports negative edge polarity for
    this signal.
    
    Add support to allow the user to select positive edge polarity using
    the CR_INVERT flag.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index bfbc2bbbce10..875b6f504626 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -60,6 +60,9 @@
  * If TRIG_EXT is used for both the start_src and stop_src, the first TGIN
  * trigger starts the command, and the second trigger will stop it. If only
  * one is TRIG_EXT, the first trigger will either stop or start the command.
+ * The external pin TGIN is normally set for negative edge triggering. It
+ * can be set to positive edge with the CR_INVERT flag. If TRIG_EXT is used
+ * for both the start_src and stop_src they must have the same polarity.
  *
  * Minimum conversion speed is limited to 64 microseconds (convert_arg <= 64000)
  * for 'burst' scans. This limitation does not apply for 'paced' scans. The
@@ -105,6 +108,7 @@
 #define   CGSL                    0x8
 #define   TGEN                    0x10
 #define   TGSL                    0x20
+#define   TGPL                    0x40
 #define   ATEN                    0x80
 #define DAS1800_CONTROL_B       0x5
 #define   DMA_CH5                 0x1
@@ -671,12 +675,18 @@ static int das1800_ai_cmdtest(struct comedi_device *dev,
 	    cmd->convert_src != TRIG_TIMER)
 		err |= -EINVAL;
 
+	/* the external pin TGIN must use the same polarity */
+	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg,
+						   cmd->stop_arg);
+
 	if (err)
 		return 2;
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	if (cmd->start_arg == TRIG_NOW)
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
@@ -868,6 +878,10 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 		control_a |= TGEN | CGSL;
 	else /* TRIG_NOW */
 		control_a |= CGEN;
+	if (control_a & (ATEN | TGEN)) {
+		if ((cmd->start_arg & CR_INVERT) || (cmd->stop_arg & CR_INVERT))
+			control_a |= TGPL;
+	}
 
 	control_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);
 	/* set clock source to internal or external */

commit a2706b094353b6210446af3be174c9eddfd7ce01
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:04 2016 -0700

    staging: comedi: das1800: clarify the analog input cmd triggers
    
    Clarify the documentation in the comedi driver comment block to
    better explain the cmd triggert.
    
    Add a comment to step 2b of the (*do_cmdtest) to clarify the
    trigger check.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9153c9b871c1..bfbc2bbbce10 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -39,19 +39,32 @@
  *   [3] - DMA1 (optional, requires irq and dma0)
  *
  * analog input cmd triggers supported:
- *   start_src:		TRIG_NOW | TRIG_EXT
- *   scan_begin_src:	TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT
- *   scan_end_src:	TRIG_COUNT
- *   convert_src:	TRIG_TIMER | TRIG_EXT
- *			(TRIG_EXT requires scan_begin_src == TRIG_FOLLOW)
- *   stop_src:		TRIG_COUNT | TRIG_EXT | TRIG_NONE
  *
- * scan_begin_src triggers TRIG_TIMER and TRIG_EXT use the card's
- * 'burst mode' which limits the valid conversion time to 64 microseconds
- * (convert_arg <= 64000). This limitation does not apply if scan_begin_src
- * is TRIG_FOLLOW.
+ *   start_src		TRIG_NOW	command starts immediately
+ *			TRIG_EXT	command starts on external pin TGIN
  *
- * The maximum conversion speeds are not always achievable depending on the
+ *   scan_begin_src	TRIG_FOLLOW	paced/external scans start immediately
+ *			TRIG_TIMER	burst scans start periodically
+ *			TRIG_EXT	burst scans start on external pin XPCLK
+ *
+ *   scan_end_src	TRIG_COUNT	scan ends after last channel
+ *
+ *   convert_src	TRIG_TIMER	paced/burst conversions are timed
+ *			TRIG_EXT	conversions on external pin XPCLK
+ *					(requires scan_begin_src == TRIG_FOLLOW)
+ *
+ *   stop_src		TRIG_COUNT	command stops after stop_arg scans
+ *			TRIG_EXT	command stops on external pin TGIN
+ *			TRIG_NONE	command runs until canceled
+ *
+ * If TRIG_EXT is used for both the start_src and stop_src, the first TGIN
+ * trigger starts the command, and the second trigger will stop it. If only
+ * one is TRIG_EXT, the first trigger will either stop or start the command.
+ *
+ * Minimum conversion speed is limited to 64 microseconds (convert_arg <= 64000)
+ * for 'burst' scans. This limitation does not apply for 'paced' scans. The
+ * maximum conversion speed is limited by the board (convert_arg >= ai_speed).
+ * Maximum conversion speeds are not always achievable depending on the
  * board setup (see user manual).
  *
  * NOTES:
@@ -653,6 +666,7 @@ static int das1800_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 2b : and mutually compatible */
 
+	/* burst scans must use timed conversions */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 	    cmd->convert_src != TRIG_TIMER)
 		err |= -EINVAL;

commit 5f657f8bf3fd4a238239264dc56b2edd6bee9e07
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:03 2016 -0700

    staging: comedi: das1800: fix comments about the 'ao' board range
    
    The waveform analog outputs on the 'ao' boards are not currently
    supported. Modify the comment about the analog output range on
    these boards so that the information is saved but fixes the
    checkpatch.pl issues:
    WARNING: Block comments use a trailing */ on a separate line
    
    Move the comment so it's grouped with the comedi_lrange info.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 87285b2bb6de..9153c9b871c1 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -160,6 +160,12 @@ static const struct comedi_lrange das1802_ai_range = {
 	}
 };
 
+/*
+ * The waveform analog outputs on the 'ao' boards are not currently
+ * supported. They have a comedi_lrange of:
+ * { 2, { BIP_RANGE(10), BIP_RANGE(5) } }
+ */
+
 enum das1800_boardid {
 	BOARD_DAS1701ST,
 	BOARD_DAS1701ST_DA,
@@ -305,16 +311,6 @@ struct das1800_private {
 	bool ai_is_unipolar;
 };
 
-/* analog out range for 'ao' boards */
-/*
-static const struct comedi_lrange range_ao_2 = {
-	2, {
-		BIP_RANGE(10),
-		BIP_RANGE(5)
-	}
-};
-*/
-
 static void das1800_ai_munge(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     void *data, unsigned int num_bytes,

commit 6d8c9a9e88ae4d4f0fb9970cb3757eaefe4370fd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:02 2016 -0700

    staging: comedi: das1800: fix lines over 80 characters
    
    These comments are just extra cruft. Remove them to fix the
    checkpatch.pl issues:
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1edb3d6e0c44..87285b2bb6de 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -100,7 +100,7 @@
 #define   DMA_CH5_CH6             0x5
 #define   DMA_CH6_CH7             0x6
 #define   DMA_CH7_CH5             0x7
-#define   DMA_ENABLED             0x3	/* mask used to determine if dma is enabled */
+#define   DMA_ENABLED             0x3
 #define   DMA_DUAL                0x4
 #define   IRQ3                    0x8
 #define   IRQ5                    0x10
@@ -118,22 +118,21 @@
 #define   SD                      0x40
 #define   UB                      0x80
 #define DAS1800_STATUS          0x7
-/* bits that prevent interrupt status bits (and CVEN) from being cleared on write */
-#define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)
 #define   INT                     0x1
 #define   DMATC                   0x2
 #define   CT0TC                   0x8
 #define   OVF                     0x10
 #define   FHF                     0x20
 #define   FNE                     0x40
-#define   CVEN_MASK               0x40	/*  masks CVEN on write */
 #define   CVEN                    0x80
+#define   CVEN_MASK               0x40
+#define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)
 #define DAS1800_BURST_LENGTH    0x8
 #define DAS1800_BURST_RATE      0x9
 #define DAS1800_QRAM_ADDRESS    0xa
 #define DAS1800_COUNTER         0xc
 
-#define IOBASE2                   0x400	/* offset of additional ioports used on 'ao' cards */
+#define IOBASE2                   0x400
 
 static const struct comedi_lrange das1801_ai_range = {
 	8, {

commit b52fd5f08ea6949a0855fb180641257160bbec76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:01 2016 -0700

    staging: comedi: das1800: fix comments in das1800_ai_handler()
    
    Fix the checkpatch.pl issues:
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 42996cd9c948..1edb3d6e0c44 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -452,15 +452,13 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	/* select adc register (spinlock is already held) */
 	outb(ADC, dev->iobase + DAS1800_SELECT);
 
-	/*  dma buffer full */
-	if (devpriv->irq_dma_bits & DMA_ENABLED) {
-		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
+	/* get samples with dma, fifo, or polled as necessary */
+	if (devpriv->irq_dma_bits & DMA_ENABLED)
 		das1800_handle_dma(dev, s, status);
-	} else if (status & FHF) {	/*  if fifo half full */
+	else if (status & FHF)
 		das1800_handle_fifo_half_full(dev, s);
-	} else if (status & FNE) {	/*  if fifo not empty */
+	else if (status & FNE)
 		das1800_handle_fifo_not_empty(dev, s);
-	}
 
 	/* if the card's fifo has overflowed */
 	if (status & OVF) {
@@ -476,7 +474,7 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	if (status & CT0TC) {
 		/*  clear CT0TC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);
-		/*  make sure we get all remaining data from board before quitting */
+		/* get all remaining samples before quitting */
 		if (devpriv->irq_dma_bits & DMA_ENABLED)
 			das1800_flush_dma(dev, s);
 		else

commit 99ad808faf61cb884c3e6e5643114f8e3326c7e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:42:00 2016 -0700

    staging: comedi: das1800: fix comments in das1800_ai_cmd()
    
    Fix the checkpatch.pl issues:
    WARNING: Block comments use a trailing */ on a separate line
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3bfe0410838e..42996cd9c948 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -833,8 +833,10 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 	const struct comedi_cmd *cmd = &async->cmd;
 	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
 
-	/* disable dma on CMDF_WAKE_EOS, or CMDF_PRIORITY
-	 * (because dma in handler is unsafe at hard real-time priority) */
+	/*
+	 * Disable dma on CMDF_WAKE_EOS, or CMDF_PRIORITY (because dma in
+	 * handler is unsafe at hard real-time priority).
+	 */
 	if (cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY))
 		devpriv->irq_dma_bits &= ~DMA_ENABLED;
 	else
@@ -897,14 +899,15 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
 	/*  set conversion rate and length for burst mode */
 	if (control_c & BMDE) {
-		/*  program conversion period with number of microseconds minus 1 */
-		outb(cmd->convert_arg / 1000 - 1,
+		outb(cmd->convert_arg / 1000 - 1,	/* microseconds - 1 */
 		     dev->iobase + DAS1800_BURST_RATE);
 		outb(cmd->chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
 	}
-	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
-	outb(control_a, dev->iobase + DAS1800_CONTROL_A);	/* enable fifo and triggering */
-	outb(CVEN, dev->iobase + DAS1800_STATUS);	/* enable conversions */
+
+	/* enable and start conversions */
+	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);
+	outb(control_a, dev->iobase + DAS1800_CONTROL_A);
+	outb(CVEN, dev->iobase + DAS1800_STATUS);
 
 	return 0;
 }

commit 18092f4486138195cc49d2ced17e0a4f38b4718a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:59 2016 -0700

    staging: comedi: das1800: remove the function comments
    
    These comments are just added cruft. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index ea6aa5abd77e..3bfe0410838e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -359,7 +359,6 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 	}
 }
 
-/* Utility function used by das1800_flush_dma() and das1800_handle_dma() */
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      struct comedi_isadma_desc *desc)
@@ -375,8 +374,6 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	comedi_buf_write_samples(s, desc->virt_addr, nsamples);
 }
 
-/* flushes remaining data from board when external trigger has stopped acquisition
- * and we are using dma transfers */
 static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
@@ -444,7 +441,6 @@ static int das1800_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/* the guts of the interrupt handler, that is shared with das1800_ai_poll */
 static void das1800_ai_handler(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;

commit 7d5fa05cc41bba07908661de9790ad9291777ba6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:58 2016 -0700

    staging: comedi: das1800: clarify step 4 of the ai (*do_cmdtest)
    
    This step of the (*do_cmdtest) fixes the timing arguments when the
    cmd->convert_src is TRIG_TIMER. The code is compact but it's a bit
    hard to understand the "burst mode" vs. "non burst mode" (i.e. paced)
    timing.
    
    Clarify the fixup by splitting it into separate functions to check
    the arguments based on if the command is doing 'paced' or 'burst'
    timing. Add some comments to clarify the fixups.
    
    This also fixes a minor issue with the 'burst' timing. When the
    cmd->scan_begin_src is also TRIG_TIMER the pacer clock is used to
    start each scan. The cmd->scan_begin_arg specifies the scan time.
    The minimum (not maximum) value for this time must be large enough
    for the 'burst' conversion time to sample all the channels.
    
    The current 'max' check limits the scan time to the minimum time
    (i.e. the max conversion speed).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 8302f334f3be..ea6aa5abd77e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -544,33 +544,73 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* converts requested conversion timing to timing compatible with
- * hardware, used only when card is in 'burst mode'
- */
-static unsigned int burst_convert_arg(unsigned int convert_arg, int flags)
+static int das1800_ai_fixup_paced_timing(struct comedi_device *dev,
+					 struct comedi_cmd *cmd)
 {
-	unsigned int micro_sec;
+	unsigned int arg = cmd->convert_arg;
+
+	/*
+	 * Paced mode:
+	 *	scan_begin_src is TRIG_FOLLOW
+	 *	convert_src is TRIG_TIMER
+	 *
+	 * The convert_arg sets the pacer sample acquisition time.
+	 * The max acquisition speed is limited to the boards
+	 * 'ai_speed' (this was already verified). The min speed is
+	 * limited by the cascaded 8254 timer.
+	 */
+	comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
+	return comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
+}
 
-	/*  in burst mode, the maximum conversion time is 64 microseconds */
-	if (convert_arg > 64000)
-		convert_arg = 64000;
+static int das1800_ai_fixup_burst_timing(struct comedi_device *dev,
+					 struct comedi_cmd *cmd)
+{
+	unsigned int arg = cmd->convert_arg;
+	int err = 0;
+
+	/*
+	 * Burst mode:
+	 *	scan_begin_src is TRIG_TIMER or TRIG_EXT
+	 *	convert_src is TRIG_TIMER
+	 *
+	 * The convert_arg sets burst sample acquisition time.
+	 * The max acquisition speed is limited to the boards
+	 * 'ai_speed' (this was already verified). The min speed is
+	 * limiited to 64 microseconds,
+	 */
+	err |= comedi_check_trigger_arg_max(&arg, 64000);
 
-	/*  the conversion time must be an integral number of microseconds */
-	switch (flags & CMDF_ROUND_MASK) {
+	/* round to microseconds then verify */
+	switch (cmd->flags & CMDF_ROUND_MASK) {
 	case CMDF_ROUND_NEAREST:
 	default:
-		micro_sec = (convert_arg + 500) / 1000;
+		arg = DIV_ROUND_CLOSEST(arg, 1000);
 		break;
 	case CMDF_ROUND_DOWN:
-		micro_sec = convert_arg / 1000;
+		arg = arg / 1000;
 		break;
 	case CMDF_ROUND_UP:
-		micro_sec = (convert_arg - 1) / 1000 + 1;
+		arg = DIV_ROUND_UP(arg, 1000);
 		break;
 	}
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg * 1000);
+
+	/*
+	 * The pacer can be used to set the scan sample rate. The max scan
+	 * speed is limited by the conversion speed and the number of channels
+	 * to convert. The min speed is limited by the cascaded 8254 timer.
+	 */
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		arg = cmd->convert_arg * cmd->chanlist_len;
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);
 
-	/*  return number of nanoseconds */
-	return micro_sec * 1000;
+		arg = cmd->scan_begin_arg;
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+	}
+
+	return err;
 }
 
 static int das1800_ai_check_chanlist(struct comedi_device *dev,
@@ -600,7 +640,6 @@ static int das1800_ai_cmdtest(struct comedi_device *dev,
 {
 	const struct das1800_board *board = dev->board_ptr;
 	int err = 0;
-	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -659,31 +698,13 @@ static int das1800_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
+	/* Step 4: fix up any arguments */
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW &&
-	    cmd->convert_src == TRIG_TIMER) {
-		/* we are not in burst mode */
-		arg = cmd->convert_arg;
-		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
-	} else if (cmd->convert_src == TRIG_TIMER) {
-		/* we are in burst mode */
-		arg = burst_convert_arg(cmd->convert_arg, cmd->flags);
-		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
-
-		if (cmd->scan_begin_src == TRIG_TIMER) {
-			arg = cmd->convert_arg * cmd->chanlist_len;
-			err |= comedi_check_trigger_arg_max(&cmd->
-							    scan_begin_arg,
-							    arg);
-
-			arg = cmd->scan_begin_arg;
-			comedi_8254_cascade_ns_to_timer(dev->pacer, &arg,
-							cmd->flags);
-			err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,
-							   arg);
-		}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->scan_begin_src == TRIG_FOLLOW)
+			err |= das1800_ai_fixup_paced_timing(dev, cmd);
+		else /* TRIG_TIMER or TRIG_EXT */
+			err |= das1800_ai_fixup_burst_timing(dev, cmd);
 	}
 
 	if (err)

commit cf9eaee0edaf77d46be528f6293c08deb7b646e8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:57 2016 -0700

    staging: comedi: das1800: remove the private data member comments
    
    The comments about the members of the private data are not really
    necessary and removing them fixes a couple checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9268acb0382f..8302f334f3be 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -299,12 +299,10 @@ static const struct das1800_board das1800_boards[] = {
 
 struct das1800_private {
 	struct comedi_isadma *dma;
-	int irq_dma_bits;	/* bits for control register b */
-	/* dma bits for control register b, stored so that dma can be
-	 * turned on and off */
+	int irq_dma_bits;
 	int dma_bits;
 	unsigned short *fifo_buf;
-	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
+	unsigned long iobase2;
 	bool ai_is_unipolar;
 };
 

commit 5b28b8c45979e78e91773ec93a33c5dbafb737f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:56 2016 -0700

    staging: comedi: das1800: move comment about max conversion speeds
    
    For aesthetics, move this information into the comedi comment block.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 60459782b739..9268acb0382f 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -51,6 +51,9 @@
  * (convert_arg <= 64000). This limitation does not apply if scan_begin_src
  * is TRIG_FOLLOW.
  *
+ * The maximum conversion speeds are not always achievable depending on the
+ * board setup (see user manual).
+ *
  * NOTES:
  * Only the DAS-1801ST has been tested by me.
  * Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
@@ -194,10 +197,6 @@ struct das1800_board {
 	unsigned int is_01_series:1;
 };
 
-/* Warning: the maximum conversion speeds listed below are
- * not always achievable depending on board setup (see
- * user manual.)
- */
 static const struct das1800_board das1800_boards[] = {
 	[BOARD_DAS1701ST] = {
 		.name		= "das-1701st",

commit cc3ddba2c5ca09f477b072286d7d43493d347188
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:55 2016 -0700

    staging: comedi: das1800: change type of private data 'fifo_buf'
    
    Fix the checkpatch.pl issue:
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Change the type to 'unsigned short' as that is more typical in comedi
    drivers.
    
    Use sizeof(*p) instead of sizeof(type) when allocation the buffer.
    Also fix the checkpatch.pl issue:
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 118fa76e64ec..60459782b739 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -304,7 +304,7 @@ struct das1800_private {
 	/* dma bits for control register b, stored so that dma can be
 	 * turned on and off */
 	int dma_bits;
-	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
+	unsigned short *fifo_buf;
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	bool ai_is_unipolar;
 };
@@ -1200,7 +1200,9 @@ static int das1800_attach(struct comedi_device *dev,
 	if (dev->irq & it->options[2])
 		das1800_init_dma(dev, it);
 
-	devpriv->fifo_buf = kmalloc_array(FIFO_SIZE, sizeof(uint16_t), GFP_KERNEL);
+	devpriv->fifo_buf = kmalloc_array(FIFO_SIZE,
+					  sizeof(*devpriv->fifo_buf),
+					  GFP_KERNEL);
 	if (!devpriv->fifo_buf)
 		return -ENOMEM;
 

commit bface0f3233043bcd50a29f35496ff8ceefd5b90
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:54 2016 -0700

    staging: comedi: das1800: cleanup copyright and comedi comment blocks
    
    Tidy up these multi-line comments to fix the checkpatch.pl issues:
    WARNING: Block comments use * on subsequent lines
    WARNING: line over 80 characters
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 365a3d5231a9..118fa76e64ec 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1,97 +1,63 @@
 /*
-    comedi/drivers/das1800.c
-    Driver for Keitley das1700/das1800 series boards
-    Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
-/*
-Driver: das1800
-Description: Keithley Metrabyte DAS1800 (& compatibles)
-Author: Frank Mori Hess <fmhess@users.sourceforge.net>
-Devices: [Keithley Metrabyte] DAS-1701ST (das-1701st),
-  DAS-1701ST-DA (das-1701st-da), DAS-1701/AO (das-1701ao),
-  DAS-1702ST (das-1702st), DAS-1702ST-DA (das-1702st-da),
-  DAS-1702HR (das-1702hr), DAS-1702HR-DA (das-1702hr-da),
-  DAS-1702/AO (das-1702ao), DAS-1801ST (das-1801st),
-  DAS-1801ST-DA (das-1801st-da), DAS-1801HC (das-1801hc),
-  DAS-1801AO (das-1801ao), DAS-1802ST (das-1802st),
-  DAS-1802ST-DA (das-1802st-da), DAS-1802HR (das-1802hr),
-  DAS-1802HR-DA (das-1802hr-da), DAS-1802HC (das-1802hc),
-  DAS-1802AO (das-1802ao)
-Status: works
-
-The waveform analog output on the 'ao' cards is not supported.
-If you need it, send me (Frank Hess) an email.
-
-Configuration options:
-  [0] - I/O port base address
-  [1] - IRQ (optional, required for timed or externally triggered conversions)
-  [2] - DMA0 (optional, requires irq)
-  [3] - DMA1 (optional, requires irq and dma0)
-*/
-/*
+ * Comedi driver for Keithley DAS-1700/DAS-1800 series boards
+ * Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-This driver supports the following Keithley boards:
-
-das-1701st
-das-1701st-da
-das-1701ao
-das-1702st
-das-1702st-da
-das-1702hr
-das-1702hr-da
-das-1702ao
-das-1801st
-das-1801st-da
-das-1801hc
-das-1801ao
-das-1802st
-das-1802st-da
-das-1802hr
-das-1802hr-da
-das-1802hc
-das-1802ao
-
-Options:
-	[0] - base io address
-	[1] - irq (optional, required for timed or externally triggered conversions)
-	[2] - dma0 (optional, requires irq)
-	[3] - dma1 (optional, requires irq and dma0)
-
-irq can be omitted, although the cmd interface will not work without it.
-
-analog input cmd triggers supported:
-	start_src:      TRIG_NOW | TRIG_EXT
-	scan_begin_src: TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT
-	scan_end_src:   TRIG_COUNT
-	convert_src:    TRIG_TIMER | TRIG_EXT (TRIG_EXT requires scan_begin_src == TRIG_FOLLOW)
-	stop_src:       TRIG_COUNT | TRIG_EXT | TRIG_NONE
-
-scan_begin_src triggers TRIG_TIMER and TRIG_EXT use the card's
-'burst mode' which limits the valid conversion time to 64 microseconds
-(convert_arg <= 64000).  This limitation does not apply if scan_begin_src
-is TRIG_FOLLOW.
-
-NOTES:
-Only the DAS-1801ST has been tested by me.
-Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
-
-TODO:
-	Make it automatically allocate irq and dma channels if they are not specified
-	Add support for analog out on 'ao' cards
-*/
+/*
+ * Driver: das1800
+ * Description: Keithley Metrabyte DAS1800 (& compatibles)
+ * Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Devices: [Keithley Metrabyte] DAS-1701ST (das-1701st),
+ *   DAS-1701ST-DA (das-1701st-da), DAS-1701/AO (das-1701ao),
+ *   DAS-1702ST (das-1702st), DAS-1702ST-DA (das-1702st-da),
+ *   DAS-1702HR (das-1702hr), DAS-1702HR-DA (das-1702hr-da),
+ *   DAS-1702/AO (das-1702ao), DAS-1801ST (das-1801st),
+ *   DAS-1801ST-DA (das-1801st-da), DAS-1801HC (das-1801hc),
+ *   DAS-1801AO (das-1801ao), DAS-1802ST (das-1802st),
+ *   DAS-1802ST-DA (das-1802st-da), DAS-1802HR (das-1802hr),
+ *   DAS-1802HR-DA (das-1802hr-da), DAS-1802HC (das-1802hc),
+ *   DAS-1802AO (das-1802ao)
+ * Status: works
+ *
+ * Configuration options:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional, required for analog input cmd support)
+ *   [2] - DMA0 (optional, requires irq)
+ *   [3] - DMA1 (optional, requires irq and dma0)
+ *
+ * analog input cmd triggers supported:
+ *   start_src:		TRIG_NOW | TRIG_EXT
+ *   scan_begin_src:	TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT
+ *   scan_end_src:	TRIG_COUNT
+ *   convert_src:	TRIG_TIMER | TRIG_EXT
+ *			(TRIG_EXT requires scan_begin_src == TRIG_FOLLOW)
+ *   stop_src:		TRIG_COUNT | TRIG_EXT | TRIG_NONE
+ *
+ * scan_begin_src triggers TRIG_TIMER and TRIG_EXT use the card's
+ * 'burst mode' which limits the valid conversion time to 64 microseconds
+ * (convert_arg <= 64000). This limitation does not apply if scan_begin_src
+ * is TRIG_FOLLOW.
+ *
+ * NOTES:
+ * Only the DAS-1801ST has been tested by me.
+ * Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
+ *
+ * The waveform analog output on the 'ao' cards is not supported.
+ * If you need it, send me (Frank Hess) an email.
+ */
 
 #include <linux/module.h>
 #include <linux/interrupt.h>

commit 983330210fe138e1194e0b2ccca02400ae41c0be
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:53 2016 -0700

    staging: comedi: das1800: document the spinlock
    
    The comedi_device spinlock is used to protect the indirect addressing
    selected by the DAS1800_SELECT register. It also prevents races between
    the interrupt handler and the analog input (*poll).
    
    Update the comments to make this clear.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 677f430b5c3e..365a3d5231a9 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -490,8 +490,9 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
-	/*  select adc for base address + 0 */
+	/* select adc register (spinlock is already held) */
 	outb(ADC, dev->iobase + DAS1800_SELECT);
+
 	/*  dma buffer full */
 	if (devpriv->irq_dma_bits & DMA_ENABLED) {
 		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
@@ -535,9 +536,14 @@ static int das1800_ai_poll(struct comedi_device *dev,
 {
 	unsigned long flags;
 
-	/*  prevent race with interrupt handler */
+	/*
+	 * Protects the indirect addressing selected by DAS1800_SELECT
+	 * in das1800_ai_handler() also prevents race with das1800_interrupt().
+	 */
 	spin_lock_irqsave(&dev->spinlock, flags);
+
 	das1800_ai_handler(dev);
+
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return comedi_buf_n_bytes_ready(s);
@@ -553,9 +559,12 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	/* Prevent race with das1800_ai_poll() on multi processor systems.
-	 * Also protects indirect addressing in das1800_ai_handler */
+	/*
+	 * Protects the indirect addressing selected by DAS1800_SELECT
+	 * in das1800_ai_handler() also prevents race with das1800_ai_poll().
+	 */
 	spin_lock(&dev->spinlock);
+
 	status = inb(dev->iobase + DAS1800_STATUS);
 
 	/* if interrupt was not caused by das-1800 */
@@ -1289,6 +1298,7 @@ static int das1800_attach(struct comedi_device *dev,
 
 		/* initialize all channels to 0V */
 		for (i = 0; i < s->n_chan; i++) {
+			/* spinlock is not necessary during the attach */
 			outb(DAC(i), dev->iobase + DAS1800_SELECT);
 			outw(0, dev->iobase + DAS1800_DAC);
 		}

commit fb90ec01bc8364a6ae7b8436c759f7541ebfd37f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:52 2016 -0700

    staging: comedi: das1800: absorb control_a_bits()
    
    Absorb this helper function into the analog input (*do_cmd).
    For aesthetics, convert the switch code into if/else.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 4355171ad7d0..677f430b5c3e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -727,28 +727,6 @@ static int das1800_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-/* returns appropriate bits for control register a, depending on command */
-static int control_a_bits(const struct comedi_cmd *cmd)
-{
-	int control_a;
-
-	control_a = FFEN;	/* enable fifo */
-	if (cmd->stop_src == TRIG_EXT)
-		control_a |= ATEN;
-	switch (cmd->start_src) {
-	case TRIG_EXT:
-		control_a |= TGEN | CGSL;
-		break;
-	case TRIG_NOW:
-		control_a |= CGEN;
-		break;
-	default:
-		break;
-	}
-
-	return control_a;
-}
-
 static unsigned char das1800_ai_chanspec_bits(struct comedi_subdevice *s,
 					      unsigned int chanspec)
 {
@@ -885,8 +863,13 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 
 	devpriv->ai_is_unipolar = comedi_range_is_unipolar(s, range0);
 
-	/*  determine proper bits for control registers */
-	control_a = control_a_bits(cmd);
+	control_a = FFEN;
+	if (cmd->stop_src == TRIG_EXT)
+		control_a |= ATEN;
+	if (cmd->start_src == TRIG_EXT)
+		control_a |= TGEN | CGSL;
+	else /* TRIG_NOW */
+		control_a |= CGEN;
 
 	control_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);
 	/* set clock source to internal or external */

commit cfc2236bbce6f0e21e2618c02d750a5239d45352
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:51 2016 -0700

    staging: comedi: das1800: use comedi_timeout()
    
    Use the helper function to handle the busywaiting for the analog
    input conversion to complete.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2bb53dbb85f7..4355171ad7d0 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -937,6 +937,19 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static int das1800_ai_eoc(struct comedi_device *dev,
+			  struct comedi_subdevice *s,
+			  struct comedi_insn *insn,
+			  unsigned long context)
+{
+	unsigned char status;
+
+	status = inb(dev->iobase + DAS1800_STATUS);
+	if (status & FNE)
+		return 0;
+	return -EBUSY;
+}
+
 static int das1800_ai_insn_read(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -944,8 +957,8 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 {
 	unsigned int range = CR_RANGE(insn->chanspec);
 	bool is_unipolar = comedi_range_is_unipolar(s, range);
-	int i, n;
-	int timeout = 1000;
+	int ret = 0;
+	int n;
 	unsigned short dpnt;
 	unsigned long flags;
 
@@ -966,24 +979,19 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
 		outb(0, dev->iobase + DAS1800_FIFO);
-		for (i = 0; i < timeout; i++) {
-			if (inb(dev->iobase + DAS1800_STATUS) & FNE)
-				break;
-		}
-		if (i == timeout) {
-			dev_err(dev->class_dev, "timeout\n");
-			n = -ETIME;
-			goto exit;
-		}
+
+		ret = comedi_timeout(dev, s, insn, das1800_ai_eoc, 0);
+		if (ret)
+			break;
+
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
 		if (!is_unipolar)
 			dpnt = comedi_offset_munge(s, dpnt);
 		data[n] = dpnt;
 	}
-exit:
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	return n;
+	return ret ? ret : insn->n;
 }
 
 static int das1800_ao_insn_write(struct comedi_device *dev,

commit 7b1924b6fc8a9dbf602458bfba45065301fada48
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:50 2016 -0700

    staging: comedi: das1800: refactor program_chanlist()
    
    Refactor this function so it can be used to program the chanlist for
    the analog input (*do_cmd) and (*insn_read).
    
    Rename the function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0a4876ee333b..2bb53dbb85f7 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -828,30 +828,33 @@ static void das1800_ai_setup_dma(struct comedi_device *dev,
 	}
 }
 
-/* programs channel/gain list into card */
-static void program_chanlist(struct comedi_device *dev,
-			     const struct comedi_cmd *cmd)
+static void das1800_ai_set_chanlist(struct comedi_device *dev,
+				    unsigned int *chanlist, unsigned int len)
 {
-	int i, n, chan_range;
-	unsigned long irq_flags;
-	const int range_mask = 0x3;	/* masks unipolar/bipolar bit off range */
-	const int range_bitshift = 8;
-
-	n = cmd->chanlist_len;
-	/*  spinlock protects indirect addressing */
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
-	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
+	unsigned long flags;
+	unsigned int i;
+
+	/* protects the indirect addressing selected by DAS1800_SELECT */
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	/* select QRAM register and set start address */
+	outb(QRAM, dev->iobase + DAS1800_SELECT);
+	outb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);
+
 	/* make channel / gain list */
-	for (i = 0; i < n; i++) {
-		chan_range =
-		    CR_CHAN(cmd->chanlist[i]) |
-		    ((CR_RANGE(cmd->chanlist[i]) & range_mask) <<
-		     range_bitshift);
-		outw(chan_range, dev->iobase + DAS1800_QRAM);
+	for (i = 0; i < len; i++) {
+		unsigned int chan = CR_CHAN(chanlist[i]);
+		unsigned int range = CR_RANGE(chanlist[i]);
+		unsigned short val;
+
+		val = chan | ((range & 0x3) << 8);
+		outw(val, dev->iobase + DAS1800_QRAM);
 	}
-	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	/* finish write to QRAM */
+	outb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);
+
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 }
 
 static int das1800_ai_cmd(struct comedi_device *dev,
@@ -904,8 +907,7 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 		control_c |= BMDE | XPCLK;
 	}
 
-	/* setup card and start */
-	program_chanlist(dev, cmd);
+	das1800_ai_set_chanlist(dev, cmd->chanlist, cmd->chanlist_len);
 
 	/* setup cascaded counters for conversion/scan frequency */
 	if ((cmd->scan_begin_src == TRIG_FOLLOW ||
@@ -940,14 +942,12 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 				struct comedi_insn *insn,
 				unsigned int *data)
 {
-	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
 	bool is_unipolar = comedi_range_is_unipolar(s, range);
 	int i, n;
-	int chan_range;
 	int timeout = 1000;
 	unsigned short dpnt;
-	unsigned long irq_flags;
+	unsigned long flags;
 
 	outb(das1800_ai_chanspec_bits(s, insn->chanspec),
 	     dev->iobase + DAS1800_CONTROL_C);		/* software pacer */
@@ -955,13 +955,13 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* reset fifo */
 	outb(FFEN, dev->iobase + DAS1800_CONTROL_A);
 
-	chan_range = chan | ((range & 0x3) << 8);
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
-	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/* set QRAM address start */
-	outw(chan_range, dev->iobase + DAS1800_QRAM);
-	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
-	outb(ADC, dev->iobase + DAS1800_SELECT);	/* select ADC for baseAddress + 0x0 */
+	das1800_ai_set_chanlist(dev, &insn->chanspec, 1);
+
+	/* protects the indirect addressing selected by DAS1800_SELECT */
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	/* select ai fifo register */
+	outb(ADC, dev->iobase + DAS1800_SELECT);
 
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
@@ -981,7 +981,7 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 		data[n] = dpnt;
 	}
 exit:
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return n;
 }

commit ceba8220df4705e61f7a7c519e2f73e67dd05528
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:49 2016 -0700

    staging: comedi: das1800: absorb control_c_bits()
    
    Absorb this helper function into the analog input (*do_cmd).
    For aesthetics, convert the switch code into if/else.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5694bdb4cfe9..0a4876ee333b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -767,44 +767,6 @@ static unsigned char das1800_ai_chanspec_bits(struct comedi_subdevice *s,
 	return bits;
 }
 
-static int control_c_bits(struct comedi_subdevice *s,
-			  const struct comedi_cmd *cmd)
-{
-	int control_c;
-
-	control_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);
-
-	/* set clock source to internal or external */
-	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:	/*  not in burst mode */
-		switch (cmd->convert_src) {
-		case TRIG_TIMER:
-			/* trig on cascaded counters */
-			control_c |= IPCLK;
-			break;
-		case TRIG_EXT:
-			/* trig on falling edge of external trigger */
-			control_c |= XPCLK;
-			break;
-		default:
-			break;
-		}
-		break;
-	case TRIG_TIMER:
-		/*  burst mode with internal pacer clock */
-		control_c |= BMDE | IPCLK;
-		break;
-	case TRIG_EXT:
-		/*  burst mode with external trigger */
-		control_c |= BMDE | XPCLK;
-		break;
-	default:
-		break;
-	}
-
-	return control_c;
-}
-
 static unsigned int das1800_ai_transfer_size(struct comedi_device *dev,
 					     struct comedi_subdevice *s,
 					     unsigned int maxbytes,
@@ -922,7 +884,25 @@ static int das1800_ai_cmd(struct comedi_device *dev,
 
 	/*  determine proper bits for control registers */
 	control_a = control_a_bits(cmd);
-	control_c = control_c_bits(s, cmd);
+
+	control_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);
+	/* set clock source to internal or external */
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* not in burst mode */
+		if (cmd->convert_src == TRIG_TIMER) {
+			/* trig on cascaded counters */
+			control_c |= IPCLK;
+		} else { /* TRIG_EXT */
+			/* trig on falling edge of external trigger */
+			control_c |= XPCLK;
+		}
+	} else if (cmd->scan_begin_src == TRIG_TIMER) {
+		/* burst mode with internal pacer clock */
+		control_c |= BMDE | IPCLK;
+	} else { /* TRIG_EXT */
+		/* burst mode with external trigger */
+		control_c |= BMDE | XPCLK;
+	}
 
 	/* setup card and start */
 	program_chanlist(dev, cmd);

commit 843681c8835bcf4e02f993beae65e356a01d0111
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:48 2016 -0700

    staging: comedi: das1800: introduce das1800_ai_chanspec_bits()
    
    Introduce a helper function for the common code needed to set the
    control c register bits for a channel specification.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 64b5403f9a99..5694bdb4cfe9 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -749,25 +749,32 @@ static int control_a_bits(const struct comedi_cmd *cmd)
 	return control_a;
 }
 
-/* returns appropriate bits for control register c, depending on command */
-static int control_c_bits(struct comedi_subdevice *s,
-			  const struct comedi_cmd *cmd)
+static unsigned char das1800_ai_chanspec_bits(struct comedi_subdevice *s,
+					      unsigned int chanspec)
 {
-	unsigned int range = CR_RANGE(cmd->chanlist[0]);
-	unsigned int aref = CR_AREF(cmd->chanlist[0]);
-	int control_c;
+	unsigned int range = CR_RANGE(chanspec);
+	unsigned int aref = CR_AREF(chanspec);
+	unsigned char bits;
 
-	/* set clock source to internal or external, select analog reference,
-	 * select unipolar / bipolar
-	 */
-	control_c = UQEN;	/* enable upper qram addresses */
+	bits = UQEN;
 	if (aref != AREF_DIFF)
-		control_c |= SD;
+		bits |= SD;
 	if (aref == AREF_COMMON)
-		control_c |= CMEN;
+		bits |= CMEN;
 	if (comedi_range_is_unipolar(s, range))
-		control_c |= UB;
+		bits |= UB;
+
+	return bits;
+}
+
+static int control_c_bits(struct comedi_subdevice *s,
+			  const struct comedi_cmd *cmd)
+{
+	int control_c;
 
+	control_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);
+
+	/* set clock source to internal or external */
 	switch (cmd->scan_begin_src) {
 	case TRIG_FOLLOW:	/*  not in burst mode */
 		switch (cmd->convert_src) {
@@ -955,25 +962,15 @@ static int das1800_ai_insn_read(struct comedi_device *dev,
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
-	unsigned int aref = CR_AREF(insn->chanspec);
 	bool is_unipolar = comedi_range_is_unipolar(s, range);
 	int i, n;
 	int chan_range;
 	int timeout = 1000;
 	unsigned short dpnt;
-	int conv_flags = 0;
 	unsigned long irq_flags;
 
-	/* set up analog reference and unipolar / bipolar mode */
-	conv_flags |= UQEN;
-	if (aref != AREF_DIFF)
-		conv_flags |= SD;
-	if (aref == AREF_COMMON)
-		conv_flags |= CMEN;
-	if (is_unipolar)
-		conv_flags |= UB;
-
-	outb(conv_flags, dev->iobase + DAS1800_CONTROL_C);	/* software conversion enabled */
+	outb(das1800_ai_chanspec_bits(s, insn->chanspec),
+	     dev->iobase + DAS1800_CONTROL_C);		/* software pacer */
 	outb(CVEN, dev->iobase + DAS1800_STATUS);	/* enable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* reset fifo */
 	outb(FFEN, dev->iobase + DAS1800_CONTROL_A);

commit 750bca653d0efae236b07988c013485ccd0a5f22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:47 2016 -0700

    staging: comedi: das1800: add analog output readback
    
    Use the core provided readback support to allow reading back the last
    value written to the analog output channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 52a8c5b8234c..64b5403f9a99 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -91,7 +91,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 TODO:
 	Make it automatically allocate irq and dma channels if they are not specified
 	Add support for analog out on 'ao' cards
-	read insn for analog out
 */
 
 #include <linux/module.h>
@@ -341,8 +340,6 @@ struct das1800_private {
 	int dma_bits;
 	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
-	unsigned short ao_update_bits;	/* remembers the last write to the
-					 * 'update' dac */
 	bool ai_is_unipolar;
 };
 
@@ -1017,7 +1014,6 @@ static int das1800_ao_insn_write(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	struct das1800_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int update_chan = s->n_chan - 1;
 	unsigned long flags;
@@ -1029,9 +1025,9 @@ static int das1800_ao_insn_write(struct comedi_device *dev,
 	for (i = 0; i < insn->n; i++) {
 		unsigned int val = data[i];
 
+		s->readback[chan] = val;
+
 		val = comedi_offset_munge(s, val);
-		if (chan == update_chan)
-			devpriv->ao_update_bits = val;
 
 		/* load this channel (and update if it's the last channel) */
 		outb(DAC(chan), dev->iobase + DAS1800_SELECT);
@@ -1039,9 +1035,10 @@ static int das1800_ao_insn_write(struct comedi_device *dev,
 
 		/* update all channels */
 		if (chan != update_chan) {
+			val = comedi_offset_munge(s, s->readback[update_chan]);
+
 			outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);
-			outw(devpriv->ao_update_bits,
-			     dev->iobase + DAS1800_DAC);
+			outw(val, dev->iobase + DAS1800_DAC);
 		}
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -1318,6 +1315,10 @@ static int das1800_attach(struct comedi_device *dev,
 		s->range_table	= &range_bipolar10;
 		s->insn_write	= das1800_ao_insn_write;
 
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
+
 		/* initialize all channels to 0V */
 		for (i = 0; i < s->n_chan; i++) {
 			outb(DAC(i), dev->iobase + DAS1800_SELECT);

commit a5405cfa1b37ea2156abdbb589e06e29140844f4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:46 2016 -0700

    staging: comedi: das1800: change type of 'ai_speed' boardinfo
    
    This value is compared against the unsigned int cmd->convert_arg to
    check the minimum value (max speed) for the analog input conversion
    timing.
    
    For aesthetics, change the type to match the cmd->convert_arg type.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d3aca976ee4c..52a8c5b8234c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -225,7 +225,7 @@ enum das1800_boardid {
 struct das1800_board {
 	const char *name;
 	unsigned char id;
-	int ai_speed;		/* max conversion period in nanoseconds */
+	unsigned int ai_speed;
 	unsigned int is_01_series:1;
 };
 

commit ac8ebf8a8ff5b9e80b35b380ddcafd54bf6b5c8e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:45 2016 -0700

    staging: comedi: das1800: remove 'qram_len' boardinfo
    
    The "hc" type boards have 64 analog input channels with a 64
    entry queue. All the others have 16 channels and a 256 entry
    queue.
    
    EXP-1800 expansion boards can be used to increase the number
    of analog inputs on the 16 channel boards, 16 channels per
    EXP-1800, for a total of 256 channels.
    
    Remove the 'qram_len' member of the boardinfo and use the
    'id' member to determine the number of channels.
    
    Add a comment about the number of channels and the unclear
    mapping of the channels when EXP-1800 boards are used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 32807631dec6..d3aca976ee4c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -226,7 +226,6 @@ struct das1800_board {
 	const char *name;
 	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
-	int qram_len;		/* length of card's channel / gain queue */
 	unsigned int is_01_series:1;
 };
 
@@ -239,116 +238,98 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1701st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1701ST_DA] = {
 		.name		= "das-1701st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1702ST] = {
 		.name		= "das-1702st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1702ST_DA] = {
 		.name		= "das-1702st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1702HR] = {
 		.name		= "das-1702hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1702HR_DA] = {
 		.name		= "das-1702hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1701AO] = {
 		.name		= "das-1701ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1702AO] = {
 		.name		= "das-1702ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1801ST] = {
 		.name		= "das-1801st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1801ST_DA] = {
 		.name		= "das-1801st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802ST] = {
 		.name		= "das-1802st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1802ST_DA] = {
 		.name		= "das-1802st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1802HR] = {
 		.name		= "das-1802hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1802HR_DA] = {
 		.name		= "das-1802hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
-		.qram_len	= 256,
 	},
 	[BOARD_DAS1801HC] = {
 		.name		= "das-1801hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
-		.qram_len	= 64,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802HC] = {
 		.name		= "das-1802hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
-		.qram_len	= 64,
 	},
 	[BOARD_DAS1801AO] = {
 		.name		= "das-1801ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802AO] = {
 		.name		= "das-1802ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
-		.qram_len	= 256,
 	},
 };
 
@@ -1292,13 +1273,26 @@ static int das1800_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* Analog Input subdevice */
+	/*
+	 * Analog Input subdevice
+	 *
+	 * The "hc" type boards have 64 analog input channels and a 64
+	 * entry QRAM fifo.
+	 *
+	 * All the other board types have 16 on-board channels. Each channel
+	 * can be expanded to 16 channels with the addition of an EXP-1800
+	 * expansion board for a total of 256 channels. The QRAM fifo on
+	 * these boards has 256 entries.
+	 *
+	 * From the datasheets it's not clear what the comedi channel to
+	 * actual physical channel mapping is when EXP-1800 boards are used.
+	 */
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_GROUND;
 	if (board->id != DAS1800_ID_HC)
 		s->subdev_flags	|= SDF_COMMON;
-	s->n_chan	= board->qram_len;
+	s->n_chan	= (board->id == DAS1800_ID_HC) ? 64 : 256;
 	s->maxdata	= is_16bit ? 0xffff : 0x0fff;
 	s->range_table	= board->is_01_series ? &das1801_ai_range
 					      : &das1802_ai_range;

commit 5068827a7818cb54763975a34a0e59f1d1827ad8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:44 2016 -0700

    staging: comedi: das1800: refactor 'range_ai' boardinfo
    
    The boards supported by this driver have analog inputs with gains
    of 1, 10, 50, and 250 ("01" type) or 1, 2, 4, and 8 ("02" type).
    Unfortunately, the "01"/"02" type cannot be determined from the
    boards id or by probing.
    
    Replace the 'range_ai' member of the boardinfo with a bit-field flag,
    'is_01_series' and only set it for the "01" type boards. Remove the
    unnecessary initialization for the "02" type boards.
    
    For aesthetics, rename the comedi_lrange arrays and document the gain.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5d40811c28e8..32807631dec6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -167,30 +167,29 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 
 #define IOBASE2                   0x400	/* offset of additional ioports used on 'ao' cards */
 
-/* analog input ranges */
-static const struct comedi_lrange range_ai_das1801 = {
+static const struct comedi_lrange das1801_ai_range = {
 	8, {
-		BIP_RANGE(5),
-		BIP_RANGE(1),
-		BIP_RANGE(0.1),
-		BIP_RANGE(0.02),
-		UNI_RANGE(5),
-		UNI_RANGE(1),
-		UNI_RANGE(0.1),
-		UNI_RANGE(0.02)
+		BIP_RANGE(5),		/* bipolar gain = 1 */
+		BIP_RANGE(1),		/* bipolar gain = 10 */
+		BIP_RANGE(0.1),		/* bipolar gain = 50 */
+		BIP_RANGE(0.02),	/* bipolar gain = 250 */
+		UNI_RANGE(5),		/* unipolar gain = 1 */
+		UNI_RANGE(1),		/* unipolar gain = 10 */
+		UNI_RANGE(0.1),		/* unipolar gain = 50 */
+		UNI_RANGE(0.02)		/* unipolar gain = 250 */
 	}
 };
 
-static const struct comedi_lrange range_ai_das1802 = {
+static const struct comedi_lrange das1802_ai_range = {
 	8, {
-		BIP_RANGE(10),
-		BIP_RANGE(5),
-		BIP_RANGE(2.5),
-		BIP_RANGE(1.25),
-		UNI_RANGE(10),
-		UNI_RANGE(5),
-		UNI_RANGE(2.5),
-		UNI_RANGE(1.25)
+		BIP_RANGE(10),		/* bipolar gain = 1 */
+		BIP_RANGE(5),		/* bipolar gain = 2 */
+		BIP_RANGE(2.5),		/* bipolar gain = 4 */
+		BIP_RANGE(1.25),	/* bipolar gain = 8 */
+		UNI_RANGE(10),		/* unipolar gain = 1 */
+		UNI_RANGE(5),		/* unipolar gain = 2 */
+		UNI_RANGE(2.5),		/* unipolar gain = 4 */
+		UNI_RANGE(1.25)		/* unipolar gain = 8 */
 	}
 };
 
@@ -228,7 +227,7 @@ struct das1800_board {
 	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int qram_len;		/* length of card's channel / gain queue */
-	const struct comedi_lrange *range_ai;	/* available input ranges */
+	unsigned int is_01_series:1;
 };
 
 /* Warning: the maximum conversion speeds listed below are
@@ -241,126 +240,115 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1701ST_DA] = {
 		.name		= "das-1701st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1702ST] = {
 		.name		= "das-1702st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702ST_DA] = {
 		.name		= "das-1702st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR] = {
 		.name		= "das-1702hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR_DA] = {
 		.name		= "das-1702hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1701AO] = {
 		.name		= "das-1701ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1702AO] = {
 		.name		= "das-1702ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801ST] = {
 		.name		= "das-1801st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1801ST_DA] = {
 		.name		= "das-1801st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802ST] = {
 		.name		= "das-1802st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802ST_DA] = {
 		.name		= "das-1802st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR] = {
 		.name		= "das-1802hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR_DA] = {
 		.name		= "das-1802hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801HC] = {
 		.name		= "das-1801hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802HC] = {
 		.name		= "das-1802hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801AO] = {
 		.name		= "das-1801ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1801,
+		.is_01_series	= 1,
 	},
 	[BOARD_DAS1802AO] = {
 		.name		= "das-1802ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.range_ai	= &range_ai_das1802,
 	},
 };
 
@@ -1312,7 +1300,8 @@ static int das1800_attach(struct comedi_device *dev,
 		s->subdev_flags	|= SDF_COMMON;
 	s->n_chan	= board->qram_len;
 	s->maxdata	= is_16bit ? 0xffff : 0x0fff;
-	s->range_table	= board->range_ai;
+	s->range_table	= board->is_01_series ? &das1801_ai_range
+					      : &das1802_ai_range;
 	s->insn_read	= das1800_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;

commit 8114b5ecb8dc9d2b79b9cba12c4edb737da80575
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:43 2016 -0700

    staging: comedi: das1800: remove 'ao_ability' boardinfo
    
    The "da" and "hc" type boards have normal analog outputs. The
    "ao" type boards have move advanced analog outputs with waveform
    generation capability.
    
    Remove the 'ao_ability' member of the boardinfo and use the
    'id' member to determine if the subdevice should be initialized.
    
    The "ao" waveform analog outputs are not currently supported.
    For aesthetics, add an else if for the initialization of the
    subdevice for these boards.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1a9565ead83e..5d40811c28e8 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -228,7 +228,6 @@ struct das1800_board {
 	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int qram_len;		/* length of card's channel / gain queue */
-	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
 	const struct comedi_lrange *range_ai;	/* available input ranges */
 };
 
@@ -242,7 +241,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1701ST_DA] = {
@@ -250,7 +248,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1702ST] = {
@@ -258,7 +255,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702ST_DA] = {
@@ -266,7 +262,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR] = {
@@ -274,7 +269,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR_DA] = {
@@ -282,7 +276,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1701AO] = {
@@ -290,7 +283,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 2,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1702AO] = {
@@ -298,7 +290,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.ao_ability	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801ST] = {
@@ -306,7 +297,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1801ST_DA] = {
@@ -314,7 +304,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802ST] = {
@@ -322,7 +311,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802ST_DA] = {
@@ -330,7 +318,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR] = {
@@ -338,7 +325,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.ao_ability	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR_DA] = {
@@ -346,7 +332,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801HC] = {
@@ -354,7 +339,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802HC] = {
@@ -362,7 +346,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.ao_ability	= 1,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801AO] = {
@@ -370,7 +353,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 2,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802AO] = {
@@ -378,7 +360,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.ao_ability	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 };
@@ -1266,8 +1247,8 @@ static int das1800_attach(struct comedi_device *dev,
 
 	is_16bit = board->id == DAS1800_ID_HR || board->id == DAS1800_ID_HR_DA;
 
-	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
-	if (board->ao_ability == 2) {
+	/* waveform 'ao' boards have additional io ports */
+	if (board->id == DAS1800_ID_AO) {
 		unsigned long iobase2 = dev->iobase + IOBASE2;
 
 		ret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);
@@ -1346,7 +1327,7 @@ static int das1800_attach(struct comedi_device *dev,
 
 	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
-	if (board->ao_ability == 1) {
+	if (board->id == DAS1800_ID_ST_DA || board->id == DAS1800_ID_HR_DA) {
 		s->type		= COMEDI_SUBD_AO;
 		s->subdev_flags	= SDF_WRITABLE;
 		s->n_chan	= (board->id == DAS1800_ID_ST_DA) ? 4 : 2;
@@ -1359,6 +1340,12 @@ static int das1800_attach(struct comedi_device *dev,
 			outb(DAC(i), dev->iobase + DAS1800_SELECT);
 			outw(0, dev->iobase + DAS1800_DAC);
 		}
+	} else if (board->id == DAS1800_ID_AO) {
+		/*
+		 * 'ao' boards have waveform analog outputs that are not
+		 * currently supported.
+		 */
+		s->type		= COMEDI_SUBD_UNUSED;
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}

commit 1322f148983dfc91f2f011043bcdbc6de4a9df33
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:42 2016 -0700

    staging: comedi: das1800: remove 'ao_n_chan' boardinfo
    
    The "st-da" board types have 4 analog output channels. All other
    board types, with analog outputs, only have 2 channels.
    
    Remove the 'ao_n_chan' member of the boardinfo and use the
    'id' member to determine the subdevice 'n_chan'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 962a414e0544..1a9565ead83e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -229,7 +229,6 @@ struct das1800_board {
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int qram_len;		/* length of card's channel / gain queue */
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
-	int ao_n_chan;		/* number of analog out channels */
 	const struct comedi_lrange *range_ai;	/* available input ranges */
 };
 
@@ -244,7 +243,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1701ST_DA] = {
@@ -253,7 +251,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1702ST] = {
@@ -262,7 +259,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702ST_DA] = {
@@ -271,7 +267,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR] = {
@@ -280,7 +275,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 20000,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1702HR_DA] = {
@@ -289,7 +283,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 20000,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1701AO] = {
@@ -298,7 +291,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 2,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1702AO] = {
@@ -307,7 +299,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.qram_len	= 256,
 		.ao_ability	= 2,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801ST] = {
@@ -316,7 +307,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1801ST_DA] = {
@@ -325,7 +315,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802ST] = {
@@ -334,7 +323,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802ST_DA] = {
@@ -343,7 +331,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR] = {
@@ -352,7 +339,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 10000,
 		.qram_len	= 256,
 		.ao_ability	= 0,
-		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1802HR_DA] = {
@@ -361,7 +347,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 10000,
 		.qram_len	= 256,
 		.ao_ability	= 1,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801HC] = {
@@ -370,7 +355,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 64,
 		.ao_ability	= 1,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802HC] = {
@@ -379,7 +363,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 64,
 		.ao_ability	= 1,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 	[BOARD_DAS1801AO] = {
@@ -388,7 +371,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 2,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
 	},
 	[BOARD_DAS1802AO] = {
@@ -397,7 +379,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.qram_len	= 256,
 		.ao_ability	= 2,
-		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
 	},
 };
@@ -1368,7 +1349,7 @@ static int das1800_attach(struct comedi_device *dev,
 	if (board->ao_ability == 1) {
 		s->type		= COMEDI_SUBD_AO;
 		s->subdev_flags	= SDF_WRITABLE;
-		s->n_chan	= board->ao_n_chan;
+		s->n_chan	= (board->id == DAS1800_ID_ST_DA) ? 4 : 2;
 		s->maxdata	= is_16bit ? 0xffff : 0x0fff;
 		s->range_table	= &range_bipolar10;
 		s->insn_write	= das1800_ao_insn_write;

commit 4c6f738e0f15a8d7a264f49f3d4f42a458edf773
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:41 2016 -0700

    staging: comedi: das1800: tidy up das1800_ao_insn_write()
    
    The (*insn_write) functions are supposed to write insn->n values to the
    specified channel. Tidy up this function and make it work like the core
    expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 45d72013917c..962a414e0544 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1086,30 +1086,36 @@ static int das1800_ao_insn_write(struct comedi_device *dev,
 				 struct comedi_insn *insn,
 				 unsigned int *data)
 {
-	const struct das1800_board *board = dev->board_ptr;
 	struct das1800_private *devpriv = dev->private;
-	int chan = CR_CHAN(insn->chanspec);
-/* int range = CR_RANGE(insn->chanspec); */
-	int update_chan = board->ao_n_chan - 1;
-	unsigned short output;
-	unsigned long irq_flags;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int update_chan = s->n_chan - 1;
+	unsigned long flags;
+	int i;
 
-	output = comedi_offset_munge(s, data[0]);
-	/*  if the write is to the 'update' channel, we need to remember its value */
-	if (chan == update_chan)
-		devpriv->ao_update_bits = output;
-	/*  write to channel */
-	spin_lock_irqsave(&dev->spinlock, irq_flags);
-	outb(DAC(chan), dev->iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
-	outw(output, dev->iobase + DAS1800_DAC);
-	/*  now we need to write to 'update' channel to update all dac channels */
-	if (chan != update_chan) {
-		outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
-		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
+	/* protects the indirect addressing selected by DAS1800_SELECT */
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	for (i = 0; i < insn->n; i++) {
+		unsigned int val = data[i];
+
+		val = comedi_offset_munge(s, val);
+		if (chan == update_chan)
+			devpriv->ao_update_bits = val;
+
+		/* load this channel (and update if it's the last channel) */
+		outb(DAC(chan), dev->iobase + DAS1800_SELECT);
+		outw(val, dev->iobase + DAS1800_DAC);
+
+		/* update all channels */
+		if (chan != update_chan) {
+			outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);
+			outw(devpriv->ao_update_bits,
+			     dev->iobase + DAS1800_DAC);
+		}
 	}
-	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	return 1;
+	return insn->n;
 }
 
 static int das1800_di_insn_bits(struct comedi_device *dev,

commit 605b670e9b0ca1036dee636701af0dd220927e67
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:40 2016 -0700

    staging: comedi: das1800: initialize all analog outputs
    
    The current code used to initialize the analog outputs only sets the
    last channel. The other channels will be reloaded with the last value
    that was written to them.
    
    Move the code into the subdevice init and properly initialize all the
    channels to 0V.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6641f2ed3fe6..45d72013917c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1262,6 +1262,7 @@ static int das1800_attach(struct comedi_device *dev,
 	unsigned int irq = it->options[1];
 	bool is_16bit;
 	int ret;
+	int i;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1365,6 +1366,12 @@ static int das1800_attach(struct comedi_device *dev,
 		s->maxdata	= is_16bit ? 0xffff : 0x0fff;
 		s->range_table	= &range_bipolar10;
 		s->insn_write	= das1800_ao_insn_write;
+
+		/* initialize all channels to 0V */
+		for (i = 0; i < s->n_chan; i++) {
+			outb(DAC(i), dev->iobase + DAS1800_SELECT);
+			outw(0, dev->iobase + DAS1800_DAC);
+		}
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}
@@ -1392,14 +1399,6 @@ static int das1800_attach(struct comedi_device *dev,
 	/*  initialize digital out channels */
 	outb(0, dev->iobase + DAS1800_DIGITAL);
 
-	/*  initialize analog out channels */
-	if (board->ao_ability == 1) {
-		/*  select 'update' dac channel for baseAddress + 0x0 */
-		outb(DAC(board->ao_n_chan - 1),
-		     dev->iobase + DAS1800_SELECT);
-		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
-	}
-
 	return 0;
 };
 

commit bc524200ed26d173c78be46e4753c6f7754dc84e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:39 2016 -0700

    staging: comedi: das1800: remove 'do_n_chan' boardinfo
    
    The "hc" type boards have 8 digtial outputs. All other board
    types have 4.
    
    Remove the 'do_n_chan' member of the boardinfo and use the
    'id' member to determine the subdevice 'n_chan'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 43e621b8689c..6641f2ed3fe6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -228,7 +228,6 @@ struct das1800_board {
 	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int qram_len;		/* length of card's channel / gain queue */
-	int do_n_chan;		/* number of digital output channels */
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
 	int ao_n_chan;		/* number of analog out channels */
 	const struct comedi_lrange *range_ai;	/* available input ranges */
@@ -244,7 +243,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
@@ -254,7 +252,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
@@ -264,7 +261,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
@@ -274,7 +270,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
@@ -284,7 +279,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
@@ -294,7 +288,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
@@ -304,7 +297,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
@@ -314,7 +306,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
@@ -324,7 +315,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
@@ -334,7 +324,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
@@ -344,7 +333,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
@@ -354,7 +342,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
@@ -364,7 +351,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
@@ -374,7 +360,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
@@ -384,7 +369,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.do_n_chan	= 8,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
@@ -394,7 +378,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.qram_len	= 64,
-		.do_n_chan	= 8,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
@@ -404,7 +387,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
@@ -414,7 +396,6 @@ static const struct das1800_board das1800_boards[] = {
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.qram_len	= 256,
-		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
@@ -1401,7 +1382,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s = &dev->subdevices[3];
 	s->type		= COMEDI_SUBD_DO;
 	s->subdev_flags	= SDF_WRITABLE;
-	s->n_chan	= board->do_n_chan;
+	s->n_chan	= (board->id == DAS1800_ID_HC) ? 8 : 4;
 	s->maxdata	= 1;
 	s->range_table	= &range_digital;
 	s->insn_bits	= das1800_do_insn_bits;

commit dad1e30fde3c4c9c9f8f24afa5a5c3404d19213f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:38 2016 -0700

    staging: comedi: das1800: remove 'resolution' boardinfo
    
    The "hr" type boards have 16-bit analog inputs and outputs.
    All other board types have 12-bit.
    
    Remove the 'resolution' member of the boardinfo and use the
    'id' member to determine the subdevices 'maxdata'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f870824ecf19..43e621b8689c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -227,7 +227,6 @@ struct das1800_board {
 	const char *name;
 	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
-	int resolution;		/* bits of ai resolution */
 	int qram_len;		/* length of card's channel / gain queue */
 	int do_n_chan;		/* number of digital output channels */
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
@@ -244,7 +243,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1701st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -255,7 +253,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1701st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -266,7 +263,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1702st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -277,7 +273,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1702st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -288,7 +283,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1702hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
-		.resolution	= 16,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -299,7 +293,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1702hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
-		.resolution	= 16,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -310,7 +303,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1701ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
@@ -321,7 +313,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1702ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
@@ -332,7 +323,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1801st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -343,7 +333,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1801st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -354,7 +343,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802st",
 		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -365,7 +353,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802st-da",
 		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -376,7 +363,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802hr",
 		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
-		.resolution	= 16,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
@@ -387,7 +373,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802hr-da",
 		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
-		.resolution	= 16,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
@@ -398,7 +383,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1801hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 64,
 		.do_n_chan	= 8,
 		.ao_ability	= 1,
@@ -409,7 +393,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802hc",
 		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 64,
 		.do_n_chan	= 8,
 		.ao_ability	= 1,
@@ -420,7 +403,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1801ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
@@ -431,7 +413,6 @@ static const struct das1800_board das1800_boards[] = {
 		.name		= "das-1802ao",
 		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
-		.resolution	= 12,
 		.qram_len	= 256,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
@@ -1298,6 +1279,7 @@ static int das1800_attach(struct comedi_device *dev,
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
+	bool is_16bit;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -1313,6 +1295,8 @@ static int das1800_attach(struct comedi_device *dev,
 		return ret;
 	board = dev->board_ptr;
 
+	is_16bit = board->id == DAS1800_ID_HR || board->id == DAS1800_ID_HR_DA;
+
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (board->ao_ability == 2) {
 		unsigned long iobase2 = dev->iobase + IOBASE2;
@@ -1377,7 +1361,7 @@ static int das1800_attach(struct comedi_device *dev,
 	if (board->id != DAS1800_ID_HC)
 		s->subdev_flags	|= SDF_COMMON;
 	s->n_chan	= board->qram_len;
-	s->maxdata	= (1 << board->resolution) - 1;
+	s->maxdata	= is_16bit ? 0xffff : 0x0fff;
 	s->range_table	= board->range_ai;
 	s->insn_read	= das1800_ai_insn_read;
 	if (dev->irq) {
@@ -1397,7 +1381,7 @@ static int das1800_attach(struct comedi_device *dev,
 		s->type		= COMEDI_SUBD_AO;
 		s->subdev_flags	= SDF_WRITABLE;
 		s->n_chan	= board->ao_n_chan;
-		s->maxdata	= (1 << board->resolution) - 1;
+		s->maxdata	= is_16bit ? 0xffff : 0x0fff;
 		s->range_table	= &range_bipolar10;
 		s->insn_write	= das1800_ao_insn_write;
 	} else {

commit 90f39b9f996a6de8da850a71502ab2bef24cfe9b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:37 2016 -0700

    staging: comedi: das1800: use comedi_offset_munge() for analog output
    
    The analog outputs expect 2's complement data. For aesthetics, use
    the helper function to handle the munging instead of depending on
    the boardinfo 'resolution'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6795f3e03d1a..f870824ecf19 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1132,8 +1132,7 @@ static int das1800_ao_insn_write(struct comedi_device *dev,
 	unsigned short output;
 	unsigned long irq_flags;
 
-	/*   card expects two's complement data */
-	output = data[0] - (1 << (board->resolution - 1));
+	output = comedi_offset_munge(s, data[0]);
 	/*  if the write is to the 'update' channel, we need to remember its value */
 	if (chan == update_chan)
 		devpriv->ao_update_bits = output;

commit 7a9254962bf3b636a3c04da69e94bc00da7d5935
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:36 2016 -0700

    staging: comedi: das1800: remove 'common' boardinfo member
    
    The "hc" type boards do not support common mode analog inputs
    all the other board types do.
    
    Remove the unnecessary member from the boardinfo and use the
    'id' member to determine if the SDF_COMMON flag should be set
    for the subdevice.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e24d0c9ca13a..6795f3e03d1a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -229,7 +229,6 @@ struct das1800_board {
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int resolution;		/* bits of ai resolution */
 	int qram_len;		/* length of card's channel / gain queue */
-	int common;		/* supports AREF_COMMON flag */
 	int do_n_chan;		/* number of digital output channels */
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
 	int ao_n_chan;		/* number of analog out channels */
@@ -247,7 +246,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -259,7 +257,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
@@ -271,7 +268,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -283,7 +279,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
@@ -295,7 +290,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 20000,
 		.resolution	= 16,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -307,7 +301,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 20000,
 		.resolution	= 16,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
@@ -319,7 +312,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
@@ -331,7 +323,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
@@ -343,7 +334,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -355,7 +345,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
@@ -367,7 +356,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -379,7 +367,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
@@ -391,7 +378,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 10000,
 		.resolution	= 16,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
@@ -403,7 +389,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 10000,
 		.resolution	= 16,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
@@ -415,7 +400,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 64,
-		.common		= 0,
 		.do_n_chan	= 8,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
@@ -427,7 +411,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 64,
-		.common		= 0,
 		.do_n_chan	= 8,
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
@@ -439,7 +422,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
@@ -451,7 +433,6 @@ static const struct das1800_board das1800_boards[] = {
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
-		.common		= 1,
 		.do_n_chan	= 4,
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
@@ -1394,7 +1375,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_GROUND;
-	if (board->common)
+	if (board->id != DAS1800_ID_HC)
 		s->subdev_flags	|= SDF_COMMON;
 	s->n_chan	= board->qram_len;
 	s->maxdata	= (1 << board->resolution) - 1;

commit fa33428fe00743dd11965f6276a994f3088f551d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:35 2016 -0700

    staging: comedi: das1800: tidy up das1800_probe()
    
    Refactor das1800_probe() to return an errno instead of the boardinfo
    pointer.
    
    Add the board 'id' to the boardinfo to tidy up this function to clarify
    the sanity check when the user provided a board name when trying to
    attach to the driver.
    
    Currently when this function probes for a boardinfo based on the board
    id it returns the wrong boardinfo for the "st-da" and "hr-da" types.
    This causes the analog input subdevice for those boards to not be
    available. Fix the probe so that a proper boardinfo is used.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index aba8021afdb0..e24d0c9ca13a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -167,13 +167,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 
 #define IOBASE2                   0x400	/* offset of additional ioports used on 'ao' cards */
 
-enum {
-	das1701st, das1701st_da, das1702st, das1702st_da, das1702hr,
-	das1702hr_da,
-	das1701ao, das1702ao, das1801st, das1801st_da, das1802st, das1802st_da,
-	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
-};
-
 /* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {
 	8, {
@@ -201,8 +194,38 @@ static const struct comedi_lrange range_ai_das1802 = {
 	}
 };
 
+enum das1800_boardid {
+	BOARD_DAS1701ST,
+	BOARD_DAS1701ST_DA,
+	BOARD_DAS1702ST,
+	BOARD_DAS1702ST_DA,
+	BOARD_DAS1702HR,
+	BOARD_DAS1702HR_DA,
+	BOARD_DAS1701AO,
+	BOARD_DAS1702AO,
+	BOARD_DAS1801ST,
+	BOARD_DAS1801ST_DA,
+	BOARD_DAS1802ST,
+	BOARD_DAS1802ST_DA,
+	BOARD_DAS1802HR,
+	BOARD_DAS1802HR_DA,
+	BOARD_DAS1801HC,
+	BOARD_DAS1802HC,
+	BOARD_DAS1801AO,
+	BOARD_DAS1802AO
+};
+
+/* board probe id values (hi byte of the digital input register) */
+#define DAS1800_ID_ST_DA		0x3
+#define DAS1800_ID_HR_DA		0x4
+#define DAS1800_ID_AO			0x5
+#define DAS1800_ID_HR			0x6
+#define DAS1800_ID_ST			0x7
+#define DAS1800_ID_HC			0x8
+
 struct das1800_board {
 	const char *name;
+	unsigned char id;
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int resolution;		/* bits of ai resolution */
 	int qram_len;		/* length of card's channel / gain queue */
@@ -218,8 +241,9 @@ struct das1800_board {
  * user manual.)
  */
 static const struct das1800_board das1800_boards[] = {
-	{
+	[BOARD_DAS1701ST] = {
 		.name		= "das-1701st",
+		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -228,8 +252,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1701ST_DA] = {
 		.name		= "das-1701st-da",
+		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -238,8 +264,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1702ST] = {
 		.name		= "das-1702st",
+		.id		= DAS1800_ID_ST,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -248,8 +276,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1702ST_DA] = {
 		.name		= "das-1702st-da",
+		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -258,8 +288,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1702HR] = {
 		.name		= "das-1702hr",
+		.id		= DAS1800_ID_HR,
 		.ai_speed	= 20000,
 		.resolution	= 16,
 		.qram_len	= 256,
@@ -268,8 +300,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1702HR_DA] = {
 		.name		= "das-1702hr-da",
+		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 20000,
 		.resolution	= 16,
 		.qram_len	= 256,
@@ -278,8 +312,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1701AO] = {
 		.name		= "das-1701ao",
+		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -288,8 +324,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1702AO] = {
 		.name		= "das-1702ao",
+		.id		= DAS1800_ID_AO,
 		.ai_speed	= 6250,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -298,8 +336,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1801ST] = {
 		.name		= "das-1801st",
+		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -308,8 +348,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1801ST_DA] = {
 		.name		= "das-1801st-da",
+		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -318,8 +360,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1802ST] = {
 		.name		= "das-1802st",
+		.id		= DAS1800_ID_ST,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -328,8 +372,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1802ST_DA] = {
 		.name		= "das-1802st-da",
+		.id		= DAS1800_ID_ST_DA,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -338,8 +384,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 4,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1802HR] = {
 		.name		= "das-1802hr",
+		.id		= DAS1800_ID_HR,
 		.ai_speed	= 10000,
 		.resolution	= 16,
 		.qram_len	= 256,
@@ -348,8 +396,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 0,
 		.ao_n_chan	= 0,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1802HR_DA] = {
 		.name		= "das-1802hr-da",
+		.id		= DAS1800_ID_HR_DA,
 		.ai_speed	= 10000,
 		.resolution	= 16,
 		.qram_len	= 256,
@@ -358,8 +408,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1801HC] = {
 		.name		= "das-1801hc",
+		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 64,
@@ -368,8 +420,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1802HC] = {
 		.name		= "das-1802hc",
+		.id		= DAS1800_ID_HC,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 64,
@@ -378,8 +432,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 1,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1802,
-	}, {
+	},
+	[BOARD_DAS1801AO] = {
 		.name		= "das-1801ao",
+		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -388,8 +444,10 @@ static const struct das1800_board das1800_boards[] = {
 		.ao_ability	= 2,
 		.ao_n_chan	= 2,
 		.range_ai	= &range_ai_das1801,
-	}, {
+	},
+	[BOARD_DAS1802AO] = {
 		.name		= "das-1802ao",
+		.id		= DAS1800_ID_AO,
 		.ai_speed	= 3000,
 		.resolution	= 12,
 		.qram_len	= 256,
@@ -1189,68 +1247,68 @@ static void das1800_free_dma(struct comedi_device *dev)
 		comedi_isadma_free(devpriv->dma);
 }
 
-static const struct das1800_board *das1800_probe(struct comedi_device *dev)
+static int das1800_probe(struct comedi_device *dev)
 {
 	const struct das1800_board *board = dev->board_ptr;
-	int index = board ? board - das1800_boards : -EINVAL;
-	int id;
+	unsigned char id;
+
+	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;
 
 	/*
 	 * The dev->board_ptr will be set by comedi_device_attach() if the
 	 * board name provided by the user matches a board->name in this
 	 * driver. If so, this function sanity checks the id to verify that
 	 * the board is correct.
-	 *
-	 * If the dev->board_ptr is not set, the user is trying to attach
-	 * an unspecified board to this driver. In this case the id is used
-	 * to 'probe' for the correct dev->board_ptr.
 	 */
-	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;
+	if (board) {
+		if (board->id == id)
+			return 0;
+		dev_err(dev->class_dev,
+			"probed id does not match board id (0x%x != 0x%x)\n",
+			id, board->id);
+		return -ENODEV;
+	}
+
+	 /*
+	  * If the dev->board_ptr is not set, the user is trying to attach
+	  * an unspecified board to this driver. In this case the id is used
+	  * to 'probe' for the dev->board_ptr.
+	  */
 	switch (id) {
-	case 0x3:
-		if (index == das1801st_da || index == das1802st_da ||
-		    index == das1701st_da || index == das1702st_da)
-			return board;
-		index = das1801st;
+	case DAS1800_ID_ST_DA:
+		/* das-1701st-da, das-1702st-da, das-1801st-da, das-1802st-da */
+		board = &das1800_boards[BOARD_DAS1801ST_DA];
 		break;
-	case 0x4:
-		if (index == das1802hr_da || index == das1702hr_da)
-			return board;
-		index = das1802hr;
+	case DAS1800_ID_HR_DA:
+		/* das-1702hr-da, das-1802hr-da */
+		board = &das1800_boards[BOARD_DAS1802HR_DA];
 		break;
-	case 0x5:
-		if (index == das1801ao || index == das1802ao ||
-		    index == das1701ao || index == das1702ao)
-			return board;
-		index = das1801ao;
+	case DAS1800_ID_AO:
+		/* das-1701ao, das-1702ao, das-1801ao, das-1802ao */
+		board = &das1800_boards[BOARD_DAS1801AO];
 		break;
-	case 0x6:
-		if (index == das1802hr || index == das1702hr)
-			return board;
-		index = das1802hr;
+	case DAS1800_ID_HR:
+		/*  das-1702hr, das-1802hr */
+		board = &das1800_boards[BOARD_DAS1802HR];
 		break;
-	case 0x7:
-		if (index == das1801st || index == das1802st ||
-		    index == das1701st || index == das1702st)
-			return board;
-		index = das1801st;
+	case DAS1800_ID_ST:
+		/* das-1701st, das-1702st, das-1801st, das-1802st */
+		board = &das1800_boards[BOARD_DAS1801ST];
 		break;
-	case 0x8:
-		if (index == das1801hc || index == das1802hc)
-			return board;
-		index = das1801hc;
+	case DAS1800_ID_HC:
+		/* das-1801hc, das-1802hc */
+		board = &das1800_boards[BOARD_DAS1801HC];
 		break;
 	default:
-		dev_err(dev->class_dev,
-			"Board model: probe returned 0x%x (unknown, please report)\n",
-			id);
-		return NULL;
+		dev_err(dev->class_dev, "invalid probe id 0x%x\n", id);
+		return -ENODEV;
 	}
-	dev_err(dev->class_dev,
-		"Board model (probed, not recommended): %s series\n",
-		das1800_boards[index].name);
-
-	return &das1800_boards[index];
+	dev->board_ptr = board;
+	dev->board_name = board->name;
+	dev_warn(dev->class_dev,
+		 "probed id 0x%0x: %s series (not recommended)\n",
+		 id, board->name);
+	return 0;
 }
 
 static int das1800_attach(struct comedi_device *dev,
@@ -1270,13 +1328,10 @@ static int das1800_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	board = das1800_probe(dev);
-	if (!board) {
-		dev_err(dev->class_dev, "unable to determine board type\n");
-		return -ENODEV;
-	}
-	dev->board_ptr = board;
-	dev->board_name = board->name;
+	ret = das1800_probe(dev);
+	if (ret)
+		return ret;
+	board = dev->board_ptr;
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (board->ao_ability == 2) {

commit 1e436ce3ffc26230f3e422eed8db557ba7471a07
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:34 2016 -0700

    staging: comedi: das1800: tidy up boardinfo
    
    For aesthetics, add some whitespace to the boardinfo array.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index fc8c0f92818e..aba8021afdb0 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -219,203 +219,186 @@ struct das1800_board {
  */
 static const struct das1800_board das1800_boards[] = {
 	{
-	 .name = "das-1701st",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1701st-da",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 4,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1702st",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1702st-da",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 4,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1702hr",
-	 .ai_speed = 20000,
-	 .resolution = 16,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1702hr-da",
-	 .ai_speed = 20000,
-	 .resolution = 16,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1701ao",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 2,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1702ao",
-	 .ai_speed = 6250,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 2,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1801st",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1801st-da",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 4,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1802st",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1802st-da",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 4,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1802hr",
-	 .ai_speed = 10000,
-	 .resolution = 16,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 0,
-	 .ao_n_chan = 0,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1802hr-da",
-	 .ai_speed = 10000,
-	 .resolution = 16,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 1,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1801hc",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 64,
-	 .common = 0,
-	 .do_n_chan = 8,
-	 .ao_ability = 1,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1802hc",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 64,
-	 .common = 0,
-	 .do_n_chan = 8,
-	 .ao_ability = 1,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1802,
-	 },
-	{
-	 .name = "das-1801ao",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 2,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1801,
-	 },
-	{
-	 .name = "das-1802ao",
-	 .ai_speed = 3000,
-	 .resolution = 12,
-	 .qram_len = 256,
-	 .common = 1,
-	 .do_n_chan = 4,
-	 .ao_ability = 2,
-	 .ao_n_chan = 2,
-	 .range_ai = &range_ai_das1802,
-	 },
+		.name		= "das-1701st",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1701st-da",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 4,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1702st",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1702st-da",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 4,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1702hr",
+		.ai_speed	= 20000,
+		.resolution	= 16,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1702hr-da",
+		.ai_speed	= 20000,
+		.resolution	= 16,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1701ao",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 2,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1702ao",
+		.ai_speed	= 6250,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 2,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1801st",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1801st-da",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 4,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1802st",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1802st-da",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 4,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1802hr",
+		.ai_speed	= 10000,
+		.resolution	= 16,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 0,
+		.ao_n_chan	= 0,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1802hr-da",
+		.ai_speed	= 10000,
+		.resolution	= 16,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 1,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1801hc",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 64,
+		.common		= 0,
+		.do_n_chan	= 8,
+		.ao_ability	= 1,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1802hc",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 64,
+		.common		= 0,
+		.do_n_chan	= 8,
+		.ao_ability	= 1,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1802,
+	}, {
+		.name		= "das-1801ao",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 2,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1801,
+	}, {
+		.name		= "das-1802ao",
+		.ai_speed	= 3000,
+		.resolution	= 12,
+		.qram_len	= 256,
+		.common		= 1,
+		.do_n_chan	= 4,
+		.ao_ability	= 2,
+		.ao_n_chan	= 2,
+		.range_ai	= &range_ai_das1802,
+	},
 };
 
 struct das1800_private {

commit 768417450edf0592c032895854a6bf0ce37263c7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:33 2016 -0700

    staging: comedi: das1800: tidy up analog input subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and rename
    the subdevice support functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 7f7b1d02c199..fc8c0f92818e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -545,7 +545,8 @@ static void das1800_handle_dma(struct comedi_device *dev,
 	}
 }
 
-static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das1800_ai_cancel(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
@@ -709,10 +710,9 @@ static int das1800_ai_check_chanlist(struct comedi_device *dev,
 	return 0;
 }
 
-/* test analog input cmd */
-static int das1800_ai_do_cmdtest(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_cmd *cmd)
+static int das1800_ai_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd)
 {
 	const struct das1800_board *board = dev->board_ptr;
 	int err = 0;
@@ -973,9 +973,8 @@ static void program_chanlist(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 }
 
-/* analog input do_cmd */
-static int das1800_ai_do_cmd(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
+static int das1800_ai_cmd(struct comedi_device *dev,
+			  struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
 	int control_a, control_c;
@@ -998,7 +997,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 		devpriv->irq_dma_bits |= FIMD;
 	}
 
-	das1800_cancel(dev, s);
+	das1800_ai_cancel(dev, s);
 
 	devpriv->ai_is_unipolar = comedi_range_is_unipolar(s, range0);
 
@@ -1037,10 +1036,10 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	return 0;
 }
 
-/* read analog input */
-static int das1800_ai_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int das1800_ai_insn_read(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
@@ -1353,25 +1352,25 @@ static int das1800_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/* analog input subdevice */
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_DIFF | SDF_GROUND;
 	if (board->common)
-		s->subdev_flags |= SDF_COMMON;
-	s->n_chan = board->qram_len;
-	s->maxdata = (1 << board->resolution) - 1;
-	s->range_table = board->range_ai;
-	s->insn_read = das1800_ai_rinsn;
+		s->subdev_flags	|= SDF_COMMON;
+	s->n_chan	= board->qram_len;
+	s->maxdata	= (1 << board->resolution) - 1;
+	s->range_table	= board->range_ai;
+	s->insn_read	= das1800_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->subdev_flags |= SDF_CMD_READ;
-		s->len_chanlist = s->n_chan;
-		s->do_cmd = das1800_ai_do_cmd;
-		s->do_cmdtest = das1800_ai_do_cmdtest;
-		s->poll = das1800_ai_poll;
-		s->cancel = das1800_cancel;
-		s->munge = das1800_ai_munge;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->do_cmd	= das1800_ai_cmd;
+		s->do_cmdtest	= das1800_ai_cmdtest;
+		s->poll		= das1800_ai_poll;
+		s->cancel	= das1800_ai_cancel;
+		s->munge	= das1800_ai_munge;
 	}
 
 	/* Analog Output subdevice */
@@ -1405,7 +1404,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s->range_table	= &range_digital;
 	s->insn_bits	= das1800_do_insn_bits;
 
-	das1800_cancel(dev, dev->read_subdev);
+	das1800_ai_cancel(dev, dev->read_subdev);
 
 	/*  initialize digital out channels */
 	outb(0, dev->iobase + DAS1800_DIGITAL);

commit f4c96e0120cf8fe75ce2706eb8de8dc1e9fd17ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:32 2016 -0700

    staging: comedi: das1800: tidy up analog output subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and rename
    the (*insn_write) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 93a9d1f9a120..7f7b1d02c199 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1098,10 +1098,10 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-/* writes to an analog output channel */
-static int das1800_ao_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int das1800_ao_insn_write(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
 {
 	const struct das1800_board *board = dev->board_ptr;
 	struct das1800_private *devpriv = dev->private;
@@ -1374,17 +1374,17 @@ static int das1800_attach(struct comedi_device *dev,
 		s->munge = das1800_ai_munge;
 	}
 
-	/* analog out */
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
 	if (board->ao_ability == 1) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = board->ao_n_chan;
-		s->maxdata = (1 << board->resolution) - 1;
-		s->range_table = &range_bipolar10;
-		s->insn_write = das1800_ao_winsn;
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE;
+		s->n_chan	= board->ao_n_chan;
+		s->maxdata	= (1 << board->resolution) - 1;
+		s->range_table	= &range_bipolar10;
+		s->insn_write	= das1800_ao_insn_write;
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* Digital Input subdevice */

commit 92a3b54bd20eb15b5b7c6b70ba3423776ebcd2f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:31 2016 -0700

    staging: comedi: das1800: tidy up digital input subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and rename
    the (*insn_bits) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e7787ae3fb27..93a9d1f9a120 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1130,10 +1130,10 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 	return 1;
 }
 
-/* reads from digital input channels */
-static int das1800_di_rbits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int das1800_di_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
 	data[0] = 0;
@@ -1387,14 +1387,14 @@ static int das1800_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	/* di */
+	/* Digital Input subdevice */
 	s = &dev->subdevices[2];
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das1800_di_rbits;
+	s->type		= COMEDI_SUBD_DI;
+	s->subdev_flags	= SDF_READABLE;
+	s->n_chan	= 4;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das1800_di_insn_bits;
 
 	/* Digital Output subdevice */
 	s = &dev->subdevices[3];

commit 5934ff9e7b5d584bf54cc47caab174f11364a45a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 12:41:30 2016 -0700

    staging: comedi: das1800: tidy up digital output subdevice init
    
    For aesthetics, add some whitespace to the subdevice init and rename
    the (*insn_bits) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 24b33a450c5f..e7787ae3fb27 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1141,10 +1141,10 @@ static int das1800_di_rbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das1800_do_wbits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn,
-			    unsigned int *data)
+static int das1800_do_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	if (comedi_dio_update_state(s, data))
 		outb(s->state, dev->iobase + DAS1800_DIGITAL);
@@ -1396,14 +1396,14 @@ static int das1800_attach(struct comedi_device *dev,
 	s->range_table = &range_digital;
 	s->insn_bits = das1800_di_rbits;
 
-	/* do */
+	/* Digital Output subdevice */
 	s = &dev->subdevices[3];
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = board->do_n_chan;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das1800_do_wbits;
+	s->type		= COMEDI_SUBD_DO;
+	s->subdev_flags	= SDF_WRITABLE;
+	s->n_chan	= board->do_n_chan;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= das1800_do_insn_bits;
 
 	das1800_cancel(dev, dev->read_subdev);
 

commit 30539a115564ab0fda5e9e2af469273bf4b9236a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 10:15:00 2016 -0700

    staging: comedi: das1800: fix das-1801st-da boardinfo
    
    The "da" type boards all have 4 analog outputs. Fix the boardinfo
    for the das-1801st-da.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index ea54ed8f2436..24b33a450c5f 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -324,7 +324,7 @@ static const struct das1800_board das1800_boards[] = {
 	 .qram_len = 256,
 	 .common = 1,
 	 .do_n_chan = 4,
-	 .ao_ability = 0,
+	 .ao_ability = 1,
 	 .ao_n_chan = 4,
 	 .range_ai = &range_ai_das1801,
 	 },

commit afd055838cfb6f387e8b6d1f884a7ff529524e06
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 10:14:59 2016 -0700

    staging: comedi: das1800: fix analog input sample munging
    
    The analog input samples are 2's complement when the inputs are configured
    for bipolar ranges and offset binary when they are unipolar ranges. For
    bipolar ranges the sample needs to be munged to the offset binary format
    that comedi uses.
    
    The (*insn_read) does the munging correctly but the async command support
    incorrectly munges the data for both bipolar and unipolar ranges when
    reading the remaining samples from the fifo in das1800_handle_fifo_not_empty().
    
    Add a (*munge) function to the analog input subdevice so that the samples
    are correctly munged when they are added to the async buffer by
    comedi_buf_write_samples(). Add a flag to the private data and set it in
    the (*do_cmd) so that the munging is only done for bipolar ranges.
    
    Clarify the code by using the core helper functions to check the range and
    do the munging.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3be10963f98b..ea54ed8f2436 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -107,7 +107,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 /* misc. defines */
 #define DAS1800_SIZE           16	/* uses 16 io addresses */
 #define FIFO_SIZE              1024	/*  1024 sample fifo */
-#define UNIPOLAR               0x4	/*  bit that determines whether input range is uni/bipolar */
 #define DMA_BUF_SIZE           0x1ff00	/*  size in bytes of dma buffers */
 
 /* Registers for the das1800 */
@@ -429,6 +428,7 @@ struct das1800_private {
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	unsigned short ao_update_bits;	/* remembers the last write to the
 					 * 'update' dac */
+	bool ai_is_unipolar;
 };
 
 /* analog out range for 'ao' boards */
@@ -441,29 +441,21 @@ static const struct comedi_lrange range_ao_2 = {
 };
 */
 
-static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
-					    uint16_t sample)
-{
-	const struct das1800_board *board = dev->board_ptr;
-
-	sample += 1 << (board->resolution - 1);
-	return sample;
-}
-
-static void munge_data(struct comedi_device *dev, uint16_t *array,
-		       unsigned int num_elements)
+static void das1800_ai_munge(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     void *data, unsigned int num_bytes,
+			     unsigned int start_chan_index)
 {
+	struct das1800_private *devpriv = dev->private;
+	unsigned short *array = data;
+	unsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);
 	unsigned int i;
-	int unipolar;
 
-	/* see if card is using a unipolar or bipolar range so we can munge data correctly */
-	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
+	if (devpriv->ai_is_unipolar)
+		return;
 
-	/* convert to unsigned type if we are in a bipolar mode */
-	if (!unipolar) {
-		for (i = 0; i < num_elements; i++)
-			array[i] = munge_bipolar_sample(dev, array[i]);
-	}
+	for (i = 0; i < num_samples; i++)
+		array[i] = comedi_offset_munge(s, array[i]);
 }
 
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
@@ -473,7 +465,6 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 	unsigned int nsamples = comedi_nsamples_left(s, FIFO_SIZE / 2);
 
 	insw(dev->iobase + DAS1800_FIFO, devpriv->fifo_buf, nsamples);
-	munge_data(dev, devpriv->fifo_buf, nsamples);
 	comedi_buf_write_samples(s, devpriv->fifo_buf, nsamples);
 }
 
@@ -482,14 +473,9 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short dpnt;
-	int unipolar;
-
-	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
 
 	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
-		/* convert to unsigned type */
-		dpnt = munge_bipolar_sample(dev, dpnt);
 		comedi_buf_write_samples(s, &dpnt, 1);
 
 		if (cmd->stop_src == TRIG_COUNT &&
@@ -511,7 +497,6 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 	nsamples = comedi_nsamples_left(s, nsamples);
 
-	munge_data(dev, desc->virt_addr, nsamples);
 	comedi_buf_write_samples(s, desc->virt_addr, nsamples);
 }
 
@@ -707,13 +692,14 @@ static int das1800_ai_check_chanlist(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     struct comedi_cmd *cmd)
 {
-	unsigned int unipolar0 = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;
+	unsigned int range = CR_RANGE(cmd->chanlist[0]);
+	bool unipolar0 = comedi_range_is_unipolar(s, range);
 	int i;
 
 	for (i = 1; i < cmd->chanlist_len; i++) {
-		unsigned int unipolar = CR_RANGE(cmd->chanlist[i]) & UNIPOLAR;
+		range = CR_RANGE(cmd->chanlist[i]);
 
-		if (unipolar != unipolar0) {
+		if (unipolar0 != comedi_range_is_unipolar(s, range)) {
 			dev_dbg(dev->class_dev,
 				"unipolar and bipolar ranges cannot be mixed in the chanlist\n");
 			return -EINVAL;
@@ -852,23 +838,24 @@ static int control_a_bits(const struct comedi_cmd *cmd)
 }
 
 /* returns appropriate bits for control register c, depending on command */
-static int control_c_bits(const struct comedi_cmd *cmd)
+static int control_c_bits(struct comedi_subdevice *s,
+			  const struct comedi_cmd *cmd)
 {
+	unsigned int range = CR_RANGE(cmd->chanlist[0]);
+	unsigned int aref = CR_AREF(cmd->chanlist[0]);
 	int control_c;
-	int aref;
 
 	/* set clock source to internal or external, select analog reference,
 	 * select unipolar / bipolar
 	 */
-	aref = CR_AREF(cmd->chanlist[0]);
 	control_c = UQEN;	/* enable upper qram addresses */
 	if (aref != AREF_DIFF)
 		control_c |= SD;
 	if (aref == AREF_COMMON)
 		control_c |= CMEN;
-	/* if a unipolar range was selected */
-	if (CR_RANGE(cmd->chanlist[0]) & UNIPOLAR)
+	if (comedi_range_is_unipolar(s, range))
 		control_c |= UB;
+
 	switch (cmd->scan_begin_src) {
 	case TRIG_FOLLOW:	/*  not in burst mode */
 		switch (cmd->convert_src) {
@@ -994,6 +981,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	int control_a, control_c;
 	struct comedi_async *async = s->async;
 	const struct comedi_cmd *cmd = &async->cmd;
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
 
 	/* disable dma on CMDF_WAKE_EOS, or CMDF_PRIORITY
 	 * (because dma in handler is unsafe at hard real-time priority) */
@@ -1012,9 +1000,11 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 
 	das1800_cancel(dev, s);
 
+	devpriv->ai_is_unipolar = comedi_range_is_unipolar(s, range0);
+
 	/*  determine proper bits for control registers */
 	control_a = control_a_bits(cmd);
-	control_c = control_c_bits(cmd);
+	control_c = control_c_bits(s, cmd);
 
 	/* setup card and start */
 	program_chanlist(dev, cmd);
@@ -1052,23 +1042,24 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct das1800_board *board = dev->board_ptr;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int aref = CR_AREF(insn->chanspec);
+	bool is_unipolar = comedi_range_is_unipolar(s, range);
 	int i, n;
-	int chan, range, aref, chan_range;
+	int chan_range;
 	int timeout = 1000;
 	unsigned short dpnt;
 	int conv_flags = 0;
 	unsigned long irq_flags;
 
 	/* set up analog reference and unipolar / bipolar mode */
-	aref = CR_AREF(insn->chanspec);
 	conv_flags |= UQEN;
 	if (aref != AREF_DIFF)
 		conv_flags |= SD;
 	if (aref == AREF_COMMON)
 		conv_flags |= CMEN;
-	/* if a unipolar range was selected */
-	if (CR_RANGE(insn->chanspec) & UNIPOLAR)
+	if (is_unipolar)
 		conv_flags |= UB;
 
 	outb(conv_flags, dev->iobase + DAS1800_CONTROL_C);	/* software conversion enabled */
@@ -1076,10 +1067,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* reset fifo */
 	outb(FFEN, dev->iobase + DAS1800_CONTROL_A);
 
-	chan = CR_CHAN(insn->chanspec);
-	/* mask of unipolar/bipolar bit from range */
-	range = CR_RANGE(insn->chanspec) & 0x3;
-	chan_range = chan | (range << 8);
+	chan_range = chan | ((range & 0x3) << 8);
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/* set QRAM address start */
@@ -1100,9 +1088,8 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			goto exit;
 		}
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
-		/* shift data to offset binary for bipolar ranges */
-		if ((conv_flags & UB) == 0)
-			dpnt += 1 << (board->resolution - 1);
+		if (!is_unipolar)
+			dpnt = comedi_offset_munge(s, dpnt);
 		data[n] = dpnt;
 	}
 exit:
@@ -1384,6 +1371,7 @@ static int das1800_attach(struct comedi_device *dev,
 		s->do_cmdtest = das1800_ai_do_cmdtest;
 		s->poll = das1800_ai_poll;
 		s->cancel = das1800_cancel;
+		s->munge = das1800_ai_munge;
 	}
 
 	/* analog out */

commit d375278d666760e195693b57415ba0a125cadd55
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 8 10:14:58 2016 -0700

    staging: comedi: das1800: fix possible NULL dereference
    
    DMA is optional with this driver. If it was not enabled the devpriv->dma
    pointer will be NULL.
    
    Fix the possible NULL pointer dereference when trying to disable the DMA
    channels in das1800_ai_cancel() and tidy up the comments to fix the
    checkpatch.pl issues:
    WARNING: line over 80 characters
    
    It's probably harmless in das1800_ai_setup_dma() because the 'desc' pointer
    will not be used if DMA is disabled but fix it there also.
    
    Fixes: 99dfc3357e98 ("staging: comedi: das1800: remove depends on ISA_DMA_API limitation")
    Cc: <stable@vger.kernel.org> # 4.0+
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 940781183fac..3be10963f98b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -567,14 +567,17 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct comedi_isadma_desc *desc;
 	int i;
 
-	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
-	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
-	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
-
-	for (i = 0; i < 2; i++) {
-		desc = &dma->desc[i];
-		if (desc->chan)
-			comedi_isadma_disable(desc->chan);
+	/* disable and stop conversions */
+	outb(0x0, dev->iobase + DAS1800_STATUS);
+	outb(0x0, dev->iobase + DAS1800_CONTROL_B);
+	outb(0x0, dev->iobase + DAS1800_CONTROL_A);
+
+	if (dma) {
+		for (i = 0; i < 2; i++) {
+			desc = &dma->desc[i];
+			if (desc->chan)
+				comedi_isadma_disable(desc->chan);
+		}
 	}
 
 	return 0;
@@ -934,13 +937,14 @@ static void das1800_ai_setup_dma(struct comedi_device *dev,
 {
 	struct das1800_private *devpriv = dev->private;
 	struct comedi_isadma *dma = devpriv->dma;
-	struct comedi_isadma_desc *desc = &dma->desc[0];
+	struct comedi_isadma_desc *desc;
 	unsigned int bytes;
 
 	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
 		return;
 
 	dma->cur_dma = 0;
+	desc = &dma->desc[0];
 
 	/* determine a dma transfer size to fill buffer in 0.3 sec */
 	bytes = das1800_ai_transfer_size(dev, s, desc->maxsize, 300000000);

commit 40c3ef9d2f14cce91dbd6ae9c9ccf6210d8c5df7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 27 10:27:21 2015 -0700

    staging: comedi: das1800: add missing break in switch
    
    Commit 06ad6bd8 "staging: comedi: das1800: cleanup das1800_probe()"
    
    Accidently removed the 'break' statement for case 0x8 of the switch.
    Add it back.
    
    Reported-by: coverity (CID 1309550)
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index bfa42620a3f6..940781183fac 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1266,6 +1266,7 @@ static const struct das1800_board *das1800_probe(struct comedi_device *dev)
 		if (index == das1801hc || index == das1802hc)
 			return board;
 		index = das1801hc;
+		break;
 	default:
 		dev_err(dev->class_dev,
 			"Board model: probe returned 0x%x (unknown, please report)\n",

commit 8c79825ec861945dca5ce30db75a9673a8be8581
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:50 2015 -0700

    staging: comedi: das1800: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index a7471bb7c39b..bfa42620a3f6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -444,9 +444,9 @@ static const struct comedi_lrange range_ao_2 = {
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
-	const struct das1800_board *thisboard = dev->board_ptr;
+	const struct das1800_board *board = dev->board_ptr;
 
-	sample += 1 << (thisboard->resolution - 1);
+	sample += 1 << (board->resolution - 1);
 	return sample;
 }
 
@@ -725,7 +725,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
-	const struct das1800_board *thisboard = dev->board_ptr;
+	const struct das1800_board *board = dev->board_ptr;
 	int err = 0;
 	unsigned int arg;
 
@@ -765,7 +765,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-						    thisboard->ai_speed);
+						    board->ai_speed);
 	}
 
 	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
@@ -1048,7 +1048,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct das1800_board *thisboard = dev->board_ptr;
+	const struct das1800_board *board = dev->board_ptr;
 	int i, n;
 	int chan, range, aref, chan_range;
 	int timeout = 1000;
@@ -1098,7 +1098,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
 		/* shift data to offset binary for bipolar ranges */
 		if ((conv_flags & UB) == 0)
-			dpnt += 1 << (thisboard->resolution - 1);
+			dpnt += 1 << (board->resolution - 1);
 		data[n] = dpnt;
 	}
 exit:
@@ -1112,16 +1112,16 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct das1800_board *thisboard = dev->board_ptr;
+	const struct das1800_board *board = dev->board_ptr;
 	struct das1800_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
-	int update_chan = thisboard->ao_n_chan - 1;
+	int update_chan = board->ao_n_chan - 1;
 	unsigned short output;
 	unsigned long irq_flags;
 
 	/*   card expects two's complement data */
-	output = data[0] - (1 << (thisboard->resolution - 1));
+	output = data[0] - (1 << (board->resolution - 1));
 	/*  if the write is to the 'update' channel, we need to remember its value */
 	if (chan == update_chan)
 		devpriv->ao_update_bits = output;
@@ -1282,7 +1282,7 @@ static const struct das1800_board *das1800_probe(struct comedi_device *dev)
 static int das1800_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
-	const struct das1800_board *thisboard;
+	const struct das1800_board *board;
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
@@ -1296,16 +1296,16 @@ static int das1800_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	thisboard = das1800_probe(dev);
-	if (!thisboard) {
+	board = das1800_probe(dev);
+	if (!board) {
 		dev_err(dev->class_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_ptr = board;
+	dev->board_name = board->name;
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
-	if (thisboard->ao_ability == 2) {
+	if (board->ao_ability == 2) {
 		unsigned long iobase2 = dev->iobase + IOBASE2;
 
 		ret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);
@@ -1365,11 +1365,11 @@ static int das1800_attach(struct comedi_device *dev,
 	s = &dev->subdevices[0];
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
-	if (thisboard->common)
+	if (board->common)
 		s->subdev_flags |= SDF_COMMON;
-	s->n_chan = thisboard->qram_len;
-	s->maxdata = (1 << thisboard->resolution) - 1;
-	s->range_table = thisboard->range_ai;
+	s->n_chan = board->qram_len;
+	s->maxdata = (1 << board->resolution) - 1;
+	s->range_table = board->range_ai;
 	s->insn_read = das1800_ai_rinsn;
 	if (dev->irq) {
 		dev->read_subdev = s;
@@ -1383,11 +1383,11 @@ static int das1800_attach(struct comedi_device *dev,
 
 	/* analog out */
 	s = &dev->subdevices[1];
-	if (thisboard->ao_ability == 1) {
+	if (board->ao_ability == 1) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = thisboard->ao_n_chan;
-		s->maxdata = (1 << thisboard->resolution) - 1;
+		s->n_chan = board->ao_n_chan;
+		s->maxdata = (1 << board->resolution) - 1;
 		s->range_table = &range_bipolar10;
 		s->insn_write = das1800_ao_winsn;
 	} else {
@@ -1407,7 +1407,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE;
-	s->n_chan = thisboard->do_n_chan;
+	s->n_chan = board->do_n_chan;
 	s->maxdata = 1;
 	s->range_table = &range_digital;
 	s->insn_bits = das1800_do_wbits;
@@ -1418,9 +1418,9 @@ static int das1800_attach(struct comedi_device *dev,
 	outb(0, dev->iobase + DAS1800_DIGITAL);
 
 	/*  initialize analog out channels */
-	if (thisboard->ao_ability == 1) {
+	if (board->ao_ability == 1) {
 		/*  select 'update' dac channel for baseAddress + 0x0 */
-		outb(DAC(thisboard->ao_n_chan - 1),
+		outb(DAC(board->ao_n_chan - 1),
 		     dev->iobase + DAS1800_SELECT);
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
 	}

commit 06ad6bd8698c1202423ead5a9e85564134382065
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:49 2015 -0700

    staging: comedi: das1800: cleanup das1800_probe()
    
    Make this function return a pointer to the boardinfo instead of an index.
    Since it's not typical, add a comment to clarify why this legacy driver
    does a probe.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 53baf37cd21a..a7471bb7c39b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1216,62 +1216,67 @@ static void das1800_free_dma(struct comedi_device *dev)
 		comedi_isadma_free(devpriv->dma);
 }
 
-static int das1800_probe(struct comedi_device *dev)
+static const struct das1800_board *das1800_probe(struct comedi_device *dev)
 {
 	const struct das1800_board *board = dev->board_ptr;
-	int index;
+	int index = board ? board - das1800_boards : -EINVAL;
 	int id;
 
-	/* calc the offset to the boardinfo that was found by the core */
-	index = board - das1800_boards;
-
-	/* verify that the board id matches the boardinfo */
+	/*
+	 * The dev->board_ptr will be set by comedi_device_attach() if the
+	 * board name provided by the user matches a board->name in this
+	 * driver. If so, this function sanity checks the id to verify that
+	 * the board is correct.
+	 *
+	 * If the dev->board_ptr is not set, the user is trying to attach
+	 * an unspecified board to this driver. In this case the id is used
+	 * to 'probe' for the correct dev->board_ptr.
+	 */
 	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;
 	switch (id) {
 	case 0x3:
 		if (index == das1801st_da || index == das1802st_da ||
 		    index == das1701st_da || index == das1702st_da)
-			return index;
+			return board;
 		index = das1801st;
 		break;
 	case 0x4:
 		if (index == das1802hr_da || index == das1702hr_da)
-			return index;
+			return board;
 		index = das1802hr;
 		break;
 	case 0x5:
 		if (index == das1801ao || index == das1802ao ||
 		    index == das1701ao || index == das1702ao)
-			return index;
+			return board;
 		index = das1801ao;
 		break;
 	case 0x6:
 		if (index == das1802hr || index == das1702hr)
-			return index;
+			return board;
 		index = das1802hr;
 		break;
 	case 0x7:
 		if (index == das1801st || index == das1802st ||
 		    index == das1701st || index == das1702st)
-			return index;
+			return board;
 		index = das1801st;
 		break;
 	case 0x8:
 		if (index == das1801hc || index == das1802hc)
-			return index;
+			return board;
 		index = das1801hc;
-		break;
 	default:
 		dev_err(dev->class_dev,
 			"Board model: probe returned 0x%x (unknown, please report)\n",
 			id);
-		break;
+		return NULL;
 	}
 	dev_err(dev->class_dev,
 		"Board model (probed, not recommended): %s series\n",
 		das1800_boards[index].name);
 
-	return index;
+	return &das1800_boards[index];
 }
 
 static int das1800_attach(struct comedi_device *dev,
@@ -1281,7 +1286,6 @@ static int das1800_attach(struct comedi_device *dev,
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
-	int board;
 	int ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
@@ -1292,14 +1296,12 @@ static int das1800_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	board = das1800_probe(dev);
-	if (board < 0) {
+	thisboard = das1800_probe(dev);
+	if (!thisboard) {
 		dev_err(dev->class_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
-
-	dev->board_ptr = das1800_boards + board;
-	thisboard = dev->board_ptr;
+	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */

commit 05e07db18552de231f0a62172c2f7715a58c46cd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:10 2015 +0000

    staging: comedi: das1800: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0a93ae93da93..53baf37cd21a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -102,7 +102,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 #include "comedi_8254.h"
 
 /* misc. defines */
@@ -732,12 +731,13 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src,
+	err |= comedi_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src,
 					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
@@ -745,10 +745,10 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -761,21 +761,23 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 thisboard->ai_speed);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    thisboard->ai_speed);
+	}
 
-	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;
@@ -791,22 +793,23 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 		/* we are not in burst mode */
 		arg = cmd->convert_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	} else if (cmd->convert_src == TRIG_TIMER) {
 		/* we are in burst mode */
 		arg = burst_convert_arg(cmd->convert_arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			arg = cmd->convert_arg * cmd->chanlist_len;
-			err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
-							 arg);
+			err |= comedi_check_trigger_arg_max(&cmd->
+							    scan_begin_arg,
+							    arg);
 
 			arg = cmd->scan_begin_arg;
 			comedi_8254_cascade_ns_to_timer(dev->pacer, &arg,
 							cmd->flags);
-			err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
-							arg);
+			err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,
+							   arg);
 		}
 	}
 

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index ca4f322c0d2f..0a93ae93da93 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1141,7 +1141,6 @@ static int das1800_di_rbits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
 	data[0] = 0;
 

commit 82d28561b7e01eccaa36b06c987045f08a77b4f4
Author: Navya Sri Nizamkari <navyasri.tech@gmail.com>
Date:   Tue Mar 3 17:08:06 2015 +0530

    staging: comedi: Remove if condition.
    
    This patch removes a if condition which has a semicolon
    after it. As the conditional check is redundant, the comment
    before it is also changed. The following
    coccinelle script was used to detect the pattern of a
    semicolon after if.
    
    @r1@
    position p;
    @@
    if (...);@p
    @script:python@
    p0 << r1.p;
    @@
    // Emacs org-mode output
    cocci.print_main("", p0)
    cocci.print_secs("", p0)
    
    Signed-off-by: Navya Sri Nizamkari <navyasri.tech@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3eb02e8d6103..ca4f322c0d2f 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -489,9 +489,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 
 	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
-		/* convert to unsigned type if we are in a bipolar mode */
-		if (!unipolar)
-			;
+		/* convert to unsigned type */
 		dpnt = munge_bipolar_sample(dev, dpnt);
 		comedi_buf_write_samples(s, &dpnt, 1);
 

commit a6c6c9b143d3abd854678b8ccfeb431f3db02f86
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:46 2015 -0700

    staging: comedi: das1800: convert driver to use the comedi_8254 module
    
    This driver uses an 8254 timer to generate the pacer clock used for analog
    input data conversion. Convert it to use the comedi_8254 module to provide
    support for the 8254 timer.
    
    Tidy up the (*do_cmdtest) validation of the timer arguments.
    
    Absorb the converted das1800_setup_counters() code into the (*do_cmd).
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0790a28828de..3eb02e8d6103 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -103,7 +103,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 
 #include "comedi_isadma.h"
 #include "comedi_fc.h"
-#include "8253.h"
+#include "comedi_8254.h"
 
 /* misc. defines */
 #define DAS1800_SIZE           16	/* uses 16 io addresses */
@@ -422,8 +422,6 @@ static const struct das1800_board das1800_boards[] = {
 
 struct das1800_private {
 	struct comedi_isadma *dma;
-	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
-	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
 	int irq_dma_bits;	/* bits for control register b */
 	/* dma bits for control register b, stored so that dma can be
 	 * turned on and off */
@@ -731,7 +729,6 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_cmd *cmd)
 {
 	const struct das1800_board *thisboard = dev->board_ptr;
-	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -795,35 +792,23 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	    cmd->convert_src == TRIG_TIMER) {
 		/* we are not in burst mode */
 		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (arg != cmd->convert_arg)
-			err++;
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	} else if (cmd->convert_src == TRIG_TIMER) {
 		/* we are in burst mode */
-		arg = cmd->convert_arg;
-		cmd->convert_arg = burst_convert_arg(cmd->convert_arg,
-						     cmd->flags);
-		if (arg != cmd->convert_arg)
-			err++;
+		arg = burst_convert_arg(cmd->convert_arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 		if (cmd->scan_begin_src == TRIG_TIMER) {
 			arg = cmd->convert_arg * cmd->chanlist_len;
-			if (arg > cmd->scan_begin_arg) {
-				cmd->scan_begin_arg = arg;
-				err++;
-			}
+			err |= cfc_check_trigger_arg_max(&cmd->scan_begin_arg,
+							 arg);
 
 			arg = cmd->scan_begin_arg;
-			i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
-						  &devpriv->divisor1,
-						  &devpriv->divisor2,
-						  &cmd->scan_begin_arg,
-						  cmd->flags);
-			if (arg != cmd->scan_begin_arg)
-				err++;
+			comedi_8254_cascade_ns_to_timer(dev->pacer, &arg,
+							cmd->flags);
+			err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg,
+							arg);
 		}
 	}
 
@@ -910,31 +895,6 @@ static int control_c_bits(const struct comedi_cmd *cmd)
 	return control_c;
 }
 
-static void das1800_setup_counters(struct comedi_device *dev,
-				   const struct comedi_cmd *cmd)
-{
-	struct das1800_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + DAS1800_COUNTER;
-
-	/* setup cascaded counters for conversion/scan frequency */
-	if ((cmd->scan_begin_src == TRIG_FOLLOW ||
-	     cmd->scan_begin_src == TRIG_TIMER) &&
-	    cmd->convert_src == TRIG_TIMER) {
-		i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-		i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-
-		i8254_write(timer_base, 0, 1, devpriv->divisor1);
-		i8254_write(timer_base, 0, 2, devpriv->divisor2);
-	}
-
-	/* setup counter 0 for 'about triggering' */
-	if (cmd->stop_src == TRIG_EXT) {
-		i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
-
-		i8254_write(timer_base, 0, 0, 1);
-	}
-}
-
 static unsigned int das1800_ai_transfer_size(struct comedi_device *dev,
 					     struct comedi_subdevice *s,
 					     unsigned int maxbytes,
@@ -1053,7 +1013,19 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 
 	/* setup card and start */
 	program_chanlist(dev, cmd);
-	das1800_setup_counters(dev, cmd);
+
+	/* setup cascaded counters for conversion/scan frequency */
+	if ((cmd->scan_begin_src == TRIG_FOLLOW ||
+	     cmd->scan_begin_src == TRIG_TIMER) &&
+	    cmd->convert_src == TRIG_TIMER) {
+		comedi_8254_update_divisors(dev->pacer);
+		comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
+	}
+
+	/* setup counter 0 for 'about triggering' */
+	if (cmd->stop_src == TRIG_EXT)
+		comedi_8254_load(dev->pacer, 0, 1, I8254_MODE0 | I8254_BINARY);
+
 	das1800_ai_setup_dma(dev, s);
 	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
 	/*  set conversion rate and length for burst mode */
@@ -1378,6 +1350,11 @@ static int das1800_attach(struct comedi_device *dev,
 	if (!devpriv->fifo_buf)
 		return -ENOMEM;
 
+	dev->pacer = comedi_8254_init(dev->iobase + DAS1800_COUNTER,
+				      I8254_OSC_BASE_5MHZ, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
 		return ret;

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 13ed31cebb7e..0790a28828de 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -611,7 +611,7 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		/*  clear OVF interrupt bit */
 		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
 		dev_err(dev->class_dev, "FIFO overflow\n");
-		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		async->events |= COMEDI_CB_ERROR;
 		comedi_handle_events(dev, s);
 		return;
 	}

commit bff776931e6589192f07f22e1ec17b8eb878bd1a
Author: Chase Southwood <chase.southwood@gmail.com>
Date:   Mon Jan 19 20:42:49 2015 -0600

    staging: comedi: das1800: prefer kmalloc_array over kmalloc with multiply
    
    Checkpatch doesn't like kmalloc with multiply very much:
    drivers/staging/comedi/drivers/das1800.c:1377: WARNING: Prefer kmalloc_array over kmalloc with multiply
    
    So this patch swaps that use out for kmalloc_array instead.
    
    Signed-off-by: Chase Southwood <chase.southwood@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 381ae9440ab2..13ed31cebb7e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1374,7 +1374,7 @@ static int das1800_attach(struct comedi_device *dev,
 	if (dev->irq & it->options[2])
 		das1800_init_dma(dev, it);
 
-	devpriv->fifo_buf = kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+	devpriv->fifo_buf = kmalloc_array(FIFO_SIZE, sizeof(uint16_t), GFP_KERNEL);
 	if (!devpriv->fifo_buf)
 		return -ENOMEM;
 

commit 99dfc3357e9889f247f052ae7c8596084faf7a81
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:07 2015 -0700

    staging: comedi: das1800: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5be5162dfe69..381ae9440ab2 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -98,12 +98,12 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>
-#include "../comedidev.h"
 
-#include <asm/dma.h>
+#include "../comedidev.h"
 
-#include "8253.h"
+#include "comedi_isadma.h"
 #include "comedi_fc.h"
+#include "8253.h"
 
 /* misc. defines */
 #define DAS1800_SIZE           16	/* uses 16 io addresses */
@@ -420,22 +420,14 @@ static const struct das1800_board das1800_boards[] = {
 	 },
 };
 
-struct das1800_dma_desc {
-	unsigned int chan;	/* DMA channel */
-	void *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* transfer size (in bytes) */
-};
-
 struct das1800_private {
+	struct comedi_isadma *dma;
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
 	int irq_dma_bits;	/* bits for control register b */
 	/* dma bits for control register b, stored so that dma can be
 	 * turned on and off */
 	int dma_bits;
-	struct das1800_dma_desc dma_desc[2];
-	int cur_dma;
 	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	unsigned short ao_update_bits;	/* remembers the last write to the
@@ -452,32 +444,6 @@ static const struct comedi_lrange range_ao_2 = {
 };
 */
 
-static void das1800_isadma_program(struct das1800_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma->chan);
-	set_dma_mode(dma->chan, DMA_MODE_READ);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
-	release_dma_lock(flags);
-}
-
-static unsigned int das1800_isadma_disable(unsigned int dma_chan)
-{
-	unsigned long flags;
-	unsigned int residue;
-
-	flags = claim_dma_lock();
-	disable_dma(dma_chan);
-	residue = get_dma_residue(dma_chan);
-	release_dma_lock(flags);
-
-	return residue;
-}
-
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
@@ -540,18 +506,18 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma() */
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
-				      struct das1800_dma_desc *dma)
+				      struct comedi_isadma_desc *desc)
 {
-	unsigned int residue = das1800_isadma_disable(dma->chan);
-	unsigned int nbytes = dma->size - residue;
+	unsigned int residue = comedi_isadma_disable(desc->chan);
+	unsigned int nbytes = desc->size - residue;
 	unsigned int nsamples;
 
 	/*  figure out how many points to read */
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 	nsamples = comedi_nsamples_left(s, nsamples);
 
-	munge_data(dev, dma->virt_addr, nsamples);
-	comedi_buf_write_samples(s, dma->virt_addr, nsamples);
+	munge_data(dev, desc->virt_addr, nsamples);
+	comedi_buf_write_samples(s, desc->virt_addr, nsamples);
 }
 
 /* flushes remaining data from board when external trigger has stopped acquisition
@@ -560,16 +526,17 @@ static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	das1800_flush_dma_channel(dev, s, dma);
+	das1800_flush_dma_channel(dev, s, desc);
 
 	if (dual_dma) {
 		/*  switch to other channel and flush it */
-		devpriv->cur_dma = 1 - devpriv->cur_dma;
-		dma = &devpriv->dma_desc[devpriv->cur_dma];
-		das1800_flush_dma_channel(dev, s, dma);
+		dma->cur_dma = 1 - dma->cur_dma;
+		desc = &dma->desc[dma->cur_dma];
+		das1800_flush_dma_channel(dev, s, desc);
 	}
 
 	/*  get any remaining samples in fifo */
@@ -580,27 +547,29 @@ static void das1800_handle_dma(struct comedi_device *dev,
 			       struct comedi_subdevice *s, unsigned int status)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	das1800_flush_dma_channel(dev, s, dma);
+	das1800_flush_dma_channel(dev, s, desc);
 
 	/* re-enable dma channel */
-	das1800_isadma_program(dma);
+	comedi_isadma_program(desc);
 
 	if (status & DMATC) {
 		/*  clear DMATC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
 		/*  switch dma channels for next time, if appropriate */
 		if (dual_dma)
-			devpriv->cur_dma = 1 - devpriv->cur_dma;
+			dma->cur_dma = 1 - dma->cur_dma;
 	}
 }
 
 static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc;
 	int i;
 
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
@@ -608,9 +577,9 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
 
 	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->chan)
-			das1800_isadma_disable(dma->chan);
+		desc = &dma->desc[i];
+		if (desc->chan)
+			comedi_isadma_disable(desc->chan);
 	}
 
 	return 0;
@@ -968,10 +937,11 @@ static void das1800_setup_counters(struct comedi_device *dev,
 
 static unsigned int das1800_ai_transfer_size(struct comedi_device *dev,
 					     struct comedi_subdevice *s,
+					     unsigned int maxbytes,
 					     unsigned int ns)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int max_samples = comedi_bytes_to_samples(s, DMA_BUF_SIZE);
+	unsigned int max_samples = comedi_bytes_to_samples(s, maxbytes);
 	unsigned int samples;
 
 	samples = max_samples;
@@ -1002,25 +972,26 @@ static void das1800_ai_setup_dma(struct comedi_device *dev,
 				 struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma = &devpriv->dma_desc[0];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[0];
 	unsigned int bytes;
 
 	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
 		return;
 
-	devpriv->cur_dma = 0;
+	dma->cur_dma = 0;
 
 	/* determine a dma transfer size to fill buffer in 0.3 sec */
-	bytes = das1800_ai_transfer_size(dev, s, 300000000);
+	bytes = das1800_ai_transfer_size(dev, s, desc->maxsize, 300000000);
 
-	dma->size = bytes;
-	das1800_isadma_program(dma);
+	desc->size = bytes;
+	comedi_isadma_program(desc);
 
 	/* set up dual dma if appropriate */
 	if (devpriv->irq_dma_bits & DMA_DUAL) {
-		dma = &devpriv->dma_desc[1];
-		dma->size = bytes;
-		das1800_isadma_program(dma);
+		desc = &dma->desc[1];
+		desc->size = bytes;
+		comedi_isadma_program(desc);
 	}
 }
 
@@ -1220,13 +1191,11 @@ static int das1800_do_wbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das1800_init_dma(struct comedi_device *dev,
-			    struct comedi_devconfig *it)
+static void das1800_init_dma(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma;
 	unsigned int *dma_chan;
-	int i;
 
 	/*
 	 * it->options[2] is DMA channel 0
@@ -1238,75 +1207,41 @@ static int das1800_init_dma(struct comedi_device *dev,
 
 	switch ((dma_chan[0] & 0x7) | (dma_chan[1] << 4)) {
 	case 0x5:	/*  dma0 == 5 */
-		devpriv->dma_bits |= DMA_CH5;
+		devpriv->dma_bits = DMA_CH5;
 		break;
 	case 0x6:	/*  dma0 == 6 */
-		devpriv->dma_bits |= DMA_CH6;
+		devpriv->dma_bits = DMA_CH6;
 		break;
 	case 0x7:	/*  dma0 == 7 */
-		devpriv->dma_bits |= DMA_CH7;
+		devpriv->dma_bits = DMA_CH7;
 		break;
 	case 0x65:	/*  dma0 == 5, dma1 == 6 */
-		devpriv->dma_bits |= DMA_CH5_CH6;
+		devpriv->dma_bits = DMA_CH5_CH6;
 		break;
 	case 0x76:	/*  dma0 == 6, dma1 == 7 */
-		devpriv->dma_bits |= DMA_CH6_CH7;
+		devpriv->dma_bits = DMA_CH6_CH7;
 		break;
 	case 0x57:	/*  dma0 == 7, dma1 == 5 */
-		devpriv->dma_bits |= DMA_CH7_CH5;
+		devpriv->dma_bits = DMA_CH7_CH5;
 		break;
 	default:
-		dev_err(dev->class_dev,
-			"only supports dma channels 5 through 7\n");
-		dev_err(dev->class_dev,
-			"Dual dma only allows the following combinations:\n");
-		dev_err(dev->class_dev,
-			"dma 5,6 / 6,7 / or 7,5\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-
-		if (dma_chan[i] == 0)
-			break;
-
-		if (request_dma(dma_chan[i], dev->board_name)) {
-			dev_err(dev->class_dev,
-				"failed to allocate dma channel %i\n",
-				dma_chan[i]);
-			return -EINVAL;
-		}
-		dma->chan = dma_chan[i];
-
-		dma->virt_addr = dma_alloc_coherent(NULL, DMA_BUF_SIZE,
-						    &dma->hw_addr, GFP_KERNEL);
-		if (!dma->virt_addr)
-			return -ENOMEM;
-
-		das1800_isadma_disable(dma->chan);
+		return;
 	}
 
-	return 0;
+	/* DMA can use 1 or 2 buffers, each with a separate channel */
+	devpriv->dma = comedi_isadma_alloc(dev, dma_chan[1] ? 2 : 1,
+					   dma_chan[0], dma_chan[1],
+					   DMA_BUF_SIZE, COMEDI_ISADMA_READ);
+	if (!devpriv->dma)
+		devpriv->dma_bits = 0;
 }
 
 static void das1800_free_dma(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma;
-	int i;
-
-	if (!devpriv)
-		return;
 
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->chan)
-			free_dma(dma->chan);
-		if (dma->virt_addr)
-			dma_free_coherent(NULL, DMA_BUF_SIZE,
-					  dma->virt_addr, dma->hw_addr);
-	}
+	if (devpriv)
+		comedi_isadma_free(devpriv->dma);
 }
 
 static int das1800_probe(struct comedi_device *dev)
@@ -1436,11 +1371,8 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	/* an irq and one dma channel is required to use dma */
-	if (dev->irq & it->options[2]) {
-		ret = das1800_init_dma(dev, it);
-		if (ret < 0)
-			return ret;
-	}
+	if (dev->irq & it->options[2])
+		das1800_init_dma(dev, it);
 
 	devpriv->fifo_buf = kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
 	if (!devpriv->fifo_buf)

commit 5e5a21cf8e7756f668e7eb51ba99619136b79c4d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:44 2015 -0700

    staging: comedi: das1800: tidy up das1800_ai_transfer_size()
    
    For aesthetics, pass the fill time 'ns' as a parameter to this function.
    
    Refactor this function to calculate the transfer size in 'samples' instead
    of 'bytes'. This removes the need to constantly multiply the values by the
    'sample_size'. It also helps avoid any possible integer overflow issues.
    
    Use the comedi_nsamples_left() helper to limit the samples when cmd->stop_src
    is TRIG_COUNT.
    
    Use comedi_samples_to_bytes() to return the final DMA size in bytes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index c36ce0c73c68..5be5162dfe69 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -967,42 +967,35 @@ static void das1800_setup_counters(struct comedi_device *dev,
 }
 
 static unsigned int das1800_ai_transfer_size(struct comedi_device *dev,
-					     struct comedi_subdevice *s)
+					     struct comedi_subdevice *s,
+					     unsigned int ns)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int size = DMA_BUF_SIZE;
-	unsigned int sample_size = comedi_bytes_per_sample(s);
-	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
-	unsigned int max_size;	/*  maximum size we will allow for a transfer */
+	unsigned int max_samples = comedi_bytes_to_samples(s, DMA_BUF_SIZE);
+	unsigned int samples;
 
-	/*  make dma buffer fill in 0.3 seconds for timed modes */
+	samples = max_samples;
+
+	/* for timed modes, make dma buffer fill in 'ns' time */
 	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:	/*  not in burst mode */
+	case TRIG_FOLLOW:	/* not in burst mode */
 		if (cmd->convert_src == TRIG_TIMER)
-			size = (fill_time / cmd->convert_arg) * sample_size;
+			samples = ns / cmd->convert_arg;
 		break;
 	case TRIG_TIMER:
-		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
-		    sample_size;
-		break;
-	default:
-		size = DMA_BUF_SIZE;
+		samples = ns / (cmd->scan_begin_arg * cmd->chanlist_len);
 		break;
 	}
 
-	/*  set a minimum and maximum size allowed */
-	max_size = DMA_BUF_SIZE;
-	/*  if we are taking limited number of conversions, limit transfer size to that */
-	if (cmd->stop_src == TRIG_COUNT &&
-	    cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
-		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
+	/* limit samples to what is remaining in the command */
+	samples = comedi_nsamples_left(s, samples);
 
-	if (size > max_size)
-		size = max_size;
-	if (size < sample_size)
-		size = sample_size;
+	if (samples > max_samples)
+		samples = max_samples;
+	if (samples < 1)
+		samples = 1;
 
-	return size;
+	return comedi_samples_to_bytes(s, samples);
 }
 
 static void das1800_ai_setup_dma(struct comedi_device *dev,
@@ -1017,8 +1010,8 @@ static void das1800_ai_setup_dma(struct comedi_device *dev,
 
 	devpriv->cur_dma = 0;
 
-	/* determine a reasonable dma transfer size */
-	bytes = das1800_ai_transfer_size(dev, s);
+	/* determine a dma transfer size to fill buffer in 0.3 sec */
+	bytes = das1800_ai_transfer_size(dev, s, 300000000);
 
 	dma->size = bytes;
 	das1800_isadma_program(dma);

commit 620ec185a208f5bf54af46912ae75a330697bd3f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:43 2015 -0700

    staging: comedi: das1800: remove hard coded 'sample_size'
    
    Use the comedi_bytes_per_sample() helper to remove the hard coded sample_size
    in suggest_transfer_size().
    
    The helper function needs to comedi_subdevice pointer. Change the parameters
    passed to suggest_transfer_size() and setup_dma() so that this pointer is
    available. Rename these functions so they have namespace associated with the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6359fe665ed6..c36ce0c73c68 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -966,11 +966,12 @@ static void das1800_setup_counters(struct comedi_device *dev,
 	}
 }
 
-/* utility function that suggests a dma transfer size based on the conversion period 'ns' */
-static unsigned int suggest_transfer_size(const struct comedi_cmd *cmd)
+static unsigned int das1800_ai_transfer_size(struct comedi_device *dev,
+					     struct comedi_subdevice *s)
 {
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int size = DMA_BUF_SIZE;
-	static const int sample_size = 2;	/*  size in bytes of one sample from board */
+	unsigned int sample_size = comedi_bytes_per_sample(s);
 	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
 	unsigned int max_size;	/*  maximum size we will allow for a transfer */
 
@@ -1004,8 +1005,8 @@ static unsigned int suggest_transfer_size(const struct comedi_cmd *cmd)
 	return size;
 }
 
-/* sets up dma */
-static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
+static void das1800_ai_setup_dma(struct comedi_device *dev,
+				 struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma = &devpriv->dma_desc[0];
@@ -1017,7 +1018,7 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	devpriv->cur_dma = 0;
 
 	/* determine a reasonable dma transfer size */
-	bytes = suggest_transfer_size(cmd);
+	bytes = das1800_ai_transfer_size(dev, s);
 
 	dma->size = bytes;
 	das1800_isadma_program(dma);
@@ -1089,7 +1090,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	/* setup card and start */
 	program_chanlist(dev, cmd);
 	das1800_setup_counters(dev, cmd);
-	setup_dma(dev, cmd);
+	das1800_ai_setup_dma(dev, s);
 	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
 	/*  set conversion rate and length for burst mode */
 	if (control_c & BMDE) {

commit ae4e131e0b5ab57313371aa7d773ac8b01fdb2c7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:29 2015 -0700

    staging: comedi: das1800: introduce das1800_isadma_disable()
    
    Introduce a helper function to disable and the ISA DMA controller and
    return the residue as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6df58cda7d32..6359fe665ed6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -465,6 +465,19 @@ static void das1800_isadma_program(struct das1800_dma_desc *dma)
 	release_dma_lock(flags);
 }
 
+static unsigned int das1800_isadma_disable(unsigned int dma_chan)
+{
+	unsigned long flags;
+	unsigned int residue;
+
+	flags = claim_dma_lock();
+	disable_dma(dma_chan);
+	residue = get_dma_residue(dma_chan);
+	release_dma_lock(flags);
+
+	return residue;
+}
+
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
@@ -524,23 +537,16 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 	}
 }
 
-/* Utility function used by das1800_flush_dma() and das1800_handle_dma().
- * Assumes dma lock is held */
+/* Utility function used by das1800_flush_dma() and das1800_handle_dma() */
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      struct das1800_dma_desc *dma)
 {
-	unsigned int nbytes;
+	unsigned int residue = das1800_isadma_disable(dma->chan);
+	unsigned int nbytes = dma->size - residue;
 	unsigned int nsamples;
 
-	disable_dma(dma->chan);
-
-	/* clear flip-flop to make sure 2-byte registers
-	 * get set correctly */
-	clear_dma_ff(dma->chan);
-
 	/*  figure out how many points to read */
-	nbytes = dma->size - get_dma_residue(dma->chan);
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 	nsamples = comedi_nsamples_left(s, nsamples);
 
@@ -555,10 +561,8 @@ static void das1800_flush_dma(struct comedi_device *dev,
 {
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, dma);
 
 	if (dual_dma) {
@@ -568,8 +572,6 @@ static void das1800_flush_dma(struct comedi_device *dev,
 		das1800_flush_dma_channel(dev, s, dma);
 	}
 
-	release_dma_lock(flags);
-
 	/*  get any remaining samples in fifo */
 	das1800_handle_fifo_not_empty(dev, s);
 }
@@ -579,12 +581,9 @@ static void das1800_handle_dma(struct comedi_device *dev,
 {
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, dma);
-	release_dma_lock(flags);
 
 	/* re-enable dma channel */
 	das1800_isadma_program(dma);
@@ -611,7 +610,7 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 	for (i = 0; i < 2; i++) {
 		dma = &devpriv->dma_desc[i];
 		if (dma->chan)
-			disable_dma(dma->chan);
+			das1800_isadma_disable(dma->chan);
 	}
 
 	return 0;
@@ -1233,7 +1232,6 @@ static int das1800_init_dma(struct comedi_device *dev,
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma;
 	unsigned int *dma_chan;
-	unsigned long flags;
 	int i;
 
 	/*
@@ -1292,9 +1290,7 @@ static int das1800_init_dma(struct comedi_device *dev,
 		if (!dma->virt_addr)
 			return -ENOMEM;
 
-		flags = claim_dma_lock();
-		disable_dma(dma->chan);
-		release_dma_lock(flags);
+		das1800_isadma_disable(dma->chan);
 	}
 
 	return 0;

commit dec3aa4fff19e00e2f5be6213adfa4124b93fc19
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:28 2015 -0700

    staging: comedi: das1800: introduce das1800_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index c8ad7dd1ac21..6df58cda7d32 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -452,6 +452,19 @@ static const struct comedi_lrange range_ao_2 = {
 };
 */
 
+static void das1800_isadma_program(struct das1800_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma->chan);
+	set_dma_mode(dma->chan, DMA_MODE_READ);
+	set_dma_addr(dma->chan, dma->hw_addr);
+	set_dma_count(dma->chan, dma->size);
+	enable_dma(dma->chan);
+	release_dma_lock(flags);
+}
+
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
@@ -571,12 +584,11 @@ static void das1800_handle_dma(struct comedi_device *dev,
 
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, dma);
-	/*  re-enable  dma channel */
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
 	release_dma_lock(flags);
 
+	/* re-enable dma channel */
+	das1800_isadma_program(dma);
+
 	if (status & DMATC) {
 		/*  clear DMATC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
@@ -998,8 +1010,6 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma = &devpriv->dma_desc[0];
-	unsigned long lock_flags;
-	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 	unsigned int bytes;
 
 	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
@@ -1011,29 +1021,14 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	bytes = suggest_transfer_size(cmd);
 
 	dma->size = bytes;
-	lock_flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	/* clear flip-flop to make sure 2-byte registers for
-	 * count and address get set correctly */
-	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	/*  set appropriate size of transfer */
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
-	/*  set up dual dma if appropriate */
-	if (dual_dma) {
+	das1800_isadma_program(dma);
+
+	/* set up dual dma if appropriate */
+	if (devpriv->irq_dma_bits & DMA_DUAL) {
 		dma = &devpriv->dma_desc[1];
 		dma->size = bytes;
-		disable_dma(dma->chan);
-		/* clear flip-flop to make sure 2-byte registers for
-		 * count and address get set correctly */
-		clear_dma_ff(dma->chan);
-		set_dma_addr(dma->chan, dma->hw_addr);
-		/*  set appropriate size of transfer */
-		set_dma_count(dma->chan, dma->size);
-		enable_dma(dma->chan);
+		das1800_isadma_program(dma);
 	}
-	release_dma_lock(lock_flags);
 }
 
 /* programs channel/gain list into card */
@@ -1299,7 +1294,6 @@ static int das1800_init_dma(struct comedi_device *dev,
 
 		flags = claim_dma_lock();
 		disable_dma(dma->chan);
-		set_dma_mode(dma->chan, DMA_MODE_READ);
 		release_dma_lock(flags);
 	}
 

commit 5d12431c5cb5955d6b98700cc665414553986ef2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:27 2015 -0700

    staging: comedi: das1800: move dma transfer 'size' to dma descriptor
    
    For asethetics, move the variable that holds the dma transfer 'size' into
    the dma descriptor.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f99aa79af533..c8ad7dd1ac21 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -424,6 +424,7 @@ struct das1800_dma_desc {
 	unsigned int chan;	/* DMA channel */
 	void *virt_addr;	/* virtual address of DMA buffer */
 	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
+	unsigned int size;	/* transfer size (in bytes) */
 };
 
 struct das1800_private {
@@ -436,7 +437,6 @@ struct das1800_private {
 	struct das1800_dma_desc dma_desc[2];
 	int cur_dma;
 	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
-	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	unsigned short ao_update_bits;	/* remembers the last write to the
 					 * 'update' dac */
@@ -517,7 +517,6 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      struct das1800_dma_desc *dma)
 {
-	struct das1800_private *devpriv = dev->private;
 	unsigned int nbytes;
 	unsigned int nsamples;
 
@@ -528,7 +527,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	clear_dma_ff(dma->chan);
 
 	/*  figure out how many points to read */
-	nbytes = devpriv->dma_transfer_size - get_dma_residue(dma->chan);
+	nbytes = dma->size - get_dma_residue(dma->chan);
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 	nsamples = comedi_nsamples_left(s, nsamples);
 
@@ -574,7 +573,7 @@ static void das1800_handle_dma(struct comedi_device *dev,
 	das1800_flush_dma_channel(dev, s, dma);
 	/*  re-enable  dma channel */
 	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, devpriv->dma_transfer_size);
+	set_dma_count(dma->chan, dma->size);
 	enable_dma(dma->chan);
 	release_dma_lock(flags);
 
@@ -1001,6 +1000,7 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	struct das1800_dma_desc *dma = &devpriv->dma_desc[0];
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
+	unsigned int bytes;
 
 	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
 		return;
@@ -1008,7 +1008,9 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	devpriv->cur_dma = 0;
 
 	/* determine a reasonable dma transfer size */
-	devpriv->dma_transfer_size = suggest_transfer_size(cmd);
+	bytes = suggest_transfer_size(cmd);
+
+	dma->size = bytes;
 	lock_flags = claim_dma_lock();
 	disable_dma(dma->chan);
 	/* clear flip-flop to make sure 2-byte registers for
@@ -1016,18 +1018,19 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	clear_dma_ff(dma->chan);
 	set_dma_addr(dma->chan, dma->hw_addr);
 	/*  set appropriate size of transfer */
-	set_dma_count(dma->chan, devpriv->dma_transfer_size);
+	set_dma_count(dma->chan, dma->size);
 	enable_dma(dma->chan);
 	/*  set up dual dma if appropriate */
 	if (dual_dma) {
 		dma = &devpriv->dma_desc[1];
+		dma->size = bytes;
 		disable_dma(dma->chan);
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
 		clear_dma_ff(dma->chan);
 		set_dma_addr(dma->chan, dma->hw_addr);
 		/*  set appropriate size of transfer */
-		set_dma_count(dma->chan, devpriv->dma_transfer_size);
+		set_dma_count(dma->chan, dma->size);
 		enable_dma(dma->chan);
 	}
 	release_dma_lock(lock_flags);

commit 38f23ed0a61d83fb67afd01895989cae7ee29581
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:26 2015 -0700

    staging: comedi: das1800: pass dma descriptor to das1800_flush_dma_channel()
    
    Instead of passing the dma descriptor 'chan' and 'virt_addr' just pass the
    dma descriptor.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1eb5eab52007..f99aa79af533 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -515,25 +515,25 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
  * Assumes dma lock is held */
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
-				      unsigned int channel, uint16_t *buffer)
+				      struct das1800_dma_desc *dma)
 {
 	struct das1800_private *devpriv = dev->private;
 	unsigned int nbytes;
 	unsigned int nsamples;
 
-	disable_dma(channel);
+	disable_dma(dma->chan);
 
 	/* clear flip-flop to make sure 2-byte registers
 	 * get set correctly */
-	clear_dma_ff(channel);
+	clear_dma_ff(dma->chan);
 
 	/*  figure out how many points to read */
-	nbytes = devpriv->dma_transfer_size - get_dma_residue(channel);
+	nbytes = devpriv->dma_transfer_size - get_dma_residue(dma->chan);
 	nsamples = comedi_bytes_to_samples(s, nbytes);
 	nsamples = comedi_nsamples_left(s, nsamples);
 
-	munge_data(dev, buffer, nsamples);
-	comedi_buf_write_samples(s, buffer, nsamples);
+	munge_data(dev, dma->virt_addr, nsamples);
+	comedi_buf_write_samples(s, dma->virt_addr, nsamples);
 }
 
 /* flushes remaining data from board when external trigger has stopped acquisition
@@ -547,13 +547,13 @@ static void das1800_flush_dma(struct comedi_device *dev,
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
+	das1800_flush_dma_channel(dev, s, dma);
 
 	if (dual_dma) {
 		/*  switch to other channel and flush it */
 		devpriv->cur_dma = 1 - devpriv->cur_dma;
 		dma = &devpriv->dma_desc[devpriv->cur_dma];
-		das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
+		das1800_flush_dma_channel(dev, s, dma);
 	}
 
 	release_dma_lock(flags);
@@ -571,7 +571,7 @@ static void das1800_handle_dma(struct comedi_device *dev,
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
+	das1800_flush_dma_channel(dev, s, dma);
 	/*  re-enable  dma channel */
 	set_dma_addr(dma->chan, dma->hw_addr);
 	set_dma_count(dma->chan, devpriv->dma_transfer_size);

commit 99b21f22d2b6708bfe06507d5f8a6955766f8b27
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:45 2015 -0700

    staging: comedi: das1800: introduce das1800_free_dma()
    
    For aesthetics, introduce a helper function to free the DMA channels and
    allocated buffers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index dd46a919904a..1eb5eab52007 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1303,6 +1303,25 @@ static int das1800_init_dma(struct comedi_device *dev,
 	return 0;
 }
 
+static void das1800_free_dma(struct comedi_device *dev)
+{
+	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	for (i = 0; i < 2; i++) {
+		dma = &devpriv->dma_desc[i];
+		if (dma->chan)
+			free_dma(dma->chan);
+		if (dma->virt_addr)
+			dma_free_coherent(NULL, DMA_BUF_SIZE,
+					  dma->virt_addr, dma->hw_addr);
+	}
+}
+
 static int das1800_probe(struct comedi_device *dev)
 {
 	const struct das1800_board *board = dev->board_ptr;
@@ -1514,18 +1533,9 @@ static int das1800_attach(struct comedi_device *dev,
 static void das1800_detach(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct das1800_dma_desc *dma;
-	int i;
 
+	das1800_free_dma(dev);
 	if (devpriv) {
-		for (i = 0; i < 2; i++) {
-			dma = &devpriv->dma_desc[i];
-			if (dma->chan)
-				free_dma(dma->chan);
-			if (dma->virt_addr)
-				dma_free_coherent(NULL, DMA_BUF_SIZE,
-						  dma->virt_addr, dma->hw_addr);
-		}
 		kfree(devpriv->fifo_buf);
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);

commit a4b064ee4675686dfe31fcc54c3ec188141f6ee2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:44 2015 -0700

    staging: comedi: das1800: remove VIRT_TO_BUS dependancy
    
    Use dma_{alloc,free}_coherent() to allocate and free the DMA buffers.
    This removes the dependancy on VIRT_TO_BUS.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index df28d36aa580..dd46a919904a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -422,7 +422,8 @@ static const struct das1800_board das1800_boards[] = {
 
 struct das1800_dma_desc {
 	unsigned int chan;	/* DMA channel */
-	uint16_t *virt_addr;	/* virtual address of DMA buffer */
+	void *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 };
 
 struct das1800_private {
@@ -572,7 +573,7 @@ static void das1800_handle_dma(struct comedi_device *dev,
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
 	/*  re-enable  dma channel */
-	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_addr(dma->chan, dma->hw_addr);
 	set_dma_count(dma->chan, devpriv->dma_transfer_size);
 	enable_dma(dma->chan);
 	release_dma_lock(flags);
@@ -1013,7 +1014,7 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
 	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_addr(dma->chan, dma->hw_addr);
 	/*  set appropriate size of transfer */
 	set_dma_count(dma->chan, devpriv->dma_transfer_size);
 	enable_dma(dma->chan);
@@ -1024,7 +1025,7 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
 		clear_dma_ff(dma->chan);
-		set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+		set_dma_addr(dma->chan, dma->hw_addr);
 		/*  set appropriate size of transfer */
 		set_dma_count(dma->chan, devpriv->dma_transfer_size);
 		enable_dma(dma->chan);
@@ -1288,7 +1289,8 @@ static int das1800_init_dma(struct comedi_device *dev,
 		}
 		dma->chan = dma_chan[i];
 
-		dma->virt_addr = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+		dma->virt_addr = dma_alloc_coherent(NULL, DMA_BUF_SIZE,
+						    &dma->hw_addr, GFP_KERNEL);
 		if (!dma->virt_addr)
 			return -ENOMEM;
 
@@ -1520,7 +1522,9 @@ static void das1800_detach(struct comedi_device *dev)
 			dma = &devpriv->dma_desc[i];
 			if (dma->chan)
 				free_dma(dma->chan);
-			kfree(dma->virt_addr);
+			if (dma->virt_addr)
+				dma_free_coherent(NULL, DMA_BUF_SIZE,
+						  dma->virt_addr, dma->hw_addr);
 		}
 		kfree(devpriv->fifo_buf);
 		if (devpriv->iobase2)

commit 6e89008b06c344b49e27febdeb5fc7b84d35fb25
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:43 2015 -0700

    staging: comedi: das1800: tidy up das1800_init_dma()
    
    Refactor this function so that a for loop can be used to request and
    set up the two DMA descriptors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2d376fde2aad..df28d36aa580 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1228,15 +1228,24 @@ static int das1800_do_wbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
-			    unsigned int dma1)
+static int das1800_init_dma(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct das1800_private *devpriv = dev->private;
 	struct das1800_dma_desc *dma;
+	unsigned int *dma_chan;
 	unsigned long flags;
+	int i;
+
+	/*
+	 * it->options[2] is DMA channel 0
+	 * it->options[3] is DMA channel 1
+	 *
+	 * Encode the DMA channels into 2 digit hexadecimal for switch.
+	 */
+	dma_chan = &it->options[2];
 
-	/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
-	switch ((dma0 & 0x7) | (dma1 << 4)) {
+	switch ((dma_chan[0] & 0x7) | (dma_chan[1] << 4)) {
 	case 0x5:	/*  dma0 == 5 */
 		devpriv->dma_bits |= DMA_CH5;
 		break;
@@ -1265,33 +1274,24 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 		return -EINVAL;
 	}
 
-	dma = &devpriv->dma_desc[0];
-	if (request_dma(dma0, dev->driver->driver_name)) {
-		dev_err(dev->class_dev,
-			"failed to allocate dma channel %i\n", dma0);
-		return -EINVAL;
-	}
-	dma->chan = dma0;
-	dma->virt_addr = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-	if (!dma->virt_addr)
-		return -ENOMEM;
-	flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	set_dma_mode(dma->chan, DMA_MODE_READ);
-	release_dma_lock(flags);
+	for (i = 0; i < 2; i++) {
+		dma = &devpriv->dma_desc[i];
 
-	if (dma1) {
-		dma = &devpriv->dma_desc[1];
-		if (request_dma(dma1, dev->driver->driver_name)) {
+		if (dma_chan[i] == 0)
+			break;
+
+		if (request_dma(dma_chan[i], dev->board_name)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %i\n",
-				dma1);
+				dma_chan[i]);
 			return -EINVAL;
 		}
-		dma->chan = dma1;
+		dma->chan = dma_chan[i];
+
 		dma->virt_addr = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
 		if (!dma->virt_addr)
 			return -ENOMEM;
+
 		flags = claim_dma_lock();
 		disable_dma(dma->chan);
 		set_dma_mode(dma->chan, DMA_MODE_READ);
@@ -1366,8 +1366,6 @@ static int das1800_attach(struct comedi_device *dev,
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];
-	unsigned int dma0 = it->options[2];
-	unsigned int dma1 = it->options[3];
 	int board;
 	int ret;
 
@@ -1430,8 +1428,8 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	/* an irq and one dma channel is required to use dma */
-	if (dev->irq & dma0) {
-		ret = das1800_init_dma(dev, dma0, dma1);
+	if (dev->irq & it->options[2]) {
+		ret = das1800_init_dma(dev, it);
 		if (ret < 0)
 			return ret;
 	}

commit fd8aab1a9c4505dc410f189c81911f8d6a99c6fc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:42 2015 -0700

    staging: comedi: das1800: introduce struct das1800_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2e087b1b8ce1..2d376fde2aad 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -420,6 +420,11 @@ static const struct das1800_board das1800_boards[] = {
 	 },
 };
 
+struct das1800_dma_desc {
+	unsigned int chan;	/* DMA channel */
+	uint16_t *virt_addr;	/* virtual address of DMA buffer */
+};
+
 struct das1800_private {
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
@@ -427,12 +432,8 @@ struct das1800_private {
 	/* dma bits for control register b, stored so that dma can be
 	 * turned on and off */
 	int dma_bits;
-	unsigned int dma0;	/* dma channels used */
-	unsigned int dma1;
-	unsigned int dma_current;	/* dma channel currently in use */
-	uint16_t *ai_buf0;	/* pointers to dma buffers */
-	uint16_t *ai_buf1;
-	uint16_t *dma_current_buf;	/* pointer to dma buffer currently being used */
+	struct das1800_dma_desc dma_desc[2];
+	int cur_dma;
 	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
 	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
@@ -540,24 +541,18 @@ static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-				  devpriv->dma_current_buf);
+	das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
 
 	if (dual_dma) {
 		/*  switch to other channel and flush it */
-		if (devpriv->dma_current == devpriv->dma0) {
-			devpriv->dma_current = devpriv->dma1;
-			devpriv->dma_current_buf = devpriv->ai_buf1;
-		} else {
-			devpriv->dma_current = devpriv->dma0;
-			devpriv->dma_current_buf = devpriv->ai_buf0;
-		}
-		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-					  devpriv->dma_current_buf);
+		devpriv->cur_dma = 1 - devpriv->cur_dma;
+		dma = &devpriv->dma_desc[devpriv->cur_dma];
+		das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
 	}
 
 	release_dma_lock(flags);
@@ -570,47 +565,43 @@ static void das1800_handle_dma(struct comedi_device *dev,
 			       struct comedi_subdevice *s, unsigned int status)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-				  devpriv->dma_current_buf);
+	das1800_flush_dma_channel(dev, s, dma->chan, dma->virt_addr);
 	/*  re-enable  dma channel */
-	set_dma_addr(devpriv->dma_current,
-		     virt_to_bus(devpriv->dma_current_buf));
-	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
-	enable_dma(devpriv->dma_current);
+	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_count(dma->chan, devpriv->dma_transfer_size);
+	enable_dma(dma->chan);
 	release_dma_lock(flags);
 
 	if (status & DMATC) {
 		/*  clear DMATC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
 		/*  switch dma channels for next time, if appropriate */
-		if (dual_dma) {
-			/*  read data from the other channel next time */
-			if (devpriv->dma_current == devpriv->dma0) {
-				devpriv->dma_current = devpriv->dma1;
-				devpriv->dma_current_buf = devpriv->ai_buf1;
-			} else {
-				devpriv->dma_current = devpriv->dma0;
-				devpriv->dma_current_buf = devpriv->ai_buf0;
-			}
-		}
+		if (dual_dma)
+			devpriv->cur_dma = 1 - devpriv->cur_dma;
 	}
 }
 
 static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma;
+	int i;
 
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
-	if (devpriv->dma0)
-		disable_dma(devpriv->dma0);
-	if (devpriv->dma1)
-		disable_dma(devpriv->dma1);
+
+	for (i = 0; i < 2; i++) {
+		dma = &devpriv->dma_desc[i];
+		if (dma->chan)
+			disable_dma(dma->chan);
+	}
+
 	return 0;
 }
 
@@ -1006,35 +997,37 @@ static unsigned int suggest_transfer_size(const struct comedi_cmd *cmd)
 static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma = &devpriv->dma_desc[0];
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
 		return;
 
+	devpriv->cur_dma = 0;
+
 	/* determine a reasonable dma transfer size */
 	devpriv->dma_transfer_size = suggest_transfer_size(cmd);
 	lock_flags = claim_dma_lock();
-	disable_dma(devpriv->dma0);
+	disable_dma(dma->chan);
 	/* clear flip-flop to make sure 2-byte registers for
 	 * count and address get set correctly */
-	clear_dma_ff(devpriv->dma0);
-	set_dma_addr(devpriv->dma0, virt_to_bus(devpriv->ai_buf0));
+	clear_dma_ff(dma->chan);
+	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
 	/*  set appropriate size of transfer */
-	set_dma_count(devpriv->dma0, devpriv->dma_transfer_size);
-	devpriv->dma_current = devpriv->dma0;
-	devpriv->dma_current_buf = devpriv->ai_buf0;
-	enable_dma(devpriv->dma0);
+	set_dma_count(dma->chan, devpriv->dma_transfer_size);
+	enable_dma(dma->chan);
 	/*  set up dual dma if appropriate */
 	if (dual_dma) {
-		disable_dma(devpriv->dma1);
+		dma = &devpriv->dma_desc[1];
+		disable_dma(dma->chan);
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
-		clear_dma_ff(devpriv->dma1);
-		set_dma_addr(devpriv->dma1, virt_to_bus(devpriv->ai_buf1));
+		clear_dma_ff(dma->chan);
+		set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
 		/*  set appropriate size of transfer */
-		set_dma_count(devpriv->dma1, devpriv->dma_transfer_size);
-		enable_dma(devpriv->dma1);
+		set_dma_count(dma->chan, devpriv->dma_transfer_size);
+		enable_dma(dma->chan);
 	}
 	release_dma_lock(lock_flags);
 }
@@ -1239,6 +1232,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			    unsigned int dma1)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma;
 	unsigned long flags;
 
 	/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
@@ -1270,40 +1264,39 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			"dma 5,6 / 6,7 / or 7,5\n");
 		return -EINVAL;
 	}
+
+	dma = &devpriv->dma_desc[0];
 	if (request_dma(dma0, dev->driver->driver_name)) {
 		dev_err(dev->class_dev,
 			"failed to allocate dma channel %i\n", dma0);
 		return -EINVAL;
 	}
-	devpriv->dma0 = dma0;
-	devpriv->dma_current = dma0;
+	dma->chan = dma0;
+	dma->virt_addr = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+	if (!dma->virt_addr)
+		return -ENOMEM;
+	flags = claim_dma_lock();
+	disable_dma(dma->chan);
+	set_dma_mode(dma->chan, DMA_MODE_READ);
+	release_dma_lock(flags);
+
 	if (dma1) {
+		dma = &devpriv->dma_desc[1];
 		if (request_dma(dma1, dev->driver->driver_name)) {
 			dev_err(dev->class_dev,
 				"failed to allocate dma channel %i\n",
 				dma1);
 			return -EINVAL;
 		}
-		devpriv->dma1 = dma1;
-	}
-	devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-	if (devpriv->ai_buf0 == NULL)
-		return -ENOMEM;
-	devpriv->dma_current_buf = devpriv->ai_buf0;
-	if (dma1) {
-		devpriv->ai_buf1 =
-			kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-		if (devpriv->ai_buf1 == NULL)
+		dma->chan = dma1;
+		dma->virt_addr = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+		if (!dma->virt_addr)
 			return -ENOMEM;
+		flags = claim_dma_lock();
+		disable_dma(dma->chan);
+		set_dma_mode(dma->chan, DMA_MODE_READ);
+		release_dma_lock(flags);
 	}
-	flags = claim_dma_lock();
-	disable_dma(devpriv->dma0);
-	set_dma_mode(devpriv->dma0, DMA_MODE_READ);
-	if (dma1) {
-		disable_dma(devpriv->dma1);
-		set_dma_mode(devpriv->dma1, DMA_MODE_READ);
-	}
-	release_dma_lock(flags);
 
 	return 0;
 }
@@ -1521,14 +1514,16 @@ static int das1800_attach(struct comedi_device *dev,
 static void das1800_detach(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
+	struct das1800_dma_desc *dma;
+	int i;
 
 	if (devpriv) {
-		if (devpriv->dma0)
-			free_dma(devpriv->dma0);
-		if (devpriv->dma1)
-			free_dma(devpriv->dma1);
-		kfree(devpriv->ai_buf0);
-		kfree(devpriv->ai_buf1);
+		for (i = 0; i < 2; i++) {
+			dma = &devpriv->dma_desc[i];
+			if (dma->chan)
+				free_dma(dma->chan);
+			kfree(dma->virt_addr);
+		}
 		kfree(devpriv->fifo_buf);
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);

commit 1f190a73590ce0070d6a5b6ee0d50e076aafebd6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:41 2015 -0700

    staging: comedi: das1800: separate AI FIFO bounce buffer from DMA buffer
    
    This driver can use DMA or the hardware FIFO to read analog input samples.
    When DMA is enabled it's also possible for some async commands to cause
    DMA to be disabled and the FIFO is used instead.
    
    Currently the first DMA channels buffer is used for the bounce buffer
    when using the FIFO. For aesthetics, add a new member to the private
    data and use that for the FIFO bounce buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index c415b578f5fb..2e087b1b8ce1 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -433,6 +433,7 @@ struct das1800_private {
 	uint16_t *ai_buf0;	/* pointers to dma buffers */
 	uint16_t *ai_buf1;
 	uint16_t *dma_current_buf;	/* pointer to dma buffer currently being used */
+	uint16_t *fifo_buf;	/* bounce buffer for analog input FIFO */
 	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	unsigned short ao_update_bits;	/* remembers the last write to the
@@ -480,9 +481,9 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 	struct das1800_private *devpriv = dev->private;
 	unsigned int nsamples = comedi_nsamples_left(s, FIFO_SIZE / 2);
 
-	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, nsamples);
-	munge_data(dev, devpriv->ai_buf0, nsamples);
-	comedi_buf_write_samples(s, devpriv->ai_buf0, nsamples);
+	insw(dev->iobase + DAS1800_FIFO, devpriv->fifo_buf, nsamples);
+	munge_data(dev, devpriv->fifo_buf, nsamples);
+	comedi_buf_write_samples(s, devpriv->fifo_buf, nsamples);
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
@@ -1442,12 +1443,9 @@ static int das1800_attach(struct comedi_device *dev,
 			return ret;
 	}
 
-	if (devpriv->ai_buf0 == NULL) {
-		devpriv->ai_buf0 =
-		    kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
-		if (devpriv->ai_buf0 == NULL)
-			return -ENOMEM;
-	}
+	devpriv->fifo_buf = kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+	if (!devpriv->fifo_buf)
+		return -ENOMEM;
 
 	ret = comedi_alloc_subdevices(dev, 4);
 	if (ret)
@@ -1531,6 +1529,7 @@ static void das1800_detach(struct comedi_device *dev)
 			free_dma(devpriv->dma1);
 		kfree(devpriv->ai_buf0);
 		kfree(devpriv->ai_buf1);
+		kfree(devpriv->fifo_buf);
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);
 	}

commit f19810d21becb4f3a92ce8d0b7cc2a0657a153de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:55:40 2015 -0700

    staging: comedi: das1800: reduce indent level of das1800_init_dma()
    
    An IRQ and at least one DMA channel are required to use DMA with this driver.
    Move the check to the caller to reduce the indent level of this function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index be825d21a185..c415b578f5fb 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1240,72 +1240,70 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 	struct das1800_private *devpriv = dev->private;
 	unsigned long flags;
 
-	/*  need an irq to do dma */
-	if (dev->irq && dma0) {
-		/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
-		switch ((dma0 & 0x7) | (dma1 << 4)) {
-		case 0x5:	/*  dma0 == 5 */
-			devpriv->dma_bits |= DMA_CH5;
-			break;
-		case 0x6:	/*  dma0 == 6 */
-			devpriv->dma_bits |= DMA_CH6;
-			break;
-		case 0x7:	/*  dma0 == 7 */
-			devpriv->dma_bits |= DMA_CH7;
-			break;
-		case 0x65:	/*  dma0 == 5, dma1 == 6 */
-			devpriv->dma_bits |= DMA_CH5_CH6;
-			break;
-		case 0x76:	/*  dma0 == 6, dma1 == 7 */
-			devpriv->dma_bits |= DMA_CH6_CH7;
-			break;
-		case 0x57:	/*  dma0 == 7, dma1 == 5 */
-			devpriv->dma_bits |= DMA_CH7_CH5;
-			break;
-		default:
-			dev_err(dev->class_dev,
-				"only supports dma channels 5 through 7\n");
-			dev_err(dev->class_dev,
-				"Dual dma only allows the following combinations:\n");
-			dev_err(dev->class_dev,
-				"dma 5,6 / 6,7 / or 7,5\n");
-			return -EINVAL;
-		}
-		if (request_dma(dma0, dev->driver->driver_name)) {
+	/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
+	switch ((dma0 & 0x7) | (dma1 << 4)) {
+	case 0x5:	/*  dma0 == 5 */
+		devpriv->dma_bits |= DMA_CH5;
+		break;
+	case 0x6:	/*  dma0 == 6 */
+		devpriv->dma_bits |= DMA_CH6;
+		break;
+	case 0x7:	/*  dma0 == 7 */
+		devpriv->dma_bits |= DMA_CH7;
+		break;
+	case 0x65:	/*  dma0 == 5, dma1 == 6 */
+		devpriv->dma_bits |= DMA_CH5_CH6;
+		break;
+	case 0x76:	/*  dma0 == 6, dma1 == 7 */
+		devpriv->dma_bits |= DMA_CH6_CH7;
+		break;
+	case 0x57:	/*  dma0 == 7, dma1 == 5 */
+		devpriv->dma_bits |= DMA_CH7_CH5;
+		break;
+	default:
+		dev_err(dev->class_dev,
+			"only supports dma channels 5 through 7\n");
+		dev_err(dev->class_dev,
+			"Dual dma only allows the following combinations:\n");
+		dev_err(dev->class_dev,
+			"dma 5,6 / 6,7 / or 7,5\n");
+		return -EINVAL;
+	}
+	if (request_dma(dma0, dev->driver->driver_name)) {
+		dev_err(dev->class_dev,
+			"failed to allocate dma channel %i\n", dma0);
+		return -EINVAL;
+	}
+	devpriv->dma0 = dma0;
+	devpriv->dma_current = dma0;
+	if (dma1) {
+		if (request_dma(dma1, dev->driver->driver_name)) {
 			dev_err(dev->class_dev,
-				"failed to allocate dma channel %i\n", dma0);
+				"failed to allocate dma channel %i\n",
+				dma1);
 			return -EINVAL;
 		}
-		devpriv->dma0 = dma0;
-		devpriv->dma_current = dma0;
-		if (dma1) {
-			if (request_dma(dma1, dev->driver->driver_name)) {
-				dev_err(dev->class_dev,
-					"failed to allocate dma channel %i\n",
-					dma1);
-				return -EINVAL;
-			}
-			devpriv->dma1 = dma1;
-		}
-		devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-		if (devpriv->ai_buf0 == NULL)
+		devpriv->dma1 = dma1;
+	}
+	devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+	if (devpriv->ai_buf0 == NULL)
+		return -ENOMEM;
+	devpriv->dma_current_buf = devpriv->ai_buf0;
+	if (dma1) {
+		devpriv->ai_buf1 =
+			kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+		if (devpriv->ai_buf1 == NULL)
 			return -ENOMEM;
-		devpriv->dma_current_buf = devpriv->ai_buf0;
-		if (dma1) {
-			devpriv->ai_buf1 =
-			    kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-			if (devpriv->ai_buf1 == NULL)
-				return -ENOMEM;
-		}
-		flags = claim_dma_lock();
-		disable_dma(devpriv->dma0);
-		set_dma_mode(devpriv->dma0, DMA_MODE_READ);
-		if (dma1) {
-			disable_dma(devpriv->dma1);
-			set_dma_mode(devpriv->dma1, DMA_MODE_READ);
-		}
-		release_dma_lock(flags);
 	}
+	flags = claim_dma_lock();
+	disable_dma(devpriv->dma0);
+	set_dma_mode(devpriv->dma0, DMA_MODE_READ);
+	if (dma1) {
+		disable_dma(devpriv->dma1);
+		set_dma_mode(devpriv->dma1, DMA_MODE_READ);
+	}
+	release_dma_lock(flags);
+
 	return 0;
 }
 
@@ -1437,9 +1435,12 @@ static int das1800_attach(struct comedi_device *dev,
 		}
 	}
 
-	ret = das1800_init_dma(dev, dma0, dma1);
-	if (ret < 0)
-		return ret;
+	/* an irq and one dma channel is required to use dma */
+	if (dev->irq & dma0) {
+		ret = das1800_init_dma(dev, dma0, dma1);
+		if (ret < 0)
+			return ret;
+	}
 
 	if (devpriv->ai_buf0 == NULL) {
 		devpriv->ai_buf0 =

commit 605d76f6eb007aeb1dbcb7429adde73f2ef1fd9f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:41 2014 -0700

    staging: comedi: das1800: use comedi_async 'scans_done' to detect EOA
    
    Remove the private data member 'count' and use the comedi_async 'scans_done'
    member to detect the end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    add to the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 03b1ff9de92c..be825d21a185 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -421,7 +421,6 @@ static const struct das1800_board das1800_boards[] = {
 };
 
 struct das1800_private {
-	unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
 	int irq_dma_bits;	/* bits for control register b */
@@ -479,41 +478,33 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	int numPoints = 0;	/* number of points to read */
-	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int nsamples = comedi_nsamples_left(s, FIFO_SIZE / 2);
 
-	numPoints = FIFO_SIZE / 2;
-	/* if we only need some of the points */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->count < numPoints)
-		numPoints = devpriv->count;
-	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
-	munge_data(dev, devpriv->ai_buf0, numPoints);
-	comedi_buf_write_samples(s, devpriv->ai_buf0, numPoints);
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count -= numPoints;
+	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, nsamples);
+	munge_data(dev, devpriv->ai_buf0, nsamples);
+	comedi_buf_write_samples(s, devpriv->ai_buf0, nsamples);
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
-	struct das1800_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned short dpnt;
 	int unipolar;
-	struct comedi_cmd *cmd = &s->async->cmd;
 
 	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
 
 	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
-		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
-			break;
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
 		/* convert to unsigned type if we are in a bipolar mode */
 		if (!unipolar)
 			;
 		dpnt = munge_bipolar_sample(dev, dpnt);
 		comedi_buf_write_samples(s, &dpnt, 1);
-		if (cmd->stop_src == TRIG_COUNT)
-			devpriv->count--;
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    s->async->scans_done >= cmd->stop_arg)
+			break;
 	}
 }
 
@@ -524,8 +515,8 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      unsigned int channel, uint16_t *buffer)
 {
 	struct das1800_private *devpriv = dev->private;
-	unsigned int num_bytes, num_samples;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int nbytes;
+	unsigned int nsamples;
 
 	disable_dma(channel);
 
@@ -534,17 +525,12 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	clear_dma_ff(channel);
 
 	/*  figure out how many points to read */
-	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
-	num_samples = comedi_bytes_to_samples(s, num_bytes);
-
-	/* if we only need some of the points */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)
-		num_samples = devpriv->count;
+	nbytes = devpriv->dma_transfer_size - get_dma_residue(channel);
+	nsamples = comedi_bytes_to_samples(s, nbytes);
+	nsamples = comedi_nsamples_left(s, nsamples);
 
-	munge_data(dev, buffer, num_samples);
-	comedi_buf_write_samples(s, buffer, num_samples);
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count -= num_samples;
+	munge_data(dev, buffer, nsamples);
+	comedi_buf_write_samples(s, buffer, nsamples);
 }
 
 /* flushes remaining data from board when external trigger has stopped acquisition
@@ -668,7 +654,8 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		else
 			das1800_handle_fifo_not_empty(dev, s);
 		async->events |= COMEDI_CB_EOA;
-	} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {	/*  stop_src TRIG_COUNT */
+	} else if (cmd->stop_src == TRIG_COUNT &&
+		   async->scans_done >= cmd->stop_arg) {
 		async->events |= COMEDI_CB_EOA;
 	}
 
@@ -1100,9 +1087,6 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 		/*  interrupt fifo half full */
 		devpriv->irq_dma_bits |= FIMD;
 	}
-	/*  determine how many conversions we need */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
 	das1800_cancel(dev, s);
 

commit 5035a96f3640ee4705f69287726bfcc598212717
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:30 2014 -0700

    staging: comedi: das1800: use sample manipulation helpers
    
    Use the recently added sample manipulation helpers to remove the hardcoded
    assumption of the sample size.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index bf8bfcf7034d..03b1ff9de92c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -535,7 +535,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 
 	/*  figure out how many points to read */
 	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
-	num_samples = num_bytes / sizeof(short);
+	num_samples = comedi_bytes_to_samples(s, num_bytes);
 
 	/* if we only need some of the points */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)

commit 453fd2b395799fa2e83e3e926ff7fee810d26f92
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Oct 30 11:19:36 2014 -0700

    staging: comedi: drivers: digital output subdevices do not need SDF_READABLE
    
    The SDF_READABLE flag is not necessary for digital output subdevices. For
    consistency, remove this flag from the comedi drivers that set it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 246a18648223..bf8bfcf7034d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1513,7 +1513,7 @@ static int das1800_attach(struct comedi_device *dev,
 	/* do */
 	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->subdev_flags = SDF_WRITABLE;
 	s->n_chan = thisboard->do_n_chan;
 	s->maxdata = 1;
 	s->range_table = &range_digital;

commit 880f582068ab8dc92c00dcea409c26e7ddaca675
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:32 2014 -0700

    staging: comedi: das1800: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer. That
    function will handle single and multi samples writes by determining the number
    of bytes to add based on the number of samples and the bytes_per_sample().
    
    Also, remove the unnecessary COMEDI_CB_BLOCK event. comedi_buf_write_samples()
    will automatically add that event after adding the samples to the async
    buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 7b0b65e883f6..246a18648223 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -488,8 +488,7 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 		numPoints = devpriv->count;
 	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
 	munge_data(dev, devpriv->ai_buf0, numPoints);
-	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
-				  numPoints * sizeof(devpriv->ai_buf0[0]));
+	comedi_buf_write_samples(s, devpriv->ai_buf0, numPoints);
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= numPoints;
 }
@@ -512,7 +511,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 		if (!unipolar)
 			;
 		dpnt = munge_bipolar_sample(dev, dpnt);
-		cfc_write_to_buffer(s, dpnt);
+		comedi_buf_write_samples(s, &dpnt, 1);
 		if (cmd->stop_src == TRIG_COUNT)
 			devpriv->count--;
 	}
@@ -543,7 +542,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 		num_samples = devpriv->count;
 
 	munge_data(dev, buffer, num_samples);
-	cfc_write_array_to_buffer(s, buffer, num_bytes);
+	comedi_buf_write_samples(s, buffer, num_samples);
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= num_samples;
 }
@@ -649,7 +648,6 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		das1800_handle_fifo_not_empty(dev, s);
 	}
 
-	async->events |= COMEDI_CB_BLOCK;
 	/* if the card's fifo has overflowed */
 	if (status & OVF) {
 		/*  clear OVF interrupt bit */

commit fe43b8f5ded501013c61924efcbbe836d73a4ad6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:23 2014 -0700

    staging: comedi: das1800: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index a53d87ce9b14..7b0b65e883f6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -656,7 +656,7 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
 		dev_err(dev->class_dev, "FIFO overflow\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		cfc_handle_events(dev, s);
+		comedi_handle_events(dev, s);
 		return;
 	}
 	/*  stop taking data if appropriate */
@@ -674,7 +674,7 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		async->events |= COMEDI_CB_EOA;
 	}
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static int das1800_ai_poll(struct comedi_device *dev,

commit e0dd99bd12d883062d42cd2a912175b0525974da
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:28 2014 +0100

    staging: comedi: das1800: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9d0150d44d76..a53d87ce9b14 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -453,7 +453,7 @@ static const struct comedi_lrange range_ao_2 = {
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
-	const struct das1800_board *thisboard = comedi_board(dev);
+	const struct das1800_board *thisboard = dev->board_ptr;
 
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
@@ -773,7 +773,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
-	const struct das1800_board *thisboard = comedi_board(dev);
+	const struct das1800_board *thisboard = dev->board_ptr;
 	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -1136,7 +1136,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct das1800_board *thisboard = comedi_board(dev);
+	const struct das1800_board *thisboard = dev->board_ptr;
 	int i, n;
 	int chan, range, aref, chan_range;
 	int timeout = 1000;
@@ -1200,7 +1200,7 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	const struct das1800_board *thisboard = comedi_board(dev);
+	const struct das1800_board *thisboard = dev->board_ptr;
 	struct das1800_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
@@ -1329,7 +1329,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 
 static int das1800_probe(struct comedi_device *dev)
 {
-	const struct das1800_board *board = comedi_board(dev);
+	const struct das1800_board *board = dev->board_ptr;
 	int index;
 	int id;
 
@@ -1412,7 +1412,7 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	dev->board_ptr = das1800_boards + board;
-	thisboard = comedi_board(dev);
+	thisboard = dev->board_ptr;
 	dev->board_name = thisboard->name;
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */

commit 07600725059e1a1f6d27b1a310dfc73244f4afb3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:51 2014 +0100

    staging: comedi: das1800: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 951292d2c6c5..9d0150d44d76 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -731,15 +731,15 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int flags)
 		convert_arg = 64000;
 
 	/*  the conversion time must be an integral number of microseconds */
-	switch (flags & TRIG_ROUND_MASK) {
-	case TRIG_ROUND_NEAREST:
+	switch (flags & CMDF_ROUND_MASK) {
+	case CMDF_ROUND_NEAREST:
 	default:
 		micro_sec = (convert_arg + 500) / 1000;
 		break;
-	case TRIG_ROUND_DOWN:
+	case CMDF_ROUND_DOWN:
 		micro_sec = convert_arg / 1000;
 		break;
-	case TRIG_ROUND_UP:
+	case CMDF_ROUND_UP:
 		micro_sec = (convert_arg - 1) / 1000 + 1;
 		break;
 	}

commit a28f42f3eb2dc2ab53d240c58503cffc0fd165ad
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:37 2014 +0100

    staging: comedi: das1800: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f9e4f72e3769..951292d2c6c5 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1088,14 +1088,14 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	const struct comedi_cmd *cmd = &async->cmd;
 
-	/* disable dma on TRIG_WAKE_EOS, or CMDF_PRIORITY
+	/* disable dma on CMDF_WAKE_EOS, or CMDF_PRIORITY
 	 * (because dma in handler is unsafe at hard real-time priority) */
-	if (cmd->flags & (TRIG_WAKE_EOS | CMDF_PRIORITY))
+	if (cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY))
 		devpriv->irq_dma_bits &= ~DMA_ENABLED;
 	else
 		devpriv->irq_dma_bits |= devpriv->dma_bits;
-	/*  interrupt on end of conversion for TRIG_WAKE_EOS */
-	if (cmd->flags & TRIG_WAKE_EOS) {
+	/*  interrupt on end of conversion for CMDF_WAKE_EOS */
+	if (cmd->flags & CMDF_WAKE_EOS) {
 		/*  interrupt fifo not empty */
 		devpriv->irq_dma_bits &= ~FIMD;
 	} else {

commit 6a8df3a9e8179cfcc7bbced9ed89d222e7ac5c82
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:26 2014 +0100

    staging: comedi: das1800: use CMDF_PRIORITY
    
    Replace use of `TRIG_RT` command flag with the equivalent flag
    `CMDF_PRIORITY`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0cfca33965f6..f9e4f72e3769 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1088,9 +1088,9 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	const struct comedi_cmd *cmd = &async->cmd;
 
-	/* disable dma on TRIG_WAKE_EOS, or TRIG_RT
+	/* disable dma on TRIG_WAKE_EOS, or CMDF_PRIORITY
 	 * (because dma in handler is unsafe at hard real-time priority) */
-	if (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT))
+	if (cmd->flags & (TRIG_WAKE_EOS | CMDF_PRIORITY))
 		devpriv->irq_dma_bits &= ~DMA_ENABLED;
 	else
 		devpriv->irq_dma_bits |= devpriv->dma_bits;

commit bbedf943f2380e4d0d5c00b196791ddc484f3b6c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 13:29:57 2014 -0700

    staging: comedi: das1800: tidy up das1800_probe()
    
    The (*attach) of driver calls this function to probe the 'id' of the
    hardware to verify that a valid boardinfo has been selected by the
    user.
    
    The dev_dbg() messages when the boardinfo is valid is just added
    noise. The printk messages when the id does not match the boardinfo
    does have some value.
    
    Refactor the function to remove the noise and use a common message
    for the "(probed, not recommended)" message.
    
    Convert the printk() messages to dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e4234292b1f7..0cfca33965f6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1329,77 +1329,60 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 
 static int das1800_probe(struct comedi_device *dev)
 {
+	const struct das1800_board *board = comedi_board(dev);
+	int index;
 	int id;
-	int board;
 
-	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
-	board = ((struct das1800_board *)dev->board_ptr) - das1800_boards;
+	/* calc the offset to the boardinfo that was found by the core */
+	index = board - das1800_boards;
 
+	/* verify that the board id matches the boardinfo */
+	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;
 	switch (id) {
 	case 0x3:
-		if (board == das1801st_da || board == das1802st_da ||
-		    board == das1701st_da || board == das1702st_da) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800st-da series\n");
-		return das1801st;
+		if (index == das1801st_da || index == das1802st_da ||
+		    index == das1701st_da || index == das1702st_da)
+			return index;
+		index = das1801st;
+		break;
 	case 0x4:
-		if (board == das1802hr_da || board == das1702hr_da) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1802hr-da\n");
-		return das1802hr;
+		if (index == das1802hr_da || index == das1702hr_da)
+			return index;
+		index = das1802hr;
+		break;
 	case 0x5:
-		if (board == das1801ao || board == das1802ao ||
-		    board == das1701ao || board == das1702ao) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800ao series\n");
-		return das1801ao;
+		if (index == das1801ao || index == das1802ao ||
+		    index == das1701ao || index == das1702ao)
+			return index;
+		index = das1801ao;
+		break;
 	case 0x6:
-		if (board == das1802hr || board == das1702hr) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1802hr\n");
-		return das1802hr;
+		if (index == das1802hr || index == das1702hr)
+			return index;
+		index = das1802hr;
+		break;
 	case 0x7:
-		if (board == das1801st || board == das1802st ||
-		    board == das1701st || board == das1702st) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800st series\n");
-		return das1801st;
+		if (index == das1801st || index == das1802st ||
+		    index == das1701st || index == das1702st)
+			return index;
+		index = das1801st;
+		break;
 	case 0x8:
-		if (board == das1801hc || board == das1802hc) {
-			dev_dbg(dev->class_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800hc series\n");
-		return das1801hc;
+		if (index == das1801hc || index == das1802hc)
+			return index;
+		index = das1801hc;
+		break;
 	default:
-		printk
-		    (" Board model: probe returned 0x%x (unknown, please report)\n",
-		     id);
-		return board;
+		dev_err(dev->class_dev,
+			"Board model: probe returned 0x%x (unknown, please report)\n",
+			id);
+		break;
 	}
-	return -1;
+	dev_err(dev->class_dev,
+		"Board model (probed, not recommended): %s series\n",
+		das1800_boards[index].name);
+
+	return index;
 }
 
 static int das1800_attach(struct comedi_device *dev,

commit 6d65caa5214718cb21a154cdc5bbe0cf72873ef0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:42 2014 -0700

    staging: comedi: das1800: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e9c24d050a26..e4234292b1f7 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -654,7 +654,7 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	if (status & OVF) {
 		/*  clear OVF interrupt bit */
 		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
-		comedi_error(dev, "DAS1800 FIFO overflow");
+		dev_err(dev->class_dev, "FIFO overflow\n");
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
 		cfc_handle_events(dev, s);
 		return;
@@ -696,7 +696,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 	unsigned int status;
 
 	if (!dev->attached) {
-		comedi_error(dev, "premature interrupt");
+		dev_err(dev->class_dev, "premature interrupt\n");
 		return IRQ_HANDLED;
 	}
 
@@ -1179,7 +1179,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 				break;
 		}
 		if (i == timeout) {
-			comedi_error(dev, "timeout");
+			dev_err(dev->class_dev, "timeout\n");
 			n = -ETIME;
 			goto exit;
 		}

commit 04a4da61a14f4652c28d62216359347851f67523
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:22:50 2014 -0700

    staging: comedi: das1800: remove 'volatile' from private data
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index c3561ff8ae2b..e9c24d050a26 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -421,7 +421,7 @@ static const struct das1800_board das1800_boards[] = {
 };
 
 struct das1800_private {
-	volatile unsigned int count;	/* number of data points left to be taken */
+	unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
 	int irq_dma_bits;	/* bits for control register b */
@@ -430,7 +430,7 @@ struct das1800_private {
 	int dma_bits;
 	unsigned int dma0;	/* dma channels used */
 	unsigned int dma1;
-	volatile unsigned int dma_current;	/* dma channel currently in use */
+	unsigned int dma_current;	/* dma channel currently in use */
 	uint16_t *ai_buf0;	/* pointers to dma buffers */
 	uint16_t *ai_buf1;
 	uint16_t *dma_current_buf;	/* pointer to dma buffer currently being used */

commit bb905ab1f8731c387c427370737ca60c4ce19ba4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 11:01:56 2014 -0700

    staging: comedi: das1800: checkpatch.pl cleanup (void function return)
    
    Fix the checkpatch.pl warning:
    
    WARNING: void function return statements are not generally useful
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d89512ef7484..c3561ff8ae2b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -492,7 +492,6 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 				  numPoints * sizeof(devpriv->ai_buf0[0]));
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= numPoints;
-	return;
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
@@ -517,8 +516,6 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 		if (cmd->stop_src == TRIG_COUNT)
 			devpriv->count--;
 	}
-
-	return;
 }
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
@@ -549,8 +546,6 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	cfc_write_array_to_buffer(s, buffer, num_bytes);
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= num_samples;
-
-	return;
 }
 
 /* flushes remaining data from board when external trigger has stopped acquisition
@@ -583,8 +578,6 @@ static void das1800_flush_dma(struct comedi_device *dev,
 
 	/*  get any remaining samples in fifo */
 	das1800_handle_fifo_not_empty(dev, s);
-
-	return;
 }
 
 static void das1800_handle_dma(struct comedi_device *dev,
@@ -619,8 +612,6 @@ static void das1800_handle_dma(struct comedi_device *dev,
 			}
 		}
 	}
-
-	return;
 }
 
 static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
@@ -1060,8 +1051,6 @@ static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 		enable_dma(devpriv->dma1);
 	}
 	release_dma_lock(lock_flags);
-
-	return;
 }
 
 /* programs channel/gain list into card */
@@ -1088,8 +1077,6 @@ static void program_chanlist(struct comedi_device *dev,
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
-
-	return;
 }
 
 /* analog input do_cmd */

commit f8d17129540d08751e8b530a276c91cca711172b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:25 2014 -0700

    staging: comedi: das1800: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index b2f8391d5de1..d89512ef7484 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1301,7 +1301,6 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			dev_err(dev->class_dev,
 				"dma 5,6 / 6,7 / or 7,5\n");
 			return -EINVAL;
-			break;
 		}
 		if (request_dma(dma0, dev->driver->driver_name)) {
 			dev_err(dev->class_dev,
@@ -1360,7 +1359,6 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1800st-da series\n");
 		return das1801st;
-		break;
 	case 0x4:
 		if (board == das1802hr_da || board == das1702hr_da) {
 			dev_dbg(dev->class_dev, "Board model: %s\n",
@@ -1370,7 +1368,6 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1802hr-da\n");
 		return das1802hr;
-		break;
 	case 0x5:
 		if (board == das1801ao || board == das1802ao ||
 		    board == das1701ao || board == das1702ao) {
@@ -1381,7 +1378,6 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1800ao series\n");
 		return das1801ao;
-		break;
 	case 0x6:
 		if (board == das1802hr || board == das1702hr) {
 			dev_dbg(dev->class_dev, "Board model: %s\n",
@@ -1391,7 +1387,6 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1802hr\n");
 		return das1802hr;
-		break;
 	case 0x7:
 		if (board == das1801st || board == das1802st ||
 		    board == das1701st || board == das1702st) {
@@ -1402,7 +1397,6 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1800st series\n");
 		return das1801st;
-		break;
 	case 0x8:
 		if (board == das1801hc || board == das1802hc) {
 			dev_dbg(dev->class_dev, "Board model: %s\n",
@@ -1412,13 +1406,11 @@ static int das1800_probe(struct comedi_device *dev)
 		printk
 		    (" Board model (probed, not recommended): das-1800hc series\n");
 		return das1801hc;
-		break;
 	default:
 		printk
 		    (" Board model: probe returned 0x%x (unknown, please report)\n",
 		     id);
 		return board;
-		break;
 	}
 	return -1;
 }

commit f4f3f7cf27e7ae015672b59ec40c7deabeaf5d2e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 10:58:28 2014 -0700

    staging: comedi: introduce comedi_buf_n_bytes_ready()
    
    Introduce an inline helper to return the number of bytes that are
    ready to read from the comedi_async buffer. Use the helper in the
    comedi drivers that currently do the calculation as part of the
    (*poll) operation.
    
    Also, use the helper in comedi_fops where the calculation is used as
    part of the subdevice going nonbusy.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 859519026c4c..b2f8391d5de1 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -696,7 +696,7 @@ static int das1800_ai_poll(struct comedi_device *dev,
 	das1800_ai_handler(dev);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	return s->async->buf_write_count - s->async->buf_read_count;
+	return comedi_buf_n_bytes_ready(s);
 }
 
 static irqreturn_t das1800_interrupt(int irq, void *d)

commit d1462b9430d8c7e2e17c807116f2e24b3a81cd87
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:51 2014 -0700

    staging: comedi: das1800: use comedi_cmd pointer
    
    Use the local variable to access the comedi_cmd as a pointer instead
    of getting to it from the comedi_subdevice pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index ba357b6ec127..859519026c4c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -547,7 +547,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 
 	munge_data(dev, buffer, num_samples);
 	cfc_write_array_to_buffer(s, buffer, num_bytes);
-	if (s->async->cmd.stop_src == TRIG_COUNT)
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= num_samples;
 
 	return;

commit 1265c22fc8575e857f0a0573db263b507988f420
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:32 2014 -0700

    staging: comedi: das1800: don't calc pacer divisors twice
    
    The analog input async command can use the pacer for the scan_begin_src
    or the convert_src. The (*do_cmdtest) calculates the divisors when
    validating the cmd argument.
    
    There is no reason to recalc the divisors in the (*do_cmd). Just use the
    values from the private data.
    
    For aesthetics, rename the setup_counters() function so it has namespace
    associated with the driver. Refactor the function to use the values from
    the private data and absorb das1800_set_frequency() to clarify the code.
    Refactor the function to use the i8254_set_mode() and i8254_write()
    helpers instead of i8254_load(). This allows us to use the I8254_* defines
    when setting the mode to clarify the code.
    
    This function will not fail so change the return type to void to simplify
    the (*do_cmd) a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 93fd58b60e5c..ba357b6ec127 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -962,68 +962,29 @@ static int control_c_bits(const struct comedi_cmd *cmd)
 	return control_c;
 }
 
-/* loads counters with divisor1, divisor2 from private structure */
-static int das1800_set_frequency(struct comedi_device *dev)
+static void das1800_setup_counters(struct comedi_device *dev,
+				   const struct comedi_cmd *cmd)
 {
 	struct das1800_private *devpriv = dev->private;
-	int err = 0;
-
-	/*  counter 1, mode 2 */
-	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
-		       2))
-		err++;
-	/*  counter 2, mode 2 */
-	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
-		       2))
-		err++;
-	if (err)
-		return -1;
+	unsigned long timer_base = dev->iobase + DAS1800_COUNTER;
 
-	return 0;
-}
-
-/* sets up counters */
-static int setup_counters(struct comedi_device *dev,
-			  const struct comedi_cmd *cmd)
-{
-	struct das1800_private *devpriv = dev->private;
-	unsigned int period;
+	/* setup cascaded counters for conversion/scan frequency */
+	if ((cmd->scan_begin_src == TRIG_FOLLOW ||
+	     cmd->scan_begin_src == TRIG_TIMER) &&
+	    cmd->convert_src == TRIG_TIMER) {
+		i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+		i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
 
-	/*  setup cascaded counters for conversion/scan frequency */
-	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:	/*  not in burst mode */
-		if (cmd->convert_src == TRIG_TIMER) {
-			/* set conversion frequency */
-			period = cmd->convert_arg;
-			i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
-						  &devpriv->divisor1,
-						  &devpriv->divisor2,
-						  &period, cmd->flags);
-			if (das1800_set_frequency(dev) < 0)
-				return -1;
-		}
-		break;
-	case TRIG_TIMER:	/*  in burst mode */
-		/* set scan frequency */
-		period = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &period, cmd->flags);
-		if (das1800_set_frequency(dev) < 0)
-			return -1;
-		break;
-	default:
-		break;
+		i8254_write(timer_base, 0, 1, devpriv->divisor1);
+		i8254_write(timer_base, 0, 2, devpriv->divisor2);
 	}
 
-	/*  setup counter 0 for 'about triggering' */
+	/* setup counter 0 for 'about triggering' */
 	if (cmd->stop_src == TRIG_EXT) {
-		/*  load counter 0 in mode 0 */
-		i8254_load(dev->iobase + DAS1800_COUNTER, 0, 0, 1, 0);
-	}
+		i8254_set_mode(timer_base, 0, 0, I8254_MODE0 | I8254_BINARY);
 
-	return 0;
+		i8254_write(timer_base, 0, 0, 1);
+	}
 }
 
 /* utility function that suggests a dma transfer size based on the conversion period 'ns' */
@@ -1136,7 +1097,6 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	int ret;
 	int control_a, control_c;
 	struct comedi_async *async = s->async;
 	const struct comedi_cmd *cmd = &async->cmd;
@@ -1167,11 +1127,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 
 	/* setup card and start */
 	program_chanlist(dev, cmd);
-	ret = setup_counters(dev, cmd);
-	if (ret < 0) {
-		comedi_error(dev, "Error setting up counters");
-		return ret;
-	}
+	das1800_setup_counters(dev, cmd);
 	setup_dma(dev, cmd);
 	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
 	/*  set conversion rate and length for burst mode */

commit 66fea98e6251e15d25965ef805786e8e0b1c5ee4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:31 2014 -0700

    staging: comedi: das1800: refactor Step 4 of das1800_ai_do_cmdtest()
    
    Refactor this code to reduce the indent level and the > 80 char
    lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0335a70a918b..93fd58b60e5c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -731,7 +731,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 /* converts requested conversion timing to timing compatible with
  * hardware, used only when card is in 'burst mode'
  */
-static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
+static unsigned int burst_convert_arg(unsigned int convert_arg, int flags)
 {
 	unsigned int micro_sec;
 
@@ -740,7 +740,7 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 		convert_arg = 64000;
 
 	/*  the conversion time must be an integral number of microseconds */
-	switch (round_mode) {
+	switch (flags & TRIG_ROUND_MASK) {
 	case TRIG_ROUND_NEAREST:
 	default:
 		micro_sec = (convert_arg + 500) / 1000;
@@ -785,7 +785,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	const struct das1800_board *thisboard = comedi_board(dev);
 	struct das1800_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int tmp_arg;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -843,48 +843,39 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	if (cmd->convert_src == TRIG_TIMER) {
-		/*  if we are not in burst mode */
-		if (cmd->scan_begin_src == TRIG_FOLLOW) {
-			tmp_arg = cmd->convert_arg;
-			/* calculate counter values that give desired timing */
+	if (cmd->scan_begin_src == TRIG_FOLLOW &&
+	    cmd->convert_src == TRIG_TIMER) {
+		/* we are not in burst mode */
+		arg = cmd->convert_arg;
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->convert_arg, cmd->flags);
+		if (arg != cmd->convert_arg)
+			err++;
+	} else if (cmd->convert_src == TRIG_TIMER) {
+		/* we are in burst mode */
+		arg = cmd->convert_arg;
+		cmd->convert_arg = burst_convert_arg(cmd->convert_arg,
+						     cmd->flags);
+		if (arg != cmd->convert_arg)
+			err++;
+
+		if (cmd->scan_begin_src == TRIG_TIMER) {
+			arg = cmd->convert_arg * cmd->chanlist_len;
+			if (arg > cmd->scan_begin_arg) {
+				cmd->scan_begin_arg = arg;
+				err++;
+			}
+
+			arg = cmd->scan_begin_arg;
 			i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
 						  &devpriv->divisor1,
 						  &devpriv->divisor2,
-						  &cmd->convert_arg,
+						  &cmd->scan_begin_arg,
 						  cmd->flags);
-			if (tmp_arg != cmd->convert_arg)
-				err++;
-		}
-		/*  if we are in burst mode */
-		else {
-			/*  check that convert_arg is compatible */
-			tmp_arg = cmd->convert_arg;
-			cmd->convert_arg =
-			    burst_convert_arg(cmd->convert_arg,
-					      cmd->flags & TRIG_ROUND_MASK);
-			if (tmp_arg != cmd->convert_arg)
+			if (arg != cmd->scan_begin_arg)
 				err++;
-
-			if (cmd->scan_begin_src == TRIG_TIMER) {
-				/*  if scans are timed faster than conversion rate allows */
-				if (cmd->convert_arg * cmd->chanlist_len >
-				    cmd->scan_begin_arg) {
-					cmd->scan_begin_arg =
-					    cmd->convert_arg *
-					    cmd->chanlist_len;
-					err++;
-				}
-				tmp_arg = cmd->scan_begin_arg;
-				/* calculate counter values that give desired timing */
-				i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
-							  &devpriv->divisor1,
-							  &devpriv->divisor2,
-							  &cmd->scan_begin_arg,
-							  cmd->flags);
-				if (tmp_arg != cmd->scan_begin_arg)
-					err++;
-			}
 		}
 	}
 

commit 1d57261c96cf37949b87d9d239afb3734846d78e
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Sat Apr 26 16:04:29 2014 +0200

    staging: comedi: remove duplicate pointer assignments in attach functions
    
    Some board pointer are assigned twice via comedi_board() in the comedi low
    level driver attach functions. Remove the duplicate assignment from the
    variable definition where the pointer is not used anyway until assigned later
    in the function when dev->board_ptr, that comedi_board() relies on, is setup
    correctly.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d581029146cb..0335a70a918b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1479,7 +1479,7 @@ static int das1800_probe(struct comedi_device *dev)
 static int das1800_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
-	const struct das1800_board *thisboard = comedi_board(dev);
+	const struct das1800_board *thisboard;
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned int irq = it->options[1];

commit 8c3ca59af3ec7326a1d6b07ed56edc5e729a36ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:14 2014 -0700

    staging: comedi: das1800: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input async command
    support. Tidy up the factored out code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 8e975d6b06db..d581029146cb 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -757,6 +757,26 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 	return micro_sec * 1000;
 }
 
+static int das1800_ai_check_chanlist(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_cmd *cmd)
+{
+	unsigned int unipolar0 = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int unipolar = CR_RANGE(cmd->chanlist[i]) & UNIPOLAR;
+
+		if (unipolar != unipolar0) {
+			dev_dbg(dev->class_dev,
+				"unipolar and bipolar ranges cannot be mixed in the chanlist\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 /* test analog input cmd */
 static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
@@ -766,8 +786,6 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp_arg;
-	int i;
-	int unipolar;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -873,18 +891,9 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/*  make sure user is not trying to mix unipolar and bipolar ranges */
-	if (cmd->chanlist) {
-		unipolar = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (unipolar != (CR_RANGE(cmd->chanlist[i]) & UNIPOLAR)) {
-				comedi_error(dev,
-					     "unipolar and bipolar ranges cannot be mixed in the chanlist");
-				err++;
-				break;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= das1800_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 52037a0d520e988e3287b28bc767b58ddc66ad94
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:46 2014 -0700

    staging: comedi: drivers should not clear the async->events
    
    The comedi core resets the async->events in comedi_buf_reset() which is
    called when the subdevice is restored to an idle state and at the start
    of an async command. The async->events are also cleared after handling
    the events in comedi_event().
    
    Drivers should not clear the events manually.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9f353cf9c0ed..8e975d6b06db 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -646,7 +646,6 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
-	async->events = 0;
 	/*  select adc for base address + 0 */
 	outb(ADC, dev->iobase + DAS1800_SELECT);
 	/*  dma buffer full */

commit c9695093017d71a0571df7140feacfbf5ef4cdd4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:32 2014 -0700

    staging: comedi: das1800: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    In the Kconfig, COMEDI_DAS1800 already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 320d95a5f47b..9f353cf9c0ed 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -665,9 +665,8 @@ static void das1800_ai_handler(struct comedi_device *dev)
 		/*  clear OVF interrupt bit */
 		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
 		comedi_error(dev, "DAS1800 FIFO overflow");
-		das1800_cancel(dev, s);
 		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
-		comedi_event(dev, s);
+		cfc_handle_events(dev, s);
 		return;
 	}
 	/*  stop taking data if appropriate */
@@ -680,16 +679,12 @@ static void das1800_ai_handler(struct comedi_device *dev)
 			das1800_flush_dma(dev, s);
 		else
 			das1800_handle_fifo_not_empty(dev, s);
-		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async->events |= COMEDI_CB_EOA;
 	} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {	/*  stop_src TRIG_COUNT */
-		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async->events |= COMEDI_CB_EOA;
 	}
 
-	comedi_event(dev, s);
-
-	return;
+	cfc_handle_events(dev, s);
 }
 
 static int das1800_ai_poll(struct comedi_device *dev,

commit c6273c0cfa3ff658f63d1c59029f01b8cbb2998b
Author: Chase Southwood <chase.southwood@yahoo.com>
Date:   Sun Jan 5 21:46:54 2014 -0600

    Staging: comedi: fix spacing/style problem in das1800.c (and das6402.c)
    
    This patch fixes a style issue regarding asterisk placement in
    das1800.c and das6402.c found by checkpatch.pl.
    
    Signed-off-by: Chase Southwood <chase.southwood@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 165bdfd6104d..320d95a5f47b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -459,7 +459,7 @@ static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 	return sample;
 }
 
-static void munge_data(struct comedi_device *dev, uint16_t * array,
+static void munge_data(struct comedi_device *dev, uint16_t *array,
 		       unsigned int num_elements)
 {
 	unsigned int i;

commit 53a38e23cda9ebd0439fb6481a9ffd0335eb68c0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:09 2013 -0700

    staging: comedi: das1800: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Use the BIP_RANGE and UNI_RANGE macros instead of the more generic
    RANGE macro to reduce possible typo errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 37e92a0373f1..165bdfd6104d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -178,31 +178,29 @@ enum {
 
 /* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {
-	8,
-	{
-	 RANGE(-5, 5),
-	 RANGE(-1, 1),
-	 RANGE(-0.1, 0.1),
-	 RANGE(-0.02, 0.02),
-	 RANGE(0, 5),
-	 RANGE(0, 1),
-	 RANGE(0, 0.1),
-	 RANGE(0, 0.02),
-	 }
+	8, {
+		BIP_RANGE(5),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.02),
+		UNI_RANGE(5),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.02)
+	}
 };
 
 static const struct comedi_lrange range_ai_das1802 = {
-	8,
-	{
-	 RANGE(-10, 10),
-	 RANGE(-5, 5),
-	 RANGE(-2.5, 2.5),
-	 RANGE(-1.25, 1.25),
-	 RANGE(0, 10),
-	 RANGE(0, 5),
-	 RANGE(0, 2.5),
-	 RANGE(0, 1.25),
-	 }
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 struct das1800_board {
@@ -445,10 +443,9 @@ struct das1800_private {
 /* analog out range for 'ao' boards */
 /*
 static const struct comedi_lrange range_ao_2 = {
-	2,
-	{
-		RANGE(-10, 10),
-		RANGE(-5, 5),
+	2, {
+		BIP_RANGE(10),
+		BIP_RANGE(5)
 	}
 };
 */

commit 6f6e144d4d53e29a9f6487e4baed748f3fde1fa2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:26 2013 -0700

    staging: comedi: das1800: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 92df02d989a6..37e92a0373f1 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -644,7 +644,7 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 static void das1800_ai_handler(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
-	struct comedi_subdevice *s = &dev->subdevices[0];
+	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);

commit ed7a693f1391c053a355e7210c238bcb4fb7a332
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:25 2013 -0700

    staging: comedi: das1800: tidy up irq request
    
    This driver only needs an irq in order to support async commands.
    If the irq is not available the driver will still function for
    single analog input reads.
    
    Tidy up the code that does the irq requests so that the driver
    will still attach if it is not avaliable.
    
    Remove the noise about the irq during the attach.
    
    Only hook up the async commands support if the irq is available.
    Remove the then unnecessary sanity check in das1800_ai_do_cmd().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1880038956d0..92df02d989a6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1150,12 +1150,6 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	struct comedi_async *async = s->async;
 	const struct comedi_cmd *cmd = &async->cmd;
 
-	if (!dev->irq) {
-		comedi_error(dev,
-			     "no irq assigned for das-1800, cannot do hardware conversions");
-		return -1;
-	}
-
 	/* disable dma on TRIG_WAKE_EOS, or TRIG_RT
 	 * (because dma in handler is unsafe at hard real-time priority) */
 	if (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT))
@@ -1522,43 +1516,34 @@ static int das1800_attach(struct comedi_device *dev,
 		devpriv->iobase2 = iobase2;
 	}
 
-	/* grab our IRQ */
-	if (irq) {
-		if (request_irq(irq, das1800_interrupt, 0,
-				dev->driver->driver_name, dev)) {
-			dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
-	}
-	dev->irq = irq;
+	if (irq == 3 || irq == 5 || irq == 7 || irq == 10 || irq == 11 ||
+	    irq == 15) {
+		ret = request_irq(irq, das1800_interrupt, 0,
+				  dev->board_name, dev);
+		if (ret == 0) {
+			dev->irq = irq;
 
-	/*  set bits that tell card which irq to use */
-	switch (irq) {
-	case 0:
-		break;
-	case 3:
-		devpriv->irq_dma_bits |= 0x8;
-		break;
-	case 5:
-		devpriv->irq_dma_bits |= 0x10;
-		break;
-	case 7:
-		devpriv->irq_dma_bits |= 0x18;
-		break;
-	case 10:
-		devpriv->irq_dma_bits |= 0x28;
-		break;
-	case 11:
-		devpriv->irq_dma_bits |= 0x30;
-		break;
-	case 15:
-		devpriv->irq_dma_bits |= 0x38;
-		break;
-	default:
-		dev_err(dev->class_dev, "irq out of range\n");
-		return -EINVAL;
-		break;
+			switch (irq) {
+			case 3:
+				devpriv->irq_dma_bits |= 0x8;
+				break;
+			case 5:
+				devpriv->irq_dma_bits |= 0x10;
+				break;
+			case 7:
+				devpriv->irq_dma_bits |= 0x18;
+				break;
+			case 10:
+				devpriv->irq_dma_bits |= 0x28;
+				break;
+			case 11:
+				devpriv->irq_dma_bits |= 0x30;
+				break;
+			case 15:
+				devpriv->irq_dma_bits |= 0x38;
+				break;
+			}
+		}
 	}
 
 	ret = das1800_init_dma(dev, dma0, dma1);
@@ -1578,20 +1563,23 @@ static int das1800_attach(struct comedi_device *dev,
 
 	/* analog input subdevice */
 	s = &dev->subdevices[0];
-	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;
 	if (thisboard->common)
 		s->subdev_flags |= SDF_COMMON;
 	s->n_chan = thisboard->qram_len;
-	s->len_chanlist = thisboard->qram_len;
 	s->maxdata = (1 << thisboard->resolution) - 1;
 	s->range_table = thisboard->range_ai;
-	s->do_cmd = das1800_ai_do_cmd;
-	s->do_cmdtest = das1800_ai_do_cmdtest;
 	s->insn_read = das1800_ai_rinsn;
-	s->poll = das1800_ai_poll;
-	s->cancel = das1800_cancel;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->len_chanlist = s->n_chan;
+		s->do_cmd = das1800_ai_do_cmd;
+		s->do_cmdtest = das1800_ai_do_cmdtest;
+		s->poll = das1800_ai_poll;
+		s->cancel = das1800_cancel;
+	}
 
 	/* analog out */
 	s = &dev->subdevices[1];

commit 65a62aaec2e888b6271a4f302f10ad72e966cc10
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:18 2013 +0100

    staging: comedi: das1800: sample types are unsigned
    
    Sample values in comedi are generally represented by unsigned values.
    Change the type of the `ao_update_bits` member of `struct
    das1800_private` and the types of various local variables used to hold
    sample values from `short` to `unsigned short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f753a10c6549..1880038956d0 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -438,7 +438,8 @@ struct das1800_private {
 	uint16_t *dma_current_buf;	/* pointer to dma buffer currently being used */
 	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
-	short ao_update_bits;	/* remembers the last write to the 'update' dac */
+	unsigned short ao_update_bits;	/* remembers the last write to the
+					 * 'update' dac */
 };
 
 /* analog out range for 'ao' boards */
@@ -501,7 +502,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
 	struct das1800_private *devpriv = dev->private;
-	short dpnt;
+	unsigned short dpnt;
 	int unipolar;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -1211,7 +1212,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 	int i, n;
 	int chan, range, aref, chan_range;
 	int timeout = 1000;
-	short dpnt;
+	unsigned short dpnt;
 	int conv_flags = 0;
 	unsigned long irq_flags;
 
@@ -1276,7 +1277,7 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
 	int update_chan = thisboard->ao_n_chan - 1;
-	short output;
+	unsigned short output;
 	unsigned long irq_flags;
 
 	/*   card expects two's complement data */

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 8b9a0a66b5a5..f753a10c6549 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -108,7 +108,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 /* misc. defines */
 #define DAS1800_SIZE           16	/* uses 16 io addresses */
 #define FIFO_SIZE              1024	/*  1024 sample fifo */
-#define TIMER_BASE             200	/*  5 Mhz master clock */
 #define UNIPOLAR               0x4	/*  bit that determines whether input range is uni/bipolar */
 #define DMA_BUF_SIZE           0x1ff00	/*  size in bytes of dma buffers */
 
@@ -839,12 +838,11 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 		if (cmd->scan_begin_src == TRIG_FOLLOW) {
 			tmp_arg = cmd->convert_arg;
 			/* calculate counter values that give desired timing */
-			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-						       &(devpriv->divisor1),
-						       &(devpriv->divisor2),
-						       &(cmd->convert_arg),
-						       cmd->
-						       flags & TRIG_ROUND_MASK);
+			i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
+						  &devpriv->divisor1,
+						  &devpriv->divisor2,
+						  &cmd->convert_arg,
+						  cmd->flags);
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 		}
@@ -869,16 +867,11 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				}
 				tmp_arg = cmd->scan_begin_arg;
 				/* calculate counter values that give desired timing */
-				i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-							       &(devpriv->
-								 divisor1),
-							       &(devpriv->
-								 divisor2),
-							       &(cmd->
-								 scan_begin_arg),
-							       cmd->
-							       flags &
-							       TRIG_ROUND_MASK);
+				i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
+							  &devpriv->divisor1,
+							  &devpriv->divisor2,
+							  &cmd->scan_begin_arg,
+							  cmd->flags);
 				if (tmp_arg != cmd->scan_begin_arg)
 					err++;
 			}
@@ -1010,12 +1003,10 @@ static int setup_counters(struct comedi_device *dev,
 		if (cmd->convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
 			period = cmd->convert_arg;
-			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-						       &devpriv->divisor1,
-						       &devpriv->divisor2,
-						       &period,
-						       cmd->flags &
-							TRIG_ROUND_MASK);
+			i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
+						  &devpriv->divisor1,
+						  &devpriv->divisor2,
+						  &period, cmd->flags);
 			if (das1800_set_frequency(dev) < 0)
 				return -1;
 		}
@@ -1023,9 +1014,10 @@ static int setup_counters(struct comedi_device *dev,
 	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
 		period = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &devpriv->divisor1,
-					       &devpriv->divisor2, &period,
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_5MHZ,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &period, cmd->flags);
 		if (das1800_set_frequency(dev) < 0)
 			return -1;
 		break;

commit 8c32d5dabc663066a0dc1e0f2266b18ef4347d34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:07:52 2013 -0700

    staging: comedi: das1800: remove do_bits from private data
    
    Use the subdevice 'state' variable instead of carrying the state of
    the output channels in the private data.
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5b300294d322..8b9a0a66b5a5 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -427,7 +427,6 @@ struct das1800_private {
 	volatile unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
-	int do_bits;		/* digital output bits */
 	int irq_dma_bits;	/* bits for control register b */
 	/* dma bits for control register b, stored so that dma can be
 	 * turned on and off */
@@ -1319,24 +1318,15 @@ static int das1800_di_rbits(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* writes to digital output channels */
 static int das1800_do_wbits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+			    struct comedi_insn *insn,
+			    unsigned int *data)
 {
-	struct das1800_private *devpriv = dev->private;
-	unsigned int wbits;
-
-	/*  only set bits that have been masked */
-	data[0] &= (1 << s->n_chan) - 1;
-	wbits = devpriv->do_bits;
-	wbits &= ~data[0];
-	wbits |= data[0] & data[1];
-	devpriv->do_bits = wbits;
-
-	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+	if (comedi_dio_update_state(s, data))
+		outb(s->state, dev->iobase + DAS1800_DIGITAL);
 
-	data[1] = devpriv->do_bits;
+	data[1] = s->state;
 
 	return insn->n;
 }
@@ -1644,7 +1634,7 @@ static int das1800_attach(struct comedi_device *dev,
 	das1800_cancel(dev, dev->read_subdev);
 
 	/*  initialize digital out channels */
-	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+	outb(0, dev->iobase + DAS1800_DIGITAL);
 
 	/*  initialize analog out channels */
 	if (thisboard->ao_ability == 1) {

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f5ed55c68fa1..5b300294d322 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -100,7 +100,6 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #include <linux/io.h>
 #include "../comedidev.h"
 
-#include <linux/ioport.h>
 #include <asm/dma.h>
 
 #include "8253.h"

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e6c852530acb..f5ed55c68fa1 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -94,6 +94,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 	read insn for analog out
 */
 
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/io.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 23b4a661eb1a..e6c852530acb 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1511,10 +1511,9 @@ static int das1800_attach(struct comedi_device *dev,
 	int board;
 	int ret;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_request_region(dev, it->options[0], DAS1800_SIZE);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index abf7638a9f71..23b4a661eb1a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -15,12 +15,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
 */
 /*
 Driver: das1800

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 4aa2c509124d..abf7638a9f71 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1668,8 +1668,6 @@ static void das1800_detach(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
 
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	if (devpriv) {
 		if (devpriv->dma0)
 			free_dma(devpriv->dma0);

commit e608796ab624049419e987be32f81ab08486c7ba
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:33:04 2013 -0700

    staging: comedi: das1800: use comedi_legacy_detach()
    
    Use the new comedi_legacy_detach() helper in the (*detach) to release
    the first I/O region requested by this driver.
    
    An additional I/O region is requested for some of the boards this driver
    supports. The iobase for that region is stored in the private data so
    that the (*detach) knows it needs to be released. Remove the extra
    cleanup in the (*attach) that releases the first region.
    
    For aesthetics, move the release of the additional region in the
    (*detach) so it follows the (*attach) order.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 767620102029..4aa2c509124d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1541,11 +1541,8 @@ static int das1800_attach(struct comedi_device *dev,
 		unsigned long iobase2 = dev->iobase + IOBASE2;
 
 		ret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);
-		if (ret) {
-			release_region(dev->iobase, DAS1800_SIZE);
-			dev->iobase = 0;
-			return -EIO;
-		}
+		if (ret)
+			return ret;
 		devpriv->iobase2 = iobase2;
 	}
 
@@ -1671,21 +1668,20 @@ static void das1800_detach(struct comedi_device *dev)
 {
 	struct das1800_private *devpriv = dev->private;
 
-	if (dev->iobase)
-		release_region(dev->iobase, DAS1800_SIZE);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (devpriv) {
-		if (devpriv->iobase2)
-			release_region(devpriv->iobase2, DAS1800_SIZE);
 		if (devpriv->dma0)
 			free_dma(devpriv->dma0);
 		if (devpriv->dma1)
 			free_dma(devpriv->dma1);
 		kfree(devpriv->ai_buf0);
 		kfree(devpriv->ai_buf1);
+		if (devpriv->iobase2)
+			release_region(devpriv->iobase2, DAS1800_SIZE);
 	}
-};
+	comedi_legacy_detach(dev);
+}
 
 static struct comedi_driver das1800_driver = {
 	.driver_name	= "das1800",

commit 8fdbc75b70967f78cbd508e33c4a1da9e90b09f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 10 10:03:59 2013 -0700

    staging: comedi: das1800: use __comedi_request_region()
    
    Use __comedi_request_region() to request the additional I/O region
    used by this driver.
    
    Remove the error message when the request_region() fails,
    comedi_request_reqion() will output the error message if necessary.
    
    For aesthetic reasons, rename the local variable 'retval' to
    simply 'ret'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index cf265c1be7d8..767620102029 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1514,18 +1514,17 @@ static int das1800_attach(struct comedi_device *dev,
 	unsigned int irq = it->options[1];
 	unsigned int dma0 = it->options[2];
 	unsigned int dma1 = it->options[3];
-	unsigned long iobase2;
 	int board;
-	int retval;
+	int ret;
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	retval = comedi_request_region(dev, it->options[0], DAS1800_SIZE);
-	if (retval)
-		return retval;
+	ret = comedi_request_region(dev, it->options[0], DAS1800_SIZE);
+	if (ret)
+		return ret;
 
 	board = das1800_probe(dev);
 	if (board < 0) {
@@ -1539,13 +1538,11 @@ static int das1800_attach(struct comedi_device *dev,
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (thisboard->ao_ability == 2) {
-		iobase2 = dev->iobase + IOBASE2;
-		if (!request_region(iobase2, DAS1800_SIZE, dev->board_name)) {
+		unsigned long iobase2 = dev->iobase + IOBASE2;
+
+		ret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);
+		if (ret) {
 			release_region(dev->iobase, DAS1800_SIZE);
-			dev_warn(dev->class_dev,
-				 "%s: I/O port conflict (%#lx,%d)\n",
-				 dev->board_name,
-				 iobase2, DAS1800_SIZE);
 			dev->iobase = 0;
 			return -EIO;
 		}
@@ -1591,9 +1588,9 @@ static int das1800_attach(struct comedi_device *dev,
 		break;
 	}
 
-	retval = das1800_init_dma(dev, dma0, dma1);
-	if (retval < 0)
-		return retval;
+	ret = das1800_init_dma(dev, dma0, dma1);
+	if (ret < 0)
+		return ret;
 
 	if (devpriv->ai_buf0 == NULL) {
 		devpriv->ai_buf0 =
@@ -1602,9 +1599,9 @@ static int das1800_attach(struct comedi_device *dev,
 			return -ENOMEM;
 	}
 
-	retval = comedi_alloc_subdevices(dev, 4);
-	if (retval)
-		return retval;
+	ret = comedi_alloc_subdevices(dev, 4);
+	if (ret)
+		return ret;
 
 	/* analog input subdevice */
 	s = &dev->subdevices[0];

commit 29a879b1250e13d777ac7f17b694ef0ead8cc472
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:16:42 2013 -0700

    staging: comedi: das1800: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    This driver does a second request_region() for the additional I/O space
    used on the 'ao' type boards. Modify the error message if that request
    fails so it matches to format of the comedi_request_region() message.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1e90287303d8..cf265c1be7d8 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1511,7 +1511,6 @@ static int das1800_attach(struct comedi_device *dev,
 	const struct das1800_board *thisboard = comedi_board(dev);
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
-	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned int dma0 = it->options[2];
 	unsigned int dma1 = it->options[3];
@@ -1524,31 +1523,9 @@ static int das1800_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
-	       dev->driver->driver_name, iobase);
-	if (irq) {
-		printk(KERN_CONT ", irq %u", irq);
-		if (dma0) {
-			printk(KERN_CONT ", dma %u", dma0);
-			if (dma1)
-				printk(KERN_CONT " and %u", dma1);
-		}
-	}
-	printk(KERN_CONT "\n");
-
-	if (iobase == 0) {
-		dev_err(dev->class_dev, "io base address required\n");
-		return -EINVAL;
-	}
-
-	/* check if io addresses are available */
-	if (!request_region(iobase, DAS1800_SIZE, dev->driver->driver_name)) {
-		printk
-		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
-		     iobase, iobase + DAS1800_SIZE - 1);
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	retval = comedi_request_region(dev, it->options[0], DAS1800_SIZE);
+	if (retval)
+		return retval;
 
 	board = das1800_probe(dev);
 	if (board < 0) {
@@ -1562,12 +1539,14 @@ static int das1800_attach(struct comedi_device *dev,
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (thisboard->ao_ability == 2) {
-		iobase2 = iobase + IOBASE2;
-		if (!request_region(iobase2, DAS1800_SIZE,
-				    dev->driver->driver_name)) {
-			printk
-			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
-			     iobase2, iobase2 + DAS1800_SIZE - 1);
+		iobase2 = dev->iobase + IOBASE2;
+		if (!request_region(iobase2, DAS1800_SIZE, dev->board_name)) {
+			release_region(dev->iobase, DAS1800_SIZE);
+			dev_warn(dev->class_dev,
+				 "%s: I/O port conflict (%#lx,%d)\n",
+				 dev->board_name,
+				 iobase2, DAS1800_SIZE);
+			dev->iobase = 0;
 			return -EIO;
 		}
 		devpriv->iobase2 = iobase2;

commit fef2aa646fa4293e3dbbdd40158c8e318f936916
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 5 17:35:22 2013 -0700

    staging: comedi: das1800: remove 'thisboard' macro
    
    The 'thisboard' macro relies on a local variable having a specific
    name and yields a pointer derived from that local variable.
    
    Replace the macro with local variables and use the comedi_board()
    helper to get the pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5a99d5b1ff9d..1e90287303d8 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -429,11 +429,6 @@ static const struct das1800_board das1800_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct das1800_board *)dev->board_ptr)
-
 struct das1800_private {
 	volatile unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
@@ -468,6 +463,8 @@ static const struct comedi_lrange range_ao_2 = {
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 					    uint16_t sample)
 {
+	const struct das1800_board *thisboard = comedi_board(dev);
+
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
 }
@@ -781,6 +778,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
+	const struct das1800_board *thisboard = comedi_board(dev);
 	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp_arg;
@@ -1224,6 +1222,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct das1800_board *thisboard = comedi_board(dev);
 	int i, n;
 	int chan, range, aref, chan_range;
 	int timeout = 1000;
@@ -1287,6 +1286,7 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	const struct das1800_board *thisboard = comedi_board(dev);
 	struct das1800_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
@@ -1508,6 +1508,7 @@ static int das1800_probe(struct comedi_device *dev)
 static int das1800_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
+	const struct das1800_board *thisboard = comedi_board(dev);
 	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -1556,6 +1557,7 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	dev->board_ptr = das1800_boards + board;
+	thisboard = comedi_board(dev);
 	dev->board_name = thisboard->name;
 
 	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */

commit 5d5cabb675779c871ca13fe016e70916394a7c53
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 3 13:36:48 2013 -0700

    staging: comedi: das1800: use comedi provided range_bipolar10
    
    Remove the private range, range_ao_1, in this driver and use the
    comedi provided range_bipolar10 instead.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d01e140885d8..5a99d5b1ff9d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -454,14 +454,6 @@ struct das1800_private {
 	short ao_update_bits;	/* remembers the last write to the 'update' dac */
 };
 
-/* analog out range for boards with basic analog out */
-static const struct comedi_lrange range_ao_1 = {
-	1,
-	{
-	 RANGE(-10, 10),
-	 }
-};
-
 /* analog out range for 'ao' boards */
 /*
 static const struct comedi_lrange range_ao_2 = {
@@ -1657,7 +1649,7 @@ static int das1800_attach(struct comedi_device *dev,
 		s->subdev_flags = SDF_WRITABLE;
 		s->n_chan = thisboard->ao_n_chan;
 		s->maxdata = (1 << thisboard->resolution) - 1;
-		s->range_table = &range_ao_1;
+		s->range_table = &range_bipolar10;
 		s->insn_write = das1800_ao_winsn;
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 7900f959555d..d01e140885d8 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -731,7 +731,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	unsigned int status;
 
-	if (dev->attached == 0) {
+	if (!dev->attached) {
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}

commit 35402007dd9ad3a05350a0815aa2e1ca7dba77d5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:54:41 2012 -0700

    staging: comedi: das1800: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of das1800_ai_do_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2495cd914793..7900f959555d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -824,39 +824,23 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
-			err++;
-		}
-	}
-	if (!cmd->chanlist_len) {
-		cmd->chanlist_len = 1;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 thisboard->ai_speed);
+
+	err |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		if (!cmd->stop_arg) {
-			cmd->stop_arg = 1;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3754fcb83531..2495cd914793 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1542,10 +1542,10 @@ static int das1800_attach(struct comedi_device *dev,
 	int board;
 	int retval;
 
-	retval = alloc_private(dev, sizeof(*devpriv));
-	if (retval)
-		return retval;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
 	       dev->driver->driver_name, iobase);

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2555f3297d7b..3754fcb83531 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -454,8 +454,6 @@ struct das1800_private {
 	short ao_update_bits;	/* remembers the last write to the 'update' dac */
 };
 
-#define devpriv ((struct das1800_private *)dev->private)
-
 /* analog out range for boards with basic analog out */
 static const struct comedi_lrange range_ao_1 = {
 	1,
@@ -501,6 +499,7 @@ static void munge_data(struct comedi_device *dev, uint16_t * array,
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
+	struct das1800_private *devpriv = dev->private;
 	int numPoints = 0;	/* number of points to read */
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -520,6 +519,7 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 					  struct comedi_subdevice *s)
 {
+	struct das1800_private *devpriv = dev->private;
 	short dpnt;
 	int unipolar;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -548,6 +548,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      unsigned int channel, uint16_t *buffer)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned int num_bytes, num_samples;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -578,6 +579,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
@@ -609,6 +611,7 @@ static void das1800_flush_dma(struct comedi_device *dev,
 static void das1800_handle_dma(struct comedi_device *dev,
 			       struct comedi_subdevice *s, unsigned int status)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
@@ -643,6 +646,8 @@ static void das1800_handle_dma(struct comedi_device *dev,
 
 static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct das1800_private *devpriv = dev->private;
+
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
@@ -656,6 +661,7 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 /* the guts of the interrupt handler, that is shared with das1800_ai_poll */
 static void das1800_ai_handler(struct comedi_device *dev)
 {
+	struct das1800_private *devpriv = dev->private;
 	struct comedi_subdevice *s = &dev->subdevices[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -783,6 +789,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_subdevice *s,
 				 struct comedi_cmd *cmd)
 {
+	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int tmp_arg;
 	int i;
@@ -1006,6 +1013,7 @@ static int control_c_bits(const struct comedi_cmd *cmd)
 /* loads counters with divisor1, divisor2 from private structure */
 static int das1800_set_frequency(struct comedi_device *dev)
 {
+	struct das1800_private *devpriv = dev->private;
 	int err = 0;
 
 	/*  counter 1, mode 2 */
@@ -1026,6 +1034,7 @@ static int das1800_set_frequency(struct comedi_device *dev)
 static int setup_counters(struct comedi_device *dev,
 			  const struct comedi_cmd *cmd)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned int period;
 
 	/*  setup cascaded counters for conversion/scan frequency */
@@ -1107,6 +1116,7 @@ static unsigned int suggest_transfer_size(const struct comedi_cmd *cmd)
 /* sets up dma */
 static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
@@ -1174,6 +1184,7 @@ static void program_chanlist(struct comedi_device *dev,
 static int das1800_ai_do_cmd(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	struct das1800_private *devpriv = dev->private;
 	int ret;
 	int control_a, control_c;
 	struct comedi_async *async = s->async;
@@ -1300,6 +1311,7 @@ static int das1800_ao_winsn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct das1800_private *devpriv = dev->private;
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
 	int update_chan = thisboard->ao_n_chan - 1;
@@ -1342,6 +1354,7 @@ static int das1800_do_wbits(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned int wbits;
 
 	/*  only set bits that have been masked */
@@ -1361,6 +1374,7 @@ static int das1800_do_wbits(struct comedi_device *dev,
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			    unsigned int dma1)
 {
+	struct das1800_private *devpriv = dev->private;
 	unsigned long flags;
 
 	/*  need an irq to do dma */
@@ -1518,6 +1532,7 @@ static int das1800_probe(struct comedi_device *dev)
 static int das1800_attach(struct comedi_device *dev,
 			  struct comedi_devconfig *it)
 {
+	struct das1800_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
@@ -1527,9 +1542,10 @@ static int das1800_attach(struct comedi_device *dev,
 	int board;
 	int retval;
 
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct das1800_private)) < 0)
-		return -ENOMEM;
+	retval = alloc_private(dev, sizeof(*devpriv));
+	if (retval)
+		return retval;
+	devpriv = dev->private;
 
 	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
 	       dev->driver->driver_name, iobase);
@@ -1699,11 +1715,13 @@ static int das1800_attach(struct comedi_device *dev,
 
 static void das1800_detach(struct comedi_device *dev)
 {
+	struct das1800_private *devpriv = dev->private;
+
 	if (dev->iobase)
 		release_region(dev->iobase, DAS1800_SIZE);
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->private) {
+	if (devpriv) {
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);
 		if (devpriv->dma0)

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 711d4e243b88..2555f3297d7b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -784,59 +784,35 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 				 struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
 	unsigned int tmp_arg;
 	int i;
 	int unipolar;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src,
+					TRIG_COUNT | TRIG_EXT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
-	/*  uniqueness check */
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT &&
-	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
-		err++;
-	/* compatibility check */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 	    cmd->convert_src != TRIG_TIMER)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit eb4332eff5aa071b19f89f45ae7f6393af59ba62
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 19 19:37:41 2012 +0100

    staging: comedi: das1800: don't pass struct comedi_cmd by value
    
    Various functions in das1800.c take a `struct comedi_cmd` parameter by
    value.  Change them to pass the parameter by reference instead.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5aca8fbdc246..711d4e243b88 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -958,14 +958,14 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 }
 
 /* returns appropriate bits for control register a, depending on command */
-static int control_a_bits(struct comedi_cmd cmd)
+static int control_a_bits(const struct comedi_cmd *cmd)
 {
 	int control_a;
 
 	control_a = FFEN;	/* enable fifo */
-	if (cmd.stop_src == TRIG_EXT)
+	if (cmd->stop_src == TRIG_EXT)
 		control_a |= ATEN;
-	switch (cmd.start_src) {
+	switch (cmd->start_src) {
 	case TRIG_EXT:
 		control_a |= TGEN | CGSL;
 		break;
@@ -980,7 +980,7 @@ static int control_a_bits(struct comedi_cmd cmd)
 }
 
 /* returns appropriate bits for control register c, depending on command */
-static int control_c_bits(struct comedi_cmd cmd)
+static int control_c_bits(const struct comedi_cmd *cmd)
 {
 	int control_c;
 	int aref;
@@ -988,18 +988,18 @@ static int control_c_bits(struct comedi_cmd cmd)
 	/* set clock source to internal or external, select analog reference,
 	 * select unipolar / bipolar
 	 */
-	aref = CR_AREF(cmd.chanlist[0]);
+	aref = CR_AREF(cmd->chanlist[0]);
 	control_c = UQEN;	/* enable upper qram addresses */
 	if (aref != AREF_DIFF)
 		control_c |= SD;
 	if (aref == AREF_COMMON)
 		control_c |= CMEN;
 	/* if a unipolar range was selected */
-	if (CR_RANGE(cmd.chanlist[0]) & UNIPOLAR)
+	if (CR_RANGE(cmd->chanlist[0]) & UNIPOLAR)
 		control_c |= UB;
-	switch (cmd.scan_begin_src) {
+	switch (cmd->scan_begin_src) {
 	case TRIG_FOLLOW:	/*  not in burst mode */
-		switch (cmd.convert_src) {
+		switch (cmd->convert_src) {
 		case TRIG_TIMER:
 			/* trig on cascaded counters */
 			control_c |= IPCLK;
@@ -1047,29 +1047,33 @@ static int das1800_set_frequency(struct comedi_device *dev)
 }
 
 /* sets up counters */
-static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
+static int setup_counters(struct comedi_device *dev,
+			  const struct comedi_cmd *cmd)
 {
+	unsigned int period;
+
 	/*  setup cascaded counters for conversion/scan frequency */
-	switch (cmd.scan_begin_src) {
+	switch (cmd->scan_begin_src) {
 	case TRIG_FOLLOW:	/*  not in burst mode */
-		if (cmd.convert_src == TRIG_TIMER) {
+		if (cmd->convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
+			period = cmd->convert_arg;
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-						       &(devpriv->divisor1),
-						       &(devpriv->divisor2),
-						       &(cmd.convert_arg),
-						       cmd.
-						       flags & TRIG_ROUND_MASK);
+						       &devpriv->divisor1,
+						       &devpriv->divisor2,
+						       &period,
+						       cmd->flags &
+							TRIG_ROUND_MASK);
 			if (das1800_set_frequency(dev) < 0)
 				return -1;
 		}
 		break;
 	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd.scan_begin_arg),
-					       cmd.flags & TRIG_ROUND_MASK);
+		period = cmd->scan_begin_arg;
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &devpriv->divisor1,
+					       &devpriv->divisor2, &period,
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (das1800_set_frequency(dev) < 0)
 			return -1;
 		break;
@@ -1078,7 +1082,7 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 	}
 
 	/*  setup counter 0 for 'about triggering' */
-	if (cmd.stop_src == TRIG_EXT) {
+	if (cmd->stop_src == TRIG_EXT) {
 		/*  load counter 0 in mode 0 */
 		i8254_load(dev->iobase + DAS1800_COUNTER, 0, 0, 1, 0);
 	}
@@ -1087,7 +1091,7 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 }
 
 /* utility function that suggests a dma transfer size based on the conversion period 'ns' */
-static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
+static unsigned int suggest_transfer_size(const struct comedi_cmd *cmd)
 {
 	unsigned int size = DMA_BUF_SIZE;
 	static const int sample_size = 2;	/*  size in bytes of one sample from board */
@@ -1125,7 +1129,7 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 }
 
 /* sets up dma */
-static void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)
+static void setup_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)
 {
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1134,7 +1138,7 @@ static void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)
 		return;
 
 	/* determine a reasonable dma transfer size */
-	devpriv->dma_transfer_size = suggest_transfer_size(&cmd);
+	devpriv->dma_transfer_size = suggest_transfer_size(cmd);
 	lock_flags = claim_dma_lock();
 	disable_dma(devpriv->dma0);
 	/* clear flip-flop to make sure 2-byte registers for
@@ -1163,14 +1167,15 @@ static void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)
 }
 
 /* programs channel/gain list into card */
-static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
+static void program_chanlist(struct comedi_device *dev,
+			     const struct comedi_cmd *cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
 	const int range_mask = 0x3;	/* masks unipolar/bipolar bit off range */
 	const int range_bitshift = 8;
 
-	n = cmd.chanlist_len;
+	n = cmd->chanlist_len;
 	/*  spinlock protects indirect addressing */
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
@@ -1178,9 +1183,9 @@ static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 	/* make channel / gain list */
 	for (i = 0; i < n; i++) {
 		chan_range =
-		    CR_CHAN(cmd.
-			    chanlist[i]) | ((CR_RANGE(cmd.chanlist[i]) &
-					     range_mask) << range_bitshift);
+		    CR_CHAN(cmd->chanlist[i]) |
+		    ((CR_RANGE(cmd->chanlist[i]) & range_mask) <<
+		     range_bitshift);
 		outw(chan_range, dev->iobase + DAS1800_QRAM);
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
@@ -1196,7 +1201,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	int ret;
 	int control_a, control_c;
 	struct comedi_async *async = s->async;
-	struct comedi_cmd cmd = async->cmd;
+	const struct comedi_cmd *cmd = &async->cmd;
 
 	if (!dev->irq) {
 		comedi_error(dev,
@@ -1206,12 +1211,12 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 
 	/* disable dma on TRIG_WAKE_EOS, or TRIG_RT
 	 * (because dma in handler is unsafe at hard real-time priority) */
-	if (cmd.flags & (TRIG_WAKE_EOS | TRIG_RT))
+	if (cmd->flags & (TRIG_WAKE_EOS | TRIG_RT))
 		devpriv->irq_dma_bits &= ~DMA_ENABLED;
 	else
 		devpriv->irq_dma_bits |= devpriv->dma_bits;
 	/*  interrupt on end of conversion for TRIG_WAKE_EOS */
-	if (cmd.flags & TRIG_WAKE_EOS) {
+	if (cmd->flags & TRIG_WAKE_EOS) {
 		/*  interrupt fifo not empty */
 		devpriv->irq_dma_bits &= ~FIMD;
 	} else {
@@ -1219,8 +1224,8 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 		devpriv->irq_dma_bits |= FIMD;
 	}
 	/*  determine how many conversions we need */
-	if (cmd.stop_src == TRIG_COUNT)
-		devpriv->count = cmd.stop_arg * cmd.chanlist_len;
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->count = cmd->stop_arg * cmd->chanlist_len;
 
 	das1800_cancel(dev, s);
 
@@ -1240,9 +1245,9 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 	/*  set conversion rate and length for burst mode */
 	if (control_c & BMDE) {
 		/*  program conversion period with number of microseconds minus 1 */
-		outb(cmd.convert_arg / 1000 - 1,
+		outb(cmd->convert_arg / 1000 - 1,
 		     dev->iobase + DAS1800_BURST_RATE);
-		outb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
+		outb(cmd->chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
 	}
 	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
 	outb(control_a, dev->iobase + DAS1800_CONTROL_A);	/* enable fifo and triggering */

commit 2e3d3cf5c7d6c69d6940054645bc2d3d575ab916
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:36:21 2012 -0700

    staging: comedi: das1800: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 25e7e56a376f..5aca8fbdc246 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -656,7 +656,7 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 /* the guts of the interrupt handler, that is shared with das1800_ai_poll */
 static void das1800_ai_handler(struct comedi_device *dev)
 {
-	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
+	struct comedi_subdevice *s = &dev->subdevices[0];
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
@@ -1653,7 +1653,7 @@ static int das1800_attach(struct comedi_device *dev,
 		return retval;
 
 	/* analog input subdevice */
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;
@@ -1670,7 +1670,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s->cancel = das1800_cancel;
 
 	/* analog out */
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	if (thisboard->ao_ability == 1) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_WRITABLE;
@@ -1683,7 +1683,7 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	/* di */
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE;
 	s->n_chan = 4;
@@ -1692,7 +1692,7 @@ static int das1800_attach(struct comedi_device *dev,
 	s->insn_bits = das1800_di_rbits;
 
 	/* do */
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_DO;
 	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
 	s->n_chan = thisboard->do_n_chan;

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 365028772b00..25e7e56a376f 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1353,7 +1353,7 @@ static int das1800_di_rbits(struct comedi_device *dev,
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
 	data[0] = 0;
 
-	return 2;
+	return insn->n;
 }
 
 /* writes to digital output channels */
@@ -1374,7 +1374,7 @@ static int das1800_do_wbits(struct comedi_device *dev,
 
 	data[1] = devpriv->do_bits;
 
-	return 2;
+	return insn->n;
 }
 
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index af60e5d5b8a3..365028772b00 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1405,22 +1405,26 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			devpriv->dma_bits |= DMA_CH7_CH5;
 			break;
 		default:
-			dev_err(dev->hw_dev, " only supports dma channels 5 through 7\n"
-				" Dual dma only allows the following combinations:\n"
-				" dma 5,6 / 6,7 / or 7,5\n");
+			dev_err(dev->class_dev,
+				"only supports dma channels 5 through 7\n");
+			dev_err(dev->class_dev,
+				"Dual dma only allows the following combinations:\n");
+			dev_err(dev->class_dev,
+				"dma 5,6 / 6,7 / or 7,5\n");
 			return -EINVAL;
 			break;
 		}
 		if (request_dma(dma0, dev->driver->driver_name)) {
-			dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
-				dma0);
+			dev_err(dev->class_dev,
+				"failed to allocate dma channel %i\n", dma0);
 			return -EINVAL;
 		}
 		devpriv->dma0 = dma0;
 		devpriv->dma_current = dma0;
 		if (dma1) {
 			if (request_dma(dma1, dev->driver->driver_name)) {
-				dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
+				dev_err(dev->class_dev,
+					"failed to allocate dma channel %i\n",
 					dma1);
 				return -EINVAL;
 			}
@@ -1460,7 +1464,7 @@ static int das1800_probe(struct comedi_device *dev)
 	case 0x3:
 		if (board == das1801st_da || board == das1802st_da ||
 		    board == das1701st_da || board == das1702st_da) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1470,7 +1474,7 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x4:
 		if (board == das1802hr_da || board == das1702hr_da) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1481,7 +1485,7 @@ static int das1800_probe(struct comedi_device *dev)
 	case 0x5:
 		if (board == das1801ao || board == das1802ao ||
 		    board == das1701ao || board == das1702ao) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1491,7 +1495,7 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x6:
 		if (board == das1802hr || board == das1702hr) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1502,7 +1506,7 @@ static int das1800_probe(struct comedi_device *dev)
 	case 0x7:
 		if (board == das1801st || board == das1802st ||
 		    board == das1701st || board == das1702st) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1512,7 +1516,7 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x8:
 		if (board == das1801hc || board == das1802hc) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
+			dev_dbg(dev->class_dev, "Board model: %s\n",
 				das1800_boards[board].name);
 			return board;
 		}
@@ -1559,7 +1563,7 @@ static int das1800_attach(struct comedi_device *dev,
 	printk(KERN_CONT "\n");
 
 	if (iobase == 0) {
-		dev_err(dev->hw_dev, "io base address required\n");
+		dev_err(dev->class_dev, "io base address required\n");
 		return -EINVAL;
 	}
 
@@ -1574,7 +1578,7 @@ static int das1800_attach(struct comedi_device *dev,
 
 	board = das1800_probe(dev);
 	if (board < 0) {
-		dev_err(dev->hw_dev, "unable to determine board type\n");
+		dev_err(dev->class_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
 
@@ -1598,7 +1602,7 @@ static int das1800_attach(struct comedi_device *dev,
 	if (irq) {
 		if (request_irq(irq, das1800_interrupt, 0,
 				dev->driver->driver_name, dev)) {
-			dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
+			dev_dbg(dev->class_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
 		}
@@ -1628,7 +1632,7 @@ static int das1800_attach(struct comedi_device *dev,
 		devpriv->irq_dma_bits |= 0x38;
 		break;
 	default:
-		dev_err(dev->hw_dev, "irq out of range\n");
+		dev_err(dev->class_dev, "irq out of range\n");
 		return -EINVAL;
 		break;
 	}

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 12d736a6e38d..af60e5d5b8a3 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1644,8 +1644,9 @@ static int das1800_attach(struct comedi_device *dev,
 			return -ENOMEM;
 	}
 
-	if (comedi_alloc_subdevices(dev, 4) < 0)
-		return -ENOMEM;
+	retval = comedi_alloc_subdevices(dev, 4);
+	if (retval)
+		return retval;
 
 	/* analog input subdevice */
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 079fb06de215..12d736a6e38d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1644,7 +1644,7 @@ static int das1800_attach(struct comedi_device *dev,
 			return -ENOMEM;
 	}
 
-	if (alloc_subdevices(dev, 4) < 0)
+	if (comedi_alloc_subdevices(dev, 4) < 0)
 		return -ENOMEM;
 
 	/* analog input subdevice */

commit 73e183c347242c90524f8913f1af5fc481ad5370
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed May 23 18:19:17 2012 -0700

    staging: comedi: das1800: complete the refactor to remove all forward declarations
    
    Complete the refactor of the das1800 driver to remove all the
    forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2ac344354c1d..079fb06de215 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -183,46 +183,6 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_probe(struct comedi_device *dev);
-static int das1800_cancel(struct comedi_device *dev,
-			  struct comedi_subdevice *s);
-static irqreturn_t das1800_interrupt(int irq, void *d);
-static int das1800_ai_poll(struct comedi_device *dev,
-			   struct comedi_subdevice *s);
-static void das1800_ai_handler(struct comedi_device *dev);
-static void das1800_handle_dma(struct comedi_device *dev,
-			       struct comedi_subdevice *s, unsigned int status);
-static void das1800_flush_dma(struct comedi_device *dev,
-			      struct comedi_subdevice *s);
-static void das1800_flush_dma_channel(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      unsigned int channel, uint16_t *buffer);
-static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-					  struct comedi_subdevice *s);
-static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-					  struct comedi_subdevice *s);
-static int das1800_ai_do_cmdtest(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 struct comedi_cmd *cmd);
-static int das1800_ai_do_cmd(struct comedi_device *dev,
-			     struct comedi_subdevice *s);
-static int das1800_ai_rinsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int das1800_ao_winsn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int das1800_di_rbits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int das1800_do_wbits(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-
-static int das1800_set_frequency(struct comedi_device *dev);
-static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
-static unsigned int suggest_transfer_size(struct comedi_cmd *cmd);
-
 /* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {
 	8,
@@ -515,421 +475,203 @@ static const struct comedi_lrange range_ao_2 = {
 };
 */
 
-static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
-			    unsigned int dma1)
+static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
+					    uint16_t sample)
 {
-	unsigned long flags;
-
-	/*  need an irq to do dma */
-	if (dev->irq && dma0) {
-		/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
-		switch ((dma0 & 0x7) | (dma1 << 4)) {
-		case 0x5:	/*  dma0 == 5 */
-			devpriv->dma_bits |= DMA_CH5;
-			break;
-		case 0x6:	/*  dma0 == 6 */
-			devpriv->dma_bits |= DMA_CH6;
-			break;
-		case 0x7:	/*  dma0 == 7 */
-			devpriv->dma_bits |= DMA_CH7;
-			break;
-		case 0x65:	/*  dma0 == 5, dma1 == 6 */
-			devpriv->dma_bits |= DMA_CH5_CH6;
-			break;
-		case 0x76:	/*  dma0 == 6, dma1 == 7 */
-			devpriv->dma_bits |= DMA_CH6_CH7;
-			break;
-		case 0x57:	/*  dma0 == 7, dma1 == 5 */
-			devpriv->dma_bits |= DMA_CH7_CH5;
-			break;
-		default:
-			dev_err(dev->hw_dev, " only supports dma channels 5 through 7\n"
-				" Dual dma only allows the following combinations:\n"
-				" dma 5,6 / 6,7 / or 7,5\n");
-			return -EINVAL;
-			break;
-		}
-		if (request_dma(dma0, dev->driver->driver_name)) {
-			dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
-				dma0);
-			return -EINVAL;
-		}
-		devpriv->dma0 = dma0;
-		devpriv->dma_current = dma0;
-		if (dma1) {
-			if (request_dma(dma1, dev->driver->driver_name)) {
-				dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
-					dma1);
-				return -EINVAL;
-			}
-			devpriv->dma1 = dma1;
-		}
-		devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-		if (devpriv->ai_buf0 == NULL)
-			return -ENOMEM;
-		devpriv->dma_current_buf = devpriv->ai_buf0;
-		if (dma1) {
-			devpriv->ai_buf1 =
-			    kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
-			if (devpriv->ai_buf1 == NULL)
-				return -ENOMEM;
-		}
-		flags = claim_dma_lock();
-		disable_dma(devpriv->dma0);
-		set_dma_mode(devpriv->dma0, DMA_MODE_READ);
-		if (dma1) {
-			disable_dma(devpriv->dma1);
-			set_dma_mode(devpriv->dma1, DMA_MODE_READ);
-		}
-		release_dma_lock(flags);
-	}
-	return 0;
+	sample += 1 << (thisboard->resolution - 1);
+	return sample;
 }
 
-static int das1800_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it)
+static void munge_data(struct comedi_device *dev, uint16_t * array,
+		       unsigned int num_elements)
 {
-	struct comedi_subdevice *s;
-	unsigned long iobase = it->options[0];
-	unsigned int irq = it->options[1];
-	unsigned int dma0 = it->options[2];
-	unsigned int dma1 = it->options[3];
-	unsigned long iobase2;
-	int board;
-	int retval;
+	unsigned int i;
+	int unipolar;
 
-	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(struct das1800_private)) < 0)
-		return -ENOMEM;
+	/* see if card is using a unipolar or bipolar range so we can munge data correctly */
+	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
 
-	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
-	       dev->driver->driver_name, iobase);
-	if (irq) {
-		printk(KERN_CONT ", irq %u", irq);
-		if (dma0) {
-			printk(KERN_CONT ", dma %u", dma0);
-			if (dma1)
-				printk(KERN_CONT " and %u", dma1);
-		}
+	/* convert to unsigned type if we are in a bipolar mode */
+	if (!unipolar) {
+		for (i = 0; i < num_elements; i++)
+			array[i] = munge_bipolar_sample(dev, array[i]);
 	}
-	printk(KERN_CONT "\n");
+}
 
-	if (iobase == 0) {
-		dev_err(dev->hw_dev, "io base address required\n");
-		return -EINVAL;
-	}
+static void das1800_handle_fifo_half_full(struct comedi_device *dev,
+					  struct comedi_subdevice *s)
+{
+	int numPoints = 0;	/* number of points to read */
+	struct comedi_cmd *cmd = &s->async->cmd;
 
-	/* check if io addresses are available */
-	if (!request_region(iobase, DAS1800_SIZE, dev->driver->driver_name)) {
-		printk
-		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
-		     iobase, iobase + DAS1800_SIZE - 1);
-		return -EIO;
-	}
-	dev->iobase = iobase;
+	numPoints = FIFO_SIZE / 2;
+	/* if we only need some of the points */
+	if (cmd->stop_src == TRIG_COUNT && devpriv->count < numPoints)
+		numPoints = devpriv->count;
+	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
+	munge_data(dev, devpriv->ai_buf0, numPoints);
+	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
+				  numPoints * sizeof(devpriv->ai_buf0[0]));
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->count -= numPoints;
+	return;
+}
 
-	board = das1800_probe(dev);
-	if (board < 0) {
-		dev_err(dev->hw_dev, "unable to determine board type\n");
-		return -ENODEV;
-	}
+static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
+					  struct comedi_subdevice *s)
+{
+	short dpnt;
+	int unipolar;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
-	dev->board_ptr = das1800_boards + board;
-	dev->board_name = thisboard->name;
+	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
 
-	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
-	if (thisboard->ao_ability == 2) {
-		iobase2 = iobase + IOBASE2;
-		if (!request_region(iobase2, DAS1800_SIZE,
-				    dev->driver->driver_name)) {
-			printk
-			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
-			     iobase2, iobase2 + DAS1800_SIZE - 1);
-			return -EIO;
-		}
-		devpriv->iobase2 = iobase2;
+	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
+		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
+			break;
+		dpnt = inw(dev->iobase + DAS1800_FIFO);
+		/* convert to unsigned type if we are in a bipolar mode */
+		if (!unipolar)
+			;
+		dpnt = munge_bipolar_sample(dev, dpnt);
+		cfc_write_to_buffer(s, dpnt);
+		if (cmd->stop_src == TRIG_COUNT)
+			devpriv->count--;
 	}
 
-	/* grab our IRQ */
-	if (irq) {
-		if (request_irq(irq, das1800_interrupt, 0,
-				dev->driver->driver_name, dev)) {
-			dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
-				irq);
-			return -EINVAL;
-		}
-	}
-	dev->irq = irq;
+	return;
+}
 
-	/*  set bits that tell card which irq to use */
-	switch (irq) {
-	case 0:
-		break;
-	case 3:
-		devpriv->irq_dma_bits |= 0x8;
-		break;
-	case 5:
-		devpriv->irq_dma_bits |= 0x10;
-		break;
-	case 7:
-		devpriv->irq_dma_bits |= 0x18;
-		break;
-	case 10:
-		devpriv->irq_dma_bits |= 0x28;
-		break;
-	case 11:
-		devpriv->irq_dma_bits |= 0x30;
-		break;
-	case 15:
-		devpriv->irq_dma_bits |= 0x38;
-		break;
-	default:
-		dev_err(dev->hw_dev, "irq out of range\n");
-		return -EINVAL;
-		break;
-	}
+/* Utility function used by das1800_flush_dma() and das1800_handle_dma().
+ * Assumes dma lock is held */
+static void das1800_flush_dma_channel(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int channel, uint16_t *buffer)
+{
+	unsigned int num_bytes, num_samples;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
-	retval = das1800_init_dma(dev, dma0, dma1);
-	if (retval < 0)
-		return retval;
+	disable_dma(channel);
 
-	if (devpriv->ai_buf0 == NULL) {
-		devpriv->ai_buf0 =
-		    kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
-		if (devpriv->ai_buf0 == NULL)
-			return -ENOMEM;
-	}
+	/* clear flip-flop to make sure 2-byte registers
+	 * get set correctly */
+	clear_dma_ff(channel);
 
-	if (alloc_subdevices(dev, 4) < 0)
-		return -ENOMEM;
+	/*  figure out how many points to read */
+	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
+	num_samples = num_bytes / sizeof(short);
 
-	/* analog input subdevice */
-	s = dev->subdevices + 0;
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;
-	if (thisboard->common)
-		s->subdev_flags |= SDF_COMMON;
-	s->n_chan = thisboard->qram_len;
-	s->len_chanlist = thisboard->qram_len;
-	s->maxdata = (1 << thisboard->resolution) - 1;
-	s->range_table = thisboard->range_ai;
-	s->do_cmd = das1800_ai_do_cmd;
-	s->do_cmdtest = das1800_ai_do_cmdtest;
-	s->insn_read = das1800_ai_rinsn;
-	s->poll = das1800_ai_poll;
-	s->cancel = das1800_cancel;
-
-	/* analog out */
-	s = dev->subdevices + 1;
-	if (thisboard->ao_ability == 1) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE;
-		s->n_chan = thisboard->ao_n_chan;
-		s->maxdata = (1 << thisboard->resolution) - 1;
-		s->range_table = &range_ao_1;
-		s->insn_write = das1800_ao_winsn;
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
+	/* if we only need some of the points */
+	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)
+		num_samples = devpriv->count;
 
-	/* di */
-	s = dev->subdevices + 2;
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE;
-	s->n_chan = 4;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das1800_di_rbits;
+	munge_data(dev, buffer, num_samples);
+	cfc_write_array_to_buffer(s, buffer, num_bytes);
+	if (s->async->cmd.stop_src == TRIG_COUNT)
+		devpriv->count -= num_samples;
 
-	/* do */
-	s = dev->subdevices + 3;
-	s->type = COMEDI_SUBD_DO;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = thisboard->do_n_chan;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
-	s->insn_bits = das1800_do_wbits;
+	return;
+}
 
-	das1800_cancel(dev, dev->read_subdev);
+/* flushes remaining data from board when external trigger has stopped acquisition
+ * and we are using dma transfers */
+static void das1800_flush_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
+{
+	unsigned long flags;
+	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	/*  initialize digital out channels */
-	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+	flags = claim_dma_lock();
+	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+				  devpriv->dma_current_buf);
 
-	/*  initialize analog out channels */
-	if (thisboard->ao_ability == 1) {
-		/*  select 'update' dac channel for baseAddress + 0x0 */
-		outb(DAC(thisboard->ao_n_chan - 1),
-		     dev->iobase + DAS1800_SELECT);
-		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
+	if (dual_dma) {
+		/*  switch to other channel and flush it */
+		if (devpriv->dma_current == devpriv->dma0) {
+			devpriv->dma_current = devpriv->dma1;
+			devpriv->dma_current_buf = devpriv->ai_buf1;
+		} else {
+			devpriv->dma_current = devpriv->dma0;
+			devpriv->dma_current_buf = devpriv->ai_buf0;
+		}
+		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+					  devpriv->dma_current_buf);
 	}
 
-	return 0;
-};
+	release_dma_lock(flags);
 
-static void das1800_detach(struct comedi_device *dev)
-{
-	if (dev->iobase)
-		release_region(dev->iobase, DAS1800_SIZE);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->private) {
-		if (devpriv->iobase2)
-			release_region(devpriv->iobase2, DAS1800_SIZE);
-		if (devpriv->dma0)
-			free_dma(devpriv->dma0);
-		if (devpriv->dma1)
-			free_dma(devpriv->dma1);
-		kfree(devpriv->ai_buf0);
-		kfree(devpriv->ai_buf1);
-	}
-};
+	/*  get any remaining samples in fifo */
+	das1800_handle_fifo_not_empty(dev, s);
 
-/* probes and checks das-1800 series board type
- */
-static int das1800_probe(struct comedi_device *dev)
+	return;
+}
+
+static void das1800_handle_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s, unsigned int status)
 {
-	int id;
-	int board;
+	unsigned long flags;
+	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
-	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
-	board = ((struct das1800_board *)dev->board_ptr) - das1800_boards;
+	flags = claim_dma_lock();
+	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+				  devpriv->dma_current_buf);
+	/*  re-enable  dma channel */
+	set_dma_addr(devpriv->dma_current,
+		     virt_to_bus(devpriv->dma_current_buf));
+	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
+	enable_dma(devpriv->dma_current);
+	release_dma_lock(flags);
 
-	switch (id) {
-	case 0x3:
-		if (board == das1801st_da || board == das1802st_da ||
-		    board == das1701st_da || board == das1702st_da) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800st-da series\n");
-		return das1801st;
-		break;
-	case 0x4:
-		if (board == das1802hr_da || board == das1702hr_da) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1802hr-da\n");
-		return das1802hr;
-		break;
-	case 0x5:
-		if (board == das1801ao || board == das1802ao ||
-		    board == das1701ao || board == das1702ao) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800ao series\n");
-		return das1801ao;
-		break;
-	case 0x6:
-		if (board == das1802hr || board == das1702hr) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1802hr\n");
-		return das1802hr;
-		break;
-	case 0x7:
-		if (board == das1801st || board == das1802st ||
-		    board == das1701st || board == das1702st) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
-		}
-		printk
-		    (" Board model (probed, not recommended): das-1800st series\n");
-		return das1801st;
-		break;
-	case 0x8:
-		if (board == das1801hc || board == das1802hc) {
-			dev_dbg(dev->hw_dev, "Board model: %s\n",
-				das1800_boards[board].name);
-			return board;
+	if (status & DMATC) {
+		/*  clear DMATC interrupt bit */
+		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
+		/*  switch dma channels for next time, if appropriate */
+		if (dual_dma) {
+			/*  read data from the other channel next time */
+			if (devpriv->dma_current == devpriv->dma0) {
+				devpriv->dma_current = devpriv->dma1;
+				devpriv->dma_current_buf = devpriv->ai_buf1;
+			} else {
+				devpriv->dma_current = devpriv->dma0;
+				devpriv->dma_current_buf = devpriv->ai_buf0;
+			}
 		}
-		printk
-		    (" Board model (probed, not recommended): das-1800hc series\n");
-		return das1801hc;
-		break;
-	default:
-		printk
-		    (" Board model: probe returned 0x%x (unknown, please report)\n",
-		     id);
-		return board;
-		break;
 	}
-	return -1;
+
+	return;
 }
 
-static int das1800_ai_poll(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
+static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	unsigned long flags;
-
-	/*  prevent race with interrupt handler */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	das1800_ai_handler(dev);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	return s->async->buf_write_count - s->async->buf_read_count;
+	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
+	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
+	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
+	if (devpriv->dma0)
+		disable_dma(devpriv->dma0);
+	if (devpriv->dma1)
+		disable_dma(devpriv->dma1);
+	return 0;
 }
 
-static irqreturn_t das1800_interrupt(int irq, void *d)
+/* the guts of the interrupt handler, that is shared with das1800_ai_poll */
+static void das1800_ai_handler(struct comedi_device *dev)
 {
-	struct comedi_device *dev = d;
-	unsigned int status;
+	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
-	if (dev->attached == 0) {
-		comedi_error(dev, "premature interrupt");
-		return IRQ_HANDLED;
-	}
-
-	/* Prevent race with das1800_ai_poll() on multi processor systems.
-	 * Also protects indirect addressing in das1800_ai_handler */
-	spin_lock(&dev->spinlock);
-	status = inb(dev->iobase + DAS1800_STATUS);
-
-	/* if interrupt was not caused by das-1800 */
-	if (!(status & INT)) {
-		spin_unlock(&dev->spinlock);
-		return IRQ_NONE;
-	}
-	/* clear the interrupt status bit INT */
-	outb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);
-	/*  handle interrupt */
-	das1800_ai_handler(dev);
-
-	spin_unlock(&dev->spinlock);
-	return IRQ_HANDLED;
-}
-
-/* the guts of the interrupt handler, that is shared with das1800_ai_poll */
-static void das1800_ai_handler(struct comedi_device *dev)
-{
-	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
-
-	async->events = 0;
-	/*  select adc for base address + 0 */
-	outb(ADC, dev->iobase + DAS1800_SELECT);
-	/*  dma buffer full */
-	if (devpriv->irq_dma_bits & DMA_ENABLED) {
-		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
-		das1800_handle_dma(dev, s, status);
-	} else if (status & FHF) {	/*  if fifo half full */
-		das1800_handle_fifo_half_full(dev, s);
-	} else if (status & FNE) {	/*  if fifo not empty */
-		das1800_handle_fifo_not_empty(dev, s);
+	async->events = 0;
+	/*  select adc for base address + 0 */
+	outb(ADC, dev->iobase + DAS1800_SELECT);
+	/*  dma buffer full */
+	if (devpriv->irq_dma_bits & DMA_ENABLED) {
+		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
+		das1800_handle_dma(dev, s, status);
+	} else if (status & FHF) {	/*  if fifo half full */
+		das1800_handle_fifo_half_full(dev, s);
+	} else if (status & FNE) {	/*  if fifo not empty */
+		das1800_handle_fifo_not_empty(dev, s);
 	}
 
 	async->events |= COMEDI_CB_BLOCK;
@@ -965,182 +707,75 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	return;
 }
 
-static void das1800_handle_dma(struct comedi_device *dev,
-			       struct comedi_subdevice *s, unsigned int status)
+static int das1800_ai_poll(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long flags;
-	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
-
-	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-				  devpriv->dma_current_buf);
-	/*  re-enable  dma channel */
-	set_dma_addr(devpriv->dma_current,
-		     virt_to_bus(devpriv->dma_current_buf));
-	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
-	enable_dma(devpriv->dma_current);
-	release_dma_lock(flags);
-
-	if (status & DMATC) {
-		/*  clear DMATC interrupt bit */
-		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
-		/*  switch dma channels for next time, if appropriate */
-		if (dual_dma) {
-			/*  read data from the other channel next time */
-			if (devpriv->dma_current == devpriv->dma0) {
-				devpriv->dma_current = devpriv->dma1;
-				devpriv->dma_current_buf = devpriv->ai_buf1;
-			} else {
-				devpriv->dma_current = devpriv->dma0;
-				devpriv->dma_current_buf = devpriv->ai_buf0;
-			}
-		}
-	}
 
-	return;
-}
+	/*  prevent race with interrupt handler */
+	spin_lock_irqsave(&dev->spinlock, flags);
+	das1800_ai_handler(dev);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
-					    uint16_t sample)
-{
-	sample += 1 << (thisboard->resolution - 1);
-	return sample;
+	return s->async->buf_write_count - s->async->buf_read_count;
 }
 
-static void munge_data(struct comedi_device *dev, uint16_t * array,
-		       unsigned int num_elements)
+static irqreturn_t das1800_interrupt(int irq, void *d)
 {
-	unsigned int i;
-	int unipolar;
-
-	/* see if card is using a unipolar or bipolar range so we can munge data correctly */
-	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
+	struct comedi_device *dev = d;
+	unsigned int status;
 
-	/* convert to unsigned type if we are in a bipolar mode */
-	if (!unipolar) {
-		for (i = 0; i < num_elements; i++)
-			array[i] = munge_bipolar_sample(dev, array[i]);
+	if (dev->attached == 0) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
 	}
-}
-
-/* Utility function used by das1800_flush_dma() and das1800_handle_dma().
- * Assumes dma lock is held */
-static void das1800_flush_dma_channel(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      unsigned int channel, uint16_t *buffer)
-{
-	unsigned int num_bytes, num_samples;
-	struct comedi_cmd *cmd = &s->async->cmd;
-
-	disable_dma(channel);
-
-	/* clear flip-flop to make sure 2-byte registers
-	 * get set correctly */
-	clear_dma_ff(channel);
-
-	/*  figure out how many points to read */
-	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
-	num_samples = num_bytes / sizeof(short);
-
-	/* if we only need some of the points */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)
-		num_samples = devpriv->count;
-
-	munge_data(dev, buffer, num_samples);
-	cfc_write_array_to_buffer(s, buffer, num_bytes);
-	if (s->async->cmd.stop_src == TRIG_COUNT)
-		devpriv->count -= num_samples;
 
-	return;
-}
-
-/* flushes remaining data from board when external trigger has stopped acquisition
- * and we are using dma transfers */
-static void das1800_flush_dma(struct comedi_device *dev,
-			      struct comedi_subdevice *s)
-{
-	unsigned long flags;
-	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
-
-	flags = claim_dma_lock();
-	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-				  devpriv->dma_current_buf);
+	/* Prevent race with das1800_ai_poll() on multi processor systems.
+	 * Also protects indirect addressing in das1800_ai_handler */
+	spin_lock(&dev->spinlock);
+	status = inb(dev->iobase + DAS1800_STATUS);
 
-	if (dual_dma) {
-		/*  switch to other channel and flush it */
-		if (devpriv->dma_current == devpriv->dma0) {
-			devpriv->dma_current = devpriv->dma1;
-			devpriv->dma_current_buf = devpriv->ai_buf1;
-		} else {
-			devpriv->dma_current = devpriv->dma0;
-			devpriv->dma_current_buf = devpriv->ai_buf0;
-		}
-		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-					  devpriv->dma_current_buf);
+	/* if interrupt was not caused by das-1800 */
+	if (!(status & INT)) {
+		spin_unlock(&dev->spinlock);
+		return IRQ_NONE;
 	}
+	/* clear the interrupt status bit INT */
+	outb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);
+	/*  handle interrupt */
+	das1800_ai_handler(dev);
 
-	release_dma_lock(flags);
-
-	/*  get any remaining samples in fifo */
-	das1800_handle_fifo_not_empty(dev, s);
-
-	return;
-}
-
-static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-					  struct comedi_subdevice *s)
-{
-	int numPoints = 0;	/* number of points to read */
-	struct comedi_cmd *cmd = &s->async->cmd;
-
-	numPoints = FIFO_SIZE / 2;
-	/* if we only need some of the points */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->count < numPoints)
-		numPoints = devpriv->count;
-	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
-	munge_data(dev, devpriv->ai_buf0, numPoints);
-	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
-				  numPoints * sizeof(devpriv->ai_buf0[0]));
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count -= numPoints;
-	return;
+	spin_unlock(&dev->spinlock);
+	return IRQ_HANDLED;
 }
 
-static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-					  struct comedi_subdevice *s)
+/* converts requested conversion timing to timing compatible with
+ * hardware, used only when card is in 'burst mode'
+ */
+static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 {
-	short dpnt;
-	int unipolar;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int micro_sec;
 
-	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
+	/*  in burst mode, the maximum conversion time is 64 microseconds */
+	if (convert_arg > 64000)
+		convert_arg = 64000;
 
-	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
-		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
-			break;
-		dpnt = inw(dev->iobase + DAS1800_FIFO);
-		/* convert to unsigned type if we are in a bipolar mode */
-		if (!unipolar)
-			;
-		dpnt = munge_bipolar_sample(dev, dpnt);
-		cfc_write_to_buffer(s, dpnt);
-		if (cmd->stop_src == TRIG_COUNT)
-			devpriv->count--;
+	/*  the conversion time must be an integral number of microseconds */
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		micro_sec = (convert_arg + 500) / 1000;
+		break;
+	case TRIG_ROUND_DOWN:
+		micro_sec = convert_arg / 1000;
+		break;
+	case TRIG_ROUND_UP:
+		micro_sec = (convert_arg - 1) / 1000 + 1;
+		break;
 	}
 
-	return;
-}
-
-static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
-{
-	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
-	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
-	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
-	if (devpriv->dma0)
-		disable_dma(devpriv->dma0);
-	if (devpriv->dma1)
-		disable_dma(devpriv->dma1);
-	return 0;
+	/*  return number of nanoseconds */
+	return micro_sec * 1000;
 }
 
 /* test analog input cmd */
@@ -1322,10 +957,6 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-/* analog input cmd interface */
-
-/* first, some utility functions used in the main ai_do_cmd() */
-
 /* returns appropriate bits for control register a, depending on command */
 static int control_a_bits(struct comedi_cmd cmd)
 {
@@ -1396,15 +1027,34 @@ static int control_c_bits(struct comedi_cmd cmd)
 	return control_c;
 }
 
-/* sets up counters */
-static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
+/* loads counters with divisor1, divisor2 from private structure */
+static int das1800_set_frequency(struct comedi_device *dev)
 {
-	/*  setup cascaded counters for conversion/scan frequency */
-	switch (cmd.scan_begin_src) {
-	case TRIG_FOLLOW:	/*  not in burst mode */
-		if (cmd.convert_src == TRIG_TIMER) {
-			/* set conversion frequency */
-			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+	int err = 0;
+
+	/*  counter 1, mode 2 */
+	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
+		       2))
+		err++;
+	/*  counter 2, mode 2 */
+	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
+		       2))
+		err++;
+	if (err)
+		return -1;
+
+	return 0;
+}
+
+/* sets up counters */
+static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
+{
+	/*  setup cascaded counters for conversion/scan frequency */
+	switch (cmd.scan_begin_src) {
+	case TRIG_FOLLOW:	/*  not in burst mode */
+		if (cmd.convert_src == TRIG_TIMER) {
+			/* set conversion frequency */
+			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
 						       &(devpriv->divisor1),
 						       &(devpriv->divisor2),
 						       &(cmd.convert_arg),
@@ -1436,6 +1086,44 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 	return 0;
 }
 
+/* utility function that suggests a dma transfer size based on the conversion period 'ns' */
+static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
+{
+	unsigned int size = DMA_BUF_SIZE;
+	static const int sample_size = 2;	/*  size in bytes of one sample from board */
+	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
+	unsigned int max_size;	/*  maximum size we will allow for a transfer */
+
+	/*  make dma buffer fill in 0.3 seconds for timed modes */
+	switch (cmd->scan_begin_src) {
+	case TRIG_FOLLOW:	/*  not in burst mode */
+		if (cmd->convert_src == TRIG_TIMER)
+			size = (fill_time / cmd->convert_arg) * sample_size;
+		break;
+	case TRIG_TIMER:
+		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
+		    sample_size;
+		break;
+	default:
+		size = DMA_BUF_SIZE;
+		break;
+	}
+
+	/*  set a minimum and maximum size allowed */
+	max_size = DMA_BUF_SIZE;
+	/*  if we are taking limited number of conversions, limit transfer size to that */
+	if (cmd->stop_src == TRIG_COUNT &&
+	    cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
+		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
+
+	if (size > max_size)
+		size = max_size;
+	if (size < sample_size)
+		size = sample_size;
+
+	return size;
+}
+
 /* sets up dma */
 static void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)
 {
@@ -1689,91 +1377,357 @@ static int das1800_do_wbits(struct comedi_device *dev,
 	return 2;
 }
 
-/* loads counters with divisor1, divisor2 from private structure */
-static int das1800_set_frequency(struct comedi_device *dev)
+static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
+			    unsigned int dma1)
 {
-	int err = 0;
-
-	/*  counter 1, mode 2 */
-	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
-		       2))
-		err++;
-	/*  counter 2, mode 2 */
-	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
-		       2))
-		err++;
-	if (err)
-		return -1;
+	unsigned long flags;
 
+	/*  need an irq to do dma */
+	if (dev->irq && dma0) {
+		/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
+		switch ((dma0 & 0x7) | (dma1 << 4)) {
+		case 0x5:	/*  dma0 == 5 */
+			devpriv->dma_bits |= DMA_CH5;
+			break;
+		case 0x6:	/*  dma0 == 6 */
+			devpriv->dma_bits |= DMA_CH6;
+			break;
+		case 0x7:	/*  dma0 == 7 */
+			devpriv->dma_bits |= DMA_CH7;
+			break;
+		case 0x65:	/*  dma0 == 5, dma1 == 6 */
+			devpriv->dma_bits |= DMA_CH5_CH6;
+			break;
+		case 0x76:	/*  dma0 == 6, dma1 == 7 */
+			devpriv->dma_bits |= DMA_CH6_CH7;
+			break;
+		case 0x57:	/*  dma0 == 7, dma1 == 5 */
+			devpriv->dma_bits |= DMA_CH7_CH5;
+			break;
+		default:
+			dev_err(dev->hw_dev, " only supports dma channels 5 through 7\n"
+				" Dual dma only allows the following combinations:\n"
+				" dma 5,6 / 6,7 / or 7,5\n");
+			return -EINVAL;
+			break;
+		}
+		if (request_dma(dma0, dev->driver->driver_name)) {
+			dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
+				dma0);
+			return -EINVAL;
+		}
+		devpriv->dma0 = dma0;
+		devpriv->dma_current = dma0;
+		if (dma1) {
+			if (request_dma(dma1, dev->driver->driver_name)) {
+				dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
+					dma1);
+				return -EINVAL;
+			}
+			devpriv->dma1 = dma1;
+		}
+		devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+		if (devpriv->ai_buf0 == NULL)
+			return -ENOMEM;
+		devpriv->dma_current_buf = devpriv->ai_buf0;
+		if (dma1) {
+			devpriv->ai_buf1 =
+			    kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+			if (devpriv->ai_buf1 == NULL)
+				return -ENOMEM;
+		}
+		flags = claim_dma_lock();
+		disable_dma(devpriv->dma0);
+		set_dma_mode(devpriv->dma0, DMA_MODE_READ);
+		if (dma1) {
+			disable_dma(devpriv->dma1);
+			set_dma_mode(devpriv->dma1, DMA_MODE_READ);
+		}
+		release_dma_lock(flags);
+	}
 	return 0;
 }
 
-/* converts requested conversion timing to timing compatible with
- * hardware, used only when card is in 'burst mode'
- */
-static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
+static int das1800_probe(struct comedi_device *dev)
 {
-	unsigned int micro_sec;
+	int id;
+	int board;
 
-	/*  in burst mode, the maximum conversion time is 64 microseconds */
-	if (convert_arg > 64000)
-		convert_arg = 64000;
+	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
+	board = ((struct das1800_board *)dev->board_ptr) - das1800_boards;
 
-	/*  the conversion time must be an integral number of microseconds */
-	switch (round_mode) {
-	case TRIG_ROUND_NEAREST:
-	default:
-		micro_sec = (convert_arg + 500) / 1000;
+	switch (id) {
+	case 0x3:
+		if (board == das1801st_da || board == das1802st_da ||
+		    board == das1701st_da || board == das1702st_da) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1800st-da series\n");
+		return das1801st;
 		break;
-	case TRIG_ROUND_DOWN:
-		micro_sec = convert_arg / 1000;
+	case 0x4:
+		if (board == das1802hr_da || board == das1702hr_da) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1802hr-da\n");
+		return das1802hr;
 		break;
-	case TRIG_ROUND_UP:
-		micro_sec = (convert_arg - 1) / 1000 + 1;
+	case 0x5:
+		if (board == das1801ao || board == das1802ao ||
+		    board == das1701ao || board == das1702ao) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1800ao series\n");
+		return das1801ao;
+		break;
+	case 0x6:
+		if (board == das1802hr || board == das1702hr) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1802hr\n");
+		return das1802hr;
+		break;
+	case 0x7:
+		if (board == das1801st || board == das1802st ||
+		    board == das1701st || board == das1702st) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1800st series\n");
+		return das1801st;
+		break;
+	case 0x8:
+		if (board == das1801hc || board == das1802hc) {
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk
+		    (" Board model (probed, not recommended): das-1800hc series\n");
+		return das1801hc;
+		break;
+	default:
+		printk
+		    (" Board model: probe returned 0x%x (unknown, please report)\n",
+		     id);
+		return board;
 		break;
 	}
-
-	/*  return number of nanoseconds */
-	return micro_sec * 1000;
+	return -1;
 }
 
-/* utility function that suggests a dma transfer size based on the conversion period 'ns' */
-static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
+static int das1800_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
-	unsigned int size = DMA_BUF_SIZE;
-	static const int sample_size = 2;	/*  size in bytes of one sample from board */
-	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
-	unsigned int max_size;	/*  maximum size we will allow for a transfer */
+	struct comedi_subdevice *s;
+	unsigned long iobase = it->options[0];
+	unsigned int irq = it->options[1];
+	unsigned int dma0 = it->options[2];
+	unsigned int dma1 = it->options[3];
+	unsigned long iobase2;
+	int board;
+	int retval;
 
-	/*  make dma buffer fill in 0.3 seconds for timed modes */
-	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:	/*  not in burst mode */
-		if (cmd->convert_src == TRIG_TIMER)
-			size = (fill_time / cmd->convert_arg) * sample_size;
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(struct das1800_private)) < 0)
+		return -ENOMEM;
+
+	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
+	       dev->driver->driver_name, iobase);
+	if (irq) {
+		printk(KERN_CONT ", irq %u", irq);
+		if (dma0) {
+			printk(KERN_CONT ", dma %u", dma0);
+			if (dma1)
+				printk(KERN_CONT " and %u", dma1);
+		}
+	}
+	printk(KERN_CONT "\n");
+
+	if (iobase == 0) {
+		dev_err(dev->hw_dev, "io base address required\n");
+		return -EINVAL;
+	}
+
+	/* check if io addresses are available */
+	if (!request_region(iobase, DAS1800_SIZE, dev->driver->driver_name)) {
+		printk
+		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+		     iobase, iobase + DAS1800_SIZE - 1);
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	board = das1800_probe(dev);
+	if (board < 0) {
+		dev_err(dev->hw_dev, "unable to determine board type\n");
+		return -ENODEV;
+	}
+
+	dev->board_ptr = das1800_boards + board;
+	dev->board_name = thisboard->name;
+
+	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
+	if (thisboard->ao_ability == 2) {
+		iobase2 = iobase + IOBASE2;
+		if (!request_region(iobase2, DAS1800_SIZE,
+				    dev->driver->driver_name)) {
+			printk
+			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+			     iobase2, iobase2 + DAS1800_SIZE - 1);
+			return -EIO;
+		}
+		devpriv->iobase2 = iobase2;
+	}
+
+	/* grab our IRQ */
+	if (irq) {
+		if (request_irq(irq, das1800_interrupt, 0,
+				dev->driver->driver_name, dev)) {
+			dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
+				irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+	/*  set bits that tell card which irq to use */
+	switch (irq) {
+	case 0:
 		break;
-	case TRIG_TIMER:
-		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
-		    sample_size;
+	case 3:
+		devpriv->irq_dma_bits |= 0x8;
+		break;
+	case 5:
+		devpriv->irq_dma_bits |= 0x10;
+		break;
+	case 7:
+		devpriv->irq_dma_bits |= 0x18;
+		break;
+	case 10:
+		devpriv->irq_dma_bits |= 0x28;
+		break;
+	case 11:
+		devpriv->irq_dma_bits |= 0x30;
+		break;
+	case 15:
+		devpriv->irq_dma_bits |= 0x38;
 		break;
 	default:
-		size = DMA_BUF_SIZE;
+		dev_err(dev->hw_dev, "irq out of range\n");
+		return -EINVAL;
 		break;
 	}
 
-	/*  set a minimum and maximum size allowed */
-	max_size = DMA_BUF_SIZE;
-	/*  if we are taking limited number of conversions, limit transfer size to that */
-	if (cmd->stop_src == TRIG_COUNT &&
-	    cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
-		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
+	retval = das1800_init_dma(dev, dma0, dma1);
+	if (retval < 0)
+		return retval;
 
-	if (size > max_size)
-		size = max_size;
-	if (size < sample_size)
-		size = sample_size;
+	if (devpriv->ai_buf0 == NULL) {
+		devpriv->ai_buf0 =
+		    kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+		if (devpriv->ai_buf0 == NULL)
+			return -ENOMEM;
+	}
 
-	return size;
-}
+	if (alloc_subdevices(dev, 4) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;
+	if (thisboard->common)
+		s->subdev_flags |= SDF_COMMON;
+	s->n_chan = thisboard->qram_len;
+	s->len_chanlist = thisboard->qram_len;
+	s->maxdata = (1 << thisboard->resolution) - 1;
+	s->range_table = thisboard->range_ai;
+	s->do_cmd = das1800_ai_do_cmd;
+	s->do_cmdtest = das1800_ai_do_cmdtest;
+	s->insn_read = das1800_ai_rinsn;
+	s->poll = das1800_ai_poll;
+	s->cancel = das1800_cancel;
+
+	/* analog out */
+	s = dev->subdevices + 1;
+	if (thisboard->ao_ability == 1) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE;
+		s->n_chan = thisboard->ao_n_chan;
+		s->maxdata = (1 << thisboard->resolution) - 1;
+		s->range_table = &range_ao_1;
+		s->insn_write = das1800_ao_winsn;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* di */
+	s = dev->subdevices + 2;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das1800_di_rbits;
+
+	/* do */
+	s = dev->subdevices + 3;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = thisboard->do_n_chan;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das1800_do_wbits;
+
+	das1800_cancel(dev, dev->read_subdev);
+
+	/*  initialize digital out channels */
+	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+
+	/*  initialize analog out channels */
+	if (thisboard->ao_ability == 1) {
+		/*  select 'update' dac channel for baseAddress + 0x0 */
+		outb(DAC(thisboard->ao_n_chan - 1),
+		     dev->iobase + DAS1800_SELECT);
+		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
+	}
+
+	return 0;
+};
+
+static void das1800_detach(struct comedi_device *dev)
+{
+	if (dev->iobase)
+		release_region(dev->iobase, DAS1800_SIZE);
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->private) {
+		if (devpriv->iobase2)
+			release_region(devpriv->iobase2, DAS1800_SIZE);
+		if (devpriv->dma0)
+			free_dma(devpriv->dma0);
+		if (devpriv->dma1)
+			free_dma(devpriv->dma1);
+		kfree(devpriv->ai_buf0);
+		kfree(devpriv->ai_buf1);
+	}
+};
 
 static struct comedi_driver das1800_driver = {
 	.driver_name	= "das1800",

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 0b1f499dea3a..2ac344354c1d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -767,9 +767,8 @@ static int das1800_attach(struct comedi_device *dev,
 	return 0;
 };
 
-static int das1800_detach(struct comedi_device *dev)
+static void das1800_detach(struct comedi_device *dev)
 {
-	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase)
 		release_region(dev->iobase, DAS1800_SIZE);
 	if (dev->irq)
@@ -784,11 +783,6 @@ static int das1800_detach(struct comedi_device *dev)
 		kfree(devpriv->ai_buf0);
 		kfree(devpriv->ai_buf1);
 	}
-
-	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
-		dev->driver->driver_name);
-
-	return 0;
 };
 
 /* probes and checks das-1800 series board type

commit 1e991a14db758ab5050108a43651e7f86569e858
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 18:34:49 2012 -0700

    staging: comedi: refactor das1800 driver and use module_comedi_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive to the end of the source. This is more
    typical of how other drivers are written and removes the need
    for the forward declarations.
    
    Convert the driver to use the module_comedi_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 99ada5a53b9e..0b1f499dea3a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -183,9 +183,6 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(struct comedi_device *dev,
-			  struct comedi_devconfig *it);
-static int das1800_detach(struct comedi_device *dev);
 static int das1800_probe(struct comedi_device *dev);
 static int das1800_cancel(struct comedi_device *dev,
 			  struct comedi_subdevice *s);
@@ -518,33 +515,6 @@ static const struct comedi_lrange range_ao_2 = {
 };
 */
 
-static struct comedi_driver driver_das1800 = {
-	.driver_name = "das1800",
-	.module = THIS_MODULE,
-	.attach = das1800_attach,
-	.detach = das1800_detach,
-	.num_names = ARRAY_SIZE(das1800_boards),
-	.board_name = &das1800_boards[0].name,
-	.offset = sizeof(struct das1800_board),
-};
-
-/*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
- */
-static int __init driver_das1800_init_module(void)
-{
-	return comedi_driver_register(&driver_das1800);
-}
-
-static void __exit driver_das1800_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_das1800);
-}
-
-module_init(driver_das1800_init_module);
-module_exit(driver_das1800_cleanup_module);
-
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			    unsigned int dma1)
 {
@@ -579,7 +549,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			return -EINVAL;
 			break;
 		}
-		if (request_dma(dma0, driver_das1800.driver_name)) {
+		if (request_dma(dma0, dev->driver->driver_name)) {
 			dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
 				dma0);
 			return -EINVAL;
@@ -587,7 +557,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 		devpriv->dma0 = dma0;
 		devpriv->dma_current = dma0;
 		if (dma1) {
-			if (request_dma(dma1, driver_das1800.driver_name)) {
+			if (request_dma(dma1, dev->driver->driver_name)) {
 				dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
 					dma1);
 				return -EINVAL;
@@ -633,7 +603,7 @@ static int das1800_attach(struct comedi_device *dev,
 		return -ENOMEM;
 
 	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
-	       driver_das1800.driver_name, iobase);
+	       dev->driver->driver_name, iobase);
 	if (irq) {
 		printk(KERN_CONT ", irq %u", irq);
 		if (dma0) {
@@ -650,7 +620,7 @@ static int das1800_attach(struct comedi_device *dev,
 	}
 
 	/* check if io addresses are available */
-	if (!request_region(iobase, DAS1800_SIZE, driver_das1800.driver_name)) {
+	if (!request_region(iobase, DAS1800_SIZE, dev->driver->driver_name)) {
 		printk
 		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
 		     iobase, iobase + DAS1800_SIZE - 1);
@@ -671,7 +641,7 @@ static int das1800_attach(struct comedi_device *dev,
 	if (thisboard->ao_ability == 2) {
 		iobase2 = iobase + IOBASE2;
 		if (!request_region(iobase2, DAS1800_SIZE,
-				    driver_das1800.driver_name)) {
+				    dev->driver->driver_name)) {
 			printk
 			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
 			     iobase2, iobase2 + DAS1800_SIZE - 1);
@@ -683,7 +653,7 @@ static int das1800_attach(struct comedi_device *dev,
 	/* grab our IRQ */
 	if (irq) {
 		if (request_irq(irq, das1800_interrupt, 0,
-				driver_das1800.driver_name, dev)) {
+				dev->driver->driver_name, dev)) {
 			dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
 				irq);
 			return -EINVAL;
@@ -816,7 +786,7 @@ static int das1800_detach(struct comedi_device *dev)
 	}
 
 	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
-		driver_das1800.driver_name);
+		dev->driver->driver_name);
 
 	return 0;
 };
@@ -1811,6 +1781,17 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 	return size;
 }
 
+static struct comedi_driver das1800_driver = {
+	.driver_name	= "das1800",
+	.module		= THIS_MODULE,
+	.attach		= das1800_attach,
+	.detach		= das1800_detach,
+	.num_names	= ARRAY_SIZE(das1800_boards),
+	.board_name	= &das1800_boards[0].name,
+	.offset		= sizeof(struct das1800_board),
+};
+module_comedi_driver(das1800_driver);
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit cecdee85515595cbb4f586918aff076aa7dbb7be
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:39 2011 +0530

    Staging: comedi: fix printk issue in das1800.c
    
    This is a patch to the das1800.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printk to dev_<levels>.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3ca751c7485b..99ada5a53b9e 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -573,9 +573,9 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			devpriv->dma_bits |= DMA_CH7_CH5;
 			break;
 		default:
-			printk(" only supports dma channels 5 through 7\n"
-			       " Dual dma only allows the following combinations:\n"
-			       " dma 5,6 / 6,7 / or 7,5\n");
+			dev_err(dev->hw_dev, " only supports dma channels 5 through 7\n"
+				" Dual dma only allows the following combinations:\n"
+				" dma 5,6 / 6,7 / or 7,5\n");
 			return -EINVAL;
 			break;
 		}
@@ -645,7 +645,7 @@ static int das1800_attach(struct comedi_device *dev,
 	printk(KERN_CONT "\n");
 
 	if (iobase == 0) {
-		printk(" io base address required\n");
+		dev_err(dev->hw_dev, "io base address required\n");
 		return -EINVAL;
 	}
 
@@ -815,8 +815,8 @@ static int das1800_detach(struct comedi_device *dev)
 		kfree(devpriv->ai_buf1);
 	}
 
-	printk("comedi%d: %s: remove\n", dev->minor,
-	       driver_das1800.driver_name);
+	dev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,
+		driver_das1800.driver_name);
 
 	return 0;
 };

commit 7cf372b1c40d8d979e64e03eb401a7daa09a8902
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:38 2011 +0530

    Staging: comedi: fix printk issue in das1800.c
    
    This is a patch to the das1800.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Included KERN_facility levels for printk.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6ef3e8f9aa8f..3ca751c7485b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -632,17 +632,17 @@ static int das1800_attach(struct comedi_device *dev,
 	if (alloc_private(dev, sizeof(struct das1800_private)) < 0)
 		return -ENOMEM;
 
-	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_das1800.driver_name,
-	       iobase);
+	printk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,
+	       driver_das1800.driver_name, iobase);
 	if (irq) {
-		printk(", irq %u", irq);
+		printk(KERN_CONT ", irq %u", irq);
 		if (dma0) {
-			printk(", dma %u", dma0);
+			printk(KERN_CONT ", dma %u", dma0);
 			if (dma1)
-				printk(" and %u", dma1);
+				printk(KERN_CONT " and %u", dma1);
 		}
 	}
-	printk("\n");
+	printk(KERN_CONT "\n");
 
 	if (iobase == 0) {
 		printk(" io base address required\n");

commit 7a647b9e4a583d514899b22c5e5fa3a849c8b2a0
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:32 2011 +0530

    Staging: comedi: fix printk issue in das1800.c
    
    This is a patch to the das1800.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_dbg().
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 1ea97896b6bd..6ef3e8f9aa8f 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -835,8 +835,8 @@ static int das1800_probe(struct comedi_device *dev)
 	case 0x3:
 		if (board == das1801st_da || board == das1802st_da ||
 		    board == das1701st_da || board == das1702st_da) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
 		printk
@@ -845,8 +845,8 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x4:
 		if (board == das1802hr_da || board == das1702hr_da) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
 		printk
@@ -856,8 +856,8 @@ static int das1800_probe(struct comedi_device *dev)
 	case 0x5:
 		if (board == das1801ao || board == das1802ao ||
 		    board == das1701ao || board == das1702ao) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
 		printk
@@ -866,18 +866,19 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x6:
 		if (board == das1802hr || board == das1702hr) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1802hr\n");
+		printk
+		    (" Board model (probed, not recommended): das-1802hr\n");
 		return das1802hr;
 		break;
 	case 0x7:
 		if (board == das1801st || board == das1802st ||
 		    board == das1701st || board == das1702st) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
 		printk
@@ -886,8 +887,8 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x8:
 		if (board == das1801hc || board == das1802hc) {
-			printk(" Board model: %s\n",
-			       das1800_boards[board].name);
+			dev_dbg(dev->hw_dev, "Board model: %s\n",
+				das1800_boards[board].name);
 			return board;
 		}
 		printk

commit 1e3a2875684bcc4af1e2f6597fdd502cc59e3593
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:31 2011 +0530

    Staging: comedi: fix printk issue in das1800.c
    
    This is a patch to the das1800.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Coverted printks to dev_<levels>.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index e89db9a9a0a4..1ea97896b6bd 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -660,7 +660,7 @@ static int das1800_attach(struct comedi_device *dev,
 
 	board = das1800_probe(dev);
 	if (board < 0) {
-		printk(" unable to determine board type\n");
+		dev_err(dev->hw_dev, "unable to determine board type\n");
 		return -ENODEV;
 	}
 
@@ -684,7 +684,8 @@ static int das1800_attach(struct comedi_device *dev,
 	if (irq) {
 		if (request_irq(irq, das1800_interrupt, 0,
 				driver_das1800.driver_name, dev)) {
-			printk(" unable to allocate irq %u\n", irq);
+			dev_dbg(dev->hw_dev, "unable to allocate irq %u\n",
+				irq);
 			return -EINVAL;
 		}
 	}
@@ -713,7 +714,7 @@ static int das1800_attach(struct comedi_device *dev,
 		devpriv->irq_dma_bits |= 0x38;
 		break;
 	default:
-		printk(" irq out of range\n");
+		dev_err(dev->hw_dev, "irq out of range\n");
 		return -EINVAL;
 		break;
 	}

commit 904c02968b4c714e5fb6e750e746d8eceb641dd9
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:29 2011 +0530

    Staging: comedi: fix printk issue in das1800.c
    
    This is a patch to the das1800.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_<levels>.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index a6df30b7fd7c..e89db9a9a0a4 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -580,15 +580,16 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			break;
 		}
 		if (request_dma(dma0, driver_das1800.driver_name)) {
-			printk(" failed to allocate dma channel %i\n", dma0);
+			dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
+				dma0);
 			return -EINVAL;
 		}
 		devpriv->dma0 = dma0;
 		devpriv->dma_current = dma0;
 		if (dma1) {
 			if (request_dma(dma1, driver_das1800.driver_name)) {
-				printk(" failed to allocate dma channel %i\n",
-				       dma1);
+				dev_err(dev->hw_dev, "failed to allocate dma channel %i\n",
+					dma1);
 				return -EINVAL;
 			}
 			devpriv->dma1 = dma1;

commit a142785d7c9dd572a5dd963f7142174901465006
Author: Matthew Skolaut <tech2077@gmail.com>
Date:   Wed Jun 22 03:32:01 2011 -0500

    Staging: comedi: das1800: fixed multiple brace coding style issues and pointer declaration style errors
    
    Fixed coding style issues
    
    Signed-off-by: Matthew Skolaut <tech2077@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9fc28bfb6727..a6df30b7fd7c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -199,7 +199,7 @@ static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s);
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
-				      unsigned int channel, uint16_t * buffer);
+				      unsigned int channel, uint16_t *buffer);
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 					  struct comedi_subdevice *s);
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
@@ -1051,9 +1051,8 @@ static void munge_data(struct comedi_device *dev, uint16_t * array,
 
 	/* convert to unsigned type if we are in a bipolar mode */
 	if (!unipolar) {
-		for (i = 0; i < num_elements; i++) {
+		for (i = 0; i < num_elements; i++)
 			array[i] = munge_bipolar_sample(dev, array[i]);
-		}
 	}
 }
 
@@ -1061,7 +1060,7 @@ static void munge_data(struct comedi_device *dev, uint16_t * array,
  * Assumes dma lock is held */
 static void das1800_flush_dma_channel(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
-				      unsigned int channel, uint16_t * buffer)
+				      unsigned int channel, uint16_t *buffer)
 {
 	unsigned int num_bytes, num_samples;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1154,7 +1153,8 @@ static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
 			break;
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
 		/* convert to unsigned type if we are in a bipolar mode */
-		if (!unipolar) ;
+		if (!unipolar)
+			;
 		dpnt = munge_bipolar_sample(dev, dpnt);
 		cfc_write_to_buffer(s, dpnt);
 		if (cmd->stop_src == TRIG_COUNT)
@@ -1365,9 +1365,8 @@ static int control_a_bits(struct comedi_cmd cmd)
 	int control_a;
 
 	control_a = FFEN;	/* enable fifo */
-	if (cmd.stop_src == TRIG_EXT) {
+	if (cmd.stop_src == TRIG_EXT)
 		control_a |= ATEN;
-	}
 	switch (cmd.start_src) {
 	case TRIG_EXT:
 		control_a |= TGEN | CGSL;
@@ -1444,9 +1443,8 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 						       &(cmd.convert_arg),
 						       cmd.
 						       flags & TRIG_ROUND_MASK);
-			if (das1800_set_frequency(dev) < 0) {
+			if (das1800_set_frequency(dev) < 0)
 				return -1;
-			}
 		}
 		break;
 	case TRIG_TIMER:	/*  in burst mode */
@@ -1455,9 +1453,8 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 					       &(devpriv->divisor2),
 					       &(cmd.scan_begin_arg),
 					       cmd.flags & TRIG_ROUND_MASK);
-		if (das1800_set_frequency(dev) < 0) {
+		if (das1800_set_frequency(dev) < 0)
 			return -1;
-		}
 		break;
 	default:
 		break;
@@ -1554,11 +1551,10 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 
 	/* disable dma on TRIG_WAKE_EOS, or TRIG_RT
 	 * (because dma in handler is unsafe at hard real-time priority) */
-	if (cmd.flags & (TRIG_WAKE_EOS | TRIG_RT)) {
+	if (cmd.flags & (TRIG_WAKE_EOS | TRIG_RT))
 		devpriv->irq_dma_bits &= ~DMA_ENABLED;
-	} else {
+	else
 		devpriv->irq_dma_bits |= devpriv->dma_bits;
-	}
 	/*  interrupt on end of conversion for TRIG_WAKE_EOS */
 	if (cmd.flags & TRIG_WAKE_EOS) {
 		/*  interrupt fifo not empty */
@@ -1568,9 +1564,8 @@ static int das1800_ai_do_cmd(struct comedi_device *dev,
 		devpriv->irq_dma_bits |= FIMD;
 	}
 	/*  determine how many conversions we need */
-	if (cmd.stop_src == TRIG_COUNT) {
+	if (cmd.stop_src == TRIG_COUNT)
 		devpriv->count = cmd.stop_arg * cmd.chanlist_len;
-	}
 
 	das1800_cancel(dev, s);
 

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 60c2b12d6ffb..9fc28bfb6727 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -102,6 +102,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/io.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6ea93f9c0b48..60c2b12d6ffb 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1087,7 +1087,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	return;
 }
 
-/* flushes remaining data from board when external trigger has stopped aquisition
+/* flushes remaining data from board when external trigger has stopped acquisition
  * and we are using dma transfers */
 static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index a68a1e47db82..6ea93f9c0b48 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -531,7 +531,18 @@ static struct comedi_driver driver_das1800 = {
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_INITCLEANUP(driver_das1800);
+static int __init driver_das1800_init_module(void)
+{
+	return comedi_driver_register(&driver_das1800);
+}
+
+static void __exit driver_das1800_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_das1800);
+}
+
+module_init(driver_das1800_init_module);
+module_exit(driver_das1800_cleanup_module);
 
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			    unsigned int dma1)

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index de5e82fec878..a68a1e47db82 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1800,3 +1800,7 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 
 	return size;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit d18c5906d0914d911a13d342ff61a6bca6aff597
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:06:33 2010 -0700

    Staging: comedi: das1800.c: fix a locking error on the error path.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index d91c2d9d595b..de5e82fec878 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1637,7 +1637,8 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 		}
 		if (i == timeout) {
 			comedi_error(dev, "timeout");
-			return -ETIME;
+			n = -ETIME;
+			goto exit;
 		}
 		dpnt = inw(dev->iobase + DAS1800_FIFO);
 		/* shift data to offset binary for bipolar ranges */
@@ -1645,6 +1646,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev,
 			dpnt += 1 << (thisboard->resolution - 1);
 		data[n] = dpnt;
 	}
+exit:
 	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return n;

commit 1bf2ee4ea19d3ebeb8fe35c03dd44cb1d851e19f
Author: David Binderman <dcb314@hotmail.com>
Date:   Fri Mar 19 09:28:07 2010 +0000

    Staging: comedi: das1800: fix kfree coding style issue
    
    Signed-off-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 3c3e0455c7c4..d91c2d9d595b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -797,10 +797,8 @@ static int das1800_detach(struct comedi_device *dev)
 			free_dma(devpriv->dma0);
 		if (devpriv->dma1)
 			free_dma(devpriv->dma1);
-		if (devpriv->ai_buf0)
-			kfree(devpriv->ai_buf0);
-		if (devpriv->ai_buf1)
-			kfree(devpriv->ai_buf1);
+		kfree(devpriv->ai_buf0);
+		kfree(devpriv->ai_buf1);
 	}
 
 	printk("comedi%d: %s: remove\n", dev->minor,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6ea59cc6b2bb..3c3e0455c7c4 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -101,6 +101,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index a3434088c9e6..6ea59cc6b2bb 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -181,33 +181,44 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das1800_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it);
 static int das1800_detach(struct comedi_device *dev);
 static int das1800_probe(struct comedi_device *dev);
-static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das1800_cancel(struct comedi_device *dev,
+			  struct comedi_subdevice *s);
 static irqreturn_t das1800_interrupt(int irq, void *d);
-static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das1800_ai_poll(struct comedi_device *dev,
+			   struct comedi_subdevice *s);
 static void das1800_ai_handler(struct comedi_device *dev);
-static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int status);
-static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s);
-static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int channel, uint16_t *buffer);
+static void das1800_handle_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s, unsigned int status);
+static void das1800_flush_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s);
+static void das1800_flush_dma_channel(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int channel, uint16_t * buffer);
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-	struct comedi_subdevice *s);
+					  struct comedi_subdevice *s);
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-	struct comedi_subdevice *s);
-static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+					  struct comedi_subdevice *s);
+static int das1800_ai_do_cmdtest(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd);
+static int das1800_ai_do_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s);
+static int das1800_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int das1800_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 
 static int das1800_set_frequency(struct comedi_device *dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
@@ -217,29 +228,29 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd);
 static const struct comedi_lrange range_ai_das1801 = {
 	8,
 	{
-			RANGE(-5, 5),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02),
-			RANGE(0, 5),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-			RANGE(0, 0.02),
-		}
+	 RANGE(-5, 5),
+	 RANGE(-1, 1),
+	 RANGE(-0.1, 0.1),
+	 RANGE(-0.02, 0.02),
+	 RANGE(0, 5),
+	 RANGE(0, 1),
+	 RANGE(0, 0.1),
+	 RANGE(0, 0.02),
+	 }
 };
 
 static const struct comedi_lrange range_ai_das1802 = {
 	8,
 	{
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-		}
+	 RANGE(-10, 10),
+	 RANGE(-5, 5),
+	 RANGE(-2.5, 2.5),
+	 RANGE(-1.25, 1.25),
+	 RANGE(0, 10),
+	 RANGE(0, 5),
+	 RANGE(0, 2.5),
+	 RANGE(0, 1.25),
+	 }
 };
 
 struct das1800_board {
@@ -260,203 +271,203 @@ struct das1800_board {
  */
 static const struct das1800_board das1800_boards[] = {
 	{
-	.name = "das-1701st",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1701st",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1701st-da",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1701st-da",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1702st",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1702st",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1702st-da",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1702st-da",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1702hr",
-	.ai_speed = 20000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1702hr",
+	 .ai_speed = 20000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1702hr-da",
-	.ai_speed = 20000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1702hr-da",
+	 .ai_speed = 20000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1701ao",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1701ao",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1702ao",
-	.ai_speed = 6250,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1702ao",
+	 .ai_speed = 6250,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1801st",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1801st",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1801st-da",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1801st-da",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1802st",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802st",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1802st-da",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 4,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802st-da",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 4,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1802hr",
-	.ai_speed = 10000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 0,
-	.ao_n_chan = 0,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802hr",
+	 .ai_speed = 10000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 0,
+	 .ao_n_chan = 0,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1802hr-da",
-	.ai_speed = 10000,
-	.resolution = 16,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802hr-da",
+	 .ai_speed = 10000,
+	 .resolution = 16,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1801hc",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 64,
-	.common = 0,
-	.do_n_chan = 8,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1801hc",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 64,
+	 .common = 0,
+	 .do_n_chan = 8,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1802hc",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 64,
-	.common = 0,
-	.do_n_chan = 8,
-	.ao_ability = 1,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802hc",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 64,
+	 .common = 0,
+	 .do_n_chan = 8,
+	 .ao_ability = 1,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 	{
-	.name = "das-1801ao",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1801,
-		},
+	 .name = "das-1801ao",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1801,
+	 },
 	{
-	.name = "das-1802ao",
-	.ai_speed = 3000,
-	.resolution = 12,
-	.qram_len = 256,
-	.common = 1,
-	.do_n_chan = 4,
-	.ao_ability = 2,
-	.ao_n_chan = 2,
-	.range_ai = &range_ai_das1802,
-		},
+	 .name = "das-1802ao",
+	 .ai_speed = 3000,
+	 .resolution = 12,
+	 .qram_len = 256,
+	 .common = 1,
+	 .do_n_chan = 4,
+	 .ao_ability = 2,
+	 .ao_n_chan = 2,
+	 .range_ai = &range_ai_das1802,
+	 },
 };
 
 /*
@@ -490,8 +501,8 @@ struct das1800_private {
 static const struct comedi_lrange range_ao_1 = {
 	1,
 	{
-			RANGE(-10, 10),
-		}
+	 RANGE(-10, 10),
+	 }
 };
 
 /* analog out range for 'ao' boards */
@@ -522,7 +533,7 @@ static struct comedi_driver driver_das1800 = {
 COMEDI_INITCLEANUP(driver_das1800);
 
 static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
-	unsigned int dma1)
+			    unsigned int dma1)
 {
 	unsigned long flags;
 
@@ -550,8 +561,8 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 			break;
 		default:
 			printk(" only supports dma channels 5 through 7\n"
-				" Dual dma only allows the following combinations:\n"
-				" dma 5,6 / 6,7 / or 7,5\n");
+			       " Dual dma only allows the following combinations:\n"
+			       " dma 5,6 / 6,7 / or 7,5\n");
 			return -EINVAL;
 			break;
 		}
@@ -564,7 +575,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 		if (dma1) {
 			if (request_dma(dma1, driver_das1800.driver_name)) {
 				printk(" failed to allocate dma channel %i\n",
-					dma1);
+				       dma1);
 				return -EINVAL;
 			}
 			devpriv->dma1 = dma1;
@@ -575,7 +586,7 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 		devpriv->dma_current_buf = devpriv->ai_buf0;
 		if (dma1) {
 			devpriv->ai_buf1 =
-				kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+			    kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
 			if (devpriv->ai_buf1 == NULL)
 				return -ENOMEM;
 		}
@@ -591,7 +602,8 @@ static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 	return 0;
 }
 
-static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int das1800_attach(struct comedi_device *dev,
+			  struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -607,7 +619,7 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 		return -ENOMEM;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_das1800.driver_name,
-		iobase);
+	       iobase);
 	if (irq) {
 		printk(", irq %u", irq);
 		if (dma0) {
@@ -625,7 +637,9 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	/* check if io addresses are available */
 	if (!request_region(iobase, DAS1800_SIZE, driver_das1800.driver_name)) {
-		printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase, iobase + DAS1800_SIZE - 1);
+		printk
+		    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+		     iobase, iobase + DAS1800_SIZE - 1);
 		return -EIO;
 	}
 	dev->iobase = iobase;
@@ -643,8 +657,10 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	if (thisboard->ao_ability == 2) {
 		iobase2 = iobase + IOBASE2;
 		if (!request_region(iobase2, DAS1800_SIZE,
-				driver_das1800.driver_name)) {
-			printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase2, iobase2 + DAS1800_SIZE - 1);
+				    driver_das1800.driver_name)) {
+			printk
+			    (" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",
+			     iobase2, iobase2 + DAS1800_SIZE - 1);
 			return -EIO;
 		}
 		devpriv->iobase2 = iobase2;
@@ -694,7 +710,7 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	if (devpriv->ai_buf0 == NULL) {
 		devpriv->ai_buf0 =
-			kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+		    kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
 		if (devpriv->ai_buf0 == NULL)
 			return -ENOMEM;
 	}
@@ -759,7 +775,7 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 	if (thisboard->ao_ability == 1) {
 		/*  select 'update' dac channel for baseAddress + 0x0 */
 		outb(DAC(thisboard->ao_n_chan - 1),
-			dev->iobase + DAS1800_SELECT);
+		     dev->iobase + DAS1800_SELECT);
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
 	}
 
@@ -787,7 +803,7 @@ static int das1800_detach(struct comedi_device *dev)
 	}
 
 	printk("comedi%d: %s: remove\n", dev->minor,
-		driver_das1800.driver_name);
+	       driver_das1800.driver_name);
 
 	return 0;
 };
@@ -800,42 +816,45 @@ static int das1800_probe(struct comedi_device *dev)
 	int board;
 
 	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
-	board = ((struct das1800_board *) dev->board_ptr) - das1800_boards;
+	board = ((struct das1800_board *)dev->board_ptr) - das1800_boards;
 
 	switch (id) {
 	case 0x3:
 		if (board == das1801st_da || board == das1802st_da ||
-			board == das1701st_da || board == das1702st_da) {
+		    board == das1701st_da || board == das1702st_da) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800st-da series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800st-da series\n");
 		return das1801st;
 		break;
 	case 0x4:
 		if (board == das1802hr_da || board == das1702hr_da) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1802hr-da\n");
+		printk
+		    (" Board model (probed, not recommended): das-1802hr-da\n");
 		return das1802hr;
 		break;
 	case 0x5:
 		if (board == das1801ao || board == das1802ao ||
-			board == das1701ao || board == das1702ao) {
+		    board == das1701ao || board == das1702ao) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800ao series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800ao series\n");
 		return das1801ao;
 		break;
 	case 0x6:
 		if (board == das1802hr || board == das1702hr) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
 		printk(" Board model (probed, not recommended): das-1802hr\n");
@@ -843,32 +862,37 @@ static int das1800_probe(struct comedi_device *dev)
 		break;
 	case 0x7:
 		if (board == das1801st || board == das1802st ||
-			board == das1701st || board == das1702st) {
+		    board == das1701st || board == das1702st) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800st series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800st series\n");
 		return das1801st;
 		break;
 	case 0x8:
 		if (board == das1801hc || board == das1802hc) {
 			printk(" Board model: %s\n",
-				das1800_boards[board].name);
+			       das1800_boards[board].name);
 			return board;
 		}
-		printk(" Board model (probed, not recommended): das-1800hc series\n");
+		printk
+		    (" Board model (probed, not recommended): das-1800hc series\n");
 		return das1801hc;
 		break;
 	default:
-		printk(" Board model: probe returned 0x%x (unknown, please report)\n", id);
+		printk
+		    (" Board model: probe returned 0x%x (unknown, please report)\n",
+		     id);
 		return board;
 		break;
 	}
 	return -1;
 }
 
-static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das1800_ai_poll(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -963,18 +987,18 @@ static void das1800_ai_handler(struct comedi_device *dev)
 	return;
 }
 
-static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int status)
+static void das1800_handle_dma(struct comedi_device *dev,
+			       struct comedi_subdevice *s, unsigned int status)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-		devpriv->dma_current_buf);
+				  devpriv->dma_current_buf);
 	/*  re-enable  dma channel */
 	set_dma_addr(devpriv->dma_current,
-		virt_to_bus(devpriv->dma_current_buf));
+		     virt_to_bus(devpriv->dma_current_buf));
 	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
 	enable_dma(devpriv->dma_current);
 	release_dma_lock(flags);
@@ -999,14 +1023,14 @@ static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevic
 }
 
 static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
-	uint16_t sample)
+					    uint16_t sample)
 {
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
 }
 
-static void munge_data(struct comedi_device *dev, uint16_t *array,
-	unsigned int num_elements)
+static void munge_data(struct comedi_device *dev, uint16_t * array,
+		       unsigned int num_elements)
 {
 	unsigned int i;
 	int unipolar;
@@ -1024,8 +1048,9 @@ static void munge_data(struct comedi_device *dev, uint16_t *array,
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
  * Assumes dma lock is held */
-static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int channel, uint16_t *buffer)
+static void das1800_flush_dma_channel(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      unsigned int channel, uint16_t * buffer)
 {
 	unsigned int num_bytes, num_samples;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1054,14 +1079,15 @@ static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_s
 
 /* flushes remaining data from board when external trigger has stopped aquisition
  * and we are using dma transfers */
-static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s)
+static void das1800_flush_dma(struct comedi_device *dev,
+			      struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
 
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-		devpriv->dma_current_buf);
+				  devpriv->dma_current_buf);
 
 	if (dual_dma) {
 		/*  switch to other channel and flush it */
@@ -1073,7 +1099,7 @@ static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice
 			devpriv->dma_current_buf = devpriv->ai_buf0;
 		}
 		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
-			devpriv->dma_current_buf);
+					  devpriv->dma_current_buf);
 	}
 
 	release_dma_lock(flags);
@@ -1085,7 +1111,7 @@ static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice
 }
 
 static void das1800_handle_fifo_half_full(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+					  struct comedi_subdevice *s)
 {
 	int numPoints = 0;	/* number of points to read */
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1097,14 +1123,14 @@ static void das1800_handle_fifo_half_full(struct comedi_device *dev,
 	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
 	munge_data(dev, devpriv->ai_buf0, numPoints);
 	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
-		numPoints * sizeof(devpriv->ai_buf0[0]));
+				  numPoints * sizeof(devpriv->ai_buf0[0]));
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count -= numPoints;
 	return;
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
-	struct comedi_subdevice *s)
+					  struct comedi_subdevice *s)
 {
 	short dpnt;
 	int unipolar;
@@ -1140,8 +1166,9 @@ static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 /* test analog input cmd */
-static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int das1800_ai_do_cmdtest(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1185,17 +1212,17 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdev
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT &&
-		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+	    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
 	/* compatibility check */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->convert_src != TRIG_TIMER)
+	    cmd->convert_src != TRIG_TIMER)
 		err++;
 
 	if (err)
@@ -1250,9 +1277,11 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdev
 			tmp_arg = cmd->convert_arg;
 			/* calculate counter values that give desired timing */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-				&(devpriv->divisor1), &(devpriv->divisor2),
-				&(cmd->convert_arg),
-				cmd->flags & TRIG_ROUND_MASK);
+						       &(devpriv->divisor1),
+						       &(devpriv->divisor2),
+						       &(cmd->convert_arg),
+						       cmd->
+						       flags & TRIG_ROUND_MASK);
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 		}
@@ -1261,27 +1290,32 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdev
 			/*  check that convert_arg is compatible */
 			tmp_arg = cmd->convert_arg;
 			cmd->convert_arg =
-				burst_convert_arg(cmd->convert_arg,
-				cmd->flags & TRIG_ROUND_MASK);
+			    burst_convert_arg(cmd->convert_arg,
+					      cmd->flags & TRIG_ROUND_MASK);
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
 				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
-					cmd->scan_begin_arg) {
+				    cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
-						cmd->convert_arg *
-						cmd->chanlist_len;
+					    cmd->convert_arg *
+					    cmd->chanlist_len;
 					err++;
 				}
 				tmp_arg = cmd->scan_begin_arg;
 				/* calculate counter values that give desired timing */
 				i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					&(devpriv->divisor1),
-					&(devpriv->divisor2),
-					&(cmd->scan_begin_arg),
-					cmd->flags & TRIG_ROUND_MASK);
+							       &(devpriv->
+								 divisor1),
+							       &(devpriv->
+								 divisor2),
+							       &(cmd->
+								 scan_begin_arg),
+							       cmd->
+							       flags &
+							       TRIG_ROUND_MASK);
 				if (tmp_arg != cmd->scan_begin_arg)
 					err++;
 			}
@@ -1297,7 +1331,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdev
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (unipolar != (CR_RANGE(cmd->chanlist[i]) & UNIPOLAR)) {
 				comedi_error(dev,
-					"unipolar and bipolar ranges cannot be mixed in the chanlist");
+					     "unipolar and bipolar ranges cannot be mixed in the chanlist");
 				err++;
 				break;
 			}
@@ -1394,9 +1428,11 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 		if (cmd.convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-				&(devpriv->divisor1), &(devpriv->divisor2),
-				&(cmd.convert_arg),
-				cmd.flags & TRIG_ROUND_MASK);
+						       &(devpriv->divisor1),
+						       &(devpriv->divisor2),
+						       &(cmd.convert_arg),
+						       cmd.
+						       flags & TRIG_ROUND_MASK);
 			if (das1800_set_frequency(dev) < 0) {
 				return -1;
 			}
@@ -1405,8 +1441,9 @@ static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-			&(devpriv->divisor2), &(cmd.scan_begin_arg),
-			cmd.flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor2),
+					       &(cmd.scan_begin_arg),
+					       cmd.flags & TRIG_ROUND_MASK);
 		if (das1800_set_frequency(dev) < 0) {
 			return -1;
 		}
@@ -1478,9 +1515,9 @@ static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 	/* make channel / gain list */
 	for (i = 0; i < n; i++) {
 		chan_range =
-			CR_CHAN(cmd.chanlist[i]) | ((CR_RANGE(cmd.
-					chanlist[i]) & range_mask) <<
-			range_bitshift);
+		    CR_CHAN(cmd.
+			    chanlist[i]) | ((CR_RANGE(cmd.chanlist[i]) &
+					     range_mask) << range_bitshift);
 		outw(chan_range, dev->iobase + DAS1800_QRAM);
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
@@ -1490,7 +1527,8 @@ static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 }
 
 /* analog input do_cmd */
-static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int das1800_ai_do_cmd(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	int ret;
 	int control_a, control_c;
@@ -1499,7 +1537,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice
 
 	if (!dev->irq) {
 		comedi_error(dev,
-			"no irq assigned for das-1800, cannot do hardware conversions");
+			     "no irq assigned for das-1800, cannot do hardware conversions");
 		return -1;
 	}
 
@@ -1542,7 +1580,7 @@ static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice
 	if (control_c & BMDE) {
 		/*  program conversion period with number of microseconds minus 1 */
 		outb(cmd.convert_arg / 1000 - 1,
-			dev->iobase + DAS1800_BURST_RATE);
+		     dev->iobase + DAS1800_BURST_RATE);
 		outb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
 	}
 	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
@@ -1553,8 +1591,9 @@ static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice
 }
 
 /* read analog input */
-static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_ai_rinsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range, aref, chan_range;
@@ -1613,8 +1652,9 @@ static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 /* writes to an analog output channel */
-static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_ao_winsn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
@@ -1642,8 +1682,9 @@ static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 /* reads from digital input channels */
-static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_di_rbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
@@ -1653,8 +1694,9 @@ static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *
 }
 
 /* writes to digital output channels */
-static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int das1800_do_wbits(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1679,11 +1721,11 @@ static int das1800_set_frequency(struct comedi_device *dev)
 
 	/*  counter 1, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
-			2))
+		       2))
 		err++;
 	/*  counter 2, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
-			2))
+		       2))
 		err++;
 	if (err)
 		return -1;
@@ -1736,7 +1778,7 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 		break;
 	case TRIG_TIMER:
 		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
-			sample_size;
+		    sample_size;
 		break;
 	default:
 		size = DMA_BUF_SIZE;
@@ -1747,7 +1789,7 @@ static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 	max_size = DMA_BUF_SIZE;
 	/*  if we are taking limited number of conversions, limit transfer size to that */
 	if (cmd->stop_src == TRIG_COUNT &&
-		cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
+	    cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
 		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
 
 	if (size > max_size)

commit 25436dc9d84f1be60ff549c9ab712bba2835f284
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 15:14:34 2009 -0700

    Staging: comedi: remove RT code
    
    This removes the unused RT code from the comedi subsystem.
    
    A lot of drivers needed to then include interrupt.h on their own, as they
    were picking it up through the comedi_rt.h inclusion.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5d67d2359add..a3434088c9e6 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -100,6 +100,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 	read insn for analog out
 */
 
+#include <linux/interrupt.h>
 #include "../comedidev.h"
 
 #include <linux/ioport.h>

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 7fbcfb107e6d..5d67d2359add 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -651,7 +651,7 @@ static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it
 
 	/* grab our IRQ */
 	if (irq) {
-		if (comedi_request_irq(irq, das1800_interrupt, 0,
+		if (request_irq(irq, das1800_interrupt, 0,
 				driver_das1800.driver_name, dev)) {
 			printk(" unable to allocate irq %u\n", irq);
 			return -EINVAL;
@@ -771,7 +771,7 @@ static int das1800_detach(struct comedi_device *dev)
 	if (dev->iobase)
 		release_region(dev->iobase, DAS1800_SIZE);
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->private) {
 		if (devpriv->iobase2)
 			release_region(devpriv->iobase2, DAS1800_SIZE);
@@ -872,9 +872,9 @@ static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s
 	unsigned long flags;
 
 	/*  prevent race with interrupt handler */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	das1800_ai_handler(dev);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
@@ -1471,7 +1471,7 @@ static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 
 	n = cmd.chanlist_len;
 	/*  spinlock protects indirect addressing */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
 	/* make channel / gain list */
@@ -1483,7 +1483,7 @@ static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 		outw(chan_range, dev->iobase + DAS1800_QRAM);
 	}
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return;
 }
@@ -1582,7 +1582,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *
 	/* mask of unipolar/bipolar bit from range */
 	range = CR_RANGE(insn->chanspec) & 0x3;
 	chan_range = chan | (range << 8);
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/* set QRAM address start */
 	outw(chan_range, dev->iobase + DAS1800_QRAM);
@@ -1606,7 +1606,7 @@ static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *
 			dpnt += 1 << (thisboard->resolution - 1);
 		data[n] = dpnt;
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return n;
 }
@@ -1627,7 +1627,7 @@ static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *
 	if (chan == update_chan)
 		devpriv->ao_update_bits = output;
 	/*  write to channel */
-	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(DAC(chan), dev->iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
 	outw(output, dev->iobase + DAS1800_DAC);
 	/*  now we need to write to 'update' channel to update all dac channels */
@@ -1635,7 +1635,7 @@ static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *
 		outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+	spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 
 	return 1;
 }

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9c6c9b89558a..7fbcfb107e6d 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -509,7 +509,7 @@ static struct comedi_driver driver_das1800 = {
 	.module = THIS_MODULE,
 	.attach = das1800_attach,
 	.detach = das1800_detach,
-	.num_names = sizeof(das1800_boards) / sizeof(struct das1800_board),
+	.num_names = ARRAY_SIZE(das1800_boards),
 	.board_name = &das1800_boards[0].name,
 	.offset = sizeof(struct das1800_board),
 };

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index b420e7649bc9..9c6c9b89558a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -180,37 +180,37 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int das1800_detach(struct comedi_device * dev);
-static int das1800_probe(struct comedi_device * dev);
-static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int das1800_detach(struct comedi_device *dev);
+static int das1800_probe(struct comedi_device *dev);
+static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static irqreturn_t das1800_interrupt(int irq, void *d);
-static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s);
-static void das1800_ai_handler(struct comedi_device * dev);
-static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevice * s,
+static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s);
+static void das1800_ai_handler(struct comedi_device *dev);
+static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int status);
-static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevice * s);
-static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_subdevice * s,
-	unsigned int channel, uint16_t * buffer);
-static void das1800_handle_fifo_half_full(struct comedi_device * dev,
-	struct comedi_subdevice * s);
-static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
-	struct comedi_subdevice * s);
-static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-
-static int das1800_set_frequency(struct comedi_device * dev);
+static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s);
+static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
+	unsigned int channel, uint16_t *buffer);
+static void das1800_handle_fifo_half_full(struct comedi_device *dev,
+	struct comedi_subdevice *s);
+static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
+	struct comedi_subdevice *s);
+static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+
+static int das1800_set_frequency(struct comedi_device *dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
-static unsigned int suggest_transfer_size(struct comedi_cmd * cmd);
+static unsigned int suggest_transfer_size(struct comedi_cmd *cmd);
 
 /* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2112783d37e2..b420e7649bc9 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -259,202 +259,202 @@ struct das1800_board {
  */
 static const struct das1800_board das1800_boards[] = {
 	{
-	      name:	"das-1701st",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1701st",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1701st-da",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:1,
-	      ao_n_chan:4,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1701st-da",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 1,
+	.ao_n_chan = 4,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1702st",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1702st",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1702st-da",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:1,
-	      ao_n_chan:4,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1702st-da",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 1,
+	.ao_n_chan = 4,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1702hr",
-	      ai_speed:20000,
-	      resolution:16,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1702hr",
+	.ai_speed = 20000,
+	.resolution = 16,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1702hr-da",
-	      ai_speed:20000,
-	      resolution:16,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:1,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1702hr-da",
+	.ai_speed = 20000,
+	.resolution = 16,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 1,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1701ao",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:2,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1701ao",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 2,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1702ao",
-	      ai_speed:6250,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:2,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1702ao",
+	.ai_speed = 6250,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 2,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1801st",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1801st",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1801st-da",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:4,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1801st-da",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 4,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1802st",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802st",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1802st-da",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:1,
-	      ao_n_chan:4,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802st-da",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 1,
+	.ao_n_chan = 4,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1802hr",
-	      ai_speed:10000,
-	      resolution:16,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:0,
-	      ao_n_chan:0,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802hr",
+	.ai_speed = 10000,
+	.resolution = 16,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 0,
+	.ao_n_chan = 0,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1802hr-da",
-	      ai_speed:10000,
-	      resolution:16,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:1,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802hr-da",
+	.ai_speed = 10000,
+	.resolution = 16,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 1,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1801hc",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:64,
-	      common:	0,
-	      do_n_chan:8,
-	      ao_ability:1,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1801hc",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 64,
+	.common = 0,
+	.do_n_chan = 8,
+	.ao_ability = 1,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1802hc",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:64,
-	      common:	0,
-	      do_n_chan:8,
-	      ao_ability:1,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802hc",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 64,
+	.common = 0,
+	.do_n_chan = 8,
+	.ao_ability = 1,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1802,
 		},
 	{
-	      name:	"das-1801ao",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:2,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1801,
+	.name = "das-1801ao",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 2,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1801,
 		},
 	{
-	      name:	"das-1802ao",
-	      ai_speed:3000,
-	      resolution:12,
-	      qram_len:256,
-	      common:	1,
-	      do_n_chan:4,
-	      ao_ability:2,
-	      ao_n_chan:2,
-	      range_ai:&range_ai_das1802,
+	.name = "das-1802ao",
+	.ai_speed = 3000,
+	.resolution = 12,
+	.qram_len = 256,
+	.common = 1,
+	.do_n_chan = 4,
+	.ao_ability = 2,
+	.ao_n_chan = 2,
+	.range_ai = &range_ai_das1802,
 		},
 };
 
@@ -505,13 +505,13 @@ static const struct comedi_lrange range_ao_2 = {
 */
 
 static struct comedi_driver driver_das1800 = {
-      driver_name:"das1800",
-      module:THIS_MODULE,
-      attach:das1800_attach,
-      detach:das1800_detach,
-      num_names:sizeof(das1800_boards) / sizeof(struct das1800_board),
-      board_name:&das1800_boards[0].name,
-      offset:sizeof(struct das1800_board),
+	.driver_name = "das1800",
+	.module = THIS_MODULE,
+	.attach = das1800_attach,
+	.detach = das1800_detach,
+	.num_names = sizeof(das1800_boards) / sizeof(struct das1800_board),
+	.board_name = &das1800_boards[0].name,
+	.offset = sizeof(struct das1800_board),
 };
 
 /*

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 7e1b8f8fec57..2112783d37e2 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -520,7 +520,7 @@ static struct comedi_driver driver_das1800 = {
  */
 COMEDI_INITCLEANUP(driver_das1800);
 
-static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
+static int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,
 	unsigned int dma1)
 {
 	unsigned long flags;
@@ -590,7 +590,7 @@ static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 	return 0;
 }
 
-static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int das1800_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -765,7 +765,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	return 0;
 };
 
-static int das1800_detach(struct comedi_device * dev)
+static int das1800_detach(struct comedi_device *dev)
 {
 	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase)
@@ -793,7 +793,7 @@ static int das1800_detach(struct comedi_device * dev)
 
 /* probes and checks das-1800 series board type
  */
-static int das1800_probe(struct comedi_device * dev)
+static int das1800_probe(struct comedi_device *dev)
 {
 	int id;
 	int board;
@@ -867,7 +867,7 @@ static int das1800_probe(struct comedi_device * dev)
 	return -1;
 }
 
-static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das1800_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -909,7 +909,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d)
 }
 
 /* the guts of the interrupt handler, that is shared with das1800_ai_poll */
-static void das1800_ai_handler(struct comedi_device * dev)
+static void das1800_ai_handler(struct comedi_device *dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
 	struct comedi_async *async = s->async;
@@ -962,7 +962,7 @@ static void das1800_ai_handler(struct comedi_device * dev)
 	return;
 }
 
-static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevice * s,
+static void das1800_handle_dma(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int status)
 {
 	unsigned long flags;
@@ -997,14 +997,14 @@ static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevi
 	return;
 }
 
-static inline uint16_t munge_bipolar_sample(const struct comedi_device * dev,
+static inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,
 	uint16_t sample)
 {
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
 }
 
-static void munge_data(struct comedi_device * dev, uint16_t * array,
+static void munge_data(struct comedi_device *dev, uint16_t *array,
 	unsigned int num_elements)
 {
 	unsigned int i;
@@ -1023,8 +1023,8 @@ static void munge_data(struct comedi_device * dev, uint16_t * array,
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
  * Assumes dma lock is held */
-static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_subdevice * s,
-	unsigned int channel, uint16_t * buffer)
+static void das1800_flush_dma_channel(struct comedi_device *dev, struct comedi_subdevice *s,
+	unsigned int channel, uint16_t *buffer)
 {
 	unsigned int num_bytes, num_samples;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1053,7 +1053,7 @@ static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_
 
 /* flushes remaining data from board when external trigger has stopped aquisition
  * and we are using dma transfers */
-static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevice * s)
+static void das1800_flush_dma(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1083,8 +1083,8 @@ static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevic
 	return;
 }
 
-static void das1800_handle_fifo_half_full(struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static void das1800_handle_fifo_half_full(struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	int numPoints = 0;	/* number of points to read */
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1102,8 +1102,8 @@ static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 	return;
 }
 
-static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
-	struct comedi_subdevice * s)
+static void das1800_handle_fifo_not_empty(struct comedi_device *dev,
+	struct comedi_subdevice *s)
 {
 	short dpnt;
 	int unipolar;
@@ -1126,7 +1126,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 	return;
 }
 
-static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
@@ -1139,8 +1139,8 @@ static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 /* test analog input cmd */
-static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int das1800_ai_do_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1385,7 +1385,7 @@ static int control_c_bits(struct comedi_cmd cmd)
 }
 
 /* sets up counters */
-static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
+static int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)
 {
 	/*  setup cascaded counters for conversion/scan frequency */
 	switch (cmd.scan_begin_src) {
@@ -1424,7 +1424,7 @@ static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 }
 
 /* sets up dma */
-static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
+static void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)
 {
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1462,7 +1462,7 @@ static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 }
 
 /* programs channel/gain list into card */
-static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
+static void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
@@ -1489,7 +1489,7 @@ static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 }
 
 /* analog input do_cmd */
-static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int das1800_ai_do_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int ret;
 	int control_a, control_c;
@@ -1552,8 +1552,8 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* read analog input */
-static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das1800_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i, n;
 	int chan, range, aref, chan_range;
@@ -1612,8 +1612,8 @@ static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* writes to an analog output channel */
-static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das1800_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 /* int range = CR_RANGE(insn->chanspec); */
@@ -1641,8 +1641,8 @@ static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* reads from digital input channels */
-static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das1800_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
@@ -1652,8 +1652,8 @@ static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* writes to digital output channels */
-static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int das1800_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int wbits;
 
@@ -1672,7 +1672,7 @@ static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* loads counters with divisor1, divisor2 from private structure */
-static int das1800_set_frequency(struct comedi_device * dev)
+static int das1800_set_frequency(struct comedi_device *dev)
 {
 	int err = 0;
 
@@ -1720,7 +1720,7 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 }
 
 /* utility function that suggests a dma transfer size based on the conversion period 'ns' */
-static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
+static unsigned int suggest_transfer_size(struct comedi_cmd *cmd)
 {
 	unsigned int size = DMA_BUF_SIZE;
 	static const int sample_size = 2;	/*  size in bytes of one sample from board */

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 60724600607c..7e1b8f8fec57 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -184,7 +184,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 static int das1800_detach(struct comedi_device * dev);
 static int das1800_probe(struct comedi_device * dev);
 static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t das1800_interrupt(int irq, void *d);
 static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s);
 static void das1800_ai_handler(struct comedi_device * dev);
 static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevice * s,
@@ -879,7 +879,7 @@ static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 	return s->async->buf_write_count - s->async->buf_read_count;
 }
 
-static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t das1800_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	unsigned int status;

commit a351ecf3081f94796cf915dba820f9f5e62c43cf
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:40 2009 -0400

    Staging: comedi: remove C99 comments in das1800.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index cd4cd4e6a79b..60724600607c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -108,12 +108,12 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #include "8253.h"
 #include "comedi_fc.h"
 
-// misc. defines
-#define DAS1800_SIZE           16	//uses 16 io addresses
-#define FIFO_SIZE              1024	// 1024 sample fifo
-#define TIMER_BASE             200	// 5 Mhz master clock
-#define UNIPOLAR               0x4	// bit that determines whether input range is uni/bipolar
-#define DMA_BUF_SIZE           0x1ff00	// size in bytes of dma buffers
+/* misc. defines */
+#define DAS1800_SIZE           16	/* uses 16 io addresses */
+#define FIFO_SIZE              1024	/*  1024 sample fifo */
+#define TIMER_BASE             200	/*  5 Mhz master clock */
+#define UNIPOLAR               0x4	/*  bit that determines whether input range is uni/bipolar */
+#define DMA_BUF_SIZE           0x1ff00	/*  size in bytes of dma buffers */
 
 /* Registers for the das1800 */
 #define DAS1800_FIFO            0x0
@@ -138,7 +138,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   DMA_CH5_CH6             0x5
 #define   DMA_CH6_CH7             0x6
 #define   DMA_CH7_CH5             0x7
-#define   DMA_ENABLED             0x3	//mask used to determine if dma is enabled
+#define   DMA_ENABLED             0x3	/* mask used to determine if dma is enabled */
 #define   DMA_DUAL                0x4
 #define   IRQ3                    0x8
 #define   IRQ5                    0x10
@@ -156,7 +156,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   SD                      0x40
 #define   UB                      0x80
 #define DAS1800_STATUS          0x7
-// bits that prevent interrupt status bits (and CVEN) from being cleared on write
+/* bits that prevent interrupt status bits (and CVEN) from being cleared on write */
 #define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)
 #define   INT                     0x1
 #define   DMATC                   0x2
@@ -164,14 +164,14 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   OVF                     0x10
 #define   FHF                     0x20
 #define   FNE                     0x40
-#define   CVEN_MASK               0x40	// masks CVEN on write
+#define   CVEN_MASK               0x40	/*  masks CVEN on write */
 #define   CVEN                    0x80
 #define DAS1800_BURST_LENGTH    0x8
 #define DAS1800_BURST_RATE      0x9
 #define DAS1800_QRAM_ADDRESS    0xa
 #define DAS1800_COUNTER         0xc
 
-#define IOBASE2                   0x400	//offset of additional ioports used on 'ao' cards
+#define IOBASE2                   0x400	/* offset of additional ioports used on 'ao' cards */
 
 enum {
 	das1701st, das1701st_da, das1702st, das1702st_da, das1702hr,
@@ -212,7 +212,7 @@ static int das1800_set_frequency(struct comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
 static unsigned int suggest_transfer_size(struct comedi_cmd * cmd);
 
-// analog input ranges
+/* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {
 	8,
 	{
@@ -485,7 +485,7 @@ struct das1800_private {
 
 #define devpriv ((struct das1800_private *)dev->private)
 
-// analog out range for boards with basic analog out
+/* analog out range for boards with basic analog out */
 static const struct comedi_lrange range_ao_1 = {
 	1,
 	{
@@ -493,7 +493,7 @@ static const struct comedi_lrange range_ao_1 = {
 		}
 };
 
-// analog out range for 'ao' boards
+/* analog out range for 'ao' boards */
 /*
 static const struct comedi_lrange range_ao_2 = {
 	2,
@@ -525,26 +525,26 @@ static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 {
 	unsigned long flags;
 
-	// need an irq to do dma
+	/*  need an irq to do dma */
 	if (dev->irq && dma0) {
-		//encode dma0 and dma1 into 2 digit hexadecimal for switch
+		/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
 		switch ((dma0 & 0x7) | (dma1 << 4)) {
-		case 0x5:	// dma0 == 5
+		case 0x5:	/*  dma0 == 5 */
 			devpriv->dma_bits |= DMA_CH5;
 			break;
-		case 0x6:	// dma0 == 6
+		case 0x6:	/*  dma0 == 6 */
 			devpriv->dma_bits |= DMA_CH6;
 			break;
-		case 0x7:	// dma0 == 7
+		case 0x7:	/*  dma0 == 7 */
 			devpriv->dma_bits |= DMA_CH7;
 			break;
-		case 0x65:	// dma0 == 5, dma1 == 6
+		case 0x65:	/*  dma0 == 5, dma1 == 6 */
 			devpriv->dma_bits |= DMA_CH5_CH6;
 			break;
-		case 0x76:	// dma0 == 6, dma1 == 7
+		case 0x76:	/*  dma0 == 6, dma1 == 7 */
 			devpriv->dma_bits |= DMA_CH6_CH7;
 			break;
-		case 0x57:	// dma0 == 7, dma1 == 5
+		case 0x57:	/*  dma0 == 7, dma1 == 5 */
 			devpriv->dma_bits |= DMA_CH7_CH5;
 			break;
 		default:
@@ -638,7 +638,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	dev->board_ptr = das1800_boards + board;
 	dev->board_name = thisboard->name;
 
-	// if it is an 'ao' board with fancy analog out then we need extra io ports
+	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (thisboard->ao_ability == 2) {
 		iobase2 = iobase + IOBASE2;
 		if (!request_region(iobase2, DAS1800_SIZE,
@@ -659,7 +659,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	}
 	dev->irq = irq;
 
-	// set bits that tell card which irq to use
+	/*  set bits that tell card which irq to use */
 	switch (irq) {
 	case 0:
 		break;
@@ -751,12 +751,12 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 	das1800_cancel(dev, dev->read_subdev);
 
-	// initialize digital out channels
+	/*  initialize digital out channels */
 	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
 
-	// initialize analog out channels
+	/*  initialize analog out channels */
 	if (thisboard->ao_ability == 1) {
-		// select 'update' dac channel for baseAddress + 0x0
+		/*  select 'update' dac channel for baseAddress + 0x0 */
 		outb(DAC(thisboard->ao_n_chan - 1),
 			dev->iobase + DAS1800_SELECT);
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
@@ -871,7 +871,7 @@ static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 {
 	unsigned long flags;
 
-	// prevent race with interrupt handler
+	/*  prevent race with interrupt handler */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	das1800_ai_handler(dev);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -901,14 +901,14 @@ static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 	/* clear the interrupt status bit INT */
 	outb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);
-	// handle interrupt
+	/*  handle interrupt */
 	das1800_ai_handler(dev);
 
 	spin_unlock(&dev->spinlock);
 	return IRQ_HANDLED;
 }
 
-// the guts of the interrupt handler, that is shared with das1800_ai_poll
+/* the guts of the interrupt handler, that is shared with das1800_ai_poll */
 static void das1800_ai_handler(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
@@ -917,22 +917,22 @@ static void das1800_ai_handler(struct comedi_device * dev)
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
 	async->events = 0;
-	// select adc for base address + 0
+	/*  select adc for base address + 0 */
 	outb(ADC, dev->iobase + DAS1800_SELECT);
-	// dma buffer full
+	/*  dma buffer full */
 	if (devpriv->irq_dma_bits & DMA_ENABLED) {
-		// look for data from dma transfer even if dma terminal count hasn't happened yet
+		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
 		das1800_handle_dma(dev, s, status);
-	} else if (status & FHF) {	// if fifo half full
+	} else if (status & FHF) {	/*  if fifo half full */
 		das1800_handle_fifo_half_full(dev, s);
-	} else if (status & FNE) {	// if fifo not empty
+	} else if (status & FNE) {	/*  if fifo not empty */
 		das1800_handle_fifo_not_empty(dev, s);
 	}
 
 	async->events |= COMEDI_CB_BLOCK;
 	/* if the card's fifo has overflowed */
 	if (status & OVF) {
-		// clear OVF interrupt bit
+		/*  clear OVF interrupt bit */
 		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
 		comedi_error(dev, "DAS1800 FIFO overflow");
 		das1800_cancel(dev, s);
@@ -940,19 +940,19 @@ static void das1800_ai_handler(struct comedi_device * dev)
 		comedi_event(dev, s);
 		return;
 	}
-	// stop taking data if appropriate
+	/*  stop taking data if appropriate */
 	/* stop_src TRIG_EXT */
 	if (status & CT0TC) {
-		// clear CT0TC interrupt bit
+		/*  clear CT0TC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);
-		// make sure we get all remaining data from board before quitting
+		/*  make sure we get all remaining data from board before quitting */
 		if (devpriv->irq_dma_bits & DMA_ENABLED)
 			das1800_flush_dma(dev, s);
 		else
 			das1800_handle_fifo_not_empty(dev, s);
 		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async->events |= COMEDI_CB_EOA;
-	} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {	// stop_src TRIG_COUNT
+	} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {	/*  stop_src TRIG_COUNT */
 		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async->events |= COMEDI_CB_EOA;
 	}
@@ -971,7 +971,7 @@ static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevi
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
 		devpriv->dma_current_buf);
-	// re-enable  dma channel
+	/*  re-enable  dma channel */
 	set_dma_addr(devpriv->dma_current,
 		virt_to_bus(devpriv->dma_current_buf));
 	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
@@ -979,11 +979,11 @@ static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevi
 	release_dma_lock(flags);
 
 	if (status & DMATC) {
-		// clear DMATC interrupt bit
+		/*  clear DMATC interrupt bit */
 		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
-		// switch dma channels for next time, if appropriate
+		/*  switch dma channels for next time, if appropriate */
 		if (dual_dma) {
-			// read data from the other channel next time
+			/*  read data from the other channel next time */
 			if (devpriv->dma_current == devpriv->dma0) {
 				devpriv->dma_current = devpriv->dma1;
 				devpriv->dma_current_buf = devpriv->ai_buf1;
@@ -1035,7 +1035,7 @@ static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_
 	 * get set correctly */
 	clear_dma_ff(channel);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
 	num_samples = num_bytes / sizeof(short);
 
@@ -1063,7 +1063,7 @@ static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevic
 		devpriv->dma_current_buf);
 
 	if (dual_dma) {
-		// switch to other channel and flush it
+		/*  switch to other channel and flush it */
 		if (devpriv->dma_current == devpriv->dma0) {
 			devpriv->dma_current = devpriv->dma1;
 			devpriv->dma_current_buf = devpriv->ai_buf1;
@@ -1077,7 +1077,7 @@ static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevic
 
 	release_dma_lock(flags);
 
-	// get any remaining samples in fifo
+	/*  get any remaining samples in fifo */
 	das1800_handle_fifo_not_empty(dev, s);
 
 	return;
@@ -1180,7 +1180,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
@@ -1192,7 +1192,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	if (cmd->stop_src != TRIG_COUNT &&
 		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
 		err++;
-	//compatibility check
+	/* compatibility check */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 		cmd->convert_src != TRIG_TIMER)
 		err++;
@@ -1244,7 +1244,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	/* step 4: fix up any arguments */
 
 	if (cmd->convert_src == TRIG_TIMER) {
-		// if we are not in burst mode
+		/*  if we are not in burst mode */
 		if (cmd->scan_begin_src == TRIG_FOLLOW) {
 			tmp_arg = cmd->convert_arg;
 			/* calculate counter values that give desired timing */
@@ -1255,9 +1255,9 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 			if (tmp_arg != cmd->convert_arg)
 				err++;
 		}
-		// if we are in burst mode
+		/*  if we are in burst mode */
 		else {
-			// check that convert_arg is compatible
+			/*  check that convert_arg is compatible */
 			tmp_arg = cmd->convert_arg;
 			cmd->convert_arg =
 				burst_convert_arg(cmd->convert_arg,
@@ -1266,7 +1266,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 				err++;
 
 			if (cmd->scan_begin_src == TRIG_TIMER) {
-				// if scans are timed faster than conversion rate allows
+				/*  if scans are timed faster than conversion rate allows */
 				if (cmd->convert_arg * cmd->chanlist_len >
 					cmd->scan_begin_arg) {
 					cmd->scan_begin_arg =
@@ -1290,7 +1290,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	if (err)
 		return 4;
 
-	// make sure user is not trying to mix unipolar and bipolar ranges
+	/*  make sure user is not trying to mix unipolar and bipolar ranges */
 	if (cmd->chanlist) {
 		unipolar = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;
 		for (i = 1; i < cmd->chanlist_len; i++) {
@@ -1311,14 +1311,14 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 
 /* analog input cmd interface */
 
-// first, some utility functions used in the main ai_do_cmd()
+/* first, some utility functions used in the main ai_do_cmd() */
 
-// returns appropriate bits for control register a, depending on command
+/* returns appropriate bits for control register a, depending on command */
 static int control_a_bits(struct comedi_cmd cmd)
 {
 	int control_a;
 
-	control_a = FFEN;	//enable fifo
+	control_a = FFEN;	/* enable fifo */
 	if (cmd.stop_src == TRIG_EXT) {
 		control_a |= ATEN;
 	}
@@ -1336,7 +1336,7 @@ static int control_a_bits(struct comedi_cmd cmd)
 	return control_a;
 }
 
-// returns appropriate bits for control register c, depending on command
+/* returns appropriate bits for control register c, depending on command */
 static int control_c_bits(struct comedi_cmd cmd)
 {
 	int control_c;
@@ -1346,7 +1346,7 @@ static int control_c_bits(struct comedi_cmd cmd)
 	 * select unipolar / bipolar
 	 */
 	aref = CR_AREF(cmd.chanlist[0]);
-	control_c = UQEN;	//enable upper qram addresses
+	control_c = UQEN;	/* enable upper qram addresses */
 	if (aref != AREF_DIFF)
 		control_c |= SD;
 	if (aref == AREF_COMMON)
@@ -1355,7 +1355,7 @@ static int control_c_bits(struct comedi_cmd cmd)
 	if (CR_RANGE(cmd.chanlist[0]) & UNIPOLAR)
 		control_c |= UB;
 	switch (cmd.scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		switch (cmd.convert_src) {
 		case TRIG_TIMER:
 			/* trig on cascaded counters */
@@ -1370,11 +1370,11 @@ static int control_c_bits(struct comedi_cmd cmd)
 		}
 		break;
 	case TRIG_TIMER:
-		// burst mode with internal pacer clock
+		/*  burst mode with internal pacer clock */
 		control_c |= BMDE | IPCLK;
 		break;
 	case TRIG_EXT:
-		// burst mode with external trigger
+		/*  burst mode with external trigger */
 		control_c |= BMDE | XPCLK;
 		break;
 	default:
@@ -1384,12 +1384,12 @@ static int control_c_bits(struct comedi_cmd cmd)
 	return control_c;
 }
 
-// sets up counters
+/* sets up counters */
 static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 {
-	// setup cascaded counters for conversion/scan frequency
+	/*  setup cascaded counters for conversion/scan frequency */
 	switch (cmd.scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		if (cmd.convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
@@ -1401,7 +1401,7 @@ static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 			}
 		}
 		break;
-	case TRIG_TIMER:	// in burst mode
+	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
 			&(devpriv->divisor2), &(cmd.scan_begin_arg),
@@ -1414,16 +1414,16 @@ static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 		break;
 	}
 
-	// setup counter 0 for 'about triggering'
+	/*  setup counter 0 for 'about triggering' */
 	if (cmd.stop_src == TRIG_EXT) {
-		// load counter 0 in mode 0
+		/*  load counter 0 in mode 0 */
 		i8254_load(dev->iobase + DAS1800_COUNTER, 0, 0, 1, 0);
 	}
 
 	return 0;
 }
 
-// sets up dma
+/* sets up dma */
 static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	unsigned long lock_flags;
@@ -1440,19 +1440,19 @@ static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv->dma0);
 	set_dma_addr(devpriv->dma0, virt_to_bus(devpriv->ai_buf0));
-	// set appropriate size of transfer
+	/*  set appropriate size of transfer */
 	set_dma_count(devpriv->dma0, devpriv->dma_transfer_size);
 	devpriv->dma_current = devpriv->dma0;
 	devpriv->dma_current_buf = devpriv->ai_buf0;
 	enable_dma(devpriv->dma0);
-	// set up dual dma if appropriate
+	/*  set up dual dma if appropriate */
 	if (dual_dma) {
 		disable_dma(devpriv->dma1);
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
 		clear_dma_ff(devpriv->dma1);
 		set_dma_addr(devpriv->dma1, virt_to_bus(devpriv->ai_buf1));
-		// set appropriate size of transfer
+		/*  set appropriate size of transfer */
 		set_dma_count(devpriv->dma1, devpriv->dma_transfer_size);
 		enable_dma(devpriv->dma1);
 	}
@@ -1461,16 +1461,16 @@ static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 	return;
 }
 
-// programs channel/gain list into card
+/* programs channel/gain list into card */
 static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
-	const int range_mask = 0x3;	//masks unipolar/bipolar bit off range
+	const int range_mask = 0x3;	/* masks unipolar/bipolar bit off range */
 	const int range_bitshift = 8;
 
 	n = cmd.chanlist_len;
-	// spinlock protects indirect addressing
+	/*  spinlock protects indirect addressing */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
@@ -1488,7 +1488,7 @@ static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 	return;
 }
 
-// analog input do_cmd
+/* analog input do_cmd */
 static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int ret;
@@ -1509,22 +1509,22 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	} else {
 		devpriv->irq_dma_bits |= devpriv->dma_bits;
 	}
-	// interrupt on end of conversion for TRIG_WAKE_EOS
+	/*  interrupt on end of conversion for TRIG_WAKE_EOS */
 	if (cmd.flags & TRIG_WAKE_EOS) {
-		// interrupt fifo not empty
+		/*  interrupt fifo not empty */
 		devpriv->irq_dma_bits &= ~FIMD;
 	} else {
-		// interrupt fifo half full
+		/*  interrupt fifo half full */
 		devpriv->irq_dma_bits |= FIMD;
 	}
-	// determine how many conversions we need
+	/*  determine how many conversions we need */
 	if (cmd.stop_src == TRIG_COUNT) {
 		devpriv->count = cmd.stop_arg * cmd.chanlist_len;
 	}
 
 	das1800_cancel(dev, s);
 
-	// determine proper bits for control registers
+	/*  determine proper bits for control registers */
 	control_a = control_a_bits(cmd);
 	control_c = control_c_bits(cmd);
 
@@ -1537,14 +1537,14 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	}
 	setup_dma(dev, cmd);
 	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
-	// set conversion rate and length for burst mode
+	/*  set conversion rate and length for burst mode */
 	if (control_c & BMDE) {
-		// program conversion period with number of microseconds minus 1
+		/*  program conversion period with number of microseconds minus 1 */
 		outb(cmd.convert_arg / 1000 - 1,
 			dev->iobase + DAS1800_BURST_RATE);
 		outb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
 	}
-	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	// enable irq/dma
+	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
 	outb(control_a, dev->iobase + DAS1800_CONTROL_A);	/* enable fifo and triggering */
 	outb(CVEN, dev->iobase + DAS1800_STATUS);	/* enable conversions */
 
@@ -1616,21 +1616,21 @@ static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
-//      int range = CR_RANGE(insn->chanspec);
+/* int range = CR_RANGE(insn->chanspec); */
 	int update_chan = thisboard->ao_n_chan - 1;
 	short output;
 	unsigned long irq_flags;
 
-	//  card expects two's complement data
+	/*   card expects two's complement data */
 	output = data[0] - (1 << (thisboard->resolution - 1));
-	// if the write is to the 'update' channel, we need to remember its value
+	/*  if the write is to the 'update' channel, we need to remember its value */
 	if (chan == update_chan)
 		devpriv->ao_update_bits = output;
-	// write to channel
+	/*  write to channel */
 	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(DAC(chan), dev->iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
 	outw(output, dev->iobase + DAS1800_DAC);
-	// now we need to write to 'update' channel to update all dac channels
+	/*  now we need to write to 'update' channel to update all dac channels */
 	if (chan != update_chan) {
 		outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
 		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
@@ -1657,7 +1657,7 @@ static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice
 {
 	unsigned int wbits;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &= (1 << s->n_chan) - 1;
 	wbits = devpriv->do_bits;
 	wbits &= ~data[0];
@@ -1676,11 +1676,11 @@ static int das1800_set_frequency(struct comedi_device * dev)
 {
 	int err = 0;
 
-	// counter 1, mode 2
+	/*  counter 1, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
 			2))
 		err++;
-	// counter 2, mode 2
+	/*  counter 2, mode 2 */
 	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
 			2))
 		err++;
@@ -1697,11 +1697,11 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 {
 	unsigned int micro_sec;
 
-	// in burst mode, the maximum conversion time is 64 microseconds
+	/*  in burst mode, the maximum conversion time is 64 microseconds */
 	if (convert_arg > 64000)
 		convert_arg = 64000;
 
-	// the conversion time must be an integral number of microseconds
+	/*  the conversion time must be an integral number of microseconds */
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
 	default:
@@ -1715,21 +1715,21 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 		break;
 	}
 
-	// return number of nanoseconds
+	/*  return number of nanoseconds */
 	return micro_sec * 1000;
 }
 
-// utility function that suggests a dma transfer size based on the conversion period 'ns'
+/* utility function that suggests a dma transfer size based on the conversion period 'ns' */
 static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
 {
 	unsigned int size = DMA_BUF_SIZE;
-	static const int sample_size = 2;	// size in bytes of one sample from board
-	unsigned int fill_time = 300000000;	// target time in nanoseconds for filling dma buffer
-	unsigned int max_size;	// maximum size we will allow for a transfer
+	static const int sample_size = 2;	/*  size in bytes of one sample from board */
+	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
+	unsigned int max_size;	/*  maximum size we will allow for a transfer */
 
-	// make dma buffer fill in 0.3 seconds for timed modes
+	/*  make dma buffer fill in 0.3 seconds for timed modes */
 	switch (cmd->scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		if (cmd->convert_src == TRIG_TIMER)
 			size = (fill_time / cmd->convert_arg) * sample_size;
 		break;
@@ -1742,9 +1742,9 @@ static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
 		break;
 	}
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	max_size = DMA_BUF_SIZE;
-	// if we are taking limited number of conversions, limit transfer size to that
+	/*  if we are taking limited number of conversions, limit transfer size to that */
 	if (cmd->stop_src == TRIG_COUNT &&
 		cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
 		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;

commit 0c5a144d730a68967dfb3f8163260a142e3282e3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:58 2009 -0400

    Staging: comedi: Remove das1800_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 950ee2c7cd57..cd4cd4e6a79b 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -463,7 +463,7 @@ static const struct das1800_board das1800_boards[] = {
  */
 #define thisboard ((const struct das1800_board *)dev->board_ptr)
 
-typedef struct {
+struct das1800_private {
 	volatile unsigned int count;	/* number of data points left to be taken */
 	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
 	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
@@ -481,9 +481,9 @@ typedef struct {
 	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
 	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
 	short ao_update_bits;	/* remembers the last write to the 'update' dac */
-} das1800_private;
+};
 
-#define devpriv ((das1800_private *)dev->private)
+#define devpriv ((struct das1800_private *)dev->private)
 
 // analog out range for boards with basic analog out
 static const struct comedi_lrange range_ao_1 = {
@@ -602,7 +602,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	int retval;
 
 	/* allocate and initialize dev->private */
-	if (alloc_private(dev, sizeof(das1800_private)) < 0)
+	if (alloc_private(dev, sizeof(struct das1800_private)) < 0)
 		return -ENOMEM;
 
 	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_das1800.driver_name,

commit ce422cf3569444116d7d826b274bd59cc34d3b28
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:13:53 2009 -0400

    Staging: comedi: Remove das1800_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 06f755a5d32c..950ee2c7cd57 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -241,7 +241,7 @@ static const struct comedi_lrange range_ai_das1802 = {
 		}
 };
 
-typedef struct das1800_board_struct {
+struct das1800_board {
 	const char *name;
 	int ai_speed;		/* max conversion period in nanoseconds */
 	int resolution;		/* bits of ai resolution */
@@ -251,13 +251,13 @@ typedef struct das1800_board_struct {
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
 	int ao_n_chan;		/* number of analog out channels */
 	const struct comedi_lrange *range_ai;	/* available input ranges */
-} das1800_board;
+};
 
 /* Warning: the maximum conversion speeds listed below are
  * not always achievable depending on board setup (see
  * user manual.)
  */
-static const das1800_board das1800_boards[] = {
+static const struct das1800_board das1800_boards[] = {
 	{
 	      name:	"das-1701st",
 	      ai_speed:6250,
@@ -461,7 +461,7 @@ static const das1800_board das1800_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const das1800_board *)dev->board_ptr)
+#define thisboard ((const struct das1800_board *)dev->board_ptr)
 
 typedef struct {
 	volatile unsigned int count;	/* number of data points left to be taken */
@@ -509,9 +509,9 @@ static struct comedi_driver driver_das1800 = {
       module:THIS_MODULE,
       attach:das1800_attach,
       detach:das1800_detach,
-      num_names:sizeof(das1800_boards) / sizeof(das1800_board),
+      num_names:sizeof(das1800_boards) / sizeof(struct das1800_board),
       board_name:&das1800_boards[0].name,
-      offset:sizeof(das1800_board),
+      offset:sizeof(struct das1800_board),
 };
 
 /*
@@ -799,7 +799,7 @@ static int das1800_probe(struct comedi_device * dev)
 	int board;
 
 	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
-	board = ((das1800_board *) dev->board_ptr) - das1800_boards;
+	board = ((struct das1800_board *) dev->board_ptr) - das1800_boards;
 
 	switch (id) {
 	case 0x3:

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index cb53e8fe2403..06f755a5d32c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -180,7 +180,7 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int das1800_detach(struct comedi_device * dev);
 static int das1800_probe(struct comedi_device * dev);
 static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -590,7 +590,7 @@ static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 	return 0;
 }
 
-static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 8d8ecac73a08..cb53e8fe2403 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -200,13 +200,13 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	struct comedi_cmd * cmd);
 static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 
 static int das1800_set_frequency(struct comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
@@ -1553,7 +1553,7 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 
 /* read analog input */
 static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan, range, aref, chan_range;
@@ -1613,7 +1613,7 @@ static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice
 
 /* writes to an analog output channel */
 static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 //      int range = CR_RANGE(insn->chanspec);
@@ -1642,7 +1642,7 @@ static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 
 /* reads from digital input channels */
 static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
@@ -1653,7 +1653,7 @@ static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice
 
 /* writes to digital output channels */
 static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;
 

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2e066727fda3..8d8ecac73a08 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -197,7 +197,7 @@ static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 	struct comedi_subdevice * s);
 static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
@@ -210,7 +210,7 @@ static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice
 
 static int das1800_set_frequency(struct comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
-static unsigned int suggest_transfer_size(comedi_cmd * cmd);
+static unsigned int suggest_transfer_size(struct comedi_cmd * cmd);
 
 // analog input ranges
 static const struct comedi_lrange range_ai_das1801 = {
@@ -913,7 +913,7 @@ static void das1800_ai_handler(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
 	async->events = 0;
@@ -1027,7 +1027,7 @@ static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_
 	unsigned int channel, uint16_t * buffer)
 {
 	unsigned int num_bytes, num_samples;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	disable_dma(channel);
 
@@ -1087,7 +1087,7 @@ static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 	struct comedi_subdevice * s)
 {
 	int numPoints = 0;	/* number of points to read */
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	numPoints = FIFO_SIZE / 2;
 	/* if we only need some of the points */
@@ -1107,7 +1107,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 {
 	short dpnt;
 	int unipolar;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
 
@@ -1140,7 +1140,7 @@ static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice *
 
 /* test analog input cmd */
 static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1314,7 +1314,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 // first, some utility functions used in the main ai_do_cmd()
 
 // returns appropriate bits for control register a, depending on command
-static int control_a_bits(comedi_cmd cmd)
+static int control_a_bits(struct comedi_cmd cmd)
 {
 	int control_a;
 
@@ -1337,7 +1337,7 @@ static int control_a_bits(comedi_cmd cmd)
 }
 
 // returns appropriate bits for control register c, depending on command
-static int control_c_bits(comedi_cmd cmd)
+static int control_c_bits(struct comedi_cmd cmd)
 {
 	int control_c;
 	int aref;
@@ -1385,7 +1385,7 @@ static int control_c_bits(comedi_cmd cmd)
 }
 
 // sets up counters
-static int setup_counters(struct comedi_device * dev, comedi_cmd cmd)
+static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	// setup cascaded counters for conversion/scan frequency
 	switch (cmd.scan_begin_src) {
@@ -1424,7 +1424,7 @@ static int setup_counters(struct comedi_device * dev, comedi_cmd cmd)
 }
 
 // sets up dma
-static void setup_dma(struct comedi_device * dev, comedi_cmd cmd)
+static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1462,7 +1462,7 @@ static void setup_dma(struct comedi_device * dev, comedi_cmd cmd)
 }
 
 // programs channel/gain list into card
-static void program_chanlist(struct comedi_device * dev, comedi_cmd cmd)
+static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
@@ -1494,7 +1494,7 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	int ret;
 	int control_a, control_c;
 	struct comedi_async *async = s->async;
-	comedi_cmd cmd = async->cmd;
+	struct comedi_cmd cmd = async->cmd;
 
 	if (!dev->irq) {
 		comedi_error(dev,
@@ -1720,7 +1720,7 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 }
 
 // utility function that suggests a dma transfer size based on the conversion period 'ns'
-static unsigned int suggest_transfer_size(comedi_cmd * cmd)
+static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
 {
 	unsigned int size = DMA_BUF_SIZE;
 	static const int sample_size = 2;	// size in bytes of one sample from board

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 2bdb6a33dde4..2e066727fda3 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -213,7 +213,7 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
 static unsigned int suggest_transfer_size(comedi_cmd * cmd);
 
 // analog input ranges
-static const comedi_lrange range_ai_das1801 = {
+static const struct comedi_lrange range_ai_das1801 = {
 	8,
 	{
 			RANGE(-5, 5),
@@ -227,7 +227,7 @@ static const comedi_lrange range_ai_das1801 = {
 		}
 };
 
-static const comedi_lrange range_ai_das1802 = {
+static const struct comedi_lrange range_ai_das1802 = {
 	8,
 	{
 			RANGE(-10, 10),
@@ -250,7 +250,7 @@ typedef struct das1800_board_struct {
 	int do_n_chan;		/* number of digital output channels */
 	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
 	int ao_n_chan;		/* number of analog out channels */
-	const comedi_lrange *range_ai;	/* available input ranges */
+	const struct comedi_lrange *range_ai;	/* available input ranges */
 } das1800_board;
 
 /* Warning: the maximum conversion speeds listed below are
@@ -486,7 +486,7 @@ typedef struct {
 #define devpriv ((das1800_private *)dev->private)
 
 // analog out range for boards with basic analog out
-static const comedi_lrange range_ao_1 = {
+static const struct comedi_lrange range_ao_1 = {
 	1,
 	{
 			RANGE(-10, 10),
@@ -495,7 +495,7 @@ static const comedi_lrange range_ao_1 = {
 
 // analog out range for 'ao' boards
 /*
-static const comedi_lrange range_ao_2 = {
+static const struct comedi_lrange range_ao_2 = {
 	2,
 	{
 		RANGE(-10, 10),

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 47d92c70ca0a..2bdb6a33dde4 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -504,7 +504,7 @@ static const comedi_lrange range_ao_2 = {
 };
 */
 
-static comedi_driver driver_das1800 = {
+static struct comedi_driver driver_das1800 = {
       driver_name:"das1800",
       module:THIS_MODULE,
       attach:das1800_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 5a63a00d1a4c..47d92c70ca0a 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -912,7 +912,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 static void das1800_ai_handler(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
 
@@ -1493,7 +1493,7 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 {
 	int ret;
 	int control_a, control_c;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd cmd = async->cmd;
 
 	if (!dev->irq) {

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9fb800fbfc15..5a63a00d1a4c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -183,29 +183,29 @@ enum {
 static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int das1800_detach(struct comedi_device * dev);
 static int das1800_probe(struct comedi_device * dev);
-static int das1800_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG);
-static int das1800_ai_poll(struct comedi_device * dev, comedi_subdevice * s);
+static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s);
 static void das1800_ai_handler(struct comedi_device * dev);
-static void das1800_handle_dma(struct comedi_device * dev, comedi_subdevice * s,
+static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int status);
-static void das1800_flush_dma(struct comedi_device * dev, comedi_subdevice * s);
-static void das1800_flush_dma_channel(struct comedi_device * dev, comedi_subdevice * s,
+static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevice * s);
+static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int channel, uint16_t * buffer);
 static void das1800_handle_fifo_half_full(struct comedi_device * dev,
-	comedi_subdevice * s);
+	struct comedi_subdevice * s);
 static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
-	comedi_subdevice * s);
-static int das1800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+	struct comedi_subdevice * s);
+static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das1800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int das1800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
 static int das1800_set_frequency(struct comedi_device * dev);
@@ -592,7 +592,7 @@ static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 
 static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
 	unsigned int irq = it->options[1];
 	unsigned int dma0 = it->options[2];
@@ -867,7 +867,7 @@ static int das1800_probe(struct comedi_device * dev)
 	return -1;
 }
 
-static int das1800_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
+static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -911,7 +911,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 // the guts of the interrupt handler, that is shared with das1800_ai_poll
 static void das1800_ai_handler(struct comedi_device * dev)
 {
-	comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
+	struct comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
@@ -962,7 +962,7 @@ static void das1800_ai_handler(struct comedi_device * dev)
 	return;
 }
 
-static void das1800_handle_dma(struct comedi_device * dev, comedi_subdevice * s,
+static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int status)
 {
 	unsigned long flags;
@@ -1023,7 +1023,7 @@ static void munge_data(struct comedi_device * dev, uint16_t * array,
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
  * Assumes dma lock is held */
-static void das1800_flush_dma_channel(struct comedi_device * dev, comedi_subdevice * s,
+static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int channel, uint16_t * buffer)
 {
 	unsigned int num_bytes, num_samples;
@@ -1053,7 +1053,7 @@ static void das1800_flush_dma_channel(struct comedi_device * dev, comedi_subdevi
 
 /* flushes remaining data from board when external trigger has stopped aquisition
  * and we are using dma transfers */
-static void das1800_flush_dma(struct comedi_device * dev, comedi_subdevice * s)
+static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1084,7 +1084,7 @@ static void das1800_flush_dma(struct comedi_device * dev, comedi_subdevice * s)
 }
 
 static void das1800_handle_fifo_half_full(struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	int numPoints = 0;	/* number of points to read */
 	comedi_cmd *cmd = &s->async->cmd;
@@ -1103,7 +1103,7 @@ static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 }
 
 static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
-	comedi_subdevice * s)
+	struct comedi_subdevice * s)
 {
 	short dpnt;
 	int unipolar;
@@ -1126,7 +1126,7 @@ static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 	return;
 }
 
-static int das1800_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int das1800_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
@@ -1139,7 +1139,7 @@ static int das1800_cancel(struct comedi_device * dev, comedi_subdevice * s)
 }
 
 /* test analog input cmd */
-static int das1800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1489,7 +1489,7 @@ static void program_chanlist(struct comedi_device * dev, comedi_cmd cmd)
 }
 
 // analog input do_cmd
-static int das1800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int ret;
 	int control_a, control_c;
@@ -1552,7 +1552,7 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
 }
 
 /* read analog input */
-static int das1800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1612,7 +1612,7 @@ static int das1800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 /* writes to an analog output channel */
-static int das1800_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1641,7 +1641,7 @@ static int das1800_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 /* reads from digital input channels */
-static int das1800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_di_rbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 
@@ -1652,7 +1652,7 @@ static int das1800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 /* writes to digital output channels */
-static int das1800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
+static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index f66cf17bbbcd..9fb800fbfc15 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -180,35 +180,35 @@ enum {
 	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
 };
 
-static int das1800_attach(comedi_device * dev, comedi_devconfig * it);
-static int das1800_detach(comedi_device * dev);
-static int das1800_probe(comedi_device * dev);
-static int das1800_cancel(comedi_device * dev, comedi_subdevice * s);
+static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int das1800_detach(struct comedi_device * dev);
+static int das1800_probe(struct comedi_device * dev);
+static int das1800_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG);
-static int das1800_ai_poll(comedi_device * dev, comedi_subdevice * s);
-static void das1800_ai_handler(comedi_device * dev);
-static void das1800_handle_dma(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_poll(struct comedi_device * dev, comedi_subdevice * s);
+static void das1800_ai_handler(struct comedi_device * dev);
+static void das1800_handle_dma(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int status);
-static void das1800_flush_dma(comedi_device * dev, comedi_subdevice * s);
-static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
+static void das1800_flush_dma(struct comedi_device * dev, comedi_subdevice * s);
+static void das1800_flush_dma_channel(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int channel, uint16_t * buffer);
-static void das1800_handle_fifo_half_full(comedi_device * dev,
+static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 	comedi_subdevice * s);
-static void das1800_handle_fifo_not_empty(comedi_device * dev,
+static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 	comedi_subdevice * s);
-static int das1800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
-static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int das1800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das1800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das1800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 
-static int das1800_set_frequency(comedi_device * dev);
+static int das1800_set_frequency(struct comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
 static unsigned int suggest_transfer_size(comedi_cmd * cmd);
 
@@ -520,7 +520,7 @@ static comedi_driver driver_das1800 = {
  */
 COMEDI_INITCLEANUP(driver_das1800);
 
-static int das1800_init_dma(comedi_device * dev, unsigned int dma0,
+static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 	unsigned int dma1)
 {
 	unsigned long flags;
@@ -590,7 +590,7 @@ static int das1800_init_dma(comedi_device * dev, unsigned int dma0,
 	return 0;
 }
 
-static int das1800_attach(comedi_device * dev, comedi_devconfig * it)
+static int das1800_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned long iobase = it->options[0];
@@ -765,7 +765,7 @@ static int das1800_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 };
 
-static int das1800_detach(comedi_device * dev)
+static int das1800_detach(struct comedi_device * dev)
 {
 	/* only free stuff if it has been allocated by _attach */
 	if (dev->iobase)
@@ -793,7 +793,7 @@ static int das1800_detach(comedi_device * dev)
 
 /* probes and checks das-1800 series board type
  */
-static int das1800_probe(comedi_device * dev)
+static int das1800_probe(struct comedi_device * dev)
 {
 	int id;
 	int board;
@@ -867,7 +867,7 @@ static int das1800_probe(comedi_device * dev)
 	return -1;
 }
 
-static int das1800_ai_poll(comedi_device * dev, comedi_subdevice * s)
+static int das1800_ai_poll(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -881,7 +881,7 @@ static int das1800_ai_poll(comedi_device * dev, comedi_subdevice * s)
 
 static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	unsigned int status;
 
 	if (dev->attached == 0) {
@@ -909,7 +909,7 @@ static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 }
 
 // the guts of the interrupt handler, that is shared with das1800_ai_poll
-static void das1800_ai_handler(comedi_device * dev)
+static void das1800_ai_handler(struct comedi_device * dev)
 {
 	comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
 	comedi_async *async = s->async;
@@ -962,7 +962,7 @@ static void das1800_ai_handler(comedi_device * dev)
 	return;
 }
 
-static void das1800_handle_dma(comedi_device * dev, comedi_subdevice * s,
+static void das1800_handle_dma(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int status)
 {
 	unsigned long flags;
@@ -997,14 +997,14 @@ static void das1800_handle_dma(comedi_device * dev, comedi_subdevice * s,
 	return;
 }
 
-static inline uint16_t munge_bipolar_sample(const comedi_device * dev,
+static inline uint16_t munge_bipolar_sample(const struct comedi_device * dev,
 	uint16_t sample)
 {
 	sample += 1 << (thisboard->resolution - 1);
 	return sample;
 }
 
-static void munge_data(comedi_device * dev, uint16_t * array,
+static void munge_data(struct comedi_device * dev, uint16_t * array,
 	unsigned int num_elements)
 {
 	unsigned int i;
@@ -1023,7 +1023,7 @@ static void munge_data(comedi_device * dev, uint16_t * array,
 
 /* Utility function used by das1800_flush_dma() and das1800_handle_dma().
  * Assumes dma lock is held */
-static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
+static void das1800_flush_dma_channel(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int channel, uint16_t * buffer)
 {
 	unsigned int num_bytes, num_samples;
@@ -1053,7 +1053,7 @@ static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
 
 /* flushes remaining data from board when external trigger has stopped aquisition
  * and we are using dma transfers */
-static void das1800_flush_dma(comedi_device * dev, comedi_subdevice * s)
+static void das1800_flush_dma(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1083,7 +1083,7 @@ static void das1800_flush_dma(comedi_device * dev, comedi_subdevice * s)
 	return;
 }
 
-static void das1800_handle_fifo_half_full(comedi_device * dev,
+static void das1800_handle_fifo_half_full(struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	int numPoints = 0;	/* number of points to read */
@@ -1102,7 +1102,7 @@ static void das1800_handle_fifo_half_full(comedi_device * dev,
 	return;
 }
 
-static void das1800_handle_fifo_not_empty(comedi_device * dev,
+static void das1800_handle_fifo_not_empty(struct comedi_device * dev,
 	comedi_subdevice * s)
 {
 	short dpnt;
@@ -1126,7 +1126,7 @@ static void das1800_handle_fifo_not_empty(comedi_device * dev,
 	return;
 }
 
-static int das1800_cancel(comedi_device * dev, comedi_subdevice * s)
+static int das1800_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
 	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
@@ -1139,7 +1139,7 @@ static int das1800_cancel(comedi_device * dev, comedi_subdevice * s)
 }
 
 /* test analog input cmd */
-static int das1800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_do_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1385,7 +1385,7 @@ static int control_c_bits(comedi_cmd cmd)
 }
 
 // sets up counters
-static int setup_counters(comedi_device * dev, comedi_cmd cmd)
+static int setup_counters(struct comedi_device * dev, comedi_cmd cmd)
 {
 	// setup cascaded counters for conversion/scan frequency
 	switch (cmd.scan_begin_src) {
@@ -1424,7 +1424,7 @@ static int setup_counters(comedi_device * dev, comedi_cmd cmd)
 }
 
 // sets up dma
-static void setup_dma(comedi_device * dev, comedi_cmd cmd)
+static void setup_dma(struct comedi_device * dev, comedi_cmd cmd)
 {
 	unsigned long lock_flags;
 	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
@@ -1462,7 +1462,7 @@ static void setup_dma(comedi_device * dev, comedi_cmd cmd)
 }
 
 // programs channel/gain list into card
-static void program_chanlist(comedi_device * dev, comedi_cmd cmd)
+static void program_chanlist(struct comedi_device * dev, comedi_cmd cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
@@ -1489,7 +1489,7 @@ static void program_chanlist(comedi_device * dev, comedi_cmd cmd)
 }
 
 // analog input do_cmd
-static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
+static int das1800_ai_do_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int ret;
 	int control_a, control_c;
@@ -1552,7 +1552,7 @@ static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
 }
 
 /* read analog input */
-static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
@@ -1612,7 +1612,7 @@ static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* writes to an analog output channel */
-static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+static int das1800_ao_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
@@ -1641,7 +1641,7 @@ static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* reads from digital input channels */
-static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+static int das1800_di_rbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 
@@ -1652,7 +1652,7 @@ static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* writes to digital output channels */
-static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+static int das1800_do_wbits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int wbits;
@@ -1672,7 +1672,7 @@ static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* loads counters with divisor1, divisor2 from private structure */
-static int das1800_set_frequency(comedi_device * dev)
+static int das1800_set_frequency(struct comedi_device * dev)
 {
 	int err = 0;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 9c106965a429..f66cf17bbbcd 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -200,13 +200,13 @@ static int das1800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
 static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 
 static int das1800_set_frequency(comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
@@ -1037,7 +1037,7 @@ static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
 
 	// figure out how many points to read
 	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
-	num_samples = num_bytes / sizeof(sampl_t);
+	num_samples = num_bytes / sizeof(short);
 
 	/* if we only need some of the points */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)
@@ -1105,7 +1105,7 @@ static void das1800_handle_fifo_half_full(comedi_device * dev,
 static void das1800_handle_fifo_not_empty(comedi_device * dev,
 	comedi_subdevice * s)
 {
-	sampl_t dpnt;
+	short dpnt;
 	int unipolar;
 	comedi_cmd *cmd = &s->async->cmd;
 
@@ -1553,7 +1553,7 @@ static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
 
 /* read analog input */
 static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i, n;
 	int chan, range, aref, chan_range;
@@ -1613,7 +1613,7 @@ static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 
 /* writes to an analog output channel */
 static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn->chanspec);
 //      int range = CR_RANGE(insn->chanspec);
@@ -1642,7 +1642,7 @@ static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 
 /* reads from digital input channels */
 static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 
 	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
@@ -1653,9 +1653,9 @@ static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
 
 /* writes to digital output channels */
 static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	lsampl_t wbits;
+	unsigned int wbits;
 
 	// only set bits that have been masked
 	data[0] &= (1 << s->n_chan) - 1;

commit a69cc3a9fae82f3620d7242fe5bfaedd24b65df5
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 19 09:51:15 2009 -0800

    Staging: comedi: add das1800 driver
    
    Driver for Keitley das1700/das1800 series boards
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
new file mode 100644
index 000000000000..9c106965a429
--- /dev/null
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -0,0 +1,1758 @@
+/*
+    comedi/drivers/das1800.c
+    Driver for Keitley das1700/das1800 series boards
+    Copyright (C) 2000 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: das1800
+Description: Keithley Metrabyte DAS1800 (& compatibles)
+Author: Frank Mori Hess <fmhess@users.sourceforge.net>
+Devices: [Keithley Metrabyte] DAS-1701ST (das-1701st),
+  DAS-1701ST-DA (das-1701st-da), DAS-1701/AO (das-1701ao),
+  DAS-1702ST (das-1702st), DAS-1702ST-DA (das-1702st-da),
+  DAS-1702HR (das-1702hr), DAS-1702HR-DA (das-1702hr-da),
+  DAS-1702/AO (das-1702ao), DAS-1801ST (das-1801st),
+  DAS-1801ST-DA (das-1801st-da), DAS-1801HC (das-1801hc),
+  DAS-1801AO (das-1801ao), DAS-1802ST (das-1802st),
+  DAS-1802ST-DA (das-1802st-da), DAS-1802HR (das-1802hr),
+  DAS-1802HR-DA (das-1802hr-da), DAS-1802HC (das-1802hc),
+  DAS-1802AO (das-1802ao)
+Status: works
+
+The waveform analog output on the 'ao' cards is not supported.
+If you need it, send me (Frank Hess) an email.
+
+Configuration options:
+  [0] - I/O port base address
+  [1] - IRQ (optional, required for timed or externally triggered conversions)
+  [2] - DMA0 (optional, requires irq)
+  [3] - DMA1 (optional, requires irq and dma0)
+*/
+/*
+
+This driver supports the following Keithley boards:
+
+das-1701st
+das-1701st-da
+das-1701ao
+das-1702st
+das-1702st-da
+das-1702hr
+das-1702hr-da
+das-1702ao
+das-1801st
+das-1801st-da
+das-1801hc
+das-1801ao
+das-1802st
+das-1802st-da
+das-1802hr
+das-1802hr-da
+das-1802hc
+das-1802ao
+
+Options:
+	[0] - base io address
+	[1] - irq (optional, required for timed or externally triggered conversions)
+	[2] - dma0 (optional, requires irq)
+	[3] - dma1 (optional, requires irq and dma0)
+
+irq can be omitted, although the cmd interface will not work without it.
+
+analog input cmd triggers supported:
+	start_src:      TRIG_NOW | TRIG_EXT
+	scan_begin_src: TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT
+	scan_end_src:   TRIG_COUNT
+	convert_src:    TRIG_TIMER | TRIG_EXT (TRIG_EXT requires scan_begin_src == TRIG_FOLLOW)
+	stop_src:       TRIG_COUNT | TRIG_EXT | TRIG_NONE
+
+scan_begin_src triggers TRIG_TIMER and TRIG_EXT use the card's
+'burst mode' which limits the valid conversion time to 64 microseconds
+(convert_arg <= 64000).  This limitation does not apply if scan_begin_src
+is TRIG_FOLLOW.
+
+NOTES:
+Only the DAS-1801ST has been tested by me.
+Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
+
+TODO:
+	Make it automatically allocate irq and dma channels if they are not specified
+	Add support for analog out on 'ao' cards
+	read insn for analog out
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <asm/dma.h>
+
+#include "8253.h"
+#include "comedi_fc.h"
+
+// misc. defines
+#define DAS1800_SIZE           16	//uses 16 io addresses
+#define FIFO_SIZE              1024	// 1024 sample fifo
+#define TIMER_BASE             200	// 5 Mhz master clock
+#define UNIPOLAR               0x4	// bit that determines whether input range is uni/bipolar
+#define DMA_BUF_SIZE           0x1ff00	// size in bytes of dma buffers
+
+/* Registers for the das1800 */
+#define DAS1800_FIFO            0x0
+#define DAS1800_QRAM            0x0
+#define DAS1800_DAC             0x0
+#define DAS1800_SELECT          0x2
+#define   ADC                     0x0
+#define   QRAM                    0x1
+#define   DAC(a)                  (0x2 + a)
+#define DAS1800_DIGITAL         0x3
+#define DAS1800_CONTROL_A       0x4
+#define   FFEN                    0x1
+#define   CGEN                    0x4
+#define   CGSL                    0x8
+#define   TGEN                    0x10
+#define   TGSL                    0x20
+#define   ATEN                    0x80
+#define DAS1800_CONTROL_B       0x5
+#define   DMA_CH5                 0x1
+#define   DMA_CH6                 0x2
+#define   DMA_CH7                 0x3
+#define   DMA_CH5_CH6             0x5
+#define   DMA_CH6_CH7             0x6
+#define   DMA_CH7_CH5             0x7
+#define   DMA_ENABLED             0x3	//mask used to determine if dma is enabled
+#define   DMA_DUAL                0x4
+#define   IRQ3                    0x8
+#define   IRQ5                    0x10
+#define   IRQ7                    0x18
+#define   IRQ10                   0x28
+#define   IRQ11                   0x30
+#define   IRQ15                   0x38
+#define   FIMD                    0x40
+#define DAS1800_CONTROL_C       0X6
+#define   IPCLK                   0x1
+#define   XPCLK                   0x3
+#define   BMDE                    0x4
+#define   CMEN                    0x8
+#define   UQEN                    0x10
+#define   SD                      0x40
+#define   UB                      0x80
+#define DAS1800_STATUS          0x7
+// bits that prevent interrupt status bits (and CVEN) from being cleared on write
+#define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)
+#define   INT                     0x1
+#define   DMATC                   0x2
+#define   CT0TC                   0x8
+#define   OVF                     0x10
+#define   FHF                     0x20
+#define   FNE                     0x40
+#define   CVEN_MASK               0x40	// masks CVEN on write
+#define   CVEN                    0x80
+#define DAS1800_BURST_LENGTH    0x8
+#define DAS1800_BURST_RATE      0x9
+#define DAS1800_QRAM_ADDRESS    0xa
+#define DAS1800_COUNTER         0xc
+
+#define IOBASE2                   0x400	//offset of additional ioports used on 'ao' cards
+
+enum {
+	das1701st, das1701st_da, das1702st, das1702st_da, das1702hr,
+	das1702hr_da,
+	das1701ao, das1702ao, das1801st, das1801st_da, das1802st, das1802st_da,
+	das1802hr, das1802hr_da, das1801hc, das1802hc, das1801ao, das1802ao
+};
+
+static int das1800_attach(comedi_device * dev, comedi_devconfig * it);
+static int das1800_detach(comedi_device * dev);
+static int das1800_probe(comedi_device * dev);
+static int das1800_cancel(comedi_device * dev, comedi_subdevice * s);
+static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG);
+static int das1800_ai_poll(comedi_device * dev, comedi_subdevice * s);
+static void das1800_ai_handler(comedi_device * dev);
+static void das1800_handle_dma(comedi_device * dev, comedi_subdevice * s,
+	unsigned int status);
+static void das1800_flush_dma(comedi_device * dev, comedi_subdevice * s);
+static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
+	unsigned int channel, uint16_t * buffer);
+static void das1800_handle_fifo_half_full(comedi_device * dev,
+	comedi_subdevice * s);
+static void das1800_handle_fifo_not_empty(comedi_device * dev,
+	comedi_subdevice * s);
+static int das1800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
+static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+
+static int das1800_set_frequency(comedi_device * dev);
+static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
+static unsigned int suggest_transfer_size(comedi_cmd * cmd);
+
+// analog input ranges
+static const comedi_lrange range_ai_das1801 = {
+	8,
+	{
+			RANGE(-5, 5),
+			RANGE(-1, 1),
+			RANGE(-0.1, 0.1),
+			RANGE(-0.02, 0.02),
+			RANGE(0, 5),
+			RANGE(0, 1),
+			RANGE(0, 0.1),
+			RANGE(0, 0.02),
+		}
+};
+
+static const comedi_lrange range_ai_das1802 = {
+	8,
+	{
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2.5, 2.5),
+			RANGE(-1.25, 1.25),
+			RANGE(0, 10),
+			RANGE(0, 5),
+			RANGE(0, 2.5),
+			RANGE(0, 1.25),
+		}
+};
+
+typedef struct das1800_board_struct {
+	const char *name;
+	int ai_speed;		/* max conversion period in nanoseconds */
+	int resolution;		/* bits of ai resolution */
+	int qram_len;		/* length of card's channel / gain queue */
+	int common;		/* supports AREF_COMMON flag */
+	int do_n_chan;		/* number of digital output channels */
+	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
+	int ao_n_chan;		/* number of analog out channels */
+	const comedi_lrange *range_ai;	/* available input ranges */
+} das1800_board;
+
+/* Warning: the maximum conversion speeds listed below are
+ * not always achievable depending on board setup (see
+ * user manual.)
+ */
+static const das1800_board das1800_boards[] = {
+	{
+	      name:	"das-1701st",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1701st-da",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:1,
+	      ao_n_chan:4,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1702st",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1702st-da",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:1,
+	      ao_n_chan:4,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1702hr",
+	      ai_speed:20000,
+	      resolution:16,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1702hr-da",
+	      ai_speed:20000,
+	      resolution:16,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:1,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1701ao",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:2,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1702ao",
+	      ai_speed:6250,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:2,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1801st",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1801st-da",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:4,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1802st",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1802st-da",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:1,
+	      ao_n_chan:4,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1802hr",
+	      ai_speed:10000,
+	      resolution:16,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:0,
+	      ao_n_chan:0,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1802hr-da",
+	      ai_speed:10000,
+	      resolution:16,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:1,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1801hc",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:64,
+	      common:	0,
+	      do_n_chan:8,
+	      ao_ability:1,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1802hc",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:64,
+	      common:	0,
+	      do_n_chan:8,
+	      ao_ability:1,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1802,
+		},
+	{
+	      name:	"das-1801ao",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:2,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1801,
+		},
+	{
+	      name:	"das-1802ao",
+	      ai_speed:3000,
+	      resolution:12,
+	      qram_len:256,
+	      common:	1,
+	      do_n_chan:4,
+	      ao_ability:2,
+	      ao_n_chan:2,
+	      range_ai:&range_ai_das1802,
+		},
+};
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const das1800_board *)dev->board_ptr)
+
+typedef struct {
+	volatile unsigned int count;	/* number of data points left to be taken */
+	unsigned int divisor1;	/* value to load into board's counter 1 for timed conversions */
+	unsigned int divisor2;	/* value to load into board's counter 2 for timed conversions */
+	int do_bits;		/* digital output bits */
+	int irq_dma_bits;	/* bits for control register b */
+	/* dma bits for control register b, stored so that dma can be
+	 * turned on and off */
+	int dma_bits;
+	unsigned int dma0;	/* dma channels used */
+	unsigned int dma1;
+	volatile unsigned int dma_current;	/* dma channel currently in use */
+	uint16_t *ai_buf0;	/* pointers to dma buffers */
+	uint16_t *ai_buf1;
+	uint16_t *dma_current_buf;	/* pointer to dma buffer currently being used */
+	unsigned int dma_transfer_size;	/* size of transfer currently used, in bytes */
+	unsigned long iobase2;	/* secondary io address used for analog out on 'ao' boards */
+	short ao_update_bits;	/* remembers the last write to the 'update' dac */
+} das1800_private;
+
+#define devpriv ((das1800_private *)dev->private)
+
+// analog out range for boards with basic analog out
+static const comedi_lrange range_ao_1 = {
+	1,
+	{
+			RANGE(-10, 10),
+		}
+};
+
+// analog out range for 'ao' boards
+/*
+static const comedi_lrange range_ao_2 = {
+	2,
+	{
+		RANGE(-10, 10),
+		RANGE(-5, 5),
+	}
+};
+*/
+
+static comedi_driver driver_das1800 = {
+      driver_name:"das1800",
+      module:THIS_MODULE,
+      attach:das1800_attach,
+      detach:das1800_detach,
+      num_names:sizeof(das1800_boards) / sizeof(das1800_board),
+      board_name:&das1800_boards[0].name,
+      offset:sizeof(das1800_board),
+};
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_INITCLEANUP(driver_das1800);
+
+static int das1800_init_dma(comedi_device * dev, unsigned int dma0,
+	unsigned int dma1)
+{
+	unsigned long flags;
+
+	// need an irq to do dma
+	if (dev->irq && dma0) {
+		//encode dma0 and dma1 into 2 digit hexadecimal for switch
+		switch ((dma0 & 0x7) | (dma1 << 4)) {
+		case 0x5:	// dma0 == 5
+			devpriv->dma_bits |= DMA_CH5;
+			break;
+		case 0x6:	// dma0 == 6
+			devpriv->dma_bits |= DMA_CH6;
+			break;
+		case 0x7:	// dma0 == 7
+			devpriv->dma_bits |= DMA_CH7;
+			break;
+		case 0x65:	// dma0 == 5, dma1 == 6
+			devpriv->dma_bits |= DMA_CH5_CH6;
+			break;
+		case 0x76:	// dma0 == 6, dma1 == 7
+			devpriv->dma_bits |= DMA_CH6_CH7;
+			break;
+		case 0x57:	// dma0 == 7, dma1 == 5
+			devpriv->dma_bits |= DMA_CH7_CH5;
+			break;
+		default:
+			printk(" only supports dma channels 5 through 7\n"
+				" Dual dma only allows the following combinations:\n"
+				" dma 5,6 / 6,7 / or 7,5\n");
+			return -EINVAL;
+			break;
+		}
+		if (request_dma(dma0, driver_das1800.driver_name)) {
+			printk(" failed to allocate dma channel %i\n", dma0);
+			return -EINVAL;
+		}
+		devpriv->dma0 = dma0;
+		devpriv->dma_current = dma0;
+		if (dma1) {
+			if (request_dma(dma1, driver_das1800.driver_name)) {
+				printk(" failed to allocate dma channel %i\n",
+					dma1);
+				return -EINVAL;
+			}
+			devpriv->dma1 = dma1;
+		}
+		devpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+		if (devpriv->ai_buf0 == NULL)
+			return -ENOMEM;
+		devpriv->dma_current_buf = devpriv->ai_buf0;
+		if (dma1) {
+			devpriv->ai_buf1 =
+				kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);
+			if (devpriv->ai_buf1 == NULL)
+				return -ENOMEM;
+		}
+		flags = claim_dma_lock();
+		disable_dma(devpriv->dma0);
+		set_dma_mode(devpriv->dma0, DMA_MODE_READ);
+		if (dma1) {
+			disable_dma(devpriv->dma1);
+			set_dma_mode(devpriv->dma1, DMA_MODE_READ);
+		}
+		release_dma_lock(flags);
+	}
+	return 0;
+}
+
+static int das1800_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned long iobase = it->options[0];
+	unsigned int irq = it->options[1];
+	unsigned int dma0 = it->options[2];
+	unsigned int dma1 = it->options[3];
+	unsigned long iobase2;
+	int board;
+	int retval;
+
+	/* allocate and initialize dev->private */
+	if (alloc_private(dev, sizeof(das1800_private)) < 0)
+		return -ENOMEM;
+
+	printk("comedi%d: %s: io 0x%lx", dev->minor, driver_das1800.driver_name,
+		iobase);
+	if (irq) {
+		printk(", irq %u", irq);
+		if (dma0) {
+			printk(", dma %u", dma0);
+			if (dma1)
+				printk(" and %u", dma1);
+		}
+	}
+	printk("\n");
+
+	if (iobase == 0) {
+		printk(" io base address required\n");
+		return -EINVAL;
+	}
+
+	/* check if io addresses are available */
+	if (!request_region(iobase, DAS1800_SIZE, driver_das1800.driver_name)) {
+		printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase, iobase + DAS1800_SIZE - 1);
+		return -EIO;
+	}
+	dev->iobase = iobase;
+
+	board = das1800_probe(dev);
+	if (board < 0) {
+		printk(" unable to determine board type\n");
+		return -ENODEV;
+	}
+
+	dev->board_ptr = das1800_boards + board;
+	dev->board_name = thisboard->name;
+
+	// if it is an 'ao' board with fancy analog out then we need extra io ports
+	if (thisboard->ao_ability == 2) {
+		iobase2 = iobase + IOBASE2;
+		if (!request_region(iobase2, DAS1800_SIZE,
+				driver_das1800.driver_name)) {
+			printk(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n", iobase2, iobase2 + DAS1800_SIZE - 1);
+			return -EIO;
+		}
+		devpriv->iobase2 = iobase2;
+	}
+
+	/* grab our IRQ */
+	if (irq) {
+		if (comedi_request_irq(irq, das1800_interrupt, 0,
+				driver_das1800.driver_name, dev)) {
+			printk(" unable to allocate irq %u\n", irq);
+			return -EINVAL;
+		}
+	}
+	dev->irq = irq;
+
+	// set bits that tell card which irq to use
+	switch (irq) {
+	case 0:
+		break;
+	case 3:
+		devpriv->irq_dma_bits |= 0x8;
+		break;
+	case 5:
+		devpriv->irq_dma_bits |= 0x10;
+		break;
+	case 7:
+		devpriv->irq_dma_bits |= 0x18;
+		break;
+	case 10:
+		devpriv->irq_dma_bits |= 0x28;
+		break;
+	case 11:
+		devpriv->irq_dma_bits |= 0x30;
+		break;
+	case 15:
+		devpriv->irq_dma_bits |= 0x38;
+		break;
+	default:
+		printk(" irq out of range\n");
+		return -EINVAL;
+		break;
+	}
+
+	retval = das1800_init_dma(dev, dma0, dma1);
+	if (retval < 0)
+		return retval;
+
+	if (devpriv->ai_buf0 == NULL) {
+		devpriv->ai_buf0 =
+			kmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);
+		if (devpriv->ai_buf0 == NULL)
+			return -ENOMEM;
+	}
+
+	if (alloc_subdevices(dev, 4) < 0)
+		return -ENOMEM;
+
+	/* analog input subdevice */
+	s = dev->subdevices + 0;
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;
+	if (thisboard->common)
+		s->subdev_flags |= SDF_COMMON;
+	s->n_chan = thisboard->qram_len;
+	s->len_chanlist = thisboard->qram_len;
+	s->maxdata = (1 << thisboard->resolution) - 1;
+	s->range_table = thisboard->range_ai;
+	s->do_cmd = das1800_ai_do_cmd;
+	s->do_cmdtest = das1800_ai_do_cmdtest;
+	s->insn_read = das1800_ai_rinsn;
+	s->poll = das1800_ai_poll;
+	s->cancel = das1800_cancel;
+
+	/* analog out */
+	s = dev->subdevices + 1;
+	if (thisboard->ao_ability == 1) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_WRITABLE;
+		s->n_chan = thisboard->ao_n_chan;
+		s->maxdata = (1 << thisboard->resolution) - 1;
+		s->range_table = &range_ao_1;
+		s->insn_write = das1800_ao_winsn;
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* di */
+	s = dev->subdevices + 2;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE;
+	s->n_chan = 4;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das1800_di_rbits;
+
+	/* do */
+	s = dev->subdevices + 3;
+	s->type = COMEDI_SUBD_DO;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = thisboard->do_n_chan;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+	s->insn_bits = das1800_do_wbits;
+
+	das1800_cancel(dev, dev->read_subdev);
+
+	// initialize digital out channels
+	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+
+	// initialize analog out channels
+	if (thisboard->ao_ability == 1) {
+		// select 'update' dac channel for baseAddress + 0x0
+		outb(DAC(thisboard->ao_n_chan - 1),
+			dev->iobase + DAS1800_SELECT);
+		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
+	}
+
+	return 0;
+};
+
+static int das1800_detach(comedi_device * dev)
+{
+	/* only free stuff if it has been allocated by _attach */
+	if (dev->iobase)
+		release_region(dev->iobase, DAS1800_SIZE);
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (dev->private) {
+		if (devpriv->iobase2)
+			release_region(devpriv->iobase2, DAS1800_SIZE);
+		if (devpriv->dma0)
+			free_dma(devpriv->dma0);
+		if (devpriv->dma1)
+			free_dma(devpriv->dma1);
+		if (devpriv->ai_buf0)
+			kfree(devpriv->ai_buf0);
+		if (devpriv->ai_buf1)
+			kfree(devpriv->ai_buf1);
+	}
+
+	printk("comedi%d: %s: remove\n", dev->minor,
+		driver_das1800.driver_name);
+
+	return 0;
+};
+
+/* probes and checks das-1800 series board type
+ */
+static int das1800_probe(comedi_device * dev)
+{
+	int id;
+	int board;
+
+	id = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;	/* get id bits */
+	board = ((das1800_board *) dev->board_ptr) - das1800_boards;
+
+	switch (id) {
+	case 0x3:
+		if (board == das1801st_da || board == das1802st_da ||
+			board == das1701st_da || board == das1702st_da) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1800st-da series\n");
+		return das1801st;
+		break;
+	case 0x4:
+		if (board == das1802hr_da || board == das1702hr_da) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1802hr-da\n");
+		return das1802hr;
+		break;
+	case 0x5:
+		if (board == das1801ao || board == das1802ao ||
+			board == das1701ao || board == das1702ao) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1800ao series\n");
+		return das1801ao;
+		break;
+	case 0x6:
+		if (board == das1802hr || board == das1702hr) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1802hr\n");
+		return das1802hr;
+		break;
+	case 0x7:
+		if (board == das1801st || board == das1802st ||
+			board == das1701st || board == das1702st) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1800st series\n");
+		return das1801st;
+		break;
+	case 0x8:
+		if (board == das1801hc || board == das1802hc) {
+			printk(" Board model: %s\n",
+				das1800_boards[board].name);
+			return board;
+		}
+		printk(" Board model (probed, not recommended): das-1800hc series\n");
+		return das1801hc;
+		break;
+	default:
+		printk(" Board model: probe returned 0x%x (unknown, please report)\n", id);
+		return board;
+		break;
+	}
+	return -1;
+}
+
+static int das1800_ai_poll(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	// prevent race with interrupt handler
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	das1800_ai_handler(dev);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return s->async->buf_write_count - s->async->buf_read_count;
+}
+
+static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	unsigned int status;
+
+	if (dev->attached == 0) {
+		comedi_error(dev, "premature interrupt");
+		return IRQ_HANDLED;
+	}
+
+	/* Prevent race with das1800_ai_poll() on multi processor systems.
+	 * Also protects indirect addressing in das1800_ai_handler */
+	spin_lock(&dev->spinlock);
+	status = inb(dev->iobase + DAS1800_STATUS);
+
+	/* if interrupt was not caused by das-1800 */
+	if (!(status & INT)) {
+		spin_unlock(&dev->spinlock);
+		return IRQ_NONE;
+	}
+	/* clear the interrupt status bit INT */
+	outb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);
+	// handle interrupt
+	das1800_ai_handler(dev);
+
+	spin_unlock(&dev->spinlock);
+	return IRQ_HANDLED;
+}
+
+// the guts of the interrupt handler, that is shared with das1800_ai_poll
+static void das1800_ai_handler(comedi_device * dev)
+{
+	comedi_subdevice *s = dev->subdevices + 0;	/* analog input subdevice */
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int status = inb(dev->iobase + DAS1800_STATUS);
+
+	async->events = 0;
+	// select adc for base address + 0
+	outb(ADC, dev->iobase + DAS1800_SELECT);
+	// dma buffer full
+	if (devpriv->irq_dma_bits & DMA_ENABLED) {
+		// look for data from dma transfer even if dma terminal count hasn't happened yet
+		das1800_handle_dma(dev, s, status);
+	} else if (status & FHF) {	// if fifo half full
+		das1800_handle_fifo_half_full(dev, s);
+	} else if (status & FNE) {	// if fifo not empty
+		das1800_handle_fifo_not_empty(dev, s);
+	}
+
+	async->events |= COMEDI_CB_BLOCK;
+	/* if the card's fifo has overflowed */
+	if (status & OVF) {
+		// clear OVF interrupt bit
+		outb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);
+		comedi_error(dev, "DAS1800 FIFO overflow");
+		das1800_cancel(dev, s);
+		async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;
+		comedi_event(dev, s);
+		return;
+	}
+	// stop taking data if appropriate
+	/* stop_src TRIG_EXT */
+	if (status & CT0TC) {
+		// clear CT0TC interrupt bit
+		outb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);
+		// make sure we get all remaining data from board before quitting
+		if (devpriv->irq_dma_bits & DMA_ENABLED)
+			das1800_flush_dma(dev, s);
+		else
+			das1800_handle_fifo_not_empty(dev, s);
+		das1800_cancel(dev, s);	/* disable hardware conversions */
+		async->events |= COMEDI_CB_EOA;
+	} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {	// stop_src TRIG_COUNT
+		das1800_cancel(dev, s);	/* disable hardware conversions */
+		async->events |= COMEDI_CB_EOA;
+	}
+
+	comedi_event(dev, s);
+
+	return;
+}
+
+static void das1800_handle_dma(comedi_device * dev, comedi_subdevice * s,
+	unsigned int status)
+{
+	unsigned long flags;
+	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
+
+	flags = claim_dma_lock();
+	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+		devpriv->dma_current_buf);
+	// re-enable  dma channel
+	set_dma_addr(devpriv->dma_current,
+		virt_to_bus(devpriv->dma_current_buf));
+	set_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);
+	enable_dma(devpriv->dma_current);
+	release_dma_lock(flags);
+
+	if (status & DMATC) {
+		// clear DMATC interrupt bit
+		outb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);
+		// switch dma channels for next time, if appropriate
+		if (dual_dma) {
+			// read data from the other channel next time
+			if (devpriv->dma_current == devpriv->dma0) {
+				devpriv->dma_current = devpriv->dma1;
+				devpriv->dma_current_buf = devpriv->ai_buf1;
+			} else {
+				devpriv->dma_current = devpriv->dma0;
+				devpriv->dma_current_buf = devpriv->ai_buf0;
+			}
+		}
+	}
+
+	return;
+}
+
+static inline uint16_t munge_bipolar_sample(const comedi_device * dev,
+	uint16_t sample)
+{
+	sample += 1 << (thisboard->resolution - 1);
+	return sample;
+}
+
+static void munge_data(comedi_device * dev, uint16_t * array,
+	unsigned int num_elements)
+{
+	unsigned int i;
+	int unipolar;
+
+	/* see if card is using a unipolar or bipolar range so we can munge data correctly */
+	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
+
+	/* convert to unsigned type if we are in a bipolar mode */
+	if (!unipolar) {
+		for (i = 0; i < num_elements; i++) {
+			array[i] = munge_bipolar_sample(dev, array[i]);
+		}
+	}
+}
+
+/* Utility function used by das1800_flush_dma() and das1800_handle_dma().
+ * Assumes dma lock is held */
+static void das1800_flush_dma_channel(comedi_device * dev, comedi_subdevice * s,
+	unsigned int channel, uint16_t * buffer)
+{
+	unsigned int num_bytes, num_samples;
+	comedi_cmd *cmd = &s->async->cmd;
+
+	disable_dma(channel);
+
+	/* clear flip-flop to make sure 2-byte registers
+	 * get set correctly */
+	clear_dma_ff(channel);
+
+	// figure out how many points to read
+	num_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);
+	num_samples = num_bytes / sizeof(sampl_t);
+
+	/* if we only need some of the points */
+	if (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)
+		num_samples = devpriv->count;
+
+	munge_data(dev, buffer, num_samples);
+	cfc_write_array_to_buffer(s, buffer, num_bytes);
+	if (s->async->cmd.stop_src == TRIG_COUNT)
+		devpriv->count -= num_samples;
+
+	return;
+}
+
+/* flushes remaining data from board when external trigger has stopped aquisition
+ * and we are using dma transfers */
+static void das1800_flush_dma(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
+
+	flags = claim_dma_lock();
+	das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+		devpriv->dma_current_buf);
+
+	if (dual_dma) {
+		// switch to other channel and flush it
+		if (devpriv->dma_current == devpriv->dma0) {
+			devpriv->dma_current = devpriv->dma1;
+			devpriv->dma_current_buf = devpriv->ai_buf1;
+		} else {
+			devpriv->dma_current = devpriv->dma0;
+			devpriv->dma_current_buf = devpriv->ai_buf0;
+		}
+		das1800_flush_dma_channel(dev, s, devpriv->dma_current,
+			devpriv->dma_current_buf);
+	}
+
+	release_dma_lock(flags);
+
+	// get any remaining samples in fifo
+	das1800_handle_fifo_not_empty(dev, s);
+
+	return;
+}
+
+static void das1800_handle_fifo_half_full(comedi_device * dev,
+	comedi_subdevice * s)
+{
+	int numPoints = 0;	/* number of points to read */
+	comedi_cmd *cmd = &s->async->cmd;
+
+	numPoints = FIFO_SIZE / 2;
+	/* if we only need some of the points */
+	if (cmd->stop_src == TRIG_COUNT && devpriv->count < numPoints)
+		numPoints = devpriv->count;
+	insw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);
+	munge_data(dev, devpriv->ai_buf0, numPoints);
+	cfc_write_array_to_buffer(s, devpriv->ai_buf0,
+		numPoints * sizeof(devpriv->ai_buf0[0]));
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->count -= numPoints;
+	return;
+}
+
+static void das1800_handle_fifo_not_empty(comedi_device * dev,
+	comedi_subdevice * s)
+{
+	sampl_t dpnt;
+	int unipolar;
+	comedi_cmd *cmd = &s->async->cmd;
+
+	unipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;
+
+	while (inb(dev->iobase + DAS1800_STATUS) & FNE) {
+		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
+			break;
+		dpnt = inw(dev->iobase + DAS1800_FIFO);
+		/* convert to unsigned type if we are in a bipolar mode */
+		if (!unipolar) ;
+		dpnt = munge_bipolar_sample(dev, dpnt);
+		cfc_write_to_buffer(s, dpnt);
+		if (cmd->stop_src == TRIG_COUNT)
+			devpriv->count--;
+	}
+
+	return;
+}
+
+static int das1800_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	outb(0x0, dev->iobase + DAS1800_STATUS);	/* disable conversions */
+	outb(0x0, dev->iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */
+	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */
+	if (devpriv->dma0)
+		disable_dma(devpriv->dma0);
+	if (devpriv->dma1)
+		disable_dma(devpriv->dma1);
+	return 0;
+}
+
+/* test analog input cmd */
+static int das1800_ai_do_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	unsigned int tmp_arg;
+	int i;
+	int unipolar;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	// uniqueness check
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT &&
+		cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)
+		err++;
+	//compatibility check
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->convert_src != TRIG_TIMER)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+	if (!cmd->chanlist_len) {
+		cmd->chanlist_len = 1;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		if (!cmd->stop_arg) {
+			cmd->stop_arg = 1;
+			err++;
+		}
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->convert_src == TRIG_TIMER) {
+		// if we are not in burst mode
+		if (cmd->scan_begin_src == TRIG_FOLLOW) {
+			tmp_arg = cmd->convert_arg;
+			/* calculate counter values that give desired timing */
+			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+				&(devpriv->divisor1), &(devpriv->divisor2),
+				&(cmd->convert_arg),
+				cmd->flags & TRIG_ROUND_MASK);
+			if (tmp_arg != cmd->convert_arg)
+				err++;
+		}
+		// if we are in burst mode
+		else {
+			// check that convert_arg is compatible
+			tmp_arg = cmd->convert_arg;
+			cmd->convert_arg =
+				burst_convert_arg(cmd->convert_arg,
+				cmd->flags & TRIG_ROUND_MASK);
+			if (tmp_arg != cmd->convert_arg)
+				err++;
+
+			if (cmd->scan_begin_src == TRIG_TIMER) {
+				// if scans are timed faster than conversion rate allows
+				if (cmd->convert_arg * cmd->chanlist_len >
+					cmd->scan_begin_arg) {
+					cmd->scan_begin_arg =
+						cmd->convert_arg *
+						cmd->chanlist_len;
+					err++;
+				}
+				tmp_arg = cmd->scan_begin_arg;
+				/* calculate counter values that give desired timing */
+				i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+					&(devpriv->divisor1),
+					&(devpriv->divisor2),
+					&(cmd->scan_begin_arg),
+					cmd->flags & TRIG_ROUND_MASK);
+				if (tmp_arg != cmd->scan_begin_arg)
+					err++;
+			}
+		}
+	}
+
+	if (err)
+		return 4;
+
+	// make sure user is not trying to mix unipolar and bipolar ranges
+	if (cmd->chanlist) {
+		unipolar = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (unipolar != (CR_RANGE(cmd->chanlist[i]) & UNIPOLAR)) {
+				comedi_error(dev,
+					"unipolar and bipolar ranges cannot be mixed in the chanlist");
+				err++;
+				break;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+/* analog input cmd interface */
+
+// first, some utility functions used in the main ai_do_cmd()
+
+// returns appropriate bits for control register a, depending on command
+static int control_a_bits(comedi_cmd cmd)
+{
+	int control_a;
+
+	control_a = FFEN;	//enable fifo
+	if (cmd.stop_src == TRIG_EXT) {
+		control_a |= ATEN;
+	}
+	switch (cmd.start_src) {
+	case TRIG_EXT:
+		control_a |= TGEN | CGSL;
+		break;
+	case TRIG_NOW:
+		control_a |= CGEN;
+		break;
+	default:
+		break;
+	}
+
+	return control_a;
+}
+
+// returns appropriate bits for control register c, depending on command
+static int control_c_bits(comedi_cmd cmd)
+{
+	int control_c;
+	int aref;
+
+	/* set clock source to internal or external, select analog reference,
+	 * select unipolar / bipolar
+	 */
+	aref = CR_AREF(cmd.chanlist[0]);
+	control_c = UQEN;	//enable upper qram addresses
+	if (aref != AREF_DIFF)
+		control_c |= SD;
+	if (aref == AREF_COMMON)
+		control_c |= CMEN;
+	/* if a unipolar range was selected */
+	if (CR_RANGE(cmd.chanlist[0]) & UNIPOLAR)
+		control_c |= UB;
+	switch (cmd.scan_begin_src) {
+	case TRIG_FOLLOW:	// not in burst mode
+		switch (cmd.convert_src) {
+		case TRIG_TIMER:
+			/* trig on cascaded counters */
+			control_c |= IPCLK;
+			break;
+		case TRIG_EXT:
+			/* trig on falling edge of external trigger */
+			control_c |= XPCLK;
+			break;
+		default:
+			break;
+		}
+		break;
+	case TRIG_TIMER:
+		// burst mode with internal pacer clock
+		control_c |= BMDE | IPCLK;
+		break;
+	case TRIG_EXT:
+		// burst mode with external trigger
+		control_c |= BMDE | XPCLK;
+		break;
+	default:
+		break;
+	}
+
+	return control_c;
+}
+
+// sets up counters
+static int setup_counters(comedi_device * dev, comedi_cmd cmd)
+{
+	// setup cascaded counters for conversion/scan frequency
+	switch (cmd.scan_begin_src) {
+	case TRIG_FOLLOW:	// not in burst mode
+		if (cmd.convert_src == TRIG_TIMER) {
+			/* set conversion frequency */
+			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+				&(devpriv->divisor1), &(devpriv->divisor2),
+				&(cmd.convert_arg),
+				cmd.flags & TRIG_ROUND_MASK);
+			if (das1800_set_frequency(dev) < 0) {
+				return -1;
+			}
+		}
+		break;
+	case TRIG_TIMER:	// in burst mode
+		/* set scan frequency */
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
+			&(devpriv->divisor2), &(cmd.scan_begin_arg),
+			cmd.flags & TRIG_ROUND_MASK);
+		if (das1800_set_frequency(dev) < 0) {
+			return -1;
+		}
+		break;
+	default:
+		break;
+	}
+
+	// setup counter 0 for 'about triggering'
+	if (cmd.stop_src == TRIG_EXT) {
+		// load counter 0 in mode 0
+		i8254_load(dev->iobase + DAS1800_COUNTER, 0, 0, 1, 0);
+	}
+
+	return 0;
+}
+
+// sets up dma
+static void setup_dma(comedi_device * dev, comedi_cmd cmd)
+{
+	unsigned long lock_flags;
+	const int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;
+
+	if ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)
+		return;
+
+	/* determine a reasonable dma transfer size */
+	devpriv->dma_transfer_size = suggest_transfer_size(&cmd);
+	lock_flags = claim_dma_lock();
+	disable_dma(devpriv->dma0);
+	/* clear flip-flop to make sure 2-byte registers for
+	 * count and address get set correctly */
+	clear_dma_ff(devpriv->dma0);
+	set_dma_addr(devpriv->dma0, virt_to_bus(devpriv->ai_buf0));
+	// set appropriate size of transfer
+	set_dma_count(devpriv->dma0, devpriv->dma_transfer_size);
+	devpriv->dma_current = devpriv->dma0;
+	devpriv->dma_current_buf = devpriv->ai_buf0;
+	enable_dma(devpriv->dma0);
+	// set up dual dma if appropriate
+	if (dual_dma) {
+		disable_dma(devpriv->dma1);
+		/* clear flip-flop to make sure 2-byte registers for
+		 * count and address get set correctly */
+		clear_dma_ff(devpriv->dma1);
+		set_dma_addr(devpriv->dma1, virt_to_bus(devpriv->ai_buf1));
+		// set appropriate size of transfer
+		set_dma_count(devpriv->dma1, devpriv->dma_transfer_size);
+		enable_dma(devpriv->dma1);
+	}
+	release_dma_lock(lock_flags);
+
+	return;
+}
+
+// programs channel/gain list into card
+static void program_chanlist(comedi_device * dev, comedi_cmd cmd)
+{
+	int i, n, chan_range;
+	unsigned long irq_flags;
+	const int range_mask = 0x3;	//masks unipolar/bipolar bit off range
+	const int range_bitshift = 8;
+
+	n = cmd.chanlist_len;
+	// spinlock protects indirect addressing
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
+	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
+	/* make channel / gain list */
+	for (i = 0; i < n; i++) {
+		chan_range =
+			CR_CHAN(cmd.chanlist[i]) | ((CR_RANGE(cmd.
+					chanlist[i]) & range_mask) <<
+			range_bitshift);
+		outw(chan_range, dev->iobase + DAS1800_QRAM);
+	}
+	outb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	return;
+}
+
+// analog input do_cmd
+static int das1800_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	int ret;
+	int control_a, control_c;
+	comedi_async *async = s->async;
+	comedi_cmd cmd = async->cmd;
+
+	if (!dev->irq) {
+		comedi_error(dev,
+			"no irq assigned for das-1800, cannot do hardware conversions");
+		return -1;
+	}
+
+	/* disable dma on TRIG_WAKE_EOS, or TRIG_RT
+	 * (because dma in handler is unsafe at hard real-time priority) */
+	if (cmd.flags & (TRIG_WAKE_EOS | TRIG_RT)) {
+		devpriv->irq_dma_bits &= ~DMA_ENABLED;
+	} else {
+		devpriv->irq_dma_bits |= devpriv->dma_bits;
+	}
+	// interrupt on end of conversion for TRIG_WAKE_EOS
+	if (cmd.flags & TRIG_WAKE_EOS) {
+		// interrupt fifo not empty
+		devpriv->irq_dma_bits &= ~FIMD;
+	} else {
+		// interrupt fifo half full
+		devpriv->irq_dma_bits |= FIMD;
+	}
+	// determine how many conversions we need
+	if (cmd.stop_src == TRIG_COUNT) {
+		devpriv->count = cmd.stop_arg * cmd.chanlist_len;
+	}
+
+	das1800_cancel(dev, s);
+
+	// determine proper bits for control registers
+	control_a = control_a_bits(cmd);
+	control_c = control_c_bits(cmd);
+
+	/* setup card and start */
+	program_chanlist(dev, cmd);
+	ret = setup_counters(dev, cmd);
+	if (ret < 0) {
+		comedi_error(dev, "Error setting up counters");
+		return ret;
+	}
+	setup_dma(dev, cmd);
+	outb(control_c, dev->iobase + DAS1800_CONTROL_C);
+	// set conversion rate and length for burst mode
+	if (control_c & BMDE) {
+		// program conversion period with number of microseconds minus 1
+		outb(cmd.convert_arg / 1000 - 1,
+			dev->iobase + DAS1800_BURST_RATE);
+		outb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);
+	}
+	outb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);	// enable irq/dma
+	outb(control_a, dev->iobase + DAS1800_CONTROL_A);	/* enable fifo and triggering */
+	outb(CVEN, dev->iobase + DAS1800_STATUS);	/* enable conversions */
+
+	return 0;
+}
+
+/* read analog input */
+static int das1800_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i, n;
+	int chan, range, aref, chan_range;
+	int timeout = 1000;
+	short dpnt;
+	int conv_flags = 0;
+	unsigned long irq_flags;
+
+	/* set up analog reference and unipolar / bipolar mode */
+	aref = CR_AREF(insn->chanspec);
+	conv_flags |= UQEN;
+	if (aref != AREF_DIFF)
+		conv_flags |= SD;
+	if (aref == AREF_COMMON)
+		conv_flags |= CMEN;
+	/* if a unipolar range was selected */
+	if (CR_RANGE(insn->chanspec) & UNIPOLAR)
+		conv_flags |= UB;
+
+	outb(conv_flags, dev->iobase + DAS1800_CONTROL_C);	/* software conversion enabled */
+	outb(CVEN, dev->iobase + DAS1800_STATUS);	/* enable conversions */
+	outb(0x0, dev->iobase + DAS1800_CONTROL_A);	/* reset fifo */
+	outb(FFEN, dev->iobase + DAS1800_CONTROL_A);
+
+	chan = CR_CHAN(insn->chanspec);
+	/* mask of unipolar/bipolar bit from range */
+	range = CR_RANGE(insn->chanspec) & 0x3;
+	chan_range = chan | (range << 8);
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(QRAM, dev->iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
+	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/* set QRAM address start */
+	outw(chan_range, dev->iobase + DAS1800_QRAM);
+	outb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);	/*finish write to QRAM */
+	outb(ADC, dev->iobase + DAS1800_SELECT);	/* select ADC for baseAddress + 0x0 */
+
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		outb(0, dev->iobase + DAS1800_FIFO);
+		for (i = 0; i < timeout; i++) {
+			if (inb(dev->iobase + DAS1800_STATUS) & FNE)
+				break;
+		}
+		if (i == timeout) {
+			comedi_error(dev, "timeout");
+			return -ETIME;
+		}
+		dpnt = inw(dev->iobase + DAS1800_FIFO);
+		/* shift data to offset binary for bipolar ranges */
+		if ((conv_flags & UB) == 0)
+			dpnt += 1 << (thisboard->resolution - 1);
+		data[n] = dpnt;
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	return n;
+}
+
+/* writes to an analog output channel */
+static int das1800_ao_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int chan = CR_CHAN(insn->chanspec);
+//      int range = CR_RANGE(insn->chanspec);
+	int update_chan = thisboard->ao_n_chan - 1;
+	short output;
+	unsigned long irq_flags;
+
+	//  card expects two's complement data
+	output = data[0] - (1 << (thisboard->resolution - 1));
+	// if the write is to the 'update' channel, we need to remember its value
+	if (chan == update_chan)
+		devpriv->ao_update_bits = output;
+	// write to channel
+	comedi_spin_lock_irqsave(&dev->spinlock, irq_flags);
+	outb(DAC(chan), dev->iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
+	outw(output, dev->iobase + DAS1800_DAC);
+	// now we need to write to 'update' channel to update all dac channels
+	if (chan != update_chan) {
+		outb(DAC(update_chan), dev->iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
+		outw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, irq_flags);
+
+	return 1;
+}
+
+/* reads from digital input channels */
+static int das1800_di_rbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+
+	data[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;
+	data[0] = 0;
+
+	return 2;
+}
+
+/* writes to digital output channels */
+static int das1800_do_wbits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	lsampl_t wbits;
+
+	// only set bits that have been masked
+	data[0] &= (1 << s->n_chan) - 1;
+	wbits = devpriv->do_bits;
+	wbits &= ~data[0];
+	wbits |= data[0] & data[1];
+	devpriv->do_bits = wbits;
+
+	outb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);
+
+	data[1] = devpriv->do_bits;
+
+	return 2;
+}
+
+/* loads counters with divisor1, divisor2 from private structure */
+static int das1800_set_frequency(comedi_device * dev)
+{
+	int err = 0;
+
+	// counter 1, mode 2
+	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,
+			2))
+		err++;
+	// counter 2, mode 2
+	if (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,
+			2))
+		err++;
+	if (err)
+		return -1;
+
+	return 0;
+}
+
+/* converts requested conversion timing to timing compatible with
+ * hardware, used only when card is in 'burst mode'
+ */
+static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
+{
+	unsigned int micro_sec;
+
+	// in burst mode, the maximum conversion time is 64 microseconds
+	if (convert_arg > 64000)
+		convert_arg = 64000;
+
+	// the conversion time must be an integral number of microseconds
+	switch (round_mode) {
+	case TRIG_ROUND_NEAREST:
+	default:
+		micro_sec = (convert_arg + 500) / 1000;
+		break;
+	case TRIG_ROUND_DOWN:
+		micro_sec = convert_arg / 1000;
+		break;
+	case TRIG_ROUND_UP:
+		micro_sec = (convert_arg - 1) / 1000 + 1;
+		break;
+	}
+
+	// return number of nanoseconds
+	return micro_sec * 1000;
+}
+
+// utility function that suggests a dma transfer size based on the conversion period 'ns'
+static unsigned int suggest_transfer_size(comedi_cmd * cmd)
+{
+	unsigned int size = DMA_BUF_SIZE;
+	static const int sample_size = 2;	// size in bytes of one sample from board
+	unsigned int fill_time = 300000000;	// target time in nanoseconds for filling dma buffer
+	unsigned int max_size;	// maximum size we will allow for a transfer
+
+	// make dma buffer fill in 0.3 seconds for timed modes
+	switch (cmd->scan_begin_src) {
+	case TRIG_FOLLOW:	// not in burst mode
+		if (cmd->convert_src == TRIG_TIMER)
+			size = (fill_time / cmd->convert_arg) * sample_size;
+		break;
+	case TRIG_TIMER:
+		size = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *
+			sample_size;
+		break;
+	default:
+		size = DMA_BUF_SIZE;
+		break;
+	}
+
+	// set a minimum and maximum size allowed
+	max_size = DMA_BUF_SIZE;
+	// if we are taking limited number of conversions, limit transfer size to that
+	if (cmd->stop_src == TRIG_COUNT &&
+		cmd->stop_arg * cmd->chanlist_len * sample_size < max_size)
+		max_size = cmd->stop_arg * cmd->chanlist_len * sample_size;
+
+	if (size > max_size)
+		size = max_size;
+	if (size < sample_size)
+		size = sample_size;
+
+	return size;
+}
