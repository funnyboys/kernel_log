commit 347e244884c3be1f5bce1d93730f0c32efabba99
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Wed Oct 3 14:56:08 2018 -0600

    staging: comedi: tio: implement global tio/ctr routing
    
    Adds ability to use device-global names in command args, in particular
    cmd->start_arg (for NI_CtrArmStartTrigger), and cmd->scan_begin_arg or
    cmd->convert_arg (either is used to specify NI_CtrGate, with preference
    given to cmd->scan_begin_arg, if it is set).
    
    The actual arguments of cmd->start_arg are not fully checked against known
    register values for the particular devices because these are not documented
    or currently known.  This follows the precedence of prior versions of the
    tio driver.  Should these become known, they should be annotated in the
    route_values tables and the set of lines in ni_tio_cmdtest should be
    uncommented to allow the tests to be made.
    
    This patch also adds interface functions that allow routes for particular
    counter route destinations to be made/queried/unmade.  This allows overseer
    modules to implement test_route, connect_route, and disconnect_route.  As a
    part of these changes, various functions were cleaned up and clarified.
    
    These new interface functions allow direct writing/reading of register
    values.  This is an example of exactly what the new device-global access
    was intended to solve:  the old interface was not consistent with other
    portions of the ni_* drivers--it did not allow full register values to be
    given for various MUXes.  Instead, the old interface _did_ abstract away
    some of the actual hardware from the underlying devices, but it was not
    consistent with any other NI hardware.  Allowing the device-global
    identifiers to be used, the new patch provides for consistency across all
    ni_* drivers.  One final note:  these changes provide for backwards
    compatibility by allowing the older values to still be used in through the
    pre-existing kernel interfaces--though not in the new device-global
    test/dis/connect/route interfaces.
    
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 050bee0b9515..2a9f7e9821a7 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -33,6 +33,7 @@
 #include <linux/module.h>
 #include "ni_tio_internal.h"
 #include "mite.h"
+#include "ni_routes.h"
 
 static void ni_tio_configure_dma(struct ni_gpct *counter,
 				 bool enable, bool read)
@@ -100,6 +101,8 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 {
 	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	const struct ni_route_tables *routing_tables =
+		counter_dev->routing_tables;
 	unsigned int cidx = counter->counter_index;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -128,8 +131,19 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 
 		if (cmd->start_src == TRIG_NOW)
 			ret = ni_tio_arm(counter, true, NI_GPCT_ARM_IMMEDIATE);
-		else if (cmd->start_src == TRIG_EXT)
-			ret = ni_tio_arm(counter, true, cmd->start_arg);
+		else if (cmd->start_src == TRIG_EXT) {
+			int reg = CR_CHAN(cmd->start_arg);
+
+			if (reg >= NI_NAMES_BASE) {
+				/* using a device-global name. lookup reg */
+				reg = ni_get_reg_value(reg,
+						       NI_CtrArmStartTrigger(cidx),
+						       routing_tables);
+				/* mark this as a raw register value */
+				reg |= NI_GPCT_HW_ARM;
+			}
+			ret = ni_tio_arm(counter, true, reg);
+		}
 	}
 	return ret;
 }
@@ -148,6 +162,8 @@ static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct ni_gpct *counter = s->private;
 	unsigned int cidx = counter->counter_index;
+	const struct ni_route_tables *routing_tables =
+		counter->counter_dev->routing_tables;
 	int set_gate_source = 0;
 	unsigned int gate_source;
 	int retval = 0;
@@ -159,8 +175,24 @@ static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 		set_gate_source = 1;
 		gate_source = cmd->convert_arg;
 	}
-	if (set_gate_source)
-		retval = ni_tio_set_gate_src(counter, 0, gate_source);
+	if (set_gate_source) {
+		if (CR_CHAN(gate_source) >= NI_NAMES_BASE) {
+			/* Lookup and use the real register values */
+			int reg = ni_get_reg_value(CR_CHAN(gate_source),
+						   NI_CtrGate(cidx),
+						   routing_tables);
+			if (reg < 0)
+				return -EINVAL;
+			retval = ni_tio_set_gate_src_raw(counter, 0, reg);
+		} else {
+			/*
+			 * This function must be used separately since it does
+			 * not expect real register values and attempts to
+			 * convert these to real register values.
+			 */
+			retval = ni_tio_set_gate_src(counter, 0, gate_source);
+		}
+	}
 	if (cmd->flags & CMDF_WAKE_EOS) {
 		ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
 				GI_GATE_INTERRUPT_ENABLE(cidx),
@@ -203,6 +235,9 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 		   struct comedi_cmd *cmd)
 {
 	struct ni_gpct *counter = s->private;
+	unsigned int cidx = counter->counter_index;
+	const struct ni_route_tables *routing_tables =
+		counter->counter_dev->routing_tables;
 	int err = 0;
 	unsigned int sources;
 
@@ -247,14 +282,37 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 		break;
 	case TRIG_EXT:
 		/* start_arg is the start_trigger passed to ni_tio_arm() */
+		/*
+		 * This should be done, but we don't yet know the actual
+		 * register values.  These should be tested and then documented
+		 * in the ni_route_values/ni_*.csv files, with indication of
+		 * who/when/which/how these these were tested.
+		 * When at least a e/m/660x series have been tested, this code
+		 * should be uncommented:
+		 *
+		 * err |= ni_check_trigger_arg(CR_CHAN(cmd->start_arg),
+		 *			    NI_CtrArmStartTrigger(cidx),
+		 *			    routing_tables);
+		 */
 		break;
 	}
 
+	/*
+	 * It seems that convention is to allow either scan_begin_arg or
+	 * convert_arg to specify the Gate source, with scan_begin_arg taking
+	 * precedence.
+	 */
 	if (cmd->scan_begin_src != TRIG_EXT)
 		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	else
+		err |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),
+					    NI_CtrGate(cidx), routing_tables);
 
 	if (cmd->convert_src != TRIG_EXT)
 		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	else
+		err |= ni_check_trigger_arg(CR_CHAN(cmd->convert_arg),
+					    NI_CtrGate(cidx), routing_tables);
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 8157cf663741..050bee0b9515 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -3,16 +3,6 @@
  * Command support for NI general purpose counters
  *
  * Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 9007c57544bf..8157cf663741 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Command support for NI general purpose counters
  *

commit f7d005c33c109ef034c9480334d3d25d91aa2d6d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:44 2016 -0700

    staging: comedi: mite: make mite_ack_linkc() handle mite_sync_dma()
    
    The mite dma is always synced on a LINKC status. Some of the mite users
    sync the dma regadless of the status.
    
    Add a 'sync' parameter to mite_ack_linkc() to force a dma sync. Then do
    the dma sync as needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 5228b9fc2a72..9007c57544bf 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -428,10 +428,8 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		break;
 	}
 	spin_lock_irqsave(&counter->lock, flags);
-	if (counter->mite_chan) {
-		mite_ack_linkc(counter->mite_chan, s);
-		mite_sync_dma(counter->mite_chan, s);
-	}
+	if (counter->mite_chan)
+		mite_ack_linkc(counter->mite_chan, s, true);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
 EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);

commit cc38da7287ed4f0f08956351167c31e4e6abc427
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 21 12:04:37 2016 -0700

    staging: comedi: mite: check for transfer errors in mite_ack_linkc()
    
    Currently only some of the users of mite dma check for transfer errors.
    
    The ni_mio_common code does the check for the analog input and analog
    output subdevices. The m-series digital I/O subdevice and the counter
    subdevices (handled by ni_tiocmd) do not check.
    
    The ni_pcidio driver checks for the digital input subdevice.
    
    The ni_660x driver counter subdevices (handled by ni_tiocmd) also do
    not check.
    
    Move the transfer error checking into mite_ack_linkc() so that the
    drivers that use mite don't have to deal with it. This also makes
    sure that all the subdevices that use mite for dma will cancel the
    async command if a transfer error is detected.
    
    Simplfy the transfer error check by just checking the CHSR_XFERR bit.
    This bit will be set if one or more transfer processes terminated with
    an error. The actual error is determined by the LERR, MERR, and DERR
    bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 4c76cb80f34c..5228b9fc2a72 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -429,7 +429,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	}
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan) {
-		mite_ack_linkc(counter->mite_chan);
+		mite_ack_linkc(counter->mite_chan, s);
 		mite_sync_dma(counter->mite_chan, s);
 	}
 	spin_unlock_irqrestore(&counter->lock, flags);

commit 51d430056c2a695ff7ffc62ae917c413616ec6b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 20 10:36:39 2016 -0700

    staging: comedi: mite: introduce mite_sync_dma()
    
    The struct mite_channel 'dir' member specifies if the dma is input
    or output. Wrap the mite_sync_input_dma() and mite_sync_output_dma()
    functions with a single mite_sync_dma() so that the drivers don't
    have to worry about the sync direction.
    
    The functions that actually sync the input/output dma currently return
    -1 if an overflow/underrun is detected otherwise they return 0. If an
    overflow/underrun is detected the async->event COMEDI_CB_OVERFLOW is
    also set.
    
    The callers never check the return value anyway so just make the
    functions return void. The async->event can be checked if necessary
    to detect any errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index dc0b0f3d9db1..4c76cb80f34c 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -430,7 +430,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan) {
 		mite_ack_linkc(counter->mite_chan);
-		mite_sync_input_dma(counter->mite_chan, s);
+		mite_sync_dma(counter->mite_chan, s);
 	}
 	spin_unlock_irqrestore(&counter->lock, flags);
 }

commit 4d88096df9ca49b71381eda90aa770c6db237f54
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 20 10:36:37 2016 -0700

    staging: comedi: mite: introduce mite_ack_linkc()
    
    Introduce a helper function to handle the ack of a LINKC interrupt.
    Tidy up the drivers that use the new helper.
    
    The extra check for CHSR_INT in the ni_pcidio driver is not necessary.
    This bit will be set if any of the interrupt sources, including CHSR_LINKC,
    have generated an interrupt. Remove the extra check.
    
    The mite_get_status() function is now only used by the mite driver.
    Make it static and remove the export.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 3c3f5430e552..dc0b0f3d9db1 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -400,7 +400,6 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 			     struct comedi_subdevice *s)
 {
 	unsigned int cidx = counter->counter_index;
-	unsigned int gpct_mite_status;
 	unsigned long flags;
 	int gate_error;
 	int tc_error;
@@ -429,16 +428,10 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		break;
 	}
 	spin_lock_irqsave(&counter->lock, flags);
-	if (!counter->mite_chan) {
-		spin_unlock_irqrestore(&counter->lock, flags);
-		return;
+	if (counter->mite_chan) {
+		mite_ack_linkc(counter->mite_chan);
+		mite_sync_input_dma(counter->mite_chan, s);
 	}
-	gpct_mite_status = mite_get_status(counter->mite_chan);
-	if (gpct_mite_status & CHSR_LINKC)
-		writel(CHOR_CLRLC,
-		       counter->mite_chan->mite->mite_io_addr +
-		       MITE_CHOR(counter->mite_chan->channel));
-	mite_sync_input_dma(counter->mite_chan, s);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
 EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);

commit a19b9b476ae3612e6c61c60e7fad7c8974158ef9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:59 2016 -0700

    staging: comedi: ni_tiocmd: remove BUG() which can never occur
    
    All the counter_dev->variant options are handled by the switch.
    Remove the BUG() which can never occur.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 2d801bf90e52..3c3f5430e552 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -125,9 +125,6 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 	case ni_gpct_variant_e_series:
 		mite_prep_dma(counter->mite_chan, 16, 32);
 		break;
-	default:
-		BUG();
-		break;
 	}
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
 	ni_tio_configure_dma(counter, true, true);

commit 53d63371293dfc8fdd49f14716c2f2b80aa11373
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:58 2016 -0700

    staging: comedi: ni_tiocmd: remove unsed param from ni_tio_acknowledge_and_confirm()
    
    The 'stale_data' pointer is always NULL. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 1400b1f2305d..2d801bf90e52 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -338,8 +338,7 @@ static int should_ack_gate(struct ni_gpct *counter)
 static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 					   int *gate_error,
 					   int *tc_error,
-					   int *perm_stale_data,
-					   int *stale_data)
+					   int *perm_stale_data)
 {
 	unsigned int cidx = counter->counter_index;
 	const unsigned short gxx_status = ni_tio_read(counter,
@@ -354,8 +353,6 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 		*tc_error = 0;
 	if (perm_stale_data)
 		*perm_stale_data = 0;
-	if (stale_data)
-		*stale_data = 0;
 
 	if (gxx_status & GI_GATE_ERROR(cidx)) {
 		ack |= GI_GATE_ERROR_CONFIRM(cidx);
@@ -385,10 +382,6 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 		ni_tio_write(counter, ack, NITIO_INT_ACK_REG(cidx));
 	if (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &
 	    GI_LOADING_ON_GATE) {
-		if (gxx_status & GI_STALE_DATA(cidx)) {
-			if (stale_data)
-				*stale_data = 1;
-		}
 		if (ni_tio_read(counter, NITIO_STATUS2_REG(cidx)) &
 		    GI_PERMANENT_STALE(cidx)) {
 			dev_info(counter->counter_dev->dev->class_dev,
@@ -402,7 +395,7 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 
 void ni_tio_acknowledge(struct ni_gpct *counter)
 {
-	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
+	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL);
 }
 EXPORT_SYMBOL_GPL(ni_tio_acknowledge);
 
@@ -417,7 +410,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	int perm_stale_data;
 
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
-				       &perm_stale_data, NULL);
+				       &perm_stale_data);
 	if (gate_error) {
 		dev_notice(counter->counter_dev->dev->class_dev,
 			   "%s: Gi_Gate_Error detected.\n", __func__);

commit b878a82ee15f77ff1106aa0e5be36a1ee3ec85ea
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:57 2016 -0700

    staging: comedi: ni_tiocmd: fix block comments
    
    Fix the checkpatch.pl issues:
    WARNING: Block comments use * on subsequent lines
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index df4ffdbcd96d..1400b1f2305d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -1,19 +1,18 @@
 /*
-  comedi/drivers/ni_tiocmd.c
-  Command support for NI general purpose counters
-
-  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-*/
+ * Command support for NI general purpose counters
+ *
+ * Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
 /*
  * Module: ni_tiocmd
@@ -36,13 +35,10 @@
  * DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
  * DAQ 6601/6602 User Manual (NI 322137B-01)
  * 340934b.pdf  DAQ-STC reference manual
+ *
+ * TODO: Support use of both banks X and Y
  */
 
-/*
-TODO:
-	Support use of both banks X and Y
-*/
-
 #include <linux/module.h>
 #include "ni_tio_internal.h"
 #include "mite.h"
@@ -305,9 +301,6 @@ int ni_tio_cancel(struct ni_gpct *counter)
 }
 EXPORT_SYMBOL_GPL(ni_tio_cancel);
 
-	/* During buffered input counter operation for e-series, the gate
-	   interrupt is acked automatically by the dma controller, due to the
-	   Gi_Read/Write_Acknowledges_IRQ bits in the input select register.  */
 static int should_ack_gate(struct ni_gpct *counter)
 {
 	unsigned long flags;
@@ -315,12 +308,19 @@ static int should_ack_gate(struct ni_gpct *counter)
 
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
-	/*  not sure if 660x really supports gate
-	    interrupts (the bits are not listed
-	    in register-level manual) */
 	case ni_gpct_variant_660x:
+		/*
+		 * not sure if 660x really supports gate interrupts
+		 * (the bits are not listed in register-level manual)
+		 */
 		return 1;
 	case ni_gpct_variant_e_series:
+		/*
+		 * During buffered input counter operation for e-series,
+		 * the gate interrupt is acked automatically by the dma
+		 * controller, due to the Gi_Read/Write_Acknowledges_IRQ
+		 * bits in the input select register.
+		 */
 		spin_lock_irqsave(&counter->lock, flags);
 		{
 			if (!counter->mite_chan ||
@@ -360,9 +360,11 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 	if (gxx_status & GI_GATE_ERROR(cidx)) {
 		ack |= GI_GATE_ERROR_CONFIRM(cidx);
 		if (gate_error) {
-			/*660x don't support automatic acknowledgment
-			  of gate interrupt via dma read/write
-			   and report bogus gate errors */
+			/*
+			 * 660x don't support automatic acknowledgment
+			 * of gate interrupt via dma read/write
+			 * and report bogus gate errors
+			 */
 			if (counter->counter_dev->variant !=
 			    ni_gpct_variant_660x)
 				*gate_error = 1;

commit 9f62bee520b04346c3501a5da7534a96b873c01f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:56 2016 -0700

    staging: comedi: ni_tiocmd: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Fix the checkpatch.pl issues.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index d5ffbb135844..df4ffdbcd96d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -51,9 +51,9 @@ static void ni_tio_configure_dma(struct ni_gpct *counter,
 				 bool enable, bool read)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
-	unsigned mask;
-	unsigned bits;
+	unsigned int cidx = counter->counter_index;
+	unsigned int mask;
+	unsigned int bits;
 
 	mask = GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ;
 	bits = 0;
@@ -113,7 +113,7 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 {
 	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int ret = 0;
@@ -163,9 +163,9 @@ static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct ni_gpct *counter = s->private;
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	int set_gate_source = 0;
-	unsigned gate_source;
+	unsigned int gate_source;
 	int retval = 0;
 
 	if (cmd->scan_begin_src == TRIG_EXT) {
@@ -289,7 +289,7 @@ EXPORT_SYMBOL_GPL(ni_tio_cmdtest);
 
 int ni_tio_cancel(struct ni_gpct *counter)
 {
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	unsigned long flags;
 
 	ni_tio_arm(counter, false, 0);
@@ -341,12 +341,12 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 					   int *perm_stale_data,
 					   int *stale_data)
 {
-	unsigned cidx = counter->counter_index;
+	unsigned int cidx = counter->counter_index;
 	const unsigned short gxx_status = ni_tio_read(counter,
 						NITIO_SHARED_STATUS_REG(cidx));
 	const unsigned short gi_status = ni_tio_read(counter,
 						NITIO_STATUS_REG(cidx));
-	unsigned ack = 0;
+	unsigned int ack = 0;
 
 	if (gate_error)
 		*gate_error = 0;
@@ -407,8 +407,8 @@ EXPORT_SYMBOL_GPL(ni_tio_acknowledge);
 void ni_tio_handle_interrupt(struct ni_gpct *counter,
 			     struct comedi_subdevice *s)
 {
-	unsigned cidx = counter->counter_index;
-	unsigned gpct_mite_status;
+	unsigned int cidx = counter->counter_index;
+	unsigned int gpct_mite_status;
 	unsigned long flags;
 	int gate_error;
 	int tc_error;

commit 51f2e4eb2882209c84c2546b5a9b5c638b850f95
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:44 2016 -0700

    staging: comedi: ni_tio_internal: export {read, write)_register()
    
    Move these inline functions out of the header and export them instead.
    These functions have pretty generic names, rename them.
    
    Fix the checkpatch.pl issues:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    CHECK: Avoid crashing the kernel - try using WARN_ON & recovery code
           rather than BUG() or BUG_ON()
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 0546a55b7277..d5ffbb135844 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -342,9 +342,9 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 					   int *stale_data)
 {
 	unsigned cidx = counter->counter_index;
-	const unsigned short gxx_status = read_register(counter,
+	const unsigned short gxx_status = ni_tio_read(counter,
 						NITIO_SHARED_STATUS_REG(cidx));
-	const unsigned short gi_status = read_register(counter,
+	const unsigned short gi_status = ni_tio_read(counter,
 						NITIO_STATUS_REG(cidx));
 	unsigned ack = 0;
 
@@ -380,14 +380,14 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 			ack |= GI_GATE_INTERRUPT_ACK;
 	}
 	if (ack)
-		write_register(counter, ack, NITIO_INT_ACK_REG(cidx));
+		ni_tio_write(counter, ack, NITIO_INT_ACK_REG(cidx));
 	if (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &
 	    GI_LOADING_ON_GATE) {
 		if (gxx_status & GI_STALE_DATA(cidx)) {
 			if (stale_data)
 				*stale_data = 1;
 		}
-		if (read_register(counter, NITIO_STATUS2_REG(cidx)) &
+		if (ni_tio_read(counter, NITIO_STATUS2_REG(cidx)) &
 		    GI_PERMANENT_STALE(cidx)) {
 			dev_info(counter->counter_dev->dev->class_dev,
 				 "%s: Gi_Permanent_Stale_Data detected.\n",
@@ -426,7 +426,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
-		if (read_register(counter, NITIO_DMA_STATUS_REG(cidx)) &
+		if (ni_tio_read(counter, NITIO_DMA_STATUS_REG(cidx)) &
 		    GI_DRQ_ERROR) {
 			dev_notice(counter->counter_dev->dev->class_dev,
 				   "%s: Gi_DRQ_Error detected.\n", __func__);

commit c9813d50a514b451c4ad3acf1f5a400fff005c70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 15:36:40 2016 -0700

    staging: comedi: ni_tio: fix ni_tio_arm() params/vars
    
    As suggested by checkpatch.pl:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    The 'arm' parameter is really a true/false flag. For aesthetics,
    change it to a bool.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 823e47910004..0546a55b7277 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -103,7 +103,7 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 	spin_unlock_irqrestore(&counter->lock, flags);
 	if (ret < 0)
 		return ret;
-	ret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+	ret = ni_tio_arm(counter, true, NI_GPCT_ARM_IMMEDIATE);
 	s->async->inttrig = NULL;
 
 	return ret;
@@ -143,9 +143,9 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 		mite_dma_arm(counter->mite_chan);
 
 		if (cmd->start_src == TRIG_NOW)
-			ret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+			ret = ni_tio_arm(counter, true, NI_GPCT_ARM_IMMEDIATE);
 		else if (cmd->start_src == TRIG_EXT)
-			ret = ni_tio_arm(counter, 1, cmd->start_arg);
+			ret = ni_tio_arm(counter, true, cmd->start_arg);
 	}
 	return ret;
 }
@@ -292,7 +292,7 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	unsigned cidx = counter->counter_index;
 	unsigned long flags;
 
-	ni_tio_arm(counter, 0, 0);
+	ni_tio_arm(counter, false, 0);
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan)
 		mite_dma_disarm(counter->mite_chan);

commit 1fd24a4702d2af0ea4d5845126cf57d4d1796216
Author: Spencer E. Olson <olsonse@umich.edu>
Date:   Tue Jan 12 10:33:18 2016 -0700

    staging: comedi: ni_tiocmd: change mistaken use of start_src for start_arg
    
    This fixes a bug in function ni_tio_input_inttrig().  The trigger number
    should be compared to cmd->start_arg, not cmd->start_src.
    
    Fixes: 6a760394d7eb ("staging: comedi: ni_tiocmd: clarify the cmd->start_arg validation and use")
    Cc: <stable@vger.kernel.org> # 3.17+
    Signed-off-by: Spencer E. Olson <olsonse@umich.edu>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 437f723bb34d..823e47910004 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -92,7 +92,7 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 	unsigned long flags;
 	int ret = 0;
 
-	if (trig_num != cmd->start_src)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	spin_lock_irqsave(&counter->lock, flags);

commit 02ab79c80bc4ba5288e84d717ec4f6dc0030c90f
Author: Luis de Bethencourt <luisbg@osg.samsung.com>
Date:   Tue Sep 29 12:22:03 2015 +0100

    staging: comedi: ni_tiocmd: remove unused code
    
    Code after a return will never run, removing this dead code.
    
    Suggested-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 9b124b09e914..437f723bb34d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -157,12 +157,6 @@ static int ni_tio_output_cmd(struct comedi_subdevice *s)
 	dev_err(counter->counter_dev->dev->class_dev,
 		"output commands not yet implemented.\n");
 	return -ENOTSUPP;
-
-	counter->mite_chan->dir = COMEDI_OUTPUT;
-	mite_prep_dma(counter->mite_chan, 32, 32);
-	ni_tio_configure_dma(counter, true, false);
-	mite_dma_arm(counter->mite_chan);
-	return ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
 }
 
 static int ni_tio_cmd_setup(struct comedi_subdevice *s)

commit eeae1cc974a711478cf7b229dec7f69321f999ad
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:26 2015 +0000

    staging: comedi: ni_tiocmd: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 2a1f8b26c407..9b124b09e914 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -44,7 +44,6 @@
 */
 
 #include <linux/module.h>
-#include "comedi_fc.h"
 #include "ni_tio_internal.h"
 #include "mite.h"
 
@@ -234,23 +233,23 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 	sources = TRIG_NOW | TRIG_INT | TRIG_OTHER;
 	if (ni_tio_counting_mode_registers_present(counter->counter_dev))
 		sources |= TRIG_EXT;
-	err |= cfc_check_trigger_src(&cmd->start_src, sources);
+	err |= comedi_check_trigger_src(&cmd->start_src, sources);
 
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_FOLLOW | TRIG_EXT | TRIG_OTHER);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
+	err |= comedi_check_trigger_src(&cmd->convert_src,
 					TRIG_NOW | TRIG_EXT | TRIG_OTHER);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -266,7 +265,7 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 	case TRIG_NOW:
 	case TRIG_INT:
 	case TRIG_OTHER:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		/* start_arg is the start_trigger passed to ni_tio_arm() */
@@ -274,13 +273,14 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 	}
 
 	if (cmd->scan_begin_src != TRIG_EXT)
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	if (cmd->convert_src != TRIG_EXT)
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 9949595c0da61ff2aecc90c3a8e924848e6ac03b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:15 2015 -0700

    staging: comedi: drivers/*.c: fix common misspellings
    
    Fix these common misspellings:
      s/dependancy/dependency
      s/occured/occurred
      s/informations/information
      s/intialize/initialize
      s/serveral/several
      s/interrups/interrupts
      s/acknowledgement/acknowledgment
      s/suppport/support
      s/writting/writing
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 41735700e5f9..2a1f8b26c407 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -366,7 +366,7 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 	if (gxx_status & GI_GATE_ERROR(cidx)) {
 		ack |= GI_GATE_ERROR_CONFIRM(cidx);
 		if (gate_error) {
-			/*660x don't support automatic acknowledgement
+			/*660x don't support automatic acknowledgment
 			  of gate interrupt via dma read/write
 			   and report bogus gate errors */
 			if (counter->counter_dev->variant !=

commit 56e97078602996123d849b7621442a934aa19b77
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 4 12:15:39 2015 -0700

    staging: comedi: ni_tiocmd: (!foo) preferred over (foo == NULL)
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index d36c3abd3120..41735700e5f9 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -201,7 +201,7 @@ int ni_tio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	unsigned long flags;
 
 	spin_lock_irqsave(&counter->lock, flags);
-	if (counter->mite_chan == NULL) {
+	if (!counter->mite_chan) {
 		dev_err(counter->counter_dev->dev->class_dev,
 			"commands only supported with DMA.  ");
 		dev_err(counter->counter_dev->dev->class_dev,
@@ -329,7 +329,7 @@ static int should_ack_gate(struct ni_gpct *counter)
 	case ni_gpct_variant_e_series:
 		spin_lock_irqsave(&counter->lock, flags);
 		{
-			if (counter->mite_chan == NULL ||
+			if (!counter->mite_chan ||
 			    counter->mite_chan->dir != COMEDI_INPUT ||
 			    (mite_done(counter->mite_chan))) {
 				retval = 1;
@@ -443,7 +443,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		break;
 	}
 	spin_lock_irqsave(&counter->lock, flags);
-	if (counter->mite_chan == NULL) {
+	if (!counter->mite_chan) {
 		spin_unlock_irqrestore(&counter->lock, flags);
 		return;
 	}

commit 6bd4fa872e971ce1569a6c012fff7c90f348dfd2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:58 2015 +0000

    staging: comedi: ni_tiocmd: change comedi "driver" comment to "module"
    
    This module contains support code for some other comedi drivers, but
    isn't a comedi driver itself, so doesn't need a comedi "driver" comment.
    To preserve the details in the original comment, change it into a comedi
    "module" comment (which I've just invented) by changing the "Driver:"
    line into a "Module:" line and removing the "Devices:" line.
    
    Also reformat it to use the usual block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 6037bec77ef1..d36c3abd3120 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -16,29 +16,28 @@
 */
 
 /*
-Driver: ni_tiocmd
-Description: National Instruments general purpose counters command support
-Devices:
-Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
-	Herman.Bruyninckx@mech.kuleuven.ac.be,
-	Wim.Meeussen@mech.kuleuven.ac.be,
-	Klaas.Gadeyne@mech.kuleuven.ac.be,
-	Frank Mori Hess <fmhess@users.sourceforge.net>
-Updated: Fri, 11 Apr 2008 12:32:35 +0100
-Status: works
-
-This module is not used directly by end-users.  Rather, it
-is used by other drivers (for example ni_660x and ni_pcimio)
-to provide command support for NI's general purpose counters.
-It was originally split out of ni_tio.c to stop the 'ni_tio'
-module depending on the 'mite' module.
-
-References:
-DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
-DAQ 6601/6602 User Manual (NI 322137B-01)
-340934b.pdf  DAQ-STC reference manual
+ * Module: ni_tiocmd
+ * Description: National Instruments general purpose counters command support
+ * Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
+ *         Herman.Bruyninckx@mech.kuleuven.ac.be,
+ *         Wim.Meeussen@mech.kuleuven.ac.be,
+ *         Klaas.Gadeyne@mech.kuleuven.ac.be,
+ *         Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Updated: Fri, 11 Apr 2008 12:32:35 +0100
+ * Status: works
+ *
+ * This module is not used directly by end-users.  Rather, it
+ * is used by other drivers (for example ni_660x and ni_pcimio)
+ * to provide command support for NI's general purpose counters.
+ * It was originally split out of ni_tio.c to stop the 'ni_tio'
+ * module depending on the 'mite' module.
+ *
+ * References:
+ * DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
+ * DAQ 6601/6602 User Manual (NI 322137B-01)
+ * 340934b.pdf  DAQ-STC reference manual
+ */
 
-*/
 /*
 TODO:
 	Support use of both banks X and Y

commit 6b9214b793a4ae2350f748a587a61a267bfd119b
Author: Surya Seetharaman <surya.seetharaman9@gmail.com>
Date:   Mon Oct 27 19:58:20 2014 +0530

    Staging: comedi: nio_tiocmd: fixed a brace coding style issue.
    
    Removed unnecessary braces using checkpatch.pl tool
    
    Signed-off-by: Surya Seetharaman <suryaseetharaman.9@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 46cf3eb2ee54..6037bec77ef1 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -449,11 +449,10 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		return;
 	}
 	gpct_mite_status = mite_get_status(counter->mite_chan);
-	if (gpct_mite_status & CHSR_LINKC) {
+	if (gpct_mite_status & CHSR_LINKC)
 		writel(CHOR_CLRLC,
 		       counter->mite_chan->mite->mite_io_addr +
 		       MITE_CHOR(counter->mite_chan->channel));
-	}
 	mite_sync_input_dma(counter->mite_chan, s);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }

commit 0297ac39fae9edcccf8752a53e6ce6f903469c4f
Author: tssurya <suryaseetharaman.9@gmail.com>
Date:   Sat Oct 25 00:37:33 2014 +0530

    Staging: comedi: ni_tiocmd: fixed a brace coding style issue
    
    Removed unneeded braces with the help of checkpatch.pl tool.
    
    Signed-off-by: Surya Seetharaman <suryaseetharaman.9@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 26e7291c4a51..46cf3eb2ee54 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -371,9 +371,8 @@ static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
 			  of gate interrupt via dma read/write
 			   and report bogus gate errors */
 			if (counter->counter_dev->variant !=
-			    ni_gpct_variant_660x) {
+			    ni_gpct_variant_660x)
 				*gate_error = 1;
-			}
 		}
 	}
 	if (gxx_status & GI_TC_ERROR(cidx)) {

commit 656d9b0fe1866397d407fae7f5fff55b54d5b861
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:40 2014 +0100

    staging: comedi: ni_tiocmd: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index c1e3966de301..26e7291c4a51 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -185,7 +185,7 @@ static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 	}
 	if (set_gate_source)
 		retval = ni_tio_set_gate_src(counter, 0, gate_source);
-	if (cmd->flags & TRIG_WAKE_EOS) {
+	if (cmd->flags & CMDF_WAKE_EOS) {
 		ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
 				GI_GATE_INTERRUPT_ENABLE(cidx),
 				GI_GATE_INTERRUPT_ENABLE(cidx));

commit ae2aef64fb10f8c976cd7e95372bab45944d754a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 15:23:49 2014 -0700

    staging: comedi: ni_tiocmd: remove deadcode in ni_tio_cmdtest()
    
    Reported by: coverity
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 299ceddfb233..c1e3966de301 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -286,10 +286,9 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 3;
 
-	/* step 4: fix up any arguments */
+	/* Step 4: fix up any arguments */
 
-	if (err)
-		return 4;
+	/* Step 5: check channel list if it exists */
 
 	return 0;
 }

commit f8cfd0eb3c11337844215c5e93937c561858eb13
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:04 2014 -0700

    staging: comedi: ni_tiocmd: introduce ni_tio_acknowledge()
    
    The external callers of ni_tio_acknowledge_and_confirm() only call
    this function to ack any pending errors or interrupts before starting
    a new async command. Only the internal code in ni_tiocmd uses the
    data that is optionally returned by this function.
    
    Remove the export from ni_tio_acknowledge_and_confirm() and introduce
    a new exported function that handles passing the NULL params.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index c360667b1ba4..299ceddfb233 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -343,9 +343,11 @@ static int should_ack_gate(struct ni_gpct *counter)
 	return retval;
 }
 
-void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
-				    int *tc_error, int *perm_stale_data,
-				    int *stale_data)
+static void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,
+					   int *gate_error,
+					   int *tc_error,
+					   int *perm_stale_data,
+					   int *stale_data)
 {
 	unsigned cidx = counter->counter_index;
 	const unsigned short gxx_status = read_register(counter,
@@ -404,7 +406,12 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		}
 	}
 }
-EXPORT_SYMBOL_GPL(ni_tio_acknowledge_and_confirm);
+
+void ni_tio_acknowledge(struct ni_gpct *counter)
+{
+	ni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);
+}
+EXPORT_SYMBOL_GPL(ni_tio_acknowledge);
 
 void ni_tio_handle_interrupt(struct ni_gpct *counter,
 			     struct comedi_subdevice *s)

commit 4cf2f3a5745f4fbcd9eb80e3bb1406be6d95cf26
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:03 2014 -0700

    staging: comedi: ni_tiocmd: tidy up ni_tio_input_cmd()
    
    The cmd->start_src is validated in the (*do_cmdtest) before this
    function is called. All valid trigger sources are handled so the
    default BUG() case can never occure.
    
    For aesthetics, refactor the switch into if/else tests and remove
    the BUG().
    
    For aesthetics, rename the local variable 'retval' to simply 'ret'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 334ce3529e08..c360667b1ba4 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -118,7 +118,7 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 	unsigned cidx = counter->counter_index;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	int retval = 0;
+	int ret = 0;
 
 	/* write alloc the entire buffer */
 	comedi_buf_write_alloc(s, async->prealloc_bufsz);
@@ -137,29 +137,19 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 	}
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
 	ni_tio_configure_dma(counter, true, true);
-	switch (cmd->start_src) {
-	case TRIG_NOW:
-		async->inttrig = NULL;
-		mite_dma_arm(counter->mite_chan);
-		retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
-		break;
-	case TRIG_INT:
+
+	if (cmd->start_src == TRIG_INT) {
 		async->inttrig = &ni_tio_input_inttrig;
-		break;
-	case TRIG_EXT:
+	} else {	/* TRIG_NOW || TRIG_EXT || TRIG_OTHER */
 		async->inttrig = NULL;
 		mite_dma_arm(counter->mite_chan);
-		retval = ni_tio_arm(counter, 1, cmd->start_arg);
-		break;
-	case TRIG_OTHER:
-		async->inttrig = NULL;
-		mite_dma_arm(counter->mite_chan);
-		break;
-	default:
-		BUG();
-		break;
+
+		if (cmd->start_src == TRIG_NOW)
+			ret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+		else if (cmd->start_src == TRIG_EXT)
+			ret = ni_tio_arm(counter, 1, cmd->start_arg);
 	}
-	return retval;
+	return ret;
 }
 
 static int ni_tio_output_cmd(struct comedi_subdevice *s)

commit 78c7a4a6592cde3e2ecba1732727d3ed3866a653
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:02 2014 -0700

    staging: comedi: ni_tiocmd: tidy up ni_tio_input_inttrig()
    
    Remove the BUG_ON(counter == NULL). If this can never happen and it
    if did the driver should have died long before this function is called.
    
    For aesthetics, rename the local variable 'retval' to simply 'ret'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 16858fbd215d..334ce3529e08 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -92,9 +92,7 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 	struct ni_gpct *counter = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
-	int retval = 0;
-
-	BUG_ON(counter == NULL);
+	int ret = 0;
 
 	if (trig_num != cmd->start_src)
 		return -EINVAL;
@@ -103,14 +101,14 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 	if (counter->mite_chan)
 		mite_dma_arm(counter->mite_chan);
 	else
-		retval = -EIO;
+		ret = -EIO;
 	spin_unlock_irqrestore(&counter->lock, flags);
-	if (retval < 0)
-		return retval;
-	retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+	if (ret < 0)
+		return ret;
+	ret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
 	s->async->inttrig = NULL;
 
-	return retval;
+	return ret;
 }
 
 static int ni_tio_input_cmd(struct comedi_subdevice *s)

commit 65dbae525fc1e6b5c2cd09e1fc700a7d80b3577d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:01 2014 -0700

    staging: comedi: ni_tiocmd: tidy up ni_tio_configure_dma()
    
    The 'enable' and 'read_not_write' parameters are true/false flags. For
    aesthetics, change their types to bool.
    
    Rename the local variable 'input_select_bits' to simply 'bits' and reuse
    it when enabling the dma on the m series and 660x counter variants.
    
    Add a local variable for the 'mask' that is passed to ni_tio_set_bits()
    to help clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 8c89786047e1..16858fbd215d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -49,40 +49,38 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 #include "ni_tio_internal.h"
 #include "mite.h"
 
-static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
-				 short read_not_write)
+static void ni_tio_configure_dma(struct ni_gpct *counter,
+				 bool enable, bool read)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
-	unsigned input_select_bits = 0;
+	unsigned mask;
+	unsigned bits;
+
+	mask = GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ;
+	bits = 0;
 
 	if (enable) {
-		if (read_not_write)
-			input_select_bits |= GI_READ_ACKS_IRQ;
+		if (read)
+			bits |= GI_READ_ACKS_IRQ;
 		else
-			input_select_bits |= GI_WRITE_ACKS_IRQ;
+			bits |= GI_WRITE_ACKS_IRQ;
 	}
-	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ,
-			input_select_bits);
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), mask, bits);
+
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 		break;
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
-		{
-			unsigned gi_dma_config_bits = 0;
-
-			if (enable) {
-				gi_dma_config_bits |= GI_DMA_ENABLE;
-				gi_dma_config_bits |= GI_DMA_INT_ENA;
-			}
-			if (read_not_write == 0)
-				gi_dma_config_bits |= GI_DMA_WRITE;
-			ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx),
-					GI_DMA_ENABLE | GI_DMA_INT_ENA |
-					GI_DMA_WRITE, gi_dma_config_bits);
-		}
+		mask = GI_DMA_ENABLE | GI_DMA_INT_ENA | GI_DMA_WRITE;
+		bits = 0;
+
+		if (enable)
+			bits |= GI_DMA_ENABLE | GI_DMA_INT_ENA;
+		if (!read)
+			bits |= GI_DMA_WRITE;
+		ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), mask, bits);
 		break;
 	}
 }
@@ -140,7 +138,7 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 		break;
 	}
 	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
-	ni_tio_configure_dma(counter, 1, 1);
+	ni_tio_configure_dma(counter, true, true);
 	switch (cmd->start_src) {
 	case TRIG_NOW:
 		async->inttrig = NULL;
@@ -176,7 +174,7 @@ static int ni_tio_output_cmd(struct comedi_subdevice *s)
 
 	counter->mite_chan->dir = COMEDI_OUTPUT;
 	mite_prep_dma(counter->mite_chan, 32, 32);
-	ni_tio_configure_dma(counter, 1, 0);
+	ni_tio_configure_dma(counter, true, false);
 	mite_dma_arm(counter->mite_chan);
 	return ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
 }
@@ -319,7 +317,7 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	if (counter->mite_chan)
 		mite_dma_disarm(counter->mite_chan);
 	spin_unlock_irqrestore(&counter->lock, flags);
-	ni_tio_configure_dma(counter, 0, 0);
+	ni_tio_configure_dma(counter, false, false);
 
 	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
 			GI_GATE_INTERRUPT_ENABLE(cidx), 0x0);

commit 613117fbfe02586f4f53b83b668eab06bec6bc5f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:27:00 2014 -0700

    staging: comedi: ni_tio: tidy up G{02, 12}_Interrupt_Enable_Bits
    
    Convert these enums into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 3ec8995f0cf4..8c89786047e1 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -201,8 +201,8 @@ static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 		retval = ni_tio_set_gate_src(counter, 0, gate_source);
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
-				Gi_Gate_Interrupt_Enable_Bit(cidx),
-				Gi_Gate_Interrupt_Enable_Bit(cidx));
+				GI_GATE_INTERRUPT_ENABLE(cidx),
+				GI_GATE_INTERRUPT_ENABLE(cidx));
 	}
 	return retval;
 }
@@ -322,7 +322,7 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
-			Gi_Gate_Interrupt_Enable_Bit(cidx), 0x0);
+			GI_GATE_INTERRUPT_ENABLE(cidx), 0x0);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_cancel);

commit fcf6560c52f0e29569ed5b2d41e64a1360d955a0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:59 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Status_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 43a7bee55052..3ec8995f0cf4 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -394,9 +394,9 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		if (tc_error)
 			*tc_error = 1;
 	}
-	if (gi_status & Gi_TC_Bit)
+	if (gi_status & GI_TC)
 		ack |= GI_TC_INTERRUPT_ACK;
-	if (gi_status & Gi_Gate_Interrupt_Bit) {
+	if (gi_status & GI_GATE_INTERRUPT) {
 		if (should_ack_gate(counter))
 			ack |= GI_GATE_INTERRUPT_ACK;
 	}

commit 4bf9d435b2e82d12f663706de32c286f423a43d4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:58 2014 -0700

    staging: comedi: ni_tio: tidy up Gxx_Interrupt_Acknowledge_Bits
    
    Convert this enum and the others related to it into defines and
    rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index f8019bf57ea5..43a7bee55052 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -378,7 +378,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		*stale_data = 0;
 
 	if (gxx_status & GI_GATE_ERROR(cidx)) {
-		ack |= Gi_Gate_Error_Confirm_Bit(cidx);
+		ack |= GI_GATE_ERROR_CONFIRM(cidx);
 		if (gate_error) {
 			/*660x don't support automatic acknowledgement
 			  of gate interrupt via dma read/write
@@ -390,15 +390,15 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		}
 	}
 	if (gxx_status & GI_TC_ERROR(cidx)) {
-		ack |= Gi_TC_Error_Confirm_Bit(cidx);
+		ack |= GI_TC_ERROR_CONFIRM(cidx);
 		if (tc_error)
 			*tc_error = 1;
 	}
 	if (gi_status & Gi_TC_Bit)
-		ack |= Gi_TC_Interrupt_Ack_Bit;
+		ack |= GI_TC_INTERRUPT_ACK;
 	if (gi_status & Gi_Gate_Interrupt_Bit) {
 		if (should_ack_gate(counter))
-			ack |= Gi_Gate_Interrupt_Ack_Bit;
+			ack |= GI_GATE_INTERRUPT_ACK;
 	}
 	if (ack)
 		write_register(counter, ack, NITIO_INT_ACK_REG(cidx));

commit 923de26e74a5fe944e9a2f0301342a73db05f3b4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:57 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_DMA_Status_Reg_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index d80bb35aed40..f8019bf57ea5 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -443,7 +443,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		if (read_register(counter, NITIO_DMA_STATUS_REG(cidx)) &
-		    Gi_DRQ_Error_Bit) {
+		    GI_DRQ_ERROR) {
 			dev_notice(counter->counter_dev->dev->class_dev,
 				   "%s: Gi_DRQ_Error detected.\n", __func__);
 			s->async->events |= COMEDI_CB_OVERFLOW;

commit 150dde701f8cae00ecb0084316a9e60f5046de9c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:56 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_DMA_Config_Reg_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 9ba40794ac21..d80bb35aed40 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -74,14 +74,14 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 			unsigned gi_dma_config_bits = 0;
 
 			if (enable) {
-				gi_dma_config_bits |= Gi_DMA_Enable_Bit;
-				gi_dma_config_bits |= Gi_DMA_Int_Bit;
+				gi_dma_config_bits |= GI_DMA_ENABLE;
+				gi_dma_config_bits |= GI_DMA_INT_ENA;
 			}
 			if (read_not_write == 0)
-				gi_dma_config_bits |= Gi_DMA_Write_Bit;
+				gi_dma_config_bits |= GI_DMA_WRITE;
 			ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx),
-					Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
-					Gi_DMA_Write_Bit, gi_dma_config_bits);
+					GI_DMA_ENABLE | GI_DMA_INT_ENA |
+					GI_DMA_WRITE, gi_dma_config_bits);
 		}
 		break;
 	}

commit 29c2003d11a57c88d99e892e9dd26b36d29ae454
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:55 2014 -0700

    staging: comedi: ni_tio: tidy up Gxx_Joint_Status2_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index d628748ac513..9ba40794ac21 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -409,7 +409,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				*stale_data = 1;
 		}
 		if (read_register(counter, NITIO_STATUS2_REG(cidx)) &
-		    Gi_Permanent_Stale_Bit(cidx)) {
+		    GI_PERMANENT_STALE(cidx)) {
 			dev_info(counter->counter_dev->dev->class_dev,
 				 "%s: Gi_Permanent_Stale_Data detected.\n",
 				 __func__);

commit 24a675c5130198fcf354325f108b4a62aa7575a5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:53 2014 -0700

    staging: comedi: ni_tio: tidy up Gxx_Status_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 16dba7fe7797..d628748ac513 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -377,7 +377,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	if (stale_data)
 		*stale_data = 0;
 
-	if (gxx_status & Gi_Gate_Error_Bit(cidx)) {
+	if (gxx_status & GI_GATE_ERROR(cidx)) {
 		ack |= Gi_Gate_Error_Confirm_Bit(cidx);
 		if (gate_error) {
 			/*660x don't support automatic acknowledgement
@@ -389,7 +389,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 			}
 		}
 	}
-	if (gxx_status & Gi_TC_Error_Bit(cidx)) {
+	if (gxx_status & GI_TC_ERROR(cidx)) {
 		ack |= Gi_TC_Error_Confirm_Bit(cidx);
 		if (tc_error)
 			*tc_error = 1;
@@ -404,7 +404,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		write_register(counter, ack, NITIO_INT_ACK_REG(cidx));
 	if (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &
 	    GI_LOADING_ON_GATE) {
-		if (gxx_status & Gi_Stale_Data_Bit(cidx)) {
+		if (gxx_status & GI_STALE_DATA(cidx)) {
 			if (stale_data)
 				*stale_data = 1;
 		}

commit 36d80f4a5460cae2e33b15568e572426ff976c70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:51 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Mode_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 789d61f2a732..16dba7fe7797 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -403,7 +403,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	if (ack)
 		write_register(counter, ack, NITIO_INT_ACK_REG(cidx));
 	if (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &
-	    Gi_Loading_On_Gate_Bit) {
+	    GI_LOADING_ON_GATE) {
 		if (gxx_status & Gi_Stale_Data_Bit(cidx)) {
 			if (stale_data)
 				*stale_data = 1;

commit c2c6c288f9bfa898b86c9c107af4227e022e18f1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:50 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Input_Select_Bits
    
    Convert this enum into defines and rename the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with
    the register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 8ea0debd58d4..789d61f2a732 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -58,12 +58,12 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 
 	if (enable) {
 		if (read_not_write)
-			input_select_bits |= Gi_Read_Acknowledges_Irq;
+			input_select_bits |= GI_READ_ACKS_IRQ;
 		else
-			input_select_bits |= Gi_Write_Acknowledges_Irq;
+			input_select_bits |= GI_WRITE_ACKS_IRQ;
 	}
 	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
-			Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
+			GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ,
 			input_select_bits);
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:

commit b9a09764eeb75c3b38f99d5d4154fcb68155e65a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jul 28 10:26:48 2014 -0700

    staging: comedi: ni_tio: tidy up Gi_Command_Reg_Bits
    
    Convert this enum into defines and rename all the CamelCase symbols.
    
    For aesthetics, move the new defines so they are associated with the
    register define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index f66b504811bf..8ea0debd58d4 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -139,7 +139,7 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 		BUG();
 		break;
 	}
-	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), Gi_Save_Trace_Bit, 0);
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);
 	ni_tio_configure_dma(counter, 1, 1);
 	switch (cmd->start_src) {
 	case TRIG_NOW:

commit 1c6820bc167a06e4b28c586a990b8bf6a173d64b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:39 2014 -0700

    staging: comedi: ni_tiocmd: checkpatch.pl cleanup (break is not useful)
    
    Fix the checkpatch.pl warning:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 2557ab48cb6c..f66b504811bf 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -342,7 +342,6 @@ static int should_ack_gate(struct ni_gpct *counter)
 	    in register-level manual) */
 	case ni_gpct_variant_660x:
 		return 1;
-		break;
 	case ni_gpct_variant_e_series:
 		spin_lock_irqsave(&counter->lock, flags);
 		{

commit 74f63db7ae614aee8370df6152c0da76e14b6ff0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:16 2014 +0100

    staging: comedi: mite: pass subdevice to mite_sync_input_dma()
    
    `mite_sync_input_dma()` in the "mite" module currently takes a pointer
    to a `struct comedi_async` and gets a pointer to the owning `struct
    comedi_subdevice` from the `subdevice` member.  Change it to take a
    pointer to a `struct comedi_subdevice` and use the `async` member.
    
    The motivation for this is to eliminate the `subdevice` member of
    `struct comedi_async`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 9cc77c0b2f0f..2557ab48cb6c 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -464,7 +464,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		       counter->mite_chan->mite->mite_io_addr +
 		       MITE_CHOR(counter->mite_chan->channel));
 	}
-	mite_sync_input_dma(counter->mite_chan, s->async);
+	mite_sync_input_dma(counter->mite_chan, s);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
 EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);

commit 24e894bbf247ecdeed3ed2f77f658da756760f60
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:04 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_write_alloc()
    
    Change the parameters of `comedi_buf_write_alloc()` to pass a pointer to
    the comedi subdevice instead of a pointer to the "async" structure
    belonging to the subdevice.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 7a163fc31f5d..9cc77c0b2f0f 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -125,7 +125,7 @@ static int ni_tio_input_cmd(struct comedi_subdevice *s)
 	int retval = 0;
 
 	/* write alloc the entire buffer */
-	comedi_buf_write_alloc(async, async->prealloc_bufsz);
+	comedi_buf_write_alloc(s, async->prealloc_bufsz);
 	counter->mite_chan->dir = COMEDI_INPUT;
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_m_series:

commit 67ab76f0ce3b65f5b38501143e07a0b98ff93434
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:12:03 2014 +0100

    staging: comedi: ni_tiocmd: pass subdevice to command setup functions
    
    The `ni_tio_input_cmd()`, `ni_tio_output_cmd()` and `ni_tio_cmd_setup()`
    functions are called from `ni_tio_cmd()` to set up a comedi command.
    They currently get passed two parameters, a pointer to a `struct
    ni_gpct` and a pointer to a `struct comedi_async`, but both of those
    come from members of a `struct comedi_subdevice` (the former from the
    `private` member).  Replace the parameters with a pointer to the `struct
    comedi_subdevice`.
    
    The main motive is to make the comedi subdevice more easily available to
    the functions for the use of subsequent patches to remove the `struct
    comedi_async *` parameters from the comedi buffer handling functions.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index b9d23db4004b..7a163fc31f5d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -115,10 +115,12 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 	return retval;
 }
 
-static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
+static int ni_tio_input_cmd(struct comedi_subdevice *s)
 {
+	struct ni_gpct *counter = s->private;
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned cidx = counter->counter_index;
+	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int retval = 0;
 
@@ -164,9 +166,10 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	return retval;
 }
 
-static int ni_tio_output_cmd(struct ni_gpct *counter,
-			     struct comedi_async *async)
+static int ni_tio_output_cmd(struct comedi_subdevice *s)
 {
+	struct ni_gpct *counter = s->private;
+
 	dev_err(counter->counter_dev->dev->class_dev,
 		"output commands not yet implemented.\n");
 	return -ENOTSUPP;
@@ -178,9 +181,10 @@ static int ni_tio_output_cmd(struct ni_gpct *counter,
 	return ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
 }
 
-static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
+static int ni_tio_cmd_setup(struct comedi_subdevice *s)
 {
-	struct comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	struct ni_gpct *counter = s->private;
 	unsigned cidx = counter->counter_index;
 	int set_gate_source = 0;
 	unsigned gate_source;
@@ -219,12 +223,12 @@ int ni_tio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 			"Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
-		retval = ni_tio_cmd_setup(counter, async);
+		retval = ni_tio_cmd_setup(s);
 		if (retval == 0) {
 			if (cmd->flags & CMDF_WRITE)
-				retval = ni_tio_output_cmd(counter, async);
+				retval = ni_tio_output_cmd(s);
 			else
-				retval = ni_tio_input_cmd(counter, async);
+				retval = ni_tio_input_cmd(s);
 		}
 	}
 	spin_unlock_irqrestore(&counter->lock, flags);

commit 6a760394d7eb70a810bf472289473f915eb6da0d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:08:03 2014 -0700

    staging: comedi: ni_tiocmd: clarify the cmd->start_arg validation and use
    
    This driver supportes cmd->start_src sources of TRIG_NOW, TRIG_INT, TRIG_OTHER,
    and TRIG_EXT. Refactor the (*do_cmdtest) to clarify the trivial validation of
    the cmd->start_arg. For a TRIG_INT source, the cmd->start_arg is actually the
    valid trig_num that is passed to the async (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used to check
    the trig_num instead of the open coded value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 7d64f8892f08..b9d23db4004b 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -89,14 +89,16 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 
 static int ni_tio_input_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				unsigned int trignum)
+				unsigned int trig_num)
 {
+	struct ni_gpct *counter = s->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 	int retval = 0;
-	struct ni_gpct *counter = s->private;
 
 	BUG_ON(counter == NULL);
-	if (trignum != 0)
+
+	if (trig_num != cmd->start_src)
 		return -EINVAL;
 
 	spin_lock_irqsave(&counter->lock, flags);
@@ -271,8 +273,16 @@ int ni_tio_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_src != TRIG_EXT)
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+	case TRIG_INT:
+	case TRIG_OTHER:
 		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
+	case TRIG_EXT:
+		/* start_arg is the start_trigger passed to ni_tio_arm() */
+		break;
+	}
 
 	if (cmd->scan_begin_src != TRIG_EXT)
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);

commit 16cc181d630db4bd75b36979ffaef5d76017cd70
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:04 2013 -0700

    staging: comedi: ni_tiocmd: make ni_tio_cmd() a proper comedi (*do_cmd)
    
    Change the parameters to ni_tio_cmd() to make it a proper comedi
    (*do_cmd) function.
    
    The wrappers in the ni_660x and ni_mio_common modules are still needed
    to request the mite channel and setup the device before actually doing
    the command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 98be76496334..7d64f8892f08 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -201,8 +201,10 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 	return retval;
 }
 
-int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
+int ni_tio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_gpct *counter = s->private;
+	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	int retval = 0;
 	unsigned long flags;

commit c3f3b431dec0de741e35a93d506e439bef0bbb26
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:32:03 2013 -0700

    staging: comedi: ni_tiocmd: make ni_tio_cmdtest() a proper comedi (*do_cmdtest)
    
    Change the parameters to ni_tio_cmdtest() to make it a proper comedi
    (*do_cmdtest) function. This allows using it directly and removing the
    wrapper functions in the ni_660x and ni_mio_common modules.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 1ab542a6b07d..98be76496334 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -228,8 +228,11 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 }
 EXPORT_SYMBOL_GPL(ni_tio_cmd);
 
-int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
+int ni_tio_cmdtest(struct comedi_device *dev,
+		   struct comedi_subdevice *s,
+		   struct comedi_cmd *cmd)
 {
+	struct ni_gpct *counter = s->private;
 	int err = 0;
 	unsigned int sources;
 

commit cafa814958348058afb4f03fc96631cb7445616f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:56 2013 -0700

    staging: comedi: ni_tiocmd: move the MODULE_* stuff to the end of file
    
    For aesthetics, move all the MODULE_* information to the end of the file.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 473b6e0001db..1ab542a6b07d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -49,10 +49,6 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 #include "ni_tio_internal.h"
 #include "mite.h"
 
-MODULE_AUTHOR("Comedi <comedi@comedi.org>");
-MODULE_DESCRIPTION("Comedi command support for NI general-purpose counters");
-MODULE_LICENSE("GPL");
-
 static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 				 short read_not_write)
 {
@@ -469,11 +465,13 @@ static int __init ni_tiocmd_init_module(void)
 {
 	return 0;
 }
-
 module_init(ni_tiocmd_init_module);
 
 static void __exit ni_tiocmd_cleanup_module(void)
 {
 }
-
 module_exit(ni_tiocmd_cleanup_module);
+
+MODULE_AUTHOR("Comedi <comedi@comedi.org>");
+MODULE_DESCRIPTION("Comedi command support for NI general-purpose counters");
+MODULE_LICENSE("GPL");

commit 5382bfb9788822a9d470ab777f34ad62d0b97224
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:54 2013 -0700

    staging: comedi: ni_tiocmd: use a local var for the 'counter_index'
    
    Use a local variable for the 'counter->counter_index' to help shorten the
    long lines and ugly line breaks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 290fd073de7c..473b6e0001db 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -57,6 +57,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 				 short read_not_write)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 	unsigned input_select_bits = 0;
 
 	if (enable) {
@@ -65,8 +66,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 		else
 			input_select_bits |= Gi_Write_Acknowledges_Irq;
 	}
-	ni_tio_set_bits(counter,
-			NITIO_INPUT_SEL_REG(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),
 			Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
 			input_select_bits);
 	switch (counter_dev->variant) {
@@ -83,9 +83,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 			}
 			if (read_not_write == 0)
 				gi_dma_config_bits |= Gi_DMA_Write_Bit;
-			ni_tio_set_bits(counter,
-					NITIO_DMA_CFG_REG(counter->
-								counter_index),
+			ni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx),
 					Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
 					Gi_DMA_Write_Bit, gi_dma_config_bits);
 		}
@@ -122,6 +120,7 @@ static int ni_tio_input_inttrig(struct comedi_device *dev,
 static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned cidx = counter->counter_index;
 	struct comedi_cmd *cmd = &async->cmd;
 	int retval = 0;
 
@@ -140,8 +139,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 		BUG();
 		break;
 	}
-	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
-			Gi_Save_Trace_Bit, 0);
+	ni_tio_set_bits(counter, NITIO_CMD_REG(cidx), Gi_Save_Trace_Bit, 0);
 	ni_tio_configure_dma(counter, 1, 1);
 	switch (cmd->start_src) {
 	case TRIG_NOW:
@@ -185,6 +183,7 @@ static int ni_tio_output_cmd(struct ni_gpct *counter,
 static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 {
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned cidx = counter->counter_index;
 	int set_gate_source = 0;
 	unsigned gate_source;
 	int retval = 0;
@@ -199,13 +198,9 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 	if (set_gate_source)
 		retval = ni_tio_set_gate_src(counter, 0, gate_source);
 	if (cmd->flags & TRIG_WAKE_EOS) {
-		ni_tio_set_bits(counter,
-				NITIO_INT_ENA_REG(counter->
-							      counter_index),
-				Gi_Gate_Interrupt_Enable_Bit(counter->
-							     counter_index),
-				Gi_Gate_Interrupt_Enable_Bit(counter->
-							     counter_index));
+		ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
+				Gi_Gate_Interrupt_Enable_Bit(cidx),
+				Gi_Gate_Interrupt_Enable_Bit(cidx));
 	}
 	return retval;
 }
@@ -301,6 +296,7 @@ EXPORT_SYMBOL_GPL(ni_tio_cmdtest);
 
 int ni_tio_cancel(struct ni_gpct *counter)
 {
+	unsigned cidx = counter->counter_index;
 	unsigned long flags;
 
 	ni_tio_arm(counter, 0, 0);
@@ -310,10 +306,8 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	spin_unlock_irqrestore(&counter->lock, flags);
 	ni_tio_configure_dma(counter, 0, 0);
 
-	ni_tio_set_bits(counter,
-			NITIO_INT_ENA_REG(counter->counter_index),
-			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
-			0x0);
+	ni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),
+			Gi_Gate_Interrupt_Enable_Bit(cidx), 0x0);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ni_tio_cancel);
@@ -353,14 +347,11 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				    int *tc_error, int *perm_stale_data,
 				    int *stale_data)
 {
+	unsigned cidx = counter->counter_index;
 	const unsigned short gxx_status = read_register(counter,
-							NITIO_SHARED_STATUS_REG
-							(counter->
-							 counter_index));
+						NITIO_SHARED_STATUS_REG(cidx));
 	const unsigned short gi_status = read_register(counter,
-						       NITIO_STATUS_REG
-						       (counter->
-							counter_index));
+						NITIO_STATUS_REG(cidx));
 	unsigned ack = 0;
 
 	if (gate_error)
@@ -372,8 +363,8 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	if (stale_data)
 		*stale_data = 0;
 
-	if (gxx_status & Gi_Gate_Error_Bit(counter->counter_index)) {
-		ack |= Gi_Gate_Error_Confirm_Bit(counter->counter_index);
+	if (gxx_status & Gi_Gate_Error_Bit(cidx)) {
+		ack |= Gi_Gate_Error_Confirm_Bit(cidx);
 		if (gate_error) {
 			/*660x don't support automatic acknowledgement
 			  of gate interrupt via dma read/write
@@ -384,8 +375,8 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 			}
 		}
 	}
-	if (gxx_status & Gi_TC_Error_Bit(counter->counter_index)) {
-		ack |= Gi_TC_Error_Confirm_Bit(counter->counter_index);
+	if (gxx_status & Gi_TC_Error_Bit(cidx)) {
+		ack |= Gi_TC_Error_Confirm_Bit(cidx);
 		if (tc_error)
 			*tc_error = 1;
 	}
@@ -396,21 +387,15 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 			ack |= Gi_Gate_Interrupt_Ack_Bit;
 	}
 	if (ack)
-		write_register(counter, ack,
-			       NITIO_INT_ACK_REG
-			       (counter->counter_index));
-	if (ni_tio_get_soft_copy
-	    (counter,
-	     NITIO_MODE_REG(counter->counter_index)) &
+		write_register(counter, ack, NITIO_INT_ACK_REG(cidx));
+	if (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &
 	    Gi_Loading_On_Gate_Bit) {
-		if (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {
+		if (gxx_status & Gi_Stale_Data_Bit(cidx)) {
 			if (stale_data)
 				*stale_data = 1;
 		}
-		if (read_register(counter,
-				  NITIO_STATUS2_REG
-				  (counter->counter_index)) &
-		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
+		if (read_register(counter, NITIO_STATUS2_REG(cidx)) &
+		    Gi_Permanent_Stale_Bit(cidx)) {
 			dev_info(counter->counter_dev->dev->class_dev,
 				 "%s: Gi_Permanent_Stale_Data detected.\n",
 				 __func__);
@@ -424,6 +409,7 @@ EXPORT_SYMBOL_GPL(ni_tio_acknowledge_and_confirm);
 void ni_tio_handle_interrupt(struct ni_gpct *counter,
 			     struct comedi_subdevice *s)
 {
+	unsigned cidx = counter->counter_index;
 	unsigned gpct_mite_status;
 	unsigned long flags;
 	int gate_error;
@@ -442,9 +428,8 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
-		if (read_register(counter,
-				NITIO_DMA_STATUS_REG
-				(counter->counter_index)) & Gi_DRQ_Error_Bit) {
+		if (read_register(counter, NITIO_DMA_STATUS_REG(cidx)) &
+		    Gi_DRQ_Error_Bit) {
 			dev_notice(counter->counter_dev->dev->class_dev,
 				   "%s: Gi_DRQ_Error detected.\n", __func__);
 			s->async->events |= COMEDI_CB_OVERFLOW;

commit 94baf025ba41136eb4e9e858ebdbad33a6b3c539
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:52 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Interrupt_Enable_Reg()
    
    The "Interrupt Enable" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index e7cff8dff574..290fd073de7c 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -200,7 +200,7 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 		retval = ni_tio_set_gate_src(counter, 0, gate_source);
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		ni_tio_set_bits(counter,
-				NITIO_Gi_Interrupt_Enable_Reg(counter->
+				NITIO_INT_ENA_REG(counter->
 							      counter_index),
 				Gi_Gate_Interrupt_Enable_Bit(counter->
 							     counter_index),
@@ -311,7 +311,7 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			NITIO_INT_ENA_REG(counter->counter_index),
 			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
 			0x0);
 	return 0;

commit c9d766d04ab032943c0fa68ddc6434ca1fe2c9f8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:51 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Status_Reg()
    
    The "Status" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Rename the define for the shared status register.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 4f59f5a06c75..e7cff8dff574 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -354,11 +354,11 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				    int *stale_data)
 {
 	const unsigned short gxx_status = read_register(counter,
-							NITIO_STATUS_REG
+							NITIO_SHARED_STATUS_REG
 							(counter->
 							 counter_index));
 	const unsigned short gi_status = read_register(counter,
-						       NITIO_Gi_Status_Reg
+						       NITIO_STATUS_REG
 						       (counter->
 							counter_index));
 	unsigned ack = 0;

commit e72ccb041bc1d068ae216c7fa6513d70c075d440
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:50 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Interrupt_Acknowledge_Reg()
    
    The "Interrupt Acknowledge" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index e43dd17bb45d..4f59f5a06c75 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -397,7 +397,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	}
 	if (ack)
 		write_register(counter, ack,
-			       NITIO_Gi_Interrupt_Acknowledge_Reg
+			       NITIO_INT_ACK_REG
 			       (counter->counter_index));
 	if (ni_tio_get_soft_copy
 	    (counter,

commit 8cd3936e974916238a2f7e10c635c63befa5dfe6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:48 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_DMA_Status_Reg()
    
    The "DMA Status" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 68ffa742427e..e43dd17bb45d 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -443,7 +443,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		if (read_register(counter,
-				NITIO_Gi_DMA_Status_Reg
+				NITIO_DMA_STATUS_REG
 				(counter->counter_index)) & Gi_DRQ_Error_Bit) {
 			dev_notice(counter->counter_dev->dev->class_dev,
 				   "%s: Gi_DRQ_Error detected.\n", __func__);

commit 1dd26c2152502b4521d4c7d3aad07ed4eda5705f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:47 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_DMA_Config_Reg()
    
    The "DMA Config" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index bfae717da31f..68ffa742427e 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -84,7 +84,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 			if (read_not_write == 0)
 				gi_dma_config_bits |= Gi_DMA_Write_Bit;
 			ni_tio_set_bits(counter,
-					NITIO_Gi_DMA_Config_Reg(counter->
+					NITIO_DMA_CFG_REG(counter->
 								counter_index),
 					Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
 					Gi_DMA_Write_Bit, gi_dma_config_bits);

commit 5f19efaca687de6c9f12def06b14eb6c1cd79ee8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:46 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gxx_Joint_Status2_Reg()
    
    The shared "Status2" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 0ffb3a4c2a65..bfae717da31f 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -408,7 +408,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				*stale_data = 1;
 		}
 		if (read_register(counter,
-				  NITIO_Gxx_Joint_Status2_Reg
+				  NITIO_STATUS2_REG
 				  (counter->counter_index)) &
 		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
 			dev_info(counter->counter_dev->dev->class_dev,

commit 96b6175aa32385db609c706f2c78b14ac515e926
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:43 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gxx_Status_Reg()
    
    The shared "Status" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index b3dad4f91656..0ffb3a4c2a65 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -354,7 +354,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				    int *stale_data)
 {
 	const unsigned short gxx_status = read_register(counter,
-							NITIO_Gxx_Status_Reg
+							NITIO_STATUS_REG
 							(counter->
 							 counter_index));
 	const unsigned short gi_status = read_register(counter,

commit 3da68f50f2a1eaa8d9e5bf1e354eb14c0da1375d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:40 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Input_Select_Reg()
    
    The "Input Select" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index b78103d6c5e1..b3dad4f91656 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -66,7 +66,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 			input_select_bits |= Gi_Write_Acknowledges_Irq;
 	}
 	ni_tio_set_bits(counter,
-			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			NITIO_INPUT_SEL_REG(counter->counter_index),
 			Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
 			input_select_bits);
 	switch (counter_dev->variant) {

commit 0101791e83cbd9076c34bf138d1407442dfdf95f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:37 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Mode_Reg()
    
    The "Mode" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 4fb4df09dd33..b78103d6c5e1 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -401,7 +401,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 			       (counter->counter_index));
 	if (ni_tio_get_soft_copy
 	    (counter,
-	     NITIO_Gi_Mode_Reg(counter->counter_index)) &
+	     NITIO_MODE_REG(counter->counter_index)) &
 	    Gi_Loading_On_Gate_Bit) {
 		if (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {
 			if (stale_data)

commit e25ef744460ca114c9f4cd5178932135c760f456
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 19 16:31:35 2013 -0700

    staging: comedi: ni_tio_internal.h: replace NITIO_Gi_Command_Reg()
    
    The "Command" registers are sequential in the enum ni_gpct_register.
    Replace this inline CamelCase function with a simple define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 45691efefd05..4fb4df09dd33 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -140,7 +140,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 		BUG();
 		break;
 	}
-	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+	ni_tio_set_bits(counter, NITIO_CMD_REG(counter->counter_index),
 			Gi_Save_Trace_Bit, 0);
 	ni_tio_configure_dma(counter, 1, 1);
 	switch (cmd->start_src) {

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index cff50bc45bcd..45691efefd05 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -44,6 +44,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 	Support use of both banks X and Y
 */
 
+#include <linux/module.h>
 #include "comedi_fc.h"
 #include "ni_tio_internal.h"
 #include "mite.h"

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 13747f324936..cff50bc45bcd 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -13,10 +13,6 @@
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*

commit 8841d798f42430133a7874430ac634347b31fce5
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sun Jan 13 23:05:05 2013 +0300

    Staging: comedi: add a missing break statement
    
    This is a static checker fix.  From the context it looks like there
    should be a break here.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 0c991b99da13..13747f324936 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -159,6 +159,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 		async->inttrig = NULL;
 		mite_dma_arm(counter->mite_chan);
 		retval = ni_tio_arm(counter, 1, cmd->start_arg);
+		break;
 	case TRIG_OTHER:
 		async->inttrig = NULL;
 		mite_dma_arm(counter->mite_chan);

commit aadd0132c5ac794415690b5ef95fd4da986fec78
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:57:27 2012 -0700

    staging: comedi: ni_tiocmd: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of ni_tio_cmdtest().
    
    Note that cmd->stop_src only has one trigger source so the extra
    test is not required.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 11a377a6c27c..0c991b99da13 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -275,37 +275,19 @@ int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
-	if (cmd->start_src != TRIG_EXT) {
-		if (cmd->start_arg != 0) {
-			cmd->start_arg = 0;
-			err++;
-		}
-	}
-	if (cmd->scan_begin_src != TRIG_EXT) {
-		if (cmd->scan_begin_arg) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
-	if (cmd->convert_src != TRIG_EXT) {
-		if (cmd->convert_arg) {
-			cmd->convert_arg = 0;
-			err++;
-		}
-	}
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	if (cmd->start_src != TRIG_EXT)
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->stop_src == TRIG_NONE) {
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src != TRIG_EXT)
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+
+	if (cmd->convert_src != TRIG_EXT)
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit bb29ea142d0e990b6c54d18860b7f7d4a5a5a337
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Fri Nov 2 13:55:48 2012 +0900

    staging/comedi: Use dev_ printks in ni_tiocmd.c
    
    fixed below checkpatch warnings.
    - WARNING: Prefer netdev_err(netdev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    - WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    - WARNING: Prefer netdev_notice(netdev, ... then dev_notice(dev, ... then pr_notice(...  to printk(KERN_NOTICE ...
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 8ee93d359bed..11a377a6c27c 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -173,7 +173,8 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 static int ni_tio_output_cmd(struct ni_gpct *counter,
 			     struct comedi_async *async)
 {
-	printk(KERN_ERR "ni_tio: output commands not yet implemented.\n");
+	dev_err(counter->counter_dev->dev->class_dev,
+		"output commands not yet implemented.\n");
 	return -ENOTSUPP;
 
 	counter->mite_chan->dir = COMEDI_OUTPUT;
@@ -219,7 +220,10 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		printk(KERN_ERR "ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
+		dev_err(counter->counter_dev->dev->class_dev,
+			"commands only supported with DMA.  ");
+		dev_err(counter->counter_dev->dev->class_dev,
+			"Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
 		retval = ni_tio_cmd_setup(counter, async);
@@ -427,8 +431,9 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				  NITIO_Gxx_Joint_Status2_Reg
 				  (counter->counter_index)) &
 		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
-			printk(KERN_INFO "%s: Gi_Permanent_Stale_Data detected.\n",
-			       __func__);
+			dev_info(counter->counter_dev->dev->class_dev,
+				 "%s: Gi_Permanent_Stale_Data detected.\n",
+				 __func__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
 		}
@@ -448,7 +453,8 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
 				       &perm_stale_data, NULL);
 	if (gate_error) {
-		printk(KERN_NOTICE "%s: Gi_Gate_Error detected.\n", __func__);
+		dev_notice(counter->counter_dev->dev->class_dev,
+			   "%s: Gi_Gate_Error detected.\n", __func__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (perm_stale_data)
@@ -459,8 +465,8 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 		if (read_register(counter,
 				NITIO_Gi_DMA_Status_Reg
 				(counter->counter_index)) & Gi_DRQ_Error_Bit) {
-			printk(KERN_NOTICE "%s: Gi_DRQ_Error detected.\n",
-							__func__);
+			dev_notice(counter->counter_dev->dev->class_dev,
+				   "%s: Gi_DRQ_Error detected.\n", __func__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 		break;

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index a9611587460a..8ee93d359bed 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -48,6 +48,7 @@ DAQ 6601/6602 User Manual (NI 322137B-01)
 	Support use of both banks X and Y
 */
 
+#include "comedi_fc.h"
 #include "ni_tio_internal.h"
 #include "mite.h"
 
@@ -237,61 +238,35 @@ EXPORT_SYMBOL_GPL(ni_tio_cmd);
 int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
-	int sources;
+	unsigned int sources;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
 	sources = TRIG_NOW | TRIG_INT | TRIG_OTHER;
 	if (ni_tio_counting_mode_registers_present(counter->counter_dev))
 		sources |= TRIG_EXT;
-	cmd->start_src &= sources;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_EXT | TRIG_OTHER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	sources = TRIG_NOW | TRIG_EXT | TRIG_OTHER;
-	cmd->convert_src &= sources;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, sources);
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_FOLLOW | TRIG_EXT | TRIG_OTHER);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_NOW | TRIG_EXT | TRIG_OTHER);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique... */
+	/* Step 2a : make sure trigger sources are unique */
+
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+
+	/* Step 2b : and mutually compatible */
 
-	if (cmd->start_src != TRIG_NOW &&
-	    cmd->start_src != TRIG_INT &&
-	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
-		err++;
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT &&
-	    cmd->scan_begin_src != TRIG_OTHER)
-		err++;
-	if (cmd->convert_src != TRIG_OTHER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_NONE)
-		err++;
-	/* ... and mutually compatible */
 	if (cmd->convert_src != TRIG_NOW && cmd->scan_begin_src != TRIG_FOLLOW)
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;

commit ed271e049d4e0bf8c6586c9626964a01d1c62fa2
Author: Xenofon Foukas <foukas.xenofon@gmail.com>
Date:   Fri Dec 10 21:07:25 2010 +0200

    Staging: comedi: Fix coding style issues in ni_tiocmd.c
    
    This patch fixes the following issues in ni_tiocmd.c:
    
    WARNING: braces {} are not necessary for any arm of this statement
    WARNING: braces {} are not necessary for single statement blocks
    WARNING: printk() should include KERN_ facility level
    WARNING: line over 80 characters
    __func__ should be used instead of gcc specific __FUNCTION__
    ERROR: that open brace { should be on the previous line
    WARNING: EXPORT_SYMBOL(foo); should immediately follow its function/variable
    
    Signed-off-by: Xenofon Foukas <foukas.xenofon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index b0d44b547a69..a9611587460a 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -62,11 +62,10 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 	unsigned input_select_bits = 0;
 
 	if (enable) {
-		if (read_not_write) {
+		if (read_not_write)
 			input_select_bits |= Gi_Read_Acknowledges_Irq;
-		} else {
+		else
 			input_select_bits |= Gi_Write_Acknowledges_Irq;
-		}
 	}
 	ni_tio_set_bits(counter,
 			NITIO_Gi_Input_Select_Reg(counter->counter_index),
@@ -84,9 +83,8 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 				gi_dma_config_bits |= Gi_DMA_Enable_Bit;
 				gi_dma_config_bits |= Gi_DMA_Int_Bit;
 			}
-			if (read_not_write == 0) {
+			if (read_not_write == 0)
 				gi_dma_config_bits |= Gi_DMA_Write_Bit;
-			}
 			ni_tio_set_bits(counter,
 					NITIO_Gi_DMA_Config_Reg(counter->
 								counter_index),
@@ -174,7 +172,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 static int ni_tio_output_cmd(struct ni_gpct *counter,
 			     struct comedi_async *async)
 {
-	printk("ni_tio: output commands not yet implemented.\n");
+	printk(KERN_ERR "ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
 
 	counter->mite_chan->dir = COMEDI_OUTPUT;
@@ -198,9 +196,8 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 		set_gate_source = 1;
 		gate_source = cmd->convert_arg;
 	}
-	if (set_gate_source) {
+	if (set_gate_source)
 		retval = ni_tio_set_gate_src(counter, 0, gate_source);
-	}
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		ni_tio_set_bits(counter,
 				NITIO_Gi_Interrupt_Enable_Reg(counter->
@@ -221,22 +218,21 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		printk
-		    ("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
+		printk(KERN_ERR "ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
 		retval = ni_tio_cmd_setup(counter, async);
 		if (retval == 0) {
-			if (cmd->flags & CMDF_WRITE) {
+			if (cmd->flags & CMDF_WRITE)
 				retval = ni_tio_output_cmd(counter, async);
-			} else {
+			else
 				retval = ni_tio_input_cmd(counter, async);
-			}
 		}
 	}
 	spin_unlock_irqrestore(&counter->lock, flags);
 	return retval;
 }
+EXPORT_SYMBOL_GPL(ni_tio_cmd);
 
 int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 {
@@ -342,6 +338,7 @@ int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_cmdtest);
 
 int ni_tio_cancel(struct ni_gpct *counter)
 {
@@ -349,9 +346,8 @@ int ni_tio_cancel(struct ni_gpct *counter)
 
 	ni_tio_arm(counter, 0, 0);
 	spin_lock_irqsave(&counter->lock, flags);
-	if (counter->mite_chan) {
+	if (counter->mite_chan)
 		mite_dma_disarm(counter->mite_chan);
-	}
 	spin_unlock_irqrestore(&counter->lock, flags);
 	ni_tio_configure_dma(counter, 0, 0);
 
@@ -361,10 +357,11 @@ int ni_tio_cancel(struct ni_gpct *counter)
 			0x0);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ni_tio_cancel);
 
-	/* During buffered input counter operation for e-series, the gate interrupt is acked
-	   automatically by the dma controller, due to the Gi_Read/Write_Acknowledges_IRQ bits
-	   in the input select register.  */
+	/* During buffered input counter operation for e-series, the gate
+	   interrupt is acked automatically by the dma controller, due to the
+	   Gi_Read/Write_Acknowledges_IRQ bits in the input select register.  */
 static int should_ack_gate(struct ni_gpct *counter)
 {
 	unsigned long flags;
@@ -372,7 +369,10 @@ static int should_ack_gate(struct ni_gpct *counter)
 
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
-	case ni_gpct_variant_660x:	/*  not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual) */
+	/*  not sure if 660x really supports gate
+	    interrupts (the bits are not listed
+	    in register-level manual) */
+	case ni_gpct_variant_660x:
 		return 1;
 		break;
 	case ni_gpct_variant_e_series:
@@ -416,7 +416,8 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	if (gxx_status & Gi_Gate_Error_Bit(counter->counter_index)) {
 		ack |= Gi_Gate_Error_Confirm_Bit(counter->counter_index);
 		if (gate_error) {
-			/*660x don't support automatic acknowledgement of gate interrupt via dma read/write
+			/*660x don't support automatic acknowledgement
+			  of gate interrupt via dma read/write
 			   and report bogus gate errors */
 			if (counter->counter_dev->variant !=
 			    ni_gpct_variant_660x) {
@@ -429,9 +430,8 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 		if (tc_error)
 			*tc_error = 1;
 	}
-	if (gi_status & Gi_TC_Bit) {
+	if (gi_status & Gi_TC_Bit)
 		ack |= Gi_TC_Interrupt_Ack_Bit;
-	}
 	if (gi_status & Gi_Gate_Interrupt_Bit) {
 		if (should_ack_gate(counter))
 			ack |= Gi_Gate_Interrupt_Ack_Bit;
@@ -452,13 +452,14 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				  NITIO_Gxx_Joint_Status2_Reg
 				  (counter->counter_index)) &
 		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
-			printk("%s: Gi_Permanent_Stale_Data detected.\n",
-			       __FUNCTION__);
+			printk(KERN_INFO "%s: Gi_Permanent_Stale_Data detected.\n",
+			       __func__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
 		}
 	}
 }
+EXPORT_SYMBOL_GPL(ni_tio_acknowledge_and_confirm);
 
 void ni_tio_handle_interrupt(struct ni_gpct *counter,
 			     struct comedi_subdevice *s)
@@ -472,20 +473,19 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
 				       &perm_stale_data, NULL);
 	if (gate_error) {
-		printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
+		printk(KERN_NOTICE "%s: Gi_Gate_Error detected.\n", __func__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
-	if (perm_stale_data) {
+	if (perm_stale_data)
 		s->async->events |= COMEDI_CB_ERROR;
-	}
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		if (read_register(counter,
-				  NITIO_Gi_DMA_Status_Reg
-				  (counter->counter_index)) & Gi_DRQ_Error_Bit)
-		{
-			printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
+				NITIO_Gi_DMA_Status_Reg
+				(counter->counter_index)) & Gi_DRQ_Error_Bit) {
+			printk(KERN_NOTICE "%s: Gi_DRQ_Error detected.\n",
+							__func__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 		break;
@@ -506,6 +506,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter,
 	mite_sync_input_dma(counter->mite_chan, s->async);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
+EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);
 
 void ni_tio_set_mite_channel(struct ni_gpct *counter,
 			     struct mite_channel *mite_chan)
@@ -516,6 +517,7 @@ void ni_tio_set_mite_channel(struct ni_gpct *counter,
 	counter->mite_chan = mite_chan;
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
+EXPORT_SYMBOL_GPL(ni_tio_set_mite_channel);
 
 static int __init ni_tiocmd_init_module(void)
 {
@@ -529,10 +531,3 @@ static void __exit ni_tiocmd_cleanup_module(void)
 }
 
 module_exit(ni_tiocmd_cleanup_module);
-
-EXPORT_SYMBOL_GPL(ni_tio_cmd);
-EXPORT_SYMBOL_GPL(ni_tio_cmdtest);
-EXPORT_SYMBOL_GPL(ni_tio_cancel);
-EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);
-EXPORT_SYMBOL_GPL(ni_tio_set_mite_channel);
-EXPORT_SYMBOL_GPL(ni_tio_acknowledge_and_confirm);

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 5be1e1a62c0a..b0d44b547a69 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -56,7 +56,7 @@ MODULE_DESCRIPTION("Comedi command support for NI general-purpose counters");
 MODULE_LICENSE("GPL");
 
 static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
-	short read_not_write)
+				 short read_not_write)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	unsigned input_select_bits = 0;
@@ -69,9 +69,9 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 		}
 	}
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Input_Select_Reg(counter->counter_index),
-		Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
-		input_select_bits);
+			NITIO_Gi_Input_Select_Reg(counter->counter_index),
+			Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
+			input_select_bits);
 	switch (counter_dev->variant) {
 	case ni_gpct_variant_e_series:
 		break;
@@ -88,16 +88,18 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 				gi_dma_config_bits |= Gi_DMA_Write_Bit;
 			}
 			ni_tio_set_bits(counter,
-				NITIO_Gi_DMA_Config_Reg(counter->counter_index),
-				Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
-				Gi_DMA_Write_Bit, gi_dma_config_bits);
+					NITIO_Gi_DMA_Config_Reg(counter->
+								counter_index),
+					Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
+					Gi_DMA_Write_Bit, gi_dma_config_bits);
 		}
 		break;
 	}
 }
 
-static int ni_tio_input_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+static int ni_tio_input_inttrig(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int trignum)
 {
 	unsigned long flags;
 	int retval = 0;
@@ -143,7 +145,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 		break;
 	}
 	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
-		Gi_Save_Trace_Bit, 0);
+			Gi_Save_Trace_Bit, 0);
 	ni_tio_configure_dma(counter, 1, 1);
 	switch (cmd->start_src) {
 	case TRIG_NOW:
@@ -169,7 +171,8 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	return retval;
 }
 
-static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async)
+static int ni_tio_output_cmd(struct ni_gpct *counter,
+			     struct comedi_async *async)
 {
 	printk("ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
@@ -200,9 +203,12 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 	}
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		ni_tio_set_bits(counter,
-			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
-			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
-			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index));
+				NITIO_Gi_Interrupt_Enable_Reg(counter->
+							      counter_index),
+				Gi_Gate_Interrupt_Enable_Bit(counter->
+							     counter_index),
+				Gi_Gate_Interrupt_Enable_Bit(counter->
+							     counter_index));
 	}
 	return retval;
 }
@@ -216,7 +222,7 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
 		printk
-			("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
+		    ("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
 		retval = ni_tio_cmd_setup(counter, async);
@@ -232,7 +238,7 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	return retval;
 }
 
-int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd * cmd)
+int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -275,15 +281,15 @@ int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd * cmd)
 	/* step 2: make sure trigger sources are unique... */
 
 	if (cmd->start_src != TRIG_NOW &&
-		cmd->start_src != TRIG_INT &&
-		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
+	    cmd->start_src != TRIG_INT &&
+	    cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT &&
-		cmd->scan_begin_src != TRIG_OTHER)
+	    cmd->scan_begin_src != TRIG_EXT &&
+	    cmd->scan_begin_src != TRIG_OTHER)
 		err++;
 	if (cmd->convert_src != TRIG_OTHER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_NONE)
 		err++;
@@ -350,8 +356,9 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter,
-		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
-		Gi_Gate_Interrupt_Enable_Bit(counter->counter_index), 0x0);
+			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
+			0x0);
 	return 0;
 }
 
@@ -372,8 +379,8 @@ static int should_ack_gate(struct ni_gpct *counter)
 		spin_lock_irqsave(&counter->lock, flags);
 		{
 			if (counter->mite_chan == NULL ||
-				counter->mite_chan->dir != COMEDI_INPUT ||
-				(mite_done(counter->mite_chan))) {
+			    counter->mite_chan->dir != COMEDI_INPUT ||
+			    (mite_done(counter->mite_chan))) {
 				retval = 1;
 			}
 		}
@@ -384,12 +391,17 @@ static int should_ack_gate(struct ni_gpct *counter)
 }
 
 void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
-	int *tc_error, int *perm_stale_data, int *stale_data)
+				    int *tc_error, int *perm_stale_data,
+				    int *stale_data)
 {
 	const unsigned short gxx_status = read_register(counter,
-		NITIO_Gxx_Status_Reg(counter->counter_index));
+							NITIO_Gxx_Status_Reg
+							(counter->
+							 counter_index));
 	const unsigned short gi_status = read_register(counter,
-		NITIO_Gi_Status_Reg(counter->counter_index));
+						       NITIO_Gi_Status_Reg
+						       (counter->
+							counter_index));
 	unsigned ack = 0;
 
 	if (gate_error)
@@ -407,7 +419,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 			/*660x don't support automatic acknowledgement of gate interrupt via dma read/write
 			   and report bogus gate errors */
 			if (counter->counter_dev->variant !=
-				ni_gpct_variant_660x) {
+			    ni_gpct_variant_660x) {
 				*gate_error = 1;
 			}
 		}
@@ -426,28 +438,30 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	}
 	if (ack)
 		write_register(counter, ack,
-			NITIO_Gi_Interrupt_Acknowledge_Reg(counter->
-				counter_index));
-	if (ni_tio_get_soft_copy(counter,
-			NITIO_Gi_Mode_Reg(counter->
-				counter_index)) & Gi_Loading_On_Gate_Bit) {
+			       NITIO_Gi_Interrupt_Acknowledge_Reg
+			       (counter->counter_index));
+	if (ni_tio_get_soft_copy
+	    (counter,
+	     NITIO_Gi_Mode_Reg(counter->counter_index)) &
+	    Gi_Loading_On_Gate_Bit) {
 		if (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {
 			if (stale_data)
 				*stale_data = 1;
 		}
 		if (read_register(counter,
-				NITIO_Gxx_Joint_Status2_Reg(counter->
-					counter_index)) &
-			Gi_Permanent_Stale_Bit(counter->counter_index)) {
+				  NITIO_Gxx_Joint_Status2_Reg
+				  (counter->counter_index)) &
+		    Gi_Permanent_Stale_Bit(counter->counter_index)) {
 			printk("%s: Gi_Permanent_Stale_Data detected.\n",
-				__FUNCTION__);
+			       __FUNCTION__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
 		}
 	}
 }
 
-void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice * s)
+void ni_tio_handle_interrupt(struct ni_gpct *counter,
+			     struct comedi_subdevice *s)
 {
 	unsigned gpct_mite_status;
 	unsigned long flags;
@@ -456,7 +470,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 	int perm_stale_data;
 
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
-		&perm_stale_data, NULL);
+				       &perm_stale_data, NULL);
 	if (gate_error) {
 		printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
@@ -468,8 +482,9 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 	case ni_gpct_variant_m_series:
 	case ni_gpct_variant_660x:
 		if (read_register(counter,
-				NITIO_Gi_DMA_Status_Reg(counter->
-					counter_index)) & Gi_DRQ_Error_Bit) {
+				  NITIO_Gi_DMA_Status_Reg
+				  (counter->counter_index)) & Gi_DRQ_Error_Bit)
+		{
 			printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
@@ -485,15 +500,15 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 	gpct_mite_status = mite_get_status(counter->mite_chan);
 	if (gpct_mite_status & CHSR_LINKC) {
 		writel(CHOR_CLRLC,
-			counter->mite_chan->mite->mite_io_addr +
-			MITE_CHOR(counter->mite_chan->channel));
+		       counter->mite_chan->mite->mite_io_addr +
+		       MITE_CHOR(counter->mite_chan->channel));
 	}
 	mite_sync_input_dma(counter->mite_chan, s->async);
 	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 void ni_tio_set_mite_channel(struct ni_gpct *counter,
-	struct mite_channel *mite_chan)
+			     struct mite_channel *mite_chan)
 {
 	unsigned long flags;
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index fcf4eb6cdf60..5be1e1a62c0a 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -107,12 +107,12 @@ static int ni_tio_input_inttrig(struct comedi_device *dev, struct comedi_subdevi
 	if (trignum != 0)
 		return -EINVAL;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan)
 		mite_dma_arm(counter->mite_chan);
 	else
 		retval = -EIO;
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	if (retval < 0)
 		return retval;
 	retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
@@ -171,7 +171,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 
 static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
-	rt_printk("ni_tio: output commands not yet implemented.\n");
+	printk("ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
 
 	counter->mite_chan->dir = COMEDI_OUTPUT;
@@ -213,9 +213,9 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	int retval = 0;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		rt_printk
+		printk
 			("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
 		retval = -EIO;
 	} else {
@@ -228,7 +228,7 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	return retval;
 }
 
@@ -342,11 +342,11 @@ int ni_tio_cancel(struct ni_gpct *counter)
 	unsigned long flags;
 
 	ni_tio_arm(counter, 0, 0);
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan) {
 		mite_dma_disarm(counter->mite_chan);
 	}
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 	ni_tio_configure_dma(counter, 0, 0);
 
 	ni_tio_set_bits(counter,
@@ -369,7 +369,7 @@ static int should_ack_gate(struct ni_gpct *counter)
 		return 1;
 		break;
 	case ni_gpct_variant_e_series:
-		comedi_spin_lock_irqsave(&counter->lock, flags);
+		spin_lock_irqsave(&counter->lock, flags);
 		{
 			if (counter->mite_chan == NULL ||
 				counter->mite_chan->dir != COMEDI_INPUT ||
@@ -377,7 +377,7 @@ static int should_ack_gate(struct ni_gpct *counter)
 				retval = 1;
 			}
 		}
-		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		spin_unlock_irqrestore(&counter->lock, flags);
 		break;
 	}
 	return retval;
@@ -439,7 +439,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 				NITIO_Gxx_Joint_Status2_Reg(counter->
 					counter_index)) &
 			Gi_Permanent_Stale_Bit(counter->counter_index)) {
-			rt_printk("%s: Gi_Permanent_Stale_Data detected.\n",
+			printk("%s: Gi_Permanent_Stale_Data detected.\n",
 				__FUNCTION__);
 			if (perm_stale_data)
 				*perm_stale_data = 1;
@@ -458,7 +458,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
 		&perm_stale_data, NULL);
 	if (gate_error) {
-		rt_printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
+		printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 	}
 	if (perm_stale_data) {
@@ -470,16 +470,16 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 		if (read_register(counter,
 				NITIO_Gi_DMA_Status_Reg(counter->
 					counter_index)) & Gi_DRQ_Error_Bit) {
-			rt_printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
+			printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
 			s->async->events |= COMEDI_CB_OVERFLOW;
 		}
 		break;
 	case ni_gpct_variant_e_series:
 		break;
 	}
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	if (counter->mite_chan == NULL) {
-		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		spin_unlock_irqrestore(&counter->lock, flags);
 		return;
 	}
 	gpct_mite_status = mite_get_status(counter->mite_chan);
@@ -489,7 +489,7 @@ void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice *
 			MITE_CHOR(counter->mite_chan->channel));
 	}
 	mite_sync_input_dma(counter->mite_chan, s->async);
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 void ni_tio_set_mite_channel(struct ni_gpct *counter,
@@ -497,9 +497,9 @@ void ni_tio_set_mite_channel(struct ni_gpct *counter,
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&counter->lock, flags);
+	spin_lock_irqsave(&counter->lock, flags);
 	counter->mite_chan = mite_chan;
-	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	spin_unlock_irqrestore(&counter->lock, flags);
 }
 
 static int __init ni_tiocmd_init_module(void)

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index a3c55979cf4c..fcf4eb6cdf60 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -96,7 +96,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 	}
 }
 
-static int ni_tio_input_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int ni_tio_input_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	unsigned long flags;

commit 2696fb57e6af653dd8b4df41b16754579f42fc78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:29:34 2009 -0400

    Staging: comedi: Remove C99 comments
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 16a26e73c994..a3c55979cf4c 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -365,7 +365,7 @@ static int should_ack_gate(struct ni_gpct *counter)
 
 	switch (counter->counter_dev->variant) {
 	case ni_gpct_variant_m_series:
-	case ni_gpct_variant_660x:	// not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual)
+	case ni_gpct_variant_660x:	/*  not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual) */
 		return 1;
 		break;
 	case ni_gpct_variant_e_series:

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index 2c3a21771875..16a26e73c994 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -124,7 +124,7 @@ static int ni_tio_input_inttrig(struct comedi_device * dev, struct comedi_subdev
 static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	int retval = 0;
 
 	/* write alloc the entire buffer */
@@ -183,7 +183,7 @@ static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async
 
 static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 {
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	int set_gate_source = 0;
 	unsigned gate_source;
 	int retval = 0;
@@ -209,7 +209,7 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 
 int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	int retval = 0;
 	unsigned long flags;
 
@@ -232,7 +232,7 @@ int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 	return retval;
 }
 
-int ni_tio_cmdtest(struct ni_gpct *counter, comedi_cmd * cmd)
+int ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index dffaafe9d5fa..2c3a21771875 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -121,7 +121,7 @@ static int ni_tio_input_inttrig(struct comedi_device * dev, struct comedi_subdev
 	return retval;
 }
 
-static int ni_tio_input_cmd(struct ni_gpct *counter, comedi_async * async)
+static int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
 	struct ni_gpct_device *counter_dev = counter->counter_dev;
 	comedi_cmd *cmd = &async->cmd;
@@ -169,7 +169,7 @@ static int ni_tio_input_cmd(struct ni_gpct *counter, comedi_async * async)
 	return retval;
 }
 
-static int ni_tio_output_cmd(struct ni_gpct *counter, comedi_async * async)
+static int ni_tio_output_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
 	rt_printk("ni_tio: output commands not yet implemented.\n");
 	return -ENOTSUPP;
@@ -181,7 +181,7 @@ static int ni_tio_output_cmd(struct ni_gpct *counter, comedi_async * async)
 	return ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
 }
 
-static int ni_tio_cmd_setup(struct ni_gpct *counter, comedi_async * async)
+static int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)
 {
 	comedi_cmd *cmd = &async->cmd;
 	int set_gate_source = 0;
@@ -207,7 +207,7 @@ static int ni_tio_cmd_setup(struct ni_gpct *counter, comedi_async * async)
 	return retval;
 }
 
-int ni_tio_cmd(struct ni_gpct *counter, comedi_async * async)
+int ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)
 {
 	comedi_cmd *cmd = &async->cmd;
 	int retval = 0;

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index e28bc754f672..dffaafe9d5fa 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -96,7 +96,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 	}
 }
 
-static int ni_tio_input_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int ni_tio_input_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;
@@ -447,7 +447,7 @@ void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
 	}
 }
 
-void ni_tio_handle_interrupt(struct ni_gpct *counter, comedi_subdevice * s)
+void ni_tio_handle_interrupt(struct ni_gpct *counter, struct comedi_subdevice * s)
 {
 	unsigned gpct_mite_status;
 	unsigned long flags;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
index e4cc5c59f0c5..e28bc754f672 100644
--- a/drivers/staging/comedi/drivers/ni_tiocmd.c
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -96,7 +96,7 @@ static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
 	}
 }
 
-static int ni_tio_input_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int ni_tio_input_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	unsigned long flags;

commit cb7859a90af1c6dedcc244f4b680ee68ed607add
Author: Frank Mori Hess <fmhess@users.sourceforge.net>
Date:   Thu Feb 12 15:39:24 2009 -0800

    Staging: comedi: add National Instruments infrastructure
    
    These drivers are used to support National Instruments general purpose
    counters and commands.
    
    From: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: J.P. Mellor <jpmellor@rose-hulman.edu>
    Cc: Herman Bruyninckx <Herman.Bruyninckx@mech.kuleuven.ac.be>
    Cc: Wim Meeussen <Wim.Meeussen@mech.kuleuven.ac.be>
    Cc: Klass Gadeyne <Klaas.Gadeyne@mech.kuleuven.ac.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c
new file mode 100644
index 000000000000..e4cc5c59f0c5
--- /dev/null
+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c
@@ -0,0 +1,523 @@
+/*
+  comedi/drivers/ni_tiocmd.c
+  Command support for NI general purpose counters
+
+  Copyright (C) 2006 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+Driver: ni_tiocmd
+Description: National Instruments general purpose counters command support
+Devices:
+Author: J.P. Mellor <jpmellor@rose-hulman.edu>,
+	Herman.Bruyninckx@mech.kuleuven.ac.be,
+	Wim.Meeussen@mech.kuleuven.ac.be,
+	Klaas.Gadeyne@mech.kuleuven.ac.be,
+	Frank Mori Hess <fmhess@users.sourceforge.net>
+Updated: Fri, 11 Apr 2008 12:32:35 +0100
+Status: works
+
+This module is not used directly by end-users.  Rather, it
+is used by other drivers (for example ni_660x and ni_pcimio)
+to provide command support for NI's general purpose counters.
+It was originally split out of ni_tio.c to stop the 'ni_tio'
+module depending on the 'mite' module.
+
+References:
+DAQ 660x Register-Level Programmer Manual  (NI 370505A-01)
+DAQ 6601/6602 User Manual (NI 322137B-01)
+340934b.pdf  DAQ-STC reference manual
+
+*/
+/*
+TODO:
+	Support use of both banks X and Y
+*/
+
+#include "ni_tio_internal.h"
+#include "mite.h"
+
+MODULE_AUTHOR("Comedi <comedi@comedi.org>");
+MODULE_DESCRIPTION("Comedi command support for NI general-purpose counters");
+MODULE_LICENSE("GPL");
+
+static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,
+	short read_not_write)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	unsigned input_select_bits = 0;
+
+	if (enable) {
+		if (read_not_write) {
+			input_select_bits |= Gi_Read_Acknowledges_Irq;
+		} else {
+			input_select_bits |= Gi_Write_Acknowledges_Irq;
+		}
+	}
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Input_Select_Reg(counter->counter_index),
+		Gi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,
+		input_select_bits);
+	switch (counter_dev->variant) {
+	case ni_gpct_variant_e_series:
+		break;
+	case ni_gpct_variant_m_series:
+	case ni_gpct_variant_660x:
+		{
+			unsigned gi_dma_config_bits = 0;
+
+			if (enable) {
+				gi_dma_config_bits |= Gi_DMA_Enable_Bit;
+				gi_dma_config_bits |= Gi_DMA_Int_Bit;
+			}
+			if (read_not_write == 0) {
+				gi_dma_config_bits |= Gi_DMA_Write_Bit;
+			}
+			ni_tio_set_bits(counter,
+				NITIO_Gi_DMA_Config_Reg(counter->counter_index),
+				Gi_DMA_Enable_Bit | Gi_DMA_Int_Bit |
+				Gi_DMA_Write_Bit, gi_dma_config_bits);
+		}
+		break;
+	}
+}
+
+static int ni_tio_input_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	unsigned long flags;
+	int retval = 0;
+	struct ni_gpct *counter = s->private;
+
+	BUG_ON(counter == NULL);
+	if (trignum != 0)
+		return -EINVAL;
+
+	comedi_spin_lock_irqsave(&counter->lock, flags);
+	if (counter->mite_chan)
+		mite_dma_arm(counter->mite_chan);
+	else
+		retval = -EIO;
+	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	if (retval < 0)
+		return retval;
+	retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+	s->async->inttrig = NULL;
+
+	return retval;
+}
+
+static int ni_tio_input_cmd(struct ni_gpct *counter, comedi_async * async)
+{
+	struct ni_gpct_device *counter_dev = counter->counter_dev;
+	comedi_cmd *cmd = &async->cmd;
+	int retval = 0;
+
+	/* write alloc the entire buffer */
+	comedi_buf_write_alloc(async, async->prealloc_bufsz);
+	counter->mite_chan->dir = COMEDI_INPUT;
+	switch (counter_dev->variant) {
+	case ni_gpct_variant_m_series:
+	case ni_gpct_variant_660x:
+		mite_prep_dma(counter->mite_chan, 32, 32);
+		break;
+	case ni_gpct_variant_e_series:
+		mite_prep_dma(counter->mite_chan, 16, 32);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	ni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),
+		Gi_Save_Trace_Bit, 0);
+	ni_tio_configure_dma(counter, 1, 1);
+	switch (cmd->start_src) {
+	case TRIG_NOW:
+		async->inttrig = NULL;
+		mite_dma_arm(counter->mite_chan);
+		retval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+		break;
+	case TRIG_INT:
+		async->inttrig = &ni_tio_input_inttrig;
+		break;
+	case TRIG_EXT:
+		async->inttrig = NULL;
+		mite_dma_arm(counter->mite_chan);
+		retval = ni_tio_arm(counter, 1, cmd->start_arg);
+	case TRIG_OTHER:
+		async->inttrig = NULL;
+		mite_dma_arm(counter->mite_chan);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	return retval;
+}
+
+static int ni_tio_output_cmd(struct ni_gpct *counter, comedi_async * async)
+{
+	rt_printk("ni_tio: output commands not yet implemented.\n");
+	return -ENOTSUPP;
+
+	counter->mite_chan->dir = COMEDI_OUTPUT;
+	mite_prep_dma(counter->mite_chan, 32, 32);
+	ni_tio_configure_dma(counter, 1, 0);
+	mite_dma_arm(counter->mite_chan);
+	return ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);
+}
+
+static int ni_tio_cmd_setup(struct ni_gpct *counter, comedi_async * async)
+{
+	comedi_cmd *cmd = &async->cmd;
+	int set_gate_source = 0;
+	unsigned gate_source;
+	int retval = 0;
+
+	if (cmd->scan_begin_src == TRIG_EXT) {
+		set_gate_source = 1;
+		gate_source = cmd->scan_begin_arg;
+	} else if (cmd->convert_src == TRIG_EXT) {
+		set_gate_source = 1;
+		gate_source = cmd->convert_arg;
+	}
+	if (set_gate_source) {
+		retval = ni_tio_set_gate_src(counter, 0, gate_source);
+	}
+	if (cmd->flags & TRIG_WAKE_EOS) {
+		ni_tio_set_bits(counter,
+			NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index),
+			Gi_Gate_Interrupt_Enable_Bit(counter->counter_index));
+	}
+	return retval;
+}
+
+int ni_tio_cmd(struct ni_gpct *counter, comedi_async * async)
+{
+	comedi_cmd *cmd = &async->cmd;
+	int retval = 0;
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&counter->lock, flags);
+	if (counter->mite_chan == NULL) {
+		rt_printk
+			("ni_tio: commands only supported with DMA.  Interrupt-driven commands not yet implemented.\n");
+		retval = -EIO;
+	} else {
+		retval = ni_tio_cmd_setup(counter, async);
+		if (retval == 0) {
+			if (cmd->flags & CMDF_WRITE) {
+				retval = ni_tio_output_cmd(counter, async);
+			} else {
+				retval = ni_tio_input_cmd(counter, async);
+			}
+		}
+	}
+	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	return retval;
+}
+
+int ni_tio_cmdtest(struct ni_gpct *counter, comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int sources;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	sources = TRIG_NOW | TRIG_INT | TRIG_OTHER;
+	if (ni_tio_counting_mode_registers_present(counter->counter_dev))
+		sources |= TRIG_EXT;
+	cmd->start_src &= sources;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_EXT | TRIG_OTHER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	sources = TRIG_NOW | TRIG_EXT | TRIG_OTHER;
+	cmd->convert_src &= sources;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique... */
+
+	if (cmd->start_src != TRIG_NOW &&
+		cmd->start_src != TRIG_INT &&
+		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_OTHER)
+		err++;
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT &&
+		cmd->scan_begin_src != TRIG_OTHER)
+		err++;
+	if (cmd->convert_src != TRIG_OTHER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_NONE)
+		err++;
+	/* ... and mutually compatible */
+	if (cmd->convert_src != TRIG_NOW && cmd->scan_begin_src != TRIG_FOLLOW)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+	if (cmd->start_src != TRIG_EXT) {
+		if (cmd->start_arg != 0) {
+			cmd->start_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->scan_begin_src != TRIG_EXT) {
+		if (cmd->scan_begin_arg) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->convert_src != TRIG_EXT) {
+		if (cmd->convert_arg) {
+			cmd->convert_arg = 0;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	if (cmd->stop_src == TRIG_NONE) {
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+int ni_tio_cancel(struct ni_gpct *counter)
+{
+	unsigned long flags;
+
+	ni_tio_arm(counter, 0, 0);
+	comedi_spin_lock_irqsave(&counter->lock, flags);
+	if (counter->mite_chan) {
+		mite_dma_disarm(counter->mite_chan);
+	}
+	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+	ni_tio_configure_dma(counter, 0, 0);
+
+	ni_tio_set_bits(counter,
+		NITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),
+		Gi_Gate_Interrupt_Enable_Bit(counter->counter_index), 0x0);
+	return 0;
+}
+
+	/* During buffered input counter operation for e-series, the gate interrupt is acked
+	   automatically by the dma controller, due to the Gi_Read/Write_Acknowledges_IRQ bits
+	   in the input select register.  */
+static int should_ack_gate(struct ni_gpct *counter)
+{
+	unsigned long flags;
+	int retval = 0;
+
+	switch (counter->counter_dev->variant) {
+	case ni_gpct_variant_m_series:
+	case ni_gpct_variant_660x:	// not sure if 660x really supports gate interrupts (the bits are not listed in register-level manual)
+		return 1;
+		break;
+	case ni_gpct_variant_e_series:
+		comedi_spin_lock_irqsave(&counter->lock, flags);
+		{
+			if (counter->mite_chan == NULL ||
+				counter->mite_chan->dir != COMEDI_INPUT ||
+				(mite_done(counter->mite_chan))) {
+				retval = 1;
+			}
+		}
+		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		break;
+	}
+	return retval;
+}
+
+void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,
+	int *tc_error, int *perm_stale_data, int *stale_data)
+{
+	const unsigned short gxx_status = read_register(counter,
+		NITIO_Gxx_Status_Reg(counter->counter_index));
+	const unsigned short gi_status = read_register(counter,
+		NITIO_Gi_Status_Reg(counter->counter_index));
+	unsigned ack = 0;
+
+	if (gate_error)
+		*gate_error = 0;
+	if (tc_error)
+		*tc_error = 0;
+	if (perm_stale_data)
+		*perm_stale_data = 0;
+	if (stale_data)
+		*stale_data = 0;
+
+	if (gxx_status & Gi_Gate_Error_Bit(counter->counter_index)) {
+		ack |= Gi_Gate_Error_Confirm_Bit(counter->counter_index);
+		if (gate_error) {
+			/*660x don't support automatic acknowledgement of gate interrupt via dma read/write
+			   and report bogus gate errors */
+			if (counter->counter_dev->variant !=
+				ni_gpct_variant_660x) {
+				*gate_error = 1;
+			}
+		}
+	}
+	if (gxx_status & Gi_TC_Error_Bit(counter->counter_index)) {
+		ack |= Gi_TC_Error_Confirm_Bit(counter->counter_index);
+		if (tc_error)
+			*tc_error = 1;
+	}
+	if (gi_status & Gi_TC_Bit) {
+		ack |= Gi_TC_Interrupt_Ack_Bit;
+	}
+	if (gi_status & Gi_Gate_Interrupt_Bit) {
+		if (should_ack_gate(counter))
+			ack |= Gi_Gate_Interrupt_Ack_Bit;
+	}
+	if (ack)
+		write_register(counter, ack,
+			NITIO_Gi_Interrupt_Acknowledge_Reg(counter->
+				counter_index));
+	if (ni_tio_get_soft_copy(counter,
+			NITIO_Gi_Mode_Reg(counter->
+				counter_index)) & Gi_Loading_On_Gate_Bit) {
+		if (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {
+			if (stale_data)
+				*stale_data = 1;
+		}
+		if (read_register(counter,
+				NITIO_Gxx_Joint_Status2_Reg(counter->
+					counter_index)) &
+			Gi_Permanent_Stale_Bit(counter->counter_index)) {
+			rt_printk("%s: Gi_Permanent_Stale_Data detected.\n",
+				__FUNCTION__);
+			if (perm_stale_data)
+				*perm_stale_data = 1;
+		}
+	}
+}
+
+void ni_tio_handle_interrupt(struct ni_gpct *counter, comedi_subdevice * s)
+{
+	unsigned gpct_mite_status;
+	unsigned long flags;
+	int gate_error;
+	int tc_error;
+	int perm_stale_data;
+
+	ni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,
+		&perm_stale_data, NULL);
+	if (gate_error) {
+		rt_printk("%s: Gi_Gate_Error detected.\n", __FUNCTION__);
+		s->async->events |= COMEDI_CB_OVERFLOW;
+	}
+	if (perm_stale_data) {
+		s->async->events |= COMEDI_CB_ERROR;
+	}
+	switch (counter->counter_dev->variant) {
+	case ni_gpct_variant_m_series:
+	case ni_gpct_variant_660x:
+		if (read_register(counter,
+				NITIO_Gi_DMA_Status_Reg(counter->
+					counter_index)) & Gi_DRQ_Error_Bit) {
+			rt_printk("%s: Gi_DRQ_Error detected.\n", __FUNCTION__);
+			s->async->events |= COMEDI_CB_OVERFLOW;
+		}
+		break;
+	case ni_gpct_variant_e_series:
+		break;
+	}
+	comedi_spin_lock_irqsave(&counter->lock, flags);
+	if (counter->mite_chan == NULL) {
+		comedi_spin_unlock_irqrestore(&counter->lock, flags);
+		return;
+	}
+	gpct_mite_status = mite_get_status(counter->mite_chan);
+	if (gpct_mite_status & CHSR_LINKC) {
+		writel(CHOR_CLRLC,
+			counter->mite_chan->mite->mite_io_addr +
+			MITE_CHOR(counter->mite_chan->channel));
+	}
+	mite_sync_input_dma(counter->mite_chan, s->async);
+	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+}
+
+void ni_tio_set_mite_channel(struct ni_gpct *counter,
+	struct mite_channel *mite_chan)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&counter->lock, flags);
+	counter->mite_chan = mite_chan;
+	comedi_spin_unlock_irqrestore(&counter->lock, flags);
+}
+
+static int __init ni_tiocmd_init_module(void)
+{
+	return 0;
+}
+
+module_init(ni_tiocmd_init_module);
+
+static void __exit ni_tiocmd_cleanup_module(void)
+{
+}
+
+module_exit(ni_tiocmd_cleanup_module);
+
+EXPORT_SYMBOL_GPL(ni_tio_cmd);
+EXPORT_SYMBOL_GPL(ni_tio_cmdtest);
+EXPORT_SYMBOL_GPL(ni_tio_cancel);
+EXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);
+EXPORT_SYMBOL_GPL(ni_tio_set_mite_channel);
+EXPORT_SYMBOL_GPL(ni_tio_acknowledge_and_confirm);
