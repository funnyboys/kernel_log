commit 05ffb11ca7e2c24364cb353265d6ce586fd83990
Author: Deepak R Varma <mh12gx2825@gmail.com>
Date:   Wed Mar 11 02:55:48 2020 +0530

    staging: comedi: dt282x: remove old unused code
    
    There are two #if 0 blocks that have no recent history of any change.
    Remove those code blocks for improved readability of the code.
    
    Signed-off-by: Deepak R Varma <mh12gx2825@gmail.com>
    Link: https://lore.kernel.org/r/20200310212545.GA8914@deeUbuntu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e15e33ed94ae..89dc84d3c803 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -484,14 +484,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 		s->async->events |= COMEDI_CB_EOA;
 		return;
 	}
-#if 0
-	/* clear the dual dma flag, making this the last dma segment */
-	/* XXX probably wrong */
-	if (!devpriv->ntrig) {
-		devpriv->supcsr &= ~DT2821_SUPCSR_DDMA;
-		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);
-	}
-#endif
+
 	/* restart the channel */
 	dt282x_prep_ai_dma(dev, dma->cur_dma, 0);
 
@@ -534,28 +527,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		s_ao->async->events |= COMEDI_CB_ERROR;
 		handled = 1;
 	}
-#if 0
-	if (adcsr & DT2821_ADCSR_ADDONE) {
-		unsigned short data;
-
-		data = inw(dev->iobase + DT2821_ADDAT_REG);
-		data &= s->maxdata;
-		if (devpriv->ad_2scomp)
-			data = comedi_offset_munge(s, data);
 
-		comedi_buf_write_samples(s, &data, 1);
-
-		devpriv->nread--;
-		if (!devpriv->nread) {
-			s->async->events |= COMEDI_CB_EOA;
-		} else {
-			if (supcsr & DT2821_SUPCSR_SCDN)
-				outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
-				     dev->iobase + DT2821_SUPCSR_REG);
-		}
-		handled = 1;
-	}
-#endif
 	comedi_handle_events(dev, s);
 	if (s_ao)
 		comedi_handle_events(dev, s_ao);

commit b8336be66dec06bef518030a0df9847122053ec5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Jun 26 14:18:04 2019 +0100

    staging: comedi: dt282x: fix a null pointer deref on interrupt
    
    The interrupt handler `dt282x_interrupt()` causes a null pointer
    dereference for those supported boards that have no analog output
    support.  For these boards, `dev->write_subdev` will be `NULL` and
    therefore the `s_ao` subdevice pointer variable will be `NULL`.  In that
    case, the following call near the end of the interrupt handler results
    in a null pointer dereference:
    
            comedi_handle_events(dev, s_ao);
    
    Fix it by only calling the above function if `s_ao` is valid.
    
    (There are other uses of `s_ao` by the interrupt handler that may or may
    not be reached depending on values of hardware registers.  Trust that
    they are reliable for now.)
    
    Note:
    commit 4f6f009b204f ("staging: comedi: dt282x: use comedi_handle_events()")
    propagates an earlier error from
    commit f21c74fa4cfe ("staging: comedi: dt282x: use cfc_handle_events()").
    
    Fixes: 4f6f009b204f ("staging: comedi: dt282x: use comedi_handle_events()")
    Cc: <stable@vger.kernel.org> # v3.19+
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3be927f1d3a9..e15e33ed94ae 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -557,7 +557,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	}
 #endif
 	comedi_handle_events(dev, s);
-	comedi_handle_events(dev, s_ao);
+	if (s_ao)
+		comedi_handle_events(dev, s_ao);
 
 	return IRQ_RETVAL(handled);
 }

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 421652003ffc..3be927f1d3a9 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -5,16 +5,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 217a4b884689..421652003ffc 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * dt282x.c
  * Comedi driver for Data Translation DT2821 series

commit 526739265e5eb984f6f7114b17e63c5654ca1b93
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Oct 6 23:55:56 2017 +0530

    staging: comedi: dt282x: fix IRQ assignment for dev->irq.
    
    Here, dev->irq is not assigned with irq. comedi_legacy_detach()
    is using dev->irq for release irq and dt282x_attach() is using dev->irq
    for initialize comedi_subdevice.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index d5295bbdd28c..217a4b884689 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1062,6 +1062,8 @@ static void dt282x_alloc_dma(struct comedi_device *dev,
 					   PAGE_SIZE, 0);
 	if (!devpriv->dma)
 		free_irq(irq_num, dev);
+	else
+		dev->irq = irq_num;
 }
 
 static void dt282x_free_dma(struct comedi_device *dev)

commit f91e45e2acbd300c5042c9ce0133dbc602da9788
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 12:24:31 2016 -0700

    staging: comedi: dt282x: remove unnecessary comment
    
    The "Configuration options" are documented in the comedi driver comment
    block. Remove the redundant comment before the drivers (*attach) function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 661c3ada0712..d5295bbdd28c 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1093,20 +1093,6 @@ static int dt282x_initialize(struct comedi_device *dev)
 	return 0;
 }
 
-/*
-   options:
-   0	i/o base
-   1	irq
-   2	dma1
-   3	dma2
-   4	0=single ended, 1=differential
-   5	ai 0=straight binary, 1=2's comp
-   6	ao0 0=straight binary, 1=2's comp
-   7	ao1 0=straight binary, 1=2's comp
-   8	ai 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V
-   9	ao0 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
-   10	ao1 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
- */
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dt282x_board *board = dev->board_ptr;

commit 20ea5c3506abfe46c98dfa47d1bf933e2efa15c9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 12:24:30 2016 -0700

    staging: comedi: dt282x: remove redundant comedi_check_trigger_arg_min()
    
    The 'convert_arg' sets the acquisition timing of the analog input command.
    The maximum speed (the minimum timing) depends on the board 'ai_speed' which
    if always >= 4000. Remove the redundant 'min' check,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e6958eaf5178..661c3ada0712 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -697,11 +697,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	/* Step 3: check if arguments are trivially valid */
 
 	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
-
 	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-
-	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 4000);
-
 	err |= comedi_check_trigger_arg_max(&cmd->convert_arg, DT2821_OSC_MAX);
 	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,

commit 581867bd9151ee77fad4b0fe47af96d923ac9ec2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 23 12:24:29 2016 -0700

    staging: comedi: dt282x: refactor dt282x_ns_to_timer()
    
    Define the pacer clock limits and remove the magic numbers. Refactor
    the code to use a common path to return the actual 'ns' timing and
    the timer divisor value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 06a87a10a2d0..e6958eaf5178 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -113,6 +113,17 @@
 #define DT2821_SUPCSR_XCLK		BIT(1)
 #define DT2821_SUPCSR_BDINIT		BIT(0)
 #define DT2821_TMRCTR_REG		0x0e
+#define DT2821_TMRCTR_PRESCALE(x)	(((x) & 0xf) << 8)
+#define DT2821_TMRCTR_DIVIDER(x)	((255 - ((x) & 0xff)) << 0)
+
+/* Pacer Clock */
+#define DT2821_OSC_BASE		250	/* 4 MHz (in nanoseconds) */
+#define DT2821_PRESCALE(x)	BIT(x)
+#define DT2821_PRESCALE_MAX	15
+#define DT2821_DIVIDER_MAX	255
+#define DT2821_OSC_MAX		(DT2821_OSC_BASE *			\
+				 DT2821_PRESCALE(DT2821_PRESCALE_MAX) *	\
+				 DT2821_DIVIDER_MAX)
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = {
 	4, {
@@ -365,10 +376,10 @@ static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 {
 	unsigned int prescale, base, divider;
 
-	for (prescale = 0; prescale < 16; prescale++) {
-		if (prescale == 1)
+	for (prescale = 0; prescale <= DT2821_PRESCALE_MAX; prescale++) {
+		if (prescale == 1)	/* 0 and 1 are both divide by 1 */
 			continue;
-		base = 250 * (1 << prescale);
+		base = DT2821_OSC_BASE * DT2821_PRESCALE(prescale);
 		switch (flags & CMDF_ROUND_MASK) {
 		case CMDF_ROUND_NEAREST:
 		default:
@@ -381,15 +392,17 @@ static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 			divider = DIV_ROUND_UP(*ns, base);
 			break;
 		}
-		if (divider < 256) {
-			*ns = divider * base;
-			return (prescale << 8) | (255 - divider);
-		}
+		if (divider <= DT2821_DIVIDER_MAX)
+			break;
+	}
+	if (divider > DT2821_DIVIDER_MAX) {
+		prescale = DT2821_PRESCALE_MAX;
+		divider = DT2821_DIVIDER_MAX;
+		base = DT2821_OSC_BASE * DT2821_PRESCALE(prescale);
 	}
-	base = 250 * (1 << 15);
-	divider = 255;
 	*ns = divider * base;
-	return (15 << 8) | (255 - divider);
+	return DT2821_TMRCTR_PRESCALE(prescale) |
+	       DT2821_TMRCTR_DIVIDER(divider);
 }
 
 static void dt282x_munge(struct comedi_device *dev,
@@ -689,8 +702,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 4000);
 
-#define SLOWEST_TIMER	(250*(1<<15)*255)
-	err |= comedi_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);
+	err |= comedi_check_trigger_arg_max(&cmd->convert_arg, DT2821_OSC_MAX);
 	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
 					   cmd->chanlist_len);

commit f6b1160eb27f990cc1c48b67a5f83cb63115284e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 17 10:10:40 2016 -0700

    staging: comedi: dt282x: tidy up register bit defines
    
    Arnd Bergmann pointed out that gcc-6 warns about passing negative signed
    integer into swab16() due to the macro expansion of 'outw'.
    
    It appears that the register map constants are causing the warnings.
    Actually, it might just be the (1 << 15) ones...
    
    Convert all the constants as suggested by checkpatch.pl:
    CHECK: Prefer using the BIT macro
    
    The BIT() macro will make all the constants explicitly 'unsigned', which
    helps to avoid the warning.
    
    Fix the, unsused, DT2821_CHANCSR_PRESLA() macro. The "Present List
    Address" (PRESLA) bits in the CHANCSR register are read only. This
    define was meant to extract the bits from the read value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Tested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 40bf00984fa5..06a87a10a2d0 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -69,48 +69,49 @@
  * Register map
  */
 #define DT2821_ADCSR_REG		0x00
-#define DT2821_ADCSR_ADERR		(1 << 15)
-#define DT2821_ADCSR_ADCLK		(1 << 9)
-#define DT2821_ADCSR_MUXBUSY		(1 << 8)
-#define DT2821_ADCSR_ADDONE		(1 << 7)
-#define DT2821_ADCSR_IADDONE		(1 << 6)
+#define DT2821_ADCSR_ADERR		BIT(15)
+#define DT2821_ADCSR_ADCLK		BIT(9)
+#define DT2821_ADCSR_MUXBUSY		BIT(8)
+#define DT2821_ADCSR_ADDONE		BIT(7)
+#define DT2821_ADCSR_IADDONE		BIT(6)
 #define DT2821_ADCSR_GS(x)		(((x) & 0x3) << 4)
 #define DT2821_ADCSR_CHAN(x)		(((x) & 0xf) << 0)
 #define DT2821_CHANCSR_REG		0x02
-#define DT2821_CHANCSR_LLE		(1 << 15)
-#define DT2821_CHANCSR_PRESLA(x)	(((x) & 0xf) >> 8)
+#define DT2821_CHANCSR_LLE		BIT(15)
+#define DT2821_CHANCSR_TO_PRESLA(x)	(((x) >> 8) & 0xf)
 #define DT2821_CHANCSR_NUMB(x)		((((x) - 1) & 0xf) << 0)
 #define DT2821_ADDAT_REG		0x04
 #define DT2821_DACSR_REG		0x06
-#define DT2821_DACSR_DAERR		(1 << 15)
+#define DT2821_DACSR_DAERR		BIT(15)
 #define DT2821_DACSR_YSEL(x)		((x) << 9)
-#define DT2821_DACSR_SSEL		(1 << 8)
-#define DT2821_DACSR_DACRDY		(1 << 7)
-#define DT2821_DACSR_IDARDY		(1 << 6)
-#define DT2821_DACSR_DACLK		(1 << 5)
-#define DT2821_DACSR_HBOE		(1 << 1)
-#define DT2821_DACSR_LBOE		(1 << 0)
+#define DT2821_DACSR_SSEL		BIT(8)
+#define DT2821_DACSR_DACRDY		BIT(7)
+#define DT2821_DACSR_IDARDY		BIT(6)
+#define DT2821_DACSR_DACLK		BIT(5)
+#define DT2821_DACSR_HBOE		BIT(1)
+#define DT2821_DACSR_LBOE		BIT(0)
 #define DT2821_DADAT_REG		0x08
 #define DT2821_DIODAT_REG		0x0a
 #define DT2821_SUPCSR_REG		0x0c
-#define DT2821_SUPCSR_DMAD		(1 << 15)
-#define DT2821_SUPCSR_ERRINTEN		(1 << 14)
-#define DT2821_SUPCSR_CLRDMADNE		(1 << 13)
-#define DT2821_SUPCSR_DDMA		(1 << 12)
-#define DT2821_SUPCSR_DS_PIO		(0 << 10)
-#define DT2821_SUPCSR_DS_AD_CLK		(1 << 10)
-#define DT2821_SUPCSR_DS_DA_CLK		(2 << 10)
-#define DT2821_SUPCSR_DS_AD_TRIG	(3 << 10)
-#define DT2821_SUPCSR_BUFFB		(1 << 9)
-#define DT2821_SUPCSR_SCDN		(1 << 8)
-#define DT2821_SUPCSR_DACON		(1 << 7)
-#define DT2821_SUPCSR_ADCINIT		(1 << 6)
-#define DT2821_SUPCSR_DACINIT		(1 << 5)
-#define DT2821_SUPCSR_PRLD		(1 << 4)
-#define DT2821_SUPCSR_STRIG		(1 << 3)
-#define DT2821_SUPCSR_XTRIG		(1 << 2)
-#define DT2821_SUPCSR_XCLK		(1 << 1)
-#define DT2821_SUPCSR_BDINIT		(1 << 0)
+#define DT2821_SUPCSR_DMAD		BIT(15)
+#define DT2821_SUPCSR_ERRINTEN		BIT(14)
+#define DT2821_SUPCSR_CLRDMADNE		BIT(13)
+#define DT2821_SUPCSR_DDMA		BIT(12)
+#define DT2821_SUPCSR_DS(x)		(((x) & 0x3) << 10)
+#define DT2821_SUPCSR_DS_PIO		DT2821_SUPCSR_DS(0)
+#define DT2821_SUPCSR_DS_AD_CLK		DT2821_SUPCSR_DS(1)
+#define DT2821_SUPCSR_DS_DA_CLK		DT2821_SUPCSR_DS(2)
+#define DT2821_SUPCSR_DS_AD_TRIG	DT2821_SUPCSR_DS(3)
+#define DT2821_SUPCSR_BUFFB		BIT(9)
+#define DT2821_SUPCSR_SCDN		BIT(8)
+#define DT2821_SUPCSR_DACON		BIT(7)
+#define DT2821_SUPCSR_ADCINIT		BIT(6)
+#define DT2821_SUPCSR_DACINIT		BIT(5)
+#define DT2821_SUPCSR_PRLD		BIT(4)
+#define DT2821_SUPCSR_STRIG		BIT(3)
+#define DT2821_SUPCSR_XTRIG		BIT(2)
+#define DT2821_SUPCSR_XCLK		BIT(1)
+#define DT2821_SUPCSR_BDINIT		BIT(0)
 #define DT2821_TMRCTR_REG		0x0e
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = {

commit 621ab40df94c00e197bb06d9b853dce9a47139c6
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Thu Mar 10 00:24:49 2016 +0530

    staging: comedi: dt282x: Prefer using macro DIV_ROUND_UP
    
    The macro DIV_ROUND_UP performs the computation
    (((n) + (d) - 1) /(d)). It clarifies the divisor calculations.
    This was done using the coccinelle script:
    @@
    expression e1;
    expression e2;
    @@
    (
    - ((e1) + e2 - 1) / (e2)
    + DIV_ROUND_UP(e1,e2)
    |
    - ((e1) + (e2 - 1)) / (e2)
    + DIV_ROUND_UP(e1,e2)
    )
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6c26e0924ebd..40bf00984fa5 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -377,7 +377,7 @@ static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 			divider = (*ns) / base;
 			break;
 		case CMDF_ROUND_UP:
-			divider = (*ns + base - 1) / base;
+			divider = DIV_ROUND_UP(*ns, base);
 			break;
 		}
 		if (divider < 256) {

commit 2ead7b32aadc83833d7cf6e9751ef56b89e90462
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Fri Feb 19 20:57:15 2016 +0530

    staging: comedi: drivers: Use DIV_ROUND_CLOSEST
    
    The kernel.h macro DIV_ROUND_CLOSEST performs the computation
    `(x +d/2)/d` but is perhaps more readable.
    
    The Coccinelle script used is as follows:
    // <smpl>
    @@
    expression x,__divisor;
    @@
    - (((x) + ((__divisor) / 2)) / (__divisor))
    + DIV_ROUND_CLOSEST(x,__divisor)
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5a536a00066f..6c26e0924ebd 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -371,7 +371,7 @@ static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 		switch (flags & CMDF_ROUND_MASK) {
 		case CMDF_ROUND_NEAREST:
 		default:
-			divider = (*ns + base / 2) / base;
+			divider = DIV_ROUND_CLOSEST(*ns, base);
 			break;
 		case CMDF_ROUND_DOWN:
 			divider = (*ns) / base;

commit 34e444c8581866a32e7f3ed3229909c732c621f5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:15 2015 +0000

    staging: comedi: dt282x: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 52a50bc3343a..5a536a00066f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -64,7 +64,6 @@
 #include "../comedidev.h"
 
 #include "comedi_isadma.h"
-#include "comedi_fc.h"
 
 /*
  * Register map
@@ -661,20 +660,20 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_FOLLOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -683,21 +682,22 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
-	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 4000);
+	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, 4000);
 
 #define SLOWEST_TIMER	(250*(1<<15)*255)
-	err |= cfc_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);
-	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);
+	err |= comedi_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_EXT | TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -706,7 +706,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	arg = cmd->convert_arg;
 	devpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 	if (err)
 		return 4;
@@ -831,18 +831,18 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -851,15 +851,16 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);
+	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_EXT | TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -868,7 +869,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 
 	arg = cmd->scan_begin_arg;
 	devpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 
 	if (err)
 		return 4;

commit c8f4b98f47e498a823d1b82b8f3848d81183ea22
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:17 2015 -0700

    staging: comedi: drivers/*.c: remove unnecessary blank lines
    
    Blank lines are not needed before a close brace '}' or after an
    open brace '{'. Also remove any multiple blank lines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2cdd8bf44b4d..52a50bc3343a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -874,7 +874,6 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 		return 4;
 
 	return 0;
-
 }
 
 static int dt282x_ao_inttrig(struct comedi_device *dev,

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index db21d2135856..2cdd8bf44b4d 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -764,7 +764,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
-			dev->iobase + DT2821_SUPCSR_REG);
+		     dev->iobase + DT2821_SUPCSR_REG);
 	} else {
 		devpriv->supcsr |= DT2821_SUPCSR_XTRIG;
 		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);

commit 369ba5b8310b401bd04d73d39f57d50a06ef8c09
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Wed Feb 4 12:02:33 2015 -0500

    staging: comedi: dt282x: condition with no effect - if identical to else
    
    The if and the else branch code are identical - so the condition has no
    effect on the effective code - this patch removes the condition and the
    duplicated code.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 051dfb290f4f..db21d2135856 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -685,14 +685,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	} else {
-		/* external trigger */
-		/* should be level/edge, hi/lo specification here */
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 
 	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 4000);
 

commit 860f7c0919a05a1c1cdf3247f0a905851e526c36
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 14 10:05:08 2015 -0700

    staging: comedi: dt282x: remove depends on ISA_DMA_API limitation
    
    Use the new comedi_isadma module to provide the ISA DMA support. This removes
    all the ISA_DMA_API code from this driver and allows the driver to be used on
    platforms that don't support the ISA_DMA_API.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 54c679a0387b..051dfb290f4f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -56,15 +56,14 @@
  */
 
 #include <linux/module.h>
-#include "../comedidev.h"
-
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 
-#include <asm/dma.h>
+#include "../comedidev.h"
 
+#include "comedi_isadma.h"
 #include "comedi_fc.h"
 
 /*
@@ -300,72 +299,37 @@ static const struct dt282x_board boardtypes[] = {
 	},
 };
 
-struct dt282x_dma_desc {
-	unsigned int chan;	/* DMA channel */
-	void *virt_addr;	/* virtual address of DMA buffer */
-	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
-	unsigned int size;	/* transfer size (in bytes) */
-	char mode;		/* DMA_MODE_* */
-};
-
 struct dt282x_private {
+	struct comedi_isadma *dma;
 	unsigned int ad_2scomp:1;
-
 	unsigned int divisor;
-
 	int dacsr;	/* software copies of registers */
 	int adcsr;
 	int supcsr;
-
 	int ntrig;
 	int nread;
-
-	struct dt282x_dma_desc dma_desc[2];
-	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
-	int cur_dma;
 	int dma_dir;
 };
 
-static void dt282x_isadma_program(struct dt282x_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(dma->chan);
-	set_dma_mode(dma->chan, dma->mode);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	enable_dma(dma->chan);
-	release_dma_lock(flags);
-}
-
-static void dt282x_isadma_disable(struct dt282x_dma_desc *dma)
-{
-	unsigned long flags;
-
-	flags = claim_dma_lock();
-	disable_dma(dma->chan);
-	release_dma_lock(flags);
-}
-
 static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma_index];
 
 	if (!devpriv->ntrig)
 		return 0;
 
 	if (n == 0)
-		n = devpriv->dma_maxsize;
+		n = desc->maxsize;
 	if (n > devpriv->ntrig * 2)
 		n = devpriv->ntrig * 2;
 	devpriv->ntrig -= n / 2;
 
-	dma->size = n;
-	dma->mode = DMA_MODE_READ;
+	desc->size = n;
+	comedi_isadma_set_mode(desc, devpriv->dma_dir);
 
-	dt282x_isadma_program(dma);
+	comedi_isadma_program(desc);
 
 	return n;
 }
@@ -373,12 +337,13 @@ static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma_index];
 
-	dma->size = n;
-	dma->mode = DMA_MODE_WRITE;
+	desc->size = n;
+	comedi_isadma_set_mode(desc, devpriv->dma_dir);
 
-	dt282x_isadma_program(dma);
+	comedi_isadma_program(desc);
 
 	return n;
 }
@@ -386,10 +351,14 @@ static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 static void dt282x_disable_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc;
 	int i;
 
-	for (i = 0; i < 2; i++)
-		dt282x_isadma_disable(&devpriv->dma_desc[i]);
+	for (i = 0; i < 2; i++) {
+		desc = &dma->desc[i];
+		comedi_isadma_disable(desc->chan);
+	}
 }
 
 static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
@@ -451,11 +420,12 @@ static unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,
 					int cur_dma)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma = &devpriv->dma_desc[cur_dma];
-	unsigned int nsamples = comedi_bytes_to_samples(s, devpriv->dma_maxsize);
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[cur_dma];
+	unsigned int nsamples = comedi_bytes_to_samples(s, desc->maxsize);
 	unsigned int nbytes;
 
-	nbytes = comedi_buf_read_samples(s, dma->virt_addr, nsamples);
+	nbytes = comedi_buf_read_samples(s, desc->virt_addr, nsamples);
 	if (nbytes)
 		dt282x_prep_ao_dma(dev, cur_dma, nbytes);
 	else
@@ -468,35 +438,37 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	dt282x_isadma_disable(dma);
+	comedi_isadma_disable(desc->chan);
 
-	if (!dt282x_ao_setup_dma(dev, s, devpriv->cur_dma))
+	if (!dt282x_ao_setup_dma(dev, s, dma->cur_dma))
 		s->async->events |= COMEDI_CB_OVERFLOW;
 
-	devpriv->cur_dma = 1 - devpriv->cur_dma;
+	dma->cur_dma = 1 - dma->cur_dma;
 }
 
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
-	unsigned int nsamples = comedi_bytes_to_samples(s, dma->size);
+	struct comedi_isadma *dma = devpriv->dma;
+	struct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];
+	unsigned int nsamples = comedi_bytes_to_samples(s, desc->size);
 	int ret;
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	dt282x_isadma_disable(dma);
+	comedi_isadma_disable(desc->chan);
 
-	dt282x_munge(dev, s, dma->virt_addr, dma->size);
-	ret = comedi_buf_write_samples(s, dma->virt_addr, nsamples);
-	if (ret != dma->size)
+	dt282x_munge(dev, s, desc->virt_addr, desc->size);
+	ret = comedi_buf_write_samples(s, desc->virt_addr, nsamples);
+	if (ret != desc->size)
 		return;
 
 	devpriv->nread -= nsamples;
@@ -517,9 +489,9 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	}
 #endif
 	/* restart the channel */
-	dt282x_prep_ai_dma(dev, devpriv->cur_dma, 0);
+	dt282x_prep_ai_dma(dev, dma->cur_dma, 0);
 
-	devpriv->cur_dma = 1 - devpriv->cur_dma;
+	dma->cur_dma = 1 - dma->cur_dma;
 }
 
 static irqreturn_t dt282x_interrupt(int irq, void *d)
@@ -540,7 +512,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	dacsr = inw(dev->iobase + DT2821_DACSR_REG);
 	supcsr = inw(dev->iobase + DT2821_SUPCSR_REG);
 	if (supcsr & DT2821_SUPCSR_DMAD) {
-		if (devpriv->dma_dir == DMA_MODE_READ)
+		if (devpriv->dma_dir == COMEDI_ISADMA_READ)
 			dt282x_ai_dma_interrupt(dev, s);
 		else
 			dt282x_ao_dma_interrupt(dev, s_ao);
@@ -752,6 +724,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int ret;
 
@@ -773,8 +746,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;
 	devpriv->nread = devpriv->ntrig;
 
-	devpriv->dma_dir = DMA_MODE_READ;
-	devpriv->cur_dma = 0;
+	devpriv->dma_dir = COMEDI_ISADMA_READ;
+	dma->cur_dma = 0;
 	dt282x_prep_ai_dma(dev, 0, 0);
 	if (devpriv->ntrig) {
 		dt282x_prep_ai_dma(dev, 1, 0);
@@ -937,6 +910,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_isadma *dma = devpriv->dma;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	dt282x_disable_dma(dev);
@@ -953,8 +927,8 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;
 	devpriv->nread = devpriv->ntrig;
 
-	devpriv->dma_dir = DMA_MODE_WRITE;
-	devpriv->cur_dma = 0;
+	devpriv->dma_dir = COMEDI_ISADMA_WRITE;
+	dma->cur_dma = 0;
 
 	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);
 
@@ -1058,13 +1032,12 @@ static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 	return ai_range_table[x];
 }
 
-static int dt282x_alloc_dma(struct comedi_device *dev,
-			    struct comedi_devconfig *it)
+static void dt282x_alloc_dma(struct comedi_device *dev,
+			     struct comedi_devconfig *it)
 {
 	struct dt282x_private *devpriv = dev->private;
 	unsigned int irq_num = it->options[1];
 	unsigned int dma_chan[2];
-	int i;
 
 	if (it->options[2] < it->options[3]) {
 		dma_chan[0] = it->options[2];
@@ -1077,53 +1050,24 @@ static int dt282x_alloc_dma(struct comedi_device *dev,
 	if (!irq_num || dma_chan[0] == dma_chan[1] ||
 	    dma_chan[0] < 5 || dma_chan[0] > 7 ||
 	    dma_chan[1] < 5 || dma_chan[1] > 7)
-		return 0;
+		return;
 
 	if (request_irq(irq_num, dt282x_interrupt, 0, dev->board_name, dev))
-		return 0;
-	if (request_dma(dma_chan[0], dev->board_name)) {
-		free_irq(irq_num, dev);
-		return 0;
-	}
-	if (request_dma(dma_chan[1], dev->board_name)) {
-		free_dma(dma_chan[0]);
-		free_irq(irq_num, dev);
-		return 0;
-	}
-
-	dev->irq = irq_num;
-
-	devpriv->dma_maxsize = PAGE_SIZE;
-	for (i = 0; i < 2; i++) {
-		struct dt282x_dma_desc *dma = &devpriv->dma_desc[i];
-
-		dma->chan = dma_chan[i];
-		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->dma_maxsize,
-						    &dma->hw_addr, GFP_KERNEL);
-		if (!dma->virt_addr)
-			return -ENOMEM;
-	}
+		return;
 
-	return 0;
+	/* DMA uses two 4K buffers with separate DMA channels */
+	devpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan[0], dma_chan[1],
+					   PAGE_SIZE, 0);
+	if (!devpriv->dma)
+		free_irq(irq_num, dev);
 }
 
 static void dt282x_free_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct dt282x_dma_desc *dma;
-	int i;
 
-	if (!devpriv)
-		return;
-
-	for (i = 0; i < 2; i++) {
-		dma = &devpriv->dma_desc[i];
-		if (dma->chan)
-			free_dma(dma->chan);
-		if (dma->virt_addr)
-			dma_free_coherent(NULL, devpriv->dma_maxsize,
-					  dma->virt_addr, dma->hw_addr);
-	}
+	if (devpriv)
+		comedi_isadma_free(devpriv->dma);
 }
 
 static int dt282x_initialize(struct comedi_device *dev)
@@ -1181,9 +1125,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	/* an IRQ and 2 DMA channels are required for async command support */
-	ret = dt282x_alloc_dma(dev, it);
-	if (ret)
-		return ret;
+	dt282x_alloc_dma(dev, it);
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit 7877445b5c1bb10078ef72db65df1553f4cbd73e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:25 2015 -0700

    staging: comedi: dt282x: introduce dt282x_isadma_disable()
    
    According to Documentation/DMA-ISA-LPC.txt, the DMA lock needs to be
    claimed before using any of the ISA DMA routines. Introduce a helper
    function to disable the ISA DMA controller and add the necessary
    locking calls.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2d01c6cfbb4d..54c679a0387b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -339,6 +339,15 @@ static void dt282x_isadma_program(struct dt282x_dma_desc *dma)
 	release_dma_lock(flags);
 }
 
+static void dt282x_isadma_disable(struct dt282x_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	disable_dma(dma->chan);
+	release_dma_lock(flags);
+}
+
 static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
@@ -377,9 +386,10 @@ static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 static void dt282x_disable_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
+	int i;
 
-	disable_dma(devpriv->dma_desc[0].chan);
-	disable_dma(devpriv->dma_desc[1].chan);
+	for (i = 0; i < 2; i++)
+		dt282x_isadma_disable(&devpriv->dma_desc[i]);
 }
 
 static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
@@ -463,7 +473,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	disable_dma(dma->chan);
+	dt282x_isadma_disable(dma);
 
 	if (!dt282x_ao_setup_dma(dev, s, devpriv->cur_dma))
 		s->async->events |= COMEDI_CB_OVERFLOW;
@@ -482,7 +492,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	disable_dma(dma->chan);
+	dt282x_isadma_disable(dma);
 
 	dt282x_munge(dev, s, dma->virt_addr, dma->size);
 	ret = comedi_buf_write_samples(s, dma->virt_addr, nsamples);

commit f609c29dfb7a5729bfab9384fad45fbf12653c67
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 13 10:16:24 2015 -0700

    staging: comedi: dt282x: introduce dt282x_isadma_program()
    
    Introduce a helper function to program the ISA DMA controller. Program
    the ISA DMA as described in Documentation/DMA-ISA-LPC.txt.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f24ad6684bf5..2d01c6cfbb4d 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -305,6 +305,7 @@ struct dt282x_dma_desc {
 	void *virt_addr;	/* virtual address of DMA buffer */
 	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 	unsigned int size;	/* transfer size (in bytes) */
+	char mode;		/* DMA_MODE_* */
 };
 
 struct dt282x_private {
@@ -325,11 +326,23 @@ struct dt282x_private {
 	int dma_dir;
 };
 
+static void dt282x_isadma_program(struct dt282x_dma_desc *dma)
+{
+	unsigned long flags;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(dma->chan);
+	set_dma_mode(dma->chan, dma->mode);
+	set_dma_addr(dma->chan, dma->hw_addr);
+	set_dma_count(dma->chan, dma->size);
+	enable_dma(dma->chan);
+	release_dma_lock(flags);
+}
+
 static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
 	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
-	unsigned long flags;
 
 	if (!devpriv->ntrig)
 		return 0;
@@ -341,15 +354,9 @@ static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 	devpriv->ntrig -= n / 2;
 
 	dma->size = n;
+	dma->mode = DMA_MODE_READ;
 
-	set_dma_mode(dma->chan, DMA_MODE_READ);
-	flags = claim_dma_lock();
-	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	release_dma_lock(flags);
-
-	enable_dma(dma->chan);
+	dt282x_isadma_program(dma);
 
 	return n;
 }
@@ -358,18 +365,11 @@ static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
 	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
-	unsigned long flags;
 
 	dma->size = n;
+	dma->mode = DMA_MODE_WRITE;
 
-	set_dma_mode(dma->chan, DMA_MODE_WRITE);
-	flags = claim_dma_lock();
-	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, dma->hw_addr);
-	set_dma_count(dma->chan, dma->size);
-	release_dma_lock(flags);
-
-	enable_dma(dma->chan);
+	dt282x_isadma_program(dma);
 
 	return n;
 }

commit ef98a104c2ffa885de4e5bb76fb2e80fa677f7c5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:11 2015 -0700

    staging: comedi: dt282x: remove VIRT_TO_BUS dependancy
    
    Use dma_{alloc,free}_coherent() to allocate and free the DMA buffers.
    This removes the dependancy on VIRT_TO_BUS.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 8ee61861f7ae..f24ad6684bf5 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -302,7 +302,8 @@ static const struct dt282x_board boardtypes[] = {
 
 struct dt282x_dma_desc {
 	unsigned int chan;	/* DMA channel */
-	unsigned short *virt_addr;	/* virtual address of DMA buffer */
+	void *virt_addr;	/* virtual address of DMA buffer */
+	dma_addr_t hw_addr;	/* hardware (bus) address of DMA buffer */
 	unsigned int size;	/* transfer size (in bytes) */
 };
 
@@ -344,7 +345,7 @@ static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 	set_dma_mode(dma->chan, DMA_MODE_READ);
 	flags = claim_dma_lock();
 	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_addr(dma->chan, dma->hw_addr);
 	set_dma_count(dma->chan, dma->size);
 	release_dma_lock(flags);
 
@@ -364,7 +365,7 @@ static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 	set_dma_mode(dma->chan, DMA_MODE_WRITE);
 	flags = claim_dma_lock();
 	clear_dma_ff(dma->chan);
-	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_addr(dma->chan, dma->hw_addr);
 	set_dma_count(dma->chan, dma->size);
 	release_dma_lock(flags);
 
@@ -1087,7 +1088,8 @@ static int dt282x_alloc_dma(struct comedi_device *dev,
 		struct dt282x_dma_desc *dma = &devpriv->dma_desc[i];
 
 		dma->chan = dma_chan[i];
-		dma->virt_addr = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+		dma->virt_addr = dma_alloc_coherent(NULL, devpriv->dma_maxsize,
+						    &dma->hw_addr, GFP_KERNEL);
 		if (!dma->virt_addr)
 			return -ENOMEM;
 	}
@@ -1109,7 +1111,8 @@ static void dt282x_free_dma(struct comedi_device *dev)
 		if (dma->chan)
 			free_dma(dma->chan);
 		if (dma->virt_addr)
-			free_page((unsigned long)dma->virt_addr);
+			dma_free_coherent(NULL, devpriv->dma_maxsize,
+					  dma->virt_addr, dma->hw_addr);
 	}
 }
 

commit eca331c20fbedaf04b28b79f388ae0836db33e5e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:10 2015 -0700

    staging: comedi: dt282x: introduce struct dt282x_dma_desc
    
    For aesthetics, introduce a struct to hold the DMA descriptor data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 873aae6f6985..8ee61861f7ae 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -300,6 +300,12 @@ static const struct dt282x_board boardtypes[] = {
 	},
 };
 
+struct dt282x_dma_desc {
+	unsigned int chan;	/* DMA channel */
+	unsigned short *virt_addr;	/* virtual address of DMA buffer */
+	unsigned int size;	/* transfer size (in bytes) */
+};
+
 struct dt282x_private {
 	unsigned int ad_2scomp:1;
 
@@ -312,21 +318,16 @@ struct dt282x_private {
 	int ntrig;
 	int nread;
 
-	struct {
-		int chan;
-		unsigned short *buf;	/* DMA buffer */
-		int size;	/* size of current transfer */
-	} dma[2];
+	struct dt282x_dma_desc dma_desc[2];
 	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
-	int current_dma_index;
+	int cur_dma;
 	int dma_dir;
 };
 
 static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int dma_chan;
-	unsigned long dma_ptr;
+	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
 	unsigned long flags;
 
 	if (!devpriv->ntrig)
@@ -338,18 +339,16 @@ static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 		n = devpriv->ntrig * 2;
 	devpriv->ntrig -= n / 2;
 
-	devpriv->dma[dma_index].size = n;
-	dma_chan = devpriv->dma[dma_index].chan;
-	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+	dma->size = n;
 
-	set_dma_mode(dma_chan, DMA_MODE_READ);
+	set_dma_mode(dma->chan, DMA_MODE_READ);
 	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_addr(dma_chan, dma_ptr);
-	set_dma_count(dma_chan, n);
+	clear_dma_ff(dma->chan);
+	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_count(dma->chan, dma->size);
 	release_dma_lock(flags);
 
-	enable_dma(dma_chan);
+	enable_dma(dma->chan);
 
 	return n;
 }
@@ -357,22 +356,19 @@ static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int dma_chan;
-	unsigned long dma_ptr;
+	struct dt282x_dma_desc *dma = &devpriv->dma_desc[dma_index];
 	unsigned long flags;
 
-	devpriv->dma[dma_index].size = n;
-	dma_chan = devpriv->dma[dma_index].chan;
-	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+	dma->size = n;
 
-	set_dma_mode(dma_chan, DMA_MODE_WRITE);
+	set_dma_mode(dma->chan, DMA_MODE_WRITE);
 	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_addr(dma_chan, dma_ptr);
-	set_dma_count(dma_chan, n);
+	clear_dma_ff(dma->chan);
+	set_dma_addr(dma->chan, virt_to_bus(dma->virt_addr));
+	set_dma_count(dma->chan, dma->size);
 	release_dma_lock(flags);
 
-	enable_dma(dma_chan);
+	enable_dma(dma->chan);
 
 	return n;
 }
@@ -381,8 +377,8 @@ static void dt282x_disable_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
 
-	disable_dma(devpriv->dma[0].chan);
-	disable_dma(devpriv->dma[1].chan);
+	disable_dma(devpriv->dma_desc[0].chan);
+	disable_dma(devpriv->dma_desc[1].chan);
 }
 
 static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
@@ -444,11 +440,11 @@ static unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,
 					int cur_dma)
 {
 	struct dt282x_private *devpriv = dev->private;
-	void *ptr = devpriv->dma[cur_dma].buf;
+	struct dt282x_dma_desc *dma = &devpriv->dma_desc[cur_dma];
 	unsigned int nsamples = comedi_bytes_to_samples(s, devpriv->dma_maxsize);
 	unsigned int nbytes;
 
-	nbytes = comedi_buf_read_samples(s, ptr, nsamples);
+	nbytes = comedi_buf_read_samples(s, dma->virt_addr, nsamples);
 	if (nbytes)
 		dt282x_prep_ao_dma(dev, cur_dma, nbytes);
 	else
@@ -461,39 +457,35 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int cur_dma = devpriv->current_dma_index;
+	struct dt282x_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	disable_dma(devpriv->dma[cur_dma].chan);
+	disable_dma(dma->chan);
 
-	devpriv->current_dma_index = 1 - cur_dma;
-
-	if (!dt282x_ao_setup_dma(dev, s, cur_dma))
+	if (!dt282x_ao_setup_dma(dev, s, devpriv->cur_dma))
 		s->async->events |= COMEDI_CB_OVERFLOW;
+
+	devpriv->cur_dma = 1 - devpriv->cur_dma;
 }
 
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int cur_dma = devpriv->current_dma_index;
-	void *ptr = devpriv->dma[cur_dma].buf;
-	int size = devpriv->dma[cur_dma].size;
-	unsigned int nsamples = comedi_bytes_to_samples(s, size);
+	struct dt282x_dma_desc *dma = &devpriv->dma_desc[devpriv->cur_dma];
+	unsigned int nsamples = comedi_bytes_to_samples(s, dma->size);
 	int ret;
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
 
-	disable_dma(devpriv->dma[cur_dma].chan);
+	disable_dma(dma->chan);
 
-	devpriv->current_dma_index = 1 - cur_dma;
-
-	dt282x_munge(dev, s, ptr, size);
-	ret = comedi_buf_write_samples(s, ptr, nsamples);
-	if (ret != size)
+	dt282x_munge(dev, s, dma->virt_addr, dma->size);
+	ret = comedi_buf_write_samples(s, dma->virt_addr, nsamples);
+	if (ret != dma->size)
 		return;
 
 	devpriv->nread -= nsamples;
@@ -514,7 +506,9 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	}
 #endif
 	/* restart the channel */
-	dt282x_prep_ai_dma(dev, cur_dma, 0);
+	dt282x_prep_ai_dma(dev, devpriv->cur_dma, 0);
+
+	devpriv->cur_dma = 1 - devpriv->cur_dma;
 }
 
 static irqreturn_t dt282x_interrupt(int irq, void *d)
@@ -769,7 +763,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->nread = devpriv->ntrig;
 
 	devpriv->dma_dir = DMA_MODE_READ;
-	devpriv->current_dma_index = 0;
+	devpriv->cur_dma = 0;
 	dt282x_prep_ai_dma(dev, 0, 0);
 	if (devpriv->ntrig) {
 		dt282x_prep_ai_dma(dev, 1, 0);
@@ -949,7 +943,7 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->nread = devpriv->ntrig;
 
 	devpriv->dma_dir = DMA_MODE_WRITE;
-	devpriv->current_dma_index = 0;
+	devpriv->cur_dma = 0;
 
 	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);
 
@@ -1090,10 +1084,11 @@ static int dt282x_alloc_dma(struct comedi_device *dev,
 
 	devpriv->dma_maxsize = PAGE_SIZE;
 	for (i = 0; i < 2; i++) {
-		devpriv->dma[i].chan = dma_chan[i];
-		devpriv->dma[i].buf =
-			(void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-		if (!devpriv->dma[i].buf)
+		struct dt282x_dma_desc *dma = &devpriv->dma_desc[i];
+
+		dma->chan = dma_chan[i];
+		dma->virt_addr = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+		if (!dma->virt_addr)
 			return -ENOMEM;
 	}
 
@@ -1103,18 +1098,18 @@ static int dt282x_alloc_dma(struct comedi_device *dev,
 static void dt282x_free_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct dt282x_dma_desc *dma;
 	int i;
 
 	if (!devpriv)
 		return;
 
 	for (i = 0; i < 2; i++) {
-		if (devpriv->dma[i].chan)
-			free_dma(devpriv->dma[i].chan);
-		if (devpriv->dma[i].buf)
-			free_page((unsigned long)devpriv->dma[i].buf);
-		devpriv->dma[i].chan = 0;
-		devpriv->dma[i].buf = NULL;
+		dma = &devpriv->dma_desc[i];
+		if (dma->chan)
+			free_dma(dma->chan);
+		if (dma->virt_addr)
+			free_page((unsigned long)dma->virt_addr);
 	}
 }
 

commit d5702e34761bd821709234e7900ddbfd19f1c321
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jan 12 10:56:09 2015 -0700

    staging: comedi: dt282x: introduce dt282x_alloc_dma()
    
    The IRA and DMA are optional with this driver but both are required to
    support async commands. Introduce a helper function to request the IRQ
    and DMA channel and allocate the buffers. Don't fail the driver attach
    if the user passed an invalid IRQ or DMA channel or they cannot be
    requested.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index cfa0f9781cf2..873aae6f6985 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1053,26 +1053,49 @@ static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 	return ai_range_table[x];
 }
 
-static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
+static int dt282x_alloc_dma(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int ret;
+	unsigned int irq_num = it->options[1];
+	unsigned int dma_chan[2];
+	int i;
 
-	ret = request_dma(dma1, "dt282x A");
-	if (ret)
-		return -EBUSY;
-	devpriv->dma[0].chan = dma1;
+	if (it->options[2] < it->options[3]) {
+		dma_chan[0] = it->options[2];
+		dma_chan[1] = it->options[3];
+	} else {
+		dma_chan[0] = it->options[3];
+		dma_chan[1] = it->options[2];
+	}
 
-	ret = request_dma(dma2, "dt282x B");
-	if (ret)
-		return -EBUSY;
-	devpriv->dma[1].chan = dma2;
+	if (!irq_num || dma_chan[0] == dma_chan[1] ||
+	    dma_chan[0] < 5 || dma_chan[0] > 7 ||
+	    dma_chan[1] < 5 || dma_chan[1] > 7)
+		return 0;
+
+	if (request_irq(irq_num, dt282x_interrupt, 0, dev->board_name, dev))
+		return 0;
+	if (request_dma(dma_chan[0], dev->board_name)) {
+		free_irq(irq_num, dev);
+		return 0;
+	}
+	if (request_dma(dma_chan[1], dev->board_name)) {
+		free_dma(dma_chan[0]);
+		free_irq(irq_num, dev);
+		return 0;
+	}
+
+	dev->irq = irq_num;
 
 	devpriv->dma_maxsize = PAGE_SIZE;
-	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf)
-		return -ENOMEM;
+	for (i = 0; i < 2; i++) {
+		devpriv->dma[i].chan = dma_chan[i];
+		devpriv->dma[i].buf =
+			(void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+		if (!devpriv->dma[i].buf)
+			return -ENOMEM;
+	}
 
 	return 0;
 }
@@ -1150,36 +1173,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	/* an IRQ and 2 DMA channels are required for async command support */
-	if (it->options[1] && it->options[2] && it->options[3]) {
-		unsigned int irq = it->options[1];
-		unsigned int dma1 = it->options[2];
-		unsigned int dma2 = it->options[3];
-
-		if (dma2 < dma1) {
-			unsigned int swap;
-
-			swap = dma1;
-			dma1 = dma2;
-			dma2 = swap;
-		}
-
-		if (dma1 != dma2 &&
-		    dma1 >= 5 && dma1 <= 7 &&
-		    dma2 >= 5 && dma2 <= 7) {
-			ret = request_irq(irq, dt282x_interrupt, 0,
-					  dev->board_name, dev);
-			if (ret == 0) {
-				dev->irq = irq;
-
-				ret = dt282x_grab_dma(dev, dma1, dma2);
-				if (ret < 0) {
-					dt282x_free_dma(dev);
-					free_irq(dev->irq, dev);
-					dev->irq = 0;
-				}
-			}
-		}
-	}
+	ret = dt282x_alloc_dma(dev, it);
+	if (ret)
+		return ret;
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)

commit f8e82bb315d1d999481e29149f1709ebdc247c11
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jan 5 17:54:45 2015 +0000

    staging: comedi: dt282x: rewrite "Devices:" line
    
    Rewrite the "Devices:" line in the comedi "driver" comment to conform to
    the usual comedi format for this line.  The line should be a
    comma-separated list where the first item is in the following format:
    
      [Manufacturer] BOARD-NAME (comedi-board-name)
    
    The "[Manufacturer]" and/or "(comedi-board-name)" parts may be omitted
    from following items, in which case the parts from the preceding item
    are used.  The "Devices:" line may be continued continued over several
    lines by using one or more spaces at the start of each continuation line
    (not counting the space after the "*" in the block comment).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2be98bb9a809..cfa0f9781cf2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -20,22 +20,12 @@
  * Driver: dt282x
  * Description: Data Translation DT2821 series (including DT-EZ)
  * Author: ds
- * Devices: (Data Translation) DT2821 [dt2821]
- *	    (Data Translation) DT2821-F-16SE [dt2821-f]
- *	    (Data Translation) DT2821-F-8DI [dt2821-f]
- *	    (Data Translation) DT2821-G-16SE [dt2821-g]
- *	    (Data Translation) DT2821-G-8DI [dt2821-g]
- *	    (Data Translation) DT2823 [dt2823]
- *	    (Data Translation) DT2824-PGH [dt2824-pgh]
- *	    (Data Translation) DT2824-PGL [dt2824-pgl]
- *	    (Data Translation) DT2825 [dt2825]
- *	    (Data Translation) DT2827 [dt2827]
- *	    (Data Translation) DT2828 [dt2828]
- *	    (Data Translation) DT2928 [dt2829]
- *	    (Data Translation) DT21-EZ [dt21-ez]
- *	    (Data Translation) DT23-EZ [dt23-ez]
- *	    (Data Translation) DT24-EZ [dt24-ez]
- *	    (Data Translation) DT24-EZ-PGL [dt24-ez-pgl]
+ * Devices: [Data Translation] DT2821 (dt2821), DT2821-F-16SE (dt2821-f),
+ *   DT2821-F-8DI (dt2821-f), DT2821-G-16SE (dt2821-g),
+ *   DT2821-G-8DI (dt2821-g), DT2823 (dt2823), DT2824-PGH (dt2824-pgh),
+ *   DT2824-PGL (dt2824-pgl), DT2825 (dt2825), DT2827 (dt2827),
+ *   DT2828 (dt2828), DT2928 (dt2829), DT21-EZ (dt21-ez), DT23-EZ (dt23-ez),
+ *   DT24-EZ (dt24-ez), DT24-EZ-PGL (dt24-ez-pgl)
  * Status: complete
  * Updated: Wed, 22 Aug 2001 17:11:34 -0700
  *

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 674e03eb1601..2be98bb9a809 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1231,7 +1231,6 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		/* ranges are per-channel, set by jumpers on the board */
 		s->range_table	= &dt282x_ao_range;
 		s->insn_write	= dt282x_ao_insn_write;
-		s->insn_read	= comedi_readback_insn_read;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags	|= SDF_CMD_WRITE;

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 1d9fa371d03c..674e03eb1601 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -455,7 +455,7 @@ static unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,
 {
 	struct dt282x_private *devpriv = dev->private;
 	void *ptr = devpriv->dma[cur_dma].buf;
-	unsigned int nsamples = devpriv->dma_maxsize / bytes_per_sample(s);
+	unsigned int nsamples = comedi_bytes_to_samples(s, devpriv->dma_maxsize);
 	unsigned int nbytes;
 
 	nbytes = comedi_buf_read_samples(s, ptr, nsamples);
@@ -491,7 +491,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	int cur_dma = devpriv->current_dma_index;
 	void *ptr = devpriv->dma[cur_dma].buf;
 	int size = devpriv->dma[cur_dma].size;
-	unsigned int nsamples = size / bytes_per_sample(s);
+	unsigned int nsamples = comedi_bytes_to_samples(s, size);
 	int ret;
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,

commit d4c2acd233191fe67fddac7bf74e93ddb12bc1f7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:42 2014 -0700

    staging: comedi: dt282x: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will determining the number of bytes to add based on the
    bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 88b56104d4e7..1d9fa371d03c 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -491,6 +491,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	int cur_dma = devpriv->current_dma_index;
 	void *ptr = devpriv->dma[cur_dma].buf;
 	int size = devpriv->dma[cur_dma].size;
+	unsigned int nsamples = size / bytes_per_sample(s);
 	int ret;
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
@@ -501,13 +502,11 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	devpriv->current_dma_index = 1 - cur_dma;
 
 	dt282x_munge(dev, s, ptr, size);
-	ret = cfc_write_array_to_buffer(s, ptr, size);
-	if (ret != size) {
-		s->async->events |= COMEDI_CB_OVERFLOW;
+	ret = comedi_buf_write_samples(s, ptr, nsamples);
+	if (ret != size)
 		return;
-	}
 
-	devpriv->nread -= size / 2;
+	devpriv->nread -= nsamples;
 	if (devpriv->nread < 0) {
 		dev_info(dev->class_dev, "nread off by one\n");
 		devpriv->nread = 0;
@@ -566,7 +565,6 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	}
 #if 0
 	if (adcsr & DT2821_ADCSR_ADDONE) {
-		int ret;
 		unsigned short data;
 
 		data = inw(dev->iobase + DT2821_ADDAT_REG);
@@ -574,10 +572,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		if (devpriv->ad_2scomp)
 			data = comedi_offset_munge(s, data);
 
-		ret = comedi_buf_put(s, data);
-
-		if (ret == 0)
-			s->async->events |= COMEDI_CB_OVERFLOW;
+		comedi_buf_write_samples(s, &data, 1);
 
 		devpriv->nread--;
 		if (!devpriv->nread) {

commit ecb11d8c28aa7fe761467873e69a3c5c66b57aed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:38 2014 -0700

    staging: comedi: dt282x: introduce dt282x_ao_setup_dma()
    
    Introduce a helper function to read the analog output samples from the
    async buffer and prep the DMA.
    
    Use comedi_buf_read_samples() to read the analog output samples from
    the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f23d883f2544..88b56104d4e7 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -449,13 +449,29 @@ static void dt282x_munge(struct comedi_device *dev,
 	}
 }
 
+static unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					int cur_dma)
+{
+	struct dt282x_private *devpriv = dev->private;
+	void *ptr = devpriv->dma[cur_dma].buf;
+	unsigned int nsamples = devpriv->dma_maxsize / bytes_per_sample(s);
+	unsigned int nbytes;
+
+	nbytes = comedi_buf_read_samples(s, ptr, nsamples);
+	if (nbytes)
+		dt282x_prep_ao_dma(dev, cur_dma, nbytes);
+	else
+		dev_err(dev->class_dev, "AO underrun\n");
+
+	return nbytes;
+}
+
 static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
 	int cur_dma = devpriv->current_dma_index;
-	void *ptr = devpriv->dma[cur_dma].buf;
-	int size;
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
 	     dev->iobase + DT2821_SUPCSR_REG);
@@ -464,13 +480,8 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 
 	devpriv->current_dma_index = 1 - cur_dma;
 
-	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
-	if (size == 0) {
-		dev_err(dev->class_dev, "AO underrun\n");
+	if (!dt282x_ao_setup_dma(dev, s, cur_dma))
 		s->async->events |= COMEDI_CB_OVERFLOW;
-	} else {
-		dt282x_prep_ao_dma(dev, cur_dma, size);
-	}
 }
 
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
@@ -916,26 +927,15 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 {
 	struct dt282x_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int size;
 
 	if (trig_num != cmd->start_src)
 		return -EINVAL;
 
-	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
-					  devpriv->dma_maxsize);
-	if (size == 0) {
-		dev_err(dev->class_dev, "AO underrun\n");
+	if (!dt282x_ao_setup_dma(dev, s, 0))
 		return -EPIPE;
-	}
-	dt282x_prep_ao_dma(dev, 0, size);
 
-	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
-					  devpriv->dma_maxsize);
-	if (size == 0) {
-		dev_err(dev->class_dev, "AO underrun\n");
+	if (!dt282x_ao_setup_dma(dev, s, 1))
 		return -EPIPE;
-	}
-	dt282x_prep_ao_dma(dev, 1, size);
 
 	outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
 	     dev->iobase + DT2821_SUPCSR_REG);

commit 4f6f009b204fca46136de98c10332de5f3e91ce8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:24 2014 -0700

    staging: comedi: dt282x: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index cc974a5e5cf6..f23d883f2544 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -579,8 +579,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		handled = 1;
 	}
 #endif
-	cfc_handle_events(dev, s);
-	cfc_handle_events(dev, s_ao);
+	comedi_handle_events(dev, s);
+	comedi_handle_events(dev, s_ao);
 
 	return IRQ_RETVAL(handled);
 }

commit 759658ddff327675bbf35063e2b04e0d7424124d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:48 2014 -0700

    staging: comedi: dt282x: prevent "empty acquisition" async commands
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0 for both the analog input and output async commands. The (*do_cmd) for
    both subdevices sets up and starts the command without handling the "empty
    acquisition". This results in the interrupt functions trying to transfer 0 data
    samples.
    
    Validate that the cmd->stop_arg is >= 1 in the (*do_cmdtest) to prevent the
    "empty acquisition".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e725e3bf1532..cc974a5e5cf6 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -728,11 +728,10 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {	/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_EXT | TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;
@@ -890,11 +889,10 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_COUNT) {
-		/* any count is allowed */
-	} else {	/* TRIG_NONE */
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_EXT | TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-	}
 
 	if (err)
 		return 3;

commit a4759d39e25cf8858e66608cee04f29910225e11
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:33 2014 +0100

    staging: comedi: dt282x: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 4017fcbe641a..e725e3bf1532 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -681,7 +681,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_cmd *cmd)
 {
-	const struct dt282x_board *board = comedi_board(dev);
+	const struct dt282x_board *board = dev->board_ptr;
 	struct dt282x_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -1149,7 +1149,7 @@ static int dt282x_initialize(struct comedi_device *dev)
  */
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct dt282x_board *board = comedi_board(dev);
+	const struct dt282x_board *board = dev->board_ptr;
 	struct dt282x_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;

commit ba81e62d9934d072a77c01cd7715eed0816b5c53
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:52 2014 +0100

    staging: comedi: dt282x: use CMDF_ROUND_...
    
    Replace use of the `TRIG_ROUND_...` macros with the new names
    `CMDF_ROUND_...`.  The numeric values are unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index b98969154c6a..4017fcbe641a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -403,15 +403,15 @@ static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 		if (prescale == 1)
 			continue;
 		base = 250 * (1 << prescale);
-		switch (flags & TRIG_ROUND_MASK) {
-		case TRIG_ROUND_NEAREST:
+		switch (flags & CMDF_ROUND_MASK) {
+		case CMDF_ROUND_NEAREST:
 		default:
 			divider = (*ns + base / 2) / base;
 			break;
-		case TRIG_ROUND_DOWN:
+		case CMDF_ROUND_DOWN:
 			divider = (*ns) / base;
 			break;
-		case TRIG_ROUND_UP:
+		case CMDF_ROUND_UP:
 			divider = (*ns + base - 1) / base;
 			break;
 		}

commit 559975c175767ccb2f0f9a8231b3fcb3adcd1650
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:04 2014 -0700

    staging: comedi: dt282x: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5de26745783a..b98969154c6a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -315,8 +315,6 @@ struct dt282x_private {
 
 	unsigned int divisor;
 
-	unsigned short ao_readback[2];
-
 	int dacsr;	/* software copies of registers */
 	int adcsr;
 	int supcsr;
@@ -826,21 +824,6 @@ static int dt282x_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static int dt282x_ao_insn_read(struct comedi_device *dev,
-			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn,
-			       unsigned int *data)
-{
-	struct dt282x_private *devpriv = dev->private;
-	unsigned int chan = CR_CHAN(insn->chanspec);
-	int i;
-
-	for (i = 0; i < insn->n; i++)
-		data[i] = devpriv->ao_readback[chan];
-
-	return insn->n;
-}
-
 static int dt282x_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn,
@@ -849,14 +832,14 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 	struct dt282x_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
-	unsigned int val;
 	int i;
 
 	devpriv->dacsr |= DT2821_DACSR_SSEL | DT2821_DACSR_YSEL(chan);
 
 	for (i = 0; i < insn->n; i++) {
-		val = data[i];
-		devpriv->ao_readback[chan] = val;
+		unsigned int val = data[i];
+
+		s->readback[chan] = val;
 
 		if (comedi_range_is_bipolar(s, range))
 			val = comedi_offset_munge(s, val);
@@ -1252,12 +1235,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags	= SDF_WRITABLE;
 		s->n_chan	= board->dachan;
 		s->maxdata	= board->ao_maxdata;
-
 		/* ranges are per-channel, set by jumpers on the board */
 		s->range_table	= &dt282x_ao_range;
-
-		s->insn_read	= dt282x_ao_insn_read;
 		s->insn_write	= dt282x_ao_insn_write;
+		s->insn_read	= comedi_readback_insn_read;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags	|= SDF_CMD_WRITE;
@@ -1266,6 +1247,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			s->do_cmd	= dt282x_ao_cmd;
 			s->cancel	= dt282x_ao_cancel;
 		}
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
 	} else {
 		s->type		= COMEDI_SUBD_UNUSED;
 	}

commit 5a96ffbe795d71347fbebac9cf29772543d22961
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:39 2014 -0700

    staging: comedi: dt282x: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index cacb4f40bbba..5de26745783a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -438,7 +438,8 @@ static void dt282x_munge(struct comedi_device *dev,
 	int i;
 
 	if (nbytes % 2)
-		comedi_error(dev, "bug! odd number of bytes from dma xfer");
+		dev_err(dev->class_dev,
+			"bug! odd number of bytes from dma xfer\n");
 
 	for (i = 0; i < nbytes / 2; i++) {
 		val = buf[i];
@@ -528,7 +529,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	int handled = 0;
 
 	if (!dev->attached) {
-		comedi_error(dev, "spurious interrupt");
+		dev_err(dev->class_dev, "spurious interrupt\n");
 		return IRQ_HANDLED;
 	}
 
@@ -544,13 +545,13 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	}
 	if (adcsr & DT2821_ADCSR_ADERR) {
 		if (devpriv->nread != 0) {
-			comedi_error(dev, "A/D error");
+			dev_err(dev->class_dev, "A/D error\n");
 			s->async->events |= COMEDI_CB_ERROR;
 		}
 		handled = 1;
 	}
 	if (dacsr & DT2821_DACSR_DAERR) {
-		comedi_error(dev, "D/A error");
+		dev_err(dev->class_dev, "D/A error\n");
 		s_ao->async->events |= COMEDI_CB_ERROR;
 		handled = 1;
 	}

commit aa2998450bcd44979b44ed8d4f226e3f486b3bb4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:23 2014 -0700

    staging: comedi: dt282x: checkpatch.pl cleanup (else after return)
    
    Fix checkpatch.pl warning:
    
    WARNING: else is not generally useful after a break or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 27a8bb18bcd5..cacb4f40bbba 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1079,11 +1079,11 @@ static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 		if (x < 0 || x >= 2)
 			x = 0;
 		return ai_range_pgl_table[x];
-	} else {
-		if (x < 0 || x >= 4)
-			x = 0;
-		return ai_range_table[x];
 	}
+
+	if (x < 0 || x >= 4)
+		x = 0;
+	return ai_range_table[x];
 }
 
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)

commit d7b6c574d17fed09a0d9fa4bc7674c13fa156805
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:13:02 2014 -0700

    staging: comedi: dt282x: automatically handle D/A data format
    
    The DT2821 series board have jumpers that set the output range for
    the two Analog Output channels. The range_table for the Analog Output
    subdevice provides all possible ranges to the user. When a unipolar
    range is selected the board expects the data to be in a straight
    binary format. When a bipolar range is select the data should be in
    two's complement format.
    
    Currently, the user passes some configuration options when attaching
    to the driver to select the data format for each channel. If the
    user does not pass the config options, the data format is assumed to
    be straight binary.
    
    The Analog Output subdevice now has a range_table that provides the
    user will all possible ranges. Use the range information to determine
    if the data values need to be munged into two's complememnt values
    and deprecate the config options.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e30a0646f4f1..27a8bb18bcd5 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -46,8 +46,8 @@
  *   [3] - DMA 2 (optional, required for async command support)
  *   [4] - AI jumpered for 0=single ended, 1=differential
  *   [5] - AI jumpered for 0=straight binary, 1=2's complement
- *   [6] - AO 0 jumpered for 0=straight binary, 1=2's complement
- *   [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
+ *   [6] - AO 0 data format (deprecated, see below)
+ *   [7] - AO 1 data format (deprecated, see below)
  *   [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
  *   [9] - AO channel 0 range (deprecated, see below)
  *   [10]- AO channel 1 range (deprecated, see below)
@@ -60,7 +60,9 @@
  *   - AO range is not programmable. The AO subdevice has a range_table
  *     containing all the possible analog output ranges. Use the range
  *     that matches your board configuration to convert between data
- *     values and physical units.
+ *     values and physical units. The format of the data written to the
+ *     board is handled automatically based on the unipolar/bipolar
+ *     range that is selected.
  */
 
 #include <linux/module.h>
@@ -310,8 +312,6 @@ static const struct dt282x_board boardtypes[] = {
 
 struct dt282x_private {
 	unsigned int ad_2scomp:1;
-	unsigned int da0_2scomp:1;
-	unsigned int da1_2scomp:1;
 
 	unsigned int divisor;
 
@@ -847,24 +847,17 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 {
 	struct dt282x_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
-	bool munge = false;
+	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int val;
 	int i;
 
 	devpriv->dacsr |= DT2821_DACSR_SSEL | DT2821_DACSR_YSEL(chan);
-	if (chan) {
-		if (devpriv->da1_2scomp)
-			munge = true;
-	} else {
-		if (devpriv->da0_2scomp)
-			munge = true;
-	}
 
 	for (i = 0; i < insn->n; i++) {
 		val = data[i];
 		devpriv->ao_readback[chan] = val;
 
-		if (munge)
+		if (comedi_range_is_bipolar(s, range))
 			val = comedi_offset_munge(s, val);
 
 		outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
@@ -1261,8 +1254,6 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		/* ranges are per-channel, set by jumpers on the board */
 		s->range_table	= &dt282x_ao_range;
-		devpriv->da0_2scomp = it->options[6] ? 1 : 0;
-		devpriv->da1_2scomp = it->options[7] ? 1 : 0;
 
 		s->insn_read	= dt282x_ao_insn_read;
 		s->insn_write	= dt282x_ao_insn_write;

commit c50d32de3707ee8165eaeaa319c5c13d12ea0669
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:13:01 2014 -0700

    staging: comedi: dt282x: fix bug where DIO direction is reset to inputs
    
    The direction of the 16 DIO channels is controlled with two bits in the
    DACSR register. The HBOE bit controls the direction of channels 15-8 and
    the LBOE bit channels 7-0.
    
    The DACSR register is also used to control the Analog Output async command
    support. Currently, starting or canceling an Analog Output command would
    also reset the DIO directions so that all channels were inputs.
    
    Fix the driver so that the DIO direction is not changed when starting or
    canceling an Analog Output async command.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6e813bb562e8..e30a0646f4f1 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -993,9 +993,12 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);
 
-	devpriv->dacsr = DT2821_DACSR_SSEL |
-			 DT2821_DACSR_DACLK |
-			 DT2821_DACSR_IDARDY;
+	/* clear all bits but the DIO direction bits */
+	devpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);
+
+	devpriv->dacsr |= (DT2821_DACSR_SSEL |
+			   DT2821_DACSR_DACLK |
+			   DT2821_DACSR_IDARDY);
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
 	s->async->inttrig = dt282x_ao_inttrig;
@@ -1010,7 +1013,9 @@ static int dt282x_ao_cancel(struct comedi_device *dev,
 
 	dt282x_disable_dma(dev);
 
-	devpriv->dacsr = 0;
+	/* clear all bits but the DIO direction bits */
+	devpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);
+
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
 	devpriv->supcsr = 0;

commit 0f8e8c5ab67a818ad56291007796d17f16d0fd6a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:13:00 2014 -0700

    staging: comedi: dt282x: tidy up the register map and bit defines
    
    For aesthetics, rename the register map defines so that the bit defines
    are associated with the registers. Also, convert all the bit defines into
    bit-shifts to make them clear.
    
    Remove all the verbose comments. All the registers and bits are named
    according to the User Manual for the DT2821 Series, Document UM-05073-G.
    That manual can be checked if necessary for the verbose information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9d8b603cdf68..6e813bb562e8 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -76,70 +76,52 @@
 #include "comedi_fc.h"
 
 /*
- *    Registers in the DT282x
+ * Register map
  */
-
-#define DT2821_ADCSR	0x00	/* A/D Control/Status             */
-#define DT2821_CHANCSR	0x02	/* Channel Control/Status */
-#define DT2821_ADDAT	0x04	/* A/D data                       */
-#define DT2821_DACSR	0x06	/* D/A Control/Status             */
-#define DT2821_DADAT	0x08	/* D/A data                       */
-#define DT2821_DIODAT	0x0a	/* digital data                   */
-#define DT2821_SUPCSR	0x0c	/* Supervisor Control/Status      */
-#define DT2821_TMRCTR	0x0e	/* Timer/Counter          */
-
-/*
- *    Bit fields of each register
- */
-
-/* ADCSR */
-
-#define DT2821_ADERR	0x8000	/* (R)   1 for A/D error  */
-#define DT2821_ADCLK	0x0200	/* (R/W) A/D clock enable */
-		/*      0x7c00           read as 1's            */
-#define DT2821_MUXBUSY	0x0100	/* (R)   multiplexer busy */
-#define DT2821_ADDONE	0x0080	/* (R)   A/D done         */
-#define DT2821_IADDONE	0x0040	/* (R/W) interrupt on A/D done    */
-		/*      0x0030           gain select            */
-		/*      0x000f           channel select         */
-
-/* CHANCSR */
-
-#define DT2821_LLE	0x8000	/* (R/W) Load List Enable */
-		/*      0x7000           read as 1's            */
-		/*      0x0f00     (R)   present address        */
-		/*      0x00f0           read as 1's            */
-		/*      0x000f     (R)   number of entries - 1  */
-
-/* DACSR */
-
-#define DT2821_DAERR	0x8000	/* (R)   D/A error                */
-#define DT2821_YSEL	0x0200	/* (R/W) DAC 1 select             */
-#define DT2821_SSEL	0x0100	/* (R/W) single channel select    */
-#define DT2821_DACRDY	0x0080	/* (R)   DAC ready                */
-#define DT2821_IDARDY	0x0040	/* (R/W) interrupt on DAC ready   */
-#define DT2821_DACLK	0x0020	/* (R/W) D/A clock enable */
-#define DT2821_HBOE	0x0002	/* (R/W) DIO high byte output enable      */
-#define DT2821_LBOE	0x0001	/* (R/W) DIO low byte output enable       */
-
-/* SUPCSR */
-
-#define DT2821_DMAD	0x8000	/* (R)   DMA done                 */
-#define DT2821_ERRINTEN	0x4000	/* (R/W) interrupt on error               */
-#define DT2821_CLRDMADNE 0x2000	/* (W)   clear DMA done                   */
-#define DT2821_DDMA	0x1000	/* (R/W) dual DMA                 */
-#define DT2821_DS1	0x0800	/* (R/W) DMA select 1                     */
-#define DT2821_DS0	0x0400	/* (R/W) DMA select 0                     */
-#define DT2821_BUFFB	0x0200	/* (R/W) buffer B selected                */
-#define DT2821_SCDN	0x0100	/* (R)   scan done                        */
-#define DT2821_DACON	0x0080	/* (W)   DAC single conversion            */
-#define DT2821_ADCINIT	0x0040	/* (W)   A/D initialize                   */
-#define DT2821_DACINIT	0x0020	/* (W)   D/A initialize                   */
-#define DT2821_PRLD	0x0010	/* (W)   preload multiplexer              */
-#define DT2821_STRIG	0x0008	/* (W)   software trigger         */
-#define DT2821_XTRIG	0x0004	/* (R/W) external trigger enable  */
-#define DT2821_XCLK	0x0002	/* (R/W) external clock enable            */
-#define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
+#define DT2821_ADCSR_REG		0x00
+#define DT2821_ADCSR_ADERR		(1 << 15)
+#define DT2821_ADCSR_ADCLK		(1 << 9)
+#define DT2821_ADCSR_MUXBUSY		(1 << 8)
+#define DT2821_ADCSR_ADDONE		(1 << 7)
+#define DT2821_ADCSR_IADDONE		(1 << 6)
+#define DT2821_ADCSR_GS(x)		(((x) & 0x3) << 4)
+#define DT2821_ADCSR_CHAN(x)		(((x) & 0xf) << 0)
+#define DT2821_CHANCSR_REG		0x02
+#define DT2821_CHANCSR_LLE		(1 << 15)
+#define DT2821_CHANCSR_PRESLA(x)	(((x) & 0xf) >> 8)
+#define DT2821_CHANCSR_NUMB(x)		((((x) - 1) & 0xf) << 0)
+#define DT2821_ADDAT_REG		0x04
+#define DT2821_DACSR_REG		0x06
+#define DT2821_DACSR_DAERR		(1 << 15)
+#define DT2821_DACSR_YSEL(x)		((x) << 9)
+#define DT2821_DACSR_SSEL		(1 << 8)
+#define DT2821_DACSR_DACRDY		(1 << 7)
+#define DT2821_DACSR_IDARDY		(1 << 6)
+#define DT2821_DACSR_DACLK		(1 << 5)
+#define DT2821_DACSR_HBOE		(1 << 1)
+#define DT2821_DACSR_LBOE		(1 << 0)
+#define DT2821_DADAT_REG		0x08
+#define DT2821_DIODAT_REG		0x0a
+#define DT2821_SUPCSR_REG		0x0c
+#define DT2821_SUPCSR_DMAD		(1 << 15)
+#define DT2821_SUPCSR_ERRINTEN		(1 << 14)
+#define DT2821_SUPCSR_CLRDMADNE		(1 << 13)
+#define DT2821_SUPCSR_DDMA		(1 << 12)
+#define DT2821_SUPCSR_DS_PIO		(0 << 10)
+#define DT2821_SUPCSR_DS_AD_CLK		(1 << 10)
+#define DT2821_SUPCSR_DS_DA_CLK		(2 << 10)
+#define DT2821_SUPCSR_DS_AD_TRIG	(3 << 10)
+#define DT2821_SUPCSR_BUFFB		(1 << 9)
+#define DT2821_SUPCSR_SCDN		(1 << 8)
+#define DT2821_SUPCSR_DACON		(1 << 7)
+#define DT2821_SUPCSR_ADCINIT		(1 << 6)
+#define DT2821_SUPCSR_DACINIT		(1 << 5)
+#define DT2821_SUPCSR_PRLD		(1 << 4)
+#define DT2821_SUPCSR_STRIG		(1 << 3)
+#define DT2821_SUPCSR_XTRIG		(1 << 2)
+#define DT2821_SUPCSR_XCLK		(1 << 1)
+#define DT2821_SUPCSR_BDINIT		(1 << 0)
+#define DT2821_TMRCTR_REG		0x0e
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = {
 	4, {
@@ -476,7 +458,8 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 	void *ptr = devpriv->dma[cur_dma].buf;
 	int size;
 
-	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
+	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	disable_dma(devpriv->dma[cur_dma].chan);
 
@@ -500,7 +483,8 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	int size = devpriv->dma[cur_dma].size;
 	int ret;
 
-	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
+	outw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	disable_dma(devpriv->dma[cur_dma].chan);
 
@@ -526,8 +510,8 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
 	/* clear the dual dma flag, making this the last dma segment */
 	/* XXX probably wrong */
 	if (!devpriv->ntrig) {
-		devpriv->supcsr &= ~(DT2821_DDMA);
-		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
+		devpriv->supcsr &= ~DT2821_SUPCSR_DDMA;
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);
 	}
 #endif
 	/* restart the channel */
@@ -548,34 +532,34 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	adcsr = inw(dev->iobase + DT2821_ADCSR);
-	dacsr = inw(dev->iobase + DT2821_DACSR);
-	supcsr = inw(dev->iobase + DT2821_SUPCSR);
-	if (supcsr & DT2821_DMAD) {
+	adcsr = inw(dev->iobase + DT2821_ADCSR_REG);
+	dacsr = inw(dev->iobase + DT2821_DACSR_REG);
+	supcsr = inw(dev->iobase + DT2821_SUPCSR_REG);
+	if (supcsr & DT2821_SUPCSR_DMAD) {
 		if (devpriv->dma_dir == DMA_MODE_READ)
 			dt282x_ai_dma_interrupt(dev, s);
 		else
 			dt282x_ao_dma_interrupt(dev, s_ao);
 		handled = 1;
 	}
-	if (adcsr & DT2821_ADERR) {
+	if (adcsr & DT2821_ADCSR_ADERR) {
 		if (devpriv->nread != 0) {
 			comedi_error(dev, "A/D error");
 			s->async->events |= COMEDI_CB_ERROR;
 		}
 		handled = 1;
 	}
-	if (dacsr & DT2821_DAERR) {
+	if (dacsr & DT2821_DACSR_DAERR) {
 		comedi_error(dev, "D/A error");
 		s_ao->async->events |= COMEDI_CB_ERROR;
 		handled = 1;
 	}
 #if 0
-	if (adcsr & DT2821_ADDONE) {
+	if (adcsr & DT2821_ADCSR_ADDONE) {
 		int ret;
 		unsigned short data;
 
-		data = inw(dev->iobase + DT2821_ADDAT);
+		data = inw(dev->iobase + DT2821_ADDAT_REG);
 		data &= s->maxdata;
 		if (devpriv->ad_2scomp)
 			data = comedi_offset_munge(s, data);
@@ -589,9 +573,9 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		if (!devpriv->nread) {
 			s->async->events |= COMEDI_CB_EOA;
 		} else {
-			if (supcsr & DT2821_SCDN)
-				outw(devpriv->supcsr | DT2821_STRIG,
-					dev->iobase + DT2821_SUPCSR);
+			if (supcsr & DT2821_SUPCSR_SCDN)
+				outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
+				     dev->iobase + DT2821_SUPCSR_REG);
 		}
 		handled = 1;
 	}
@@ -606,17 +590,20 @@ static void dt282x_load_changain(struct comedi_device *dev, int n,
 				 unsigned int *chanlist)
 {
 	struct dt282x_private *devpriv = dev->private;
-	unsigned int i;
-	unsigned int chan, range;
+	int i;
 
-	outw(DT2821_LLE | (n - 1), dev->iobase + DT2821_CHANCSR);
+	outw(DT2821_CHANCSR_LLE | DT2821_CHANCSR_NUMB(n),
+	     dev->iobase + DT2821_CHANCSR_REG);
 	for (i = 0; i < n; i++) {
-		chan = CR_CHAN(chanlist[i]);
-		range = CR_RANGE(chanlist[i]);
-		outw(devpriv->adcsr | (range << 4) | chan,
-			dev->iobase + DT2821_ADCSR);
+		unsigned int chan = CR_CHAN(chanlist[i]);
+		unsigned int range = CR_RANGE(chanlist[i]);
+
+		outw(devpriv->adcsr |
+		     DT2821_ADCSR_GS(range) |
+		     DT2821_ADCSR_CHAN(chan),
+		     dev->iobase + DT2821_ADCSR_REG);
 	}
-	outw(n - 1, dev->iobase + DT2821_CHANCSR);
+	outw(DT2821_CHANCSR_NUMB(n), dev->iobase + DT2821_CHANCSR_REG);
 }
 
 static int dt282x_ai_timeout(struct comedi_device *dev,
@@ -626,14 +613,14 @@ static int dt282x_ai_timeout(struct comedi_device *dev,
 {
 	unsigned int status;
 
-	status = inw(dev->iobase + DT2821_ADCSR);
+	status = inw(dev->iobase + DT2821_ADCSR_REG);
 	switch (context) {
-	case DT2821_MUXBUSY:
-		if ((status & DT2821_MUXBUSY) == 0)
+	case DT2821_ADCSR_MUXBUSY:
+		if ((status & DT2821_ADCSR_MUXBUSY) == 0)
 			return 0;
 		break;
-	case DT2821_ADDONE:
-		if (status & DT2821_ADDONE)
+	case DT2821_ADCSR_ADDONE:
+		if (status & DT2821_ADCSR_ADDONE)
 			return 0;
 		break;
 	default:
@@ -659,26 +646,28 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 	int i;
 
 	/* XXX should we really be enabling the ad clock here? */
-	devpriv->adcsr = DT2821_ADCLK;
-	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
+	devpriv->adcsr = DT2821_ADCSR_ADCLK;
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);
 
 	dt282x_load_changain(dev, 1, &insn->chanspec);
 
-	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
-	ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout, DT2821_MUXBUSY);
+	outw(devpriv->supcsr | DT2821_SUPCSR_PRLD,
+	     dev->iobase + DT2821_SUPCSR_REG);
+	ret = comedi_timeout(dev, s, insn,
+			     dt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);
 	if (ret)
 		return ret;
 
 	for (i = 0; i < insn->n; i++) {
-		outw(devpriv->supcsr | DT2821_STRIG,
-			dev->iobase + DT2821_SUPCSR);
+		outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
+		     dev->iobase + DT2821_SUPCSR_REG);
 
-		ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout,
-				     DT2821_ADDONE);
+		ret = comedi_timeout(dev, s, insn,
+				     dt282x_ai_timeout, DT2821_ADCSR_ADDONE);
 		if (ret)
 			return ret;
 
-		val = inw(dev->iobase + DT2821_ADDAT);
+		val = inw(dev->iobase + DT2821_ADDAT_REG);
 		val &= s->maxdata;
 		if (devpriv->ad_2scomp)
 			val = comedi_offset_munge(s, val);
@@ -769,17 +758,18 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	dt282x_disable_dma(dev);
 
-	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR);
+	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);
 
-	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		/* internal trigger */
-		devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0;
-	} else {
-		/* external trigger */
-		devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0 | DT2821_DS1;
-	}
-	outw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_ADCINIT,
-		dev->iobase + DT2821_SUPCSR);
+	devpriv->supcsr = DT2821_SUPCSR_ERRINTEN;
+	if (cmd->scan_begin_src == TRIG_FOLLOW)
+		devpriv->supcsr = DT2821_SUPCSR_DS_AD_CLK;
+	else
+		devpriv->supcsr = DT2821_SUPCSR_DS_AD_TRIG;
+	outw(devpriv->supcsr |
+	     DT2821_SUPCSR_CLRDMADNE |
+	     DT2821_SUPCSR_BUFFB |
+	     DT2821_SUPCSR_ADCINIT,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	devpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;
 	devpriv->nread = devpriv->ntrig;
@@ -789,28 +779,30 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dt282x_prep_ai_dma(dev, 0, 0);
 	if (devpriv->ntrig) {
 		dt282x_prep_ai_dma(dev, 1, 0);
-		devpriv->supcsr |= DT2821_DDMA;
-		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
+		devpriv->supcsr |= DT2821_SUPCSR_DDMA;
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);
 	}
 
 	devpriv->adcsr = 0;
 
 	dt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);
 
-	devpriv->adcsr = DT2821_ADCLK | DT2821_IADDONE;
-	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
+	devpriv->adcsr = DT2821_ADCSR_ADCLK | DT2821_ADCSR_IADDONE;
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);
 
-	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
-	ret = comedi_timeout(dev, s, NULL, dt282x_ai_timeout, DT2821_MUXBUSY);
+	outw(devpriv->supcsr | DT2821_SUPCSR_PRLD,
+	     dev->iobase + DT2821_SUPCSR_REG);
+	ret = comedi_timeout(dev, s, NULL,
+			     dt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);
 	if (ret)
 		return ret;
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		outw(devpriv->supcsr | DT2821_STRIG,
-			dev->iobase + DT2821_SUPCSR);
+		outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
+			dev->iobase + DT2821_SUPCSR_REG);
 	} else {
-		devpriv->supcsr |= DT2821_XTRIG;
-		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
+		devpriv->supcsr |= DT2821_SUPCSR_XTRIG;
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);
 	}
 
 	return 0;
@@ -824,10 +816,11 @@ static int dt282x_ai_cancel(struct comedi_device *dev,
 	dt282x_disable_dma(dev);
 
 	devpriv->adcsr = 0;
-	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);
 
 	devpriv->supcsr = 0;
-	outw(devpriv->supcsr | DT2821_ADCINIT, dev->iobase + DT2821_SUPCSR);
+	outw(devpriv->supcsr | DT2821_SUPCSR_ADCINIT,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	return 0;
 }
@@ -858,13 +851,11 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 	unsigned int val;
 	int i;
 
-	devpriv->dacsr |= DT2821_SSEL;
+	devpriv->dacsr |= DT2821_DACSR_SSEL | DT2821_DACSR_YSEL(chan);
 	if (chan) {
-		devpriv->dacsr |= DT2821_YSEL;
 		if (devpriv->da1_2scomp)
 			munge = true;
 	} else {
-		devpriv->dacsr &= ~DT2821_YSEL;
 		if (devpriv->da0_2scomp)
 			munge = true;
 	}
@@ -876,12 +867,12 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 		if (munge)
 			val = comedi_offset_munge(s, val);
 
-		outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+		outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
-		outw(val, dev->iobase + DT2821_DADAT);
+		outw(val, dev->iobase + DT2821_DADAT_REG);
 
-		outw(devpriv->supcsr | DT2821_DACON,
-		     dev->iobase + DT2821_SUPCSR);
+		outw(devpriv->supcsr | DT2821_SUPCSR_DACON,
+		     dev->iobase + DT2821_SUPCSR_REG);
 	}
 
 	return insn->n;
@@ -971,7 +962,8 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	}
 	dt282x_prep_ao_dma(dev, 1, size);
 
-	outw(devpriv->supcsr | DT2821_STRIG, dev->iobase + DT2821_SUPCSR);
+	outw(devpriv->supcsr | DT2821_SUPCSR_STRIG,
+	     dev->iobase + DT2821_SUPCSR_REG);
 	s->async->inttrig = NULL;
 
 	return 1;
@@ -984,9 +976,14 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	dt282x_disable_dma(dev);
 
-	devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS1 | DT2821_DDMA;
-	outw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_DACINIT,
-		dev->iobase + DT2821_SUPCSR);
+	devpriv->supcsr = DT2821_SUPCSR_ERRINTEN |
+			  DT2821_SUPCSR_DS_DA_CLK |
+			  DT2821_SUPCSR_DDMA;
+	outw(devpriv->supcsr |
+	     DT2821_SUPCSR_CLRDMADNE |
+	     DT2821_SUPCSR_BUFFB |
+	     DT2821_SUPCSR_DACINIT,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	devpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;
 	devpriv->nread = devpriv->ntrig;
@@ -994,10 +991,12 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->dma_dir = DMA_MODE_WRITE;
 	devpriv->current_dma_index = 0;
 
-	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR);
+	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);
 
-	devpriv->dacsr = DT2821_SSEL | DT2821_DACLK | DT2821_IDARDY;
-	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+	devpriv->dacsr = DT2821_DACSR_SSEL |
+			 DT2821_DACSR_DACLK |
+			 DT2821_DACSR_IDARDY;
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
 	s->async->inttrig = dt282x_ao_inttrig;
 
@@ -1012,10 +1011,11 @@ static int dt282x_ao_cancel(struct comedi_device *dev,
 	dt282x_disable_dma(dev);
 
 	devpriv->dacsr = 0;
-	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
 	devpriv->supcsr = 0;
-	outw(devpriv->supcsr | DT2821_DACINIT, dev->iobase + DT2821_SUPCSR);
+	outw(devpriv->supcsr | DT2821_SUPCSR_DACINIT,
+	     dev->iobase + DT2821_SUPCSR_REG);
 
 	return 0;
 }
@@ -1026,9 +1026,9 @@ static int dt282x_dio_insn_bits(struct comedi_device *dev,
 				unsigned int *data)
 {
 	if (comedi_dio_update_state(s, data))
-		outw(s->state, dev->iobase + DT2821_DIODAT);
+		outw(s->state, dev->iobase + DT2821_DIODAT_REG);
 
-	data[1] = inw(dev->iobase + DT2821_DIODAT);
+	data[1] = inw(dev->iobase + DT2821_DIODAT_REG);
 
 	return insn->n;
 }
@@ -1052,13 +1052,13 @@ static int dt282x_dio_insn_config(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->dacsr &= ~(DT2821_LBOE | DT2821_HBOE);
+	devpriv->dacsr &= ~(DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);
 	if (s->io_bits & 0x00ff)
-		devpriv->dacsr |= DT2821_LBOE;
+		devpriv->dacsr |= DT2821_DACSR_LBOE;
 	if (s->io_bits & 0xff00)
-		devpriv->dacsr |= DT2821_HBOE;
+		devpriv->dacsr |= DT2821_DACSR_HBOE;
 
-	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);
 
 	return insn->n;
 }
@@ -1133,18 +1133,18 @@ static void dt282x_free_dma(struct comedi_device *dev)
 static int dt282x_initialize(struct comedi_device *dev)
 {
 	/* Initialize board */
-	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
-	inw(dev->iobase + DT2821_ADCSR);
+	outw(DT2821_SUPCSR_BDINIT, dev->iobase + DT2821_SUPCSR_REG);
+	inw(dev->iobase + DT2821_ADCSR_REG);
 
 	/*
 	 * At power up, some registers are in a well-known state.
 	 * Check them to see if a DT2821 series board is present.
 	 */
-	if (((inw(dev->iobase + DT2821_ADCSR) & 0xfff0) != 0x7c00) ||
-	    ((inw(dev->iobase + DT2821_CHANCSR) & 0xf0f0) != 0x70f0) ||
-	    ((inw(dev->iobase + DT2821_DACSR) & 0x7c93) != 0x7c90) ||
-	    ((inw(dev->iobase + DT2821_SUPCSR) & 0xf8ff) != 0x0000) ||
-	    ((inw(dev->iobase + DT2821_TMRCTR) & 0xff00) != 0xf000)) {
+	if (((inw(dev->iobase + DT2821_ADCSR_REG) & 0xfff0) != 0x7c00) ||
+	    ((inw(dev->iobase + DT2821_CHANCSR_REG) & 0xf0f0) != 0x70f0) ||
+	    ((inw(dev->iobase + DT2821_DACSR_REG) & 0x7c93) != 0x7c90) ||
+	    ((inw(dev->iobase + DT2821_SUPCSR_REG) & 0xf8ff) != 0x0000) ||
+	    ((inw(dev->iobase + DT2821_TMRCTR_REG) & 0xff00) != 0xf000)) {
 		dev_err(dev->class_dev, "board not found\n");
 		return -EIO;
 	}

commit 3ec2e20274f5721949c27eac403e876f397db50e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:59 2014 -0700

    staging: comedi: dt282x: avoid calculating the timer divisor multiple times
    
    A common timer is used for analog input and output async commands. The
    (*do_cmdtest) for both subdevices calculates the divisor as part of
    Step 4 when validating the trigger arguments. The divisor is calculated
    again in the (*do_cmd) for both subdevices in order to set the timer.
    
    The comedi core only calls the (*do_cmd) is called after a successful
    (*do_cmdtest). Save the divisor from the (*do_cmdtest) in the private
    data and use that value in the (*do_cmd).
    
    The extra check of the cmd->convert_arg in dt282x_ai_cmd() is not necessary.
    The convert_arg was already checked in the (*do_cmdtest), and it's not used
    in the (*do_cmd).
    
    Tidy up dt282x_ns_to_timer(), the parameters are all unsigned int's and the
    mask of the 'flags' can be moved here to simplify the callers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 28ee5a3c3f14..9d8b603cdf68 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -331,6 +331,8 @@ struct dt282x_private {
 	unsigned int da0_2scomp:1;
 	unsigned int da1_2scomp:1;
 
+	unsigned int divisor;
+
 	unsigned short ao_readback[2];
 
 	int dacsr;	/* software copies of registers */
@@ -413,34 +415,34 @@ static void dt282x_disable_dma(struct comedi_device *dev)
 	disable_dma(devpriv->dma[1].chan);
 }
 
-static int dt282x_ns_to_timer(int *nanosec, int round_mode)
+static unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)
 {
-	int prescale, base, divider;
+	unsigned int prescale, base, divider;
 
 	for (prescale = 0; prescale < 16; prescale++) {
 		if (prescale == 1)
 			continue;
 		base = 250 * (1 << prescale);
-		switch (round_mode) {
+		switch (flags & TRIG_ROUND_MASK) {
 		case TRIG_ROUND_NEAREST:
 		default:
-			divider = (*nanosec + base / 2) / base;
+			divider = (*ns + base / 2) / base;
 			break;
 		case TRIG_ROUND_DOWN:
-			divider = (*nanosec) / base;
+			divider = (*ns) / base;
 			break;
 		case TRIG_ROUND_UP:
-			divider = (*nanosec + base - 1) / base;
+			divider = (*ns + base - 1) / base;
 			break;
 		}
 		if (divider < 256) {
-			*nanosec = divider * base;
+			*ns = divider * base;
 			return (prescale << 8) | (255 - divider);
 		}
 	}
 	base = 250 * (1 << 15);
 	divider = 255;
-	*nanosec = divider * base;
+	*ns = divider * base;
 	return (15 << 8) | (255 - divider);
 }
 
@@ -688,9 +690,11 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 }
 
 static int dt282x_ai_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd)
 {
 	const struct dt282x_board *board = comedi_board(dev);
+	struct dt282x_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -748,7 +752,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	arg = cmd->convert_arg;
-	dt282x_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+	devpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 	if (err)
@@ -759,18 +763,13 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
-	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	int timer;
 	int ret;
 
 	dt282x_disable_dma(dev);
 
-	if (cmd->convert_arg < board->ai_speed)
-		cmd->convert_arg = board->ai_speed;
-	timer = dt282x_ns_to_timer(&cmd->convert_arg, TRIG_ROUND_NEAREST);
-	outw(timer, dev->iobase + DT2821_TMRCTR);
+	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		/* internal trigger */
@@ -889,8 +888,10 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 }
 
 static int dt282x_ao_cmdtest(struct comedi_device *dev,
-			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
+			     struct comedi_subdevice *s,
+			     struct comedi_cmd *cmd)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -933,7 +934,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	arg = cmd->scan_begin_arg;
-	dt282x_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+	devpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);
 	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 
 	if (err)
@@ -979,7 +980,6 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int timer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
 	dt282x_disable_dma(dev);
@@ -994,8 +994,7 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	devpriv->dma_dir = DMA_MODE_WRITE;
 	devpriv->current_dma_index = 0;
 
-	timer = dt282x_ns_to_timer(&cmd->scan_begin_arg, TRIG_ROUND_NEAREST);
-	outw(timer, dev->iobase + DT2821_TMRCTR);
+	outw(devpriv->divisor, dev->iobase + DT2821_TMRCTR);
 
 	devpriv->dacsr = DT2821_SSEL | DT2821_DACLK | DT2821_IDARDY;
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);

commit 7152f7d4b130a4b99c9a2dd1fc705a3b8ca8dcd5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:58 2014 -0700

    staging: comedi: dt282x: update the MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something more useful than the
    generic "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 15becb536589..28ee5a3c3f14 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1305,5 +1305,5 @@ static struct comedi_driver dt282x_driver = {
 module_comedi_driver(dt282x_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for Data Translation DT2821 series");
 MODULE_LICENSE("GPL");

commit 9c64ef47a7134d3da686b63f79761e05ac504950
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:57 2014 -0700

    staging: comedi: dt282x: tidy up multi-line comments
    
    Tidy up the multi-line comments at the beginning of the file to follow
    the CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6c799f0a5ffc..15becb536589 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1,57 +1,67 @@
 /*
-   comedi/drivers/dt282x.c
-   Hardware driver for Data Translation DT2821 series
-
-   COMEDI - Linux Control and Measurement Device Interface
-   Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+ * dt282x.c
+ * Comedi driver for Data Translation DT2821 series
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
+
 /*
-Driver: dt282x
-Description: Data Translation DT2821 series (including DT-EZ)
-Author: ds
-Devices: [Data Translation] DT2821 (dt2821),
-  DT2821-F-16SE (dt2821-f), DT2821-F-8DI (dt2821-f),
-  DT2821-G-16SE (dt2821-f), DT2821-G-8DI (dt2821-g),
-  DT2823 (dt2823),
-  DT2824-PGH (dt2824-pgh), DT2824-PGL (dt2824-pgl), DT2825 (dt2825),
-  DT2827 (dt2827), DT2828 (dt2828), DT21-EZ (dt21-ez), DT23-EZ (dt23-ez),
-  DT24-EZ (dt24-ez), DT24-EZ-PGL (dt24-ez-pgl)
-Status: complete
-Updated: Wed, 22 Aug 2001 17:11:34 -0700
-
-Configuration options:
-  [0] - I/O port base address
-  [1] - IRQ
-  [2] - DMA 1
-  [3] - DMA 2
-  [4] - AI jumpered for 0=single ended, 1=differential
-  [5] - AI jumpered for 0=straight binary, 1=2's complement
-  [6] - AO 0 jumpered for 0=straight binary, 1=2's complement
-  [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
-  [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
-  [9] - AO channel 0 range (deprecated, see below)
-  [10]- AO channel 1 range (deprecated, see below)
-
-Notes:
-  - AO commands might be broken.
-  - If you try to run a command on both the AI and AO subdevices
-    simultaneously, bad things will happen.  The driver needs to
-    be fixed to check for this situation and return an error.
-  - AO range is not programmable. The AO subdevice has a range_table
-    containing all the possible analog output ranges. Use the range
-    that matches your board configuration to convert between data
-    values and physical units.
-*/
+ * Driver: dt282x
+ * Description: Data Translation DT2821 series (including DT-EZ)
+ * Author: ds
+ * Devices: (Data Translation) DT2821 [dt2821]
+ *	    (Data Translation) DT2821-F-16SE [dt2821-f]
+ *	    (Data Translation) DT2821-F-8DI [dt2821-f]
+ *	    (Data Translation) DT2821-G-16SE [dt2821-g]
+ *	    (Data Translation) DT2821-G-8DI [dt2821-g]
+ *	    (Data Translation) DT2823 [dt2823]
+ *	    (Data Translation) DT2824-PGH [dt2824-pgh]
+ *	    (Data Translation) DT2824-PGL [dt2824-pgl]
+ *	    (Data Translation) DT2825 [dt2825]
+ *	    (Data Translation) DT2827 [dt2827]
+ *	    (Data Translation) DT2828 [dt2828]
+ *	    (Data Translation) DT2928 [dt2829]
+ *	    (Data Translation) DT21-EZ [dt21-ez]
+ *	    (Data Translation) DT23-EZ [dt23-ez]
+ *	    (Data Translation) DT24-EZ [dt24-ez]
+ *	    (Data Translation) DT24-EZ-PGL [dt24-ez-pgl]
+ * Status: complete
+ * Updated: Wed, 22 Aug 2001 17:11:34 -0700
+ *
+ * Configuration options:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional, required for async command support)
+ *   [2] - DMA 1 (optional, required for async command support)
+ *   [3] - DMA 2 (optional, required for async command support)
+ *   [4] - AI jumpered for 0=single ended, 1=differential
+ *   [5] - AI jumpered for 0=straight binary, 1=2's complement
+ *   [6] - AO 0 jumpered for 0=straight binary, 1=2's complement
+ *   [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
+ *   [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
+ *   [9] - AO channel 0 range (deprecated, see below)
+ *   [10]- AO channel 1 range (deprecated, see below)
+ *
+ * Notes:
+ *   - AO commands might be broken.
+ *   - If you try to run a command on both the AI and AO subdevices
+ *     simultaneously, bad things will happen.  The driver needs to
+ *     be fixed to check for this situation and return an error.
+ *   - AO range is not programmable. The AO subdevice has a range_table
+ *     containing all the possible analog output ranges. Use the range
+ *     that matches your board configuration to convert between data
+ *     values and physical units.
+ */
 
 #include <linux/module.h>
 #include "../comedidev.h"

commit fc00fbc990871a17e0e0f31acc0876f83165cf53
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:56 2014 -0700

    staging: comedi: dt282x: cleanup analog output range table
    
    The DT2821 series boards do not have programmable analog output ranges.
    The range is set, per-channel, with jumpers on the board.
    
    Currently the user has to pass some configuration options when attaching
    to the driver in order to set the range for each channel. If they do not
    pass the range options they will default to 0. If they pass an invalid
    range option they will also default to 0. The 0 range option is bipolar
    10V. If the user passes a range option that does not match the hardware
    setting it doesn't cause any problems in the driver it just causes the
    user space comedilib library to incorrectly convert the hardware values
    to physical values.
    
    Make the attach a bit simpler by deprecating these options and providing
    a range table with all the valid ranges for the analog outputs. The user
    can then select the correct range when they use the comedilib functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 66f15aa55b7e..6c799f0a5ffc 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -39,16 +39,18 @@ Configuration options:
   [6] - AO 0 jumpered for 0=straight binary, 1=2's complement
   [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
   [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
-  [9] - AO 0 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
-	4=[-2.5,2.5]
-  [10]- A0 1 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
-	4=[-2.5,2.5]
+  [9] - AO channel 0 range (deprecated, see below)
+  [10]- AO channel 1 range (deprecated, see below)
 
 Notes:
   - AO commands might be broken.
   - If you try to run a command on both the AI and AO subdevices
     simultaneously, bad things will happen.  The driver needs to
     be fixed to check for this situation and return an error.
+  - AO range is not programmable. The AO subdevice has a range_table
+    containing all the possible analog output ranges. Use the range
+    that matches your board configuration to convert between data
+    values and physical units.
 */
 
 #include <linux/module.h>
@@ -183,6 +185,21 @@ static const struct comedi_lrange range_dt282x_ai_hi_unipolar = {
 	}
 };
 
+/*
+ * The Analog Output range is set per-channel using jumpers on the board.
+ * All of these ranges may not be available on some DT2821 series boards.
+ * The default jumper setting has both channels set for +/-10V output.
+ */
+static const struct comedi_lrange dt282x_ao_range = {
+	5, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+	}
+};
+
 struct dt282x_board {
 	const char *name;
 	unsigned int ai_maxdata;
@@ -304,8 +321,6 @@ struct dt282x_private {
 	unsigned int da0_2scomp:1;
 	unsigned int da1_2scomp:1;
 
-	const struct comedi_lrange *darangelist[2];
-
 	unsigned short ao_readback[2];
 
 	int dacsr;	/* software copies of registers */
@@ -1064,21 +1079,6 @@ static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 	}
 }
 
-static const struct comedi_lrange *const ao_range_table[] = {
-	&range_bipolar10,
-	&range_unipolar10,
-	&range_bipolar5,
-	&range_unipolar5,
-	&range_bipolar2_5
-};
-
-static const struct comedi_lrange *opt_ao_range_lkup(int x)
-{
-	if (x < 0 || x >= 5)
-		x = 0;
-	return ao_range_table[x];
-}
-
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 {
 	struct dt282x_private *devpriv = dev->private;
@@ -1246,9 +1246,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->maxdata	= board->ao_maxdata;
 
 		/* ranges are per-channel, set by jumpers on the board */
-		s->range_table_list = devpriv->darangelist;
-		devpriv->darangelist[0] = opt_ao_range_lkup(it->options[9]);
-		devpriv->darangelist[1] = opt_ao_range_lkup(it->options[10]);
+		s->range_table	= &dt282x_ao_range;
 		devpriv->da0_2scomp = it->options[6] ? 1 : 0;
 		devpriv->da1_2scomp = it->options[7] ? 1 : 0;
 

commit d5aa6b7c31d8f9667e743a8bb2a6677caf78cd31
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:55 2014 -0700

    staging: comedi: dt282x: fix Analog Input se/diff channel configuration
    
    Most of the boards supported by this driver can do either single-ended or
    differential Analog Input but there are a couple that can only do one or
    the other. On the boards that can do both the type of input is set with
    jumpers on the board.
    
    The 'it->options[4]' passed by the user during the board (*attach) is used
    to determine how the Analog Inputs are configured. This is used to set
    the subdevice flags and number of channels correctly.
    
    Fix the check of this option so that it only applies when the board can
    actually do differential input. Also, default to differential inputs if
    that is the only mode the board supports.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9c512dac6567..66f15aa55b7e 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1215,7 +1215,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s = &dev->subdevices[0];
 	s->type		= COMEDI_SUBD_AI;
 	s->subdev_flags	= SDF_READABLE;
-	if (it->options[4]) {
+	if ((it->options[4] && board->adchan_di) || board->adchan_se == 0) {
 		s->subdev_flags	|= SDF_DIFF;
 		s->n_chan	= board->adchan_di;
 	} else {

commit 810c8a88b660b1a06bd9b8b7b0fa00c990c4e734
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:54 2014 -0700

    staging: comedi: dt282x: tidy up Analog Input subdevice init
    
    For aesthetics, add some whitespace to the Analog Input subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index c26ae86b3e2a..9c512dac6567 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1211,11 +1211,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-
-	/* ai subdevice */
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE;
 	if (it->options[4]) {
 		s->subdev_flags	|= SDF_DIFF;
 		s->n_chan	= board->adchan_di;
@@ -1223,17 +1222,19 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags	|= SDF_COMMON;
 		s->n_chan	= board->adchan_se;
 	}
-	s->insn_read = dt282x_ai_insn_read;
-	s->maxdata = board->ai_maxdata;
+	s->maxdata	= board->ai_maxdata;
+
 	s->range_table = opt_ai_range_lkup(board->ispgl, it->options[8]);
 	devpriv->ad_2scomp = it->options[5] ? 1 : 0;
+
+	s->insn_read	= dt282x_ai_insn_read;
 	if (dev->irq) {
 		dev->read_subdev = s;
-		s->subdev_flags |= SDF_CMD_READ;
-		s->len_chanlist = 16;
-		s->do_cmdtest = dt282x_ai_cmdtest;
-		s->do_cmd = dt282x_ai_cmd;
-		s->cancel = dt282x_ai_cancel;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->do_cmdtest	= dt282x_ai_cmdtest;
+		s->do_cmd	= dt282x_ai_cmd;
+		s->cancel	= dt282x_ai_cancel;
 	}
 
 	/* Analog Output subdevice */

commit 9803bc096910ce4f012699d4dae07d91346c6d66
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:53 2014 -0700

    staging: comedi: dt282x: tidy up Analog Output subdevice init
    
    For aesthetics, add some whitespace to the Analog Output subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 326924fcf90b..c26ae86b3e2a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1236,31 +1236,33 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->cancel = dt282x_ai_cancel;
 	}
 
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
+	if (board->dachan) {
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE;
+		s->n_chan	= board->dachan;
+		s->maxdata	= board->ao_maxdata;
 
-	s->n_chan = board->dachan;
-	if (s->n_chan) {
-		/* ao subsystem */
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_WRITABLE;
-		s->insn_read = dt282x_ao_insn_read;
-		s->insn_write = dt282x_ao_insn_write;
-		s->maxdata = board->ao_maxdata;
+		/* ranges are per-channel, set by jumpers on the board */
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] = opt_ao_range_lkup(it->options[9]);
 		devpriv->darangelist[1] = opt_ao_range_lkup(it->options[10]);
 		devpriv->da0_2scomp = it->options[6] ? 1 : 0;
 		devpriv->da1_2scomp = it->options[7] ? 1 : 0;
+
+		s->insn_read	= dt282x_ao_insn_read;
+		s->insn_write	= dt282x_ao_insn_write;
 		if (dev->irq) {
 			dev->write_subdev = s;
-			s->subdev_flags |= SDF_CMD_WRITE;
-			s->len_chanlist = 2;
-			s->do_cmdtest = dt282x_ao_cmdtest;
-			s->do_cmd = dt282x_ao_cmd;
-			s->cancel = dt282x_ao_cancel;
+			s->subdev_flags	|= SDF_CMD_WRITE;
+			s->len_chanlist	= s->n_chan;
+			s->do_cmdtest	= dt282x_ao_cmdtest;
+			s->do_cmd	= dt282x_ao_cmd;
+			s->cancel	= dt282x_ao_cancel;
 		}
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* Digital I/O subdevice */

commit f8b987b4d35c37cf973c30871fc42b16c6272041
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:52 2014 -0700

    staging: comedi: dt282x: remove the 'opt_*' enum
    
    This enum is used to index the 'options' values that are passed
    by the user attaches to the driver. These options are identified
    in the comedi comment block.
    
    For aesthetics, remove the enum and just open code the index values.
    
    Refactor the Analog Input subdevice init so that the it->options[4],
    indicating differential inputs, does not have to be checked multiple
    times.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f9679b919d18..326924fcf90b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1079,13 +1079,6 @@ static const struct comedi_lrange *opt_ao_range_lkup(int x)
 	return ao_range_table[x];
 }
 
-enum {  /* i/o base, irq, dma channels */
-	opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,
-	opt_diff,		/* differential */
-	opt_ai_twos, opt_ao0_twos, opt_ao1_twos,	/* twos comp */
-	opt_ai_range, opt_ao0_range, opt_ao1_range,	/* range */
-};
-
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 {
 	struct dt282x_private *devpriv = dev->private;
@@ -1183,11 +1176,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 
 	/* an IRQ and 2 DMA channels are required for async command support */
-	if (it->options[opt_irq] &&
-	    it->options[opt_dma1] && it->options[opt_dma2]) {
-		unsigned int irq = it->options[opt_irq];
-		unsigned int dma1 = it->options[opt_dma1];
-		unsigned int dma2 = it->options[opt_dma2];
+	if (it->options[1] && it->options[2] && it->options[3]) {
+		unsigned int irq = it->options[1];
+		unsigned int dma1 = it->options[2];
+		unsigned int dma2 = it->options[3];
 
 		if (dma2 < dma1) {
 			unsigned int swap;
@@ -1223,15 +1215,18 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* ai subdevice */
 	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE |
-	    ((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
-	s->n_chan =
-	    (it->options[opt_diff]) ? board->adchan_di : board->adchan_se;
+	s->subdev_flags = SDF_READABLE;
+	if (it->options[4]) {
+		s->subdev_flags	|= SDF_DIFF;
+		s->n_chan	= board->adchan_di;
+	} else {
+		s->subdev_flags	|= SDF_COMMON;
+		s->n_chan	= board->adchan_se;
+	}
 	s->insn_read = dt282x_ai_insn_read;
 	s->maxdata = board->ai_maxdata;
-	s->range_table =
-	    opt_ai_range_lkup(board->ispgl, it->options[opt_ai_range]);
-	devpriv->ad_2scomp = it->options[opt_ai_twos] ? 1 : 0;
+	s->range_table = opt_ai_range_lkup(board->ispgl, it->options[8]);
+	devpriv->ad_2scomp = it->options[5] ? 1 : 0;
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
@@ -1252,12 +1247,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->insn_write = dt282x_ao_insn_write;
 		s->maxdata = board->ao_maxdata;
 		s->range_table_list = devpriv->darangelist;
-		devpriv->darangelist[0] =
-		    opt_ao_range_lkup(it->options[opt_ao0_range]);
-		devpriv->darangelist[1] =
-		    opt_ao_range_lkup(it->options[opt_ao1_range]);
-		devpriv->da0_2scomp = it->options[opt_ao0_twos] ? 1 : 0;
-		devpriv->da1_2scomp = it->options[opt_ao1_twos] ? 1 : 0;
+		devpriv->darangelist[0] = opt_ao_range_lkup(it->options[9]);
+		devpriv->darangelist[1] = opt_ao_range_lkup(it->options[10]);
+		devpriv->da0_2scomp = it->options[6] ? 1 : 0;
+		devpriv->da1_2scomp = it->options[7] ? 1 : 0;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;

commit f4af8d4991bd3575d8eb54b08d78fb0e498b8ec8
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:51 2014 -0700

    staging: comedi: dt282x: factor board initialization out of (*attach)
    
    For aesthetics, factor the code that initializes the then checks to see
    if it is actually a DT2821 series board out of the (*attach).
    
    For clarity, remove the MASK and VAL defines used to check the board and
    jsut open code the values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f248dbcc3c70..f9679b919d18 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -76,26 +76,6 @@ Configuration options:
 #define DT2821_SUPCSR	0x0c	/* Supervisor Control/Status      */
 #define DT2821_TMRCTR	0x0e	/* Timer/Counter          */
 
-/*
- *  At power up, some registers are in a well-known state.  The
- *  masks and values are as follows:
- */
-
-#define DT2821_ADCSR_MASK 0xfff0
-#define DT2821_ADCSR_VAL 0x7c00
-
-#define DT2821_CHANCSR_MASK 0xf0f0
-#define DT2821_CHANCSR_VAL 0x70f0
-
-#define DT2821_DACSR_MASK 0x7c93
-#define DT2821_DACSR_VAL 0x7c90
-
-#define DT2821_SUPCSR_MASK 0xf8ff
-#define DT2821_SUPCSR_VAL 0x0000
-
-#define DT2821_TMRCTR_MASK 0xff00
-#define DT2821_TMRCTR_VAL 0xf000
-
 /*
  *    Bit fields of each register
  */
@@ -1148,6 +1128,27 @@ static void dt282x_free_dma(struct comedi_device *dev)
 	}
 }
 
+static int dt282x_initialize(struct comedi_device *dev)
+{
+	/* Initialize board */
+	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
+	inw(dev->iobase + DT2821_ADCSR);
+
+	/*
+	 * At power up, some registers are in a well-known state.
+	 * Check them to see if a DT2821 series board is present.
+	 */
+	if (((inw(dev->iobase + DT2821_ADCSR) & 0xfff0) != 0x7c00) ||
+	    ((inw(dev->iobase + DT2821_CHANCSR) & 0xf0f0) != 0x70f0) ||
+	    ((inw(dev->iobase + DT2821_DACSR) & 0x7c93) != 0x7c90) ||
+	    ((inw(dev->iobase + DT2821_SUPCSR) & 0xf8ff) != 0x0000) ||
+	    ((inw(dev->iobase + DT2821_TMRCTR) & 0xff00) != 0xf000)) {
+		dev_err(dev->class_dev, "board not found\n");
+		return -EIO;
+	}
+	return 0;
+}
+
 /*
    options:
    0	i/o base
@@ -1168,29 +1169,14 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct dt282x_private *devpriv;
 	struct comedi_subdevice *s;
 	int ret;
-	int i;
 
 	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
 
-	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
-	i = inw(dev->iobase + DT2821_ADCSR);
-
-	if (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)
-	     != DT2821_ADCSR_VAL) ||
-	    ((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
-	     != DT2821_CHANCSR_VAL) ||
-	    ((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
-	     != DT2821_DACSR_VAL) ||
-	    ((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
-	     != DT2821_SUPCSR_VAL) ||
-	    ((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
-	     != DT2821_TMRCTR_VAL)) {
-		dev_err(dev->class_dev, "board not found\n");
-		return -EIO;
-	}
-	/* should do board test */
+	ret = dt282x_initialize(dev);
+	if (ret)
+		return ret;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)

commit 9504be8a1b84d5139f7475c0e705bc0630e82dc9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:50 2014 -0700

    staging: comedi: dt282x: fix dt282x_ao_insn_read()
    
    The comedi core expects the (*insn_read) functions to return 'insn->n'
    samples. Fix this function to work like the core expects.
    
    For aesthetics, rename the private data 'ao' member to clarify its
    use. Also, remove the unnecessary comment.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index d4164ced8185..f248dbcc3c70 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -326,7 +326,7 @@ struct dt282x_private {
 
 	const struct comedi_lrange *darangelist[2];
 
-	unsigned short ao[2];
+	unsigned short ao_readback[2];
 
 	int dacsr;	/* software copies of registers */
 	int adcsr;
@@ -828,21 +828,19 @@ static int dt282x_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-/*
- *    Analog output routine.  Selects single channel conversion,
- *      selects correct channel, converts from 2's compliment to
- *      offset binary if necessary, loads the data into the DAC
- *      data register, and performs the conversion.
- */
 static int dt282x_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
 	struct dt282x_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int i;
 
-	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
+	for (i = 0; i < insn->n; i++)
+		data[i] = devpriv->ao_readback[chan];
 
-	return 1;
+	return insn->n;
 }
 
 static int dt282x_ao_insn_write(struct comedi_device *dev,
@@ -869,7 +867,7 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 
 	for (i = 0; i < insn->n; i++) {
 		val = data[i];
-		devpriv->ao[chan] = val;
+		devpriv->ao_readback[chan] = val;
 
 		if (munge)
 			val = comedi_offset_munge(s, val);

commit de91bb97254cec30f24b4f770e10eab7da3f6be1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:49 2014 -0700

    staging: comedi: dt282x: tidy up dt282x_ai_dma_interrupt()
    
    The main interrupt handler already has the comedi_subdevice pointer
    needed in this function. Pass that subdevice pointer so that it does
    not need to be fetched as a local variable.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 40c5794ec5c4..d4164ced8185 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -484,24 +484,20 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
 	}
 }
 
-static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
+static void dt282x_ai_dma_interrupt(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->read_subdev;
-	void *ptr;
-	int size;
-	int i;
+	int cur_dma = devpriv->current_dma_index;
+	void *ptr = devpriv->dma[cur_dma].buf;
+	int size = devpriv->dma[cur_dma].size;
 	int ret;
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
-	i = devpriv->current_dma_index;
-	ptr = devpriv->dma[i].buf;
-	size = devpriv->dma[i].size;
-
-	disable_dma(devpriv->dma[i].chan);
+	disable_dma(devpriv->dma[cur_dma].chan);
 
-	devpriv->current_dma_index = 1 - i;
+	devpriv->current_dma_index = 1 - cur_dma;
 
 	dt282x_munge(dev, s, ptr, size);
 	ret = cfc_write_array_to_buffer(s, ptr, size);
@@ -509,8 +505,8 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
 	}
-	devpriv->nread -= size / 2;
 
+	devpriv->nread -= size / 2;
 	if (devpriv->nread < 0) {
 		dev_info(dev->class_dev, "nread off by one\n");
 		devpriv->nread = 0;
@@ -528,7 +524,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	}
 #endif
 	/* restart the channel */
-	dt282x_prep_ai_dma(dev, i, 0);
+	dt282x_prep_ai_dma(dev, cur_dma, 0);
 }
 
 static irqreturn_t dt282x_interrupt(int irq, void *d)
@@ -550,7 +546,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	supcsr = inw(dev->iobase + DT2821_SUPCSR);
 	if (supcsr & DT2821_DMAD) {
 		if (devpriv->dma_dir == DMA_MODE_READ)
-			dt282x_ai_dma_interrupt(dev);
+			dt282x_ai_dma_interrupt(dev, s);
 		else
 			dt282x_ao_dma_interrupt(dev, s_ao);
 		handled = 1;

commit e6cff3990d53d93f5b1bf59984a4fe7816f02b63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:48 2014 -0700

    staging: comedi: dt282x: tidy up dt282x_ao_dma_interrupt()
    
    The main interrupt handler already has the comedi_subdevice pointer
    needed in this function. Pass that subdevice pointer so that it does
    not need to be fetched as a local variable.
    
    Tidy up the function a bit.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3071f11ba4f9..40c5794ec5c4 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -461,31 +461,27 @@ static void dt282x_munge(struct comedi_device *dev,
 	}
 }
 
-static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
+static void dt282x_ao_dma_interrupt(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
 {
 	struct dt282x_private *devpriv = dev->private;
-	struct comedi_subdevice *s = dev->write_subdev;
-	void *ptr;
+	int cur_dma = devpriv->current_dma_index;
+	void *ptr = devpriv->dma[cur_dma].buf;
 	int size;
-	int i;
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
-	i = devpriv->current_dma_index;
-	ptr = devpriv->dma[i].buf;
+	disable_dma(devpriv->dma[cur_dma].chan);
 
-	disable_dma(devpriv->dma[i].chan);
-
-	devpriv->current_dma_index = 1 - i;
+	devpriv->current_dma_index = 1 - cur_dma;
 
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
 		dev_err(dev->class_dev, "AO underrun\n");
 		s->async->events |= COMEDI_CB_OVERFLOW;
-		return;
+	} else {
+		dt282x_prep_ao_dma(dev, cur_dma, size);
 	}
-	dt282x_prep_ao_dma(dev, i, size);
-	return;
 }
 
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
@@ -556,7 +552,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		if (devpriv->dma_dir == DMA_MODE_READ)
 			dt282x_ai_dma_interrupt(dev);
 		else
-			dt282x_ao_dma_interrupt(dev);
+			dt282x_ao_dma_interrupt(dev, s_ao);
 		handled = 1;
 	}
 	if (adcsr & DT2821_ADERR) {

commit ecac148c60d341c9e50e2b65744d2ffde5b884cb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:47 2014 -0700

    staging: comedi: dt282x: remove sanity checks of 's->async->prealloc_buf'
    
    The comedi core sanity checks that the subdevice has a buffer allocated
    before allowing an async command to start. The helper functions in comedi_buf
    will also sanity check the buffer as a side effect of the 'alloc' helpers
    with reading or writing data for the buffer.
    
    Remove the unnecessary sanity checks in the ai/ao dma interrupt handlers.
    This will allow the handlers to disable the dma and then fail when they
    try to read/write the buffer. Currently dma is left enabled due to the
    sanity checks.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index d2a519d7be43..3071f11ba4f9 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -471,11 +471,6 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
-	if (!s->async->prealloc_buf) {
-		dev_err(dev->class_dev, "no buffer in %s\n", __func__);
-		return;
-	}
-
 	i = devpriv->current_dma_index;
 	ptr = devpriv->dma[i].buf;
 
@@ -504,11 +499,6 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
-	if (!s->async->prealloc_buf) {
-		dev_err(dev->class_dev, "no buffer in %s\n", __func__);
-		return;
-	}
-
 	i = devpriv->current_dma_index;
 	ptr = devpriv->dma[i].buf;
 	size = devpriv->dma[i].size;

commit f83cbc53dafb9755b0002976c3956052b089c4c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:46 2014 -0700

    staging: comedi: dt282x: tidy up Digital I/O subdevice init
    
    For aesthetics, add some whitespace to the Digital I/O subdevice init.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e3f612315fe4..d2a519d7be43 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1304,15 +1304,15 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
+	/* Digital I/O subdevice */
 	s = &dev->subdevices[2];
-	/* dio subsystem */
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 16;
-	s->insn_bits = dt282x_dio_insn_bits;
-	s->insn_config = dt282x_dio_insn_config;
-	s->maxdata = 1;
-	s->range_table = &range_digital;
+	s->type		= COMEDI_SUBD_DIO;
+	s->subdev_flags	= SDF_READABLE | SDF_WRITABLE;
+	s->n_chan	= 16;
+	s->maxdata	= 1;
+	s->range_table	= &range_digital;
+	s->insn_bits	= dt282x_dio_insn_bits;
+	s->insn_config	= dt282x_dio_insn_config;
 
 	return 0;
 }

commit 198c15a63d016ce6e7b339e1b7e02e2595a75b00
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:45 2014 -0700

    staging: comedi: dt282x: rename the prep_{ai,ao}_dma() functions
    
    Rename these functions so they have namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9527adf73ece..e3f612315fe4 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -345,7 +345,7 @@ struct dt282x_private {
 	int dma_dir;
 };
 
-static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
+static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
 	int dma_chan;
@@ -377,7 +377,7 @@ static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 	return n;
 }
 
-static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
+static int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;
 	int dma_chan;
@@ -489,7 +489,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
 	}
-	prep_ao_dma(dev, i, size);
+	dt282x_prep_ao_dma(dev, i, size);
 	return;
 }
 
@@ -542,7 +542,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	}
 #endif
 	/* restart the channel */
-	prep_ai_dma(dev, i, 0);
+	dt282x_prep_ai_dma(dev, i, 0);
 }
 
 static irqreturn_t dt282x_interrupt(int irq, void *d)
@@ -800,9 +800,9 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	devpriv->dma_dir = DMA_MODE_READ;
 	devpriv->current_dma_index = 0;
-	prep_ai_dma(dev, 0, 0);
+	dt282x_prep_ai_dma(dev, 0, 0);
 	if (devpriv->ntrig) {
-		prep_ai_dma(dev, 1, 0);
+		dt282x_prep_ai_dma(dev, 1, 0);
 		devpriv->supcsr |= DT2821_DDMA;
 		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
 	}
@@ -975,7 +975,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 		dev_err(dev->class_dev, "AO underrun\n");
 		return -EPIPE;
 	}
-	prep_ao_dma(dev, 0, size);
+	dt282x_prep_ao_dma(dev, 0, size);
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
 					  devpriv->dma_maxsize);
@@ -983,7 +983,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 		dev_err(dev->class_dev, "AO underrun\n");
 		return -EPIPE;
 	}
-	prep_ao_dma(dev, 1, size);
+	dt282x_prep_ao_dma(dev, 1, size);
 
 	outw(devpriv->supcsr | DT2821_STRIG, dev->iobase + DT2821_SUPCSR);
 	s->async->inttrig = NULL;

commit 6ee9c91fbbcf9e29951fb741492b5e9e6b6ac0ef
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:44 2014 -0700

    staging: comedi: dt282x: remove unused chan_to_DAC() macro
    
    This macro is not used in the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2e1c615c8105..9527adf73ece 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -345,11 +345,6 @@ struct dt282x_private {
 	int dma_dir;
 };
 
-/*
- *    Some useless abstractions
- */
-#define chan_to_DAC(a)	((a)&1)
-
 static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	struct dt282x_private *devpriv = dev->private;

commit 30dadbd208a480bb1ca919e395602adaafdbc449
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:43 2014 -0700

    staging: comedi: dt282x: convert private data flags to bit-fields
    
    Convert the '2scomp' flags in the private data into bit-fields to save
    a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3276c0738573..2e1c615c8105 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -320,9 +320,9 @@ static const struct dt282x_board boardtypes[] = {
 };
 
 struct dt282x_private {
-	int ad_2scomp;		/* we have 2's comp jumper set  */
-	int da0_2scomp;		/* same, for DAC0               */
-	int da1_2scomp;		/* same, for DAC1               */
+	unsigned int ad_2scomp:1;
+	unsigned int da0_2scomp:1;
+	unsigned int da1_2scomp:1;
 
 	const struct comedi_lrange *darangelist[2];
 
@@ -1270,7 +1270,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = board->ai_maxdata;
 	s->range_table =
 	    opt_ai_range_lkup(board->ispgl, it->options[opt_ai_range]);
-	devpriv->ad_2scomp = it->options[opt_ai_twos];
+	devpriv->ad_2scomp = it->options[opt_ai_twos] ? 1 : 0;
 	if (dev->irq) {
 		dev->read_subdev = s;
 		s->subdev_flags |= SDF_CMD_READ;
@@ -1295,8 +1295,8 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		    opt_ao_range_lkup(it->options[opt_ao0_range]);
 		devpriv->darangelist[1] =
 		    opt_ao_range_lkup(it->options[opt_ao1_range]);
-		devpriv->da0_2scomp = it->options[opt_ao0_twos];
-		devpriv->da1_2scomp = it->options[opt_ao1_twos];
+		devpriv->da0_2scomp = it->options[opt_ao0_twos] ? 1 : 0;
+		devpriv->da1_2scomp = it->options[opt_ao1_twos] ? 1 : 0;
 		if (dev->irq) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;

commit c53a62f64a072ea1ba31aa657e5962cf2a8f360e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:42 2014 -0700

    staging: comedi: dt282x: remove DT2821_SIZE define
    
    This define is only used in the comedi_request_region() call to specify
    the size of the I/O region. Remove it and just open code the value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index cb12cca0f28f..3276c0738573 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -63,8 +63,6 @@ Configuration options:
 
 #include "comedi_fc.h"
 
-#define DT2821_SIZE 0x10
-
 /*
  *    Registers in the DT282x
  */
@@ -1197,7 +1195,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int ret;
 	int i;
 
-	ret = comedi_request_region(dev, it->options[0], DT2821_SIZE);
+	ret = comedi_request_region(dev, it->options[0], 0x10);
 	if (ret)
 		return ret;
 

commit cb3d0d3996fe5c8c4fd7063b4bea890767469cb1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:41 2014 -0700

    staging: comedi: dt282x: IRQ and DMA are needed for async command support
    
    This driver requires an IRQ and 2 DMA channels in order to execute async
    commands.
    
    Modify the (*attach) so that command support is only hooked up if
    DMA is available. This allows removing the extra checks in the
    command support functions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5ae15bcccb5e..cb12cca0f28f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -343,7 +343,6 @@ struct dt282x_private {
 		int size;	/* size of current transfer */
 	} dma[2];
 	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
-	int usedma;		/* driver uses DMA              */
 	int current_dma_index;
 	int dma_dir;
 };
@@ -412,10 +411,8 @@ static void dt282x_disable_dma(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
 
-	if (devpriv->usedma) {
-		disable_dma(devpriv->dma[0].chan);
-		disable_dma(devpriv->dma[1].chan);
-	}
+	disable_dma(devpriv->dma[0].chan);
+	disable_dma(devpriv->dma[1].chan);
 }
 
 static int dt282x_ns_to_timer(int *nanosec, int round_mode)
@@ -788,13 +785,6 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int timer;
 	int ret;
 
-	if (devpriv->usedma == 0) {
-		comedi_error(dev,
-			     "driver requires 2 dma channels"
-						" to execute command");
-		return -EIO;
-	}
-
 	dt282x_disable_dma(dev);
 
 	if (cmd->convert_arg < board->ai_speed)
@@ -1014,13 +1004,6 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	int timer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
-	if (devpriv->usedma == 0) {
-		comedi_error(dev,
-			     "driver requires 2 dma channels"
-						" to execute command");
-		return -EIO;
-	}
-
 	dt282x_disable_dma(dev);
 
 	devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS1 | DT2821_DDMA;
@@ -1155,21 +1138,6 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 	struct dt282x_private *devpriv = dev->private;
 	int ret;
 
-	devpriv->usedma = 0;
-
-	if (!dma1 && !dma2)
-		return 0;
-
-	if (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)
-		return -EINVAL;
-
-	if (dma2 < dma1) {
-		int i;
-		i = dma1;
-		dma1 = dma2;
-		dma2 = i;
-	}
-
 	ret = request_dma(dma1, "dt282x A");
 	if (ret)
 		return -EBUSY;
@@ -1186,11 +1154,27 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf)
 		return -ENOMEM;
 
-	devpriv->usedma = 1;
-
 	return 0;
 }
 
+static void dt282x_free_dma(struct comedi_device *dev)
+{
+	struct dt282x_private *devpriv = dev->private;
+	int i;
+
+	if (!devpriv)
+		return;
+
+	for (i = 0; i < 2; i++) {
+		if (devpriv->dma[i].chan)
+			free_dma(devpriv->dma[i].chan);
+		if (devpriv->dma[i].buf)
+			free_page((unsigned long)devpriv->dma[i].buf);
+		devpriv->dma[i].chan = 0;
+		devpriv->dma[i].buf = NULL;
+	}
+}
+
 /*
    options:
    0	i/o base
@@ -1235,22 +1219,41 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	/* should do board test */
 
-	if (it->options[opt_irq] > 0) {
-		ret = request_irq(it->options[opt_irq], dt282x_interrupt, 0,
-				  dev->board_name, dev);
-		if (ret == 0)
-			dev->irq = it->options[opt_irq];
-	}
-
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
 
-	if (dev->irq) {
-		ret = dt282x_grab_dma(dev, it->options[opt_dma1],
-				      it->options[opt_dma2]);
-		if (ret < 0)
-			return ret;
+	/* an IRQ and 2 DMA channels are required for async command support */
+	if (it->options[opt_irq] &&
+	    it->options[opt_dma1] && it->options[opt_dma2]) {
+		unsigned int irq = it->options[opt_irq];
+		unsigned int dma1 = it->options[opt_dma1];
+		unsigned int dma2 = it->options[opt_dma2];
+
+		if (dma2 < dma1) {
+			unsigned int swap;
+
+			swap = dma1;
+			dma1 = dma2;
+			dma2 = swap;
+		}
+
+		if (dma1 != dma2 &&
+		    dma1 >= 5 && dma1 <= 7 &&
+		    dma2 >= 5 && dma2 <= 7) {
+			ret = request_irq(irq, dt282x_interrupt, 0,
+					  dev->board_name, dev);
+			if (ret == 0) {
+				dev->irq = irq;
+
+				ret = dt282x_grab_dma(dev, dma1, dma2);
+				if (ret < 0) {
+					dt282x_free_dma(dev);
+					free_irq(dev->irq, dev);
+					dev->irq = 0;
+				}
+			}
+		}
 	}
 
 	ret = comedi_alloc_subdevices(dev, 3);
@@ -1323,18 +1326,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void dt282x_detach(struct comedi_device *dev)
 {
-	struct dt282x_private *devpriv = dev->private;
-
-	if (dev->private) {
-		if (devpriv->dma[0].chan)
-			free_dma(devpriv->dma[0].chan);
-		if (devpriv->dma[1].chan)
-			free_dma(devpriv->dma[1].chan);
-		if (devpriv->dma[0].buf)
-			free_page((unsigned long)devpriv->dma[0].buf);
-		if (devpriv->dma[1].buf)
-			free_page((unsigned long)devpriv->dma[1].buf);
-	}
+	dt282x_free_dma(dev);
 	comedi_legacy_detach(dev);
 }
 

commit ebf86ea9a68e2ebb366dc7640f916e233d614db1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:40 2014 -0700

    staging: comedi: dt282x: remove 'volatile' on private data variables
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index dcc4055bee71..5ae15bcccb5e 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -330,21 +330,21 @@ struct dt282x_private {
 
 	unsigned short ao[2];
 
-	volatile int dacsr;	/* software copies of registers */
-	volatile int adcsr;
-	volatile int supcsr;
+	int dacsr;	/* software copies of registers */
+	int adcsr;
+	int supcsr;
 
-	volatile int ntrig;
-	volatile int nread;
+	int ntrig;
+	int nread;
 
 	struct {
 		int chan;
 		unsigned short *buf;	/* DMA buffer */
-		volatile int size;	/* size of current transfer */
+		int size;	/* size of current transfer */
 	} dma[2];
 	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
 	int usedma;		/* driver uses DMA              */
-	volatile int current_dma_index;
+	int current_dma_index;
 	int dma_dir;
 };
 

commit 804ee9ac04c01946c5ba158b5e350b40ee515fed
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:39 2014 -0700

    staging: comedi: dt282x: fix dt282x_ao_insn_write()
    
    The (*insn_write) functions are expected to write 'insn->n' samples to the
    hardware. Fix this function so it works like the comedi core expects.
    
    The comedi core sanity checks that the samples are within the 'maxdata' range
    of the subdevice before calling the (*insn_write) so this function does not
    need to mask each sample by 's->maxdata'.
    
    Also, the wrong '*2scomp' flag in the private data was being checked to see
    if the sample needs to be munged before being written. Fix this.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3eaf26cb2218..dcc4055bee71 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -882,37 +882,42 @@ static int dt282x_ao_insn_read(struct comedi_device *dev,
 
 static int dt282x_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
 	struct dt282x_private *devpriv = dev->private;
-	unsigned int d;
-	unsigned int chan;
-
-	chan = CR_CHAN(insn->chanspec);
-	d = data[0];
-	d &= s->maxdata;
-	devpriv->ao[chan] = d;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	bool munge = false;
+	unsigned int val;
+	int i;
 
 	devpriv->dacsr |= DT2821_SSEL;
-
 	if (chan) {
-		/* select channel */
 		devpriv->dacsr |= DT2821_YSEL;
-		if (devpriv->da0_2scomp)
-			d = comedi_offset_munge(s, d);
+		if (devpriv->da1_2scomp)
+			munge = true;
 	} else {
 		devpriv->dacsr &= ~DT2821_YSEL;
-		if (devpriv->da1_2scomp)
-			d = comedi_offset_munge(s, d);
+		if (devpriv->da0_2scomp)
+			munge = true;
 	}
 
-	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		devpriv->ao[chan] = val;
 
-	outw(d, dev->iobase + DT2821_DADAT);
+		if (munge)
+			val = comedi_offset_munge(s, val);
 
-	outw(devpriv->supcsr | DT2821_DACON, dev->iobase + DT2821_SUPCSR);
+		outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
 
-	return 1;
+		outw(val, dev->iobase + DT2821_DADAT);
+
+		outw(devpriv->supcsr | DT2821_DACON,
+		     dev->iobase + DT2821_SUPCSR);
+	}
+
+	return insn->n;
 }
 
 static int dt282x_ao_cmdtest(struct comedi_device *dev,

commit 58c8c47fda4aa37ec946ff7ad1a42b875b03da74
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:38 2014 -0700

    staging: comedi: dt282x: convert 'dabits' boardinfo to 'ao_maxdata'
    
    This member of the boardinfo is the number of bits in the analog output data.
    Convert this member into the subdevice 'maxdata', (1 << board->dabits) - 1,
    to avoid needing to do the calculation.
    
    Use the subdevice 'maxdata' in the driver instead of using the boardinfo and
    use the comedi_offset_munge() helper to convert the two's complement data to
    the offset binary form that the comedi core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 523e8490fedc..3eaf26cb2218 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -213,7 +213,7 @@ struct dt282x_board {
 	int ai_speed;
 	int ispgl;
 	int dachan;
-	int dabits;
+	unsigned int ao_maxdata;
 };
 
 static const struct dt282x_board boardtypes[] = {
@@ -224,7 +224,7 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2821-f",
 		.ai_maxdata	= 0x0fff,
@@ -232,7 +232,7 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 6500,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2821-g",
 		.ai_maxdata	= 0x0fff,
@@ -240,14 +240,14 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 4000,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2823",
 		.ai_maxdata	= 0xffff,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
-		.dabits		= 16,
+		.ao_maxdata	= 0xffff,
 	}, {
 		.name		= "dt2824-pgh",
 		.ai_maxdata	= 0x0fff,
@@ -269,28 +269,28 @@ static const struct dt282x_board boardtypes[] = {
 		.ai_speed	= 20000,
 		.ispgl		= 1,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2827",
 		.ai_maxdata	= 0xffff,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2828",
 		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt2829",
 		.ai_maxdata	= 0xffff,
 		.adchan_se	= 8,
 		.ai_speed	= 33250,
 		.dachan		= 2,
-		.dabits		= 16,
+		.ao_maxdata	= 0xffff,
 	}, {
 		.name		= "dt21-ez",
 		.ai_maxdata	= 0x0fff,
@@ -298,7 +298,7 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
 		.dachan		= 2,
-		.dabits		= 12,
+		.ao_maxdata	= 0x0fff,
 	}, {
 		.name		= "dt23-ez",
 		.ai_maxdata	= 0xffff,
@@ -884,14 +884,13 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
-	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
-	unsigned short d;
+	unsigned int d;
 	unsigned int chan;
 
 	chan = CR_CHAN(insn->chanspec);
 	d = data[0];
-	d &= (1 << board->dabits) - 1;
+	d &= s->maxdata;
 	devpriv->ao[chan] = d;
 
 	devpriv->dacsr |= DT2821_SSEL;
@@ -900,11 +899,11 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 		/* select channel */
 		devpriv->dacsr |= DT2821_YSEL;
 		if (devpriv->da0_2scomp)
-			d ^= (1 << (board->dabits - 1));
+			d = comedi_offset_munge(s, d);
 	} else {
 		devpriv->dacsr &= ~DT2821_YSEL;
 		if (devpriv->da1_2scomp)
-			d ^= (1 << (board->dabits - 1));
+			d = comedi_offset_munge(s, d);
 	}
 
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
@@ -1284,7 +1283,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->subdev_flags = SDF_WRITABLE;
 		s->insn_read = dt282x_ao_insn_read;
 		s->insn_write = dt282x_ao_insn_write;
-		s->maxdata = (1 << board->dabits) - 1;
+		s->maxdata = board->ao_maxdata;
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] =
 		    opt_ao_range_lkup(it->options[opt_ao0_range]);

commit d839495b64d0ec599e1d2cc74ce3705043c2dae4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jun 20 13:12:37 2014 -0700

    staging: comedi: dt282x: convert 'adbits' boardinfo to 'ai_maxdata'
    
    This member of the boardinfo is the number of bits in the analog input data.
    Convert this member into the subdevice 'maxdata', (1 << board->adbits) - 1,
    to avoid needing to do the calculation.
    
    Use the subdevice 'maxdata' in the driver instead of using the boardinfo and
    use the comedi_offset_munge() helper to convert the two's complement data to
    the offset binary form that the comedi core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index ea4abccdd202..523e8490fedc 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -207,7 +207,7 @@ static const struct comedi_lrange range_dt282x_ai_hi_unipolar = {
 
 struct dt282x_board {
 	const char *name;
-	int adbits;
+	unsigned int ai_maxdata;
 	int adchan_se;
 	int adchan_di;
 	int ai_speed;
@@ -219,7 +219,7 @@ struct dt282x_board {
 static const struct dt282x_board boardtypes[] = {
 	{
 		.name		= "dt2821",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
@@ -227,7 +227,7 @@ static const struct dt282x_board boardtypes[] = {
 		.dabits		= 12,
 	}, {
 		.name		= "dt2821-f",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 6500,
@@ -235,7 +235,7 @@ static const struct dt282x_board boardtypes[] = {
 		.dabits		= 12,
 	}, {
 		.name		= "dt2821-g",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 4000,
@@ -243,27 +243,27 @@ static const struct dt282x_board boardtypes[] = {
 		.dabits		= 12,
 	}, {
 		.name		= "dt2823",
-		.adbits		= 16,
+		.ai_maxdata	= 0xffff,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
 		.dabits		= 16,
 	}, {
 		.name		= "dt2824-pgh",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
 	}, {
 		.name		= "dt2824-pgl",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
 		.ispgl		= 1,
 	}, {
 		.name		= "dt2825",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
@@ -272,28 +272,28 @@ static const struct dt282x_board boardtypes[] = {
 		.dabits		= 12,
 	}, {
 		.name		= "dt2827",
-		.adbits		= 16,
+		.ai_maxdata	= 0xffff,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
 		.name		= "dt2828",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 4,
 		.ai_speed	= 10000,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
 		.name		= "dt2829",
-		.adbits		= 16,
+		.ai_maxdata	= 0xffff,
 		.adchan_se	= 8,
 		.ai_speed	= 33250,
 		.dachan		= 2,
 		.dabits		= 16,
 	}, {
 		.name		= "dt21-ez",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
@@ -301,19 +301,19 @@ static const struct dt282x_board boardtypes[] = {
 		.dabits		= 12,
 	}, {
 		.name		= "dt23-ez",
-		.adbits		= 16,
+		.ai_maxdata	= 0xffff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
 	}, {
 		.name		= "dt24-ez",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
 	}, {
 		.name		= "dt24-ez-pgl",
-		.adbits		= 12,
+		.ai_maxdata	= 0x0fff,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
@@ -449,26 +449,26 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
 	return (15 << 8) | (255 - divider);
 }
 
-static void dt282x_munge(struct comedi_device *dev, unsigned short *buf,
+static void dt282x_munge(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned short *buf,
 			 unsigned int nbytes)
 {
-	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
-	unsigned int i;
-	unsigned short mask = (1 << board->adbits) - 1;
-	unsigned short sign = 1 << (board->adbits - 1);
-	int n;
-
-	if (devpriv->ad_2scomp)
-		sign = 1 << (board->adbits - 1);
-	else
-		sign = 0;
+	unsigned int val;
+	int i;
 
 	if (nbytes % 2)
 		comedi_error(dev, "bug! odd number of bytes from dma xfer");
-	n = nbytes / 2;
-	for (i = 0; i < n; i++)
-		buf[i] = (buf[i] & mask) ^ sign;
+
+	for (i = 0; i < nbytes / 2; i++) {
+		val = buf[i];
+		val &= s->maxdata;
+		if (devpriv->ad_2scomp)
+			val = comedi_offset_munge(s, val);
+
+		buf[i] = val;
+	}
 }
 
 static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
@@ -527,7 +527,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 
 	devpriv->current_dma_index = 1 - i;
 
-	dt282x_munge(dev, ptr, size);
+	dt282x_munge(dev, s, ptr, size);
 	ret = cfc_write_array_to_buffer(s, ptr, size);
 	if (ret != size) {
 		s->async->events |= COMEDI_CB_OVERFLOW;
@@ -597,10 +597,10 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		unsigned short data;
 
 		data = inw(dev->iobase + DT2821_ADDAT);
-		data &= (1 << board->adbits) - 1;
-
+		data &= s->maxdata;
 		if (devpriv->ad_2scomp)
-			data ^= 1 << (board->adbits - 1);
+			data = comedi_offset_munge(s, data);
+
 		ret = comedi_buf_put(s, data);
 
 		if (ret == 0)
@@ -671,10 +671,11 @@ static int dt282x_ai_timeout(struct comedi_device *dev,
  */
 static int dt282x_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
-			       struct comedi_insn *insn, unsigned int *data)
+			       struct comedi_insn *insn,
+			       unsigned int *data)
 {
-	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
+	unsigned int val;
 	int ret;
 	int i;
 
@@ -698,11 +699,12 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 		if (ret)
 			return ret;
 
-		data[i] =
-		    inw(dev->iobase +
-			DT2821_ADDAT) & ((1 << board->adbits) - 1);
+		val = inw(dev->iobase + DT2821_ADDAT);
+		val &= s->maxdata;
 		if (devpriv->ad_2scomp)
-			data[i] ^= (1 << (board->adbits - 1));
+			val = comedi_offset_munge(s, val);
+
+		data[i] = val;
 	}
 
 	return i;
@@ -1260,7 +1262,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->n_chan =
 	    (it->options[opt_diff]) ? board->adchan_di : board->adchan_se;
 	s->insn_read = dt282x_ai_insn_read;
-	s->maxdata = (1 << board->adbits) - 1;
+	s->maxdata = board->ai_maxdata;
 	s->range_table =
 	    opt_ai_range_lkup(board->ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];

commit f11c4b6caef19f331a9ce4821602eed6b12f131f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jun 20 13:12:36 2014 -0700

    staging: comedi: dt282x: remove '= 0' boardinfo
    
    All unlisted members in the boardinfo declaraction will default to '0'.
    Remove the unnecessary code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index aa6789dce7b1..ea4abccdd202 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -223,7 +223,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
@@ -232,7 +231,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 6500,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
@@ -241,16 +239,13 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 4000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
 		.name		= "dt2823",
 		.adbits		= 16,
-		.adchan_se	= 0,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 16,
 	}, {
@@ -259,9 +254,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
 	}, {
 		.name		= "dt2824-pgl",
 		.adbits		= 12,
@@ -269,8 +261,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 20000,
 		.ispgl		= 1,
-		.dachan		= 0,
-		.dabits		= 0,
 	}, {
 		.name		= "dt2825",
 		.adbits		= 12,
@@ -283,28 +273,22 @@ static const struct dt282x_board boardtypes[] = {
 	}, {
 		.name		= "dt2827",
 		.adbits		= 16,
-		.adchan_se	= 0,
 		.adchan_di	= 4,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
 		.name		= "dt2828",
 		.adbits		= 12,
 		.adchan_se	= 4,
-		.adchan_di	= 0,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
 		.name		= "dt2829",
 		.adbits		= 16,
 		.adchan_se	= 8,
-		.adchan_di	= 0,
 		.ai_speed	= 33250,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 16,
 	}, {
@@ -313,7 +297,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
 		.dachan		= 2,
 		.dabits		= 12,
 	}, {
@@ -322,18 +305,12 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
 	}, {
 		.name		= "dt24-ez",
 		.adbits		= 12,
 		.adchan_se	= 16,
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
 	}, {
 		.name		= "dt24-ez-pgl",
 		.adbits		= 12,
@@ -341,8 +318,6 @@ static const struct dt282x_board boardtypes[] = {
 		.adchan_di	= 8,
 		.ai_speed	= 10000,
 		.ispgl		= 1,
-		.dachan		= 0,
-		.dabits		= 0,
 	},
 };
 

commit 5aeb355fc7ebc0e8e50254193ddc830c059de33d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jun 20 13:12:35 2014 -0700

    staging: comedi: dt282x: move boardinfo declaration
    
    For asethetics, move the boardinfo declaration closer to the struct
    definition.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 424eebb06a41..aa6789dce7b1 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -216,6 +216,136 @@ struct dt282x_board {
 	int dabits;
 };
 
+static const struct dt282x_board boardtypes[] = {
+	{
+		.name		= "dt2821",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2821-f",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 6500,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2821-g",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 4000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2823",
+		.adbits		= 16,
+		.adchan_se	= 0,
+		.adchan_di	= 4,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 16,
+	}, {
+		.name		= "dt2824-pgh",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt2824-pgl",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 1,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt2825",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 1,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2827",
+		.adbits		= 16,
+		.adchan_se	= 0,
+		.adchan_di	= 4,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2828",
+		.adbits		= 12,
+		.adchan_se	= 4,
+		.adchan_di	= 0,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2829",
+		.adbits		= 16,
+		.adchan_se	= 8,
+		.adchan_di	= 0,
+		.ai_speed	= 33250,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 16,
+	}, {
+		.name		= "dt21-ez",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt23-ez",
+		.adbits		= 16,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt24-ez",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt24-ez-pgl",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 1,
+		.dachan		= 0,
+		.dabits		= 0,
+	},
+};
+
 struct dt282x_private {
 	int ad_2scomp;		/* we have 2's comp jumper set  */
 	int da0_2scomp;		/* same, for DAC0               */
@@ -1227,136 +1357,6 @@ static void dt282x_detach(struct comedi_device *dev)
 	comedi_legacy_detach(dev);
 }
 
-static const struct dt282x_board boardtypes[] = {
-	{
-		.name		= "dt2821",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 20000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2821-f",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 6500,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2821-g",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 4000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2823",
-		.adbits		= 16,
-		.adchan_se	= 0,
-		.adchan_di	= 4,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 16,
-	}, {
-		.name		= "dt2824-pgh",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 20000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
-	}, {
-		.name		= "dt2824-pgl",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 20000,
-		.ispgl		= 1,
-		.dachan		= 0,
-		.dabits		= 0,
-	}, {
-		.name		= "dt2825",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 20000,
-		.ispgl		= 1,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2827",
-		.adbits		= 16,
-		.adchan_se	= 0,
-		.adchan_di	= 4,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2828",
-		.adbits		= 12,
-		.adchan_se	= 4,
-		.adchan_di	= 0,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt2829",
-		.adbits		= 16,
-		.adchan_se	= 8,
-		.adchan_di	= 0,
-		.ai_speed	= 33250,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 16,
-	}, {
-		.name		= "dt21-ez",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 2,
-		.dabits		= 12,
-	}, {
-		.name		= "dt23-ez",
-		.adbits		= 16,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
-	}, {
-		.name		= "dt24-ez",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 10000,
-		.ispgl		= 0,
-		.dachan		= 0,
-		.dabits		= 0,
-	}, {
-		.name		= "dt24-ez-pgl",
-		.adbits		= 12,
-		.adchan_se	= 16,
-		.adchan_di	= 8,
-		.ai_speed	= 10000,
-		.ispgl		= 1,
-		.dachan		= 0,
-		.dabits		= 0,
-	},
-};
-
 static struct comedi_driver dt282x_driver = {
 	.driver_name	= "dt282x",
 	.module		= THIS_MODULE,

commit 935f0e8c2b127d0aaec12184718c7b3fc73b7787
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jun 20 13:12:34 2014 -0700

    staging: comedi: dt282x: remove forward declarations
    
    Move some of the functions to remove the need for the forward
    declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index c2a66dcf99fe..424eebb06a41 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -248,16 +248,101 @@ struct dt282x_private {
  */
 #define chan_to_DAC(a)	((a)&1)
 
-static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
-static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
-static int dt282x_ai_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
-static int dt282x_ao_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
-static int dt282x_ns_to_timer(int *nanosec, int round_mode);
-static void dt282x_disable_dma(struct comedi_device *dev);
+static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
+{
+	struct dt282x_private *devpriv = dev->private;
+	int dma_chan;
+	unsigned long dma_ptr;
+	unsigned long flags;
+
+	if (!devpriv->ntrig)
+		return 0;
+
+	if (n == 0)
+		n = devpriv->dma_maxsize;
+	if (n > devpriv->ntrig * 2)
+		n = devpriv->ntrig * 2;
+	devpriv->ntrig -= n / 2;
+
+	devpriv->dma[dma_index].size = n;
+	dma_chan = devpriv->dma[dma_index].chan;
+	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_addr(dma_chan, dma_ptr);
+	set_dma_count(dma_chan, n);
+	release_dma_lock(flags);
+
+	enable_dma(dma_chan);
+
+	return n;
+}
+
+static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
+{
+	struct dt282x_private *devpriv = dev->private;
+	int dma_chan;
+	unsigned long dma_ptr;
+	unsigned long flags;
+
+	devpriv->dma[dma_index].size = n;
+	dma_chan = devpriv->dma[dma_index].chan;
+	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+
+	set_dma_mode(dma_chan, DMA_MODE_WRITE);
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_addr(dma_chan, dma_ptr);
+	set_dma_count(dma_chan, n);
+	release_dma_lock(flags);
+
+	enable_dma(dma_chan);
+
+	return n;
+}
+
+static void dt282x_disable_dma(struct comedi_device *dev)
+{
+	struct dt282x_private *devpriv = dev->private;
 
-static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
+	if (devpriv->usedma) {
+		disable_dma(devpriv->dma[0].chan);
+		disable_dma(devpriv->dma[1].chan);
+	}
+}
+
+static int dt282x_ns_to_timer(int *nanosec, int round_mode)
+{
+	int prescale, base, divider;
+
+	for (prescale = 0; prescale < 16; prescale++) {
+		if (prescale == 1)
+			continue;
+		base = 250 * (1 << prescale);
+		switch (round_mode) {
+		case TRIG_ROUND_NEAREST:
+		default:
+			divider = (*nanosec + base / 2) / base;
+			break;
+		case TRIG_ROUND_DOWN:
+			divider = (*nanosec) / base;
+			break;
+		case TRIG_ROUND_UP:
+			divider = (*nanosec + base - 1) / base;
+			break;
+		}
+		if (divider < 256) {
+			*nanosec = divider * base;
+			return (prescale << 8) | (255 - divider);
+		}
+	}
+	base = 250 * (1 << 15);
+	divider = 255;
+	*nanosec = divider * base;
+	return (15 << 8) | (255 - divider);
+}
 
 static void dt282x_munge(struct comedi_device *dev, unsigned short *buf,
 			 unsigned int nbytes)
@@ -365,61 +450,6 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	prep_ai_dma(dev, i, 0);
 }
 
-static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
-{
-	struct dt282x_private *devpriv = dev->private;
-	int dma_chan;
-	unsigned long dma_ptr;
-	unsigned long flags;
-
-	if (!devpriv->ntrig)
-		return 0;
-
-	if (n == 0)
-		n = devpriv->dma_maxsize;
-	if (n > devpriv->ntrig * 2)
-		n = devpriv->ntrig * 2;
-	devpriv->ntrig -= n / 2;
-
-	devpriv->dma[dma_index].size = n;
-	dma_chan = devpriv->dma[dma_index].chan;
-	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
-
-	set_dma_mode(dma_chan, DMA_MODE_READ);
-	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_addr(dma_chan, dma_ptr);
-	set_dma_count(dma_chan, n);
-	release_dma_lock(flags);
-
-	enable_dma(dma_chan);
-
-	return n;
-}
-
-static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
-{
-	struct dt282x_private *devpriv = dev->private;
-	int dma_chan;
-	unsigned long dma_ptr;
-	unsigned long flags;
-
-	devpriv->dma[dma_index].size = n;
-	dma_chan = devpriv->dma[dma_index].chan;
-	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
-
-	set_dma_mode(dma_chan, DMA_MODE_WRITE);
-	flags = claim_dma_lock();
-	clear_dma_ff(dma_chan);
-	set_dma_addr(dma_chan, dma_ptr);
-	set_dma_count(dma_chan, n);
-	release_dma_lock(flags);
-
-	enable_dma(dma_chan);
-
-	return n;
-}
-
 static irqreturn_t dt282x_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
@@ -710,16 +740,6 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static void dt282x_disable_dma(struct comedi_device *dev)
-{
-	struct dt282x_private *devpriv = dev->private;
-
-	if (devpriv->usedma) {
-		disable_dma(devpriv->dma[0].chan);
-		disable_dma(devpriv->dma[1].chan);
-	}
-}
-
 static int dt282x_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -736,37 +756,6 @@ static int dt282x_ai_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static int dt282x_ns_to_timer(int *nanosec, int round_mode)
-{
-	int prescale, base, divider;
-
-	for (prescale = 0; prescale < 16; prescale++) {
-		if (prescale == 1)
-			continue;
-		base = 250 * (1 << prescale);
-		switch (round_mode) {
-		case TRIG_ROUND_NEAREST:
-		default:
-			divider = (*nanosec + base / 2) / base;
-			break;
-		case TRIG_ROUND_DOWN:
-			divider = (*nanosec) / base;
-			break;
-		case TRIG_ROUND_UP:
-			divider = (*nanosec + base - 1) / base;
-			break;
-		}
-		if (divider < 256) {
-			*nanosec = divider * base;
-			return (prescale << 8) | (255 - divider);
-		}
-	}
-	base = 250 * (1 << 15);
-	divider = 255;
-	*nanosec = divider * base;
-	return (15 << 8) | (255 - divider);
-}
-
 /*
  *    Analog output routine.  Selects single channel conversion,
  *      selects correct channel, converts from 2's compliment to

commit 9f57921507dacdcba186e384b2025601ad09b227
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:50 2014 -0700

    staging: comedi: dt282x: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 15d5145166e0..c2a66dcf99fe 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -578,7 +578,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 {
 	const struct dt282x_board *board = comedi_board(dev);
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -633,10 +633,9 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	tmp = cmd->convert_arg;
-	dt282x_ns_to_timer(&cmd->convert_arg, cmd->flags & TRIG_ROUND_MASK);
-	if (tmp != cmd->convert_arg)
-		err++;
+	arg = cmd->convert_arg;
+	dt282x_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 	if (err)
 		return 4;
@@ -825,7 +824,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -865,10 +864,9 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 
 	/* step 4: fix up any arguments */
 
-	tmp = cmd->scan_begin_arg;
-	dt282x_ns_to_timer(&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
-	if (tmp != cmd->scan_begin_arg)
-		err++;
+	arg = cmd->scan_begin_arg;
+	dt282x_ns_to_timer(&arg, cmd->flags & TRIG_ROUND_MASK);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 
 	if (err)
 		return 4;

commit 3672effdeae5395d661a2103f69082146ef949fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue May 6 13:11:59 2014 +0100

    staging: comedi: pass subdevice to comedi_buf_put()
    
    Change the parameters of `comedi_buf_put()` to pass a pointer to the
    comedi subdevice instead of a pointer to the "async" structure belonging
    to the subdevice.
    
    The function puts a sample value in the comedi buffer, but currently
    only deals with 16-bit sample types.  A future version could deal with
    16 or 32-bit sample types depending on the value of the SDF_LSAMPL
    subdevice flag.
    
    The main aim at the moment is to replace all the `struct comedi_async *`
    parameters with `struct comedi_subdevice *` parameters in the comedi
    driver API.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 474f52dac15d..15d5145166e0 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -466,7 +466,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 
 		if (devpriv->ad_2scomp)
 			data ^= 1 << (board->adbits - 1);
-		ret = comedi_buf_put(s->async, data);
+		ret = comedi_buf_put(s, data);
 
 		if (ret == 0)
 			s->async->events |= COMEDI_CB_OVERFLOW;

commit bdbca9b562a2e892b77811ef2b70e1981e26b7e2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:59 2014 -0700

    staging: comedi: dt282x: fix the ao cmd->start_arg use for TRIG_INT
    
    This driver only supports a cmd->start_src of TRIG_INT for ao commands. The
    cmd->start_arg is trivially validated to be 0. For TRIG_INT source, the
    cmd->start_arg is actually the valid trig_num that is passed to the async
    (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used to check
    the trig_num instead of the open coded value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index b1154f0641d2..474f52dac15d 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -878,12 +878,14 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 }
 
 static int dt282x_ao_inttrig(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int x)
+			     struct comedi_subdevice *s,
+			     unsigned int trig_num)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int size;
 
-	if (x != 0)
+	if (trig_num != cmd->start_src)
 		return -EINVAL;
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,

commit f50cebb9baa5fd0e561f436bd53ffa35df16edb2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:47 2014 -0700

    staging: comedi: drivers: properly validate cmd->scan_end_arg
    
    When the async command 'scan_end_src' is TRIG_COUNT the 'scan_end_arg'
    is the cmd->chanlist_len. Fix a couple open-coded drivers. Add the
    check to the drivers that do not validate this command argument.
    
    The core validates that the cmd->chanlist_len is <= s->len_chanlist.
    During the post config after the attach the core also make sure that
    the s->len_chanlist is initialized. For clarity, initialize the
    s->len_chanlist in a couple drivers that are relying on the core to
    initialize it to '1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 16cc100531e5..b1154f0641d2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -852,7 +852,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);
 	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg, 2);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */

commit f21c74fa4cfe675f5e81b7d604212882799f4e6d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:33 2014 -0700

    staging: comedi: dt282x: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    This also fixes two bugs.
      1) the analog input command is canceled due to a buffer overflow
         without sending an event (@@ -341,7 +340,7 @@).
      2) an analog output error causes the command to cancel but the event
         is reported to the analog input subdevice (@@ -449,15 +447,13 @@).
    
    In the Kconfig, COMEDI_DT282X already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6cc8f1d5b831..16cc100531e5 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -306,7 +306,6 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
 		dev_err(dev->class_dev, "AO underrun\n");
-		dt282x_ao_cancel(dev, s);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
 	}
@@ -341,7 +340,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	dt282x_munge(dev, ptr, size);
 	ret = cfc_write_array_to_buffer(s, ptr, size);
 	if (ret != size) {
-		dt282x_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
 	}
 	devpriv->nread -= size / 2;
@@ -351,7 +350,6 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 		devpriv->nread = 0;
 	}
 	if (!devpriv->nread) {
-		dt282x_ai_cancel(dev, s);
 		s->async->events |= COMEDI_CB_EOA;
 		return;
 	}
@@ -449,15 +447,13 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	if (adcsr & DT2821_ADERR) {
 		if (devpriv->nread != 0) {
 			comedi_error(dev, "A/D error");
-			dt282x_ai_cancel(dev, s);
 			s->async->events |= COMEDI_CB_ERROR;
 		}
 		handled = 1;
 	}
 	if (dacsr & DT2821_DAERR) {
 		comedi_error(dev, "D/A error");
-		dt282x_ao_cancel(dev, s_ao);
-		s->async->events |= COMEDI_CB_ERROR;
+		s_ao->async->events |= COMEDI_CB_ERROR;
 		handled = 1;
 	}
 #if 0
@@ -486,7 +482,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		handled = 1;
 	}
 #endif
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
+	cfc_handle_events(dev, s_ao);
 
 	return IRQ_RETVAL(handled);
 }

commit 22ca19d93d92c79cff68270846a84bd34fe6fb34
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:45 2014 -0700

    staging: comedi: move (*insn_{read, write}) timeout debug messages to core
    
    Have the comedi core display a standard dev_dbg() message when a timeout
    occurs and remove all the driver specific messages.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f768210184c1..6cc8f1d5b831 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -554,10 +554,8 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 
 	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
 	ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout, DT2821_MUXBUSY);
-	if (ret) {
-		comedi_error(dev, "timeout\n");
+	if (ret)
 		return ret;
-	}
 
 	for (i = 0; i < insn->n; i++) {
 		outw(devpriv->supcsr | DT2821_STRIG,
@@ -565,10 +563,8 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 
 		ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout,
 				     DT2821_ADDONE);
-		if (ret) {
-			comedi_error(dev, "timeout\n");
+		if (ret)
 			return ret;
-		}
 
 		data[i] =
 		    inw(dev->iobase +
@@ -704,10 +700,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
 	ret = comedi_timeout(dev, s, NULL, dt282x_ai_timeout, DT2821_MUXBUSY);
-	if (ret) {
-		comedi_error(dev, "timeout\n");
+	if (ret)
 		return ret;
-	}
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		outw(devpriv->supcsr | DT2821_STRIG,

commit d8644e418b2613b3eaf1e10fe6fd0d84018c2f8a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:38 2014 -0700

    staging: comedi: dt282x: use comedi_timeout()
    
    The wait_for() macro in this driver is a bit nasty. It effects control flow
    which according to the CodingStyle is a _very_ bad idea.
    
    The mux_busy() and ad_done() macros are also bad since they rely on a local
    variable having a specific name.
    
    Remove these macros and use comedi_timeout() to wait for the analog input
    mux busy completion and end-of-conversion. Both of these are detected by
    reading the same register and testing different bits. Pass the bits to test
    as the 'context' to the callback function.
    
    The dt282x_ai_cmd() function also checks for the mux busy completion. The
    'insn' is not available here but passing NULL is safe because nothing
    uses it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 895f73a19023..f768210184c1 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -63,7 +63,6 @@ Configuration options:
 
 #include "comedi_fc.h"
 
-#define DT2821_TIMEOUT		100	/* 500 us */
 #define DT2821_SIZE 0x10
 
 /*
@@ -248,27 +247,6 @@ struct dt282x_private {
  *    Some useless abstractions
  */
 #define chan_to_DAC(a)	((a)&1)
-#define mux_busy() (inw(dev->iobase+DT2821_ADCSR)&DT2821_MUXBUSY)
-#define ad_done() (inw(dev->iobase+DT2821_ADCSR)&DT2821_ADDONE)
-
-/*
- *    danger! macro abuse... a is the expression to wait on, and b is
- *      the statement(s) to execute if it doesn't happen.
- */
-#define wait_for(a, b)						\
-	do {							\
-		int _i;						\
-		for (_i = 0; _i < DT2821_TIMEOUT; _i++) {	\
-			if (a) {				\
-				_i = 0;				\
-				break;				\
-			}					\
-			udelay(5);				\
-		}						\
-		if (_i) {					\
-			b					\
-		}						\
-	} while (0)
 
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
 static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
@@ -530,6 +508,29 @@ static void dt282x_load_changain(struct comedi_device *dev, int n,
 	outw(n - 1, dev->iobase + DT2821_CHANCSR);
 }
 
+static int dt282x_ai_timeout(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn,
+			     unsigned long context)
+{
+	unsigned int status;
+
+	status = inw(dev->iobase + DT2821_ADCSR);
+	switch (context) {
+	case DT2821_MUXBUSY:
+		if ((status & DT2821_MUXBUSY) == 0)
+			return 0;
+		break;
+	case DT2821_ADDONE:
+		if (status & DT2821_ADDONE)
+			return 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return -EBUSY;
+}
+
 /*
  *    Performs a single A/D conversion.
  *      - Put channel/gain into channel-gain list
@@ -542,6 +543,7 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 {
 	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
+	int ret;
 	int i;
 
 	/* XXX should we really be enabling the ad clock here? */
@@ -551,13 +553,22 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 	dt282x_load_changain(dev, 1, &insn->chanspec);
 
 	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
+	ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout, DT2821_MUXBUSY);
+	if (ret) {
+		comedi_error(dev, "timeout\n");
+		return ret;
+	}
 
 	for (i = 0; i < insn->n; i++) {
 		outw(devpriv->supcsr | DT2821_STRIG,
 			dev->iobase + DT2821_SUPCSR);
-		wait_for(ad_done(), comedi_error(dev, "timeout\n");
-			 return -ETIME;);
+
+		ret = comedi_timeout(dev, s, insn, dt282x_ai_timeout,
+				     DT2821_ADDONE);
+		if (ret) {
+			comedi_error(dev, "timeout\n");
+			return ret;
+		}
 
 		data[i] =
 		    inw(dev->iobase +
@@ -646,6 +657,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	struct dt282x_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
+	int ret;
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
@@ -691,7 +703,11 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
 
 	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
+	ret = comedi_timeout(dev, s, NULL, dt282x_ai_timeout, DT2821_MUXBUSY);
+	if (ret) {
+		comedi_error(dev, "timeout\n");
+		return ret;
+	}
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		outw(devpriv->supcsr | DT2821_STRIG,

commit 0bb7781b43b1d8585016b0e731edfa264620601e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:08 2013 -0700

    staging: comedi: dt282x: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Use the BIP_RANGE and UNI_RANGE macros instead of the more generic
    RANGE macro to reduce possible typo errors.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index ae714a526c35..895f73a19023 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -154,55 +154,55 @@ Configuration options:
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = {
 	4, {
-		RANGE(-10, 10),
-		RANGE(-5, 5),
-		RANGE(-2.5, 2.5),
-		RANGE(-1.25, 1.25)
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25)
 	}
 };
 
 static const struct comedi_lrange range_dt282x_ai_lo_unipolar = {
 	4, {
-		RANGE(0, 10),
-		RANGE(0, 5),
-		RANGE(0, 2.5),
-		RANGE(0, 1.25)
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
 	}
 };
 
 static const struct comedi_lrange range_dt282x_ai_5_bipolar = {
 	4, {
-		RANGE(-5, 5),
-		RANGE(-2.5, 2.5),
-		RANGE(-1.25, 1.25),
-		RANGE(-0.625, 0.625)
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		BIP_RANGE(0.625)
 	}
 };
 
 static const struct comedi_lrange range_dt282x_ai_5_unipolar = {
 	4, {
-		RANGE(0, 5),
-		RANGE(0, 2.5),
-		RANGE(0, 1.25),
-		RANGE(0, 0.625),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25),
+		UNI_RANGE(0.625)
 	}
 };
 
 static const struct comedi_lrange range_dt282x_ai_hi_bipolar = {
 	4, {
-		RANGE(-10, 10),
-		RANGE(-1, 1),
-		RANGE(-0.1, 0.1),
-		RANGE(-0.02, 0.02)
+		BIP_RANGE(10),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.02)
 	}
 };
 
 static const struct comedi_lrange range_dt282x_ai_hi_unipolar = {
 	4, {
-		RANGE(0, 10),
-		RANGE(0, 1),
-		RANGE(0, 0.1),
-		RANGE(0, 0.02)
+		UNI_RANGE(10),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.02)
 	}
 };
 

commit 95dc140a5e9210c6305b4f8b91cf2e654e1bba1e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:32 2013 -0700

    staging: comedi: dt282x: use dev->write_subdev
    
    Use the dev->write_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5815fc289299..ae714a526c35 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -306,10 +306,10 @@ static void dt282x_munge(struct comedi_device *dev, unsigned short *buf,
 static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->write_subdev;
 	void *ptr;
 	int size;
 	int i;
-	struct comedi_subdevice *s = &dev->subdevices[1];
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
@@ -449,7 +449,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	struct dt282x_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_subdevice *s_ao;
+	struct comedi_subdevice *s_ao = dev->write_subdev;
 	unsigned int supcsr, adcsr, dacsr;
 	int handled = 0;
 
@@ -458,7 +458,6 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	s_ao = &dev->subdevices[1];
 	adcsr = inw(dev->iobase + DT2821_ADCSR);
 	dacsr = inw(dev->iobase + DT2821_DACSR);
 	supcsr = inw(dev->iobase + DT2821_SUPCSR);

commit 9ee0de0ec1196df99c9d6ecec6a25ee383de6bc1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Dec 5 13:43:31 2013 -0700

    staging: comedi: dt282x: use dev->read_subdev
    
    Use the dev->read_subdev that was setup in the device attach instead
    of accessing the dev->subdevices array directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index df37d185125f..5815fc289299 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -339,11 +339,11 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
+	struct comedi_subdevice *s = dev->read_subdev;
 	void *ptr;
 	int size;
 	int i;
 	int ret;
-	struct comedi_subdevice *s = &dev->subdevices[0];
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
@@ -448,7 +448,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct dt282x_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
+	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_subdevice *s_ao;
 	unsigned int supcsr, adcsr, dacsr;
 	int handled = 0;
@@ -458,7 +458,6 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	s = &dev->subdevices[0];
 	s_ao = &dev->subdevices[1];
 	adcsr = inw(dev->iobase + DT2821_ADCSR);
 	dacsr = inw(dev->iobase + DT2821_DACSR);

commit 54bb2637645819302b0ca5b36ecb1391f684e87d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:07 2013 -0700

    staging: comedi: dt282x: remove commented out printk
    
    This printk is just added noise. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index a850e1d16aee..df37d185125f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -511,8 +511,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	}
 #endif
 	comedi_event(dev, s);
-	/* printk("adcsr=0x%02x dacsr-0x%02x supcsr=0x%02x\n",
-		adcsr, dacsr, supcsr); */
+
 	return IRQ_RETVAL(handled);
 }
 

commit 50dbda4a9e3573a22b00bb8e7f179d0f75c641e6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:06 2013 -0700

    staging: comedi: dt282x: convert dt282x_ao_inttrig() messages
    
    Convert the messages in this function to dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index c8df18ae4084..a850e1d16aee 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -885,7 +885,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
 					  devpriv->dma_maxsize);
 	if (size == 0) {
-		printk(KERN_ERR "dt282x: AO underrun\n");
+		dev_err(dev->class_dev, "AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 0, size);
@@ -893,7 +893,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
 					  devpriv->dma_maxsize);
 	if (size == 0) {
-		printk(KERN_ERR "dt282x: AO underrun\n");
+		dev_err(dev->class_dev, "AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 1, size);

commit e0bee2de37da868c858891dd1c5e2fd93ec15297
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:05 2013 -0700

    staging: comedi: dt282x: convert dt282x_ai_dma_interrupt() messages
    
    Convert the messages in this function to dev_{level}().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 822ce0259b03..c8df18ae4084 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -348,7 +348,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
 	if (!s->async->prealloc_buf) {
-		printk(KERN_ERR "async->data disappeared.  dang!\n");
+		dev_err(dev->class_dev, "no buffer in %s\n", __func__);
 		return;
 	}
 
@@ -369,7 +369,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	devpriv->nread -= size / 2;
 
 	if (devpriv->nread < 0) {
-		printk(KERN_INFO "dt282x: off by one\n");
+		dev_info(dev->class_dev, "nread off by one\n");
 		devpriv->nread = 0;
 	}
 	if (!devpriv->nread) {

commit 01112bf1efdec5ee63a8ee31c5b4c6b0331e83f0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:04 2013 -0700

    staging: comedi: dt282x: convert dt282x_ao_dma_interrupt() messages
    
    Convert the messages in this function to dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index b15520baef05..822ce0259b03 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -314,7 +314,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
 	if (!s->async->prealloc_buf) {
-		printk(KERN_ERR "async->data disappeared.  dang!\n");
+		dev_err(dev->class_dev, "no buffer in %s\n", __func__);
 		return;
 	}
 
@@ -327,7 +327,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
-		printk(KERN_ERR "dt282x: AO underrun\n");
+		dev_err(dev->class_dev, "AO underrun\n");
 		dt282x_ao_cancel(dev, s);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;

commit 427f35222e7da82f4ffead939b1586623d92e1c5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:03 2013 -0700

    staging: comedi: dt282x: remove disable code that disables the irq
    
    The code that would disable the irq after getting a number of D/A errors
    is disabled. Just remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 83e9d01839ab..b15520baef05 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -479,13 +479,6 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		handled = 1;
 	}
 	if (dacsr & DT2821_DAERR) {
-#if 0
-		static int warn = 5;
-		if (--warn <= 0) {
-			disable_irq(dev->irq);
-			printk(KERN_INFO "disabling irq\n");
-		}
-#endif
 		comedi_error(dev, "D/A error");
 		dt282x_ao_cancel(dev, s_ao);
 		s->async->events |= COMEDI_CB_ERROR;

commit d3ea1818f36991de1aaf8cc1958768a060a46cde
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:02 2013 -0700

    staging: comedi: dt282x: remove unnecessary blank line message
    
    This blank line message is not needed. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2e8d777d7bc1..83e9d01839ab 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1221,8 +1221,6 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = 1;
 	s->range_table = &range_digital;
 
-	printk(KERN_INFO "\n");
-
 	return 0;
 }
 

commit 753b53d9b169043c6d2c30f7f990c2e4f7b23b14
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:01 2013 -0700

    staging: comedi: dt282x: convert printk() in dt282x_attach to a dev_err()
    
    Convert this printk message into a dev_err().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 7de9c4429920..2e8d777d7bc1 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1133,7 +1133,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	     != DT2821_SUPCSR_VAL) ||
 	    ((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
 	     != DT2821_TMRCTR_VAL)) {
-		printk(KERN_ERR " board not found");
+		dev_err(dev->class_dev, "board not found\n");
 		return -EIO;
 	}
 	/* should do board test */

commit ab49581acebd6926842d261a74693e70564afe54
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:42:00 2013 -0700

    staging: comedi: dt282x: remove attach noise in dt282x_grab_dma()
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index d2f95bf94f44..7de9c4429920 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1060,10 +1060,8 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 
 	devpriv->usedma = 0;
 
-	if (!dma1 && !dma2) {
-		printk(KERN_ERR " (no dma)");
+	if (!dma1 && !dma2)
 		return 0;
-	}
 
 	if (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)
 		return -EINVAL;
@@ -1088,12 +1086,8 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 	devpriv->dma_maxsize = PAGE_SIZE;
 	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
 	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {
-		printk(KERN_ERR " can't get DMA memory");
+	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf)
 		return -ENOMEM;
-	}
-
-	printk(KERN_INFO " (dma=%d,%d)", dma1, dma2);
 
 	devpriv->usedma = 1;
 

commit 06551fda7e0f07250884c0cf47d1286da0a5651c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Nov 26 16:41:59 2013 -0700

    staging: comedi: dt282x: tidy up the irq support in dt282x_attach()
    
    An irq is only needed by this driver in order to support async commands.
    Since it is optional, modify the attach so that if the request_irq() fails
    the attach does not fail.
    
    Remove the printk noise about the irq.
    
    Only hookup the async command support if the request_irq() was successful.
    
    Also, only call dt282x_grab_dma() if we have an irq since interrupt support
    is needed to support dma.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index c4ffedbdde21..d2f95bf94f44 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1118,9 +1118,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv;
-	int i, irq;
-	int ret;
 	struct comedi_subdevice *s;
+	int ret;
+	int i;
 
 	ret = comedi_request_region(dev, it->options[0], DT2821_SIZE);
 	if (ret)
@@ -1144,53 +1144,23 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	/* should do board test */
 
-	irq = it->options[opt_irq];
-#if 0
-	if (irq < 0) {
-		unsigned long flags;
-		int irqs;
-
-		save_flags(flags);
-		sti();
-		irqs = probe_irq_on();
-
-		/* trigger interrupt */
-
-		udelay(100);
-
-		irq = probe_irq_off(irqs);
-		restore_flags(flags);
-		if (0 /* error */)
-			printk(KERN_ERR " error probing irq (bad)");
-	}
-#endif
-	if (irq > 0) {
-		printk(KERN_INFO " ( irq = %d )", irq);
-		ret = request_irq(irq, dt282x_interrupt, 0,
+	if (it->options[opt_irq] > 0) {
+		ret = request_irq(it->options[opt_irq], dt282x_interrupt, 0,
 				  dev->board_name, dev);
-		if (ret < 0) {
-			printk(KERN_ERR " failed to get irq\n");
-			return -EIO;
-		}
-		dev->irq = irq;
-	} else if (irq == 0) {
-		printk(KERN_INFO " (no irq)");
-	} else {
-#if 0
-		printk(KERN_INFO " (probe returned multiple irqs--bad)");
-#else
-		printk(KERN_INFO " (irq probe not implemented)");
-#endif
+		if (ret == 0)
+			dev->irq = it->options[opt_irq];
 	}
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
 
-	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
-			      it->options[opt_dma2]);
-	if (ret < 0)
-		return ret;
+	if (dev->irq) {
+		ret = dt282x_grab_dma(dev, it->options[opt_dma1],
+				      it->options[opt_dma2]);
+		if (ret < 0)
+			return ret;
+	}
 
 	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret)
@@ -1198,22 +1168,25 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	s = &dev->subdevices[0];
 
-	dev->read_subdev = s;
 	/* ai subdevice */
 	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_CMD_READ |
+	s->subdev_flags = SDF_READABLE |
 	    ((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
 	s->n_chan =
 	    (it->options[opt_diff]) ? board->adchan_di : board->adchan_se;
 	s->insn_read = dt282x_ai_insn_read;
-	s->do_cmdtest = dt282x_ai_cmdtest;
-	s->do_cmd = dt282x_ai_cmd;
-	s->cancel = dt282x_ai_cancel;
 	s->maxdata = (1 << board->adbits) - 1;
-	s->len_chanlist = 16;
 	s->range_table =
 	    opt_ai_range_lkup(board->ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags |= SDF_CMD_READ;
+		s->len_chanlist = 16;
+		s->do_cmdtest = dt282x_ai_cmdtest;
+		s->do_cmd = dt282x_ai_cmd;
+		s->cancel = dt282x_ai_cancel;
+	}
 
 	s = &dev->subdevices[1];
 
@@ -1221,15 +1194,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (s->n_chan) {
 		/* ao subsystem */
 		s->type = COMEDI_SUBD_AO;
-		dev->write_subdev = s;
-		s->subdev_flags = SDF_WRITABLE | SDF_CMD_WRITE;
+		s->subdev_flags = SDF_WRITABLE;
 		s->insn_read = dt282x_ao_insn_read;
 		s->insn_write = dt282x_ao_insn_write;
-		s->do_cmdtest = dt282x_ao_cmdtest;
-		s->do_cmd = dt282x_ao_cmd;
-		s->cancel = dt282x_ao_cancel;
 		s->maxdata = (1 << board->dabits) - 1;
-		s->len_chanlist = 2;
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] =
 		    opt_ao_range_lkup(it->options[opt_ao0_range]);
@@ -1237,6 +1205,14 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		    opt_ao_range_lkup(it->options[opt_ao1_range]);
 		devpriv->da0_2scomp = it->options[opt_ao0_twos];
 		devpriv->da1_2scomp = it->options[opt_ao1_twos];
+		if (dev->irq) {
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->len_chanlist = 2;
+			s->do_cmdtest = dt282x_ao_cmdtest;
+			s->do_cmd = dt282x_ao_cmd;
+			s->cancel = dt282x_ao_cancel;
+		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;
 	}

commit 84f3da09858c821d008d6efd5190565f7e8048c5
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 22 10:42:34 2013 -0700

    staging: comedi: dt282x: remove DEBUG define
    
    This define is only used to enable a debug message during the board attach.
    The message is just added noise, remove it as well as the DEBUG define.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index a01e6b553887..c4ffedbdde21 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -63,8 +63,6 @@ Configuration options:
 
 #include "comedi_fc.h"
 
-#define DEBUG
-
 #define DT2821_TIMEOUT		100	/* 500 us */
 #define DT2821_SIZE 0x10
 
@@ -1130,14 +1128,6 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
 	i = inw(dev->iobase + DT2821_ADCSR);
-#ifdef DEBUG
-	printk(KERN_DEBUG " fingerprint=%x,%x,%x,%x,%x",
-	       inw(dev->iobase + DT2821_ADCSR),
-	       inw(dev->iobase + DT2821_CHANCSR),
-	       inw(dev->iobase + DT2821_DACSR),
-	       inw(dev->iobase + DT2821_SUPCSR),
-	       inw(dev->iobase + DT2821_TMRCTR));
-#endif
 
 	if (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)
 	     != DT2821_ADCSR_VAL) ||

commit 766b1f95cf3ce6a70fa25978591f3fcf5de0d51c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:19 2013 +0100

    staging: comedi: dt282x: sample types are unsigned
    
    Sample values in comedi are generally represented as unsigned values.
    Change various members of `struct dt282x_private` and various parameters
    and variables dealing with samples to use `unsigned short` instead of
    `short` for consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e89126a15e53..a01e6b553887 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -226,7 +226,7 @@ struct dt282x_private {
 
 	const struct comedi_lrange *darangelist[2];
 
-	short ao[2];
+	unsigned short ao[2];
 
 	volatile int dacsr;	/* software copies of registers */
 	volatile int adcsr;
@@ -237,7 +237,7 @@ struct dt282x_private {
 
 	struct {
 		int chan;
-		short *buf;	/* DMA buffer */
+		unsigned short *buf;	/* DMA buffer */
 		volatile int size;	/* size of current transfer */
 	} dma[2];
 	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
@@ -283,7 +283,7 @@ static void dt282x_disable_dma(struct comedi_device *dev);
 
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 
-static void dt282x_munge(struct comedi_device *dev, short *buf,
+static void dt282x_munge(struct comedi_device *dev, unsigned short *buf,
 			 unsigned int nbytes)
 {
 	const struct dt282x_board *board = comedi_board(dev);
@@ -496,9 +496,9 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 #if 0
 	if (adcsr & DT2821_ADDONE) {
 		int ret;
-		short data;
+		unsigned short data;
 
-		data = (short)inw(dev->iobase + DT2821_ADDAT);
+		data = inw(dev->iobase + DT2821_ADDAT);
 		data &= (1 << board->adbits) - 1;
 
 		if (devpriv->ad_2scomp)
@@ -796,7 +796,7 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 {
 	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
-	short d;
+	unsigned short d;
 	unsigned int chan;
 
 	chan = CR_CHAN(insn->chanspec);

commit 97f4289ad08cffe55de06d4ac4f89ac540450aee
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 30 11:05:58 2013 -0700

    staging: comedi: drivers: use comedi_dio_update_state() for simple cases
    
    Use comedi_dio_update_state() to handle the boilerplate code to update
    the subdevice s->state for simple cases where the hardware is updated
    when any channel is modified.
    
    Also, fix a bug in the amplc_pc263 and amplc_pci263 drivers where the
    current state is not returned in data[1].
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index da3ee859bdbc..e89126a15e53 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -967,14 +967,12 @@ static int dt282x_ao_cancel(struct comedi_device *dev,
 
 static int dt282x_dio_insn_bits(struct comedi_device *dev,
 				struct comedi_subdevice *s,
-				struct comedi_insn *insn, unsigned int *data)
+				struct comedi_insn *insn,
+				unsigned int *data)
 {
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
-
+	if (comedi_dio_update_state(s, data))
 		outw(s->state, dev->iobase + DT2821_DIODAT);
-	}
+
 	data[1] = inw(dev->iobase + DT2821_DIODAT);
 
 	return insn->n;

commit 9b3e5aec9b275a6a7bad48f2dc2c2dcfd38a4779
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 26 15:28:51 2013 -0700

    staging: comedi: dt282x: fix dt282x_dio_insn_config()
    
    This is the (*insn_config) function for a DIO subdevice. It should be
    using the data[0] value as the "instruction" to perform on the subdevice.
    
    Use the comedi_dio_insn_config() helper to properly handle instructions.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 4a25382e9b86..da3ee859bdbc 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -982,29 +982,32 @@ static int dt282x_dio_insn_bits(struct comedi_device *dev,
 
 static int dt282x_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
-				  struct comedi_insn *insn, unsigned int *data)
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct dt282x_private *devpriv = dev->private;
-	int mask;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int mask;
+	int ret;
 
-	mask = (CR_CHAN(insn->chanspec) < 8) ? 0x00ff : 0xff00;
-	if (data[0])
-		s->io_bits |= mask;
+	if (chan < 8)
+		mask = 0x00ff;
 	else
-		s->io_bits &= ~mask;
+		mask = 0xff00;
+
+	ret = comedi_dio_insn_config(dev, s, insn, data, mask);
+	if (ret)
+		return ret;
 
+	devpriv->dacsr &= ~(DT2821_LBOE | DT2821_HBOE);
 	if (s->io_bits & 0x00ff)
 		devpriv->dacsr |= DT2821_LBOE;
-	else
-		devpriv->dacsr &= ~DT2821_LBOE;
 	if (s->io_bits & 0xff00)
 		devpriv->dacsr |= DT2821_HBOE;
-	else
-		devpriv->dacsr &= ~DT2821_HBOE;
 
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
 
-	return 1;
+	return insn->n;
 }
 
 static const struct comedi_lrange *const ai_range_table[] = {

commit 2c4283ca7cdcc6605859c836fc536fcd83a4525f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Aug 20 11:57:35 2013 +0300

    staging: comedi: dt282x: dt282x_ai_insn_read() always fails
    
    In dt282x_ai_insn_read() we call this macro like:
    wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
    Because the if statement doesn't have curly braces it means we always
    return -ETIME and the function never succeeds.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Ian Abbott <abbotti@mev.co.uk>
    Cc: stable <stable@vger.kernel.org> # 2.6.36+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 23cb033559b3..4a25382e9b86 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -267,8 +267,9 @@ struct dt282x_private {
 			}					\
 			udelay(5);				\
 		}						\
-		if (_i)						\
+		if (_i) {					\
 			b					\
+		}						\
 	} while (0)
 
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);

commit 8e6b7915a1da703617dca28c33e150141fcec9b0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:05:07 2013 -0700

    staging: comedi: drivers do not need <linux/ioport.h>
    
    All the ioport resources are managed by the comedi core. None of
    the drivers depend on <linux/ioport.h>. Remove the includes.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6d3553c8a24d..23cb033559b3 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -56,7 +56,6 @@ Configuration options:
 
 #include <linux/delay.h>
 #include <linux/gfp.h>
-#include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3d1ae5f3fa5f..6d3553c8a24d 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -51,13 +51,17 @@ Configuration options:
     be fixed to check for this situation and return an error.
 */
 
+#include <linux/module.h>
 #include "../comedidev.h"
 
+#include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+
 #include <asm/dma.h>
+
 #include "comedi_fc.h"
 
 #define DEBUG

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index c1950e3b19a2..3d1ae5f3fa5f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1188,10 +1188,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	}
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
 			      it->options[opt_dma2]);

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 90f2de9bc402..c1950e3b19a2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -14,11 +14,6 @@
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
  */
 /*
 Driver: dt282x

commit 3d1fe3f785c80e17f62acf8f92570ae9210bd588
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:37 2013 -0700

    staging: comedi: drivers: free_irq() in comedi_legacy_detach()
    
    All the legacy comedi drivers now call comedi_legacy_detach()
    either directly or as part of their (*detach). Move the free_irq()
    into comedi_legacy_detach() so that the drivers don't have to
    deal with it.
    
    For drivers that then only call comedi_legacy_detach() in their
    private (*detach), remove the private function and use the helper
    directly for the (*detach).
    
    The amplc_pc236 and ni_labpc drivers are hybrid legacy/PCI drivers.
    In the detach of a PCI board free_irq() still needs to be handled
    by the driver.
    
    The pcl724 and pcl726 drivers currently have the free_irq() #ifdef'ed
    out. The comedi_legacy_detach() function sanity checks that the irq
    has been requested before freeing it so they are safe to convert.
    
    For aesthetic reasons, move the #ifdef unused chunk in the pcl816
    driver up to the previous #ifdef unused block.
    
    The pcmio and pcmuio drivers request multiple irqs and handle the
    freeing of them. Remove the 'dev->irq = irq[0]' in those drivers
    so that comedi_legacy_detach() does not attempt to free the irq.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6badbd404e46..90f2de9bc402 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1271,8 +1271,6 @@ static void dt282x_detach(struct comedi_device *dev)
 {
 	struct dt282x_private *devpriv = dev->private;
 
-	if (dev->irq)
-		free_irq(dev->irq, dev);
 	if (dev->private) {
 		if (devpriv->dma[0].chan)
 			free_dma(devpriv->dma[0].chan);

commit a32c6d0084992d3e58a93120c9ce9527e80c651e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:34:19 2013 -0700

    staging: comedi: drivers: use comedi_legacy_detach()
    
    Use comedi_legacy_detach() to release the I/O region requested
    by these drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 06610453ef63..6badbd404e46 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1273,8 +1273,6 @@ static void dt282x_detach(struct comedi_device *dev)
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->iobase)
-		release_region(dev->iobase, DT2821_SIZE);
 	if (dev->private) {
 		if (devpriv->dma[0].chan)
 			free_dma(devpriv->dma[0].chan);
@@ -1285,6 +1283,7 @@ static void dt282x_detach(struct comedi_device *dev)
 		if (devpriv->dma[1].buf)
 			free_page((unsigned long)devpriv->dma[1].buf);
 	}
+	comedi_legacy_detach(dev);
 }
 
 static const struct dt282x_board boardtypes[] = {

commit 364e3a87f5759969cc287200c1cb5ba6151b5ba2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:20:07 2013 -0700

    staging: comedi: dt282x: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the default iobase address (0x240) that is used when the user
    does not pass a base address during the "comedi_config". Comedi
    legacy drivers should only attach to a specified address.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 19f0b999704f..06610453ef63 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1123,18 +1123,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int i, irq;
 	int ret;
 	struct comedi_subdevice *s;
-	unsigned long iobase;
 
-	iobase = it->options[opt_iobase];
-	if (!iobase)
-		iobase = 0x240;
-
-	printk(KERN_INFO "comedi%d: dt282x: 0x%04lx", dev->minor, iobase);
-	if (!request_region(iobase, DT2821_SIZE, dev->board_name)) {
-		printk(KERN_INFO " I/O port conflict\n");
-		return -EBUSY;
-	}
-	dev->iobase = iobase;
+	ret = comedi_request_region(dev, it->options[0], DT2821_SIZE);
+	if (ret)
+		return ret;
 
 	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
 	i = inw(dev->iobase + DT2821_ADCSR);

commit 25829c646e11dda92a5b3628b21fe852681fec44
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:19:44 2013 -0700

    staging: comedi: dt282x: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name and use it
    when requesting the resources instead of the open-coded strings.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 821e948839ad..19f0b999704f 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1125,14 +1125,12 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned long iobase;
 
-	dev->board_name = board->name;
-
 	iobase = it->options[opt_iobase];
 	if (!iobase)
 		iobase = 0x240;
 
 	printk(KERN_INFO "comedi%d: dt282x: 0x%04lx", dev->minor, iobase);
-	if (!request_region(iobase, DT2821_SIZE, "dt282x")) {
+	if (!request_region(iobase, DT2821_SIZE, dev->board_name)) {
 		printk(KERN_INFO " I/O port conflict\n");
 		return -EBUSY;
 	}
@@ -1186,7 +1184,8 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	if (irq > 0) {
 		printk(KERN_INFO " ( irq = %d )", irq);
-		ret = request_irq(irq, dt282x_interrupt, 0, "dt282x", dev);
+		ret = request_irq(irq, dt282x_interrupt, 0,
+				  dev->board_name, dev);
 		if (ret < 0) {
 			printk(KERN_ERR " failed to get irq\n");
 			return -EIO;

commit a56ec2fe6657984f84e419355e6451460ffb44ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Apr 5 17:36:22 2013 -0700

    staging: comedi: dt282x: remove 'boardtype' macro
    
    The 'boardtype' macro relies on a local variable having a specific
    name and yields a struct derived from that local variable.
    
    Replace the macro with local variables and use the comedi_board()
    helper to get the struct as a pointer. Use pointer access when
    using the variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 122d980a95a0..821e948839ad 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -248,8 +248,6 @@ struct dt282x_private {
 	int dma_dir;
 };
 
-#define boardtype (*(const struct dt282x_board *)dev->board_ptr)
-
 /*
  *    Some useless abstractions
  */
@@ -289,14 +287,15 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 static void dt282x_munge(struct comedi_device *dev, short *buf,
 			 unsigned int nbytes)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
 	unsigned int i;
-	unsigned short mask = (1 << boardtype.adbits) - 1;
-	unsigned short sign = 1 << (boardtype.adbits - 1);
+	unsigned short mask = (1 << board->adbits) - 1;
+	unsigned short sign = 1 << (board->adbits - 1);
 	int n;
 
 	if (devpriv->ad_2scomp)
-		sign = 1 << (boardtype.adbits - 1);
+		sign = 1 << (board->adbits - 1);
 	else
 		sign = 0;
 
@@ -501,10 +500,10 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		short data;
 
 		data = (short)inw(dev->iobase + DT2821_ADDAT);
-		data &= (1 << boardtype.adbits) - 1;
+		data &= (1 << board->adbits) - 1;
 
 		if (devpriv->ad_2scomp)
-			data ^= 1 << (boardtype.adbits - 1);
+			data ^= 1 << (board->adbits - 1);
 		ret = comedi_buf_put(s->async, data);
 
 		if (ret == 0)
@@ -554,6 +553,7 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
 	int i;
 
@@ -574,9 +574,9 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 
 		data[i] =
 		    inw(dev->iobase +
-			DT2821_ADDAT) & ((1 << boardtype.adbits) - 1);
+			DT2821_ADDAT) & ((1 << board->adbits) - 1);
 		if (devpriv->ad_2scomp)
-			data[i] ^= (1 << (boardtype.adbits - 1));
+			data[i] ^= (1 << (board->adbits - 1));
 	}
 
 	return i;
@@ -795,13 +795,14 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	struct dt282x_private *devpriv = dev->private;
 	short d;
 	unsigned int chan;
 
 	chan = CR_CHAN(insn->chanspec);
 	d = data[0];
-	d &= (1 << boardtype.dabits) - 1;
+	d &= (1 << board->dabits) - 1;
 	devpriv->ao[chan] = d;
 
 	devpriv->dacsr |= DT2821_SSEL;
@@ -810,11 +811,11 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 		/* select channel */
 		devpriv->dacsr |= DT2821_YSEL;
 		if (devpriv->da0_2scomp)
-			d ^= (1 << (boardtype.dabits - 1));
+			d ^= (1 << (board->dabits - 1));
 	} else {
 		devpriv->dacsr &= ~DT2821_YSEL;
 		if (devpriv->da1_2scomp)
-			d ^= (1 << (boardtype.dabits - 1));
+			d ^= (1 << (board->dabits - 1));
 	}
 
 	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
@@ -1223,20 +1224,20 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->subdev_flags = SDF_READABLE | SDF_CMD_READ |
 	    ((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
 	s->n_chan =
-	    (it->options[opt_diff]) ? boardtype.adchan_di : boardtype.adchan_se;
+	    (it->options[opt_diff]) ? board->adchan_di : board->adchan_se;
 	s->insn_read = dt282x_ai_insn_read;
 	s->do_cmdtest = dt282x_ai_cmdtest;
 	s->do_cmd = dt282x_ai_cmd;
 	s->cancel = dt282x_ai_cancel;
-	s->maxdata = (1 << boardtype.adbits) - 1;
+	s->maxdata = (1 << board->adbits) - 1;
 	s->len_chanlist = 16;
 	s->range_table =
-	    opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
+	    opt_ai_range_lkup(board->ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
 	s = &dev->subdevices[1];
 
-	s->n_chan = boardtype.dachan;
+	s->n_chan = board->dachan;
 	if (s->n_chan) {
 		/* ao subsystem */
 		s->type = COMEDI_SUBD_AO;
@@ -1247,7 +1248,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->do_cmdtest = dt282x_ao_cmdtest;
 		s->do_cmd = dt282x_ao_cmd;
 		s->cancel = dt282x_ao_cancel;
-		s->maxdata = (1 << boardtype.dabits) - 1;
+		s->maxdata = (1 << board->dabits) - 1;
 		s->len_chanlist = 2;
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] =

commit 61e55b88fd19331e33fb09e6b423ac0975aaa26d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:55:27 2012 -0700

    staging: comedi: dt282x: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of dt282x_{ai,ao}_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9746294efc94..122d980a95a0 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -611,52 +611,30 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		/* internal trigger */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	} else {
 		/* external trigger */
 		/* should be level/edge, hi/lo specification here */
-		if (cmd->scan_begin_arg != 0) {
-			cmd->scan_begin_arg = 0;
-			err++;
-		}
-	}
-	if (cmd->convert_arg < 4000) {
-		/* XXX board dependent */
-		cmd->convert_arg = 4000;
-		err++;
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
 	}
+
+	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, 4000);
+
 #define SLOWEST_TIMER	(250*(1<<15)*255)
-	if (cmd->convert_arg > SLOWEST_TIMER) {
-		cmd->convert_arg = SLOWEST_TIMER;
-		err++;
-	}
-	if (cmd->convert_arg < board->ai_speed) {
-		cmd->convert_arg = board->ai_speed;
-		err++;
-	}
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);
+	err |= cfc_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+	} else {	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)
@@ -874,33 +852,17 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
+
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_max(&cmd->scan_end_arg, 2);
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-	if (cmd->scan_begin_arg < 5000 /* XXX unknown */) {
-		cmd->scan_begin_arg = 5000;
-		err++;
-	}
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-	if (cmd->scan_end_arg > 2) {
-		/* XXX chanlist stuff? */
-		cmd->scan_end_arg = 2;
-		err++;
-	}
 	if (cmd->stop_src == TRIG_COUNT) {
 		/* any count is allowed */
-	} else {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+	} else {	/* TRIG_NONE */
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 	}
 
 	if (err)

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f25246833213..9746294efc94 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1239,10 +1239,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	}
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
 			      it->options[opt_dma2]);

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 78d340716d1e..f25246833213 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -248,7 +248,6 @@ struct dt282x_private {
 	int dma_dir;
 };
 
-#define devpriv ((struct dt282x_private *)dev->private)
 #define boardtype (*(const struct dt282x_board *)dev->board_ptr)
 
 /*
@@ -290,6 +289,7 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 static void dt282x_munge(struct comedi_device *dev, short *buf,
 			 unsigned int nbytes)
 {
+	struct dt282x_private *devpriv = dev->private;
 	unsigned int i;
 	unsigned short mask = (1 << boardtype.adbits) - 1;
 	unsigned short sign = 1 << (boardtype.adbits - 1);
@@ -309,6 +309,7 @@ static void dt282x_munge(struct comedi_device *dev, short *buf,
 
 static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 {
+	struct dt282x_private *devpriv = dev->private;
 	void *ptr;
 	int size;
 	int i;
@@ -341,6 +342,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 
 static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 {
+	struct dt282x_private *devpriv = dev->private;
 	void *ptr;
 	int size;
 	int i;
@@ -393,6 +395,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 
 static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int dma_chan;
 	unsigned long dma_ptr;
 	unsigned long flags;
@@ -424,6 +427,7 @@ static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 
 static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int dma_chan;
 	unsigned long dma_ptr;
 	unsigned long flags;
@@ -447,6 +451,7 @@ static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 static irqreturn_t dt282x_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct dt282x_private *devpriv = dev->private;
 	struct comedi_subdevice *s;
 	struct comedi_subdevice *s_ao;
 	unsigned int supcsr, adcsr, dacsr;
@@ -525,6 +530,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 static void dt282x_load_changain(struct comedi_device *dev, int n,
 				 unsigned int *chanlist)
 {
+	struct dt282x_private *devpriv = dev->private;
 	unsigned int i;
 	unsigned int chan, range;
 
@@ -548,6 +554,7 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int i;
 
 	/* XXX should we really be enabling the ad clock here? */
@@ -671,6 +678,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	const struct dt282x_board *board = comedi_board(dev);
+	struct dt282x_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
 
@@ -733,6 +741,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 static void dt282x_disable_dma(struct comedi_device *dev)
 {
+	struct dt282x_private *devpriv = dev->private;
+
 	if (devpriv->usedma) {
 		disable_dma(devpriv->dma[0].chan);
 		disable_dma(devpriv->dma[1].chan);
@@ -742,6 +752,8 @@ static void dt282x_disable_dma(struct comedi_device *dev)
 static int dt282x_ai_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct dt282x_private *devpriv = dev->private;
+
 	dt282x_disable_dma(dev);
 
 	devpriv->adcsr = 0;
@@ -794,6 +806,8 @@ static int dt282x_ao_insn_read(struct comedi_device *dev,
 			       struct comedi_subdevice *s,
 			       struct comedi_insn *insn, unsigned int *data)
 {
+	struct dt282x_private *devpriv = dev->private;
+
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -803,6 +817,7 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_insn *insn, unsigned int *data)
 {
+	struct dt282x_private *devpriv = dev->private;
 	short d;
 	unsigned int chan;
 
@@ -908,6 +923,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 static int dt282x_ao_inttrig(struct comedi_device *dev,
 			     struct comedi_subdevice *s, unsigned int x)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int size;
 
 	if (x != 0)
@@ -937,6 +953,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 
 static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int timer;
 	struct comedi_cmd *cmd = &s->async->cmd;
 
@@ -973,6 +990,8 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 static int dt282x_ao_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct dt282x_private *devpriv = dev->private;
+
 	dt282x_disable_dma(dev);
 
 	devpriv->dacsr = 0;
@@ -1003,6 +1022,7 @@ static int dt282x_dio_insn_config(struct comedi_device *dev,
 				  struct comedi_subdevice *s,
 				  struct comedi_insn *insn, unsigned int *data)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int mask;
 
 	mask = (CR_CHAN(insn->chanspec) < 8) ? 0x00ff : 0xff00;
@@ -1074,6 +1094,7 @@ enum {  /* i/o base, irq, dma channels */
 
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 {
+	struct dt282x_private *devpriv = dev->private;
 	int ret;
 
 	devpriv->usedma = 0;
@@ -1135,6 +1156,7 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dt282x_board *board = comedi_board(dev);
+	struct dt282x_private *devpriv;
 	int i, irq;
 	int ret;
 	struct comedi_subdevice *s;
@@ -1217,9 +1239,10 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	}
 
-	ret = alloc_private(dev, sizeof(struct dt282x_private));
-	if (ret < 0)
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
+	devpriv = dev->private;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
 			      it->options[opt_dma2]);
@@ -1292,6 +1315,8 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void dt282x_detach(struct comedi_device *dev)
 {
+	struct dt282x_private *devpriv = dev->private;
+
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->iobase)

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index b7c43c84d949..78d340716d1e 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -582,47 +582,24 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_FOLLOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique
-	 * and mutually compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;
@@ -862,44 +839,22 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/*
-	 * step 2: make sure trigger sources are unique
-	 * and mutually compatible
-	 */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* note that mutual compatibility is not an issue here */
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit e1d7cf9c9dd7e08390d836e9f9c8b4851c0b1df0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:41:08 2012 -0700

    staging: comedi: dt282x: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 1f0b40e4bddd..b7c43c84d949 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -312,7 +312,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 	void *ptr;
 	int size;
 	int i;
-	struct comedi_subdevice *s = dev->subdevices + 1;
+	struct comedi_subdevice *s = &dev->subdevices[1];
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
@@ -345,7 +345,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	int size;
 	int i;
 	int ret;
-	struct comedi_subdevice *s = dev->subdevices;
+	struct comedi_subdevice *s = &dev->subdevices[0];
 
 	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
@@ -457,8 +457,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 
-	s = dev->subdevices + 0;
-	s_ao = dev->subdevices + 1;
+	s = &dev->subdevices[0];
+	s_ao = &dev->subdevices[1];
 	adcsr = inw(dev->iobase + DT2821_ADCSR);
 	dacsr = inw(dev->iobase + DT2821_DACSR);
 	supcsr = inw(dev->iobase + DT2821_SUPCSR);
@@ -1275,7 +1275,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 
 	dev->read_subdev = s;
 	/* ai subdevice */
@@ -1294,7 +1294,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	    opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
-	s++;
+	s = &dev->subdevices[1];
 
 	s->n_chan = boardtype.dachan;
 	if (s->n_chan) {
@@ -1320,7 +1320,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	s++;
+	s = &dev->subdevices[2];
 	/* dio subsystem */
 	s->type = COMEDI_SUBD_DIO;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;

commit d254eb7418e389e063831d8d77b7dac240288f02
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Jul 12 17:46:37 2012 -0700

    staging: comedi: dt282x: remove the outw wrapper macros
    
    The macros 'update_dacsr', 'update_adcsr', and 'update_supcsr' all use
    the 'devpriv' macro which uses a local variable of a specific name and
    yeilds a pointer derived from that name. They are also just wrappers
    around simple 'outw' calls. Remove the macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 4af33431c380..1f0b40e4bddd 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -255,11 +255,8 @@ struct dt282x_private {
  *    Some useless abstractions
  */
 #define chan_to_DAC(a)	((a)&1)
-#define update_dacsr(a)	outw(devpriv->dacsr|(a), dev->iobase+DT2821_DACSR)
-#define update_adcsr(a)	outw(devpriv->adcsr|(a), dev->iobase+DT2821_ADCSR)
 #define mux_busy() (inw(dev->iobase+DT2821_ADCSR)&DT2821_MUXBUSY)
 #define ad_done() (inw(dev->iobase+DT2821_ADCSR)&DT2821_ADDONE)
-#define update_supcsr(a) outw(devpriv->supcsr|(a), dev->iobase+DT2821_SUPCSR)
 
 /*
  *    danger! macro abuse... a is the expression to wait on, and b is
@@ -317,7 +314,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 	int i;
 	struct comedi_subdevice *s = dev->subdevices + 1;
 
-	update_supcsr(DT2821_CLRDMADNE);
+	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
 	if (!s->async->prealloc_buf) {
 		printk(KERN_ERR "async->data disappeared.  dang!\n");
@@ -350,7 +347,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	int ret;
 	struct comedi_subdevice *s = dev->subdevices;
 
-	update_supcsr(DT2821_CLRDMADNE);
+	outw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);
 
 	if (!s->async->prealloc_buf) {
 		printk(KERN_ERR "async->data disappeared.  dang!\n");
@@ -387,7 +384,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	/* XXX probably wrong */
 	if (!devpriv->ntrig) {
 		devpriv->supcsr &= ~(DT2821_DDMA);
-		update_supcsr(0);
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
 	}
 #endif
 	/* restart the channel */
@@ -513,7 +510,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 			s->async->events |= COMEDI_CB_EOA;
 		} else {
 			if (supcsr & DT2821_SCDN)
-				update_supcsr(DT2821_STRIG);
+				outw(devpriv->supcsr | DT2821_STRIG,
+					dev->iobase + DT2821_SUPCSR);
 		}
 		handled = 1;
 	}
@@ -534,7 +532,8 @@ static void dt282x_load_changain(struct comedi_device *dev, int n,
 	for (i = 0; i < n; i++) {
 		chan = CR_CHAN(chanlist[i]);
 		range = CR_RANGE(chanlist[i]);
-		update_adcsr((range << 4) | (chan));
+		outw(devpriv->adcsr | (range << 4) | chan,
+			dev->iobase + DT2821_ADCSR);
 	}
 	outw(n - 1, dev->iobase + DT2821_CHANCSR);
 }
@@ -553,15 +552,16 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 
 	/* XXX should we really be enabling the ad clock here? */
 	devpriv->adcsr = DT2821_ADCLK;
-	update_adcsr(0);
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
 
 	dt282x_load_changain(dev, 1, &insn->chanspec);
 
-	update_supcsr(DT2821_PRLD);
+	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
 	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	for (i = 0; i < insn->n; i++) {
-		update_supcsr(DT2821_STRIG);
+		outw(devpriv->supcsr | DT2821_STRIG,
+			dev->iobase + DT2821_SUPCSR);
 		wait_for(ad_done(), comedi_error(dev, "timeout\n");
 			 return -ETIME;);
 
@@ -718,7 +718,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		/* external trigger */
 		devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0 | DT2821_DS1;
 	}
-	update_supcsr(DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_ADCINIT);
+	outw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_ADCINIT,
+		dev->iobase + DT2821_SUPCSR);
 
 	devpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;
 	devpriv->nread = devpriv->ntrig;
@@ -729,7 +730,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (devpriv->ntrig) {
 		prep_ai_dma(dev, 1, 0);
 		devpriv->supcsr |= DT2821_DDMA;
-		update_supcsr(0);
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
 	}
 
 	devpriv->adcsr = 0;
@@ -737,16 +738,17 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);
 
 	devpriv->adcsr = DT2821_ADCLK | DT2821_IADDONE;
-	update_adcsr(0);
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
 
-	update_supcsr(DT2821_PRLD);
+	outw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);
 	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
-		update_supcsr(DT2821_STRIG);
+		outw(devpriv->supcsr | DT2821_STRIG,
+			dev->iobase + DT2821_SUPCSR);
 	} else {
 		devpriv->supcsr |= DT2821_XTRIG;
-		update_supcsr(0);
+		outw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);
 	}
 
 	return 0;
@@ -766,10 +768,10 @@ static int dt282x_ai_cancel(struct comedi_device *dev,
 	dt282x_disable_dma(dev);
 
 	devpriv->adcsr = 0;
-	update_adcsr(0);
+	outw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);
 
 	devpriv->supcsr = 0;
-	update_supcsr(DT2821_ADCINIT);
+	outw(devpriv->supcsr | DT2821_ADCINIT, dev->iobase + DT2821_SUPCSR);
 
 	return 0;
 }
@@ -845,11 +847,11 @@ static int dt282x_ao_insn_write(struct comedi_device *dev,
 			d ^= (1 << (boardtype.dabits - 1));
 	}
 
-	update_dacsr(0);
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
 
 	outw(d, dev->iobase + DT2821_DADAT);
 
-	update_supcsr(DT2821_DACON);
+	outw(devpriv->supcsr | DT2821_DACON, dev->iobase + DT2821_SUPCSR);
 
 	return 1;
 }
@@ -972,7 +974,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	}
 	prep_ao_dma(dev, 1, size);
 
-	update_supcsr(DT2821_STRIG);
+	outw(devpriv->supcsr | DT2821_STRIG, dev->iobase + DT2821_SUPCSR);
 	s->async->inttrig = NULL;
 
 	return 1;
@@ -993,7 +995,8 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dt282x_disable_dma(dev);
 
 	devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS1 | DT2821_DDMA;
-	update_supcsr(DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_DACINIT);
+	outw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_DACINIT,
+		dev->iobase + DT2821_SUPCSR);
 
 	devpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;
 	devpriv->nread = devpriv->ntrig;
@@ -1005,7 +1008,7 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	outw(timer, dev->iobase + DT2821_TMRCTR);
 
 	devpriv->dacsr = DT2821_SSEL | DT2821_DACLK | DT2821_IDARDY;
-	update_dacsr(0);
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
 
 	s->async->inttrig = dt282x_ao_inttrig;
 
@@ -1018,10 +1021,10 @@ static int dt282x_ao_cancel(struct comedi_device *dev,
 	dt282x_disable_dma(dev);
 
 	devpriv->dacsr = 0;
-	update_dacsr(0);
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
 
 	devpriv->supcsr = 0;
-	update_supcsr(DT2821_DACINIT);
+	outw(devpriv->supcsr | DT2821_DACINIT, dev->iobase + DT2821_SUPCSR);
 
 	return 0;
 }

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9c0a0df7dff2..4af33431c380 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1038,7 +1038,7 @@ static int dt282x_dio_insn_bits(struct comedi_device *dev,
 	}
 	data[1] = inw(dev->iobase + DT2821_DIODAT);
 
-	return 2;
+	return insn->n;
 }
 
 static int dt282x_dio_insn_config(struct comedi_device *dev,

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f11d1fdfcae2..9c0a0df7dff2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1269,7 +1269,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	ret = comedi_alloc_subdevices(dev, 3);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	s = dev->subdevices + 0;

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index eefda3c064d3..f11d1fdfcae2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1268,7 +1268,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0)
 		return ret;
 
-	ret = alloc_subdevices(dev, 3);
+	ret = comedi_alloc_subdevices(dev, 3);
 	if (ret < 0)
 		return ret;
 

commit 061319698271bc80155cf3a67f0d5afed4024705
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 22 16:33:51 2012 -0700

    staging: comedi: remove this_board macro in the dt282x driver
    
    The 'this_board' macro depends on having a local variable with
    a magic name. The CodingStyle document suggests not doing this
    to avoid confusion. Remove the macro and use the comedi_board()
    inline helper to get the dev->board_ptr information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 736d8facaee8..eefda3c064d3 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -221,8 +221,6 @@ struct dt282x_board {
 	int dabits;
 };
 
-#define this_board ((const struct dt282x_board *)dev->board_ptr)
-
 struct dt282x_private {
 	int ad_2scomp;		/* we have 2's comp jumper set  */
 	int da0_2scomp;		/* same, for DAC0               */
@@ -580,6 +578,7 @@ static int dt282x_ai_insn_read(struct comedi_device *dev,
 static int dt282x_ai_cmdtest(struct comedi_device *dev,
 			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	int err = 0;
 	int tmp;
 
@@ -658,8 +657,8 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 		cmd->convert_arg = SLOWEST_TIMER;
 		err++;
 	}
-	if (cmd->convert_arg < this_board->ai_speed) {
-		cmd->convert_arg = this_board->ai_speed;
+	if (cmd->convert_arg < board->ai_speed) {
+		cmd->convert_arg = board->ai_speed;
 		err++;
 	}
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
@@ -694,6 +693,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
 
@@ -706,8 +706,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	dt282x_disable_dma(dev);
 
-	if (cmd->convert_arg < this_board->ai_speed)
-		cmd->convert_arg = this_board->ai_speed;
+	if (cmd->convert_arg < board->ai_speed)
+		cmd->convert_arg = board->ai_speed;
 	timer = dt282x_ns_to_timer(&cmd->convert_arg, TRIG_ROUND_NEAREST);
 	outw(timer, dev->iobase + DT2821_TMRCTR);
 
@@ -1176,12 +1176,13 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
  */
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct dt282x_board *board = comedi_board(dev);
 	int i, irq;
 	int ret;
 	struct comedi_subdevice *s;
 	unsigned long iobase;
 
-	dev->board_name = this_board->name;
+	dev->board_name = board->name;
 
 	iobase = it->options[opt_iobase];
 	if (!iobase)

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 461a056f21ef..736d8facaee8 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1331,7 +1331,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 0;
 }
 
-static void free_resources(struct comedi_device *dev)
+static void dt282x_detach(struct comedi_device *dev)
 {
 	if (dev->irq)
 		free_irq(dev->irq, dev);
@@ -1349,15 +1349,6 @@ static void free_resources(struct comedi_device *dev)
 	}
 }
 
-static int dt282x_detach(struct comedi_device *dev)
-{
-	printk(KERN_INFO "comedi%d: dt282x: remove\n", dev->minor);
-
-	free_resources(dev);
-
-	return 0;
-}
-
 static const struct dt282x_board boardtypes[] = {
 	{
 		.name		= "dt2821",

commit e0eaa10d4d23e35a2bf6ac4b3dff81ae30b0d7e5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri May 4 17:02:38 2012 -0700

    staging: comedi: refactor dt282x driver to remove forward declarations
    
    Move the struct comedi_driver and variables to the end of the
    source. This is more typical of how other drivers are written and
    removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_driver() macro which
    makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 210b3f0f6f01..461a056f21ef 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -221,135 +221,6 @@ struct dt282x_board {
 	int dabits;
 };
 
-static const struct dt282x_board boardtypes[] = {
-	{.name = "dt2821",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 20000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2821-f",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 6500,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2821-g",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 4000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2823",
-	 .adbits = 16,
-	 .adchan_se = 0,
-	 .adchan_di = 4,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 16,
-	 },
-	{.name = "dt2824-pgh",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 20000,
-	 .ispgl = 0,
-	 .dachan = 0,
-	 .dabits = 0,
-	 },
-	{.name = "dt2824-pgl",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 20000,
-	 .ispgl = 1,
-	 .dachan = 0,
-	 .dabits = 0,
-	 },
-	{.name = "dt2825",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 20000,
-	 .ispgl = 1,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2827",
-	 .adbits = 16,
-	 .adchan_se = 0,
-	 .adchan_di = 4,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2828",
-	 .adbits = 12,
-	 .adchan_se = 4,
-	 .adchan_di = 0,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt2829",
-	 .adbits = 16,
-	 .adchan_se = 8,
-	 .adchan_di = 0,
-	 .ai_speed = 33250,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 16,
-	 },
-	{.name = "dt21-ez",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 2,
-	 .dabits = 12,
-	 },
-	{.name = "dt23-ez",
-	 .adbits = 16,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 0,
-	 .dabits = 0,
-	 },
-	{.name = "dt24-ez",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 10000,
-	 .ispgl = 0,
-	 .dachan = 0,
-	 .dabits = 0,
-	 },
-	{.name = "dt24-ez-pgl",
-	 .adbits = 12,
-	 .adchan_se = 16,
-	 .adchan_di = 8,
-	 .ai_speed = 10000,
-	 .ispgl = 1,
-	 .dachan = 0,
-	 .dabits = 0,
-	 },
-};
-
 #define this_board ((const struct dt282x_board *)dev->board_ptr)
 
 struct dt282x_private {
@@ -410,33 +281,6 @@ struct dt282x_private {
 			b					\
 	} while (0)
 
-static int dt282x_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static int dt282x_detach(struct comedi_device *dev);
-static struct comedi_driver driver_dt282x = {
-	.driver_name = "dt282x",
-	.module = THIS_MODULE,
-	.attach = dt282x_attach,
-	.detach = dt282x_detach,
-	.board_name = &boardtypes[0].name,
-	.num_names = ARRAY_SIZE(boardtypes),
-	.offset = sizeof(struct dt282x_board),
-};
-
-static int __init driver_dt282x_init_module(void)
-{
-	return comedi_driver_register(&driver_dt282x);
-}
-
-static void __exit driver_dt282x_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_dt282x);
-}
-
-module_init(driver_dt282x_init_module);
-module_exit(driver_dt282x_cleanup_module);
-
-static void free_resources(struct comedi_device *dev);
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
 static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
 static int dt282x_ai_cancel(struct comedi_device *dev,
@@ -1270,6 +1114,52 @@ enum {  /* i/o base, irq, dma channels */
 	opt_ai_range, opt_ao0_range, opt_ao1_range,	/* range */
 };
 
+static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
+{
+	int ret;
+
+	devpriv->usedma = 0;
+
+	if (!dma1 && !dma2) {
+		printk(KERN_ERR " (no dma)");
+		return 0;
+	}
+
+	if (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)
+		return -EINVAL;
+
+	if (dma2 < dma1) {
+		int i;
+		i = dma1;
+		dma1 = dma2;
+		dma2 = i;
+	}
+
+	ret = request_dma(dma1, "dt282x A");
+	if (ret)
+		return -EBUSY;
+	devpriv->dma[0].chan = dma1;
+
+	ret = request_dma(dma2, "dt282x B");
+	if (ret)
+		return -EBUSY;
+	devpriv->dma[1].chan = dma2;
+
+	devpriv->dma_maxsize = PAGE_SIZE;
+	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {
+		printk(KERN_ERR " can't get DMA memory");
+		return -ENOMEM;
+	}
+
+	printk(KERN_INFO " (dma=%d,%d)", dma1, dma2);
+
+	devpriv->usedma = 1;
+
+	return 0;
+}
+
 /*
    options:
    0	i/o base
@@ -1468,51 +1358,146 @@ static int dt282x_detach(struct comedi_device *dev)
 	return 0;
 }
 
-static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
-{
-	int ret;
-
-	devpriv->usedma = 0;
-
-	if (!dma1 && !dma2) {
-		printk(KERN_ERR " (no dma)");
-		return 0;
-	}
-
-	if (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)
-		return -EINVAL;
-
-	if (dma2 < dma1) {
-		int i;
-		i = dma1;
-		dma1 = dma2;
-		dma2 = i;
-	}
-
-	ret = request_dma(dma1, "dt282x A");
-	if (ret)
-		return -EBUSY;
-	devpriv->dma[0].chan = dma1;
-
-	ret = request_dma(dma2, "dt282x B");
-	if (ret)
-		return -EBUSY;
-	devpriv->dma[1].chan = dma2;
-
-	devpriv->dma_maxsize = PAGE_SIZE;
-	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
-	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {
-		printk(KERN_ERR " can't get DMA memory");
-		return -ENOMEM;
-	}
-
-	printk(KERN_INFO " (dma=%d,%d)", dma1, dma2);
-
-	devpriv->usedma = 1;
+static const struct dt282x_board boardtypes[] = {
+	{
+		.name		= "dt2821",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2821-f",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 6500,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2821-g",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 4000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2823",
+		.adbits		= 16,
+		.adchan_se	= 0,
+		.adchan_di	= 4,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 16,
+	}, {
+		.name		= "dt2824-pgh",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt2824-pgl",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 1,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt2825",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 20000,
+		.ispgl		= 1,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2827",
+		.adbits		= 16,
+		.adchan_se	= 0,
+		.adchan_di	= 4,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2828",
+		.adbits		= 12,
+		.adchan_se	= 4,
+		.adchan_di	= 0,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt2829",
+		.adbits		= 16,
+		.adchan_se	= 8,
+		.adchan_di	= 0,
+		.ai_speed	= 33250,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 16,
+	}, {
+		.name		= "dt21-ez",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 2,
+		.dabits		= 12,
+	}, {
+		.name		= "dt23-ez",
+		.adbits		= 16,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt24-ez",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 0,
+		.dachan		= 0,
+		.dabits		= 0,
+	}, {
+		.name		= "dt24-ez-pgl",
+		.adbits		= 12,
+		.adchan_se	= 16,
+		.adchan_di	= 8,
+		.ai_speed	= 10000,
+		.ispgl		= 1,
+		.dachan		= 0,
+		.dabits		= 0,
+	},
+};
 
-	return 0;
-}
+static struct comedi_driver dt282x_driver = {
+	.driver_name	= "dt282x",
+	.module		= THIS_MODULE,
+	.attach		= dt282x_attach,
+	.detach		= dt282x_detach,
+	.board_name	= &boardtypes[0].name,
+	.num_names	= ARRAY_SIZE(boardtypes),
+	.offset		= sizeof(struct dt282x_board),
+};
+module_comedi_driver(dt282x_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 542038f4df5a9d5d806a4af8725d2d21c4423a15
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Apr 20 12:05:04 2012 -0700

    staging: comedi: use ARRAY_SIZE instead of custom n_boardtypes macros
    
    The n_boardtypes macros are simply open-coded versions of the kernels
    ARRAY_SIZE macro. Use the kernel provided macro.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 95ebc267bb74..210b3f0f6f01 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -350,7 +350,6 @@ static const struct dt282x_board boardtypes[] = {
 	 },
 };
 
-#define n_boardtypes (sizeof(boardtypes)/sizeof(struct dt282x_board))
 #define this_board ((const struct dt282x_board *)dev->board_ptr)
 
 struct dt282x_private {
@@ -420,7 +419,7 @@ static struct comedi_driver driver_dt282x = {
 	.attach = dt282x_attach,
 	.detach = dt282x_detach,
 	.board_name = &boardtypes[0].name,
-	.num_names = n_boardtypes,
+	.num_names = ARRAY_SIZE(boardtypes),
 	.offset = sizeof(struct dt282x_board),
 };
 

commit 845d131e2b363717d8ac8db2c6b4417de8cf10b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 9 12:20:28 2011 -0700

    Staging: comedi: add #include <linux/io.h> to a bunch of drivers
    
    On some arches the function virt_to_bus() wasn't being pulled in due to
    include chains being different.  So, as we are explicitly calling this
    function, explicitly include the proper header file so all will build
    properly.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 8cea9dca3d7e..95ebc267bb74 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -61,6 +61,7 @@ Configuration options:
 #include <linux/gfp.h>
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 #include "comedi_fc.h"
 

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 58a2fdfcd340..8cea9dca3d7e 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -423,7 +423,18 @@ static struct comedi_driver driver_dt282x = {
 	.offset = sizeof(struct dt282x_board),
 };
 
-COMEDI_INITCLEANUP(driver_dt282x);
+static int __init driver_dt282x_init_module(void)
+{
+	return comedi_driver_register(&driver_dt282x);
+}
+
+static void __exit driver_dt282x_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_dt282x);
+}
+
+module_init(driver_dt282x_init_module);
+module_exit(driver_dt282x_cleanup_module);
 
 static void free_resources(struct comedi_device *dev);
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index fd8728c83669..58a2fdfcd340 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1502,3 +1502,7 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 18e7e78e945527d9cb570a17f0835815f1794c2f
Author: Iain Churcher <iain.linux.coding@googlemail.com>
Date:   Thu Apr 29 19:02:01 2010 +0100

    Staging: comedi: numerous checkpatch.pl issues in dt282x.c
    
    This patch cleans up numerous WARNINGS and ERRORS listed by the
    checkpatch.pl tool
    
    Signed-off-by: Iain Churcher <iain.linux.coding@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index e548763cf2f3..fd8728c83669 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -45,9 +45,9 @@ Configuration options:
   [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
   [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
   [9] - AO 0 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
-        4=[-2.5,2.5]
+	4=[-2.5,2.5]
   [10]- A0 1 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
-        4=[-2.5,2.5]
+	4=[-2.5,2.5]
 
 Notes:
   - AO commands might be broken.
@@ -155,79 +155,58 @@ Configuration options:
 #define DT2821_XCLK	0x0002	/* (R/W) external clock enable            */
 #define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
 
-static const struct comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
-								     RANGE(-10,
-									   10),
-								     RANGE(-5,
-									   5),
-								     RANGE(-2.5,
-									   2.5),
-								     RANGE
-								     (-1.25,
-								      1.25)
-								     }
+static const struct comedi_lrange range_dt282x_ai_lo_bipolar = {
+	4, {
+		RANGE(-10, 10),
+		RANGE(-5, 5),
+		RANGE(-2.5, 2.5),
+		RANGE(-1.25, 1.25)
+	}
 };
 
-static const struct comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
-								      RANGE(0,
-									    10),
-								      RANGE(0,
-									    5),
-								      RANGE(0,
-									    2.5),
-								      RANGE(0,
-									    1.25)
-								      }
+static const struct comedi_lrange range_dt282x_ai_lo_unipolar = {
+	4, {
+		RANGE(0, 10),
+		RANGE(0, 5),
+		RANGE(0, 2.5),
+		RANGE(0, 1.25)
+	}
 };
 
-static const struct comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
-								    RANGE(-5,
-									  5),
-								    RANGE(-2.5,
-									  2.5),
-								    RANGE(-1.25,
-									  1.25),
-								    RANGE
-								    (-0.625,
-								     0.625),
-								    }
+static const struct comedi_lrange range_dt282x_ai_5_bipolar = {
+	4, {
+		RANGE(-5, 5),
+		RANGE(-2.5, 2.5),
+		RANGE(-1.25, 1.25),
+		RANGE(-0.625, 0.625)
+	}
 };
 
-static const struct comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
-								     RANGE(0,
-									   5),
-								     RANGE(0,
-									   2.5),
-								     RANGE(0,
-									   1.25),
-								     RANGE(0,
-									   0.625),
-								     }
+static const struct comedi_lrange range_dt282x_ai_5_unipolar = {
+	4, {
+		RANGE(0, 5),
+		RANGE(0, 2.5),
+		RANGE(0, 1.25),
+		RANGE(0, 0.625),
+	}
 };
 
-static const struct comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
-								     RANGE(-10,
-									   10),
-								     RANGE(-1,
-									   1),
-								     RANGE(-0.1,
-									   0.1),
-								     RANGE
-								     (-0.02,
-								      0.02)
-								     }
+static const struct comedi_lrange range_dt282x_ai_hi_bipolar = {
+	4, {
+		RANGE(-10, 10),
+		RANGE(-1, 1),
+		RANGE(-0.1, 0.1),
+		RANGE(-0.02, 0.02)
+	}
 };
 
-static const struct comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
-								      RANGE(0,
-									    10),
-								      RANGE(0,
-									    1),
-								      RANGE(0,
-									    0.1),
-								      RANGE(0,
-									    0.02)
-								      }
+static const struct comedi_lrange range_dt282x_ai_hi_unipolar = {
+	4, {
+		RANGE(0, 10),
+		RANGE(0, 1),
+		RANGE(0, 0.1),
+		RANGE(0, 0.02)
+	}
 };
 
 struct dt282x_board {
@@ -370,7 +349,7 @@ static const struct dt282x_board boardtypes[] = {
 	 },
 };
 
-#define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
+#define n_boardtypes (sizeof(boardtypes)/sizeof(struct dt282x_board))
 #define this_board ((const struct dt282x_board *)dev->board_ptr)
 
 struct dt282x_private {
@@ -411,21 +390,25 @@ struct dt282x_private {
 #define update_adcsr(a)	outw(devpriv->adcsr|(a), dev->iobase+DT2821_ADCSR)
 #define mux_busy() (inw(dev->iobase+DT2821_ADCSR)&DT2821_MUXBUSY)
 #define ad_done() (inw(dev->iobase+DT2821_ADCSR)&DT2821_ADDONE)
-#define update_supcsr(a)	outw(devpriv->supcsr|(a), dev->iobase+DT2821_SUPCSR)
+#define update_supcsr(a) outw(devpriv->supcsr|(a), dev->iobase+DT2821_SUPCSR)
 
 /*
  *    danger! macro abuse... a is the expression to wait on, and b is
  *      the statement(s) to execute if it doesn't happen.
  */
-#define wait_for(a, b)	 				\
-	do{						\
-		int _i;					\
-		for (_i=0;_i<DT2821_TIMEOUT;_i++){	\
-			if (a){_i=0;break;}		\
-			udelay(5);			\
-		}					\
-		if (_i){b}				\
-	}while (0)
+#define wait_for(a, b)						\
+	do {							\
+		int _i;						\
+		for (_i = 0; _i < DT2821_TIMEOUT; _i++) {	\
+			if (a) {				\
+				_i = 0;				\
+				break;				\
+			}					\
+			udelay(5);				\
+		}						\
+		if (_i)						\
+			b					\
+	} while (0)
 
 static int dt282x_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
@@ -462,18 +445,16 @@ static void dt282x_munge(struct comedi_device *dev, short *buf,
 	unsigned short sign = 1 << (boardtype.adbits - 1);
 	int n;
 
-	if (devpriv->ad_2scomp) {
+	if (devpriv->ad_2scomp)
 		sign = 1 << (boardtype.adbits - 1);
-	} else {
+	else
 		sign = 0;
-	}
 
 	if (nbytes % 2)
 		comedi_error(dev, "bug! odd number of bytes from dma xfer");
 	n = nbytes / 2;
-	for (i = 0; i < n; i++) {
+	for (i = 0; i < n; i++)
 		buf[i] = (buf[i] & mask) ^ sign;
-	}
 }
 
 static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
@@ -486,7 +467,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 	update_supcsr(DT2821_CLRDMADNE);
 
 	if (!s->async->prealloc_buf) {
-		printk("async->data disappeared.  dang!\n");
+		printk(KERN_ERR "async->data disappeared.  dang!\n");
 		return;
 	}
 
@@ -499,7 +480,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
-		printk("dt282x: AO underrun\n");
+		printk(KERN_ERR "dt282x: AO underrun\n");
 		dt282x_ao_cancel(dev, s);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
@@ -519,7 +500,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	update_supcsr(DT2821_CLRDMADNE);
 
 	if (!s->async->prealloc_buf) {
-		printk("async->data disappeared.  dang!\n");
+		printk(KERN_ERR "async->data disappeared.  dang!\n");
 		return;
 	}
 
@@ -540,7 +521,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 	devpriv->nread -= size / 2;
 
 	if (devpriv->nread < 0) {
-		printk("dt282x: off by one\n");
+		printk(KERN_INFO "dt282x: off by one\n");
 		devpriv->nread = 0;
 	}
 	if (!devpriv->nread) {
@@ -651,7 +632,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		static int warn = 5;
 		if (--warn <= 0) {
 			disable_irq(dev->irq);
-			printk("disabling irq\n");
+			printk(KERN_INFO "disabling irq\n");
 		}
 #endif
 		comedi_error(dev, "D/A error");
@@ -666,13 +647,13 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 
 		data = (short)inw(dev->iobase + DT2821_ADDAT);
 		data &= (1 << boardtype.adbits) - 1;
-		if (devpriv->ad_2scomp) {
+
+		if (devpriv->ad_2scomp)
 			data ^= 1 << (boardtype.adbits - 1);
-		}
 		ret = comedi_buf_put(s->async, data);
-		if (ret == 0) {
+
+		if (ret == 0)
 			s->async->events |= COMEDI_CB_OVERFLOW;
-		}
 
 		devpriv->nread--;
 		if (!devpriv->nread) {
@@ -685,7 +666,8 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	}
 #endif
 	comedi_event(dev, s);
-	/* printk("adcsr=0x%02x dacsr-0x%02x supcsr=0x%02x\n", adcsr, dacsr, supcsr); */
+	/* printk("adcsr=0x%02x dacsr-0x%02x supcsr=0x%02x\n",
+		adcsr, dacsr, supcsr); */
 	return IRQ_RETVAL(handled);
 }
 
@@ -776,7 +758,10 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources are unique
+	 * and mutually compatible
+	 */
 
 	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
@@ -859,7 +844,8 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			     "driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels"
+						" to execute command");
 		return -EIO;
 	}
 
@@ -1049,7 +1035,10 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources are unique
+	 * and mutually compatible
+	 */
 
 	/* note that mutual compatibility is not an issue here */
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
@@ -1064,7 +1053,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 		cmd->start_arg = 0;
 		err++;
 	}
-	if (cmd->scan_begin_arg < 5000 /* XXX unknown */ ) {
+	if (cmd->scan_begin_arg < 5000 /* XXX unknown */) {
 		cmd->scan_begin_arg = 5000;
 		err++;
 	}
@@ -1115,7 +1104,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
 					  devpriv->dma_maxsize);
 	if (size == 0) {
-		printk("dt282x: AO underrun\n");
+		printk(KERN_ERR "dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 0, size);
@@ -1123,7 +1112,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev,
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
 					  devpriv->dma_maxsize);
 	if (size == 0) {
-		printk("dt282x: AO underrun\n");
+		printk(KERN_ERR "dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 1, size);
@@ -1141,7 +1130,8 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			     "driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels"
+						" to execute command");
 		return -EIO;
 	}
 
@@ -1262,7 +1252,8 @@ static const struct comedi_lrange *opt_ao_range_lkup(int x)
 	return ao_range_table[x];
 }
 
-enum { opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,	/* i/o base, irq, dma channels */
+enum {  /* i/o base, irq, dma channels */
+	opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,
 	opt_diff,		/* differential */
 	opt_ai_twos, opt_ao0_twos, opt_ao1_twos,	/* twos comp */
 	opt_ai_range, opt_ao0_range, opt_ao1_range,	/* range */
@@ -1295,9 +1286,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!iobase)
 		iobase = 0x240;
 
-	printk("comedi%d: dt282x: 0x%04lx", dev->minor, iobase);
+	printk(KERN_INFO "comedi%d: dt282x: 0x%04lx", dev->minor, iobase);
 	if (!request_region(iobase, DT2821_SIZE, "dt282x")) {
-		printk(" I/O port conflict\n");
+		printk(KERN_INFO " I/O port conflict\n");
 		return -EBUSY;
 	}
 	dev->iobase = iobase;
@@ -1305,7 +1296,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
 	i = inw(dev->iobase + DT2821_ADCSR);
 #ifdef DEBUG
-	printk(" fingerprint=%x,%x,%x,%x,%x",
+	printk(KERN_DEBUG " fingerprint=%x,%x,%x,%x,%x",
 	       inw(dev->iobase + DT2821_ADCSR),
 	       inw(dev->iobase + DT2821_CHANCSR),
 	       inw(dev->iobase + DT2821_DACSR),
@@ -1323,7 +1314,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	     != DT2821_SUPCSR_VAL) ||
 	    ((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
 	     != DT2821_TMRCTR_VAL)) {
-		printk(" board not found");
+		printk(KERN_ERR " board not found");
 		return -EIO;
 	}
 	/* should do board test */
@@ -1344,26 +1335,25 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
-		if (0 /* error */ ) {
-			printk(" error probing irq (bad)");
-		}
+		if (0 /* error */)
+			printk(KERN_ERR " error probing irq (bad)");
 	}
 #endif
 	if (irq > 0) {
-		printk(" ( irq = %d )", irq);
+		printk(KERN_INFO " ( irq = %d )", irq);
 		ret = request_irq(irq, dt282x_interrupt, 0, "dt282x", dev);
 		if (ret < 0) {
-			printk(" failed to get irq\n");
+			printk(KERN_ERR " failed to get irq\n");
 			return -EIO;
 		}
 		dev->irq = irq;
 	} else if (irq == 0) {
-		printk(" (no irq)");
+		printk(KERN_INFO " (no irq)");
 	} else {
 #if 0
-		printk(" (probe returned multiple irqs--bad)");
+		printk(KERN_INFO " (probe returned multiple irqs--bad)");
 #else
-		printk(" (irq probe not implemented)");
+		printk(KERN_INFO " (irq probe not implemented)");
 #endif
 	}
 
@@ -1435,16 +1425,15 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = 1;
 	s->range_table = &range_digital;
 
-	printk("\n");
+	printk(KERN_INFO "\n");
 
 	return 0;
 }
 
 static void free_resources(struct comedi_device *dev)
 {
-	if (dev->irq) {
+	if (dev->irq)
 		free_irq(dev->irq, dev);
-	}
 	if (dev->iobase)
 		release_region(dev->iobase, DT2821_SIZE);
 	if (dev->private) {
@@ -1461,7 +1450,7 @@ static void free_resources(struct comedi_device *dev)
 
 static int dt282x_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: dt282x: remove\n", dev->minor);
+	printk(KERN_INFO "comedi%d: dt282x: remove\n", dev->minor);
 
 	free_resources(dev);
 
@@ -1475,7 +1464,7 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 	devpriv->usedma = 0;
 
 	if (!dma1 && !dma2) {
-		printk(" (no dma)");
+		printk(KERN_ERR " (no dma)");
 		return 0;
 	}
 
@@ -1503,11 +1492,11 @@ static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
 	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
 	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {
-		printk(" can't get DMA memory");
+		printk(KERN_ERR " can't get DMA memory");
 		return -ENOMEM;
 	}
 
-	printk(" (dma=%d,%d)", dma1, dma2);
+	printk(KERN_INFO " (dma=%d,%d)", dma1, dma2);
 
 	devpriv->usedma = 1;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 99ca294b1ec5..e548763cf2f3 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -58,6 +58,7 @@ Configuration options:
 
 #include "../comedidev.h"
 
+#include <linux/gfp.h>
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <asm/dma.h>

commit 828684f9a6e096f9150bad523c43b75d74b9badd
Author: Dirk Hohndel <hohndel@infradead.org>
Date:   Tue Sep 29 11:23:44 2009 +0200

    Staging: comedi: trivial fix of a very frequent spelling mistake
    
    something-bility is spelled as something-blity so a grep for 'blit'
    would find these lines
    
    this is so trivial that I didn't split it by subsystem / copy additional
    maintainers - all changes are to comments The only purpose is to get
    fewer false positives when grepping around the kernel sources.
    
    Signed-off-by: Dirk Hohndel <hohndel@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index a4c96c02fa2b..99ca294b1ec5 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -777,7 +777,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
 	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
@@ -1050,7 +1050,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	/* note that mutual compatiblity is not an issue here */
+	/* note that mutual compatibility is not an issue here */
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 22b7304af396..a4c96c02fa2b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -155,46 +155,78 @@ Configuration options:
 #define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
 
 static const struct comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25)
-	}
+								     RANGE(-10,
+									   10),
+								     RANGE(-5,
+									   5),
+								     RANGE(-2.5,
+									   2.5),
+								     RANGE
+								     (-1.25,
+								      1.25)
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25)
-	}
+								      RANGE(0,
+									    10),
+								      RANGE(0,
+									    5),
+								      RANGE(0,
+									    2.5),
+								      RANGE(0,
+									    1.25)
+								      }
 };
+
 static const struct comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
-			RANGE(-5, 5),
-			RANGE(-2.5, 2.5),
-			RANGE(-1.25, 1.25),
-			RANGE(-0.625, 0.625),
-	}
+								    RANGE(-5,
+									  5),
+								    RANGE(-2.5,
+									  2.5),
+								    RANGE(-1.25,
+									  1.25),
+								    RANGE
+								    (-0.625,
+								     0.625),
+								    }
 };
+
 static const struct comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
-			RANGE(0, 5),
-			RANGE(0, 2.5),
-			RANGE(0, 1.25),
-			RANGE(0, 0.625),
-	}
+								     RANGE(0,
+									   5),
+								     RANGE(0,
+									   2.5),
+								     RANGE(0,
+									   1.25),
+								     RANGE(0,
+									   0.625),
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
-			RANGE(-10, 10),
-			RANGE(-1, 1),
-			RANGE(-0.1, 0.1),
-			RANGE(-0.02, 0.02)
-	}
+								     RANGE(-10,
+									   10),
+								     RANGE(-1,
+									   1),
+								     RANGE(-0.1,
+									   0.1),
+								     RANGE
+								     (-0.02,
+								      0.02)
+								     }
 };
+
 static const struct comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
-			RANGE(0, 10),
-			RANGE(0, 1),
-			RANGE(0, 0.1),
-			RANGE(0, 0.02)
-	}
+								      RANGE(0,
+									    10),
+								      RANGE(0,
+									    1),
+								      RANGE(0,
+									    0.1),
+								      RANGE(0,
+									    0.02)
+								      }
 };
 
 struct dt282x_board {
@@ -217,7 +249,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2821-f",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -226,7 +258,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2821-g",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -235,7 +267,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2823",
 	 .adbits = 16,
 	 .adchan_se = 0,
@@ -244,16 +276,16 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 16,
-	},
+	 },
 	{.name = "dt2824-pgh",
-	  .adbits = 12,
-	  .adchan_se = 16,
-	  .adchan_di = 8,
-	  .ai_speed = 20000,
-	  .ispgl = 0,
-	  .dachan = 0,
-	  .dabits = 0,
-	},
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 20000,
+	 .ispgl = 0,
+	 .dachan = 0,
+	 .dabits = 0,
+	 },
 	{.name = "dt2824-pgl",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -262,7 +294,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 1,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt2825",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -271,7 +303,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 1,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2827",
 	 .adbits = 16,
 	 .adchan_se = 0,
@@ -280,7 +312,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2828",
 	 .adbits = 12,
 	 .adchan_se = 4,
@@ -289,7 +321,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt2829",
 	 .adbits = 16,
 	 .adchan_se = 8,
@@ -298,7 +330,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 16,
-	},
+	 },
 	{.name = "dt21-ez",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -307,7 +339,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 2,
 	 .dabits = 12,
-	},
+	 },
 	{.name = "dt23-ez",
 	 .adbits = 16,
 	 .adchan_se = 16,
@@ -316,7 +348,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt24-ez",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -325,7 +357,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 0,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 	{.name = "dt24-ez-pgl",
 	 .adbits = 12,
 	 .adchan_se = 16,
@@ -334,7 +366,7 @@ static const struct dt282x_board boardtypes[] = {
 	 .ispgl = 1,
 	 .dachan = 0,
 	 .dabits = 0,
-	},
+	 },
 };
 
 #define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
@@ -394,7 +426,8 @@ struct dt282x_private {
 		if (_i){b}				\
 	}while (0)
 
-static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt282x_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dt282x_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt282x = {
 	.driver_name = "dt282x",
@@ -411,15 +444,17 @@ COMEDI_INITCLEANUP(driver_dt282x);
 static void free_resources(struct comedi_device *dev);
 static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
 static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
-static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dt282x_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int dt282x_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 static int dt282x_ns_to_timer(int *nanosec, int round_mode);
 static void dt282x_disable_dma(struct comedi_device *dev);
 
 static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 
 static void dt282x_munge(struct comedi_device *dev, short *buf,
-	unsigned int nbytes)
+			 unsigned int nbytes)
 {
 	unsigned int i;
 	unsigned short mask = (1 << boardtype.adbits) - 1;
@@ -628,7 +663,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 		int ret;
 		short data;
 
-		data = (short) inw(dev->iobase + DT2821_ADDAT);
+		data = (short)inw(dev->iobase + DT2821_ADDAT);
 		data &= (1 << boardtype.adbits) - 1;
 		if (devpriv->ad_2scomp) {
 			data ^= 1 << (boardtype.adbits - 1);
@@ -654,7 +689,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 }
 
 static void dt282x_load_changain(struct comedi_device *dev, int n,
-	unsigned int *chanlist)
+				 unsigned int *chanlist)
 {
 	unsigned int i;
 	unsigned int chan, range;
@@ -674,8 +709,9 @@ static void dt282x_load_changain(struct comedi_device *dev, int n,
  *      - preload multiplexer
  *      - trigger conversion and wait for it to finish
  */
-static int dt282x_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ai_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -686,18 +722,15 @@ static int dt282x_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 	dt282x_load_changain(dev, 1, &insn->chanspec);
 
 	update_supcsr(DT2821_PRLD);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
-		return -ETIME;
-		);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	for (i = 0; i < insn->n; i++) {
 		update_supcsr(DT2821_STRIG);
 		wait_for(ad_done(), comedi_error(dev, "timeout\n");
-			return -ETIME;
-			);
+			 return -ETIME;);
 
 		data[i] =
-			inw(dev->iobase +
+		    inw(dev->iobase +
 			DT2821_ADDAT) & ((1 << boardtype.adbits) - 1);
 		if (devpriv->ad_2scomp)
 			data[i] ^= (1 << (boardtype.adbits - 1));
@@ -706,8 +739,8 @@ static int dt282x_ai_insn_read(struct comedi_device *dev, struct comedi_subdevic
 	return i;
 }
 
-static int dt282x_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt282x_ai_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -746,7 +779,7 @@ static int dt282x_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 	/* note that mutual compatiblity is not an issue here */
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -825,7 +858,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			"driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels to execute command");
 		return -EIO;
 	}
 
@@ -865,9 +898,7 @@ static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	update_adcsr(0);
 
 	update_supcsr(DT2821_PRLD);
-	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
-		return -ETIME;
-		);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);
 
 	if (cmd->scan_begin_src == TRIG_FOLLOW) {
 		update_supcsr(DT2821_STRIG);
@@ -887,7 +918,8 @@ static void dt282x_disable_dma(struct comedi_device *dev)
 	}
 }
 
-static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dt282x_ai_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -937,16 +969,18 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      offset binary if necessary, loads the data into the DAC
  *      data register, and performs the conversion.
  */
-static int dt282x_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ao_insn_read(struct comedi_device *dev,
+			       struct comedi_subdevice *s,
+			       struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int dt282x_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_ao_insn_write(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	short d;
 	unsigned int chan;
@@ -978,8 +1012,8 @@ static int dt282x_ao_insn_write(struct comedi_device *dev, struct comedi_subdevi
 	return 1;
 }
 
-static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int dt282x_ao_cmdtest(struct comedi_device *dev,
+			     struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1029,7 +1063,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		cmd->start_arg = 0;
 		err++;
 	}
-	if (cmd->scan_begin_arg < 5000 /* XXX unknown */) {
+	if (cmd->scan_begin_arg < 5000 /* XXX unknown */ ) {
 		cmd->scan_begin_arg = 5000;
 		err++;
 	}
@@ -1069,8 +1103,8 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 
 }
 
-static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int x)
+static int dt282x_ao_inttrig(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int x)
 {
 	int size;
 
@@ -1078,7 +1112,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 		return -EINVAL;
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
-		devpriv->dma_maxsize);
+					  devpriv->dma_maxsize);
 	if (size == 0) {
 		printk("dt282x: AO underrun\n");
 		return -EPIPE;
@@ -1086,7 +1120,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 	prep_ao_dma(dev, 0, size);
 
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
-		devpriv->dma_maxsize);
+					  devpriv->dma_maxsize);
 	if (size == 0) {
 		printk("dt282x: AO underrun\n");
 		return -EPIPE;
@@ -1106,7 +1140,7 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,
-			"driver requires 2 dma channels to execute command");
+			     "driver requires 2 dma channels to execute command");
 		return -EIO;
 	}
 
@@ -1132,7 +1166,8 @@ static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dt282x_ao_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -1145,8 +1180,9 @@ static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int dt282x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_dio_insn_bits(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -1159,8 +1195,9 @@ static int dt282x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevi
 	return 2;
 }
 
-static int dt282x_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dt282x_dio_insn_config(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn, unsigned int *data)
 {
 	int mask;
 
@@ -1190,10 +1227,12 @@ static const struct comedi_lrange *const ai_range_table[] = {
 	&range_dt282x_ai_5_bipolar,
 	&range_dt282x_ai_5_unipolar
 };
+
 static const struct comedi_lrange *const ai_range_pgl_table[] = {
 	&range_dt282x_ai_hi_bipolar,
 	&range_dt282x_ai_hi_unipolar
 };
+
 static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 {
 	if (ispgl) {
@@ -1206,6 +1245,7 @@ static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 		return ai_range_table[x];
 	}
 }
+
 static const struct comedi_lrange *const ao_range_table[] = {
 	&range_bipolar10,
 	&range_unipolar10,
@@ -1213,6 +1253,7 @@ static const struct comedi_lrange *const ao_range_table[] = {
 	&range_unipolar5,
 	&range_bipolar2_5
 };
+
 static const struct comedi_lrange *opt_ao_range_lkup(int x)
 {
 	if (x < 0 || x >= 5)
@@ -1264,23 +1305,23 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	i = inw(dev->iobase + DT2821_ADCSR);
 #ifdef DEBUG
 	printk(" fingerprint=%x,%x,%x,%x,%x",
-		inw(dev->iobase + DT2821_ADCSR),
-		inw(dev->iobase + DT2821_CHANCSR),
-		inw(dev->iobase + DT2821_DACSR),
-		inw(dev->iobase + DT2821_SUPCSR),
-		inw(dev->iobase + DT2821_TMRCTR));
+	       inw(dev->iobase + DT2821_ADCSR),
+	       inw(dev->iobase + DT2821_CHANCSR),
+	       inw(dev->iobase + DT2821_DACSR),
+	       inw(dev->iobase + DT2821_SUPCSR),
+	       inw(dev->iobase + DT2821_TMRCTR));
 #endif
 
 	if (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)
-			!= DT2821_ADCSR_VAL) ||
-		((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
-			!= DT2821_CHANCSR_VAL) ||
-		((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
-			!= DT2821_DACSR_VAL) ||
-		((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
-			!= DT2821_SUPCSR_VAL) ||
-		((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
-			!= DT2821_TMRCTR_VAL)) {
+	     != DT2821_ADCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
+	     != DT2821_CHANCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
+	     != DT2821_DACSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
+	     != DT2821_SUPCSR_VAL) ||
+	    ((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
+	     != DT2821_TMRCTR_VAL)) {
 		printk(" board not found");
 		return -EIO;
 	}
@@ -1302,7 +1343,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
-		if (0 /* error */) {
+		if (0 /* error */ ) {
 			printk(" error probing irq (bad)");
 		}
 	}
@@ -1330,7 +1371,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
-		it->options[opt_dma2]);
+			      it->options[opt_dma2]);
 	if (ret < 0)
 		return ret;
 
@@ -1344,10 +1385,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* ai subdevice */
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_CMD_READ |
-		((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
+	    ((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
 	s->n_chan =
-		(it->options[opt_diff]) ? boardtype.adchan_di : boardtype.
-		adchan_se;
+	    (it->options[opt_diff]) ? boardtype.adchan_di : boardtype.adchan_se;
 	s->insn_read = dt282x_ai_insn_read;
 	s->do_cmdtest = dt282x_ai_cmdtest;
 	s->do_cmd = dt282x_ai_cmd;
@@ -1355,7 +1395,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->maxdata = (1 << boardtype.adbits) - 1;
 	s->len_chanlist = 16;
 	s->range_table =
-		opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
+	    opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
 	s++;
@@ -1375,9 +1415,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->len_chanlist = 2;
 		s->range_table_list = devpriv->darangelist;
 		devpriv->darangelist[0] =
-			opt_ao_range_lkup(it->options[opt_ao0_range]);
+		    opt_ao_range_lkup(it->options[opt_ao0_range]);
 		devpriv->darangelist[1] =
-			opt_ao_range_lkup(it->options[opt_ao1_range]);
+		    opt_ao_range_lkup(it->options[opt_ao1_range]);
 		devpriv->da0_2scomp = it->options[opt_ao0_twos];
 		devpriv->da1_2scomp = it->options[opt_ao1_twos];
 	} else {

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index f852b9347027..22b7304af396 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -389,7 +389,7 @@ struct dt282x_private {
 		int _i;					\
 		for (_i=0;_i<DT2821_TIMEOUT;_i++){	\
 			if (a){_i=0;break;}		\
-			comedi_udelay(5);			\
+			udelay(5);			\
 		}					\
 		if (_i){b}				\
 	}while (0)
@@ -463,7 +463,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 
 	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		dt282x_ao_cancel(dev, s);
 		s->async->events |= COMEDI_CB_OVERFLOW;
 		return;
@@ -1080,7 +1080,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
 		devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 0, size);
@@ -1088,7 +1088,7 @@ static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice
 	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
 		devpriv->dma_maxsize);
 	if (size == 0) {
-		rt_printk("dt282x: AO underrun\n");
+		printk("dt282x: AO underrun\n");
 		return -EPIPE;
 	}
 	prep_ao_dma(dev, 1, size);
@@ -1298,7 +1298,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		/* trigger interrupt */
 
-		comedi_udelay(100);
+		udelay(100);
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
@@ -1309,8 +1309,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	if (irq > 0) {
 		printk(" ( irq = %d )", irq);
-		ret = comedi_request_irq(irq, dt282x_interrupt, 0, "dt282x",
-			dev);
+		ret = request_irq(irq, dt282x_interrupt, 0, "dt282x", dev);
 		if (ret < 0) {
 			printk(" failed to get irq\n");
 			return -EIO;
@@ -1403,7 +1402,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static void free_resources(struct comedi_device *dev)
 {
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->iobase)
 		release_region(dev->iobase, DT2821_SIZE);

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 64e9c4b32c0a..f852b9347027 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -209,132 +209,132 @@ struct dt282x_board {
 };
 
 static const struct dt282x_board boardtypes[] = {
-      {name:"dt2821",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:20000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2821-f",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:6500,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2821-g",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:4000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2823",
-	      adbits:	16,
-	      adchan_se:0,
-	      adchan_di:4,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	16,
-		},
-      {name:"dt2824-pgh",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:20000,
-	      ispgl:	0,
-	      dachan:	0,
-	      dabits:	0,
-		},
-      {name:"dt2824-pgl",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:20000,
-	      ispgl:	1,
-	      dachan:	0,
-	      dabits:	0,
-		},
-      {name:"dt2825",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:20000,
-	      ispgl:	1,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2827",
-	      adbits:	16,
-	      adchan_se:0,
-	      adchan_di:4,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2828",
-	      adbits:	12,
-	      adchan_se:4,
-	      adchan_di:0,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt2829",
-	      adbits:	16,
-	      adchan_se:8,
-	      adchan_di:0,
-	      ai_speed:33250,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	16,
-		},
-      {name:"dt21-ez",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	2,
-	      dabits:	12,
-		},
-      {name:"dt23-ez",
-	      adbits:	16,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	0,
-	      dabits:	0,
-		},
-      {name:"dt24-ez",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:10000,
-	      ispgl:	0,
-	      dachan:	0,
-	      dabits:	0,
-		},
-      {name:"dt24-ez-pgl",
-	      adbits:	12,
-	      adchan_se:16,
-	      adchan_di:8,
-	      ai_speed:10000,
-	      ispgl:	1,
-	      dachan:	0,
-	      dabits:	0,
-		},
+	{.name = "dt2821",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 20000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2821-f",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 6500,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2821-g",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 4000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2823",
+	 .adbits = 16,
+	 .adchan_se = 0,
+	 .adchan_di = 4,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 16,
+	},
+	{.name = "dt2824-pgh",
+	  .adbits = 12,
+	  .adchan_se = 16,
+	  .adchan_di = 8,
+	  .ai_speed = 20000,
+	  .ispgl = 0,
+	  .dachan = 0,
+	  .dabits = 0,
+	},
+	{.name = "dt2824-pgl",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 20000,
+	 .ispgl = 1,
+	 .dachan = 0,
+	 .dabits = 0,
+	},
+	{.name = "dt2825",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 20000,
+	 .ispgl = 1,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2827",
+	 .adbits = 16,
+	 .adchan_se = 0,
+	 .adchan_di = 4,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2828",
+	 .adbits = 12,
+	 .adchan_se = 4,
+	 .adchan_di = 0,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt2829",
+	 .adbits = 16,
+	 .adchan_se = 8,
+	 .adchan_di = 0,
+	 .ai_speed = 33250,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 16,
+	},
+	{.name = "dt21-ez",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 2,
+	 .dabits = 12,
+	},
+	{.name = "dt23-ez",
+	 .adbits = 16,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 0,
+	 .dabits = 0,
+	},
+	{.name = "dt24-ez",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 10000,
+	 .ispgl = 0,
+	 .dachan = 0,
+	 .dabits = 0,
+	},
+	{.name = "dt24-ez-pgl",
+	 .adbits = 12,
+	 .adchan_se = 16,
+	 .adchan_di = 8,
+	 .ai_speed = 10000,
+	 .ispgl = 1,
+	 .dachan = 0,
+	 .dabits = 0,
+	},
 };
 
 #define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
@@ -397,13 +397,13 @@ struct dt282x_private {
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int dt282x_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt282x = {
-      driver_name:"dt282x",
-      module:THIS_MODULE,
-      attach:dt282x_attach,
-      detach:dt282x_detach,
-      board_name:&boardtypes[0].name,
-      num_names:n_boardtypes,
-      offset:sizeof(struct dt282x_board),
+	.driver_name = "dt282x",
+	.module = THIS_MODULE,
+	.attach = dt282x_attach,
+	.detach = dt282x_detach,
+	.board_name = &boardtypes[0].name,
+	.num_names = n_boardtypes,
+	.offset = sizeof(struct dt282x_board),
 };
 
 COMEDI_INITCLEANUP(driver_dt282x);

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 66328353fdaa..64e9c4b32c0a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -1326,7 +1326,8 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	}
 
-	if ((ret = alloc_private(dev, sizeof(struct dt282x_private))) < 0)
+	ret = alloc_private(dev, sizeof(struct dt282x_private));
+	if (ret < 0)
 		return ret;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
@@ -1334,7 +1335,8 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (ret < 0)
 		return ret;
 
-	if ((ret = alloc_subdevices(dev, 3)) < 0)
+	ret = alloc_subdevices(dev, 3);
+	if (ret < 0)
 		return ret;
 
 	s = dev->subdevices + 0;
@@ -1358,7 +1360,9 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->ad_2scomp = it->options[opt_ai_twos];
 
 	s++;
-	if ((s->n_chan = boardtype.dachan)) {
+
+	s->n_chan = boardtype.dachan;
+	if (s->n_chan) {
 		/* ao subsystem */
 		s->type = COMEDI_SUBD_AO;
 		dev->write_subdev = s;

commit 53106ae68acf6eda9593150a25fc44e30fd5ff68
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:21 2009 -0400

    Staging Comedi: fix spacing around parens
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 643af376087b..66328353fdaa 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -387,12 +387,12 @@ struct dt282x_private {
 #define wait_for(a, b)	 				\
 	do{						\
 		int _i;					\
-		for(_i=0;_i<DT2821_TIMEOUT;_i++){	\
-			if(a){_i=0;break;}		\
+		for (_i=0;_i<DT2821_TIMEOUT;_i++){	\
+			if (a){_i=0;break;}		\
 			comedi_udelay(5);			\
 		}					\
-		if(_i){b}				\
-	}while(0)
+		if (_i){b}				\
+	}while (0)
 
 static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int dt282x_detach(struct comedi_device *dev);
@@ -1029,7 +1029,7 @@ static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice
 		cmd->start_arg = 0;
 		err++;
 	}
-	if (cmd->scan_begin_arg < 5000 /* XXX unknown */ ) {
+	if (cmd->scan_begin_arg < 5000 /* XXX unknown */) {
 		cmd->scan_begin_arg = 5000;
 		err++;
 	}
@@ -1302,7 +1302,7 @@ static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		irq = probe_irq_off(irqs);
 		restore_flags(flags);
-		if (0 /* error */ ) {
+		if (0 /* error */) {
 			printk(" error probing irq (bad)");
 		}
 	}

commit f7cbd7aad063b2a4b7aff6a743b2b00015ce3c3e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:16 2009 -0400

    Staging: comedi: Add spaces after commas
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 3174c36573e2..643af376087b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -374,17 +374,17 @@ struct dt282x_private {
  *    Some useless abstractions
  */
 #define chan_to_DAC(a)	((a)&1)
-#define update_dacsr(a)	outw(devpriv->dacsr|(a),dev->iobase+DT2821_DACSR)
-#define update_adcsr(a)	outw(devpriv->adcsr|(a),dev->iobase+DT2821_ADCSR)
+#define update_dacsr(a)	outw(devpriv->dacsr|(a), dev->iobase+DT2821_DACSR)
+#define update_adcsr(a)	outw(devpriv->adcsr|(a), dev->iobase+DT2821_ADCSR)
 #define mux_busy() (inw(dev->iobase+DT2821_ADCSR)&DT2821_MUXBUSY)
 #define ad_done() (inw(dev->iobase+DT2821_ADCSR)&DT2821_ADDONE)
-#define update_supcsr(a)	outw(devpriv->supcsr|(a),dev->iobase+DT2821_SUPCSR)
+#define update_supcsr(a)	outw(devpriv->supcsr|(a), dev->iobase+DT2821_SUPCSR)
 
 /*
  *    danger! macro abuse... a is the expression to wait on, and b is
  *      the statement(s) to execute if it doesn't happen.
  */
-#define wait_for(a,b)	 				\
+#define wait_for(a, b)	 				\
 	do{						\
 		int _i;					\
 		for(_i=0;_i<DT2821_TIMEOUT;_i++){	\

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 275644ac4b94..3174c36573e2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -394,8 +394,8 @@ struct dt282x_private {
 		if(_i){b}				\
 	}while(0)
 
-static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int dt282x_detach(struct comedi_device * dev);
+static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dt282x_detach(struct comedi_device *dev);
 static struct comedi_driver driver_dt282x = {
       driver_name:"dt282x",
       module:THIS_MODULE,
@@ -408,17 +408,17 @@ static struct comedi_driver driver_dt282x = {
 
 COMEDI_INITCLEANUP(driver_dt282x);
 
-static void free_resources(struct comedi_device * dev);
-static int prep_ai_dma(struct comedi_device * dev, int chan, int size);
-static int prep_ao_dma(struct comedi_device * dev, int chan, int size);
-static int dt282x_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static void free_resources(struct comedi_device *dev);
+static int prep_ai_dma(struct comedi_device *dev, int chan, int size);
+static int prep_ao_dma(struct comedi_device *dev, int chan, int size);
+static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
 static int dt282x_ns_to_timer(int *nanosec, int round_mode);
-static void dt282x_disable_dma(struct comedi_device * dev);
+static void dt282x_disable_dma(struct comedi_device *dev);
 
-static int dt282x_grab_dma(struct comedi_device * dev, int dma1, int dma2);
+static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2);
 
-static void dt282x_munge(struct comedi_device * dev, short * buf,
+static void dt282x_munge(struct comedi_device *dev, short *buf,
 	unsigned int nbytes)
 {
 	unsigned int i;
@@ -440,7 +440,7 @@ static void dt282x_munge(struct comedi_device * dev, short * buf,
 	}
 }
 
-static void dt282x_ao_dma_interrupt(struct comedi_device * dev)
+static void dt282x_ao_dma_interrupt(struct comedi_device *dev)
 {
 	void *ptr;
 	int size;
@@ -472,7 +472,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device * dev)
 	return;
 }
 
-static void dt282x_ai_dma_interrupt(struct comedi_device * dev)
+static void dt282x_ai_dma_interrupt(struct comedi_device *dev)
 {
 	void *ptr;
 	int size;
@@ -524,7 +524,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device * dev)
 	prep_ai_dma(dev, i, 0);
 }
 
-static int prep_ai_dma(struct comedi_device * dev, int dma_index, int n)
+static int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	int dma_chan;
 	unsigned long dma_ptr;
@@ -555,7 +555,7 @@ static int prep_ai_dma(struct comedi_device * dev, int dma_index, int n)
 	return n;
 }
 
-static int prep_ao_dma(struct comedi_device * dev, int dma_index, int n)
+static int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)
 {
 	int dma_chan;
 	unsigned long dma_ptr;
@@ -653,7 +653,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d)
 	return IRQ_RETVAL(handled);
 }
 
-static void dt282x_load_changain(struct comedi_device * dev, int n,
+static void dt282x_load_changain(struct comedi_device *dev, int n,
 	unsigned int *chanlist)
 {
 	unsigned int i;
@@ -674,8 +674,8 @@ static void dt282x_load_changain(struct comedi_device * dev, int n,
  *      - preload multiplexer
  *      - trigger conversion and wait for it to finish
  */
-static int dt282x_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dt282x_ai_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int i;
 
@@ -706,8 +706,8 @@ static int dt282x_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 	return i;
 }
 
-static int dt282x_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int dt282x_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -818,7 +818,7 @@ static int dt282x_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int dt282x_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -879,7 +879,7 @@ static int dt282x_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static void dt282x_disable_dma(struct comedi_device * dev)
+static void dt282x_disable_dma(struct comedi_device *dev)
 {
 	if (devpriv->usedma) {
 		disable_dma(devpriv->dma[0].chan);
@@ -887,7 +887,7 @@ static void dt282x_disable_dma(struct comedi_device * dev)
 	}
 }
 
-static int dt282x_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dt282x_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -937,16 +937,16 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      offset binary if necessary, loads the data into the DAC
  *      data register, and performs the conversion.
  */
-static int dt282x_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dt282x_ao_insn_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int dt282x_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dt282x_ao_insn_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	short d;
 	unsigned int chan;
@@ -978,8 +978,8 @@ static int dt282x_ao_insn_write(struct comedi_device * dev, struct comedi_subdev
 	return 1;
 }
 
-static int dt282x_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int dt282x_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1069,7 +1069,7 @@ static int dt282x_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 
 }
 
-static int dt282x_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
+static int dt282x_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int x)
 {
 	int size;
@@ -1099,7 +1099,7 @@ static int dt282x_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int dt282x_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	int timer;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1132,7 +1132,7 @@ static int dt282x_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s
 	return 0;
 }
 
-static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dt282x_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	dt282x_disable_dma(dev);
 
@@ -1145,8 +1145,8 @@ static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int dt282x_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dt282x_dio_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -1159,8 +1159,8 @@ static int dt282x_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
 	return 2;
 }
 
-static int dt282x_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dt282x_dio_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int mask;
 
@@ -1240,7 +1240,7 @@ enum { opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,	/* i/o base, irq, dma channe
    9	ao0 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
    10	ao1 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
  */
-static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	int i, irq;
 	int ret;
@@ -1396,7 +1396,7 @@ static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	return 0;
 }
 
-static void free_resources(struct comedi_device * dev)
+static void free_resources(struct comedi_device *dev)
 {
 	if (dev->irq) {
 		comedi_free_irq(dev->irq, dev);
@@ -1415,7 +1415,7 @@ static void free_resources(struct comedi_device * dev)
 	}
 }
 
-static int dt282x_detach(struct comedi_device * dev)
+static int dt282x_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: dt282x: remove\n", dev->minor);
 
@@ -1424,7 +1424,7 @@ static int dt282x_detach(struct comedi_device * dev)
 	return 0;
 }
 
-static int dt282x_grab_dma(struct comedi_device * dev, int dma1, int dma2)
+static int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)
 {
 	int ret;
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 4882c3e679cc..275644ac4b94 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -577,7 +577,7 @@ static int prep_ao_dma(struct comedi_device * dev, int dma_index, int n)
 	return n;
 }
 
-static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t dt282x_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct comedi_subdevice *s;

commit 68b08cdad78c79fc87df52f8c8d4adf60ec5d7fc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:14:25 2009 -0400

    Staging: comedi: Remove dt282x_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 6d76d98126d8..4882c3e679cc 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -340,7 +340,7 @@ static const struct dt282x_board boardtypes[] = {
 #define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
 #define this_board ((const struct dt282x_board *)dev->board_ptr)
 
-typedef struct {
+struct dt282x_private {
 	int ad_2scomp;		/* we have 2's comp jumper set  */
 	int da0_2scomp;		/* same, for DAC0               */
 	int da1_2scomp;		/* same, for DAC1               */
@@ -365,9 +365,9 @@ typedef struct {
 	int usedma;		/* driver uses DMA              */
 	volatile int current_dma_index;
 	int dma_dir;
-} dt282x_private;
+};
 
-#define devpriv ((dt282x_private *)dev->private)
+#define devpriv ((struct dt282x_private *)dev->private)
 #define boardtype (*(const struct dt282x_board *)dev->board_ptr)
 
 /*
@@ -1326,7 +1326,7 @@ static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * i
 #endif
 	}
 
-	if ((ret = alloc_private(dev, sizeof(dt282x_private))) < 0)
+	if ((ret = alloc_private(dev, sizeof(struct dt282x_private))) < 0)
 		return ret;
 
 	ret = dt282x_grab_dma(dev, it->options[opt_dma1],

commit 98484c1ae621eb784c4b2a7dd6c76a069bad6214
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:14:19 2009 -0400

    Staging: comedi: Remove boardtype_t typedef in dt282x.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 1cc0e3b17bb2..6d76d98126d8 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -197,7 +197,7 @@ static const struct comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
 	}
 };
 
-typedef struct {
+struct dt282x_board {
 	const char *name;
 	int adbits;
 	int adchan_se;
@@ -206,9 +206,9 @@ typedef struct {
 	int ispgl;
 	int dachan;
 	int dabits;
-} boardtype_t;
+};
 
-static const boardtype_t boardtypes[] = {
+static const struct dt282x_board boardtypes[] = {
       {name:"dt2821",
 	      adbits:	12,
 	      adchan_se:16,
@@ -337,8 +337,8 @@ static const boardtype_t boardtypes[] = {
 		},
 };
 
-#define n_boardtypes sizeof(boardtypes)/sizeof(boardtype_t)
-#define this_board ((const boardtype_t *)dev->board_ptr)
+#define n_boardtypes sizeof(boardtypes)/sizeof(struct dt282x_board)
+#define this_board ((const struct dt282x_board *)dev->board_ptr)
 
 typedef struct {
 	int ad_2scomp;		/* we have 2's comp jumper set  */
@@ -368,7 +368,7 @@ typedef struct {
 } dt282x_private;
 
 #define devpriv ((dt282x_private *)dev->private)
-#define boardtype (*(const boardtype_t *)dev->board_ptr)
+#define boardtype (*(const struct dt282x_board *)dev->board_ptr)
 
 /*
  *    Some useless abstractions
@@ -403,7 +403,7 @@ static struct comedi_driver driver_dt282x = {
       detach:dt282x_detach,
       board_name:&boardtypes[0].name,
       num_names:n_boardtypes,
-      offset:sizeof(boardtype_t),
+      offset:sizeof(struct dt282x_board),
 };
 
 COMEDI_INITCLEANUP(driver_dt282x);

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 1a74f31ad3ff..1cc0e3b17bb2 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -394,7 +394,7 @@ typedef struct {
 		if(_i){b}				\
 	}while(0)
 
-static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int dt282x_detach(struct comedi_device * dev);
 static struct comedi_driver driver_dt282x = {
       driver_name:"dt282x",
@@ -1240,7 +1240,7 @@ enum { opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,	/* i/o base, irq, dma channe
    9	ao0 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
    10	ao1 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
  */
-static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int dt282x_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	int i, irq;
 	int ret;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 79308492bcb0..1a74f31ad3ff 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -675,7 +675,7 @@ static void dt282x_load_changain(struct comedi_device * dev, int n,
  *      - trigger conversion and wait for it to finish
  */
 static int dt282x_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int i;
 
@@ -938,7 +938,7 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      data register, and performs the conversion.
  */
 static int dt282x_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
@@ -946,7 +946,7 @@ static int dt282x_ao_insn_read(struct comedi_device * dev, struct comedi_subdevi
 }
 
 static int dt282x_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	short d;
 	unsigned int chan;
@@ -1146,7 +1146,7 @@ static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int dt282x_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -1160,7 +1160,7 @@ static int dt282x_dio_insn_bits(struct comedi_device * dev, struct comedi_subdev
 }
 
 static int dt282x_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int mask;
 

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 9e8d1bc45d59..79308492bcb0 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -707,7 +707,7 @@ static int dt282x_ai_insn_read(struct comedi_device * dev, struct comedi_subdevi
 }
 
 static int dt282x_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -820,7 +820,7 @@ static int dt282x_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice
 
 static int dt282x_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int timer;
 
 	if (devpriv->usedma == 0) {
@@ -979,7 +979,7 @@ static int dt282x_ao_insn_write(struct comedi_device * dev, struct comedi_subdev
 }
 
 static int dt282x_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1102,7 +1102,7 @@ static int dt282x_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice
 static int dt282x_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int timer;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 
 	if (devpriv->usedma == 0) {
 		comedi_error(dev,

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index bed21029871b..9e8d1bc45d59 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -154,42 +154,42 @@ Configuration options:
 #define DT2821_XCLK	0x0002	/* (R/W) external clock enable            */
 #define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
 
-static const comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
 			RANGE(-10, 10),
 			RANGE(-5, 5),
 			RANGE(-2.5, 2.5),
 			RANGE(-1.25, 1.25)
 	}
 };
-static const comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
 			RANGE(0, 10),
 			RANGE(0, 5),
 			RANGE(0, 2.5),
 			RANGE(0, 1.25)
 	}
 };
-static const comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
 			RANGE(-5, 5),
 			RANGE(-2.5, 2.5),
 			RANGE(-1.25, 1.25),
 			RANGE(-0.625, 0.625),
 	}
 };
-static const comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
 			RANGE(0, 5),
 			RANGE(0, 2.5),
 			RANGE(0, 1.25),
 			RANGE(0, 0.625),
 	}
 };
-static const comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
 			RANGE(-10, 10),
 			RANGE(-1, 1),
 			RANGE(-0.1, 0.1),
 			RANGE(-0.02, 0.02)
 	}
 };
-static const comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
+static const struct comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
 			RANGE(0, 10),
 			RANGE(0, 1),
 			RANGE(0, 0.1),
@@ -345,7 +345,7 @@ typedef struct {
 	int da0_2scomp;		/* same, for DAC0               */
 	int da1_2scomp;		/* same, for DAC1               */
 
-	const comedi_lrange *darangelist[2];
+	const struct comedi_lrange *darangelist[2];
 
 	short ao[2];
 
@@ -1184,17 +1184,17 @@ static int dt282x_dio_insn_config(struct comedi_device * dev, struct comedi_subd
 	return 1;
 }
 
-static const comedi_lrange *const ai_range_table[] = {
+static const struct comedi_lrange *const ai_range_table[] = {
 	&range_dt282x_ai_lo_bipolar,
 	&range_dt282x_ai_lo_unipolar,
 	&range_dt282x_ai_5_bipolar,
 	&range_dt282x_ai_5_unipolar
 };
-static const comedi_lrange *const ai_range_pgl_table[] = {
+static const struct comedi_lrange *const ai_range_pgl_table[] = {
 	&range_dt282x_ai_hi_bipolar,
 	&range_dt282x_ai_hi_unipolar
 };
-static const comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
+static const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 {
 	if (ispgl) {
 		if (x < 0 || x >= 2)
@@ -1206,14 +1206,14 @@ static const comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
 		return ai_range_table[x];
 	}
 }
-static const comedi_lrange *const ao_range_table[] = {
+static const struct comedi_lrange *const ao_range_table[] = {
 	&range_bipolar10,
 	&range_unipolar10,
 	&range_bipolar5,
 	&range_unipolar5,
 	&range_bipolar2_5
 };
-static const comedi_lrange *opt_ao_range_lkup(int x)
+static const struct comedi_lrange *opt_ao_range_lkup(int x)
 {
 	if (x < 0 || x >= 5)
 		x = 0;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5da648d2399b..bed21029871b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -396,7 +396,7 @@ typedef struct {
 
 static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int dt282x_detach(struct comedi_device * dev);
-static comedi_driver driver_dt282x = {
+static struct comedi_driver driver_dt282x = {
       driver_name:"dt282x",
       module:THIS_MODULE,
       attach:dt282x_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 2c4557faac4a..5da648d2399b 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -411,8 +411,8 @@ COMEDI_INITCLEANUP(driver_dt282x);
 static void free_resources(struct comedi_device * dev);
 static int prep_ai_dma(struct comedi_device * dev, int chan, int size);
 static int prep_ao_dma(struct comedi_device * dev, int chan, int size);
-static int dt282x_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static int dt282x_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int dt282x_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int dt282x_ns_to_timer(int *nanosec, int round_mode);
 static void dt282x_disable_dma(struct comedi_device * dev);
 
@@ -445,7 +445,7 @@ static void dt282x_ao_dma_interrupt(struct comedi_device * dev)
 	void *ptr;
 	int size;
 	int i;
-	comedi_subdevice *s = dev->subdevices + 1;
+	struct comedi_subdevice *s = dev->subdevices + 1;
 
 	update_supcsr(DT2821_CLRDMADNE);
 
@@ -478,7 +478,7 @@ static void dt282x_ai_dma_interrupt(struct comedi_device * dev)
 	int size;
 	int i;
 	int ret;
-	comedi_subdevice *s = dev->subdevices;
+	struct comedi_subdevice *s = dev->subdevices;
 
 	update_supcsr(DT2821_CLRDMADNE);
 
@@ -580,8 +580,8 @@ static int prep_ao_dma(struct comedi_device * dev, int dma_index, int n)
 static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = d;
-	comedi_subdevice *s;
-	comedi_subdevice *s_ao;
+	struct comedi_subdevice *s;
+	struct comedi_subdevice *s_ao;
 	unsigned int supcsr, adcsr, dacsr;
 	int handled = 0;
 
@@ -674,7 +674,7 @@ static void dt282x_load_changain(struct comedi_device * dev, int n,
  *      - preload multiplexer
  *      - trigger conversion and wait for it to finish
  */
-static int dt282x_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ai_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -706,7 +706,7 @@ static int dt282x_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int dt282x_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -818,7 +818,7 @@ static int dt282x_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int dt282x_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -887,7 +887,7 @@ static void dt282x_disable_dma(struct comedi_device * dev)
 	}
 }
 
-static int dt282x_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dt282x_disable_dma(dev);
 
@@ -937,7 +937,7 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      offset binary if necessary, loads the data into the DAC
  *      data register, and performs the conversion.
  */
-static int dt282x_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_insn_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
@@ -945,7 +945,7 @@ static int dt282x_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dt282x_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_insn_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	short d;
@@ -978,7 +978,7 @@ static int dt282x_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s
 	return 1;
 }
 
-static int dt282x_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1069,7 +1069,7 @@ static int dt282x_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 
 }
 
-static int dt282x_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int x)
 {
 	int size;
@@ -1099,7 +1099,7 @@ static int dt282x_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dt282x_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int timer;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -1132,7 +1132,7 @@ static int dt282x_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int dt282x_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dt282x_disable_dma(dev);
 
@@ -1145,7 +1145,7 @@ static int dt282x_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int dt282x_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_dio_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -1159,7 +1159,7 @@ static int dt282x_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s
 	return 2;
 }
 
-static int dt282x_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
+static int dt282x_dio_insn_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int mask;
@@ -1244,7 +1244,7 @@ static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int i, irq;
 	int ret;
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase;
 
 	dev->board_name = this_board->name;

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 5cdd577475da..2c4557faac4a 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -394,8 +394,8 @@ typedef struct {
 		if(_i){b}				\
 	}while(0)
 
-static int dt282x_attach(comedi_device * dev, comedi_devconfig * it);
-static int dt282x_detach(comedi_device * dev);
+static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dt282x_detach(struct comedi_device * dev);
 static comedi_driver driver_dt282x = {
       driver_name:"dt282x",
       module:THIS_MODULE,
@@ -408,17 +408,17 @@ static comedi_driver driver_dt282x = {
 
 COMEDI_INITCLEANUP(driver_dt282x);
 
-static void free_resources(comedi_device * dev);
-static int prep_ai_dma(comedi_device * dev, int chan, int size);
-static int prep_ao_dma(comedi_device * dev, int chan, int size);
-static int dt282x_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static void free_resources(struct comedi_device * dev);
+static int prep_ai_dma(struct comedi_device * dev, int chan, int size);
+static int prep_ao_dma(struct comedi_device * dev, int chan, int size);
+static int dt282x_ai_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int dt282x_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
 static int dt282x_ns_to_timer(int *nanosec, int round_mode);
-static void dt282x_disable_dma(comedi_device * dev);
+static void dt282x_disable_dma(struct comedi_device * dev);
 
-static int dt282x_grab_dma(comedi_device * dev, int dma1, int dma2);
+static int dt282x_grab_dma(struct comedi_device * dev, int dma1, int dma2);
 
-static void dt282x_munge(comedi_device * dev, short * buf,
+static void dt282x_munge(struct comedi_device * dev, short * buf,
 	unsigned int nbytes)
 {
 	unsigned int i;
@@ -440,7 +440,7 @@ static void dt282x_munge(comedi_device * dev, short * buf,
 	}
 }
 
-static void dt282x_ao_dma_interrupt(comedi_device * dev)
+static void dt282x_ao_dma_interrupt(struct comedi_device * dev)
 {
 	void *ptr;
 	int size;
@@ -472,7 +472,7 @@ static void dt282x_ao_dma_interrupt(comedi_device * dev)
 	return;
 }
 
-static void dt282x_ai_dma_interrupt(comedi_device * dev)
+static void dt282x_ai_dma_interrupt(struct comedi_device * dev)
 {
 	void *ptr;
 	int size;
@@ -524,7 +524,7 @@ static void dt282x_ai_dma_interrupt(comedi_device * dev)
 	prep_ai_dma(dev, i, 0);
 }
 
-static int prep_ai_dma(comedi_device * dev, int dma_index, int n)
+static int prep_ai_dma(struct comedi_device * dev, int dma_index, int n)
 {
 	int dma_chan;
 	unsigned long dma_ptr;
@@ -555,7 +555,7 @@ static int prep_ai_dma(comedi_device * dev, int dma_index, int n)
 	return n;
 }
 
-static int prep_ao_dma(comedi_device * dev, int dma_index, int n)
+static int prep_ao_dma(struct comedi_device * dev, int dma_index, int n)
 {
 	int dma_chan;
 	unsigned long dma_ptr;
@@ -579,7 +579,7 @@ static int prep_ao_dma(comedi_device * dev, int dma_index, int n)
 
 static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	comedi_subdevice *s;
 	comedi_subdevice *s_ao;
 	unsigned int supcsr, adcsr, dacsr;
@@ -653,7 +653,7 @@ static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_RETVAL(handled);
 }
 
-static void dt282x_load_changain(comedi_device * dev, int n,
+static void dt282x_load_changain(struct comedi_device * dev, int n,
 	unsigned int *chanlist)
 {
 	unsigned int i;
@@ -674,7 +674,7 @@ static void dt282x_load_changain(comedi_device * dev, int n,
  *      - preload multiplexer
  *      - trigger conversion and wait for it to finish
  */
-static int dt282x_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ai_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int i;
@@ -706,7 +706,7 @@ static int dt282x_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int dt282x_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -818,7 +818,7 @@ static int dt282x_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int dt282x_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	int timer;
@@ -879,7 +879,7 @@ static int dt282x_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static void dt282x_disable_dma(comedi_device * dev)
+static void dt282x_disable_dma(struct comedi_device * dev)
 {
 	if (devpriv->usedma) {
 		disable_dma(devpriv->dma[0].chan);
@@ -887,7 +887,7 @@ static void dt282x_disable_dma(comedi_device * dev)
 	}
 }
 
-static int dt282x_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ai_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dt282x_disable_dma(dev);
 
@@ -937,7 +937,7 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      offset binary if necessary, loads the data into the DAC
  *      data register, and performs the conversion.
  */
-static int dt282x_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_insn_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
@@ -945,7 +945,7 @@ static int dt282x_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dt282x_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_insn_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	short d;
@@ -978,7 +978,7 @@ static int dt282x_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dt282x_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1069,7 +1069,7 @@ static int dt282x_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
 
 }
 
-static int dt282x_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int x)
 {
 	int size;
@@ -1099,7 +1099,7 @@ static int dt282x_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int dt282x_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	int timer;
 	comedi_cmd *cmd = &s->async->cmd;
@@ -1132,7 +1132,7 @@ static int dt282x_ao_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+static int dt282x_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dt282x_disable_dma(dev);
 
@@ -1145,7 +1145,7 @@ static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int dt282x_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_dio_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
@@ -1159,7 +1159,7 @@ static int dt282x_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int dt282x_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+static int dt282x_dio_insn_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int mask;
@@ -1240,7 +1240,7 @@ enum { opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,	/* i/o base, irq, dma channe
    9	ao0 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
    10	ao1 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
  */
-static int dt282x_attach(comedi_device * dev, comedi_devconfig * it)
+static int dt282x_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	int i, irq;
 	int ret;
@@ -1396,7 +1396,7 @@ static int dt282x_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static void free_resources(comedi_device * dev)
+static void free_resources(struct comedi_device * dev)
 {
 	if (dev->irq) {
 		comedi_free_irq(dev->irq, dev);
@@ -1415,7 +1415,7 @@ static void free_resources(comedi_device * dev)
 	}
 }
 
-static int dt282x_detach(comedi_device * dev)
+static int dt282x_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: dt282x: remove\n", dev->minor);
 
@@ -1424,7 +1424,7 @@ static int dt282x_detach(comedi_device * dev)
 	return 0;
 }
 
-static int dt282x_grab_dma(comedi_device * dev, int dma1, int dma2)
+static int dt282x_grab_dma(struct comedi_device * dev, int dma1, int dma2)
 {
 	int ret;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
index 28eadea2a424..5cdd577475da 100644
--- a/drivers/staging/comedi/drivers/dt282x.c
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -347,7 +347,7 @@ typedef struct {
 
 	const comedi_lrange *darangelist[2];
 
-	sampl_t ao[2];
+	short ao[2];
 
 	volatile int dacsr;	/* software copies of registers */
 	volatile int adcsr;
@@ -418,7 +418,7 @@ static void dt282x_disable_dma(comedi_device * dev);
 
 static int dt282x_grab_dma(comedi_device * dev, int dma1, int dma2);
 
-static void dt282x_munge(comedi_device * dev, sampl_t * buf,
+static void dt282x_munge(comedi_device * dev, short * buf,
 	unsigned int nbytes)
 {
 	unsigned int i;
@@ -626,9 +626,9 @@ static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
 #if 0
 	if (adcsr & DT2821_ADDONE) {
 		int ret;
-		sampl_t data;
+		short data;
 
-		data = (sampl_t) inw(dev->iobase + DT2821_ADDAT);
+		data = (short) inw(dev->iobase + DT2821_ADDAT);
 		data &= (1 << boardtype.adbits) - 1;
 		if (devpriv->ad_2scomp) {
 			data ^= 1 << (boardtype.adbits - 1);
@@ -675,7 +675,7 @@ static void dt282x_load_changain(comedi_device * dev, int n,
  *      - trigger conversion and wait for it to finish
  */
 static int dt282x_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int i;
 
@@ -938,7 +938,7 @@ static int dt282x_ns_to_timer(int *nanosec, int round_mode)
  *      data register, and performs the conversion.
  */
 static int dt282x_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
 
@@ -946,9 +946,9 @@ static int dt282x_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int dt282x_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
-	sampl_t d;
+	short d;
 	unsigned int chan;
 
 	chan = CR_CHAN(insn->chanspec);
@@ -1146,7 +1146,7 @@ static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s)
 }
 
 static int dt282x_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	if (data[0]) {
 		s->state &= ~data[0];
@@ -1160,7 +1160,7 @@ static int dt282x_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int dt282x_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int mask;
 

commit 8d3d823c74a4c967b4a02e6466c6727ad21422a0
Author: David Schleef <ds@schleef.org>
Date:   Thu Feb 19 10:10:52 2009 -0800

    Staging: comedi: add dt282x driver
    
    Driver for DataTranslation DT2821 series cards
    
    From: David Schleef <ds@schleef.org>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/dt282x.c b/drivers/staging/comedi/drivers/dt282x.c
new file mode 100644
index 000000000000..28eadea2a424
--- /dev/null
+++ b/drivers/staging/comedi/drivers/dt282x.c
@@ -0,0 +1,1471 @@
+/*
+   comedi/drivers/dt282x.c
+   Hardware driver for Data Translation DT2821 series
+
+   COMEDI - Linux Control and Measurement Device Interface
+   Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+ */
+/*
+Driver: dt282x
+Description: Data Translation DT2821 series (including DT-EZ)
+Author: ds
+Devices: [Data Translation] DT2821 (dt2821),
+  DT2821-F-16SE (dt2821-f), DT2821-F-8DI (dt2821-f),
+  DT2821-G-16SE (dt2821-f), DT2821-G-8DI (dt2821-g),
+  DT2823 (dt2823),
+  DT2824-PGH (dt2824-pgh), DT2824-PGL (dt2824-pgl), DT2825 (dt2825),
+  DT2827 (dt2827), DT2828 (dt2828), DT21-EZ (dt21-ez), DT23-EZ (dt23-ez),
+  DT24-EZ (dt24-ez), DT24-EZ-PGL (dt24-ez-pgl)
+Status: complete
+Updated: Wed, 22 Aug 2001 17:11:34 -0700
+
+Configuration options:
+  [0] - I/O port base address
+  [1] - IRQ
+  [2] - DMA 1
+  [3] - DMA 2
+  [4] - AI jumpered for 0=single ended, 1=differential
+  [5] - AI jumpered for 0=straight binary, 1=2's complement
+  [6] - AO 0 jumpered for 0=straight binary, 1=2's complement
+  [7] - AO 1 jumpered for 0=straight binary, 1=2's complement
+  [8] - AI jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5]
+  [9] - AO 0 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
+        4=[-2.5,2.5]
+  [10]- A0 1 jumpered for 0=[-10,10]V, 1=[0,10], 2=[-5,5], 3=[0,5],
+        4=[-2.5,2.5]
+
+Notes:
+  - AO commands might be broken.
+  - If you try to run a command on both the AI and AO subdevices
+    simultaneously, bad things will happen.  The driver needs to
+    be fixed to check for this situation and return an error.
+*/
+
+#include "../comedidev.h"
+
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include "comedi_fc.h"
+
+#define DEBUG
+
+#define DT2821_TIMEOUT		100	/* 500 us */
+#define DT2821_SIZE 0x10
+
+/*
+ *    Registers in the DT282x
+ */
+
+#define DT2821_ADCSR	0x00	/* A/D Control/Status             */
+#define DT2821_CHANCSR	0x02	/* Channel Control/Status */
+#define DT2821_ADDAT	0x04	/* A/D data                       */
+#define DT2821_DACSR	0x06	/* D/A Control/Status             */
+#define DT2821_DADAT	0x08	/* D/A data                       */
+#define DT2821_DIODAT	0x0a	/* digital data                   */
+#define DT2821_SUPCSR	0x0c	/* Supervisor Control/Status      */
+#define DT2821_TMRCTR	0x0e	/* Timer/Counter          */
+
+/*
+ *  At power up, some registers are in a well-known state.  The
+ *  masks and values are as follows:
+ */
+
+#define DT2821_ADCSR_MASK 0xfff0
+#define DT2821_ADCSR_VAL 0x7c00
+
+#define DT2821_CHANCSR_MASK 0xf0f0
+#define DT2821_CHANCSR_VAL 0x70f0
+
+#define DT2821_DACSR_MASK 0x7c93
+#define DT2821_DACSR_VAL 0x7c90
+
+#define DT2821_SUPCSR_MASK 0xf8ff
+#define DT2821_SUPCSR_VAL 0x0000
+
+#define DT2821_TMRCTR_MASK 0xff00
+#define DT2821_TMRCTR_VAL 0xf000
+
+/*
+ *    Bit fields of each register
+ */
+
+/* ADCSR */
+
+#define DT2821_ADERR	0x8000	/* (R)   1 for A/D error  */
+#define DT2821_ADCLK	0x0200	/* (R/W) A/D clock enable */
+		/*      0x7c00           read as 1's            */
+#define DT2821_MUXBUSY	0x0100	/* (R)   multiplexer busy */
+#define DT2821_ADDONE	0x0080	/* (R)   A/D done         */
+#define DT2821_IADDONE	0x0040	/* (R/W) interrupt on A/D done    */
+		/*      0x0030           gain select            */
+		/*      0x000f           channel select         */
+
+/* CHANCSR */
+
+#define DT2821_LLE	0x8000	/* (R/W) Load List Enable */
+		/*      0x7000           read as 1's            */
+		/*      0x0f00     (R)   present address        */
+		/*      0x00f0           read as 1's            */
+		/*      0x000f     (R)   number of entries - 1  */
+
+/* DACSR */
+
+#define DT2821_DAERR	0x8000	/* (R)   D/A error                */
+#define DT2821_YSEL	0x0200	/* (R/W) DAC 1 select             */
+#define DT2821_SSEL	0x0100	/* (R/W) single channel select    */
+#define DT2821_DACRDY	0x0080	/* (R)   DAC ready                */
+#define DT2821_IDARDY	0x0040	/* (R/W) interrupt on DAC ready   */
+#define DT2821_DACLK	0x0020	/* (R/W) D/A clock enable */
+#define DT2821_HBOE	0x0002	/* (R/W) DIO high byte output enable      */
+#define DT2821_LBOE	0x0001	/* (R/W) DIO low byte output enable       */
+
+/* SUPCSR */
+
+#define DT2821_DMAD	0x8000	/* (R)   DMA done                 */
+#define DT2821_ERRINTEN	0x4000	/* (R/W) interrupt on error               */
+#define DT2821_CLRDMADNE 0x2000	/* (W)   clear DMA done                   */
+#define DT2821_DDMA	0x1000	/* (R/W) dual DMA                 */
+#define DT2821_DS1	0x0800	/* (R/W) DMA select 1                     */
+#define DT2821_DS0	0x0400	/* (R/W) DMA select 0                     */
+#define DT2821_BUFFB	0x0200	/* (R/W) buffer B selected                */
+#define DT2821_SCDN	0x0100	/* (R)   scan done                        */
+#define DT2821_DACON	0x0080	/* (W)   DAC single conversion            */
+#define DT2821_ADCINIT	0x0040	/* (W)   A/D initialize                   */
+#define DT2821_DACINIT	0x0020	/* (W)   D/A initialize                   */
+#define DT2821_PRLD	0x0010	/* (W)   preload multiplexer              */
+#define DT2821_STRIG	0x0008	/* (W)   software trigger         */
+#define DT2821_XTRIG	0x0004	/* (R/W) external trigger enable  */
+#define DT2821_XCLK	0x0002	/* (R/W) external clock enable            */
+#define DT2821_BDINIT	0x0001	/* (W)   initialize board         */
+
+static const comedi_lrange range_dt282x_ai_lo_bipolar = { 4, {
+			RANGE(-10, 10),
+			RANGE(-5, 5),
+			RANGE(-2.5, 2.5),
+			RANGE(-1.25, 1.25)
+	}
+};
+static const comedi_lrange range_dt282x_ai_lo_unipolar = { 4, {
+			RANGE(0, 10),
+			RANGE(0, 5),
+			RANGE(0, 2.5),
+			RANGE(0, 1.25)
+	}
+};
+static const comedi_lrange range_dt282x_ai_5_bipolar = { 4, {
+			RANGE(-5, 5),
+			RANGE(-2.5, 2.5),
+			RANGE(-1.25, 1.25),
+			RANGE(-0.625, 0.625),
+	}
+};
+static const comedi_lrange range_dt282x_ai_5_unipolar = { 4, {
+			RANGE(0, 5),
+			RANGE(0, 2.5),
+			RANGE(0, 1.25),
+			RANGE(0, 0.625),
+	}
+};
+static const comedi_lrange range_dt282x_ai_hi_bipolar = { 4, {
+			RANGE(-10, 10),
+			RANGE(-1, 1),
+			RANGE(-0.1, 0.1),
+			RANGE(-0.02, 0.02)
+	}
+};
+static const comedi_lrange range_dt282x_ai_hi_unipolar = { 4, {
+			RANGE(0, 10),
+			RANGE(0, 1),
+			RANGE(0, 0.1),
+			RANGE(0, 0.02)
+	}
+};
+
+typedef struct {
+	const char *name;
+	int adbits;
+	int adchan_se;
+	int adchan_di;
+	int ai_speed;
+	int ispgl;
+	int dachan;
+	int dabits;
+} boardtype_t;
+
+static const boardtype_t boardtypes[] = {
+      {name:"dt2821",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:20000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2821-f",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:6500,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2821-g",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:4000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2823",
+	      adbits:	16,
+	      adchan_se:0,
+	      adchan_di:4,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	16,
+		},
+      {name:"dt2824-pgh",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:20000,
+	      ispgl:	0,
+	      dachan:	0,
+	      dabits:	0,
+		},
+      {name:"dt2824-pgl",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:20000,
+	      ispgl:	1,
+	      dachan:	0,
+	      dabits:	0,
+		},
+      {name:"dt2825",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:20000,
+	      ispgl:	1,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2827",
+	      adbits:	16,
+	      adchan_se:0,
+	      adchan_di:4,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2828",
+	      adbits:	12,
+	      adchan_se:4,
+	      adchan_di:0,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt2829",
+	      adbits:	16,
+	      adchan_se:8,
+	      adchan_di:0,
+	      ai_speed:33250,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	16,
+		},
+      {name:"dt21-ez",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	2,
+	      dabits:	12,
+		},
+      {name:"dt23-ez",
+	      adbits:	16,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	0,
+	      dabits:	0,
+		},
+      {name:"dt24-ez",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:10000,
+	      ispgl:	0,
+	      dachan:	0,
+	      dabits:	0,
+		},
+      {name:"dt24-ez-pgl",
+	      adbits:	12,
+	      adchan_se:16,
+	      adchan_di:8,
+	      ai_speed:10000,
+	      ispgl:	1,
+	      dachan:	0,
+	      dabits:	0,
+		},
+};
+
+#define n_boardtypes sizeof(boardtypes)/sizeof(boardtype_t)
+#define this_board ((const boardtype_t *)dev->board_ptr)
+
+typedef struct {
+	int ad_2scomp;		/* we have 2's comp jumper set  */
+	int da0_2scomp;		/* same, for DAC0               */
+	int da1_2scomp;		/* same, for DAC1               */
+
+	const comedi_lrange *darangelist[2];
+
+	sampl_t ao[2];
+
+	volatile int dacsr;	/* software copies of registers */
+	volatile int adcsr;
+	volatile int supcsr;
+
+	volatile int ntrig;
+	volatile int nread;
+
+	struct {
+		int chan;
+		short *buf;	/* DMA buffer */
+		volatile int size;	/* size of current transfer */
+	} dma[2];
+	int dma_maxsize;	/* max size of DMA transfer (in bytes) */
+	int usedma;		/* driver uses DMA              */
+	volatile int current_dma_index;
+	int dma_dir;
+} dt282x_private;
+
+#define devpriv ((dt282x_private *)dev->private)
+#define boardtype (*(const boardtype_t *)dev->board_ptr)
+
+/*
+ *    Some useless abstractions
+ */
+#define chan_to_DAC(a)	((a)&1)
+#define update_dacsr(a)	outw(devpriv->dacsr|(a),dev->iobase+DT2821_DACSR)
+#define update_adcsr(a)	outw(devpriv->adcsr|(a),dev->iobase+DT2821_ADCSR)
+#define mux_busy() (inw(dev->iobase+DT2821_ADCSR)&DT2821_MUXBUSY)
+#define ad_done() (inw(dev->iobase+DT2821_ADCSR)&DT2821_ADDONE)
+#define update_supcsr(a)	outw(devpriv->supcsr|(a),dev->iobase+DT2821_SUPCSR)
+
+/*
+ *    danger! macro abuse... a is the expression to wait on, and b is
+ *      the statement(s) to execute if it doesn't happen.
+ */
+#define wait_for(a,b)	 				\
+	do{						\
+		int _i;					\
+		for(_i=0;_i<DT2821_TIMEOUT;_i++){	\
+			if(a){_i=0;break;}		\
+			comedi_udelay(5);			\
+		}					\
+		if(_i){b}				\
+	}while(0)
+
+static int dt282x_attach(comedi_device * dev, comedi_devconfig * it);
+static int dt282x_detach(comedi_device * dev);
+static comedi_driver driver_dt282x = {
+      driver_name:"dt282x",
+      module:THIS_MODULE,
+      attach:dt282x_attach,
+      detach:dt282x_detach,
+      board_name:&boardtypes[0].name,
+      num_names:n_boardtypes,
+      offset:sizeof(boardtype_t),
+};
+
+COMEDI_INITCLEANUP(driver_dt282x);
+
+static void free_resources(comedi_device * dev);
+static int prep_ai_dma(comedi_device * dev, int chan, int size);
+static int prep_ao_dma(comedi_device * dev, int chan, int size);
+static int dt282x_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static int dt282x_ns_to_timer(int *nanosec, int round_mode);
+static void dt282x_disable_dma(comedi_device * dev);
+
+static int dt282x_grab_dma(comedi_device * dev, int dma1, int dma2);
+
+static void dt282x_munge(comedi_device * dev, sampl_t * buf,
+	unsigned int nbytes)
+{
+	unsigned int i;
+	unsigned short mask = (1 << boardtype.adbits) - 1;
+	unsigned short sign = 1 << (boardtype.adbits - 1);
+	int n;
+
+	if (devpriv->ad_2scomp) {
+		sign = 1 << (boardtype.adbits - 1);
+	} else {
+		sign = 0;
+	}
+
+	if (nbytes % 2)
+		comedi_error(dev, "bug! odd number of bytes from dma xfer");
+	n = nbytes / 2;
+	for (i = 0; i < n; i++) {
+		buf[i] = (buf[i] & mask) ^ sign;
+	}
+}
+
+static void dt282x_ao_dma_interrupt(comedi_device * dev)
+{
+	void *ptr;
+	int size;
+	int i;
+	comedi_subdevice *s = dev->subdevices + 1;
+
+	update_supcsr(DT2821_CLRDMADNE);
+
+	if (!s->async->prealloc_buf) {
+		printk("async->data disappeared.  dang!\n");
+		return;
+	}
+
+	i = devpriv->current_dma_index;
+	ptr = devpriv->dma[i].buf;
+
+	disable_dma(devpriv->dma[i].chan);
+
+	devpriv->current_dma_index = 1 - i;
+
+	size = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);
+	if (size == 0) {
+		rt_printk("dt282x: AO underrun\n");
+		dt282x_ao_cancel(dev, s);
+		s->async->events |= COMEDI_CB_OVERFLOW;
+		return;
+	}
+	prep_ao_dma(dev, i, size);
+	return;
+}
+
+static void dt282x_ai_dma_interrupt(comedi_device * dev)
+{
+	void *ptr;
+	int size;
+	int i;
+	int ret;
+	comedi_subdevice *s = dev->subdevices;
+
+	update_supcsr(DT2821_CLRDMADNE);
+
+	if (!s->async->prealloc_buf) {
+		printk("async->data disappeared.  dang!\n");
+		return;
+	}
+
+	i = devpriv->current_dma_index;
+	ptr = devpriv->dma[i].buf;
+	size = devpriv->dma[i].size;
+
+	disable_dma(devpriv->dma[i].chan);
+
+	devpriv->current_dma_index = 1 - i;
+
+	dt282x_munge(dev, ptr, size);
+	ret = cfc_write_array_to_buffer(s, ptr, size);
+	if (ret != size) {
+		dt282x_ai_cancel(dev, s);
+		return;
+	}
+	devpriv->nread -= size / 2;
+
+	if (devpriv->nread < 0) {
+		printk("dt282x: off by one\n");
+		devpriv->nread = 0;
+	}
+	if (!devpriv->nread) {
+		dt282x_ai_cancel(dev, s);
+		s->async->events |= COMEDI_CB_EOA;
+		return;
+	}
+#if 0
+	/* clear the dual dma flag, making this the last dma segment */
+	/* XXX probably wrong */
+	if (!devpriv->ntrig) {
+		devpriv->supcsr &= ~(DT2821_DDMA);
+		update_supcsr(0);
+	}
+#endif
+	/* restart the channel */
+	prep_ai_dma(dev, i, 0);
+}
+
+static int prep_ai_dma(comedi_device * dev, int dma_index, int n)
+{
+	int dma_chan;
+	unsigned long dma_ptr;
+	unsigned long flags;
+
+	if (!devpriv->ntrig)
+		return 0;
+
+	if (n == 0)
+		n = devpriv->dma_maxsize;
+	if (n > devpriv->ntrig * 2)
+		n = devpriv->ntrig * 2;
+	devpriv->ntrig -= n / 2;
+
+	devpriv->dma[dma_index].size = n;
+	dma_chan = devpriv->dma[dma_index].chan;
+	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+
+	set_dma_mode(dma_chan, DMA_MODE_READ);
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_addr(dma_chan, dma_ptr);
+	set_dma_count(dma_chan, n);
+	release_dma_lock(flags);
+
+	enable_dma(dma_chan);
+
+	return n;
+}
+
+static int prep_ao_dma(comedi_device * dev, int dma_index, int n)
+{
+	int dma_chan;
+	unsigned long dma_ptr;
+	unsigned long flags;
+
+	devpriv->dma[dma_index].size = n;
+	dma_chan = devpriv->dma[dma_index].chan;
+	dma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);
+
+	set_dma_mode(dma_chan, DMA_MODE_WRITE);
+	flags = claim_dma_lock();
+	clear_dma_ff(dma_chan);
+	set_dma_addr(dma_chan, dma_ptr);
+	set_dma_count(dma_chan, n);
+	release_dma_lock(flags);
+
+	enable_dma(dma_chan);
+
+	return n;
+}
+
+static irqreturn_t dt282x_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	comedi_subdevice *s;
+	comedi_subdevice *s_ao;
+	unsigned int supcsr, adcsr, dacsr;
+	int handled = 0;
+
+	if (!dev->attached) {
+		comedi_error(dev, "spurious interrupt");
+		return IRQ_HANDLED;
+	}
+
+	s = dev->subdevices + 0;
+	s_ao = dev->subdevices + 1;
+	adcsr = inw(dev->iobase + DT2821_ADCSR);
+	dacsr = inw(dev->iobase + DT2821_DACSR);
+	supcsr = inw(dev->iobase + DT2821_SUPCSR);
+	if (supcsr & DT2821_DMAD) {
+		if (devpriv->dma_dir == DMA_MODE_READ)
+			dt282x_ai_dma_interrupt(dev);
+		else
+			dt282x_ao_dma_interrupt(dev);
+		handled = 1;
+	}
+	if (adcsr & DT2821_ADERR) {
+		if (devpriv->nread != 0) {
+			comedi_error(dev, "A/D error");
+			dt282x_ai_cancel(dev, s);
+			s->async->events |= COMEDI_CB_ERROR;
+		}
+		handled = 1;
+	}
+	if (dacsr & DT2821_DAERR) {
+#if 0
+		static int warn = 5;
+		if (--warn <= 0) {
+			disable_irq(dev->irq);
+			printk("disabling irq\n");
+		}
+#endif
+		comedi_error(dev, "D/A error");
+		dt282x_ao_cancel(dev, s_ao);
+		s->async->events |= COMEDI_CB_ERROR;
+		handled = 1;
+	}
+#if 0
+	if (adcsr & DT2821_ADDONE) {
+		int ret;
+		sampl_t data;
+
+		data = (sampl_t) inw(dev->iobase + DT2821_ADDAT);
+		data &= (1 << boardtype.adbits) - 1;
+		if (devpriv->ad_2scomp) {
+			data ^= 1 << (boardtype.adbits - 1);
+		}
+		ret = comedi_buf_put(s->async, data);
+		if (ret == 0) {
+			s->async->events |= COMEDI_CB_OVERFLOW;
+		}
+
+		devpriv->nread--;
+		if (!devpriv->nread) {
+			s->async->events |= COMEDI_CB_EOA;
+		} else {
+			if (supcsr & DT2821_SCDN)
+				update_supcsr(DT2821_STRIG);
+		}
+		handled = 1;
+	}
+#endif
+	comedi_event(dev, s);
+	/* printk("adcsr=0x%02x dacsr-0x%02x supcsr=0x%02x\n", adcsr, dacsr, supcsr); */
+	return IRQ_RETVAL(handled);
+}
+
+static void dt282x_load_changain(comedi_device * dev, int n,
+	unsigned int *chanlist)
+{
+	unsigned int i;
+	unsigned int chan, range;
+
+	outw(DT2821_LLE | (n - 1), dev->iobase + DT2821_CHANCSR);
+	for (i = 0; i < n; i++) {
+		chan = CR_CHAN(chanlist[i]);
+		range = CR_RANGE(chanlist[i]);
+		update_adcsr((range << 4) | (chan));
+	}
+	outw(n - 1, dev->iobase + DT2821_CHANCSR);
+}
+
+/*
+ *    Performs a single A/D conversion.
+ *      - Put channel/gain into channel-gain list
+ *      - preload multiplexer
+ *      - trigger conversion and wait for it to finish
+ */
+static int dt282x_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int i;
+
+	/* XXX should we really be enabling the ad clock here? */
+	devpriv->adcsr = DT2821_ADCLK;
+	update_adcsr(0);
+
+	dt282x_load_changain(dev, 1, &insn->chanspec);
+
+	update_supcsr(DT2821_PRLD);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
+		return -ETIME;
+		);
+
+	for (i = 0; i < insn->n; i++) {
+		update_supcsr(DT2821_STRIG);
+		wait_for(ad_done(), comedi_error(dev, "timeout\n");
+			return -ETIME;
+			);
+
+		data[i] =
+			inw(dev->iobase +
+			DT2821_ADDAT) & ((1 << boardtype.adbits) - 1);
+		if (devpriv->ad_2scomp)
+			data[i] ^= (1 << (boardtype.adbits - 1));
+	}
+
+	return i;
+}
+
+static int dt282x_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	} else {
+		/* external trigger */
+		/* should be level/edge, hi/lo specification here */
+		if (cmd->scan_begin_arg != 0) {
+			cmd->scan_begin_arg = 0;
+			err++;
+		}
+	}
+	if (cmd->convert_arg < 4000) {
+		/* XXX board dependent */
+		cmd->convert_arg = 4000;
+		err++;
+	}
+#define SLOWEST_TIMER	(250*(1<<15)*255)
+	if (cmd->convert_arg > SLOWEST_TIMER) {
+		cmd->convert_arg = SLOWEST_TIMER;
+		err++;
+	}
+	if (cmd->convert_arg < this_board->ai_speed) {
+		cmd->convert_arg = this_board->ai_speed;
+		err++;
+	}
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	tmp = cmd->convert_arg;
+	dt282x_ns_to_timer(&cmd->convert_arg, cmd->flags & TRIG_ROUND_MASK);
+	if (tmp != cmd->convert_arg)
+		err++;
+
+	if (err)
+		return 4;
+
+	return 0;
+}
+
+static int dt282x_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	int timer;
+
+	if (devpriv->usedma == 0) {
+		comedi_error(dev,
+			"driver requires 2 dma channels to execute command");
+		return -EIO;
+	}
+
+	dt282x_disable_dma(dev);
+
+	if (cmd->convert_arg < this_board->ai_speed)
+		cmd->convert_arg = this_board->ai_speed;
+	timer = dt282x_ns_to_timer(&cmd->convert_arg, TRIG_ROUND_NEAREST);
+	outw(timer, dev->iobase + DT2821_TMRCTR);
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		/* internal trigger */
+		devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0;
+	} else {
+		/* external trigger */
+		devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0 | DT2821_DS1;
+	}
+	update_supcsr(DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_ADCINIT);
+
+	devpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;
+	devpriv->nread = devpriv->ntrig;
+
+	devpriv->dma_dir = DMA_MODE_READ;
+	devpriv->current_dma_index = 0;
+	prep_ai_dma(dev, 0, 0);
+	if (devpriv->ntrig) {
+		prep_ai_dma(dev, 1, 0);
+		devpriv->supcsr |= DT2821_DDMA;
+		update_supcsr(0);
+	}
+
+	devpriv->adcsr = 0;
+
+	dt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);
+
+	devpriv->adcsr = DT2821_ADCLK | DT2821_IADDONE;
+	update_adcsr(0);
+
+	update_supcsr(DT2821_PRLD);
+	wait_for(!mux_busy(), comedi_error(dev, "timeout\n");
+		return -ETIME;
+		);
+
+	if (cmd->scan_begin_src == TRIG_FOLLOW) {
+		update_supcsr(DT2821_STRIG);
+	} else {
+		devpriv->supcsr |= DT2821_XTRIG;
+		update_supcsr(0);
+	}
+
+	return 0;
+}
+
+static void dt282x_disable_dma(comedi_device * dev)
+{
+	if (devpriv->usedma) {
+		disable_dma(devpriv->dma[0].chan);
+		disable_dma(devpriv->dma[1].chan);
+	}
+}
+
+static int dt282x_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	dt282x_disable_dma(dev);
+
+	devpriv->adcsr = 0;
+	update_adcsr(0);
+
+	devpriv->supcsr = 0;
+	update_supcsr(DT2821_ADCINIT);
+
+	return 0;
+}
+
+static int dt282x_ns_to_timer(int *nanosec, int round_mode)
+{
+	int prescale, base, divider;
+
+	for (prescale = 0; prescale < 16; prescale++) {
+		if (prescale == 1)
+			continue;
+		base = 250 * (1 << prescale);
+		switch (round_mode) {
+		case TRIG_ROUND_NEAREST:
+		default:
+			divider = (*nanosec + base / 2) / base;
+			break;
+		case TRIG_ROUND_DOWN:
+			divider = (*nanosec) / base;
+			break;
+		case TRIG_ROUND_UP:
+			divider = (*nanosec + base - 1) / base;
+			break;
+		}
+		if (divider < 256) {
+			*nanosec = divider * base;
+			return (prescale << 8) | (255 - divider);
+		}
+	}
+	base = 250 * (1 << 15);
+	divider = 255;
+	*nanosec = divider * base;
+	return (15 << 8) | (255 - divider);
+}
+
+/*
+ *    Analog output routine.  Selects single channel conversion,
+ *      selects correct channel, converts from 2's compliment to
+ *      offset binary if necessary, loads the data into the DAC
+ *      data register, and performs the conversion.
+ */
+static int dt282x_ao_insn_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->ao[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int dt282x_ao_insn_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	sampl_t d;
+	unsigned int chan;
+
+	chan = CR_CHAN(insn->chanspec);
+	d = data[0];
+	d &= (1 << boardtype.dabits) - 1;
+	devpriv->ao[chan] = d;
+
+	devpriv->dacsr |= DT2821_SSEL;
+
+	if (chan) {
+		/* select channel */
+		devpriv->dacsr |= DT2821_YSEL;
+		if (devpriv->da0_2scomp)
+			d ^= (1 << (boardtype.dabits - 1));
+	} else {
+		devpriv->dacsr &= ~DT2821_YSEL;
+		if (devpriv->da1_2scomp)
+			d ^= (1 << (boardtype.dabits - 1));
+	}
+
+	update_dacsr(0);
+
+	outw(d, dev->iobase + DT2821_DADAT);
+
+	update_supcsr(DT2821_DACON);
+
+	return 1;
+}
+
+static int dt282x_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* note that mutual compatiblity is not an issue here */
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+	if (cmd->scan_begin_arg < 5000 /* XXX unknown */ ) {
+		cmd->scan_begin_arg = 5000;
+		err++;
+	}
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+	if (cmd->scan_end_arg > 2) {
+		/* XXX chanlist stuff? */
+		cmd->scan_end_arg = 2;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_COUNT) {
+		/* any count is allowed */
+	} else {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	tmp = cmd->scan_begin_arg;
+	dt282x_ns_to_timer(&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);
+	if (tmp != cmd->scan_begin_arg)
+		err++;
+
+	if (err)
+		return 4;
+
+	return 0;
+
+}
+
+static int dt282x_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int x)
+{
+	int size;
+
+	if (x != 0)
+		return -EINVAL;
+
+	size = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,
+		devpriv->dma_maxsize);
+	if (size == 0) {
+		rt_printk("dt282x: AO underrun\n");
+		return -EPIPE;
+	}
+	prep_ao_dma(dev, 0, size);
+
+	size = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,
+		devpriv->dma_maxsize);
+	if (size == 0) {
+		rt_printk("dt282x: AO underrun\n");
+		return -EPIPE;
+	}
+	prep_ao_dma(dev, 1, size);
+
+	update_supcsr(DT2821_STRIG);
+	s->async->inttrig = NULL;
+
+	return 1;
+}
+
+static int dt282x_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	int timer;
+	comedi_cmd *cmd = &s->async->cmd;
+
+	if (devpriv->usedma == 0) {
+		comedi_error(dev,
+			"driver requires 2 dma channels to execute command");
+		return -EIO;
+	}
+
+	dt282x_disable_dma(dev);
+
+	devpriv->supcsr = DT2821_ERRINTEN | DT2821_DS1 | DT2821_DDMA;
+	update_supcsr(DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_DACINIT);
+
+	devpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;
+	devpriv->nread = devpriv->ntrig;
+
+	devpriv->dma_dir = DMA_MODE_WRITE;
+	devpriv->current_dma_index = 0;
+
+	timer = dt282x_ns_to_timer(&cmd->scan_begin_arg, TRIG_ROUND_NEAREST);
+	outw(timer, dev->iobase + DT2821_TMRCTR);
+
+	devpriv->dacsr = DT2821_SSEL | DT2821_DACLK | DT2821_IDARDY;
+	update_dacsr(0);
+
+	s->async->inttrig = dt282x_ao_inttrig;
+
+	return 0;
+}
+
+static int dt282x_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	dt282x_disable_dma(dev);
+
+	devpriv->dacsr = 0;
+	update_dacsr(0);
+
+	devpriv->supcsr = 0;
+	update_supcsr(DT2821_DACINIT);
+
+	return 0;
+}
+
+static int dt282x_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+
+		outw(s->state, dev->iobase + DT2821_DIODAT);
+	}
+	data[1] = inw(dev->iobase + DT2821_DIODAT);
+
+	return 2;
+}
+
+static int dt282x_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int mask;
+
+	mask = (CR_CHAN(insn->chanspec) < 8) ? 0x00ff : 0xff00;
+	if (data[0])
+		s->io_bits |= mask;
+	else
+		s->io_bits &= ~mask;
+
+	if (s->io_bits & 0x00ff)
+		devpriv->dacsr |= DT2821_LBOE;
+	else
+		devpriv->dacsr &= ~DT2821_LBOE;
+	if (s->io_bits & 0xff00)
+		devpriv->dacsr |= DT2821_HBOE;
+	else
+		devpriv->dacsr &= ~DT2821_HBOE;
+
+	outw(devpriv->dacsr, dev->iobase + DT2821_DACSR);
+
+	return 1;
+}
+
+static const comedi_lrange *const ai_range_table[] = {
+	&range_dt282x_ai_lo_bipolar,
+	&range_dt282x_ai_lo_unipolar,
+	&range_dt282x_ai_5_bipolar,
+	&range_dt282x_ai_5_unipolar
+};
+static const comedi_lrange *const ai_range_pgl_table[] = {
+	&range_dt282x_ai_hi_bipolar,
+	&range_dt282x_ai_hi_unipolar
+};
+static const comedi_lrange *opt_ai_range_lkup(int ispgl, int x)
+{
+	if (ispgl) {
+		if (x < 0 || x >= 2)
+			x = 0;
+		return ai_range_pgl_table[x];
+	} else {
+		if (x < 0 || x >= 4)
+			x = 0;
+		return ai_range_table[x];
+	}
+}
+static const comedi_lrange *const ao_range_table[] = {
+	&range_bipolar10,
+	&range_unipolar10,
+	&range_bipolar5,
+	&range_unipolar5,
+	&range_bipolar2_5
+};
+static const comedi_lrange *opt_ao_range_lkup(int x)
+{
+	if (x < 0 || x >= 5)
+		x = 0;
+	return ao_range_table[x];
+}
+
+enum { opt_iobase = 0, opt_irq, opt_dma1, opt_dma2,	/* i/o base, irq, dma channels */
+	opt_diff,		/* differential */
+	opt_ai_twos, opt_ao0_twos, opt_ao1_twos,	/* twos comp */
+	opt_ai_range, opt_ao0_range, opt_ao1_range,	/* range */
+};
+
+/*
+   options:
+   0	i/o base
+   1	irq
+   2	dma1
+   3	dma2
+   4	0=single ended, 1=differential
+   5	ai 0=straight binary, 1=2's comp
+   6	ao0 0=straight binary, 1=2's comp
+   7	ao1 0=straight binary, 1=2's comp
+   8	ai 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V
+   9	ao0 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
+   10	ao1 0=±10 V, 1=0-10 V, 2=±5 V, 3=0-5 V, 4=±2.5 V
+ */
+static int dt282x_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	int i, irq;
+	int ret;
+	comedi_subdevice *s;
+	unsigned long iobase;
+
+	dev->board_name = this_board->name;
+
+	iobase = it->options[opt_iobase];
+	if (!iobase)
+		iobase = 0x240;
+
+	printk("comedi%d: dt282x: 0x%04lx", dev->minor, iobase);
+	if (!request_region(iobase, DT2821_SIZE, "dt282x")) {
+		printk(" I/O port conflict\n");
+		return -EBUSY;
+	}
+	dev->iobase = iobase;
+
+	outw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);
+	i = inw(dev->iobase + DT2821_ADCSR);
+#ifdef DEBUG
+	printk(" fingerprint=%x,%x,%x,%x,%x",
+		inw(dev->iobase + DT2821_ADCSR),
+		inw(dev->iobase + DT2821_CHANCSR),
+		inw(dev->iobase + DT2821_DACSR),
+		inw(dev->iobase + DT2821_SUPCSR),
+		inw(dev->iobase + DT2821_TMRCTR));
+#endif
+
+	if (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)
+			!= DT2821_ADCSR_VAL) ||
+		((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)
+			!= DT2821_CHANCSR_VAL) ||
+		((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)
+			!= DT2821_DACSR_VAL) ||
+		((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)
+			!= DT2821_SUPCSR_VAL) ||
+		((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)
+			!= DT2821_TMRCTR_VAL)) {
+		printk(" board not found");
+		return -EIO;
+	}
+	/* should do board test */
+
+	irq = it->options[opt_irq];
+#if 0
+	if (irq < 0) {
+		unsigned long flags;
+		int irqs;
+
+		save_flags(flags);
+		sti();
+		irqs = probe_irq_on();
+
+		/* trigger interrupt */
+
+		comedi_udelay(100);
+
+		irq = probe_irq_off(irqs);
+		restore_flags(flags);
+		if (0 /* error */ ) {
+			printk(" error probing irq (bad)");
+		}
+	}
+#endif
+	if (irq > 0) {
+		printk(" ( irq = %d )", irq);
+		ret = comedi_request_irq(irq, dt282x_interrupt, 0, "dt282x",
+			dev);
+		if (ret < 0) {
+			printk(" failed to get irq\n");
+			return -EIO;
+		}
+		dev->irq = irq;
+	} else if (irq == 0) {
+		printk(" (no irq)");
+	} else {
+#if 0
+		printk(" (probe returned multiple irqs--bad)");
+#else
+		printk(" (irq probe not implemented)");
+#endif
+	}
+
+	if ((ret = alloc_private(dev, sizeof(dt282x_private))) < 0)
+		return ret;
+
+	ret = dt282x_grab_dma(dev, it->options[opt_dma1],
+		it->options[opt_dma2]);
+	if (ret < 0)
+		return ret;
+
+	if ((ret = alloc_subdevices(dev, 3)) < 0)
+		return ret;
+
+	s = dev->subdevices + 0;
+
+	dev->read_subdev = s;
+	/* ai subdevice */
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_CMD_READ |
+		((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);
+	s->n_chan =
+		(it->options[opt_diff]) ? boardtype.adchan_di : boardtype.
+		adchan_se;
+	s->insn_read = dt282x_ai_insn_read;
+	s->do_cmdtest = dt282x_ai_cmdtest;
+	s->do_cmd = dt282x_ai_cmd;
+	s->cancel = dt282x_ai_cancel;
+	s->maxdata = (1 << boardtype.adbits) - 1;
+	s->len_chanlist = 16;
+	s->range_table =
+		opt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);
+	devpriv->ad_2scomp = it->options[opt_ai_twos];
+
+	s++;
+	if ((s->n_chan = boardtype.dachan)) {
+		/* ao subsystem */
+		s->type = COMEDI_SUBD_AO;
+		dev->write_subdev = s;
+		s->subdev_flags = SDF_WRITABLE | SDF_CMD_WRITE;
+		s->insn_read = dt282x_ao_insn_read;
+		s->insn_write = dt282x_ao_insn_write;
+		s->do_cmdtest = dt282x_ao_cmdtest;
+		s->do_cmd = dt282x_ao_cmd;
+		s->cancel = dt282x_ao_cancel;
+		s->maxdata = (1 << boardtype.dabits) - 1;
+		s->len_chanlist = 2;
+		s->range_table_list = devpriv->darangelist;
+		devpriv->darangelist[0] =
+			opt_ao_range_lkup(it->options[opt_ao0_range]);
+		devpriv->darangelist[1] =
+			opt_ao_range_lkup(it->options[opt_ao1_range]);
+		devpriv->da0_2scomp = it->options[opt_ao0_twos];
+		devpriv->da1_2scomp = it->options[opt_ao1_twos];
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	s++;
+	/* dio subsystem */
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 16;
+	s->insn_bits = dt282x_dio_insn_bits;
+	s->insn_config = dt282x_dio_insn_config;
+	s->maxdata = 1;
+	s->range_table = &range_digital;
+
+	printk("\n");
+
+	return 0;
+}
+
+static void free_resources(comedi_device * dev)
+{
+	if (dev->irq) {
+		comedi_free_irq(dev->irq, dev);
+	}
+	if (dev->iobase)
+		release_region(dev->iobase, DT2821_SIZE);
+	if (dev->private) {
+		if (devpriv->dma[0].chan)
+			free_dma(devpriv->dma[0].chan);
+		if (devpriv->dma[1].chan)
+			free_dma(devpriv->dma[1].chan);
+		if (devpriv->dma[0].buf)
+			free_page((unsigned long)devpriv->dma[0].buf);
+		if (devpriv->dma[1].buf)
+			free_page((unsigned long)devpriv->dma[1].buf);
+	}
+}
+
+static int dt282x_detach(comedi_device * dev)
+{
+	printk("comedi%d: dt282x: remove\n", dev->minor);
+
+	free_resources(dev);
+
+	return 0;
+}
+
+static int dt282x_grab_dma(comedi_device * dev, int dma1, int dma2)
+{
+	int ret;
+
+	devpriv->usedma = 0;
+
+	if (!dma1 && !dma2) {
+		printk(" (no dma)");
+		return 0;
+	}
+
+	if (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)
+		return -EINVAL;
+
+	if (dma2 < dma1) {
+		int i;
+		i = dma1;
+		dma1 = dma2;
+		dma2 = i;
+	}
+
+	ret = request_dma(dma1, "dt282x A");
+	if (ret)
+		return -EBUSY;
+	devpriv->dma[0].chan = dma1;
+
+	ret = request_dma(dma2, "dt282x B");
+	if (ret)
+		return -EBUSY;
+	devpriv->dma[1].chan = dma2;
+
+	devpriv->dma_maxsize = PAGE_SIZE;
+	devpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+	devpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);
+	if (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {
+		printk(" can't get DMA memory");
+		return -ENOMEM;
+	}
+
+	printk(" (dma=%d,%d)", dma1, dma2);
+
+	devpriv->usedma = 1;
+
+	return 0;
+}
