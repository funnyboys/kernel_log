commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 97f21964546c..26e63d64ffc6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -8,16 +8,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f5cfa71a90c6..97f21964546c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * comedi/drivers/amplc_dio200.c
  *

commit 158bb7287ea00eff8ca5c2a60a384368dcce1d7c
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri May 22 18:15:58 2015 +0100

    staging: comedi: amplc_dio200.c: reformat copyright comment
    
    Reformat the copyright comment at the top of the file to use the
    preferred block comment style.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 4fe118380218..f5cfa71a90c6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1,23 +1,24 @@
 /*
-    comedi/drivers/amplc_dio200.c
-
-    Driver for Amplicon PC212E, PC214E, PC215E, PC218E, PC272E.
-
-    Copyright (C) 2005-2013 MEV Ltd. <http://www.mev.co.uk/>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+ * comedi/drivers/amplc_dio200.c
+ *
+ * Driver for Amplicon PC212E, PC214E, PC215E, PC218E, PC272E.
+ *
+ * Copyright (C) 2005-2013 MEV Ltd. <http://www.mev.co.uk/>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
 /*
  * Driver: amplc_dio200
  * Description: Amplicon 200 Series ISA Digital I/O

commit bb83abed7dd79ae1f0471c53144934efa57d7919
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:17:23 2014 -0700

    staging: comedi: amplc_dio200: remove dio200_common_detach()
    
    This exported function just does a free_irq() to release the interrupt
    handler for the legacy and PCI dio200 drivers.
    
    The legacy driver also calls comedi_legacy_detach() which would also
    do the free_irq(). For that driver the just use comedi_legacy_detach()
    directly for the (*detach).
    
    For the PCI driver, add the free_irq() to the private (*datach) function.
    
    Remove the, then unused, dio200_common_detach() function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 9b5efb7990a5..4fe118380218 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -257,17 +257,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return amplc_dio200_common_attach(dev, it->options[1], 0);
 }
 
-static void dio200_detach(struct comedi_device *dev)
-{
-	amplc_dio200_common_detach(dev);
-	comedi_legacy_detach(dev);
-}
-
 static struct comedi_driver amplc_dio200_driver = {
 	.driver_name	= "amplc_dio200",
 	.module		= THIS_MODULE,
 	.attach		= dio200_attach,
-	.detach		= dio200_detach,
+	.detach		= comedi_legacy_detach,
 	.board_name	= &dio200_isa_boards[0].name,
 	.offset		= sizeof(struct dio200_board),
 	.num_names	= ARRAY_SIZE(dio200_isa_boards),

commit f6ce09504ddc81aec07ddfcb16ad3c5b80ab19d0
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:17:18 2014 -0700

    staging: comedi: amplc_dio200.h: remove struct dio200_layout definition
    
    This struct is used to provide part of the boardinfo data. Using the extra
    indirection does not provide any additional clarity to the driver.
    
    Absorb the members from dio200_layout into dio200_board and remove the
    extra 'layout' indirection.
    
    For aesthetics, rename all the local variables used for the boardinfo
    pointer to 'board'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 83a99c3504ef..9b5efb7990a5 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -202,53 +202,47 @@
  */
 static const struct dio200_board dio200_isa_boards[] = {
 	{
-		.name = "pc212e",
-		.layout = {
-			.n_subdevs = 6,
-			.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254, sd_8254,
-				   sd_intr},
-			.sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
+		.name		= "pc212e",
+		.n_subdevs	= 6,
+		.sdtype		= {
+			sd_8255, sd_8254, sd_8254, sd_8254, sd_8254, sd_intr
 		},
-	},
-	{
-		.name = "pc214e",
-		.layout = {
-			.n_subdevs = 4,
-			.sdtype = {sd_8255, sd_8255, sd_8254, sd_intr},
-			.sdinfo = {0x00, 0x08, 0x10, 0x01},
+		.sdinfo		= { 0x00, 0x08, 0x0c, 0x10, 0x14, 0x3f },
+		.has_int_sce	= true,
+		.has_clk_gat_sce = true,
+	}, {
+		.name		= "pc214e",
+		.n_subdevs	= 4,
+		.sdtype		= {
+			sd_8255, sd_8255, sd_8254, sd_intr
 		},
-	},
-	{
-		.name = "pc215e",
-		.layout = {
-			.n_subdevs = 5,
-			.sdtype = {sd_8255, sd_8255, sd_8254, sd_8254, sd_intr},
-			.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
+		.sdinfo		= { 0x00, 0x08, 0x10, 0x01 },
+	}, {
+		.name		= "pc215e",
+		.n_subdevs	= 5,
+		.sdtype		= {
+			sd_8255, sd_8255, sd_8254, sd_8254, sd_intr
 		},
-	},
-	{
-		.name = "pc218e",
-		.layout = {
-			.n_subdevs = 7,
-			.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254, sd_8254,
-				   sd_intr},
-			.sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
+		.sdinfo		= { 0x00, 0x08, 0x10, 0x14, 0x3f },
+		.has_int_sce	= true,
+		.has_clk_gat_sce = true,
+	}, {
+		.name		= "pc218e",
+		.n_subdevs	= 7,
+		.sdtype		= {
+			sd_8254, sd_8254, sd_8255, sd_8254, sd_8254, sd_intr
 		},
-	},
-	{
-		.name = "pc272e",
-		.layout = {
-			.n_subdevs = 4,
-			.sdtype = {sd_8255, sd_8255, sd_8255, sd_intr},
-			.sdinfo = {0x00, 0x08, 0x10, 0x3F},
-			.has_int_sce = true,
+		.sdinfo		= { 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x3f },
+		.has_int_sce	= true,
+		.has_clk_gat_sce = true,
+	}, {
+		.name		= "pc272e",
+		.n_subdevs	= 4,
+		.sdtype		= {
+			sd_8255, sd_8255, sd_8255, sd_intr
 		},
+		.sdinfo		= { 0x00, 0x08, 0x10, 0x3f },
+		.has_int_sce = true,
 	},
 };
 

commit 849db1aacd223b25826246171519413fad601df6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:17:16 2014 -0700

    staging: comedi: amplc_dio200: tidy up comedi_driver declaration
    
    For aesthetics, add some whitespace to the declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index e99012ee4109..83a99c3504ef 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -270,13 +270,13 @@ static void dio200_detach(struct comedi_device *dev)
 }
 
 static struct comedi_driver amplc_dio200_driver = {
-	.driver_name = "amplc_dio200",
-	.module = THIS_MODULE,
-	.attach = dio200_attach,
-	.detach = dio200_detach,
-	.board_name = &dio200_isa_boards[0].name,
-	.offset = sizeof(struct dio200_board),
-	.num_names = ARRAY_SIZE(dio200_isa_boards),
+	.driver_name	= "amplc_dio200",
+	.module		= THIS_MODULE,
+	.attach		= dio200_attach,
+	.detach		= dio200_detach,
+	.board_name	= &dio200_isa_boards[0].name,
+	.offset		= sizeof(struct dio200_board),
+	.num_names	= ARRAY_SIZE(dio200_isa_boards),
 };
 module_comedi_driver(amplc_dio200_driver);
 

commit acb165135dcf48875e44fe323aa63653785bf01c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 1 13:07:04 2014 -0700

    staging: comedi: amplc_dio200: remove unnecessary local variable
    
    The local variable 'irq' is not necessary in dio200_attach(). Just
    pass the it->options[1] value directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6f35c83e4789..e99012ee4109 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -254,16 +254,13 @@ static const struct dio200_board dio200_isa_boards[] = {
 
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	unsigned int irq;
 	int ret;
 
-	irq = it->options[1];
-
 	ret = comedi_request_region(dev, it->options[0], 0x20);
 	if (ret)
 		return ret;
 
-	return amplc_dio200_common_attach(dev, irq, 0);
+	return amplc_dio200_common_attach(dev, it->options[1], 0);
 }
 
 static void dio200_detach(struct comedi_device *dev)

commit cf200de92ffd97ee46f6affeb8240448319af8ae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 1 13:07:01 2014 -0700

    staging: comedi: amplc_dio200: remove 'mainsize' from ISA boardinfo
    
    All the ISA DIO200 boards have an i/o region size of 0x20 (DIO200_IO_SIZE).
    Remove the boardinfo and open code the size in the comedi_request_region()
    call.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f0adead92ba7..6f35c83e4789 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -203,7 +203,6 @@
 static const struct dio200_board dio200_isa_boards[] = {
 	{
 		.name = "pc212e",
-		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 6,
 			.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254, sd_8254,
@@ -215,7 +214,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc214e",
-		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 4,
 			.sdtype = {sd_8255, sd_8255, sd_8254, sd_intr},
@@ -224,7 +222,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc215e",
-		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 5,
 			.sdtype = {sd_8255, sd_8255, sd_8254, sd_8254, sd_intr},
@@ -235,7 +232,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc218e",
-		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 7,
 			.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254, sd_8254,
@@ -247,7 +243,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc272e",
-		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 4,
 			.sdtype = {sd_8255, sd_8255, sd_8255, sd_intr},
@@ -259,13 +254,12 @@ static const struct dio200_board dio200_isa_boards[] = {
 
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	const struct dio200_board *thisboard = comedi_board(dev);
 	unsigned int irq;
 	int ret;
 
 	irq = it->options[1];
 
-	ret = comedi_request_region(dev, it->options[0], thisboard->mainsize);
+	ret = comedi_request_region(dev, it->options[0], 0x20);
 	if (ret)
 		return ret;
 

commit 7560e527534570199382ac72278301e9ac82920e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 1 13:07:00 2014 -0700

    staging: comedi: amplc_dio200: remove 'bustype' from boardinfo
    
    This member of the boardinfo is not used by the driver. Remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d605fd95cc50..f0adead92ba7 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -203,7 +203,6 @@
 static const struct dio200_board dio200_isa_boards[] = {
 	{
 		.name = "pc212e",
-		.bustype = isa_bustype,
 		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 6,
@@ -216,7 +215,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc214e",
-		.bustype = isa_bustype,
 		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 4,
@@ -226,7 +224,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc215e",
-		.bustype = isa_bustype,
 		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 5,
@@ -238,7 +235,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc218e",
-		.bustype = isa_bustype,
 		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 7,
@@ -251,7 +247,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 	{
 		.name = "pc272e",
-		.bustype = isa_bustype,
 		.mainsize = DIO200_IO_SIZE,
 		.layout = {
 			.n_subdevs = 4,

commit 76212bf32b92a62d7057159498b7d9475d7bf295
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Aug 1 13:06:59 2014 -0700

    staging: comedi: amplc_dio200: remove private data
    
    The private data in this driver only has one member, 'intr_sd', which is
    the index to the interrupt subdevice.
    
    This member is initialized during the attach of the driver when the sd_intr
    subdevice is detected in the boadinfo 'layout'. The member is then used in
    the interrupt handler to get the pointer to the subdevice.
    
    This member is not necessary. The comedi_device 'read_subdev' is also
    initialized during the attach. This can be used in the interrupt handler
    to get the subdevice pointer.
    
    Refactor the code to not require the private data and remove the struct
    and its allocations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 17d2e20663cb..d605fd95cc50 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -265,16 +265,11 @@ static const struct dio200_board dio200_isa_boards[] = {
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv;
 	unsigned int irq;
 	int ret;
 
 	irq = it->options[1];
 
-	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
-	if (!devpriv)
-		return -ENOMEM;
-
 	ret = comedi_request_region(dev, it->options[0], thisboard->mainsize);
 	if (ret)
 		return ret;

commit 0c3dfdc2d9a913c227a71f8cf728a70316c3abb4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jul 29 15:01:45 2014 -0700

    staging: comedi: amplc_dio200: use the comedi_device 'mmio' member
    
    The amplc_dio200_common module currently uses a union in the private
    data to determine if the hardware uses port or memory mapped I/O.
    
    Use the new 'mmio' member in the comedi_device for the ioremap'ed
    base address and remove all the union code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index dc1dee79fc16..17d2e20663cb 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -278,8 +278,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	ret = comedi_request_region(dev, it->options[0], thisboard->mainsize);
 	if (ret)
 		return ret;
-	devpriv->io.u.iobase = dev->iobase;
-	devpriv->io.regtype = io_regtype;
+
 	return amplc_dio200_common_attach(dev, irq, 0);
 }
 

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d1436733e913..dc1dee79fc16 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -192,6 +192,7 @@
  * order they appear in the channel list.
  */
 
+#include <linux/module.h>
 #include "../comedidev.h"
 
 #include "amplc_dio200.h"

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index e2478105ac1a..d1436733e913 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -192,8 +192,6 @@
  * order they appear in the channel list.
  */
 
-#include <linux/slab.h>
-
 #include "../comedidev.h"
 
 #include "amplc_dio200.h"
@@ -272,10 +270,9 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	irq = it->options[1];
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_request_region(dev, it->options[0], thisboard->mainsize);
 	if (ret)

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 297750bef0f7..e2478105ac1a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -17,11 +17,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
 */
 /*
  * Driver: amplc_dio200

commit 60cb3b02bc74c90aaa77d1acda1eff73c8dda478
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 18 14:33:40 2013 -0700

    staging: comedi: amplc_dio200: use comedi_legacy_detach()
    
    The I/O region used by this driver is always requested using
    comedi_request_region(). The devpriv->io union is only used by
    the common code shared by the legacy and PCI drivers.
    
    Use the new comedi_legacy_detach() helper in the (*detach) to
    release the I/O region requested by this driver. That function
    will handle the proper sanity checking before releasing the
    resource.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index dc35cc9fb081..297750bef0f7 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -292,14 +292,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void dio200_detach(struct comedi_device *dev)
 {
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-
-	if (!thisboard || !devpriv)
-		return;
 	amplc_dio200_common_detach(dev);
-	if (devpriv->io.regtype == io_regtype)
-		release_region(devpriv->io.u.iobase, thisboard->mainsize);
+	comedi_legacy_detach(dev);
 }
 
 static struct comedi_driver amplc_dio200_driver = {

commit 71827d43421824a11ac50d83b9e212061a84b025
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:13:19 2013 -0700

    staging: comedi: ampcl_dio200: use comedi_request_region()
    
    Use comedi_request_region() to request the I/O region used by this
    driver.
    
    Remove the noise when the board is first attached as well as the
    error message when the request_region() fails, comedi_request_reqion()
    will output the error message if necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 1d1f2feaeb66..dc35cc9fb081 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -268,44 +268,24 @@ static const struct dio200_board dio200_isa_boards[] = {
 	},
 };
 
-/*
- * This function checks and requests an I/O region, reporting an error
- * if there is a conflict.
- */
-static int
-dio200_request_region(struct comedi_device *dev,
-		      unsigned long from, unsigned long extent)
-{
-	if (!from || !request_region(from, extent, dev->board_name)) {
-		dev_err(dev->class_dev, "I/O port conflict (%#lx,%lu)!\n",
-			from, extent);
-		return -EIO;
-	}
-	return 0;
-}
-
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv;
-	unsigned long iobase;
 	unsigned int irq;
 	int ret;
 
-	iobase = it->options[0];
 	irq = it->options[1];
-	dev_info(dev->class_dev, "%s: attach %s 0x%lX,%u\n",
-		 dev->driver->driver_name, dev->board_name, iobase, irq);
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	ret = dio200_request_region(dev, iobase, thisboard->mainsize);
-	if (ret < 0)
+	ret = comedi_request_region(dev, it->options[0], thisboard->mainsize);
+	if (ret)
 		return ret;
-	devpriv->io.u.iobase = iobase;
+	devpriv->io.u.iobase = dev->iobase;
 	devpriv->io.regtype = io_regtype;
 	return amplc_dio200_common_attach(dev, irq, 0);
 }

commit 9308902f301d628802e40b6c3fbefa11fc9dd9d9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 9 16:12:55 2013 -0700

    staging: comedi: amplc_dio200: cleanup dev->board_name usage
    
    This legacy driver does no additional probing so the dev->board_name
    will already be properly initialized by the comedi core before calling
    the (*attach) function.
    
    Remove the unnecessary initialization of dev->board_name.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 1a562e8e5842..1d1f2feaeb66 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -292,7 +292,6 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned int irq;
 	int ret;
 
-	dev->board_name = thisboard->name;
 	iobase = it->options[0];
 	irq = it->options[1];
 	dev_info(dev->class_dev, "%s: attach %s 0x%lX,%u\n",

commit 7ff7e4c2c460f55a96d09b33ce421f91a9b6a0fb
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:09 2013 +0000

    staging: comedi: amplc_dio200: split into ISA, PCI and common
    
    Split the "amplc_dio200" comedi driver module into separate driver
    modules for ISA and PCI boards with a common module for the shared code.
    
    Keep the old name "amplc_dio200" for the ISA board driver as the module
    may be modprobed with this name by a script.  (If the script uses insmod
    it will need modifying to load the "amplc_dio200_common" module first.)
    
    Use the module name "amplc_dio200_pci" for the PCI board driver.  On
    most systems this will be auto-loaded.
    
    Use the module name "amplc_dio200_common" for the module containing the
    shared code.  This is normally loaded as a dependency of the other two
    modules.
    
    "amplc_dio200_common" exports the following functions:
    
    * `amplc_dio200_common_attach()`: this is basically the old
      `dio200_common_attach()` from the combined driver module.  It is
      called from the driver-specific attach or auto-attach routines.
    * `amplc_dio200_common_detach()`: this is most of the old
      `dio200_detach()`.  It is called from the driver-specific detach
      routine.
    * `amplc_dio200_set_enhance()`: this is a new function called during
      initialization of PCIe cards to enable "enhanced" mode.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index e00dda1170cf..1a562e8e5842 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1,10 +1,9 @@
 /*
     comedi/drivers/amplc_dio200.c
-    Driver for Amplicon PC272E and PCI272 DIO boards.
-    (Support for other boards in Amplicon 200 series may be added at
-    a later date, e.g. PCI215.)
 
-    Copyright (C) 2005 MEV Ltd. <http://www.mev.co.uk/>
+    Driver for Amplicon PC212E, PC214E, PC215E, PC218E, PC272E.
+
+    Copyright (C) 2005-2013 MEV Ltd. <http://www.mev.co.uk/>
 
     COMEDI - Linux Control and Measurement Device Interface
     Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
@@ -26,26 +25,23 @@
 */
 /*
  * Driver: amplc_dio200
- * Description: Amplicon 200 Series Digital I/O
+ * Description: Amplicon 200 Series ISA Digital I/O
  * Author: Ian Abbott <abbotti@mev.co.uk>
  * Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
- *   PCI215 (pci215), PCIe215 (pcie215), PC218E (pc218e), PCIe236 (pcie236),
- *   PC272E (pc272e), PCI272 (pci272), PCIe296 (pcie296)
- * Updated: Wed, 24 Oct 2012 16:22:34 +0100
+ *   PC218E (pc218e), PC272E (pc272e)
+ * Updated: Mon, 18 Mar 2013 14:40:41 +0000
+ *
  * Status: works
  *
- * Configuration options - PC212E, PC214E, PC215E, PC218E, PC272E:
+ * Configuration options:
  *   [0] - I/O port base address
  *   [1] - IRQ (optional, but commands won't work without it)
  *
- * Manual configuration of PCI(e) cards is not supported; they are configured
- * automatically.
- *
  * Passing a zero for an option is the same as leaving it unspecified.
  *
  * SUBDEVICES
  *
- *                     PC212E         PC214E      PC215E/PCI215
+ *                     PC212E         PC214E         PC215E
  *                  -------------  -------------  -------------
  *   Subdevices           6              4              5
  *    0                 PPI-X          PPI-X          PPI-X
@@ -55,29 +51,16 @@
  *    4                 CTR-Z2                      INTERRUPT
  *    5               INTERRUPT
  *
- *                     PCIe215        PC218E         PCIe236
- *                  -------------  -------------  -------------
- *   Subdevices           8              7              8
- *    0                 PPI-X          CTR-X1         PPI-X
- *    1                 UNUSED         CTR-X2         UNUSED
- *    2                 PPI-Y          CTR-Y1         UNUSED
- *    3                 UNUSED         CTR-Y2         UNUSED
- *    4                 CTR-Z1         CTR-Z1         CTR-Z1
- *    5                 CTR-Z2         CTR-Z2         CTR-Z2
- *    6                 TIMER        INTERRUPT        TIMER
- *    7               INTERRUPT                     INTERRUPT
- *
- *                  PC272E/PCI272     PCIe296
+ *                     PC218E         PC272E
  *                  -------------  -------------
- *   Subdevices           4              8
- *    0                 PPI-X          PPI-X1
- *    1                 PPI-Y          PPI-X2
- *    2                 PPI-Z          PPI-Y1
- *    3               INTERRUPT        PPI-Y2
- *    4                                CTR-Z1
- *    5                                CTR-Z2
- *    6                                TIMER
- *    7                              INTERRUPT
+ *   Subdevices           7              4
+ *    0                 CTR-X1         PPI-X
+ *    1                 CTR-X2         PPI-Y
+ *    2                 CTR-Y1         PPI-Z
+ *    3                 CTR-Y2       INTERRUPT
+ *    4                 CTR-Z1
+ *    5                 CTR-Z2
+ *    6               INTERRUPT
  *
  * Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
  * are configurable as inputs or outputs in four groups:
@@ -120,14 +103,6 @@
  *         the SK1 connector.  This pin is shared by all three counter
  *         channels on the chip.
  *
- *     For the PCIe boards, clock sources in the range 0 to 31 are allowed
- *     and the following additional clock sources are defined:
- *
- *       8.  HIGH logic level.
- *       9.  LOW logic level.
- *      10.  "Pattern present" signal.
- *      11.  Internal 20 MHz clock.
- *
  *   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
  *     clock source in data[1].  For internal clock sources, data[2] is set
  *     to the period in ns.
@@ -149,27 +124,6 @@
  *       6.  Reserved.
  *       7.  Reserved.
  *
- *     For the PCIe boards, gate sources in the range 0 to 31 are allowed;
- *     the following additional clock sources and clock sources 6 and 7 are
- *     (re)defined:
- *
- *       6.  /GAT n, negated version of the counter channel's dedicated
- *         GAT input (negated version of gate source 2).
- *       7.  OUT n-2, the non-inverted output of counter channel n-2
- *         (negated version of gate source 3).
- *       8.  "Pattern present" signal, HIGH while pattern present.
- *       9.  "Pattern occurred" latched signal, latches HIGH when pattern
- *         occurs.
- *      10.  "Pattern gone away" latched signal, latches LOW when pattern
- *         goes away after it occurred.
- *      11.  Negated "pattern present" signal, LOW while pattern present
- *         (negated version of gate source 8).
- *      12.  Negated "pattern occurred" latched signal, latches LOW when
- *         pattern occurs (negated version of gate source 9).
- *      13.  Negated "pattern gone away" latched signal, latches LOW when
- *         pattern goes away after it occurred (negated version of gate
- *         source 10).
- *
  *   INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
  *     source in data[2].
  *
@@ -186,8 +140,6 @@
  *   3.  The counter subdevices are connected in a ring, so the highest
  *   counter subdevice precedes the lowest.
  *
- * The 'TIMER' subdevice is a free-running 32-bit timer subdevice.
- *
  * The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
  * digital inputs come from the interrupt status register.  The number of
  * channels matches the number of interrupt sources.  The PC214E does not
@@ -196,7 +148,7 @@
  *
  * INTERRUPT SOURCES
  *
- *                     PC212E         PC214E      PC215E/PCI215
+ *                     PC212E         PC214E         PC215E
  *                  -------------  -------------  -------------
  *   Sources              6              1              6
  *    0               PPI-X-C0       JUMPER-J5      PPI-X-C0
@@ -206,25 +158,15 @@
  *    4              CTR-Z1-OUT1                   CTR-Z1-OUT1
  *    5              CTR-Z2-OUT1                   CTR-Z2-OUT1
  *
- *                     PCIe215        PC218E         PCIe236
- *                  -------------  -------------  -------------
- *   Sources              6              6              6
- *    0               PPI-X-C0      CTR-X1-OUT1     PPI-X-C0
- *    1               PPI-X-C3      CTR-X2-OUT1     PPI-X-C3
- *    2               PPI-Y-C0      CTR-Y1-OUT1      unused
- *    3               PPI-Y-C3      CTR-Y2-OUT1      unused
- *    4              CTR-Z1-OUT1    CTR-Z1-OUT1    CTR-Z1-OUT1
- *    5              CTR-Z2-OUT1    CTR-Z2-OUT1    CTR-Z2-OUT1
- *
- *                  PC272E/PCI272     PCIe296
+ *                     PC218E         PC272E
  *                  -------------  -------------
  *   Sources              6              6
- *    0               PPI-X-C0       PPI-X1-C0
- *    1               PPI-X-C3       PPI-X1-C3
- *    2               PPI-Y-C0       PPI-Y1-C0
- *    3               PPI-Y-C3       PPI-Y1-C3
- *    4               PPI-Z-C0      CTR-Z1-OUT1
- *    5               PPI-Z-C3      CTR-Z2-OUT1
+ *    0              CTR-X1-OUT1     PPI-X-C0
+ *    1              CTR-X2-OUT1     PPI-X-C3
+ *    2              CTR-Y1-OUT1     PPI-Y-C0
+ *    3              CTR-Y2-OUT1     PPI-Y-C3
+ *    4              CTR-Z1-OUT1     PPI-Z-C0
+ *    5              CTR-Z2-OUT1     PPI-Z-C3
  *
  * When an interrupt source is enabled in the interrupt source enable
  * register, a rising edge on the source signal latches the corresponding
@@ -232,14 +174,11 @@
  *
  * When the interrupt status register value as a whole (actually, just the
  * 6 least significant bits) goes from zero to non-zero, the board will
- * generate an interrupt.  For level-triggered hardware interrupts (PCI
- * card), the interrupt will remain asserted until the interrupt status
- * register is cleared to zero.  For edge-triggered hardware interrupts
- * (ISA card), no further interrupts will occur until the interrupt status
- * register is cleared to zero.  To clear a bit to zero in the interrupt
- * status register, the corresponding interrupt source must be disabled
- * in the interrupt source enable register (there is no separate interrupt
- * clear register).
+ * generate an interrupt.  No further interrupts will occur until the
+ * interrupt status register is cleared to zero.  To clear a bit to zero in
+ * the interrupt status register, the corresponding interrupt source must
+ * be disabled in the interrupt source enable register (there is no
+ * separate interrupt clear register).
  *
  * The PC214E does not have an interrupt source enable register or an
  * interrupt status register; its 'INTERRUPT' subdevice has a single
@@ -258,159 +197,15 @@
  * order they appear in the channel list.
  */
 
-#include <linux/pci.h>
-#include <linux/interrupt.h>
 #include <linux/slab.h>
 
 #include "../comedidev.h"
 
-#include "comedi_fc.h"
-#include "8253.h"
-
-#define DO_ISA	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
-#define DO_PCI	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
-
-/* PCI IDs */
-#define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
-#define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
-#define PCI_DEVICE_ID_AMPLICON_PCIE236 0x0011
-#define PCI_DEVICE_ID_AMPLICON_PCIE215 0x0012
-#define PCI_DEVICE_ID_AMPLICON_PCIE296 0x0014
-
-/* 8255 control register bits */
-#define CR_C_LO_IO	0x01
-#define CR_B_IO		0x02
-#define CR_B_MODE	0x04
-#define CR_C_HI_IO	0x08
-#define CR_A_IO		0x10
-#define CR_A_MODE(a)	((a)<<5)
-#define CR_CW		0x80
-
-/* 200 series registers */
-#define DIO200_IO_SIZE		0x20
-#define DIO200_PCIE_IO_SIZE	0x4000
-#define DIO200_XCLK_SCE		0x18	/* Group X clock selection register */
-#define DIO200_YCLK_SCE		0x19	/* Group Y clock selection register */
-#define DIO200_ZCLK_SCE		0x1a	/* Group Z clock selection register */
-#define DIO200_XGAT_SCE		0x1b	/* Group X gate selection register */
-#define DIO200_YGAT_SCE		0x1c	/* Group Y gate selection register */
-#define DIO200_ZGAT_SCE		0x1d	/* Group Z gate selection register */
-#define DIO200_INT_SCE		0x1e	/* Interrupt enable/status register */
-/* Extra registers for new PCIe boards */
-#define DIO200_ENHANCE		0x20	/* 1 to enable enhanced features */
-#define DIO200_VERSION		0x24	/* Hardware version register */
-#define DIO200_TS_CONFIG	0x600	/* Timestamp timer config register */
-#define DIO200_TS_COUNT		0x602	/* Timestamp timer count register */
-
-/*
- * Functions for constructing value for DIO_200_?CLK_SCE and
- * DIO_200_?GAT_SCE registers:
- *
- * 'which' is: 0 for CTR-X1, CTR-Y1, CTR-Z1; 1 for CTR-X2, CTR-Y2 or CTR-Z2.
- * 'chan' is the channel: 0, 1 or 2.
- * 'source' is the signal source: 0 to 7, or 0 to 31 for "enhanced" boards.
- */
-static unsigned char clk_gat_sce(unsigned int which, unsigned int chan,
-				 unsigned int source)
-{
-	return (which << 5) | (chan << 3) |
-	       ((source & 030) << 3) | (source & 007);
-}
-
-static unsigned char clk_sce(unsigned int which, unsigned int chan,
-			     unsigned int source)
-{
-	return clk_gat_sce(which, chan, source);
-}
-
-static unsigned char gat_sce(unsigned int which, unsigned int chan,
-			     unsigned int source)
-{
-	return clk_gat_sce(which, chan, source);
-}
-
-/*
- * Periods of the internal clock sources in nanoseconds.
- */
-static const unsigned int clock_period[32] = {
-	[1] = 100,		/* 10 MHz */
-	[2] = 1000,		/* 1 MHz */
-	[3] = 10000,		/* 100 kHz */
-	[4] = 100000,		/* 10 kHz */
-	[5] = 1000000,		/* 1 kHz */
-	[11] = 50,		/* 20 MHz (enhanced boards) */
-	/* clock sources 12 and later reserved for enhanced boards */
-};
-
-/*
- * Timestamp timer configuration register (for new PCIe boards).
- */
-#define TS_CONFIG_RESET		0x100	/* Reset counter to zero. */
-#define TS_CONFIG_CLK_SRC_MASK	0x0FF	/* Clock source. */
-#define TS_CONFIG_MAX_CLK_SRC	2	/* Maximum clock source value. */
-
-/*
- * Periods of the timestamp timer clock sources in nanoseconds.
- */
-static const unsigned int ts_clock_period[TS_CONFIG_MAX_CLK_SRC + 1] = {
-	1,			/* 1 nanosecond (but with 20 ns granularity). */
-	1000,			/* 1 microsecond. */
-	1000000,		/* 1 millisecond. */
-};
-
-/*
- * Register region.
- */
-enum dio200_regtype { no_regtype = 0, io_regtype, mmio_regtype };
-struct dio200_region {
-	union {
-		unsigned long iobase;		/* I/O base address */
-		unsigned char __iomem *membase;	/* mapped MMIO base address */
-	} u;
-	enum dio200_regtype regtype;
-};
-
-/*
- * Subdevice types.
- */
-enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254, sd_timer };
-
-#define DIO200_MAX_SUBDEVS	8
-#define DIO200_MAX_ISNS		6
-
-struct dio200_layout {
-	unsigned short n_subdevs;	/* number of subdevices */
-	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
-	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
-	bool has_int_sce:1;		/* has interrupt enable/status reg */
-	bool has_clk_gat_sce:1;		/* has clock/gate selection registers */
-	bool has_enhancements:1;	/* has enhanced features */
-};
+#include "amplc_dio200.h"
 
 /*
  * Board descriptions.
  */
-
-enum dio200_bustype { isa_bustype, pci_bustype };
-
-enum dio200_pci_model {
-	pci215_model,
-	pci272_model,
-	pcie215_model,
-	pcie236_model,
-	pcie296_model
-};
-
-struct dio200_board {
-	const char *name;
-	struct dio200_layout layout;
-	enum dio200_bustype bustype;
-	unsigned char mainbar;
-	unsigned char mainshift;
-	unsigned int mainsize;
-};
-
-#if DO_ISA
 static const struct dio200_board dio200_isa_boards[] = {
 	{
 		.name = "pc212e",
@@ -472,207 +267,6 @@ static const struct dio200_board dio200_isa_boards[] = {
 		},
 	},
 };
-#endif
-
-#if DO_PCI
-static const struct dio200_board dio200_pci_boards[] = {
-	[pci215_model] {
-		.name = "pci215",
-		.bustype = pci_bustype,
-		.mainbar = 2,
-		.mainsize = DIO200_IO_SIZE,
-		.layout = {
-			.n_subdevs = 5,
-			.sdtype = {sd_8255, sd_8255, sd_8254, sd_8254, sd_intr},
-			.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
-		},
-	},
-	[pci272_model] {
-		.name = "pci272",
-		.bustype = pci_bustype,
-		.mainbar = 2,
-		.mainsize = DIO200_IO_SIZE,
-		.layout = {
-			.n_subdevs = 4,
-			.sdtype = {sd_8255, sd_8255, sd_8255, sd_intr},
-			.sdinfo = {0x00, 0x08, 0x10, 0x3F},
-			.has_int_sce = true,
-		},
-	},
-	[pcie215_model] {
-		.name = "pcie215",
-		.bustype = pci_bustype,
-		.mainbar = 1,
-		.mainshift = 3,
-		.mainsize = DIO200_PCIE_IO_SIZE,
-		.layout = {
-			.n_subdevs = 8,
-			.sdtype = {sd_8255, sd_none, sd_8255, sd_none,
-				   sd_8254, sd_8254, sd_timer, sd_intr},
-			.sdinfo = {0x00, 0x00, 0x08, 0x00,
-				   0x10, 0x14, 0x00, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
-			.has_enhancements = true,
-		},
-	},
-	[pcie236_model] {
-		.name = "pcie236",
-		.bustype = pci_bustype,
-		.mainbar = 1,
-		.mainshift = 3,
-		.mainsize = DIO200_PCIE_IO_SIZE,
-		.layout = {
-			.n_subdevs = 8,
-			.sdtype = {sd_8255, sd_none, sd_none, sd_none,
-				   sd_8254, sd_8254, sd_timer, sd_intr},
-			.sdinfo = {0x00, 0x00, 0x00, 0x00,
-				   0x10, 0x14, 0x00, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
-			.has_enhancements = true,
-		},
-	},
-	[pcie296_model] {
-		.name = "pcie296",
-		.bustype = pci_bustype,
-		.mainbar = 1,
-		.mainshift = 3,
-		.mainsize = DIO200_PCIE_IO_SIZE,
-		.layout = {
-			.n_subdevs = 8,
-			.sdtype = {sd_8255, sd_8255, sd_8255, sd_8255,
-				   sd_8254, sd_8254, sd_timer, sd_intr},
-			.sdinfo = {0x00, 0x04, 0x08, 0x0C,
-				   0x10, 0x14, 0x00, 0x3F},
-			.has_int_sce = true,
-			.has_clk_gat_sce = true,
-			.has_enhancements = true,
-		},
-	},
-};
-#endif
-
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.
- */
-struct dio200_private {
-	struct dio200_region io;	/* Register region */
-	int intr_sd;
-};
-
-struct dio200_subdev_8254 {
-	unsigned int ofs;		/* Counter base offset */
-	unsigned int clk_sce_ofs;	/* CLK_SCE base address */
-	unsigned int gat_sce_ofs;	/* GAT_SCE base address */
-	int which;			/* Bit 5 of CLK_SCE or GAT_SCE */
-	unsigned int clock_src[3];	/* Current clock sources */
-	unsigned int gate_src[3];	/* Current gate sources */
-	spinlock_t spinlock;
-};
-
-struct dio200_subdev_8255 {
-	unsigned int ofs;		/* DIO base offset */
-};
-
-struct dio200_subdev_intr {
-	spinlock_t spinlock;
-	unsigned int ofs;
-	unsigned int valid_isns;
-	unsigned int enabled_isns;
-	unsigned int stopcount;
-	bool active:1;
-	bool continuous:1;
-};
-
-static inline const struct dio200_layout *
-dio200_board_layout(const struct dio200_board *board)
-{
-	return &board->layout;
-}
-
-static inline const struct dio200_layout *
-dio200_dev_layout(struct comedi_device *dev)
-{
-	return dio200_board_layout(comedi_board(dev));
-}
-
-static inline bool is_pci_board(const struct dio200_board *board)
-{
-	return DO_PCI && board->bustype == pci_bustype;
-}
-
-static inline bool is_isa_board(const struct dio200_board *board)
-{
-	return DO_ISA && board->bustype == isa_bustype;
-}
-
-/*
- * Read 8-bit register.
- */
-static unsigned char dio200_read8(struct comedi_device *dev,
-				  unsigned int offset)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-
-	offset <<= thisboard->mainshift;
-	if (devpriv->io.regtype == io_regtype)
-		return inb(devpriv->io.u.iobase + offset);
-	else
-		return readb(devpriv->io.u.membase + offset);
-}
-
-/*
- * Write 8-bit register.
- */
-static void dio200_write8(struct comedi_device *dev, unsigned int offset,
-			  unsigned char val)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-
-	offset <<= thisboard->mainshift;
-	if (devpriv->io.regtype == io_regtype)
-		outb(val, devpriv->io.u.iobase + offset);
-	else
-		writeb(val, devpriv->io.u.membase + offset);
-}
-
-/*
- * Read 32-bit register.
- */
-static unsigned int dio200_read32(struct comedi_device *dev,
-				  unsigned int offset)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-
-	offset <<= thisboard->mainshift;
-	if (devpriv->io.regtype == io_regtype)
-		return inl(devpriv->io.u.iobase + offset);
-	else
-		return readl(devpriv->io.u.membase + offset);
-}
-
-/*
- * Write 32-bit register.
- */
-static void dio200_write32(struct comedi_device *dev, unsigned int offset,
-			   unsigned int val)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-
-	offset <<= thisboard->mainshift;
-	if (devpriv->io.regtype == io_regtype)
-		outl(val, devpriv->io.u.iobase + offset);
-	else
-		writel(val, devpriv->io.u.membase + offset);
-}
 
 /*
  * This function checks and requests an I/O region, reporting an error
@@ -690,1296 +284,56 @@ dio200_request_region(struct comedi_device *dev,
 	return 0;
 }
 
-/*
- * 'insn_bits' function for an 'INTERRUPT' subdevice.
- */
-static int
-dio200_subdev_intr_insn_bits(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_intr *subpriv = s->private;
-
-	if (layout->has_int_sce) {
-		/* Just read the interrupt status register.  */
-		data[1] = dio200_read8(dev, subpriv->ofs) & subpriv->valid_isns;
-	} else {
-		/* No interrupt status register. */
-		data[0] = 0;
-	}
-
-	return insn->n;
-}
-
-/*
- * Called to stop acquisition for an 'INTERRUPT' subdevice.
- */
-static void dio200_stop_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_intr *subpriv = s->private;
-
-	subpriv->active = false;
-	subpriv->enabled_isns = 0;
-	if (layout->has_int_sce)
-		dio200_write8(dev, subpriv->ofs, 0);
-}
-
-/*
- * Called to start acquisition for an 'INTERRUPT' subdevice.
- */
-static int dio200_start_intr(struct comedi_device *dev,
-			     struct comedi_subdevice *s)
-{
-	unsigned int n;
-	unsigned isn_bits;
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_intr *subpriv = s->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	int retval = 0;
-
-	if (!subpriv->continuous && subpriv->stopcount == 0) {
-		/* An empty acquisition! */
-		s->async->events |= COMEDI_CB_EOA;
-		subpriv->active = false;
-		retval = 1;
-	} else {
-		/* Determine interrupt sources to enable. */
-		isn_bits = 0;
-		if (cmd->chanlist) {
-			for (n = 0; n < cmd->chanlist_len; n++)
-				isn_bits |= (1U << CR_CHAN(cmd->chanlist[n]));
-		}
-		isn_bits &= subpriv->valid_isns;
-		/* Enable interrupt sources. */
-		subpriv->enabled_isns = isn_bits;
-		if (layout->has_int_sce)
-			dio200_write8(dev, subpriv->ofs, isn_bits);
-	}
-
-	return retval;
-}
-
-/*
- * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
- */
-static int
-dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-			  unsigned int trignum)
-{
-	struct dio200_subdev_intr *subpriv;
-	unsigned long flags;
-	int event = 0;
-
-	if (trignum != 0)
-		return -EINVAL;
-
-	subpriv = s->private;
-
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	s->async->inttrig = NULL;
-	if (subpriv->active)
-		event = dio200_start_intr(dev, s);
-
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-
-	if (event)
-		comedi_event(dev, s);
-
-	return 1;
-}
-
-static void dio200_read_scan_intr(struct comedi_device *dev,
-				  struct comedi_subdevice *s,
-				  unsigned int triggered)
-{
-	struct dio200_subdev_intr *subpriv = s->private;
-	unsigned short val;
-	unsigned int n, ch, len;
-
-	val = 0;
-	len = s->async->cmd.chanlist_len;
-	for (n = 0; n < len; n++) {
-		ch = CR_CHAN(s->async->cmd.chanlist[n]);
-		if (triggered & (1U << ch))
-			val |= (1U << n);
-	}
-	/* Write the scan to the buffer. */
-	if (comedi_buf_put(s->async, val)) {
-		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
-	} else {
-		/* Error!  Stop acquisition.  */
-		dio200_stop_intr(dev, s);
-		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
-		comedi_error(dev, "buffer overflow");
-	}
-
-	/* Check for end of acquisition. */
-	if (!subpriv->continuous) {
-		/* stop_src == TRIG_COUNT */
-		if (subpriv->stopcount > 0) {
-			subpriv->stopcount--;
-			if (subpriv->stopcount == 0) {
-				s->async->events |= COMEDI_CB_EOA;
-				dio200_stop_intr(dev, s);
-			}
-		}
-	}
-}
-
-/*
- * This is called from the interrupt service routine to handle a read
- * scan on an 'INTERRUPT' subdevice.
- */
-static int dio200_handle_read_intr(struct comedi_device *dev,
-				   struct comedi_subdevice *s)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_intr *subpriv = s->private;
-	unsigned triggered;
-	unsigned intstat;
-	unsigned cur_enabled;
-	unsigned int oldevents;
-	unsigned long flags;
-
-	triggered = 0;
-
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	oldevents = s->async->events;
-	if (layout->has_int_sce) {
-		/*
-		 * Collect interrupt sources that have triggered and disable
-		 * them temporarily.  Loop around until no extra interrupt
-		 * sources have triggered, at which point, the valid part of
-		 * the interrupt status register will read zero, clearing the
-		 * cause of the interrupt.
-		 *
-		 * Mask off interrupt sources already seen to avoid infinite
-		 * loop in case of misconfiguration.
-		 */
-		cur_enabled = subpriv->enabled_isns;
-		while ((intstat = (dio200_read8(dev, subpriv->ofs) &
-				   subpriv->valid_isns & ~triggered)) != 0) {
-			triggered |= intstat;
-			cur_enabled &= ~triggered;
-			dio200_write8(dev, subpriv->ofs, cur_enabled);
-		}
-	} else {
-		/*
-		 * No interrupt status register.  Assume the single interrupt
-		 * source has triggered.
-		 */
-		triggered = subpriv->enabled_isns;
-	}
-
-	if (triggered) {
-		/*
-		 * Some interrupt sources have triggered and have been
-		 * temporarily disabled to clear the cause of the interrupt.
-		 *
-		 * Reenable them NOW to minimize the time they are disabled.
-		 */
-		cur_enabled = subpriv->enabled_isns;
-		if (layout->has_int_sce)
-			dio200_write8(dev, subpriv->ofs, cur_enabled);
-
-		if (subpriv->active) {
-			/*
-			 * The command is still active.
-			 *
-			 * Ignore interrupt sources that the command isn't
-			 * interested in (just in case there's a race
-			 * condition).
-			 */
-			if (triggered & subpriv->enabled_isns)
-				/* Collect scan data. */
-				dio200_read_scan_intr(dev, s, triggered);
-		}
-	}
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-
-	if (oldevents != s->async->events)
-		comedi_event(dev, s);
-
-	return (triggered != 0);
-}
-
-/*
- * 'cancel' function for an 'INTERRUPT' subdevice.
- */
-static int dio200_subdev_intr_cancel(struct comedi_device *dev,
-				     struct comedi_subdevice *s)
+static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
-	struct dio200_subdev_intr *subpriv = s->private;
-	unsigned long flags;
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv;
+	unsigned long iobase;
+	unsigned int irq;
+	int ret;
 
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	if (subpriv->active)
-		dio200_stop_intr(dev, s);
+	dev->board_name = thisboard->name;
+	iobase = it->options[0];
+	irq = it->options[1];
+	dev_info(dev->class_dev, "%s: attach %s 0x%lX,%u\n",
+		 dev->driver->driver_name, dev->board_name, iobase, irq);
 
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
-	return 0;
+	ret = dio200_request_region(dev, iobase, thisboard->mainsize);
+	if (ret < 0)
+		return ret;
+	devpriv->io.u.iobase = iobase;
+	devpriv->io.regtype = io_regtype;
+	return amplc_dio200_common_attach(dev, irq, 0);
 }
 
-/*
- * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
- */
-static int
-dio200_subdev_intr_cmdtest(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
+static void dio200_detach(struct comedi_device *dev)
 {
-	int err = 0;
-
-	/* Step 1 : check if triggers are trivially valid */
-
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
-
-	if (err)
-		return 1;
-
-	/* Step 2a : make sure trigger sources are unique */
-
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
-
-	/* Step 2b : and mutually compatible */
-
-	if (err)
-		return 2;
-
-	/* Step 3: check if arguments are trivially valid */
-
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
-
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	/* if (err) return 4; */
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
 
-	return 0;
+	if (!thisboard || !devpriv)
+		return;
+	amplc_dio200_common_detach(dev);
+	if (devpriv->io.regtype == io_regtype)
+		release_region(devpriv->io.u.iobase, thisboard->mainsize);
 }
 
-/*
- * 'do_cmd' function for an 'INTERRUPT' subdevice.
- */
-static int dio200_subdev_intr_cmd(struct comedi_device *dev,
-				  struct comedi_subdevice *s)
-{
-	struct comedi_cmd *cmd = &s->async->cmd;
-	struct dio200_subdev_intr *subpriv = s->private;
-	unsigned long flags;
-	int event = 0;
-
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	subpriv->active = 1;
-
-	/* Set up end of acquisition. */
-	switch (cmd->stop_src) {
-	case TRIG_COUNT:
-		subpriv->continuous = false;
-		subpriv->stopcount = cmd->stop_arg;
-		break;
-	default:
-		/* TRIG_NONE */
-		subpriv->continuous = true;
-		subpriv->stopcount = 0;
-		break;
-	}
-
-	/* Set up start of acquisition. */
-	switch (cmd->start_src) {
-	case TRIG_INT:
-		s->async->inttrig = dio200_inttrig_start_intr;
-		break;
-	default:
-		/* TRIG_NOW */
-		event = dio200_start_intr(dev, s);
-		break;
-	}
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-
-	if (event)
-		comedi_event(dev, s);
-
-	return 0;
-}
-
-/*
- * This function initializes an 'INTERRUPT' subdevice.
- */
-static int
-dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned int offset, unsigned valid_isns)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_intr *subpriv;
-
-	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
-	if (!subpriv)
-		return -ENOMEM;
-
-	subpriv->ofs = offset;
-	subpriv->valid_isns = valid_isns;
-	spin_lock_init(&subpriv->spinlock);
-
-	if (layout->has_int_sce)
-		/* Disable interrupt sources. */
-		dio200_write8(dev, subpriv->ofs, 0);
-
-	s->private = subpriv;
-	s->type = COMEDI_SUBD_DI;
-	s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
-	if (layout->has_int_sce) {
-		s->n_chan = DIO200_MAX_ISNS;
-		s->len_chanlist = DIO200_MAX_ISNS;
-	} else {
-		/* No interrupt source register.  Support single channel. */
-		s->n_chan = 1;
-		s->len_chanlist = 1;
-	}
-	s->range_table = &range_digital;
-	s->maxdata = 1;
-	s->insn_bits = dio200_subdev_intr_insn_bits;
-	s->do_cmdtest = dio200_subdev_intr_cmdtest;
-	s->do_cmd = dio200_subdev_intr_cmd;
-	s->cancel = dio200_subdev_intr_cancel;
-
-	return 0;
-}
-
-/*
- * This function cleans up an 'INTERRUPT' subdevice.
- */
-static void
-dio200_subdev_intr_cleanup(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
-{
-	struct dio200_subdev_intr *subpriv = s->private;
-	kfree(subpriv);
-}
-
-/*
- * Interrupt service routine.
- */
-static irqreturn_t dio200_interrupt(int irq, void *d)
-{
-	struct comedi_device *dev = d;
-	struct dio200_private *devpriv = dev->private;
-	struct comedi_subdevice *s;
-	int handled;
-
-	if (!dev->attached)
-		return IRQ_NONE;
-
-	if (devpriv->intr_sd >= 0) {
-		s = &dev->subdevices[devpriv->intr_sd];
-		handled = dio200_handle_read_intr(dev, s);
-	} else {
-		handled = 0;
-	}
-
-	return IRQ_RETVAL(handled);
-}
-
-/*
- * Read an '8254' counter subdevice channel.
- */
-static unsigned int
-dio200_subdev_8254_read_chan(struct comedi_device *dev,
-			     struct comedi_subdevice *s, unsigned int chan)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-	unsigned int val;
-
-	/* latch counter */
-	val = chan << 6;
-	dio200_write8(dev, subpriv->ofs + i8254_control_reg, val);
-	/* read lsb, msb */
-	val = dio200_read8(dev, subpriv->ofs + chan);
-	val += dio200_read8(dev, subpriv->ofs + chan) << 8;
-	return val;
-}
-
-/*
- * Write an '8254' subdevice channel.
- */
-static void
-dio200_subdev_8254_write_chan(struct comedi_device *dev,
-			      struct comedi_subdevice *s, unsigned int chan,
-			      unsigned int count)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-
-	/* write lsb, msb */
-	dio200_write8(dev, subpriv->ofs + chan, count & 0xff);
-	dio200_write8(dev, subpriv->ofs + chan, (count >> 8) & 0xff);
-}
-
-/*
- * Set mode of an '8254' subdevice channel.
- */
-static void
-dio200_subdev_8254_set_mode(struct comedi_device *dev,
-			    struct comedi_subdevice *s, unsigned int chan,
-			    unsigned int mode)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-	unsigned int byte;
-
-	byte = chan << 6;
-	byte |= 0x30;		/* access order: lsb, msb */
-	byte |= (mode & 0xf);	/* counter mode and BCD|binary */
-	dio200_write8(dev, subpriv->ofs + i8254_control_reg, byte);
-}
-
-/*
- * Read status byte of an '8254' counter subdevice channel.
- */
-static unsigned int
-dio200_subdev_8254_status(struct comedi_device *dev,
-			  struct comedi_subdevice *s, unsigned int chan)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-
-	/* latch status */
-	dio200_write8(dev, subpriv->ofs + i8254_control_reg,
-		      0xe0 | (2 << chan));
-	/* read status */
-	return dio200_read8(dev, subpriv->ofs + chan);
-}
-
-/*
- * Handle 'insn_read' for an '8254' counter subdevice.
- */
-static int
-dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
-			struct comedi_insn *insn, unsigned int *data)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-	int chan = CR_CHAN(insn->chanspec);
-	unsigned int n;
-	unsigned long flags;
-
-	for (n = 0; n < insn->n; n++) {
-		spin_lock_irqsave(&subpriv->spinlock, flags);
-		data[n] = dio200_subdev_8254_read_chan(dev, s, chan);
-		spin_unlock_irqrestore(&subpriv->spinlock, flags);
-	}
-	return insn->n;
-}
-
-/*
- * Handle 'insn_write' for an '8254' counter subdevice.
- */
-static int
-dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
-			 struct comedi_insn *insn, unsigned int *data)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-	int chan = CR_CHAN(insn->chanspec);
-	unsigned int n;
-	unsigned long flags;
-
-	for (n = 0; n < insn->n; n++) {
-		spin_lock_irqsave(&subpriv->spinlock, flags);
-		dio200_subdev_8254_write_chan(dev, s, chan, data[n]);
-		spin_unlock_irqrestore(&subpriv->spinlock, flags);
-	}
-	return insn->n;
-}
-
-/*
- * Set gate source for an '8254' counter subdevice channel.
- */
-static int
-dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				unsigned int counter_number,
-				unsigned int gate_src)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_8254 *subpriv = s->private;
-	unsigned char byte;
-
-	if (!layout->has_clk_gat_sce)
-		return -1;
-	if (counter_number > 2)
-		return -1;
-	if (gate_src > (layout->has_enhancements ? 31 : 7))
-		return -1;
-
-	subpriv->gate_src[counter_number] = gate_src;
-	byte = gat_sce(subpriv->which, counter_number, gate_src);
-	dio200_write8(dev, subpriv->gat_sce_ofs, byte);
-
-	return 0;
-}
-
-/*
- * Get gate source for an '8254' counter subdevice channel.
- */
-static int
-dio200_subdev_8254_get_gate_src(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				unsigned int counter_number)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_8254 *subpriv = s->private;
-
-	if (!layout->has_clk_gat_sce)
-		return -1;
-	if (counter_number > 2)
-		return -1;
-
-	return subpriv->gate_src[counter_number];
-}
-
-/*
- * Set clock source for an '8254' counter subdevice channel.
- */
-static int
-dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 unsigned int counter_number,
-				 unsigned int clock_src)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_8254 *subpriv = s->private;
-	unsigned char byte;
-
-	if (!layout->has_clk_gat_sce)
-		return -1;
-	if (counter_number > 2)
-		return -1;
-	if (clock_src > (layout->has_enhancements ? 31 : 7))
-		return -1;
-
-	subpriv->clock_src[counter_number] = clock_src;
-	byte = clk_sce(subpriv->which, counter_number, clock_src);
-	dio200_write8(dev, subpriv->clk_sce_ofs, byte);
-
-	return 0;
-}
-
-/*
- * Get clock source for an '8254' counter subdevice channel.
- */
-static int
-dio200_subdev_8254_get_clock_src(struct comedi_device *dev,
-				 struct comedi_subdevice *s,
-				 unsigned int counter_number,
-				 unsigned int *period_ns)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_8254 *subpriv = s->private;
-	unsigned clock_src;
-
-	if (!layout->has_clk_gat_sce)
-		return -1;
-	if (counter_number > 2)
-		return -1;
-
-	clock_src = subpriv->clock_src[counter_number];
-	*period_ns = clock_period[clock_src];
-	return clock_src;
-}
-
-/*
- * Handle 'insn_config' for an '8254' counter subdevice.
- */
-static int
-dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
-{
-	struct dio200_subdev_8254 *subpriv = s->private;
-	int ret = 0;
-	int chan = CR_CHAN(insn->chanspec);
-	unsigned long flags;
-
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	switch (data[0]) {
-	case INSN_CONFIG_SET_COUNTER_MODE:
-		if (data[1] > (I8254_MODE5 | I8254_BINARY))
-			ret = -EINVAL;
-		else
-			dio200_subdev_8254_set_mode(dev, s, chan, data[1]);
-		break;
-	case INSN_CONFIG_8254_READ_STATUS:
-		data[1] = dio200_subdev_8254_status(dev, s, chan);
-		break;
-	case INSN_CONFIG_SET_GATE_SRC:
-		ret = dio200_subdev_8254_set_gate_src(dev, s, chan, data[2]);
-		if (ret < 0)
-			ret = -EINVAL;
-		break;
-	case INSN_CONFIG_GET_GATE_SRC:
-		ret = dio200_subdev_8254_get_gate_src(dev, s, chan);
-		if (ret < 0) {
-			ret = -EINVAL;
-			break;
-		}
-		data[2] = ret;
-		break;
-	case INSN_CONFIG_SET_CLOCK_SRC:
-		ret = dio200_subdev_8254_set_clock_src(dev, s, chan, data[1]);
-		if (ret < 0)
-			ret = -EINVAL;
-		break;
-	case INSN_CONFIG_GET_CLOCK_SRC:
-		ret = dio200_subdev_8254_get_clock_src(dev, s, chan, &data[2]);
-		if (ret < 0) {
-			ret = -EINVAL;
-			break;
-		}
-		data[1] = ret;
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-	return ret < 0 ? ret : insn->n;
-}
-
-/*
- * This function initializes an '8254' counter subdevice.
- */
-static int
-dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned int offset)
-{
-	const struct dio200_layout *layout = dio200_dev_layout(dev);
-	struct dio200_subdev_8254 *subpriv;
-	unsigned int chan;
-
-	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
-	if (!subpriv)
-		return -ENOMEM;
-
-	s->private = subpriv;
-	s->type = COMEDI_SUBD_COUNTER;
-	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
-	s->n_chan = 3;
-	s->maxdata = 0xFFFF;
-	s->insn_read = dio200_subdev_8254_read;
-	s->insn_write = dio200_subdev_8254_write;
-	s->insn_config = dio200_subdev_8254_config;
-
-	spin_lock_init(&subpriv->spinlock);
-	subpriv->ofs = offset;
-	if (layout->has_clk_gat_sce) {
-		/* Derive CLK_SCE and GAT_SCE register offsets from
-		 * 8254 offset. */
-		subpriv->clk_sce_ofs = DIO200_XCLK_SCE + (offset >> 3);
-		subpriv->gat_sce_ofs = DIO200_XGAT_SCE + (offset >> 3);
-		subpriv->which = (offset >> 2) & 1;
-	}
-
-	/* Initialize channels. */
-	for (chan = 0; chan < 3; chan++) {
-		dio200_subdev_8254_set_mode(dev, s, chan,
-					    I8254_MODE0 | I8254_BINARY);
-		if (layout->has_clk_gat_sce) {
-			/* Gate source 0 is VCC (logic 1). */
-			dio200_subdev_8254_set_gate_src(dev, s, chan, 0);
-			/* Clock source 0 is the dedicated clock input. */
-			dio200_subdev_8254_set_clock_src(dev, s, chan, 0);
-		}
-	}
-
-	return 0;
-}
-
-/*
- * This function cleans up an '8254' counter subdevice.
- */
-static void
-dio200_subdev_8254_cleanup(struct comedi_device *dev,
-			   struct comedi_subdevice *s)
-{
-	struct dio200_subdev_intr *subpriv = s->private;
-	kfree(subpriv);
-}
-
-/*
- * This function sets I/O directions for an '8255' DIO subdevice.
- */
-static void dio200_subdev_8255_set_dir(struct comedi_device *dev,
-				       struct comedi_subdevice *s)
-{
-	struct dio200_subdev_8255 *subpriv = s->private;
-	int config;
-
-	config = CR_CW;
-	/* 1 in io_bits indicates output, 1 in config indicates input */
-	if (!(s->io_bits & 0x0000ff))
-		config |= CR_A_IO;
-	if (!(s->io_bits & 0x00ff00))
-		config |= CR_B_IO;
-	if (!(s->io_bits & 0x0f0000))
-		config |= CR_C_LO_IO;
-	if (!(s->io_bits & 0xf00000))
-		config |= CR_C_HI_IO;
-	dio200_write8(dev, subpriv->ofs + 3, config);
-}
-
-/*
- * Handle 'insn_bits' for an '8255' DIO subdevice.
- */
-static int dio200_subdev_8255_bits(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
-{
-	struct dio200_subdev_8255 *subpriv = s->private;
-
-	if (data[0]) {
-		s->state &= ~data[0];
-		s->state |= (data[0] & data[1]);
-		if (data[0] & 0xff)
-			dio200_write8(dev, subpriv->ofs, s->state & 0xff);
-		if (data[0] & 0xff00)
-			dio200_write8(dev, subpriv->ofs + 1,
-				      (s->state >> 8) & 0xff);
-		if (data[0] & 0xff0000)
-			dio200_write8(dev, subpriv->ofs + 2,
-				      (s->state >> 16) & 0xff);
-	}
-	data[1] = dio200_read8(dev, subpriv->ofs);
-	data[1] |= dio200_read8(dev, subpriv->ofs + 1) << 8;
-	data[1] |= dio200_read8(dev, subpriv->ofs + 2) << 16;
-	return 2;
-}
-
-/*
- * Handle 'insn_config' for an '8255' DIO subdevice.
- */
-static int dio200_subdev_8255_config(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data)
-{
-	unsigned int mask;
-	unsigned int bits;
-
-	mask = 1 << CR_CHAN(insn->chanspec);
-	if (mask & 0x0000ff)
-		bits = 0x0000ff;
-	else if (mask & 0x00ff00)
-		bits = 0x00ff00;
-	else if (mask & 0x0f0000)
-		bits = 0x0f0000;
-	else
-		bits = 0xf00000;
-	switch (data[0]) {
-	case INSN_CONFIG_DIO_INPUT:
-		s->io_bits &= ~bits;
-		break;
-	case INSN_CONFIG_DIO_OUTPUT:
-		s->io_bits |= bits;
-		break;
-	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (s->io_bits & bits) ? COMEDI_OUTPUT : COMEDI_INPUT;
-		return insn->n;
-		break;
-	default:
-		return -EINVAL;
-	}
-	dio200_subdev_8255_set_dir(dev, s);
-	return 1;
-}
-
-/*
- * This function initializes an '8255' DIO subdevice.
- *
- * offset is the offset to the 8255 chip.
- */
-static int dio200_subdev_8255_init(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   unsigned int offset)
-{
-	struct dio200_subdev_8255 *subpriv;
-
-	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
-	if (!subpriv)
-		return -ENOMEM;
-	subpriv->ofs = offset;
-	s->private = subpriv;
-	s->type = COMEDI_SUBD_DIO;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
-	s->n_chan = 24;
-	s->range_table = &range_digital;
-	s->maxdata = 1;
-	s->insn_bits = dio200_subdev_8255_bits;
-	s->insn_config = dio200_subdev_8255_config;
-	s->state = 0;
-	s->io_bits = 0;
-	dio200_subdev_8255_set_dir(dev, s);
-	return 0;
-}
-
-/*
- * This function cleans up an '8255' DIO subdevice.
- */
-static void dio200_subdev_8255_cleanup(struct comedi_device *dev,
-				       struct comedi_subdevice *s)
-{
-	struct dio200_subdev_8255 *subpriv = s->private;
-
-	kfree(subpriv);
-}
-
-/*
- * Handle 'insn_read' for a timer subdevice.
- */
-static int dio200_subdev_timer_read(struct comedi_device *dev,
-				    struct comedi_subdevice *s,
-				    struct comedi_insn *insn,
-				    unsigned int *data)
-{
-	unsigned int n;
-
-	for (n = 0; n < insn->n; n++)
-		data[n] = dio200_read32(dev, DIO200_TS_COUNT);
-	return n;
-}
-
-/*
- * Reset timer subdevice.
- */
-static void dio200_subdev_timer_reset(struct comedi_device *dev,
-				      struct comedi_subdevice *s)
-{
-	unsigned int clock;
-
-	clock = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;
-	dio200_write32(dev, DIO200_TS_CONFIG, clock | TS_CONFIG_RESET);
-	dio200_write32(dev, DIO200_TS_CONFIG, clock);
-}
-
-/*
- * Get timer subdevice clock source and period.
- */
-static void dio200_subdev_timer_get_clock_src(struct comedi_device *dev,
-					      struct comedi_subdevice *s,
-					      unsigned int *src,
-					      unsigned int *period)
-{
-	unsigned int clk;
-
-	clk = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;
-	*src = clk;
-	*period = (clk < ARRAY_SIZE(ts_clock_period)) ?
-		  ts_clock_period[clk] : 0;
-}
-
-/*
- * Set timer subdevice clock source.
- */
-static int dio200_subdev_timer_set_clock_src(struct comedi_device *dev,
-					     struct comedi_subdevice *s,
-					     unsigned int src)
-{
-	if (src > TS_CONFIG_MAX_CLK_SRC)
-		return -EINVAL;
-	dio200_write32(dev, DIO200_TS_CONFIG, src);
-	return 0;
-}
-
-/*
- * Handle 'insn_config' for a timer subdevice.
- */
-static int dio200_subdev_timer_config(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      struct comedi_insn *insn,
-				      unsigned int *data)
-{
-	int ret = 0;
-
-	switch (data[0]) {
-	case INSN_CONFIG_RESET:
-		dio200_subdev_timer_reset(dev, s);
-		break;
-	case INSN_CONFIG_SET_CLOCK_SRC:
-		ret = dio200_subdev_timer_set_clock_src(dev, s, data[1]);
-		if (ret < 0)
-			ret = -EINVAL;
-		break;
-	case INSN_CONFIG_GET_CLOCK_SRC:
-		dio200_subdev_timer_get_clock_src(dev, s, &data[1], &data[2]);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret < 0 ? ret : insn->n;
-}
-
-/*
- * This function initializes a timer subdevice.
- *
- * Uses the timestamp timer registers.  There is only one timestamp timer.
- */
-static int dio200_subdev_timer_init(struct comedi_device *dev,
-				    struct comedi_subdevice *s)
-{
-	s->type = COMEDI_SUBD_TIMER;
-	s->subdev_flags = SDF_READABLE | SDF_LSAMPL;
-	s->n_chan = 1;
-	s->maxdata = 0xFFFFFFFF;
-	s->insn_read = dio200_subdev_timer_read;
-	s->insn_config = dio200_subdev_timer_config;
-	return 0;
-}
-
-/*
- * This function cleans up a timer subdevice.
- */
-static void dio200_subdev_timer_cleanup(struct comedi_device *dev,
-					struct comedi_subdevice *s)
-{
-	/* Nothing to do. */
-}
-
-/*
- * This function does some special set-up for the PCIe boards
- * PCIe215, PCIe236, PCIe296.
- */
-static int dio200_pcie_board_setup(struct comedi_device *dev)
-{
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	void __iomem *brbase;
-	resource_size_t brlen;
-
-	/*
-	 * The board uses Altera Cyclone IV with PCI-Express hard IP.
-	 * The FPGA configuration has the PCI-Express Avalon-MM Bridge
-	 * Control registers in PCI BAR 0, offset 0, and the length of
-	 * these registers is 0x4000.
-	 *
-	 * We need to write 0x80 to the "Avalon-MM to PCI-Express Interrupt
-	 * Enable" register at offset 0x50 to allow generation of PCIe
-	 * interrupts when RXmlrq_i is asserted in the SOPC Builder system.
-	 */
-	brlen = pci_resource_len(pcidev, 0);
-	if (brlen < 0x4000 ||
-			!(pci_resource_flags(pcidev, 0) & IORESOURCE_MEM)) {
-		dev_err(dev->class_dev, "error! bad PCI region!\n");
-		return -EINVAL;
-	}
-	brbase = ioremap_nocache(pci_resource_start(pcidev, 0), brlen);
-	if (!brbase) {
-		dev_err(dev->class_dev, "error! failed to map registers!\n");
-		return -ENOMEM;
-	}
-	writel(0x80, brbase + 0x50);
-	iounmap(brbase);
-	/* Enable "enhanced" features of board. */
-	dio200_write8(dev, DIO200_ENHANCE, 1);
-	return 0;
-}
-
-static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
-				unsigned long req_irq_flags)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-	const struct dio200_layout *layout = dio200_board_layout(thisboard);
-	struct comedi_subdevice *s;
-	int sdx;
-	unsigned int n;
-	int ret;
-
-	devpriv->intr_sd = -1;
-
-	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
-	if (ret)
-		return ret;
-
-	for (n = 0; n < dev->n_subdevices; n++) {
-		s = &dev->subdevices[n];
-		switch (layout->sdtype[n]) {
-		case sd_8254:
-			/* counter subdevice (8254) */
-			ret = dio200_subdev_8254_init(dev, s,
-						      layout->sdinfo[n]);
-			if (ret < 0)
-				return ret;
-			break;
-		case sd_8255:
-			/* digital i/o subdevice (8255) */
-			ret = dio200_subdev_8255_init(dev, s,
-						      layout->sdinfo[n]);
-			if (ret < 0)
-				return ret;
-			break;
-		case sd_intr:
-			/* 'INTERRUPT' subdevice */
-			if (irq) {
-				ret = dio200_subdev_intr_init(dev, s,
-							      DIO200_INT_SCE,
-							      layout->sdinfo[n]
-							     );
-				if (ret < 0)
-					return ret;
-				devpriv->intr_sd = n;
-			} else {
-				s->type = COMEDI_SUBD_UNUSED;
-			}
-			break;
-		case sd_timer:
-			ret = dio200_subdev_timer_init(dev, s);
-			if (ret < 0)
-				return ret;
-			break;
-		default:
-			s->type = COMEDI_SUBD_UNUSED;
-			break;
-		}
-	}
-	sdx = devpriv->intr_sd;
-	if (sdx >= 0 && sdx < dev->n_subdevices)
-		dev->read_subdev = &dev->subdevices[sdx];
-	if (irq) {
-		if (request_irq(irq, dio200_interrupt, req_irq_flags,
-				dev->board_name, dev) >= 0) {
-			dev->irq = irq;
-		} else {
-			dev_warn(dev->class_dev,
-				 "warning! irq %u unavailable!\n", irq);
-		}
-	}
-	dev_info(dev->class_dev, "attached\n");
-	return 0;
-}
-
-/* Only called for ISA boards. */
-static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv;
-	unsigned long iobase;
-	unsigned int irq;
-	int ret;
-
-	if (!DO_ISA)
-		return -EINVAL;
-
-	dev->board_name = thisboard->name;
-	iobase = it->options[0];
-	irq = it->options[1];
-	dev_info(dev->class_dev, "%s: attach %s 0x%lX,%u\n",
-		 dev->driver->driver_name, dev->board_name, iobase, irq);
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	ret = dio200_request_region(dev, iobase, thisboard->mainsize);
-	if (ret < 0)
-		return ret;
-	devpriv->io.u.iobase = iobase;
-	devpriv->io.regtype = io_regtype;
-	return dio200_common_attach(dev, irq, 0);
-}
-
-/*
- * The auto_attach hook is called at PCI probe time via
- * comedi_pci_auto_config().  dev->board_ptr is NULL on entry.
- * The context should be an index into dio200_pci_boards[].
- */
-static int dio200_auto_attach(struct comedi_device *dev,
-			      unsigned long context_model)
-{
-	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	const struct dio200_board *thisboard = NULL;
-	struct dio200_private *devpriv;
-	resource_size_t base, len;
-	unsigned int bar;
-	int ret;
-
-	if (!DO_PCI)
-		return -EINVAL;
-
-	if (context_model < ARRAY_SIZE(dio200_pci_boards))
-		thisboard = &dio200_pci_boards[context_model];
-	if (!thisboard)
-		return -EINVAL;
-	dev->board_ptr = thisboard;
-	dev->board_name = thisboard->name;
-
-	dev_info(dev->class_dev, "%s: attach pci %s (%s)\n",
-		 dev->driver->driver_name, pci_name(pci_dev), dev->board_name);
-
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
-	if (!devpriv)
-		return -ENOMEM;
-	dev->private = devpriv;
-
-	ret = comedi_pci_enable(dev);
-	if (ret)
-		return ret;
-
-	bar = thisboard->mainbar;
-	base = pci_resource_start(pci_dev, bar);
-	len = pci_resource_len(pci_dev, bar);
-	if (len < thisboard->mainsize) {
-		dev_err(dev->class_dev, "error! PCI region size too small!\n");
-		return -EINVAL;
-	}
-	if ((pci_resource_flags(pci_dev, bar) & IORESOURCE_MEM) != 0) {
-		devpriv->io.u.membase = ioremap_nocache(base, len);
-		if (!devpriv->io.u.membase) {
-			dev_err(dev->class_dev,
-				"error! cannot remap registers\n");
-			return -ENOMEM;
-		}
-		devpriv->io.regtype = mmio_regtype;
-	} else {
-		devpriv->io.u.iobase = (unsigned long)base;
-		devpriv->io.regtype = io_regtype;
-	}
-	switch (context_model) {
-	case pcie215_model:
-	case pcie236_model:
-	case pcie296_model:
-		ret = dio200_pcie_board_setup(dev);
-		if (ret < 0)
-			return ret;
-		break;
-	default:
-		break;
-	}
-	return dio200_common_attach(dev, pci_dev->irq, IRQF_SHARED);
-}
-
-static void dio200_detach(struct comedi_device *dev)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-	const struct dio200_layout *layout;
-	unsigned n;
-
-	if (!thisboard || !devpriv)
-		return;
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->subdevices) {
-		layout = dio200_board_layout(thisboard);
-		for (n = 0; n < dev->n_subdevices; n++) {
-			struct comedi_subdevice *s = &dev->subdevices[n];
-			switch (layout->sdtype[n]) {
-			case sd_8254:
-				dio200_subdev_8254_cleanup(dev, s);
-				break;
-			case sd_8255:
-				dio200_subdev_8255_cleanup(dev, s);
-				break;
-			case sd_intr:
-				dio200_subdev_intr_cleanup(dev, s);
-				break;
-			case sd_timer:
-				dio200_subdev_timer_cleanup(dev, s);
-				break;
-			default:
-				break;
-			}
-		}
-	}
-	if (is_isa_board(thisboard)) {
-		if (devpriv->io.regtype == io_regtype)
-			release_region(devpriv->io.u.iobase,
-				       thisboard->mainsize);
-	} else if (is_pci_board(thisboard)) {
-		if (devpriv->io.regtype == mmio_regtype)
-			iounmap(devpriv->io.u.membase);
-		comedi_pci_disable(dev);
-	}
-}
-
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
 static struct comedi_driver amplc_dio200_driver = {
 	.driver_name = "amplc_dio200",
 	.module = THIS_MODULE,
 	.attach = dio200_attach,
-	.auto_attach = dio200_auto_attach,
 	.detach = dio200_detach,
-#if DO_ISA
 	.board_name = &dio200_isa_boards[0].name,
 	.offset = sizeof(struct dio200_board),
 	.num_names = ARRAY_SIZE(dio200_isa_boards),
-#endif
-};
-
-#if DO_PCI
-static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{
-		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215),
-		pci215_model
-	}, {
-		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272),
-		pci272_model
-	}, {
-		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE236),
-		pcie236_model
-	}, {
-		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE215),
-		pcie215_model
-	}, {
-		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE296),
-		pcie296_model
-	},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, dio200_pci_table);
-
-static int amplc_dio200_pci_probe(struct pci_dev *dev,
-				  const struct pci_device_id *id)
-{
-	return comedi_pci_auto_config(dev, &amplc_dio200_driver,
-				      id->driver_data);
-}
-
-static struct pci_driver amplc_dio200_pci_driver = {
-	.name = "amplc_dio200",
-	.id_table = dio200_pci_table,
-	.probe = &amplc_dio200_pci_probe,
-	.remove	= comedi_pci_auto_unconfig,
 };
-module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
-#else
 module_comedi_driver(amplc_dio200_driver);
-#endif
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for Amplicon 200 Series ISA DIO boards");
 MODULE_LICENSE("GPL");

commit 8d688377867410428b21789e815f28a4631ee8f5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:08 2013 +0000

    staging: comedi: amplc_dio200: refactor dio200_handle_read_intr()
    
    Refactor `dio200_handle_read_intr()` to fix checkpatch warning about too
    many leading tabs.  Factor out the part that puts the scan data into the
    asynchronous command data buffer and checks for end of acquisition into
    new function `dio200_read_scan_intr()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 38026781b931..e00dda1170cf 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -791,6 +791,44 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	return 1;
 }
 
+static void dio200_read_scan_intr(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  unsigned int triggered)
+{
+	struct dio200_subdev_intr *subpriv = s->private;
+	unsigned short val;
+	unsigned int n, ch, len;
+
+	val = 0;
+	len = s->async->cmd.chanlist_len;
+	for (n = 0; n < len; n++) {
+		ch = CR_CHAN(s->async->cmd.chanlist[n]);
+		if (triggered & (1U << ch))
+			val |= (1U << n);
+	}
+	/* Write the scan to the buffer. */
+	if (comedi_buf_put(s->async, val)) {
+		s->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);
+	} else {
+		/* Error!  Stop acquisition.  */
+		dio200_stop_intr(dev, s);
+		s->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;
+		comedi_error(dev, "buffer overflow");
+	}
+
+	/* Check for end of acquisition. */
+	if (!subpriv->continuous) {
+		/* stop_src == TRIG_COUNT */
+		if (subpriv->stopcount > 0) {
+			subpriv->stopcount--;
+			if (subpriv->stopcount == 0) {
+				s->async->events |= COMEDI_CB_EOA;
+				dio200_stop_intr(dev, s);
+			}
+		}
+	}
+}
+
 /*
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
@@ -855,44 +893,9 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 			 * interested in (just in case there's a race
 			 * condition).
 			 */
-			if (triggered & subpriv->enabled_isns) {
+			if (triggered & subpriv->enabled_isns)
 				/* Collect scan data. */
-				short val;
-				unsigned int n, ch, len;
-
-				val = 0;
-				len = s->async->cmd.chanlist_len;
-				for (n = 0; n < len; n++) {
-					ch = CR_CHAN(s->async->cmd.chanlist[n]);
-					if (triggered & (1U << ch))
-						val |= (1U << n);
-				}
-				/* Write the scan to the buffer. */
-				if (comedi_buf_put(s->async, val)) {
-					s->async->events |= (COMEDI_CB_BLOCK |
-							     COMEDI_CB_EOS);
-				} else {
-					/* Error!  Stop acquisition.  */
-					dio200_stop_intr(dev, s);
-					s->async->events |= COMEDI_CB_ERROR
-					    | COMEDI_CB_OVERFLOW;
-					comedi_error(dev, "buffer overflow");
-				}
-
-				/* Check for end of acquisition. */
-				if (!subpriv->continuous) {
-					/* stop_src == TRIG_COUNT */
-					if (subpriv->stopcount > 0) {
-						subpriv->stopcount--;
-						if (subpriv->stopcount == 0) {
-							s->async->events |=
-							    COMEDI_CB_EOA;
-							dio200_stop_intr(dev,
-									 s);
-						}
-					}
-				}
-			}
+				dio200_read_scan_intr(dev, s, triggered);
 		}
 	}
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);

commit 5afb56cda90c100e6f9d62747d1b8cf94d0936a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:07 2013 +0000

    staging: comedi: amplc_dio200: don't check bus-type in dio200_common_attach()
    
    The "amplc_dio200" driver is going to be split into separate drivers for
    ISA and PCI cards with a common module containing most of the code.  We
    don't want the common module code to depend on whether ISA boards, PCI
    boards, or both are supported.  Currently, `dio200_common_attach()` and
    `dio200_detach()` optimize out the code to support a timer subdevice
    when built to support ISA boards only.  Remove the `if (DO_PCI)` tests
    which optimize out that code.  Unfortunately, this will expand the
    module's code size for an ISA-only driver a bit.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index eb0d3c16c41a..38026781b931 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1747,14 +1747,9 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 			}
 			break;
 		case sd_timer:
-			/* Only on PCIe boards. */
-			if (DO_PCI) {
-				ret = dio200_subdev_timer_init(dev, s);
-				if (ret < 0)
-					return ret;
-			} else {
-				s->type = COMEDI_SUBD_UNUSED;
-			}
+			ret = dio200_subdev_timer_init(dev, s);
+			if (ret < 0)
+				return ret;
 			break;
 		default:
 			s->type = COMEDI_SUBD_UNUSED;
@@ -1904,9 +1899,7 @@ static void dio200_detach(struct comedi_device *dev)
 				dio200_subdev_intr_cleanup(dev, s);
 				break;
 			case sd_timer:
-				/* Only on PCIe boards. */
-				if (DO_PCI)
-					dio200_subdev_timer_cleanup(dev, s);
+				dio200_subdev_timer_cleanup(dev, s);
 				break;
 			default:
 				break;

commit e067666acd35212e36d5361b8f64030f6b6d8283
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:06 2013 +0000

    staging: comedi: amplc_dio200: remove dio200_report_attach()
    
    `dio200_report_attach()` is called from `dio200_common_attach()` to
    report the successful attachment of a supported board.  It includes
    various information about the board.  Replace the function with a simple
    acknowledgement that the attachment completed successfully.  The
    `dio200_attach()` and `dio200_auto_attach()` functions also output an
    message during the attachment.  Include extra information in those
    messages to compensate for the removal of the information output by
    `dio200_report_attach()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index e0dd046668f6..eb0d3c16c41a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1698,32 +1698,6 @@ static int dio200_pcie_board_setup(struct comedi_device *dev)
 	return 0;
 }
 
-static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	char tmpbuf[60];
-	int tmplen;
-
-	if (is_isa_board(thisboard))
-		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
-				   "(base %#lx) ", devpriv->io.u.iobase);
-	else if (is_pci_board(thisboard))
-		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
-				   "(pci %s) ", pci_name(pcidev));
-	else
-		tmplen = 0;
-	if (irq)
-		tmplen += scnprintf(&tmpbuf[tmplen], sizeof(tmpbuf) - tmplen,
-				    "(irq %u%s) ", irq,
-				    (dev->irq ? "" : " UNAVAILABLE"));
-	else
-		tmplen += scnprintf(&tmpbuf[tmplen], sizeof(tmpbuf) - tmplen,
-				    "(no irq) ");
-	dev_info(dev->class_dev, "%s %sattached\n", dev->board_name, tmpbuf);
-}
-
 static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 				unsigned long req_irq_flags)
 {
@@ -1799,7 +1773,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 				 "warning! irq %u unavailable!\n", irq);
 		}
 	}
-	dio200_report_attach(dev, irq);
+	dev_info(dev->class_dev, "attached\n");
 	return 0;
 }
 
@@ -1816,15 +1790,16 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 
 	dev->board_name = thisboard->name;
-	dev_info(dev->class_dev, "%s: attach\n", dev->driver->driver_name);
+	iobase = it->options[0];
+	irq = it->options[1];
+	dev_info(dev->class_dev, "%s: attach %s 0x%lX,%u\n",
+		 dev->driver->driver_name, dev->board_name, iobase, irq);
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	iobase = it->options[0];
-	irq = it->options[1];
 	ret = dio200_request_region(dev, iobase, thisboard->mainsize);
 	if (ret < 0)
 		return ret;
@@ -1858,8 +1833,8 @@ static int dio200_auto_attach(struct comedi_device *dev,
 	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
-	dev_info(dev->class_dev, "%s: attach pci %s\n",
-		 dev->driver->driver_name, pci_name(pci_dev));
+	dev_info(dev->class_dev, "%s: attach pci %s (%s)\n",
+		 dev->driver->driver_name, pci_name(pci_dev), dev->board_name);
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)

commit 207c3b2b526214e632914243a69bab0d02b909c5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:05 2013 +0000

    staging: comedi: amplc_dio200: remove DIO200_DRIVER_NAME
    
    Remove the `DIO200_DRIVER_NAME` macro which expands to the driver name
    "amplc_dio200".  Use the board name from our `struct dio200_board` when
    requesting resources.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index b0b99840a1f5..e0dd046668f6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -267,8 +267,6 @@
 #include "comedi_fc.h"
 #include "8253.h"
 
-#define DIO200_DRIVER_NAME	"amplc_dio200"
-
 #define DO_ISA	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 #define DO_PCI	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
 
@@ -684,7 +682,7 @@ static int
 dio200_request_region(struct comedi_device *dev,
 		      unsigned long from, unsigned long extent)
 {
-	if (!from || !request_region(from, extent, DIO200_DRIVER_NAME)) {
+	if (!from || !request_region(from, extent, dev->board_name)) {
 		dev_err(dev->class_dev, "I/O port conflict (%#lx,%lu)!\n",
 			from, extent);
 		return -EIO;
@@ -1794,7 +1792,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 		dev->read_subdev = &dev->subdevices[sdx];
 	if (irq) {
 		if (request_irq(irq, dio200_interrupt, req_irq_flags,
-				DIO200_DRIVER_NAME, dev) >= 0) {
+				dev->board_name, dev) >= 0) {
 			dev->irq = irq;
 		} else {
 			dev_warn(dev->class_dev,
@@ -1818,7 +1816,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -EINVAL;
 
 	dev->board_name = thisboard->name;
-	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
+	dev_info(dev->class_dev, "%s: attach\n", dev->driver->driver_name);
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -1860,8 +1858,8 @@ static int dio200_auto_attach(struct comedi_device *dev,
 	dev->board_ptr = thisboard;
 	dev->board_name = thisboard->name;
 
-	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
-		 pci_name(pci_dev));
+	dev_info(dev->class_dev, "%s: attach pci %s\n",
+		 dev->driver->driver_name, pci_name(pci_dev));
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
 	if (!devpriv)
@@ -1958,7 +1956,7 @@ static void dio200_detach(struct comedi_device *dev)
  * the device code.
  */
 static struct comedi_driver amplc_dio200_driver = {
-	.driver_name = DIO200_DRIVER_NAME,
+	.driver_name = "amplc_dio200",
 	.module = THIS_MODULE,
 	.attach = dio200_attach,
 	.auto_attach = dio200_auto_attach,
@@ -2001,7 +1999,7 @@ static int amplc_dio200_pci_probe(struct pci_dev *dev,
 }
 
 static struct pci_driver amplc_dio200_pci_driver = {
-	.name = DIO200_DRIVER_NAME,
+	.name = "amplc_dio200",
 	.id_table = dio200_pci_table,
 	.probe = &amplc_dio200_pci_probe,
 	.remove	= comedi_pci_auto_unconfig,

commit e4681eba8ac585a00ecd8dd84bda5a400085e022
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:04 2013 +0000

    staging: comedi: amplc_dio200: set board_name before common attach
    
    `dio200_common_attach()` is called from `dio200_attach()` for ISA boards
    and from `dio200_auto_attach()` for PCI boards.  `dio200_auto_attach()`
    assigns `dev->board_name` (where `dev` is the `struct comedi_device *`
    under consideration) before calling `dio200_common_attach()`.  Do the
    same in `dio200_attach()` so it can be used there before the call to
    `dio200_common_attach()`.  This makes the assignment in
    `dio200_common_attach()` unnessary, so remove the assignment from there.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index ab9551580758..b0b99840a1f5 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1738,7 +1738,6 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 	int ret;
 
 	devpriv->intr_sd = -1;
-	dev->board_name = thisboard->name;
 
 	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
 	if (ret)
@@ -1818,6 +1817,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (!DO_ISA)
 		return -EINVAL;
 
+	dev->board_name = thisboard->name;
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);

commit 01d03a93f277d741ecfb744531215cd12fadf591
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:03 2013 +0000

    staging: comedi: amplc_dio200: dio200_common_attach() return 0
    
    Change the successful return value of `dio200_common_attach()` from 1 to
    0.  This is propagated as the return value from the driver's "attach"
    (`dio200_attach()`) or "auto_attach" (`dio200_auto_attach()`) handler.
    Any non-negative value will do, but 0 is more conventional than 1.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index a741fde84b7c..ab9551580758 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1803,7 +1803,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 		}
 	}
 	dio200_report_attach(dev, irq);
-	return 1;
+	return 0;
 }
 
 /* Only called for ISA boards. */

commit add873f29c6ed2c797208b861a99d992172b9495
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:02 2013 +0000

    staging: comedi: amplc_dio200: shrink struct dio200_subdev_intr
    
    Shave a few bytes off the size of `struct dio200_subdev_intr` by
    rearranging members and changing two of them to bit-fields.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index c004f4ebc563..a741fde84b7c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -581,13 +581,13 @@ struct dio200_subdev_8255 {
 };
 
 struct dio200_subdev_intr {
-	unsigned int ofs;
 	spinlock_t spinlock;
-	int active;
+	unsigned int ofs;
 	unsigned int valid_isns;
 	unsigned int enabled_isns;
 	unsigned int stopcount;
-	int continuous;
+	bool active:1;
+	bool continuous:1;
 };
 
 static inline const struct dio200_layout *
@@ -723,7 +723,7 @@ static void dio200_stop_intr(struct comedi_device *dev,
 	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv = s->private;
 
-	subpriv->active = 0;
+	subpriv->active = false;
 	subpriv->enabled_isns = 0;
 	if (layout->has_int_sce)
 		dio200_write8(dev, subpriv->ofs, 0);
@@ -745,7 +745,7 @@ static int dio200_start_intr(struct comedi_device *dev,
 	if (!subpriv->continuous && subpriv->stopcount == 0) {
 		/* An empty acquisition! */
 		s->async->events |= COMEDI_CB_EOA;
-		subpriv->active = 0;
+		subpriv->active = false;
 		retval = 1;
 	} else {
 		/* Determine interrupt sources to enable. */
@@ -998,12 +998,12 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev,
 	/* Set up end of acquisition. */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
-		subpriv->continuous = 0;
+		subpriv->continuous = false;
 		subpriv->stopcount = cmd->stop_arg;
 		break;
 	default:
 		/* TRIG_NONE */
-		subpriv->continuous = 1;
+		subpriv->continuous = true;
 		subpriv->stopcount = 0;
 		break;
 	}

commit f7282f05e1cb39556b5e29d113803e934f3e6d3e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:01 2013 +0000

    staging: comedi: amplc_dio200: embed board layout in board structure
    
    The amplc_dio200 driver supports both ISA and PCI boards, some of which
    are quite similar.  The driver takes advantage of this by defining a
    "board layout" structure `struct dio200_layout` along with an array of
    this structure `dio200_layouts[]` and an enumerated type for the indices
    into this array `enum dio200_layout_idx`.  The main board information
    structure `struct dio200_board` contains a `layout` member holding an
    enumerated index into the array of layouts and the enumerated layout
    values are used to designate the indices in the initializer of
    `dio200_layouts[]`.
    
    We would like to split the ISA and PCI support into separate driver
    modules and having the shared layouts makes this slightly awkward as the
    enumerated values are condionally present depending on whether the
    driver is configured to support ISA, PCI, or both.
    
    Embed the `struct dio200_layout` into the main board information
    structure `struct dio200_board` to make things simpler, discarding
    `dio200_layouts[]` and the `enum dio200_layout_idx` in the process.
    Only two of the layouts were used by more than one board anyway (each of
    which was used by one ISA and one PCI board).
    
    While we're at it, change the `has_int_sce`, `has_clk_gat_sce` and
    `has_enhancements` members of `struct dio200_layout` to `bool:1`
    bit-fields to save a few bytes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 4ed4e9458315..c004f4ebc563 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -372,6 +372,23 @@ struct dio200_region {
 	enum dio200_regtype regtype;
 };
 
+/*
+ * Subdevice types.
+ */
+enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254, sd_timer };
+
+#define DIO200_MAX_SUBDEVS	8
+#define DIO200_MAX_ISNS		6
+
+struct dio200_layout {
+	unsigned short n_subdevs;	/* number of subdevices */
+	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
+	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
+	bool has_int_sce:1;		/* has interrupt enable/status reg */
+	bool has_clk_gat_sce:1;		/* has clock/gate selection registers */
+	bool has_enhancements:1;	/* has enhanced features */
+};
+
 /*
  * Board descriptions.
  */
@@ -386,27 +403,10 @@ enum dio200_pci_model {
 	pcie296_model
 };
 
-enum dio200_layout_idx {
-#if DO_ISA
-	pc212_layout,
-	pc214_layout,
-#endif
-	pc215_layout,
-#if DO_ISA
-	pc218_layout,
-#endif
-	pc272_layout,
-#if DO_PCI
-	pcie215_layout,
-	pcie236_layout,
-	pcie296_layout,
-#endif
-};
-
 struct dio200_board {
 	const char *name;
+	struct dio200_layout layout;
 	enum dio200_bustype bustype;
-	enum dio200_layout_idx layout;
 	unsigned char mainbar;
 	unsigned char mainshift;
 	unsigned int mainsize;
@@ -417,32 +417,61 @@ static const struct dio200_board dio200_isa_boards[] = {
 	{
 		.name = "pc212e",
 		.bustype = isa_bustype,
-		.layout = pc212_layout,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 6,
+			.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254, sd_8254,
+				   sd_intr},
+			.sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+		},
 	},
 	{
 		.name = "pc214e",
 		.bustype = isa_bustype,
-		.layout = pc214_layout,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 4,
+			.sdtype = {sd_8255, sd_8255, sd_8254, sd_intr},
+			.sdinfo = {0x00, 0x08, 0x10, 0x01},
+		},
 	},
 	{
 		.name = "pc215e",
 		.bustype = isa_bustype,
-		.layout = pc215_layout,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 5,
+			.sdtype = {sd_8255, sd_8255, sd_8254, sd_8254, sd_intr},
+			.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+		},
 	},
 	{
 		.name = "pc218e",
 		.bustype = isa_bustype,
-		.layout = pc218_layout,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 7,
+			.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254, sd_8254,
+				   sd_intr},
+			.sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+		},
 	},
 	{
 		.name = "pc272e",
 		.bustype = isa_bustype,
-		.layout = pc272_layout,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 4,
+			.sdtype = {sd_8255, sd_8255, sd_8255, sd_intr},
+			.sdinfo = {0x00, 0x08, 0x10, 0x3F},
+			.has_int_sce = true,
+		},
 	},
 };
 #endif
@@ -452,148 +481,82 @@ static const struct dio200_board dio200_pci_boards[] = {
 	[pci215_model] {
 		.name = "pci215",
 		.bustype = pci_bustype,
-		.layout = pc215_layout,
 		.mainbar = 2,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 5,
+			.sdtype = {sd_8255, sd_8255, sd_8254, sd_8254, sd_intr},
+			.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+		},
 	},
 	[pci272_model] {
 		.name = "pci272",
 		.bustype = pci_bustype,
-		.layout = pc272_layout,
 		.mainbar = 2,
 		.mainsize = DIO200_IO_SIZE,
+		.layout = {
+			.n_subdevs = 4,
+			.sdtype = {sd_8255, sd_8255, sd_8255, sd_intr},
+			.sdinfo = {0x00, 0x08, 0x10, 0x3F},
+			.has_int_sce = true,
+		},
 	},
 	[pcie215_model] {
 		.name = "pcie215",
 		.bustype = pci_bustype,
-		.layout = pcie215_layout,
 		.mainbar = 1,
 		.mainshift = 3,
 		.mainsize = DIO200_PCIE_IO_SIZE,
+		.layout = {
+			.n_subdevs = 8,
+			.sdtype = {sd_8255, sd_none, sd_8255, sd_none,
+				   sd_8254, sd_8254, sd_timer, sd_intr},
+			.sdinfo = {0x00, 0x00, 0x08, 0x00,
+				   0x10, 0x14, 0x00, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+			.has_enhancements = true,
+		},
 	},
 	[pcie236_model] {
 		.name = "pcie236",
 		.bustype = pci_bustype,
-		.layout = pcie236_layout,
 		.mainbar = 1,
 		.mainshift = 3,
 		.mainsize = DIO200_PCIE_IO_SIZE,
+		.layout = {
+			.n_subdevs = 8,
+			.sdtype = {sd_8255, sd_none, sd_none, sd_none,
+				   sd_8254, sd_8254, sd_timer, sd_intr},
+			.sdinfo = {0x00, 0x00, 0x00, 0x00,
+				   0x10, 0x14, 0x00, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+			.has_enhancements = true,
+		},
 	},
 	[pcie296_model] {
 		.name = "pcie296",
 		.bustype = pci_bustype,
-		.layout = pcie296_layout,
 		.mainbar = 1,
 		.mainshift = 3,
 		.mainsize = DIO200_PCIE_IO_SIZE,
+		.layout = {
+			.n_subdevs = 8,
+			.sdtype = {sd_8255, sd_8255, sd_8255, sd_8255,
+				   sd_8254, sd_8254, sd_timer, sd_intr},
+			.sdinfo = {0x00, 0x04, 0x08, 0x0C,
+				   0x10, 0x14, 0x00, 0x3F},
+			.has_int_sce = true,
+			.has_clk_gat_sce = true,
+			.has_enhancements = true,
+		},
 	},
 };
 #endif
 
-/*
- * Layout descriptions - some ISA and PCI board descriptions share the same
- * layout.
- */
-
-enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254, sd_timer };
-
-#define DIO200_MAX_SUBDEVS	8
-#define DIO200_MAX_ISNS		6
-
-struct dio200_layout {
-	unsigned short n_subdevs;	/* number of subdevices */
-	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
-	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
-	char has_int_sce;	/* has interrupt enable/status register */
-	char has_clk_gat_sce;	/* has clock/gate selection registers */
-	char has_enhancements;	/* has enhanced features */
-};
-
-static const struct dio200_layout dio200_layouts[] = {
-#if DO_ISA
-	[pc212_layout] = {
-			  .n_subdevs = 6,
-			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
-				     sd_8254,
-				     sd_intr},
-			  .sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
-				     0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  },
-	[pc214_layout] = {
-			  .n_subdevs = 4,
-			  .sdtype = {sd_8255, sd_8255, sd_8254,
-				     sd_intr},
-			  .sdinfo = {0x00, 0x08, 0x10, 0x01},
-			  .has_int_sce = 0,
-			  .has_clk_gat_sce = 0,
-			  },
-#endif
-	[pc215_layout] = {
-			  .n_subdevs = 5,
-			  .sdtype = {sd_8255, sd_8255, sd_8254,
-				     sd_8254,
-				     sd_intr},
-			  .sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  },
-#if DO_ISA
-	[pc218_layout] = {
-			  .n_subdevs = 7,
-			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
-				     sd_8254,
-				     sd_intr},
-			  .sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
-				     0x14,
-				     0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  },
-#endif
-	[pc272_layout] = {
-			  .n_subdevs = 4,
-			  .sdtype = {sd_8255, sd_8255, sd_8255,
-				     sd_intr},
-			  .sdinfo = {0x00, 0x08, 0x10, 0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 0,
-			  },
-#if DO_PCI
-	[pcie215_layout] = {
-			  .n_subdevs = 8,
-			  .sdtype = {sd_8255, sd_none, sd_8255, sd_none,
-				     sd_8254, sd_8254, sd_timer, sd_intr},
-			  .sdinfo = {0x00, 0x00, 0x08, 0x00,
-				     0x10, 0x14, 0x00, 0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  .has_enhancements = 1,
-			  },
-	[pcie236_layout] = {
-			  .n_subdevs = 8,
-			  .sdtype = {sd_8255, sd_none, sd_none, sd_none,
-				     sd_8254, sd_8254, sd_timer, sd_intr},
-			  .sdinfo = {0x00, 0x00, 0x00, 0x00,
-				     0x10, 0x14, 0x00, 0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  .has_enhancements = 1,
-			  },
-	[pcie296_layout] = {
-			  .n_subdevs = 8,
-			  .sdtype = {sd_8255, sd_8255, sd_8255, sd_8255,
-				     sd_8254, sd_8254, sd_timer, sd_intr},
-			  .sdinfo = {0x00, 0x04, 0x08, 0x0C,
-				     0x10, 0x14, 0x00, 0x3F},
-			  .has_int_sce = 1,
-			  .has_clk_gat_sce = 1,
-			  .has_enhancements = 1,
-			  },
-#endif
-};
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.
@@ -630,7 +593,7 @@ struct dio200_subdev_intr {
 static inline const struct dio200_layout *
 dio200_board_layout(const struct dio200_board *board)
 {
-	return &dio200_layouts[board->layout];
+	return &board->layout;
 }
 
 static inline const struct dio200_layout *

commit 470cf7261ae7a323d4657bad9d38eb36ddd2c1a2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:19:00 2013 +0000

    staging: comedi: amplc_dio200: Simplify PCI board look-up
    
    Set the `driver_data` member of each element (apart from the sentinel)
    of our PCI device table `dio200_pci_table[]` to the index of the
    corresponding element of our private PCI board details
    `dio200_pci_boards[]`.  This index appears in the context parameter of
    our auto_attach routine `dio200_auto_attach()`.  In this function,
    nename the parameter to `context_model` and use it to set
    `dev->board_ptr` to point to an element of `dio200_pci_boards[] directly
    by index instead of calling `dio200_find_pci_board()` to search for the
    element whose `devid` member matches the PCI device ID.
    
    Remove `dio200_find_pci_board()` and the `devid` member of `struct
    dio200_board`.  Also remove the `model` member of `struct dio200_board`
    and the `enum dio200_model` type as we can do without them.  The only
    function that uses the `model` member is `dio200_auto_attach()`, so use
    the `context_model` parameter instead.
    
    Define the enumerated value for each PCI board in new type `enum
    dio200_pci_model` which replaces `enum dio200_model` minus the
    enumerated values for the ISA boards (so the numeric values for the PCI
    boards have changed).  Use these enumerated values to designate the
    initializer for each element of `dio200_pci_boards[]`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index a0e894af1e95..4ed4e9458315 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -378,14 +378,12 @@ struct dio200_region {
 
 enum dio200_bustype { isa_bustype, pci_bustype };
 
-enum dio200_model {
-	pc212e_model,
-	pc214e_model,
-	pc215e_model, pci215_model, pcie215_model,
-	pc218e_model,
+enum dio200_pci_model {
+	pci215_model,
+	pci272_model,
+	pcie215_model,
 	pcie236_model,
-	pc272e_model, pci272_model,
-	pcie296_model,
+	pcie296_model
 };
 
 enum dio200_layout_idx {
@@ -407,9 +405,7 @@ enum dio200_layout_idx {
 
 struct dio200_board {
 	const char *name;
-	unsigned short devid;
 	enum dio200_bustype bustype;
-	enum dio200_model model;
 	enum dio200_layout_idx layout;
 	unsigned char mainbar;
 	unsigned char mainshift;
@@ -421,35 +417,30 @@ static const struct dio200_board dio200_isa_boards[] = {
 	{
 		.name = "pc212e",
 		.bustype = isa_bustype,
-		.model = pc212e_model,
 		.layout = pc212_layout,
 		.mainsize = DIO200_IO_SIZE,
 	},
 	{
 		.name = "pc214e",
 		.bustype = isa_bustype,
-		.model = pc214e_model,
 		.layout = pc214_layout,
 		.mainsize = DIO200_IO_SIZE,
 	},
 	{
 		.name = "pc215e",
 		.bustype = isa_bustype,
-		.model = pc215e_model,
 		.layout = pc215_layout,
 		.mainsize = DIO200_IO_SIZE,
 	},
 	{
 		.name = "pc218e",
 		.bustype = isa_bustype,
-		.model = pc218e_model,
 		.layout = pc218_layout,
 		.mainsize = DIO200_IO_SIZE,
 	},
 	{
 		.name = "pc272e",
 		.bustype = isa_bustype,
-		.model = pc272e_model,
 		.layout = pc272_layout,
 		.mainsize = DIO200_IO_SIZE,
 	},
@@ -458,49 +449,39 @@ static const struct dio200_board dio200_isa_boards[] = {
 
 #if DO_PCI
 static const struct dio200_board dio200_pci_boards[] = {
-	{
+	[pci215_model] {
 		.name = "pci215",
-		.devid = PCI_DEVICE_ID_AMPLICON_PCI215,
 		.bustype = pci_bustype,
-		.model = pci215_model,
 		.layout = pc215_layout,
 		.mainbar = 2,
 		.mainsize = DIO200_IO_SIZE,
 	},
-	{
+	[pci272_model] {
 		.name = "pci272",
-		.devid = PCI_DEVICE_ID_AMPLICON_PCI272,
 		.bustype = pci_bustype,
-		.model = pci272_model,
 		.layout = pc272_layout,
 		.mainbar = 2,
 		.mainsize = DIO200_IO_SIZE,
 	},
-	{
+	[pcie215_model] {
 		.name = "pcie215",
-		.devid = PCI_DEVICE_ID_AMPLICON_PCIE215,
 		.bustype = pci_bustype,
-		.model = pcie215_model,
 		.layout = pcie215_layout,
 		.mainbar = 1,
 		.mainshift = 3,
 		.mainsize = DIO200_PCIE_IO_SIZE,
 	},
-	{
+	[pcie236_model] {
 		.name = "pcie236",
-		.devid = PCI_DEVICE_ID_AMPLICON_PCIE236,
 		.bustype = pci_bustype,
-		.model = pcie236_model,
 		.layout = pcie236_layout,
 		.mainbar = 1,
 		.mainshift = 3,
 		.mainsize = DIO200_PCIE_IO_SIZE,
 	},
-	{
+	[pcie296_model] {
 		.name = "pcie296",
-		.devid = PCI_DEVICE_ID_AMPLICON_PCIE296,
 		.bustype = pci_bustype,
-		.model = pcie296_model,
 		.layout = pcie296_layout,
 		.mainbar = 1,
 		.mainshift = 3,
@@ -732,20 +713,6 @@ static void dio200_write32(struct comedi_device *dev, unsigned int offset,
 		writel(val, devpriv->io.u.membase + offset);
 }
 
-/*
- * This function looks for a board matching the supplied PCI device.
- */
-static const struct dio200_board *
-dio200_find_pci_board(struct pci_dev *pci_dev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(dio200_pci_boards); i++)
-		if (pci_dev->device == dio200_pci_boards[i].devid)
-			return &dio200_pci_boards[i];
-	return NULL;
-}
-
 /*
  * This function checks and requests an I/O region, reporting an error
  * if there is a conflict.
@@ -1908,13 +1875,13 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 /*
  * The auto_attach hook is called at PCI probe time via
  * comedi_pci_auto_config().  dev->board_ptr is NULL on entry.
- * There should be a board entry matching the supplied PCI device.
+ * The context should be an index into dio200_pci_boards[].
  */
 static int dio200_auto_attach(struct comedi_device *dev,
-					unsigned long context_unused)
+			      unsigned long context_model)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
-	const struct dio200_board *thisboard;
+	const struct dio200_board *thisboard = NULL;
 	struct dio200_private *devpriv;
 	resource_size_t base, len;
 	unsigned int bar;
@@ -1923,6 +1890,13 @@ static int dio200_auto_attach(struct comedi_device *dev,
 	if (!DO_PCI)
 		return -EINVAL;
 
+	if (context_model < ARRAY_SIZE(dio200_pci_boards))
+		thisboard = &dio200_pci_boards[context_model];
+	if (!thisboard)
+		return -EINVAL;
+	dev->board_ptr = thisboard;
+	dev->board_name = thisboard->name;
+
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
 		 pci_name(pci_dev));
 
@@ -1931,13 +1905,6 @@ static int dio200_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	dev->board_ptr = dio200_find_pci_board(pci_dev);
-	if (dev->board_ptr == NULL) {
-		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
-	thisboard = comedi_board(dev);
-
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
@@ -1961,7 +1928,7 @@ static int dio200_auto_attach(struct comedi_device *dev,
 		devpriv->io.u.iobase = (unsigned long)base;
 		devpriv->io.regtype = io_regtype;
 	}
-	switch (thisboard->model) {
+	switch (context_model) {
 	case pcie215_model:
 	case pcie236_model:
 	case pcie296_model:
@@ -2042,11 +2009,22 @@ static struct comedi_driver amplc_dio200_driver = {
 
 #if DO_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE236) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE215) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE296) },
+	{
+		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215),
+		pci215_model
+	}, {
+		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272),
+		pci272_model
+	}, {
+		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE236),
+		pcie236_model
+	}, {
+		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE215),
+		pcie215_model
+	}, {
+		PCI_VDEVICE(AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE296),
+		pcie296_model
+	},
 	{0}
 };
 
@@ -2063,7 +2041,7 @@ static struct pci_driver amplc_dio200_pci_driver = {
 	.name = DIO200_DRIVER_NAME,
 	.id_table = dio200_pci_table,
 	.probe = &amplc_dio200_pci_probe,
-	.remove		= comedi_pci_auto_unconfig,
+	.remove	= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
 #else

commit 3c6b670d4fa1c811f80a11aa4a3b68ea257a7179
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:18:59 2013 +0000

    staging: comedi: amplc_dio200: don't check bus type in attach
    
    Since the legacy attach routine `dio200_attach()` is only called for board
    names matching an entry in our array of ISA boards
    `dio200_isa_boards[]`, and it is reasonable to expect all elements of
    `dio200_isa_boards[]` to have their `bustype` member initialized
    correctly to `isa_bustype`, don't bother checking the bus type in
    `dio200_attach()`.  Add `if (!DO_ISA) return -EINVAL` to optimize out
    the remainder of the function if `CONFIG_COMEDI_AMPLC_DIO200_ISA` is not
    defined.
    
    Similarly, don't bother checking the bus type in
    `dio200_find_pci_board()` as it is reasonable to expect all elements of
    `dio200_pci_boards[]` to have their `bustype` member initialized
    correctly to `pci_bustype`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 8fa8fecf64bb..a0e894af1e95 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -741,8 +741,7 @@ dio200_find_pci_board(struct pci_dev *pci_dev)
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(dio200_pci_boards); i++)
-		if (is_pci_board(&dio200_pci_boards[i]) &&
-		    pci_dev->device == dio200_pci_boards[i].devid)
+		if (pci_dev->device == dio200_pci_boards[i].devid)
 			return &dio200_pci_boards[i];
 	return NULL;
 }
@@ -1877,18 +1876,18 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 	return 1;
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
+/* Only called for ISA boards. */
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv;
+	unsigned long iobase;
+	unsigned int irq;
 	int ret;
 
+	if (!DO_ISA)
+		return -EINVAL;
+
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
 
 	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
@@ -1896,29 +1895,14 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	/* Process options and reserve resources according to bus type. */
-	if (is_isa_board(thisboard)) {
-		unsigned long iobase;
-		unsigned int irq;
-
-		iobase = it->options[0];
-		irq = it->options[1];
-		ret = dio200_request_region(dev, iobase, thisboard->mainsize);
-		if (ret < 0)
-			return ret;
-		devpriv->io.u.iobase = iobase;
-		devpriv->io.regtype = io_regtype;
-		return dio200_common_attach(dev, irq, 0);
-	} else if (is_pci_board(thisboard)) {
-		dev_err(dev->class_dev,
-			"Manual configuration of PCI board '%s' is not supported\n",
-			thisboard->name);
-		return -EIO;
-	} else {
-		dev_err(dev->class_dev, DIO200_DRIVER_NAME
-			": BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
+	iobase = it->options[0];
+	irq = it->options[1];
+	ret = dio200_request_region(dev, iobase, thisboard->mainsize);
+	if (ret < 0)
+		return ret;
+	devpriv->io.u.iobase = iobase;
+	devpriv->io.regtype = io_regtype;
+	return dio200_common_attach(dev, irq, 0);
 }
 
 /*

commit 3d9bfccd13252efffbe2f31e8e66cecfd9e6cc65
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 18 17:18:58 2013 +0000

    staging: comedi: amplc_dio200: split dio200_boards[] into ISA & PCI
    
    Split `dio200_boards[]` into `dio200_isa_boards[]` for ISA cards and
    `dio200_pci_boards[]` for PCI cards.  Only initialize the board-name
    look-up members of `struct comedi_driver amplc_dio200_driver` if the ISA
    part of the driver is enabled in the kernel config
    (`CONFIG_COMEDI_AMPLC_DIO200_ISA`) using the array of ISA boards
    (`dio200_isa_boards[]`).  The driver doesn't allow manual configuration
    of PCI devices, so there is no point having the comedi core match the
    names of the PCI boards before it calls our driver's legacy attach
    routine (`dio200_attach()`).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 652494289a13..8fa8fecf64bb 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -416,95 +416,98 @@ struct dio200_board {
 	unsigned int mainsize;
 };
 
-static const struct dio200_board dio200_boards[] = {
 #if DO_ISA
+static const struct dio200_board dio200_isa_boards[] = {
 	{
-	 .name = "pc212e",
-	 .bustype = isa_bustype,
-	 .model = pc212e_model,
-	 .layout = pc212_layout,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pc212e",
+		.bustype = isa_bustype,
+		.model = pc212e_model,
+		.layout = pc212_layout,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pc214e",
-	 .bustype = isa_bustype,
-	 .model = pc214e_model,
-	 .layout = pc214_layout,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pc214e",
+		.bustype = isa_bustype,
+		.model = pc214e_model,
+		.layout = pc214_layout,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pc215e",
-	 .bustype = isa_bustype,
-	 .model = pc215e_model,
-	 .layout = pc215_layout,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pc215e",
+		.bustype = isa_bustype,
+		.model = pc215e_model,
+		.layout = pc215_layout,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pc218e",
-	 .bustype = isa_bustype,
-	 .model = pc218e_model,
-	 .layout = pc218_layout,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pc218e",
+		.bustype = isa_bustype,
+		.model = pc218e_model,
+		.layout = pc218_layout,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pc272e",
-	 .bustype = isa_bustype,
-	 .model = pc272e_model,
-	 .layout = pc272_layout,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pc272e",
+		.bustype = isa_bustype,
+		.model = pc272e_model,
+		.layout = pc272_layout,
+		.mainsize = DIO200_IO_SIZE,
+	},
+};
 #endif
+
 #if DO_PCI
+static const struct dio200_board dio200_pci_boards[] = {
 	{
-	 .name = "pci215",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
-	 .bustype = pci_bustype,
-	 .model = pci215_model,
-	 .layout = pc215_layout,
-	 .mainbar = 2,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pci215",
+		.devid = PCI_DEVICE_ID_AMPLICON_PCI215,
+		.bustype = pci_bustype,
+		.model = pci215_model,
+		.layout = pc215_layout,
+		.mainbar = 2,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pci272",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCI272,
-	 .bustype = pci_bustype,
-	 .model = pci272_model,
-	 .layout = pc272_layout,
-	 .mainbar = 2,
-	 .mainsize = DIO200_IO_SIZE,
-	 },
+		.name = "pci272",
+		.devid = PCI_DEVICE_ID_AMPLICON_PCI272,
+		.bustype = pci_bustype,
+		.model = pci272_model,
+		.layout = pc272_layout,
+		.mainbar = 2,
+		.mainsize = DIO200_IO_SIZE,
+	},
 	{
-	 .name = "pcie215",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE215,
-	 .bustype = pci_bustype,
-	 .model = pcie215_model,
-	 .layout = pcie215_layout,
-	 .mainbar = 1,
-	 .mainshift = 3,
-	 .mainsize = DIO200_PCIE_IO_SIZE,
-	 },
+		.name = "pcie215",
+		.devid = PCI_DEVICE_ID_AMPLICON_PCIE215,
+		.bustype = pci_bustype,
+		.model = pcie215_model,
+		.layout = pcie215_layout,
+		.mainbar = 1,
+		.mainshift = 3,
+		.mainsize = DIO200_PCIE_IO_SIZE,
+	},
 	{
-	 .name = "pcie236",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE236,
-	 .bustype = pci_bustype,
-	 .model = pcie236_model,
-	 .layout = pcie236_layout,
-	 .mainbar = 1,
-	 .mainshift = 3,
-	 .mainsize = DIO200_PCIE_IO_SIZE,
-	 },
+		.name = "pcie236",
+		.devid = PCI_DEVICE_ID_AMPLICON_PCIE236,
+		.bustype = pci_bustype,
+		.model = pcie236_model,
+		.layout = pcie236_layout,
+		.mainbar = 1,
+		.mainshift = 3,
+		.mainsize = DIO200_PCIE_IO_SIZE,
+	},
 	{
-	 .name = "pcie296",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE296,
-	 .bustype = pci_bustype,
-	 .model = pcie296_model,
-	 .layout = pcie296_layout,
-	 .mainbar = 1,
-	 .mainshift = 3,
-	 .mainsize = DIO200_PCIE_IO_SIZE,
-	 },
-#endif
+		.name = "pcie296",
+		.devid = PCI_DEVICE_ID_AMPLICON_PCIE296,
+		.bustype = pci_bustype,
+		.model = pcie296_model,
+		.layout = pcie296_layout,
+		.mainbar = 1,
+		.mainshift = 3,
+		.mainsize = DIO200_PCIE_IO_SIZE,
+	},
 };
+#endif
 
 /*
  * Layout descriptions - some ISA and PCI board descriptions share the same
@@ -737,10 +740,10 @@ dio200_find_pci_board(struct pci_dev *pci_dev)
 {
 	unsigned int i;
 
-	for (i = 0; i < ARRAY_SIZE(dio200_boards); i++)
-		if (is_pci_board(&dio200_boards[i]) &&
-		    pci_dev->device == dio200_boards[i].devid)
-			return &dio200_boards[i];
+	for (i = 0; i < ARRAY_SIZE(dio200_pci_boards); i++)
+		if (is_pci_board(&dio200_pci_boards[i]) &&
+		    pci_dev->device == dio200_pci_boards[i].devid)
+			return &dio200_pci_boards[i];
 	return NULL;
 }
 
@@ -2046,9 +2049,11 @@ static struct comedi_driver amplc_dio200_driver = {
 	.attach = dio200_attach,
 	.auto_attach = dio200_auto_attach,
 	.detach = dio200_detach,
-	.board_name = &dio200_boards[0].name,
+#if DO_ISA
+	.board_name = &dio200_isa_boards[0].name,
 	.offset = sizeof(struct dio200_board),
-	.num_names = ARRAY_SIZE(dio200_boards),
+	.num_names = ARRAY_SIZE(dio200_isa_boards),
+#endif
 };
 
 #if DO_PCI

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d13a6dddcd09..652494289a13 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1950,12 +1950,11 @@ static int dio200_auto_attach(struct comedi_device *dev,
 		return -EINVAL;
 	}
 	thisboard = comedi_board(dev);
-	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
-	if (ret < 0) {
-		dev_err(dev->class_dev,
-			"error! cannot enable PCI device and request regions!\n");
+
+	ret = comedi_pci_enable(dev);
+	if (ret)
 		return ret;
-	}
+
 	bar = thisboard->mainbar;
 	base = pci_resource_start(pci_dev, bar);
 	len = pci_resource_len(pci_dev, bar);

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 82f80d563fbe..d13a6dddcd09 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -2029,14 +2029,9 @@ static void dio200_detach(struct comedi_device *dev)
 			release_region(devpriv->io.u.iobase,
 				       thisboard->mainsize);
 	} else if (is_pci_board(thisboard)) {
-		struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-		if (pcidev) {
-			if (devpriv->io.regtype != no_regtype) {
-				if (devpriv->io.regtype == mmio_regtype)
-					iounmap(devpriv->io.u.membase);
-				comedi_pci_disable(pcidev);
-			}
-		}
+		if (devpriv->io.regtype == mmio_regtype)
+			iounmap(devpriv->io.u.membase);
+		comedi_pci_disable(dev);
 	}
 }
 

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 7c53dea12c76..82f80d563fbe 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -2070,10 +2070,10 @@ static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);
 
 static int amplc_dio200_pci_probe(struct pci_dev *dev,
-						   const struct pci_device_id
-						   *ent)
+				  const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
+	return comedi_pci_auto_config(dev, &amplc_dio200_driver,
+				      id->driver_data);
 }
 
 static struct pci_driver amplc_dio200_pci_driver = {

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index b30d1a05c33c..7c53dea12c76 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1105,10 +1105,9 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct dio200_subdev_intr *subpriv;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
-	if (!subpriv) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	if (!subpriv)
 		return -ENOMEM;
-	}
+
 	subpriv->ofs = offset;
 	subpriv->valid_isns = valid_isns;
 	spin_lock_init(&subpriv->spinlock);
@@ -1444,10 +1443,8 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int chan;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
-	if (!subpriv) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	if (!subpriv)
 		return -ENOMEM;
-	}
 
 	s->private = subpriv;
 	s->type = COMEDI_SUBD_COUNTER;

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 1fadf5d0ad26..b30d1a05c33c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -258,6 +258,7 @@
  * order they appear in the channel list.
  */
 
+#include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index b09269d1902a..1fadf5d0ad26 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -2078,16 +2078,11 @@ static int amplc_dio200_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
 }
 
-static void amplc_dio200_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static struct pci_driver amplc_dio200_pci_driver = {
 	.name = DIO200_DRIVER_NAME,
 	.id_table = dio200_pci_table,
 	.probe = &amplc_dio200_pci_probe,
-	.remove = &amplc_dio200_pci_remove
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
 #else

commit 4156a7603709b2232603b10f1835f351d89b263e
Author: Jake Champlin <jake.champlin.27@gmail.com>
Date:   Fri Jan 18 20:23:36 2013 -0500

    Staging: Comedi: amplc_dio200: Fixed bracing issue
    
    Fixed coding style error
    
    Signed-off-by: Jake Champlin <jake.champlin.27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 5f309ba88a1a..b09269d1902a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1977,8 +1977,7 @@ static int dio200_auto_attach(struct comedi_device *dev,
 		devpriv->io.u.iobase = (unsigned long)base;
 		devpriv->io.regtype = io_regtype;
 	}
-	switch (thisboard->model)
-	{
+	switch (thisboard->model) {
 	case pcie215_model:
 	case pcie236_model:
 	case pcie296_model:

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 4fd28e3dd807..5f309ba88a1a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -2079,7 +2079,7 @@ static int amplc_dio200_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
 }
 
-static void __devexit amplc_dio200_pci_remove(struct pci_dev *dev)
+static void amplc_dio200_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 909acf89f4ff..4fd28e3dd807 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1925,7 +1925,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  * comedi_pci_auto_config().  dev->board_ptr is NULL on entry.
  * There should be a board entry matching the supplied PCI device.
  */
-static int __devinit dio200_auto_attach(struct comedi_device *dev,
+static int dio200_auto_attach(struct comedi_device *dev,
 					unsigned long context_unused)
 {
 	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
@@ -2072,7 +2072,7 @@ static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);
 
-static int __devinit amplc_dio200_pci_probe(struct pci_dev *dev,
+static int amplc_dio200_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 57c618b4e989..909acf89f4ff 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -2088,7 +2088,7 @@ static struct pci_driver amplc_dio200_pci_driver = {
 	.name = DIO200_DRIVER_NAME,
 	.id_table = dio200_pci_table,
 	.probe = &amplc_dio200_pci_probe,
-	.remove = __devexit_p(&amplc_dio200_pci_remove)
+	.remove = &amplc_dio200_pci_remove
 };
 module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
 #else

commit a1d6de5a9807ae45e5fbd167c8568c0e9fca71f0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:49:22 2012 -0700

    staging: comedi: amplc_dio200: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of dio200_subdev_intr_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index cb75a177c9a2..57c618b4e989 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1020,41 +1020,19 @@ dio200_subdev_intr_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_begin_src == TRIG_EXT */
-	if (cmd->scan_begin_arg != 0) {
-		cmd->scan_begin_arg = 0;
-		err++;
-	}
-
-	/* cmd->convert_src == TRIG_NOW */
-	if (cmd->convert_arg != 0) {
-		cmd->convert_arg = 0;
-		err++;
-	}
-
-	/* cmd->scan_end_src == TRIG_COUNT */
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		/* any count allowed */
 		break;
 	case TRIG_NONE:
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 		break;
 	default:
 		break;

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index ffe3f7385c7c..cb75a177c9a2 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1943,13 +1943,14 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 }
 
 /*
- * The attach_pci hook (if non-NULL) is called at PCI probe time in preference
- * to the "manual" attach hook.  dev->board_ptr is NULL on entry.  There should
- * be a board entry matching the supplied PCI device.
+ * The auto_attach hook is called at PCI probe time via
+ * comedi_pci_auto_config().  dev->board_ptr is NULL on entry.
+ * There should be a board entry matching the supplied PCI device.
  */
-static int __devinit dio200_attach_pci(struct comedi_device *dev,
-				       struct pci_dev *pci_dev)
+static int __devinit dio200_auto_attach(struct comedi_device *dev,
+					unsigned long context_unused)
 {
+	struct pci_dev *pci_dev = comedi_to_pci_dev(dev);
 	const struct dio200_board *thisboard;
 	struct dio200_private *devpriv;
 	resource_size_t base, len;
@@ -2074,7 +2075,7 @@ static struct comedi_driver amplc_dio200_driver = {
 	.driver_name = DIO200_DRIVER_NAME,
 	.module = THIS_MODULE,
 	.attach = dio200_attach,
-	.attach_pci = dio200_attach_pci,
+	.auto_attach = dio200_auto_attach,
 	.detach = dio200_detach,
 	.board_name = &dio200_boards[0].name,
 	.offset = sizeof(struct dio200_board),

commit 2847ff5d1b63496c2e3eedb8efad2752cc2e195d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 18:14:40 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_AMPLICON
    
    Add a define for the Amplicon Liveline Limited PCI vendor id.
    Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 95c3f7824d81..ffe3f7385c7c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -272,7 +272,6 @@
 #define DO_PCI	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
 
 /* PCI IDs */
-#define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
 #define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
 #define PCI_DEVICE_ID_AMPLICON_PCIE236 0x0011

commit fad18543cef4d6368b00fb318d0b31d1e2deabb6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:13 2012 +0100

    staging: comedi: amplc_dio200: support multiple read/write of counter
    
    Change the `insn_read` and `insn_write` handlers of the '8254' counter
    subdevices to support reading and writing multiple data values.
    (Writing multiple values isn't very useful, but if that's what the user
    wants....)
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d72a86b3e9ff..95c3f7824d81 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1270,13 +1270,15 @@ dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
+	unsigned int n;
 	unsigned long flags;
 
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	data[0] = dio200_subdev_8254_read_chan(dev, s, chan);
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-
-	return 1;
+	for (n = 0; n < insn->n; n++) {
+		spin_lock_irqsave(&subpriv->spinlock, flags);
+		data[n] = dio200_subdev_8254_read_chan(dev, s, chan);
+		spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	}
+	return insn->n;
 }
 
 /*
@@ -1288,13 +1290,15 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
+	unsigned int n;
 	unsigned long flags;
 
-	spin_lock_irqsave(&subpriv->spinlock, flags);
-	dio200_subdev_8254_write_chan(dev, s, chan, data[0]);
-	spin_unlock_irqrestore(&subpriv->spinlock, flags);
-
-	return 1;
+	for (n = 0; n < insn->n; n++) {
+		spin_lock_irqsave(&subpriv->spinlock, flags);
+		dio200_subdev_8254_write_chan(dev, s, chan, data[n]);
+		spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	}
+	return insn->n;
 }
 
 /*

commit 18cbf973a9a77e0b6128d4c187f337f4dc94df90
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:11 2012 +0100

    staging: comedi: amplc_dio200: implement timer subdevice
    
    Implement the timer subdevice for the new PCIe boards.  The subdevice was
    previously marked as unused, but was reserved for this purpose.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 768a269d48f8..d72a86b3e9ff 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -301,6 +301,8 @@
 /* Extra registers for new PCIe boards */
 #define DIO200_ENHANCE		0x20	/* 1 to enable enhanced features */
 #define DIO200_VERSION		0x24	/* Hardware version register */
+#define DIO200_TS_CONFIG	0x600	/* Timestamp timer config register */
+#define DIO200_TS_COUNT		0x602	/* Timestamp timer count register */
 
 /*
  * Functions for constructing value for DIO_200_?CLK_SCE and
@@ -342,6 +344,22 @@ static const unsigned int clock_period[32] = {
 	/* clock sources 12 and later reserved for enhanced boards */
 };
 
+/*
+ * Timestamp timer configuration register (for new PCIe boards).
+ */
+#define TS_CONFIG_RESET		0x100	/* Reset counter to zero. */
+#define TS_CONFIG_CLK_SRC_MASK	0x0FF	/* Clock source. */
+#define TS_CONFIG_MAX_CLK_SRC	2	/* Maximum clock source value. */
+
+/*
+ * Periods of the timestamp timer clock sources in nanoseconds.
+ */
+static const unsigned int ts_clock_period[TS_CONFIG_MAX_CLK_SRC + 1] = {
+	1,			/* 1 nanosecond (but with 20 ns granularity). */
+	1000,			/* 1 microsecond. */
+	1000000,		/* 1 millisecond. */
+};
+
 /*
  * Register region.
  */
@@ -1621,6 +1639,118 @@ static void dio200_subdev_8255_cleanup(struct comedi_device *dev,
 	kfree(subpriv);
 }
 
+/*
+ * Handle 'insn_read' for a timer subdevice.
+ */
+static int dio200_subdev_timer_read(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
+{
+	unsigned int n;
+
+	for (n = 0; n < insn->n; n++)
+		data[n] = dio200_read32(dev, DIO200_TS_COUNT);
+	return n;
+}
+
+/*
+ * Reset timer subdevice.
+ */
+static void dio200_subdev_timer_reset(struct comedi_device *dev,
+				      struct comedi_subdevice *s)
+{
+	unsigned int clock;
+
+	clock = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;
+	dio200_write32(dev, DIO200_TS_CONFIG, clock | TS_CONFIG_RESET);
+	dio200_write32(dev, DIO200_TS_CONFIG, clock);
+}
+
+/*
+ * Get timer subdevice clock source and period.
+ */
+static void dio200_subdev_timer_get_clock_src(struct comedi_device *dev,
+					      struct comedi_subdevice *s,
+					      unsigned int *src,
+					      unsigned int *period)
+{
+	unsigned int clk;
+
+	clk = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;
+	*src = clk;
+	*period = (clk < ARRAY_SIZE(ts_clock_period)) ?
+		  ts_clock_period[clk] : 0;
+}
+
+/*
+ * Set timer subdevice clock source.
+ */
+static int dio200_subdev_timer_set_clock_src(struct comedi_device *dev,
+					     struct comedi_subdevice *s,
+					     unsigned int src)
+{
+	if (src > TS_CONFIG_MAX_CLK_SRC)
+		return -EINVAL;
+	dio200_write32(dev, DIO200_TS_CONFIG, src);
+	return 0;
+}
+
+/*
+ * Handle 'insn_config' for a timer subdevice.
+ */
+static int dio200_subdev_timer_config(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
+{
+	int ret = 0;
+
+	switch (data[0]) {
+	case INSN_CONFIG_RESET:
+		dio200_subdev_timer_reset(dev, s);
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		ret = dio200_subdev_timer_set_clock_src(dev, s, data[1]);
+		if (ret < 0)
+			ret = -EINVAL;
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		dio200_subdev_timer_get_clock_src(dev, s, &data[1], &data[2]);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret < 0 ? ret : insn->n;
+}
+
+/*
+ * This function initializes a timer subdevice.
+ *
+ * Uses the timestamp timer registers.  There is only one timestamp timer.
+ */
+static int dio200_subdev_timer_init(struct comedi_device *dev,
+				    struct comedi_subdevice *s)
+{
+	s->type = COMEDI_SUBD_TIMER;
+	s->subdev_flags = SDF_READABLE | SDF_LSAMPL;
+	s->n_chan = 1;
+	s->maxdata = 0xFFFFFFFF;
+	s->insn_read = dio200_subdev_timer_read;
+	s->insn_config = dio200_subdev_timer_config;
+	return 0;
+}
+
+/*
+ * This function cleans up a timer subdevice.
+ */
+static void dio200_subdev_timer_cleanup(struct comedi_device *dev,
+					struct comedi_subdevice *s)
+{
+	/* Nothing to do. */
+}
+
 /*
  * This function does some special set-up for the PCIe boards
  * PCIe215, PCIe236, PCIe296.
@@ -1735,7 +1865,15 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 			}
 			break;
 		case sd_timer:
-			/* TODO.  Fall-thru to default for now. */
+			/* Only on PCIe boards. */
+			if (DO_PCI) {
+				ret = dio200_subdev_timer_init(dev, s);
+				if (ret < 0)
+					return ret;
+			} else {
+				s->type = COMEDI_SUBD_UNUSED;
+			}
+			break;
 		default:
 			s->type = COMEDI_SUBD_UNUSED;
 			break;
@@ -1897,6 +2035,11 @@ static void dio200_detach(struct comedi_device *dev)
 			case sd_intr:
 				dio200_subdev_intr_cleanup(dev, s);
 				break;
+			case sd_timer:
+				/* Only on PCIe boards. */
+				if (DO_PCI)
+					dio200_subdev_timer_cleanup(dev, s);
+				break;
 			default:
 				break;
 			}

commit 87276012ead9f96f249fedf715b1052106f2e0d0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:10 2012 +0100

    staging: comedi: amplc_dio200: add 32-bit register access functions
    
    These are currently unused but will be used to support extra features of
    the PCIe boards.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 34bbf9bddccc..768a269d48f8 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -679,6 +679,38 @@ static void dio200_write8(struct comedi_device *dev, unsigned int offset,
 		writeb(val, devpriv->io.u.membase + offset);
 }
 
+/*
+ * Read 32-bit register.
+ */
+static unsigned int dio200_read32(struct comedi_device *dev,
+				  unsigned int offset)
+{
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
+
+	offset <<= thisboard->mainshift;
+	if (devpriv->io.regtype == io_regtype)
+		return inl(devpriv->io.u.iobase + offset);
+	else
+		return readl(devpriv->io.u.membase + offset);
+}
+
+/*
+ * Write 32-bit register.
+ */
+static void dio200_write32(struct comedi_device *dev, unsigned int offset,
+			   unsigned int val)
+{
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
+
+	offset <<= thisboard->mainshift;
+	if (devpriv->io.regtype == io_regtype)
+		outl(val, devpriv->io.u.iobase + offset);
+	else
+		writel(val, devpriv->io.u.membase + offset);
+}
+
 /*
  * This function looks for a board matching the supplied PCI device.
  */

commit b61ce8e2ff029e2b2cdf5ec2dc7118f3ab1e01cd
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:08 2012 +0100

    staging: comedi: amplc_dio200: allow extra clock and gate sources
    
    One of the enhancements of the new PCIe boards is the addition of extra
    clock and gate sources.  Allow clock and gate sources up to 31 for these
    boards (compared to 7 for the old boards) although most of those are
    reserved for future use.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 1fc6d63398eb..34bbf9bddccc 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -120,6 +120,14 @@
  *         the SK1 connector.  This pin is shared by all three counter
  *         channels on the chip.
  *
+ *     For the PCIe boards, clock sources in the range 0 to 31 are allowed
+ *     and the following additional clock sources are defined:
+ *
+ *       8.  HIGH logic level.
+ *       9.  LOW logic level.
+ *      10.  "Pattern present" signal.
+ *      11.  Internal 20 MHz clock.
+ *
  *   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
  *     clock source in data[1].  For internal clock sources, data[2] is set
  *     to the period in ns.
@@ -141,6 +149,27 @@
  *       6.  Reserved.
  *       7.  Reserved.
  *
+ *     For the PCIe boards, gate sources in the range 0 to 31 are allowed;
+ *     the following additional clock sources and clock sources 6 and 7 are
+ *     (re)defined:
+ *
+ *       6.  /GAT n, negated version of the counter channel's dedicated
+ *         GAT input (negated version of gate source 2).
+ *       7.  OUT n-2, the non-inverted output of counter channel n-2
+ *         (negated version of gate source 3).
+ *       8.  "Pattern present" signal, HIGH while pattern present.
+ *       9.  "Pattern occurred" latched signal, latches HIGH when pattern
+ *         occurs.
+ *      10.  "Pattern gone away" latched signal, latches LOW when pattern
+ *         goes away after it occurred.
+ *      11.  Negated "pattern present" signal, LOW while pattern present
+ *         (negated version of gate source 8).
+ *      12.  Negated "pattern occurred" latched signal, latches LOW when
+ *         pattern occurs (negated version of gate source 9).
+ *      13.  Negated "pattern gone away" latched signal, latches LOW when
+ *         pattern goes away after it occurred (negated version of gate
+ *         source 10).
+ *
  *   INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
  *     source in data[2].
  *
@@ -274,28 +303,43 @@
 #define DIO200_VERSION		0x24	/* Hardware version register */
 
 /*
- * Macros for constructing value for DIO_200_?CLK_SCE and
+ * Functions for constructing value for DIO_200_?CLK_SCE and
  * DIO_200_?GAT_SCE registers:
  *
  * 'which' is: 0 for CTR-X1, CTR-Y1, CTR-Z1; 1 for CTR-X2, CTR-Y2 or CTR-Z2.
  * 'chan' is the channel: 0, 1 or 2.
- * 'source' is the signal source: 0 to 7.
+ * 'source' is the signal source: 0 to 7, or 0 to 31 for "enhanced" boards.
  */
-#define CLK_SCE(which, chan, source) (((which) << 5) | ((chan) << 3) | (source))
-#define GAT_SCE(which, chan, source) (((which) << 5) | ((chan) << 3) | (source))
+static unsigned char clk_gat_sce(unsigned int which, unsigned int chan,
+				 unsigned int source)
+{
+	return (which << 5) | (chan << 3) |
+	       ((source & 030) << 3) | (source & 007);
+}
+
+static unsigned char clk_sce(unsigned int which, unsigned int chan,
+			     unsigned int source)
+{
+	return clk_gat_sce(which, chan, source);
+}
+
+static unsigned char gat_sce(unsigned int which, unsigned int chan,
+			     unsigned int source)
+{
+	return clk_gat_sce(which, chan, source);
+}
 
 /*
  * Periods of the internal clock sources in nanoseconds.
  */
-static const unsigned clock_period[8] = {
-	0,			/* dedicated clock input/output pin */
-	100,			/* 10 MHz */
-	1000,			/* 1 MHz */
-	10000,			/* 100 kHz */
-	100000,			/* 10 kHz */
-	1000000,		/* 1 kHz */
-	0,			/* OUT N-1 */
-	0			/* group clock input pin */
+static const unsigned int clock_period[32] = {
+	[1] = 100,		/* 10 MHz */
+	[2] = 1000,		/* 1 MHz */
+	[3] = 10000,		/* 100 kHz */
+	[4] = 100000,		/* 10 kHz */
+	[5] = 1000000,		/* 1 kHz */
+	[11] = 50,		/* 20 MHz (enhanced boards) */
+	/* clock sources 12 and later reserved for enhanced boards */
 };
 
 /*
@@ -1220,11 +1264,11 @@ dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
 		return -1;
 	if (counter_number > 2)
 		return -1;
-	if (gate_src > 7)
+	if (gate_src > (layout->has_enhancements ? 31 : 7))
 		return -1;
 
 	subpriv->gate_src[counter_number] = gate_src;
-	byte = GAT_SCE(subpriv->which, counter_number, gate_src);
+	byte = gat_sce(subpriv->which, counter_number, gate_src);
 	dio200_write8(dev, subpriv->gat_sce_ofs, byte);
 
 	return 0;
@@ -1266,11 +1310,11 @@ dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
 		return -1;
 	if (counter_number > 2)
 		return -1;
-	if (clock_src > 7)
+	if (clock_src > (layout->has_enhancements ? 31 : 7))
 		return -1;
 
 	subpriv->clock_src[counter_number] = clock_src;
-	byte = CLK_SCE(subpriv->which, counter_number, clock_src);
+	byte = clk_sce(subpriv->which, counter_number, clock_src);
 	dio200_write8(dev, subpriv->clk_sce_ofs, byte);
 
 	return 0;

commit 855d5fb469a7e9ac71358248e27d17422ad4c663
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:07 2012 +0100

    staging: comedi: amplc_dio200: enable enhanced features of PCIe boards
    
    The new PCIe boards PCIe215, PCIe236 and PCIe296 have some enhanced
    features (over the older boards), although none of these features are
    supported by this driver yet.
    
    Enable the enhanced features in hardware and use `dio200_layouts[]` to
    indicate which boards support the enhanced features.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index cf53e84c3bc4..1fc6d63398eb 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -269,6 +269,9 @@
 #define DIO200_YGAT_SCE		0x1c	/* Group Y gate selection register */
 #define DIO200_ZGAT_SCE		0x1d	/* Group Z gate selection register */
 #define DIO200_INT_SCE		0x1e	/* Interrupt enable/status register */
+/* Extra registers for new PCIe boards */
+#define DIO200_ENHANCE		0x20	/* 1 to enable enhanced features */
+#define DIO200_VERSION		0x24	/* Hardware version register */
 
 /*
  * Macros for constructing value for DIO_200_?CLK_SCE and
@@ -457,6 +460,7 @@ struct dio200_layout {
 	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
 	char has_int_sce;	/* has interrupt enable/status register */
 	char has_clk_gat_sce;	/* has clock/gate selection registers */
+	char has_enhancements;	/* has enhanced features */
 };
 
 static const struct dio200_layout dio200_layouts[] = {
@@ -519,6 +523,7 @@ static const struct dio200_layout dio200_layouts[] = {
 				     0x10, 0x14, 0x00, 0x3F},
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
+			  .has_enhancements = 1,
 			  },
 	[pcie236_layout] = {
 			  .n_subdevs = 8,
@@ -528,6 +533,7 @@ static const struct dio200_layout dio200_layouts[] = {
 				     0x10, 0x14, 0x00, 0x3F},
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
+			  .has_enhancements = 1,
 			  },
 	[pcie296_layout] = {
 			  .n_subdevs = 8,
@@ -537,6 +543,7 @@ static const struct dio200_layout dio200_layouts[] = {
 				     0x10, 0x14, 0x00, 0x3F},
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
+			  .has_enhancements = 1,
 			  },
 #endif
 };
@@ -1571,6 +1578,8 @@ static int dio200_pcie_board_setup(struct comedi_device *dev)
 	}
 	writel(0x80, brbase + 0x50);
 	iounmap(brbase);
+	/* Enable "enhanced" features of board. */
+	dio200_write8(dev, DIO200_ENHANCE, 1);
 	return 0;
 }
 

commit c5f68d79259ee61b58197b0f751411e0196560f2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:06 2012 +0100

    staging: comedi: amplc_dio200: allow generation of PCIe interrupts
    
    The new PCIe boards PCIe215, PCIe236 and PCIe296 need a special register
    setting to allow generation of interrupts on the PCIe bus.  Add
    `dio200_pcie_board_setup()` to do this and call it from
    `dio200_attach_pci()` for those boards.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index a7a1be9ad728..cf53e84c3bc4 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1538,6 +1538,42 @@ static void dio200_subdev_8255_cleanup(struct comedi_device *dev,
 	kfree(subpriv);
 }
 
+/*
+ * This function does some special set-up for the PCIe boards
+ * PCIe215, PCIe236, PCIe296.
+ */
+static int dio200_pcie_board_setup(struct comedi_device *dev)
+{
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+	void __iomem *brbase;
+	resource_size_t brlen;
+
+	/*
+	 * The board uses Altera Cyclone IV with PCI-Express hard IP.
+	 * The FPGA configuration has the PCI-Express Avalon-MM Bridge
+	 * Control registers in PCI BAR 0, offset 0, and the length of
+	 * these registers is 0x4000.
+	 *
+	 * We need to write 0x80 to the "Avalon-MM to PCI-Express Interrupt
+	 * Enable" register at offset 0x50 to allow generation of PCIe
+	 * interrupts when RXmlrq_i is asserted in the SOPC Builder system.
+	 */
+	brlen = pci_resource_len(pcidev, 0);
+	if (brlen < 0x4000 ||
+			!(pci_resource_flags(pcidev, 0) & IORESOURCE_MEM)) {
+		dev_err(dev->class_dev, "error! bad PCI region!\n");
+		return -EINVAL;
+	}
+	brbase = ioremap_nocache(pci_resource_start(pcidev, 0), brlen);
+	if (!brbase) {
+		dev_err(dev->class_dev, "error! failed to map registers!\n");
+		return -ENOMEM;
+	}
+	writel(0x80, brbase + 0x50);
+	iounmap(brbase);
+	return 0;
+}
+
 static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
@@ -1736,6 +1772,18 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 		devpriv->io.u.iobase = (unsigned long)base;
 		devpriv->io.regtype = io_regtype;
 	}
+	switch (thisboard->model)
+	{
+	case pcie215_model:
+	case pcie236_model:
+	case pcie296_model:
+		ret = dio200_pcie_board_setup(dev);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	}
 	return dio200_common_attach(dev, pci_dev->irq, IRQF_SHARED);
 }
 

commit 2421a0242e17445ab35f7b450d0768518f0f63e6
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:05 2012 +0100

    staging: comedi: amplc_dio200: support PCIe215, PCIe236 and PCIe296
    
    Add preliminary support for the above PCIe boards.  The interrupt
    subdevice is not working yet as the boards need some additional
    initialization to enable interrupts.  Reserve an unused subdevice that
    will eventually become a timer subdevice.
    
    Some unused subdevices have been added between the used subdevices on
    the PCIe215 and PCIe236.  This is so the subdevice numbers will match a
    pattern-matching feature to be added at a later date, where the
    pattern-match specifications for a subdevice include pattern-match
    results from other subdevices, specified by index.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 2e6ea759914e..a7a1be9ad728 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -29,39 +29,55 @@
  * Description: Amplicon 200 Series Digital I/O
  * Author: Ian Abbott <abbotti@mev.co.uk>
  * Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
- *   PCI215 (pci215), PC218E (pc218e), PC272E (pc272e), PCI272 (pci272)
- * Updated: Wed, 22 Oct 2008 13:36:02 +0100
+ *   PCI215 (pci215), PCIe215 (pcie215), PC218E (pc218e), PCIe236 (pcie236),
+ *   PC272E (pc272e), PCI272 (pci272), PCIe296 (pcie296)
+ * Updated: Wed, 24 Oct 2012 16:22:34 +0100
  * Status: works
  *
  * Configuration options - PC212E, PC214E, PC215E, PC218E, PC272E:
  *   [0] - I/O port base address
  *   [1] - IRQ (optional, but commands won't work without it)
  *
- * Manual configuration of PCI cards is not supported; they are configured
+ * Manual configuration of PCI(e) cards is not supported; they are configured
  * automatically.
  *
  * Passing a zero for an option is the same as leaving it unspecified.
  *
  * SUBDEVICES
  *
- *                     PC218E         PC212E      PC215E/PCI215
+ *                     PC212E         PC214E      PC215E/PCI215
  *                  -------------  -------------  -------------
- *   Subdevices           7              6              5
- *    0                 CTR-X1         PPI-X          PPI-X
- *    1                 CTR-X2         CTR-Y1         PPI-Y
- *    2                 CTR-Y1         CTR-Y2         CTR-Z1
- *    3                 CTR-Y2         CTR-Z1         CTR-Z2
- *    4                 CTR-Z1         CTR-Z2       INTERRUPT
- *    5                 CTR-Z2       INTERRUPT
- *    6               INTERRUPT
+ *   Subdevices           6              4              5
+ *    0                 PPI-X          PPI-X          PPI-X
+ *    1                 CTR-Y1         PPI-Y          PPI-Y
+ *    2                 CTR-Y2         CTR-Z1*        CTR-Z1
+ *    3                 CTR-Z1       INTERRUPT*       CTR-Z2
+ *    4                 CTR-Z2                      INTERRUPT
+ *    5               INTERRUPT
  *
- *                     PC214E      PC272E/PCI272
+ *                     PCIe215        PC218E         PCIe236
+ *                  -------------  -------------  -------------
+ *   Subdevices           8              7              8
+ *    0                 PPI-X          CTR-X1         PPI-X
+ *    1                 UNUSED         CTR-X2         UNUSED
+ *    2                 PPI-Y          CTR-Y1         UNUSED
+ *    3                 UNUSED         CTR-Y2         UNUSED
+ *    4                 CTR-Z1         CTR-Z1         CTR-Z1
+ *    5                 CTR-Z2         CTR-Z2         CTR-Z2
+ *    6                 TIMER        INTERRUPT        TIMER
+ *    7               INTERRUPT                     INTERRUPT
+ *
+ *                  PC272E/PCI272     PCIe296
  *                  -------------  -------------
- *   Subdevices           4              4
- *    0                 PPI-X          PPI-X
- *    1                 PPI-Y          PPI-Y
- *    2                 CTR-Z1*        PPI-Z
- *    3               INTERRUPT*     INTERRUPT
+ *   Subdevices           4              8
+ *    0                 PPI-X          PPI-X1
+ *    1                 PPI-Y          PPI-X2
+ *    2                 PPI-Z          PPI-Y1
+ *    3               INTERRUPT        PPI-Y2
+ *    4                                CTR-Z1
+ *    5                                CTR-Z2
+ *    6                                TIMER
+ *    7                              INTERRUPT
  *
  * Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
  * are configurable as inputs or outputs in four groups:
@@ -141,6 +157,8 @@
  *   3.  The counter subdevices are connected in a ring, so the highest
  *   counter subdevice precedes the lowest.
  *
+ * The 'TIMER' subdevice is a free-running 32-bit timer subdevice.
+ *
  * The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
  * digital inputs come from the interrupt status register.  The number of
  * channels matches the number of interrupt sources.  The PC214E does not
@@ -149,25 +167,35 @@
  *
  * INTERRUPT SOURCES
  *
- *                     PC218E         PC212E      PC215E/PCI215
+ *                     PC212E         PC214E      PC215E/PCI215
+ *                  -------------  -------------  -------------
+ *   Sources              6              1              6
+ *    0               PPI-X-C0       JUMPER-J5      PPI-X-C0
+ *    1               PPI-X-C3                      PPI-X-C3
+ *    2              CTR-Y1-OUT1                    PPI-Y-C0
+ *    3              CTR-Y2-OUT1                    PPI-Y-C3
+ *    4              CTR-Z1-OUT1                   CTR-Z1-OUT1
+ *    5              CTR-Z2-OUT1                   CTR-Z2-OUT1
+ *
+ *                     PCIe215        PC218E         PCIe236
  *                  -------------  -------------  -------------
  *   Sources              6              6              6
- *    0              CTR-X1-OUT      PPI-X-C0       PPI-X-C0
- *    1              CTR-X2-OUT      PPI-X-C3       PPI-X-C3
- *    2              CTR-Y1-OUT     CTR-Y1-OUT      PPI-Y-C0
- *    3              CTR-Y2-OUT     CTR-Y2-OUT      PPI-Y-C3
- *    4              CTR-Z1-OUT     CTR-Z1-OUT     CTR-Z1-OUT
- *    5              CTR-Z2-OUT     CTR-Z2-OUT     CTR-Z2-OUT
+ *    0               PPI-X-C0      CTR-X1-OUT1     PPI-X-C0
+ *    1               PPI-X-C3      CTR-X2-OUT1     PPI-X-C3
+ *    2               PPI-Y-C0      CTR-Y1-OUT1      unused
+ *    3               PPI-Y-C3      CTR-Y2-OUT1      unused
+ *    4              CTR-Z1-OUT1    CTR-Z1-OUT1    CTR-Z1-OUT1
+ *    5              CTR-Z2-OUT1    CTR-Z2-OUT1    CTR-Z2-OUT1
  *
- *                     PC214E      PC272E/PCI272
+ *                  PC272E/PCI272     PCIe296
  *                  -------------  -------------
- *   Sources              1              6
- *    0               JUMPER-J5      PPI-X-C0
- *    1                              PPI-X-C3
- *    2                              PPI-Y-C0
- *    3                              PPI-Y-C3
- *    4                              PPI-Z-C0
- *    5                              PPI-Z-C3
+ *   Sources              6              6
+ *    0               PPI-X-C0       PPI-X1-C0
+ *    1               PPI-X-C3       PPI-X1-C3
+ *    2               PPI-Y-C0       PPI-Y1-C0
+ *    3               PPI-Y-C3       PPI-Y1-C3
+ *    4               PPI-Z-C0      CTR-Z1-OUT1
+ *    5               PPI-Z-C3      CTR-Z2-OUT1
  *
  * When an interrupt source is enabled in the interrupt source enable
  * register, a rising edge on the source signal latches the corresponding
@@ -218,7 +246,9 @@
 #define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
 #define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
-#define PCI_DEVICE_ID_INVALID 0xffff
+#define PCI_DEVICE_ID_AMPLICON_PCIE236 0x0011
+#define PCI_DEVICE_ID_AMPLICON_PCIE215 0x0012
+#define PCI_DEVICE_ID_AMPLICON_PCIE296 0x0014
 
 /* 8255 control register bits */
 #define CR_C_LO_IO	0x01
@@ -231,6 +261,7 @@
 
 /* 200 series registers */
 #define DIO200_IO_SIZE		0x20
+#define DIO200_PCIE_IO_SIZE	0x4000
 #define DIO200_XCLK_SCE		0x18	/* Group X clock selection register */
 #define DIO200_YCLK_SCE		0x19	/* Group Y clock selection register */
 #define DIO200_ZCLK_SCE		0x1a	/* Group Z clock selection register */
@@ -285,9 +316,11 @@ enum dio200_bustype { isa_bustype, pci_bustype };
 enum dio200_model {
 	pc212e_model,
 	pc214e_model,
-	pc215e_model, pci215_model,
+	pc215e_model, pci215_model, pcie215_model,
 	pc218e_model,
+	pcie236_model,
 	pc272e_model, pci272_model,
+	pcie296_model,
 };
 
 enum dio200_layout_idx {
@@ -299,7 +332,12 @@ enum dio200_layout_idx {
 #if DO_ISA
 	pc218_layout,
 #endif
-	pc272_layout
+	pc272_layout,
+#if DO_PCI
+	pcie215_layout,
+	pcie236_layout,
+	pcie296_layout,
+#endif
 };
 
 struct dio200_board {
@@ -370,6 +408,36 @@ static const struct dio200_board dio200_boards[] = {
 	 .mainbar = 2,
 	 .mainsize = DIO200_IO_SIZE,
 	 },
+	{
+	 .name = "pcie215",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE215,
+	 .bustype = pci_bustype,
+	 .model = pcie215_model,
+	 .layout = pcie215_layout,
+	 .mainbar = 1,
+	 .mainshift = 3,
+	 .mainsize = DIO200_PCIE_IO_SIZE,
+	 },
+	{
+	 .name = "pcie236",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE236,
+	 .bustype = pci_bustype,
+	 .model = pcie236_model,
+	 .layout = pcie236_layout,
+	 .mainbar = 1,
+	 .mainshift = 3,
+	 .mainsize = DIO200_PCIE_IO_SIZE,
+	 },
+	{
+	 .name = "pcie296",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCIE296,
+	 .bustype = pci_bustype,
+	 .model = pcie296_model,
+	 .layout = pcie296_layout,
+	 .mainbar = 1,
+	 .mainshift = 3,
+	 .mainsize = DIO200_PCIE_IO_SIZE,
+	 },
 #endif
 };
 
@@ -378,9 +446,9 @@ static const struct dio200_board dio200_boards[] = {
  * layout.
  */
 
-enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254 };
+enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254, sd_timer };
 
-#define DIO200_MAX_SUBDEVS	7
+#define DIO200_MAX_SUBDEVS	8
 #define DIO200_MAX_ISNS		6
 
 struct dio200_layout {
@@ -442,6 +510,35 @@ static const struct dio200_layout dio200_layouts[] = {
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 0,
 			  },
+#if DO_PCI
+	[pcie215_layout] = {
+			  .n_subdevs = 8,
+			  .sdtype = {sd_8255, sd_none, sd_8255, sd_none,
+				     sd_8254, sd_8254, sd_timer, sd_intr},
+			  .sdinfo = {0x00, 0x00, 0x08, 0x00,
+				     0x10, 0x14, 0x00, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
+	[pcie236_layout] = {
+			  .n_subdevs = 8,
+			  .sdtype = {sd_8255, sd_none, sd_none, sd_none,
+				     sd_8254, sd_8254, sd_timer, sd_intr},
+			  .sdinfo = {0x00, 0x00, 0x00, 0x00,
+				     0x10, 0x14, 0x00, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
+	[pcie296_layout] = {
+			  .n_subdevs = 8,
+			  .sdtype = {sd_8255, sd_8255, sd_8255, sd_8255,
+				     sd_8254, sd_8254, sd_timer, sd_intr},
+			  .sdinfo = {0x00, 0x04, 0x08, 0x0C,
+				     0x10, 0x14, 0x00, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
+#endif
 };
 
 /* this structure is for data unique to this hardware driver.  If
@@ -1516,6 +1613,8 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
 				s->type = COMEDI_SUBD_UNUSED;
 			}
 			break;
+		case sd_timer:
+			/* TODO.  Fall-thru to default for now. */
 		default:
 			s->type = COMEDI_SUBD_UNUSED;
 			break;
@@ -1707,6 +1806,9 @@ static struct comedi_driver amplc_dio200_driver = {
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE236) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE215) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCIE296) },
 	{0}
 };
 

commit 34ed78e8f7f7895e21dc3215c05993aa16adddf3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:04 2012 +0100

    staging: comedi: amplc_dio200: add register shift to board info
    
    Add `mainshift` member to `struct dio200_board` to hold the amount of
    left-shift required for main register offsets.  This is 0 for all the
    boards currently supported so it doesn't need initializing explicitly in
    any current element of `dio200_boards[]`.  It will be non-zero for some
    new boards to be supported by this driver.
    
    Modify the register access functions `dio200_read8()` and
    `dio200_write8()` to take the shift into account.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index ace218abae08..2e6ea759914e 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -309,6 +309,7 @@ struct dio200_board {
 	enum dio200_model model;
 	enum dio200_layout_idx layout;
 	unsigned char mainbar;
+	unsigned char mainshift;
 	unsigned int mainsize;
 };
 
@@ -504,8 +505,10 @@ static inline bool is_isa_board(const struct dio200_board *board)
 static unsigned char dio200_read8(struct comedi_device *dev,
 				  unsigned int offset)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv = dev->private;
 
+	offset <<= thisboard->mainshift;
 	if (devpriv->io.regtype == io_regtype)
 		return inb(devpriv->io.u.iobase + offset);
 	else
@@ -518,8 +521,10 @@ static unsigned char dio200_read8(struct comedi_device *dev,
 static void dio200_write8(struct comedi_device *dev, unsigned int offset,
 			  unsigned char val)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv = dev->private;
 
+	offset <<= thisboard->mainshift;
 	if (devpriv->io.regtype == io_regtype)
 		outb(val, devpriv->io.u.iobase + offset);
 	else

commit 805afd6bd62b2a6050cda8592fa2f9f72abe5a19
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:03 2012 +0100

    staging: comedi: amplc_dio200: add min register region size in board
    
    Store the length of the main register region in new member `mainsize` of
    `struct dio200_board` and initialize it in each element of
    `dio200_boards[]`.  For all currently supported boards this is
    initialized to `DIO200_IO_SIZE` (0x20), but will be different for newer
    boards to be supported in the future.
    
    For ISA boards, this is the actual region length requested, but for PCI
    boards it's the minimum expected region length.  Verify that the PCI BAR
    region length is sufficient in `dio200_attach_pci()`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 2cbd2481aeeb..ace218abae08 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -309,6 +309,7 @@ struct dio200_board {
 	enum dio200_model model;
 	enum dio200_layout_idx layout;
 	unsigned char mainbar;
+	unsigned int mainsize;
 };
 
 static const struct dio200_board dio200_boards[] = {
@@ -318,30 +319,35 @@ static const struct dio200_board dio200_boards[] = {
 	 .bustype = isa_bustype,
 	 .model = pc212e_model,
 	 .layout = pc212_layout,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 	{
 	 .name = "pc214e",
 	 .bustype = isa_bustype,
 	 .model = pc214e_model,
 	 .layout = pc214_layout,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 	{
 	 .name = "pc215e",
 	 .bustype = isa_bustype,
 	 .model = pc215e_model,
 	 .layout = pc215_layout,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 	{
 	 .name = "pc218e",
 	 .bustype = isa_bustype,
 	 .model = pc218e_model,
 	 .layout = pc218_layout,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 	{
 	 .name = "pc272e",
 	 .bustype = isa_bustype,
 	 .model = pc272e_model,
 	 .layout = pc272_layout,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 #endif
 #if DO_PCI
@@ -352,6 +358,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pci215_model,
 	 .layout = pc215_layout,
 	 .mainbar = 2,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 	{
 	 .name = "pci272",
@@ -360,6 +367,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pci272_model,
 	 .layout = pc272_layout,
 	 .mainbar = 2,
+	 .mainsize = DIO200_IO_SIZE,
 	 },
 #endif
 };
@@ -1550,7 +1558,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 		iobase = it->options[0];
 		irq = it->options[1];
-		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
+		ret = dio200_request_region(dev, iobase, thisboard->mainsize);
 		if (ret < 0)
 			return ret;
 		devpriv->io.u.iobase = iobase;
@@ -1578,7 +1586,7 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 {
 	const struct dio200_board *thisboard;
 	struct dio200_private *devpriv;
-	resource_size_t base;
+	resource_size_t base, len;
 	unsigned int bar;
 	int ret;
 
@@ -1607,8 +1615,12 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 	}
 	bar = thisboard->mainbar;
 	base = pci_resource_start(pci_dev, bar);
+	len = pci_resource_len(pci_dev, bar);
+	if (len < thisboard->mainsize) {
+		dev_err(dev->class_dev, "error! PCI region size too small!\n");
+		return -EINVAL;
+	}
 	if ((pci_resource_flags(pci_dev, bar) & IORESOURCE_MEM) != 0) {
-		resource_size_t len = pci_resource_len(pci_dev, bar);
 		devpriv->io.u.membase = ioremap_nocache(base, len);
 		if (!devpriv->io.u.membase) {
 			dev_err(dev->class_dev,
@@ -1655,7 +1667,8 @@ static void dio200_detach(struct comedi_device *dev)
 	}
 	if (is_isa_board(thisboard)) {
 		if (devpriv->io.regtype == io_regtype)
-			release_region(devpriv->io.u.iobase, DIO200_IO_SIZE);
+			release_region(devpriv->io.u.iobase,
+				       thisboard->mainsize);
 	} else if (is_pci_board(thisboard)) {
 		struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 		if (pcidev) {

commit ef0653ac20e739aba476ee63ca2a618a3a26857d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:02 2012 +0100

    staging: comedi: amplc_dio200: add PCI BAR information to board
    
    Add `mainbar` member to `struct dio200_board` to hold the PCI BAR number
    for the main registers.  This is `2` for the PCI boards currently
    supported (PCI215 and PCI272) but will be different for some new boards
    to be supported later.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 39fb82b4eca8..2cbd2481aeeb 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -308,6 +308,7 @@ struct dio200_board {
 	enum dio200_bustype bustype;
 	enum dio200_model model;
 	enum dio200_layout_idx layout;
+	unsigned char mainbar;
 };
 
 static const struct dio200_board dio200_boards[] = {
@@ -350,6 +351,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .bustype = pci_bustype,
 	 .model = pci215_model,
 	 .layout = pc215_layout,
+	 .mainbar = 2,
 	 },
 	{
 	 .name = "pci272",
@@ -357,6 +359,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .bustype = pci_bustype,
 	 .model = pci272_model,
 	 .layout = pc272_layout,
+	 .mainbar = 2,
 	 },
 #endif
 };
@@ -1573,8 +1576,10 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
+	const struct dio200_board *thisboard;
 	struct dio200_private *devpriv;
 	resource_size_t base;
+	unsigned int bar;
 	int ret;
 
 	if (!DO_PCI)
@@ -1593,15 +1598,17 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
+	thisboard = comedi_board(dev);
 	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
 			"error! cannot enable PCI device and request regions!\n");
 		return ret;
 	}
-	base = pci_resource_start(pci_dev, 2);
-	if ((pci_resource_flags(pci_dev, 2) & IORESOURCE_MEM) != 0) {
-		resource_size_t len = pci_resource_len(pci_dev, 2);
+	bar = thisboard->mainbar;
+	base = pci_resource_start(pci_dev, bar);
+	if ((pci_resource_flags(pci_dev, bar) & IORESOURCE_MEM) != 0) {
+		resource_size_t len = pci_resource_len(pci_dev, bar);
 		devpriv->io.u.membase = ioremap_nocache(base, len);
 		if (!devpriv->io.u.membase) {
 			dev_err(dev->class_dev,

commit 71b3e9e8dc218133417d3c167632a61f9fed3651
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:01 2012 +0100

    staging: comedi: amplc_dio200: support memory-mapped I/O
    
    The boards currently supported by this module all use port I/O.  Support
    memory-mapped I/O as well for future PCI/PCIe cards.
    
    Define `struct dio200_region` to hold the type of register access and
    either the port I/O base address or an ioremapped MMIO address.  Add a
    member `io` to the comedi device private data (`struct dio200_private`)
    to hold this.  Use this instead of `dev->iobase`.  Memory-mapped
    registers are mapped in `dio200_pci_attach()` and unmapped in
    `dio200_detach()`.
    
    `dio200_detach()` now uses the private data pointer `devpriv` set to
    `dev->private` but can return early if it is `NULL` because no clean-up
    needs to be done in that case.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 1b734dc51b33..39fb82b4eca8 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -264,6 +264,18 @@ static const unsigned clock_period[8] = {
 	0			/* group clock input pin */
 };
 
+/*
+ * Register region.
+ */
+enum dio200_regtype { no_regtype = 0, io_regtype, mmio_regtype };
+struct dio200_region {
+	union {
+		unsigned long iobase;		/* I/O base address */
+		unsigned char __iomem *membase;	/* mapped MMIO base address */
+	} u;
+	enum dio200_regtype regtype;
+};
+
 /*
  * Board descriptions.
  */
@@ -425,6 +437,7 @@ static const struct dio200_layout dio200_layouts[] = {
    feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct dio200_private {
+	struct dio200_region io;	/* Register region */
 	int intr_sd;
 };
 
@@ -480,7 +493,12 @@ static inline bool is_isa_board(const struct dio200_board *board)
 static unsigned char dio200_read8(struct comedi_device *dev,
 				  unsigned int offset)
 {
-	return inb(dev->iobase + offset);
+	struct dio200_private *devpriv = dev->private;
+
+	if (devpriv->io.regtype == io_regtype)
+		return inb(devpriv->io.u.iobase + offset);
+	else
+		return readb(devpriv->io.u.membase + offset);
 }
 
 /*
@@ -489,7 +507,12 @@ static unsigned char dio200_read8(struct comedi_device *dev,
 static void dio200_write8(struct comedi_device *dev, unsigned int offset,
 			  unsigned char val)
 {
-	outb(val, dev->iobase + offset);
+	struct dio200_private *devpriv = dev->private;
+
+	if (devpriv->io.regtype == io_regtype)
+		outb(val, devpriv->io.u.iobase + offset);
+	else
+		writeb(val, devpriv->io.u.membase + offset);
 }
 
 /*
@@ -1405,13 +1428,14 @@ static void dio200_subdev_8255_cleanup(struct comedi_device *dev,
 static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	char tmpbuf[60];
 	int tmplen;
 
 	if (is_isa_board(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
-				   "(base %#lx) ", dev->iobase);
+				   "(base %#lx) ", devpriv->io.u.iobase);
 	else if (is_pci_board(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(pci %s) ", pci_name(pcidev));
@@ -1526,7 +1550,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
 		if (ret < 0)
 			return ret;
-		dev->iobase = iobase;
+		devpriv->io.u.iobase = iobase;
+		devpriv->io.regtype = io_regtype;
 		return dio200_common_attach(dev, irq, 0);
 	} else if (is_pci_board(thisboard)) {
 		dev_err(dev->class_dev,
@@ -1549,6 +1574,7 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
 	struct dio200_private *devpriv;
+	resource_size_t base;
 	int ret;
 
 	if (!DO_PCI)
@@ -1573,16 +1599,32 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 			"error! cannot enable PCI device and request regions!\n");
 		return ret;
 	}
-	dev->iobase = pci_resource_start(pci_dev, 2);
+	base = pci_resource_start(pci_dev, 2);
+	if ((pci_resource_flags(pci_dev, 2) & IORESOURCE_MEM) != 0) {
+		resource_size_t len = pci_resource_len(pci_dev, 2);
+		devpriv->io.u.membase = ioremap_nocache(base, len);
+		if (!devpriv->io.u.membase) {
+			dev_err(dev->class_dev,
+				"error! cannot remap registers\n");
+			return -ENOMEM;
+		}
+		devpriv->io.regtype = mmio_regtype;
+	} else {
+		devpriv->io.u.iobase = (unsigned long)base;
+		devpriv->io.regtype = io_regtype;
+	}
 	return dio200_common_attach(dev, pci_dev->irq, IRQF_SHARED);
 }
 
 static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
 	const struct dio200_layout *layout;
 	unsigned n;
 
+	if (!thisboard || !devpriv)
+		return;
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices) {
@@ -1605,13 +1647,16 @@ static void dio200_detach(struct comedi_device *dev)
 		}
 	}
 	if (is_isa_board(thisboard)) {
-		if (dev->iobase)
-			release_region(dev->iobase, DIO200_IO_SIZE);
+		if (devpriv->io.regtype == io_regtype)
+			release_region(devpriv->io.u.iobase, DIO200_IO_SIZE);
 	} else if (is_pci_board(thisboard)) {
 		struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 		if (pcidev) {
-			if (dev->iobase)
+			if (devpriv->io.regtype != no_regtype) {
+				if (devpriv->io.regtype == mmio_regtype)
+					iounmap(devpriv->io.u.membase);
 				comedi_pci_disable(pcidev);
+			}
 		}
 	}
 }

commit 9bfa0d548c0ca427cba4a1c26658f870cfda64ca
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:48:00 2012 +0100

    staging: comedi: amplc_dio200: set dev->iobase before common attach
    
    Don't pass the I/O base address to `dio200_common_attach()`.  The only
    thing it does with it is set `dev->iobase` to the passed in value.  Do
    that before calling `dio200_common_attach()` in order to simplify
    upcoming support for different register access methods.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 4fe2b2b754cd..1b734dc51b33 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1427,8 +1427,8 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	dev_info(dev->class_dev, "%s %sattached\n", dev->board_name, tmpbuf);
 }
 
-static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
-				unsigned int irq, unsigned long req_irq_flags)
+static int dio200_common_attach(struct comedi_device *dev, unsigned int irq,
+				unsigned long req_irq_flags)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv = dev->private;
@@ -1439,7 +1439,6 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 	int ret;
 
 	devpriv->intr_sd = -1;
-	dev->iobase = iobase;
 	dev->board_name = thisboard->name;
 
 	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
@@ -1527,7 +1526,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
 		if (ret < 0)
 			return ret;
-		return dio200_common_attach(dev, iobase, irq, 0);
+		dev->iobase = iobase;
+		return dio200_common_attach(dev, irq, 0);
 	} else if (is_pci_board(thisboard)) {
 		dev_err(dev->class_dev,
 			"Manual configuration of PCI board '%s' is not supported\n",
@@ -1549,7 +1549,6 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
 	struct dio200_private *devpriv;
-	unsigned long iobase;
 	int ret;
 
 	if (!DO_PCI)
@@ -1574,8 +1573,8 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 			"error! cannot enable PCI device and request regions!\n");
 		return ret;
 	}
-	iobase = pci_resource_start(pci_dev, 2);
-	return dio200_common_attach(dev, iobase, pci_dev->irq, IRQF_SHARED);
+	dev->iobase = pci_resource_start(pci_dev, 2);
+	return dio200_common_attach(dev, pci_dev->irq, IRQF_SHARED);
 }
 
 static void dio200_detach(struct comedi_device *dev)

commit c10aa035512f9c5092d7044676d3f3d14739f8d8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:59 2012 +0100

    staging: comedi: amplc_dio200: use custom register access functions
    
    Add custom functions to access hardware registers and call them instead
    of calling `inb()` and `outb()` directly.  When additional cards are
    supported by this driver requiring different register access methods,
    the new functions will localize the register access differences to just
    these functions.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 0c824a99beda..4fe2b2b754cd 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -474,6 +474,24 @@ static inline bool is_isa_board(const struct dio200_board *board)
 	return DO_ISA && board->bustype == isa_bustype;
 }
 
+/*
+ * Read 8-bit register.
+ */
+static unsigned char dio200_read8(struct comedi_device *dev,
+				  unsigned int offset)
+{
+	return inb(dev->iobase + offset);
+}
+
+/*
+ * Write 8-bit register.
+ */
+static void dio200_write8(struct comedi_device *dev, unsigned int offset,
+			  unsigned char val)
+{
+	outb(val, dev->iobase + offset);
+}
+
 /*
  * This function looks for a board matching the supplied PCI device.
  */
@@ -518,7 +536,7 @@ dio200_subdev_intr_insn_bits(struct comedi_device *dev,
 
 	if (layout->has_int_sce) {
 		/* Just read the interrupt status register.  */
-		data[1] = inb(dev->iobase + subpriv->ofs) & subpriv->valid_isns;
+		data[1] = dio200_read8(dev, subpriv->ofs) & subpriv->valid_isns;
 	} else {
 		/* No interrupt status register. */
 		data[0] = 0;
@@ -539,7 +557,7 @@ static void dio200_stop_intr(struct comedi_device *dev,
 	subpriv->active = 0;
 	subpriv->enabled_isns = 0;
 	if (layout->has_int_sce)
-		outb(0, dev->iobase + subpriv->ofs);
+		dio200_write8(dev, subpriv->ofs, 0);
 }
 
 /*
@@ -571,7 +589,7 @@ static int dio200_start_intr(struct comedi_device *dev,
 		/* Enable interrupt sources. */
 		subpriv->enabled_isns = isn_bits;
 		if (layout->has_int_sce)
-			outb(isn_bits, dev->iobase + subpriv->ofs);
+			dio200_write8(dev, subpriv->ofs, isn_bits);
 	}
 
 	return retval;
@@ -637,11 +655,11 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 		 * loop in case of misconfiguration.
 		 */
 		cur_enabled = subpriv->enabled_isns;
-		while ((intstat = (inb(dev->iobase + subpriv->ofs) &
+		while ((intstat = (dio200_read8(dev, subpriv->ofs) &
 				   subpriv->valid_isns & ~triggered)) != 0) {
 			triggered |= intstat;
 			cur_enabled &= ~triggered;
-			outb(cur_enabled, dev->iobase + subpriv->ofs);
+			dio200_write8(dev, subpriv->ofs, cur_enabled);
 		}
 	} else {
 		/*
@@ -660,7 +678,7 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 		 */
 		cur_enabled = subpriv->enabled_isns;
 		if (layout->has_int_sce)
-			outb(cur_enabled, dev->iobase + subpriv->ofs);
+			dio200_write8(dev, subpriv->ofs, cur_enabled);
 
 		if (subpriv->active) {
 			/*
@@ -882,7 +900,7 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	if (layout->has_int_sce)
 		/* Disable interrupt sources. */
-		outb(0, dev->iobase + subpriv->ofs);
+		dio200_write8(dev, subpriv->ofs, 0);
 
 	s->private = subpriv;
 	s->type = COMEDI_SUBD_DI;
@@ -951,10 +969,10 @@ dio200_subdev_8254_read_chan(struct comedi_device *dev,
 
 	/* latch counter */
 	val = chan << 6;
-	outb(val, dev->iobase + subpriv->ofs + i8254_control_reg);
+	dio200_write8(dev, subpriv->ofs + i8254_control_reg, val);
 	/* read lsb, msb */
-	val = inb(dev->iobase + subpriv->ofs + chan);
-	val += inb(dev->iobase + subpriv->ofs + chan) << 8;
+	val = dio200_read8(dev, subpriv->ofs + chan);
+	val += dio200_read8(dev, subpriv->ofs + chan) << 8;
 	return val;
 }
 
@@ -969,8 +987,8 @@ dio200_subdev_8254_write_chan(struct comedi_device *dev,
 	struct dio200_subdev_8254 *subpriv = s->private;
 
 	/* write lsb, msb */
-	outb(count & 0xff, dev->iobase + subpriv->ofs + chan);
-	outb((count >> 8) & 0xff, dev->iobase + subpriv->ofs + chan);
+	dio200_write8(dev, subpriv->ofs + chan, count & 0xff);
+	dio200_write8(dev, subpriv->ofs + chan, (count >> 8) & 0xff);
 }
 
 /*
@@ -987,7 +1005,7 @@ dio200_subdev_8254_set_mode(struct comedi_device *dev,
 	byte = chan << 6;
 	byte |= 0x30;		/* access order: lsb, msb */
 	byte |= (mode & 0xf);	/* counter mode and BCD|binary */
-	outb(byte, dev->iobase + subpriv->ofs + i8254_control_reg);
+	dio200_write8(dev, subpriv->ofs + i8254_control_reg, byte);
 }
 
 /*
@@ -1000,10 +1018,10 @@ dio200_subdev_8254_status(struct comedi_device *dev,
 	struct dio200_subdev_8254 *subpriv = s->private;
 
 	/* latch status */
-	outb(0xe0 | (2 << chan),
-	     dev->iobase + subpriv->ofs + i8254_control_reg);
+	dio200_write8(dev, subpriv->ofs + i8254_control_reg,
+		      0xe0 | (2 << chan));
 	/* read status */
-	return inb(dev->iobase + subpriv->ofs + chan);
+	return dio200_read8(dev, subpriv->ofs + chan);
 }
 
 /*
@@ -1064,7 +1082,7 @@ dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
 
 	subpriv->gate_src[counter_number] = gate_src;
 	byte = GAT_SCE(subpriv->which, counter_number, gate_src);
-	outb(byte, dev->iobase + subpriv->gat_sce_ofs);
+	dio200_write8(dev, subpriv->gat_sce_ofs, byte);
 
 	return 0;
 }
@@ -1110,7 +1128,7 @@ dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
 
 	subpriv->clock_src[counter_number] = clock_src;
 	byte = CLK_SCE(subpriv->which, counter_number, clock_src);
-	outb(byte, dev->iobase + subpriv->clk_sce_ofs);
+	dio200_write8(dev, subpriv->clk_sce_ofs, byte);
 
 	return 0;
 }
@@ -1276,7 +1294,7 @@ static void dio200_subdev_8255_set_dir(struct comedi_device *dev,
 		config |= CR_C_LO_IO;
 	if (!(s->io_bits & 0xf00000))
 		config |= CR_C_HI_IO;
-	outb(config, dev->iobase + subpriv->ofs + 3);
+	dio200_write8(dev, subpriv->ofs + 3, config);
 }
 
 /*
@@ -1292,17 +1310,17 @@ static int dio200_subdev_8255_bits(struct comedi_device *dev,
 		s->state &= ~data[0];
 		s->state |= (data[0] & data[1]);
 		if (data[0] & 0xff)
-			outb(s->state & 0xff, dev->iobase + subpriv->ofs);
+			dio200_write8(dev, subpriv->ofs, s->state & 0xff);
 		if (data[0] & 0xff00)
-			outb((s->state >> 8) & 0xff,
-			     dev->iobase + subpriv->ofs + 1);
+			dio200_write8(dev, subpriv->ofs + 1,
+				      (s->state >> 8) & 0xff);
 		if (data[0] & 0xff0000)
-			outb((s->state >> 16) & 0xff,
-			     dev->iobase + subpriv->ofs + 2);
+			dio200_write8(dev, subpriv->ofs + 2,
+				      (s->state >> 16) & 0xff);
 	}
-	data[1] = inb(dev->iobase + subpriv->ofs);
-	data[1] |= inb(dev->iobase + subpriv->ofs + 1) << 8;
-	data[1] |= inb(dev->iobase + subpriv->ofs + 2) << 16;
+	data[1] = dio200_read8(dev, subpriv->ofs);
+	data[1] |= dio200_read8(dev, subpriv->ofs + 1) << 8;
+	data[1] |= dio200_read8(dev, subpriv->ofs + 2) << 16;
 	return 2;
 }
 

commit 57054dcaec4848d5f6ce2fddaebfd0fc110e0c53
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:57 2012 +0100

    staging: comedi: amplc_dio200: internalize 8255 DIO implementation
    
    Implement the '8255' DIO subdevice internally to this module instead of
    using the external "8255" module.  I plan to add support for additional
    cards to this driver that would require the I/O callback functionality
    of the 8255 module, but the existing callback functions do not have much
    context to handle this elegantly.  The additional cards also have extra
    DIO features which cannot be handled by the existing "8255" module and
    that I'd like to support some time in the future.
    
    The bottom line is I _could_ continue using the "8255" module for a
    while with a callback function, but it would turn out to be a very ugly
    callback function and I'd have to ditch the use of the "8255" module as
    soon as I added an extra feature to the DIO subdevice.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d874bdfed6ab..0c824a99beda 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -207,7 +207,6 @@
 #include "../comedidev.h"
 
 #include "comedi_fc.h"
-#include "8255.h"
 #include "8253.h"
 
 #define DIO200_DRIVER_NAME	"amplc_dio200"
@@ -221,6 +220,15 @@
 #define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
 #define PCI_DEVICE_ID_INVALID 0xffff
 
+/* 8255 control register bits */
+#define CR_C_LO_IO	0x01
+#define CR_B_IO		0x02
+#define CR_B_MODE	0x04
+#define CR_C_HI_IO	0x08
+#define CR_A_IO		0x10
+#define CR_A_MODE(a)	((a)<<5)
+#define CR_CW		0x80
+
 /* 200 series registers */
 #define DIO200_IO_SIZE		0x20
 #define DIO200_XCLK_SCE		0x18	/* Group X clock selection register */
@@ -430,6 +438,10 @@ struct dio200_subdev_8254 {
 	spinlock_t spinlock;
 };
 
+struct dio200_subdev_8255 {
+	unsigned int ofs;		/* DIO base offset */
+};
+
 struct dio200_subdev_intr {
 	unsigned int ofs;
 	spinlock_t spinlock;
@@ -1245,6 +1257,133 @@ dio200_subdev_8254_cleanup(struct comedi_device *dev,
 	kfree(subpriv);
 }
 
+/*
+ * This function sets I/O directions for an '8255' DIO subdevice.
+ */
+static void dio200_subdev_8255_set_dir(struct comedi_device *dev,
+				       struct comedi_subdevice *s)
+{
+	struct dio200_subdev_8255 *subpriv = s->private;
+	int config;
+
+	config = CR_CW;
+	/* 1 in io_bits indicates output, 1 in config indicates input */
+	if (!(s->io_bits & 0x0000ff))
+		config |= CR_A_IO;
+	if (!(s->io_bits & 0x00ff00))
+		config |= CR_B_IO;
+	if (!(s->io_bits & 0x0f0000))
+		config |= CR_C_LO_IO;
+	if (!(s->io_bits & 0xf00000))
+		config |= CR_C_HI_IO;
+	outb(config, dev->iobase + subpriv->ofs + 3);
+}
+
+/*
+ * Handle 'insn_bits' for an '8255' DIO subdevice.
+ */
+static int dio200_subdev_8255_bits(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
+{
+	struct dio200_subdev_8255 *subpriv = s->private;
+
+	if (data[0]) {
+		s->state &= ~data[0];
+		s->state |= (data[0] & data[1]);
+		if (data[0] & 0xff)
+			outb(s->state & 0xff, dev->iobase + subpriv->ofs);
+		if (data[0] & 0xff00)
+			outb((s->state >> 8) & 0xff,
+			     dev->iobase + subpriv->ofs + 1);
+		if (data[0] & 0xff0000)
+			outb((s->state >> 16) & 0xff,
+			     dev->iobase + subpriv->ofs + 2);
+	}
+	data[1] = inb(dev->iobase + subpriv->ofs);
+	data[1] |= inb(dev->iobase + subpriv->ofs + 1) << 8;
+	data[1] |= inb(dev->iobase + subpriv->ofs + 2) << 16;
+	return 2;
+}
+
+/*
+ * Handle 'insn_config' for an '8255' DIO subdevice.
+ */
+static int dio200_subdev_8255_config(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
+{
+	unsigned int mask;
+	unsigned int bits;
+
+	mask = 1 << CR_CHAN(insn->chanspec);
+	if (mask & 0x0000ff)
+		bits = 0x0000ff;
+	else if (mask & 0x00ff00)
+		bits = 0x00ff00;
+	else if (mask & 0x0f0000)
+		bits = 0x0f0000;
+	else
+		bits = 0xf00000;
+	switch (data[0]) {
+	case INSN_CONFIG_DIO_INPUT:
+		s->io_bits &= ~bits;
+		break;
+	case INSN_CONFIG_DIO_OUTPUT:
+		s->io_bits |= bits;
+		break;
+	case INSN_CONFIG_DIO_QUERY:
+		data[1] = (s->io_bits & bits) ? COMEDI_OUTPUT : COMEDI_INPUT;
+		return insn->n;
+		break;
+	default:
+		return -EINVAL;
+	}
+	dio200_subdev_8255_set_dir(dev, s);
+	return 1;
+}
+
+/*
+ * This function initializes an '8255' DIO subdevice.
+ *
+ * offset is the offset to the 8255 chip.
+ */
+static int dio200_subdev_8255_init(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int offset)
+{
+	struct dio200_subdev_8255 *subpriv;
+
+	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
+	if (!subpriv)
+		return -ENOMEM;
+	subpriv->ofs = offset;
+	s->private = subpriv;
+	s->type = COMEDI_SUBD_DIO;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE;
+	s->n_chan = 24;
+	s->range_table = &range_digital;
+	s->maxdata = 1;
+	s->insn_bits = dio200_subdev_8255_bits;
+	s->insn_config = dio200_subdev_8255_config;
+	s->state = 0;
+	s->io_bits = 0;
+	dio200_subdev_8255_set_dir(dev, s);
+	return 0;
+}
+
+/*
+ * This function cleans up an '8255' DIO subdevice.
+ */
+static void dio200_subdev_8255_cleanup(struct comedi_device *dev,
+				       struct comedi_subdevice *s)
+{
+	struct dio200_subdev_8255 *subpriv = s->private;
+
+	kfree(subpriv);
+}
+
 static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
@@ -1301,8 +1440,8 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 			break;
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
-			ret = subdev_8255_init(dev, s, NULL,
-					       iobase + layout->sdinfo[n]);
+			ret = dio200_subdev_8255_init(dev, s,
+						      layout->sdinfo[n]);
 			if (ret < 0)
 				return ret;
 			break;
@@ -1438,7 +1577,7 @@ static void dio200_detach(struct comedi_device *dev)
 				dio200_subdev_8254_cleanup(dev, s);
 				break;
 			case sd_8255:
-				subdev_8255_cleanup(dev, s);
+				dio200_subdev_8255_cleanup(dev, s);
 				break;
 			case sd_intr:
 				dio200_subdev_intr_cleanup(dev, s);

commit 155857cd5488d6287724ad560f063e568a077940
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:56 2012 +0100

    staging: comedi: amplc_dio200: add functions to access 8254 counters
    
    Add our own functions to manipulate the '8254' counter chip instead of
    the inline ones from "8253.h".  This will make the code less messy when
    we add code to support new boards later.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 16ae7a395d5c..d874bdfed6ab 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -927,6 +927,73 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
 	return IRQ_RETVAL(handled);
 }
 
+/*
+ * Read an '8254' counter subdevice channel.
+ */
+static unsigned int
+dio200_subdev_8254_read_chan(struct comedi_device *dev,
+			     struct comedi_subdevice *s, unsigned int chan)
+{
+	struct dio200_subdev_8254 *subpriv = s->private;
+	unsigned int val;
+
+	/* latch counter */
+	val = chan << 6;
+	outb(val, dev->iobase + subpriv->ofs + i8254_control_reg);
+	/* read lsb, msb */
+	val = inb(dev->iobase + subpriv->ofs + chan);
+	val += inb(dev->iobase + subpriv->ofs + chan) << 8;
+	return val;
+}
+
+/*
+ * Write an '8254' subdevice channel.
+ */
+static void
+dio200_subdev_8254_write_chan(struct comedi_device *dev,
+			      struct comedi_subdevice *s, unsigned int chan,
+			      unsigned int count)
+{
+	struct dio200_subdev_8254 *subpriv = s->private;
+
+	/* write lsb, msb */
+	outb(count & 0xff, dev->iobase + subpriv->ofs + chan);
+	outb((count >> 8) & 0xff, dev->iobase + subpriv->ofs + chan);
+}
+
+/*
+ * Set mode of an '8254' subdevice channel.
+ */
+static void
+dio200_subdev_8254_set_mode(struct comedi_device *dev,
+			    struct comedi_subdevice *s, unsigned int chan,
+			    unsigned int mode)
+{
+	struct dio200_subdev_8254 *subpriv = s->private;
+	unsigned int byte;
+
+	byte = chan << 6;
+	byte |= 0x30;		/* access order: lsb, msb */
+	byte |= (mode & 0xf);	/* counter mode and BCD|binary */
+	outb(byte, dev->iobase + subpriv->ofs + i8254_control_reg);
+}
+
+/*
+ * Read status byte of an '8254' counter subdevice channel.
+ */
+static unsigned int
+dio200_subdev_8254_status(struct comedi_device *dev,
+			  struct comedi_subdevice *s, unsigned int chan)
+{
+	struct dio200_subdev_8254 *subpriv = s->private;
+
+	/* latch status */
+	outb(0xe0 | (2 << chan),
+	     dev->iobase + subpriv->ofs + i8254_control_reg);
+	/* read status */
+	return inb(dev->iobase + subpriv->ofs + chan);
+}
+
 /*
  * Handle 'insn_read' for an '8254' counter subdevice.
  */
@@ -939,7 +1006,7 @@ dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	data[0] = i8254_read(dev->iobase + subpriv->ofs, 0, chan);
+	data[0] = dio200_subdev_8254_read_chan(dev, s, chan);
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
@@ -957,7 +1024,7 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	i8254_write(dev->iobase + subpriv->ofs, 0, chan, data[0]);
+	dio200_subdev_8254_write_chan(dev, s, chan, data[0]);
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
@@ -1074,13 +1141,13 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	spin_lock_irqsave(&subpriv->spinlock, flags);
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
-		ret = i8254_set_mode(dev->iobase + subpriv->ofs, 0, chan,
-				     data[1]);
-		if (ret < 0)
+		if (data[1] > (I8254_MODE5 | I8254_BINARY))
 			ret = -EINVAL;
+		else
+			dio200_subdev_8254_set_mode(dev, s, chan, data[1]);
 		break;
 	case INSN_CONFIG_8254_READ_STATUS:
-		data[1] = i8254_status(dev->iobase + subpriv->ofs, 0, chan);
+		data[1] = dio200_subdev_8254_status(dev, s, chan);
 		break;
 	case INSN_CONFIG_SET_GATE_SRC:
 		ret = dio200_subdev_8254_set_gate_src(dev, s, chan, data[2]);
@@ -1154,8 +1221,8 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	/* Initialize channels. */
 	for (chan = 0; chan < 3; chan++) {
-		i8254_set_mode(dev->iobase + subpriv->ofs, 0, chan,
-			       I8254_MODE0 | I8254_BINARY);
+		dio200_subdev_8254_set_mode(dev, s, chan,
+					    I8254_MODE0 | I8254_BINARY);
 		if (layout->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
 			dio200_subdev_8254_set_gate_src(dev, s, chan, 0);

commit cda84375f337332421101e7a94f72d0512f8d742
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:55 2012 +0100

    staging: comedi: amplc_dio200: use register offsets in subdevices
    
    Replace the absolute, modified I/O base addresses in the private data
    structures for the '8254' counter and 'intr' DIO subdevices with offsets
    from the main I/O base address.  `dio200_subdev_intr_init()` now needs
    the offset instead of the absolute address.  `dio200_subdev_8254_init()`
    now only needs the offset instead of both the absolute address and the
    offset.  The '8255' DIO subdevices are unaffected as they are handled by
    the external "8255" module.
    
    This change is not useful by itself but is an intermediate step for
    later changes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index bab2e6477fa4..16ae7a395d5c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -421,20 +421,19 @@ struct dio200_private {
 };
 
 struct dio200_subdev_8254 {
-	unsigned long iobase;	/* Counter base address */
-	unsigned long clk_sce_iobase;	/* CLK_SCE base address */
-	unsigned long gat_sce_iobase;	/* GAT_SCE base address */
-	int which;		/* Bit 5 of CLK_SCE or GAT_SCE */
-	unsigned clock_src[3];	/* Current clock sources */
-	unsigned gate_src[3];	/* Current gate sources */
+	unsigned int ofs;		/* Counter base offset */
+	unsigned int clk_sce_ofs;	/* CLK_SCE base address */
+	unsigned int gat_sce_ofs;	/* GAT_SCE base address */
+	int which;			/* Bit 5 of CLK_SCE or GAT_SCE */
+	unsigned int clock_src[3];	/* Current clock sources */
+	unsigned int gate_src[3];	/* Current gate sources */
 	spinlock_t spinlock;
 };
 
 struct dio200_subdev_intr {
-	unsigned long iobase;
+	unsigned int ofs;
 	spinlock_t spinlock;
 	int active;
-	int has_int_sce;
 	unsigned int valid_isns;
 	unsigned int enabled_isns;
 	unsigned int stopcount;
@@ -502,11 +501,12 @@ dio200_subdev_intr_insn_bits(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv = s->private;
 
-	if (subpriv->has_int_sce) {
+	if (layout->has_int_sce) {
 		/* Just read the interrupt status register.  */
-		data[1] = inb(subpriv->iobase) & subpriv->valid_isns;
+		data[1] = inb(dev->iobase + subpriv->ofs) & subpriv->valid_isns;
 	} else {
 		/* No interrupt status register. */
 		data[0] = 0;
@@ -521,12 +521,13 @@ dio200_subdev_intr_insn_bits(struct comedi_device *dev,
 static void dio200_stop_intr(struct comedi_device *dev,
 			     struct comedi_subdevice *s)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv = s->private;
 
 	subpriv->active = 0;
 	subpriv->enabled_isns = 0;
-	if (subpriv->has_int_sce)
-		outb(0, subpriv->iobase);
+	if (layout->has_int_sce)
+		outb(0, dev->iobase + subpriv->ofs);
 }
 
 /*
@@ -537,6 +538,7 @@ static int dio200_start_intr(struct comedi_device *dev,
 {
 	unsigned int n;
 	unsigned isn_bits;
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval = 0;
@@ -556,8 +558,8 @@ static int dio200_start_intr(struct comedi_device *dev,
 		isn_bits &= subpriv->valid_isns;
 		/* Enable interrupt sources. */
 		subpriv->enabled_isns = isn_bits;
-		if (subpriv->has_int_sce)
-			outb(isn_bits, subpriv->iobase);
+		if (layout->has_int_sce)
+			outb(isn_bits, dev->iobase + subpriv->ofs);
 	}
 
 	return retval;
@@ -599,6 +601,7 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 static int dio200_handle_read_intr(struct comedi_device *dev,
 				   struct comedi_subdevice *s)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
 	unsigned intstat;
@@ -610,7 +613,7 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
 	oldevents = s->async->events;
-	if (subpriv->has_int_sce) {
+	if (layout->has_int_sce) {
 		/*
 		 * Collect interrupt sources that have triggered and disable
 		 * them temporarily.  Loop around until no extra interrupt
@@ -622,11 +625,11 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 		 * loop in case of misconfiguration.
 		 */
 		cur_enabled = subpriv->enabled_isns;
-		while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
-				   & ~triggered)) != 0) {
+		while ((intstat = (inb(dev->iobase + subpriv->ofs) &
+				   subpriv->valid_isns & ~triggered)) != 0) {
 			triggered |= intstat;
 			cur_enabled &= ~triggered;
-			outb(cur_enabled, subpriv->iobase);
+			outb(cur_enabled, dev->iobase + subpriv->ofs);
 		}
 	} else {
 		/*
@@ -644,8 +647,8 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 		 * Reenable them NOW to minimize the time they are disabled.
 		 */
 		cur_enabled = subpriv->enabled_isns;
-		if (subpriv->has_int_sce)
-			outb(cur_enabled, subpriv->iobase);
+		if (layout->has_int_sce)
+			outb(cur_enabled, dev->iobase + subpriv->ofs);
 
 		if (subpriv->active) {
 			/*
@@ -851,9 +854,9 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev,
  */
 static int
 dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned long iobase, unsigned valid_isns,
-			int has_int_sce)
+			unsigned int offset, unsigned valid_isns)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_intr *subpriv;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
@@ -861,18 +864,18 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return -ENOMEM;
 	}
-	subpriv->iobase = iobase;
-	subpriv->has_int_sce = has_int_sce;
+	subpriv->ofs = offset;
 	subpriv->valid_isns = valid_isns;
 	spin_lock_init(&subpriv->spinlock);
 
-	if (has_int_sce)
-		outb(0, subpriv->iobase);	/* Disable interrupt sources. */
+	if (layout->has_int_sce)
+		/* Disable interrupt sources. */
+		outb(0, dev->iobase + subpriv->ofs);
 
 	s->private = subpriv;
 	s->type = COMEDI_SUBD_DI;
 	s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
-	if (has_int_sce) {
+	if (layout->has_int_sce) {
 		s->n_chan = DIO200_MAX_ISNS;
 		s->len_chanlist = DIO200_MAX_ISNS;
 	} else {
@@ -936,7 +939,7 @@ dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	data[0] = i8254_read(subpriv->iobase, 0, chan);
+	data[0] = i8254_read(dev->iobase + subpriv->ofs, 0, chan);
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
@@ -954,7 +957,7 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	i8254_write(subpriv->iobase, 0, chan, data[0]);
+	i8254_write(dev->iobase + subpriv->ofs, 0, chan, data[0]);
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
@@ -982,7 +985,7 @@ dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
 
 	subpriv->gate_src[counter_number] = gate_src;
 	byte = GAT_SCE(subpriv->which, counter_number, gate_src);
-	outb(byte, subpriv->gat_sce_iobase);
+	outb(byte, dev->iobase + subpriv->gat_sce_ofs);
 
 	return 0;
 }
@@ -1028,7 +1031,7 @@ dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
 
 	subpriv->clock_src[counter_number] = clock_src;
 	byte = CLK_SCE(subpriv->which, counter_number, clock_src);
-	outb(byte, subpriv->clk_sce_iobase);
+	outb(byte, dev->iobase + subpriv->clk_sce_ofs);
 
 	return 0;
 }
@@ -1071,12 +1074,13 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	spin_lock_irqsave(&subpriv->spinlock, flags);
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
-		ret = i8254_set_mode(subpriv->iobase, 0, chan, data[1]);
+		ret = i8254_set_mode(dev->iobase + subpriv->ofs, 0, chan,
+				     data[1]);
 		if (ret < 0)
 			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_8254_READ_STATUS:
-		data[1] = i8254_status(subpriv->iobase, 0, chan);
+		data[1] = i8254_status(dev->iobase + subpriv->ofs, 0, chan);
 		break;
 	case INSN_CONFIG_SET_GATE_SRC:
 		ret = dio200_subdev_8254_set_gate_src(dev, s, chan, data[2]);
@@ -1114,13 +1118,10 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 
 /*
  * This function initializes an '8254' counter subdevice.
- *
- * Note: iobase is the base address of the board, not the subdevice;
- * offset is the offset to the 8254 chip.
  */
 static int
 dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned long iobase, unsigned offset)
+			unsigned int offset)
 {
 	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv;
@@ -1142,20 +1143,18 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	s->insn_config = dio200_subdev_8254_config;
 
 	spin_lock_init(&subpriv->spinlock);
-	subpriv->iobase = offset + iobase;
+	subpriv->ofs = offset;
 	if (layout->has_clk_gat_sce) {
 		/* Derive CLK_SCE and GAT_SCE register offsets from
 		 * 8254 offset. */
-		subpriv->clk_sce_iobase =
-		    DIO200_XCLK_SCE + (offset >> 3) + iobase;
-		subpriv->gat_sce_iobase =
-		    DIO200_XGAT_SCE + (offset >> 3) + iobase;
+		subpriv->clk_sce_ofs = DIO200_XCLK_SCE + (offset >> 3);
+		subpriv->gat_sce_ofs = DIO200_XGAT_SCE + (offset >> 3);
 		subpriv->which = (offset >> 2) & 1;
 	}
 
 	/* Initialize channels. */
 	for (chan = 0; chan < 3; chan++) {
-		i8254_set_mode(subpriv->iobase, 0, chan,
+		i8254_set_mode(dev->iobase + subpriv->ofs, 0, chan,
 			       I8254_MODE0 | I8254_BINARY);
 		if (layout->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
@@ -1228,7 +1227,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 		switch (layout->sdtype[n]) {
 		case sd_8254:
 			/* counter subdevice (8254) */
-			ret = dio200_subdev_8254_init(dev, s, iobase,
+			ret = dio200_subdev_8254_init(dev, s,
 						      layout->sdinfo[n]);
 			if (ret < 0)
 				return ret;
@@ -1244,11 +1243,9 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 			/* 'INTERRUPT' subdevice */
 			if (irq) {
 				ret = dio200_subdev_intr_init(dev, s,
-							      iobase +
 							      DIO200_INT_SCE,
-							      layout->sdinfo[n],
-							      layout->
-							      has_int_sce);
+							      layout->sdinfo[n]
+							     );
 				if (ret < 0)
 					return ret;
 				devpriv->intr_sd = n;

commit 4bb4021762c33e65645244a965001454cbda6145
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:54 2012 +0100

    staging: comedi: amplc_dio200: remove 'has_clk_gat_sce' from subdevice
    
    The `has_clk_gat_sce` member of `struct dio200_subdev_8254` indicates
    whether the board has clock and gate source selection registers.  The
    same information can be obtained from read-only board layout data so
    doesn't need to be set per '8254' counter subdevice.  Eliminate the
    member and use the read-only data instead.  The last parameter of
    `dio200_subdev_8254_init()` is used to initialize this member, so remove
    that parameter as well.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index bf4f6e3365c0..bab2e6477fa4 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -425,7 +425,6 @@ struct dio200_subdev_8254 {
 	unsigned long clk_sce_iobase;	/* CLK_SCE base address */
 	unsigned long gat_sce_iobase;	/* GAT_SCE base address */
 	int which;		/* Bit 5 of CLK_SCE or GAT_SCE */
-	int has_clk_gat_sce;
 	unsigned clock_src[3];	/* Current clock sources */
 	unsigned gate_src[3];	/* Current gate sources */
 	spinlock_t spinlock;
@@ -970,10 +969,11 @@ dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
 				unsigned int counter_number,
 				unsigned int gate_src)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned char byte;
 
-	if (!subpriv->has_clk_gat_sce)
+	if (!layout->has_clk_gat_sce)
 		return -1;
 	if (counter_number > 2)
 		return -1;
@@ -995,9 +995,10 @@ dio200_subdev_8254_get_gate_src(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int counter_number)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv = s->private;
 
-	if (!subpriv->has_clk_gat_sce)
+	if (!layout->has_clk_gat_sce)
 		return -1;
 	if (counter_number > 2)
 		return -1;
@@ -1014,10 +1015,11 @@ dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
 				 unsigned int counter_number,
 				 unsigned int clock_src)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned char byte;
 
-	if (!subpriv->has_clk_gat_sce)
+	if (!layout->has_clk_gat_sce)
 		return -1;
 	if (counter_number > 2)
 		return -1;
@@ -1040,10 +1042,11 @@ dio200_subdev_8254_get_clock_src(struct comedi_device *dev,
 				 unsigned int counter_number,
 				 unsigned int *period_ns)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned clock_src;
 
-	if (!subpriv->has_clk_gat_sce)
+	if (!layout->has_clk_gat_sce)
 		return -1;
 	if (counter_number > 2)
 		return -1;
@@ -1117,9 +1120,9 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int
 dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
-			unsigned long iobase, unsigned offset,
-			int has_clk_gat_sce)
+			unsigned long iobase, unsigned offset)
 {
+	const struct dio200_layout *layout = dio200_dev_layout(dev);
 	struct dio200_subdev_8254 *subpriv;
 	unsigned int chan;
 
@@ -1140,8 +1143,7 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	spin_lock_init(&subpriv->spinlock);
 	subpriv->iobase = offset + iobase;
-	subpriv->has_clk_gat_sce = has_clk_gat_sce;
-	if (has_clk_gat_sce) {
+	if (layout->has_clk_gat_sce) {
 		/* Derive CLK_SCE and GAT_SCE register offsets from
 		 * 8254 offset. */
 		subpriv->clk_sce_iobase =
@@ -1155,7 +1157,7 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	for (chan = 0; chan < 3; chan++) {
 		i8254_set_mode(subpriv->iobase, 0, chan,
 			       I8254_MODE0 | I8254_BINARY);
-		if (subpriv->has_clk_gat_sce) {
+		if (layout->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
 			dio200_subdev_8254_set_gate_src(dev, s, chan, 0);
 			/* Clock source 0 is the dedicated clock input. */
@@ -1227,8 +1229,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 		case sd_8254:
 			/* counter subdevice (8254) */
 			ret = dio200_subdev_8254_init(dev, s, iobase,
-						      layout->sdinfo[n],
-						      layout->has_clk_gat_sce);
+						      layout->sdinfo[n]);
 			if (ret < 0)
 				return ret;
 			break;

commit a56a8a3c4979b0c968a53ab9cdbf6887e8e6ba1e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:53 2012 +0100

    staging: comedi: amplc_dio200: add helpers to get board layout
    
    Add inline helper function `dio200_board_layout(board)` to get a pointer
    to the board layout data for a board.  Add inline helper function
    `dio200_dev_layout(dev)` to get a pointer to the board layout data for a
    comedi device (this function is currently unused but will be used by a
    later change).
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index b03e7e32fb1f..bf4f6e3365c0 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -442,6 +442,18 @@ struct dio200_subdev_intr {
 	int continuous;
 };
 
+static inline const struct dio200_layout *
+dio200_board_layout(const struct dio200_board *board)
+{
+	return &dio200_layouts[board->layout];
+}
+
+static inline const struct dio200_layout *
+dio200_dev_layout(struct comedi_device *dev)
+{
+	return dio200_board_layout(comedi_board(dev));
+}
+
 static inline bool is_pci_board(const struct dio200_board *board)
 {
 	return DO_PCI && board->bustype == pci_bustype;
@@ -1195,7 +1207,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv = dev->private;
-	const struct dio200_layout *layout = &dio200_layouts[thisboard->layout];
+	const struct dio200_layout *layout = dio200_board_layout(thisboard);
 	struct comedi_subdevice *s;
 	int sdx;
 	unsigned int n;
@@ -1353,7 +1365,7 @@ static void dio200_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices) {
-		layout = &dio200_layouts[thisboard->layout];
+		layout = dio200_board_layout(thisboard);
 		for (n = 0; n < dev->n_subdevices; n++) {
 			struct comedi_subdevice *s = &dev->subdevices[n];
 			switch (layout->sdtype[n]) {

commit 4821bdfc9c39349f97e9c604992aafd55f45255a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:52 2012 +0100

    staging: comedi: amplc_dio200: rename struct dio200_layout_struct
    
    Now that the tag name `dio200_layout` is available, rename `struct
    dio200_layout_struct` to `struct dio200_layout` as the `_struct` suffix
    is a bit redundant and I plan to use this type in other places in the
    module.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index a5876f870968..b03e7e32fb1f 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -351,7 +351,7 @@ enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254 };
 #define DIO200_MAX_SUBDEVS	7
 #define DIO200_MAX_ISNS		6
 
-struct dio200_layout_struct {
+struct dio200_layout {
 	unsigned short n_subdevs;	/* number of subdevices */
 	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
 	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
@@ -359,7 +359,7 @@ struct dio200_layout_struct {
 	char has_clk_gat_sce;	/* has clock/gate selection registers */
 };
 
-static const struct dio200_layout_struct dio200_layouts[] = {
+static const struct dio200_layout dio200_layouts[] = {
 #if DO_ISA
 	[pc212_layout] = {
 			  .n_subdevs = 6,
@@ -1195,8 +1195,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct dio200_private *devpriv = dev->private;
-	const struct dio200_layout_struct *layout =
-		&dio200_layouts[thisboard->layout];
+	const struct dio200_layout *layout = &dio200_layouts[thisboard->layout];
 	struct comedi_subdevice *s;
 	int sdx;
 	unsigned int n;
@@ -1348,7 +1347,7 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	const struct dio200_layout_struct *layout;
+	const struct dio200_layout *layout;
 	unsigned n;
 
 	if (dev->irq)

commit 853376e502283d740b7700524c822bb924b171b5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:51 2012 +0100

    staging: comedi: amplc_dio200: rename enum dio200_layout
    
    Rename `enum dio200_layout` to `enum dio200_layout_idx`.  It's only used
    once and frees up the `dio200_layout` tag for something else later.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index a7fdd66e0290..a5876f870968 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -270,7 +270,7 @@ enum dio200_model {
 	pc272e_model, pci272_model,
 };
 
-enum dio200_layout {
+enum dio200_layout_idx {
 #if DO_ISA
 	pc212_layout,
 	pc214_layout,
@@ -287,7 +287,7 @@ struct dio200_board {
 	unsigned short devid;
 	enum dio200_bustype bustype;
 	enum dio200_model model;
-	enum dio200_layout layout;
+	enum dio200_layout_idx layout;
 };
 
 static const struct dio200_board dio200_boards[] = {

commit 96a9319f71169a159a38113964f0745697d33929
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:50 2012 +0100

    staging: comedi: amplc_dio200: pass device to clock/gate config
    
    Rename the clock and gate configuration functions for the '8254' counter
    subdevices and pass in the pointers to the comedi device and comedi
    subdevice.  This is just preparing the way for later changes.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 0cc6e11d188a..a7fdd66e0290 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -953,9 +953,12 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
  * Set gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_gate_src(struct dio200_subdev_8254 *subpriv,
-		    unsigned int counter_number, unsigned int gate_src)
+dio200_subdev_8254_set_gate_src(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int counter_number,
+				unsigned int gate_src)
 {
+	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned char byte;
 
 	if (!subpriv->has_clk_gat_sce)
@@ -976,9 +979,12 @@ dio200_set_gate_src(struct dio200_subdev_8254 *subpriv,
  * Get gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_gate_src(struct dio200_subdev_8254 *subpriv,
-		    unsigned int counter_number)
+dio200_subdev_8254_get_gate_src(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int counter_number)
 {
+	struct dio200_subdev_8254 *subpriv = s->private;
+
 	if (!subpriv->has_clk_gat_sce)
 		return -1;
 	if (counter_number > 2)
@@ -991,9 +997,12 @@ dio200_get_gate_src(struct dio200_subdev_8254 *subpriv,
  * Set clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_clock_src(struct dio200_subdev_8254 *subpriv,
-		     unsigned int counter_number, unsigned int clock_src)
+dio200_subdev_8254_set_clock_src(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 unsigned int counter_number,
+				 unsigned int clock_src)
 {
+	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned char byte;
 
 	if (!subpriv->has_clk_gat_sce)
@@ -1014,9 +1023,12 @@ dio200_set_clock_src(struct dio200_subdev_8254 *subpriv,
  * Get clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_clock_src(struct dio200_subdev_8254 *subpriv,
-		     unsigned int counter_number, unsigned int *period_ns)
+dio200_subdev_8254_get_clock_src(struct comedi_device *dev,
+				 struct comedi_subdevice *s,
+				 unsigned int counter_number,
+				 unsigned int *period_ns)
 {
+	struct dio200_subdev_8254 *subpriv = s->private;
 	unsigned clock_src;
 
 	if (!subpriv->has_clk_gat_sce)
@@ -1052,12 +1064,12 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 		data[1] = i8254_status(subpriv->iobase, 0, chan);
 		break;
 	case INSN_CONFIG_SET_GATE_SRC:
-		ret = dio200_set_gate_src(subpriv, chan, data[2]);
+		ret = dio200_subdev_8254_set_gate_src(dev, s, chan, data[2]);
 		if (ret < 0)
 			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_GET_GATE_SRC:
-		ret = dio200_get_gate_src(subpriv, chan);
+		ret = dio200_subdev_8254_get_gate_src(dev, s, chan);
 		if (ret < 0) {
 			ret = -EINVAL;
 			break;
@@ -1065,12 +1077,12 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 		data[2] = ret;
 		break;
 	case INSN_CONFIG_SET_CLOCK_SRC:
-		ret = dio200_set_clock_src(subpriv, chan, data[1]);
+		ret = dio200_subdev_8254_set_clock_src(dev, s, chan, data[1]);
 		if (ret < 0)
 			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
-		ret = dio200_get_clock_src(subpriv, chan, &data[2]);
+		ret = dio200_subdev_8254_get_clock_src(dev, s, chan, &data[2]);
 		if (ret < 0) {
 			ret = -EINVAL;
 			break;
@@ -1133,9 +1145,9 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 			       I8254_MODE0 | I8254_BINARY);
 		if (subpriv->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
-			dio200_set_gate_src(subpriv, chan, 0);
+			dio200_subdev_8254_set_gate_src(dev, s, chan, 0);
 			/* Clock source 0 is the dedicated clock input. */
-			dio200_set_clock_src(subpriv, chan, 0);
+			dio200_subdev_8254_set_clock_src(dev, s, chan, 0);
 		}
 	}
 

commit dba949a1a0839d324642d99bce90052964125b45
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:49 2012 +0100

    staging: comedi: amplc_dio200: absorb dio200_pci_common_attach()
    
    Absorb `dio200_pci_common_attach()` into `dio200_attach_pci()` since
    that's the only place it is called from.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 2c39dc5f8d5f..0cc6e11d188a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1253,22 +1253,6 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 	return 1;
 }
 
-static int dio200_pci_common_attach(struct comedi_device *dev,
-				    struct pci_dev *pci_dev)
-{
-	unsigned long iobase;
-	int ret;
-
-	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
-	if (ret < 0) {
-		dev_err(dev->class_dev,
-			"error! cannot enable PCI device and request regions!\n");
-		return ret;
-	}
-	iobase = pci_resource_start(pci_dev, 2);
-	return dio200_common_attach(dev, iobase, pci_dev->irq, IRQF_SHARED);
-}
-
 /*
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.  If you specified a board_name array
@@ -1320,6 +1304,8 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
 	struct dio200_private *devpriv;
+	unsigned long iobase;
+	int ret;
 
 	if (!DO_PCI)
 		return -EINVAL;
@@ -1337,7 +1323,14 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	return dio200_pci_common_attach(dev, pci_dev);
+	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
+	if (ret < 0) {
+		dev_err(dev->class_dev,
+			"error! cannot enable PCI device and request regions!\n");
+		return ret;
+	}
+	iobase = pci_resource_start(pci_dev, 2);
+	return dio200_common_attach(dev, iobase, pci_dev->irq, IRQF_SHARED);
 }
 
 static void dio200_detach(struct comedi_device *dev)

commit 8e17cfbaa0b6ffa839028661327a17020cc53d2d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:48 2012 +0100

    staging: comedi: amplc_dio200: no need to set hw_dev
    
    The call to `comedi_set_hw_dev()` from `dio200_pci_common_attach()` is
    now unnecessary since `dio200_pci_common_attach()` is now only called
    from this driver's `attach_pci` hook `dio200_attach_pci()` and the
    comedi core now calls `comedi_set_hw_dev()` before calling that.  Remove
    the unnecessary call.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 06550c999bac..2c39dc5f8d5f 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1259,8 +1259,6 @@ static int dio200_pci_common_attach(struct comedi_device *dev,
 	unsigned long iobase;
 	int ret;
 
-	comedi_set_hw_dev(dev, &pci_dev->dev);
-
 	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 	if (ret < 0) {
 		dev_err(dev->class_dev,

commit f34e08f54f078cb4911962b43c2bd16c2f8ccce3
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:47 2012 +0100

    staging: comedi: amplc_dio200: no need to manipulate PCI ref count
    
    Now that this driver no longer supports "manual" attachment of PCI
    devices in its `attach` hook (`dio200_attach()`), it no longer has code
    that searches for a suitable PCI device and increments its reference
    count.  Since the driver no longer has any reason for incrementing and
    decrementing the PCI device's reference count, the calls to
    `pci_dev_get()` and `pci_dev_put()` can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index c07f86b7a4a3..06550c999bac 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1339,13 +1339,6 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
-	/*
-	 * Need to 'get' the PCI device to match the 'put' in dio200_detach().
-	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
-	 * support for manual attachment of PCI devices via dio200_attach()
-	 * has been removed.
-	 */
-	pci_dev_get(pci_dev);
 	return dio200_pci_common_attach(dev, pci_dev);
 }
 
@@ -1384,7 +1377,6 @@ static void dio200_detach(struct comedi_device *dev)
 		if (pcidev) {
 			if (dev->iobase)
 				comedi_pci_disable(pcidev);
-			pci_dev_put(pcidev);
 		}
 	}
 }

commit e45e423be45d7bbb404fd6db724960eea3702681
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:46 2012 +0100

    staging: comedi: amplc_dio200: remove manual configuration of PCI boards
    
    Remove the code that allows PCI boards to be manually attached by the
    `COMEDI_DEVCONFIG` ioctl (or the "comedi_config" application).
    Supported PCI boards will be attached automatically at probe time via
    `comedi_pci_auto_config()` and the `attach_pci` hook in the `struct
    comedi_driver`.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d08bab4d3f24..c07f86b7a4a3 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -29,8 +29,7 @@
  * Description: Amplicon 200 Series Digital I/O
  * Author: Ian Abbott <abbotti@mev.co.uk>
  * Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
- *   PCI215 (pci215 or amplc_dio200), PC218E (pc218e), PC272E (pc272e),
- *   PCI272 (pci272 or amplc_dio200)
+ *   PCI215 (pci215), PC218E (pc218e), PC272E (pc272e), PCI272 (pci272)
  * Updated: Wed, 22 Oct 2008 13:36:02 +0100
  * Status: works
  *
@@ -38,11 +37,8 @@
  *   [0] - I/O port base address
  *   [1] - IRQ (optional, but commands won't work without it)
  *
- * Configuration options - PCI215, PCI272:
- *   [0] - PCI bus of device (optional)
- *   [1] - PCI slot of device (optional)
- *   If bus/slot is not specified, the first available PCI device will
- *   be used.
+ * Manual configuration of PCI cards is not supported; they are configured
+ * automatically.
  *
  * Passing a zero for an option is the same as leaving it unspecified.
  *
@@ -272,7 +268,6 @@ enum dio200_model {
 	pc215e_model, pci215_model,
 	pc218e_model,
 	pc272e_model, pci272_model,
-	anypci_model
 };
 
 enum dio200_layout {
@@ -343,12 +338,6 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pci272_model,
 	 .layout = pc272_layout,
 	 },
-	{
-	 .name = DIO200_DRIVER_NAME,
-	 .devid = PCI_DEVICE_ID_INVALID,
-	 .bustype = pci_bustype,
-	 .model = anypci_model,	/* wildcard */
-	 },
 #endif
 };
 
@@ -478,49 +467,6 @@ dio200_find_pci_board(struct pci_dev *pci_dev)
 	return NULL;
 }
 
-/*
- * This function looks for a PCI device matching the requested board name,
- * bus and slot.
- */
-static struct pci_dev *dio200_find_pci_dev(struct comedi_device *dev,
-					   struct comedi_devconfig *it)
-{
-	const struct dio200_board *thisboard = comedi_board(dev);
-	struct pci_dev *pci_dev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
-
-	for_each_pci_dev(pci_dev) {
-		if (bus || slot) {
-			if (bus != pci_dev->bus->number ||
-			    slot != PCI_SLOT(pci_dev->devfn))
-				continue;
-		}
-		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
-			continue;
-
-		if (thisboard->model == anypci_model) {
-			/* Wildcard board matches any supported PCI board. */
-			const struct dio200_board *foundboard;
-
-			foundboard = dio200_find_pci_board(pci_dev);
-			if (foundboard == NULL)
-				continue;
-			/* Replace wildcard board_ptr. */
-			dev->board_ptr = foundboard;
-		} else {
-			/* Match specific model name. */
-			if (pci_dev->device != thisboard->devid)
-				continue;
-		}
-		return pci_dev;
-	}
-	dev_err(dev->class_dev,
-		"No supported board found! (req. bus %d, slot %d)\n",
-		bus, slot);
-	return NULL;
-}
-
 /*
  * This function checks and requests an I/O region, reporting an error
  * if there is a conflict.
@@ -1356,12 +1302,10 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			return ret;
 		return dio200_common_attach(dev, iobase, irq, 0);
 	} else if (is_pci_board(thisboard)) {
-		struct pci_dev *pci_dev;
-
-		pci_dev = dio200_find_pci_dev(dev, it);
-		if (!pci_dev)
-			return -EIO;
-		return dio200_pci_common_attach(dev, pci_dev);
+		dev_err(dev->class_dev,
+			"Manual configuration of PCI board '%s' is not supported\n",
+			thisboard->name);
+		return -EIO;
 	} else {
 		dev_err(dev->class_dev, DIO200_DRIVER_NAME
 			": BUG! cannot determine board type!\n");

commit 41b25f871405a4abd6055ca47d3f3056c75200e7
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 24 16:47:45 2012 +0100

    staging: comedi: amplc_dio200: reformat driver comment
    
    Reformat the driver description comment to use the preferred block
    comment style so that future changes are acceptable to the checkpatch.pl
    script.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 35cd3cbb3bec..d08bab4d3f24 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -25,185 +25,185 @@
 
 */
 /*
-Driver: amplc_dio200
-Description: Amplicon 200 Series Digital I/O
-Author: Ian Abbott <abbotti@mev.co.uk>
-Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
-  PCI215 (pci215 or amplc_dio200), PC218E (pc218e), PC272E (pc272e),
-  PCI272 (pci272 or amplc_dio200)
-Updated: Wed, 22 Oct 2008 13:36:02 +0100
-Status: works
-
-Configuration options - PC212E, PC214E, PC215E, PC218E, PC272E:
-  [0] - I/O port base address
-  [1] - IRQ (optional, but commands won't work without it)
-
-Configuration options - PCI215, PCI272:
-  [0] - PCI bus of device (optional)
-  [1] - PCI slot of device (optional)
-  If bus/slot is not specified, the first available PCI device will
-  be used.
-
-Passing a zero for an option is the same as leaving it unspecified.
-
-SUBDEVICES
-
-		    PC218E         PC212E      PC215E/PCI215
-		 -------------  -------------  -------------
-  Subdevices           7              6              5
-   0                 CTR-X1         PPI-X          PPI-X
-   1                 CTR-X2         CTR-Y1         PPI-Y
-   2                 CTR-Y1         CTR-Y2         CTR-Z1
-   3                 CTR-Y2         CTR-Z1         CTR-Z2
-   4                 CTR-Z1         CTR-Z2       INTERRUPT
-   5                 CTR-Z2       INTERRUPT
-   6               INTERRUPT
-
-		    PC214E      PC272E/PCI272
-		 -------------  -------------
-  Subdevices           4              4
-   0                 PPI-X          PPI-X
-   1                 PPI-Y          PPI-Y
-   2                 CTR-Z1*        PPI-Z
-   3               INTERRUPT*     INTERRUPT
-
-Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
-are configurable as inputs or outputs in four groups:
-
-  Port A  - channels  0 to  7
-  Port B  - channels  8 to 15
-  Port CL - channels 16 to 19
-  Port CH - channels 20 to 23
-
-Only mode 0 of the 8255 chips is supported.
-
-Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
-channel is configured individually with INSN_CONFIG instructions.  The
-specific type of configuration instruction is specified in data[0].
-Some configuration instructions expect an additional parameter in
-data[1]; others return a value in data[1].  The following configuration
-instructions are supported:
-
-  INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
-    BCD/binary setting specified in data[1].
-
-  INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
-    counter channel into data[1].
-
-  INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
-    specified in data[1] (this is a hardware-specific value).  Not
-    supported on PC214E.  For the other boards, valid clock sources are
-    0 to 7 as follows:
-
-      0.  CLK n, the counter channel's dedicated CLK input from the SK1
-	connector.  (N.B. for other values, the counter channel's CLKn
-	pin on the SK1 connector is an output!)
-      1.  Internal 10 MHz clock.
-      2.  Internal 1 MHz clock.
-      3.  Internal 100 kHz clock.
-      4.  Internal 10 kHz clock.
-      5.  Internal 1 kHz clock.
-      6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
-      7.  Ext Clock, the counter chip's dedicated Ext Clock input from
-	the SK1 connector.  This pin is shared by all three counter
-	channels on the chip.
-
-  INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
-    clock source in data[1].  For internal clock sources, data[2] is set
-    to the period in ns.
-
-  INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
-    specified in data[2] (this is a hardware-specific value).  Not
-    supported on PC214E.  For the other boards, valid gate sources are 0
-    to 7 as follows:
-
-      0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
-      1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
-      2.  GAT n, the counter channel's dedicated GAT input from the SK1
-	connector.  (N.B. for other values, the counter channel's GATn
-	pin on the SK1 connector is an output!)
-      3.  /OUT n-2, the inverted output of counter channel n-2 (see note
-	2 below).
-      4.  Reserved.
-      5.  Reserved.
-      6.  Reserved.
-      7.  Reserved.
-
-  INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
-    source in data[2].
-
-Clock and gate interconnection notes:
-
-  1.  Clock source OUT n-1 is the output of the preceding channel on the
-  same counter subdevice if n > 0, or the output of channel 2 on the
-  preceding counter subdevice (see note 3) if n = 0.
-
-  2.  Gate source /OUT n-2 is the inverted output of channel 0 on the
-  same counter subdevice if n = 2, or the inverted output of channel n+1
-  on the preceding counter subdevice (see note 3) if n < 2.
-
-  3.  The counter subdevices are connected in a ring, so the highest
-  counter subdevice precedes the lowest.
-
-The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
-digital inputs come from the interrupt status register.  The number of
-channels matches the number of interrupt sources.  The PC214E does not
-have an interrupt status register; see notes on 'INTERRUPT SOURCES'
-below.
-
-INTERRUPT SOURCES
-
-		    PC218E         PC212E      PC215E/PCI215
-		 -------------  -------------  -------------
-  Sources              6              6              6
-   0              CTR-X1-OUT      PPI-X-C0       PPI-X-C0
-   1              CTR-X2-OUT      PPI-X-C3       PPI-X-C3
-   2              CTR-Y1-OUT     CTR-Y1-OUT      PPI-Y-C0
-   3              CTR-Y2-OUT     CTR-Y2-OUT      PPI-Y-C3
-   4              CTR-Z1-OUT     CTR-Z1-OUT     CTR-Z1-OUT
-   5              CTR-Z2-OUT     CTR-Z2-OUT     CTR-Z2-OUT
-
-		    PC214E      PC272E/PCI272
-		 -------------  -------------
-  Sources              1              6
-   0               JUMPER-J5      PPI-X-C0
-   1                              PPI-X-C3
-   2                              PPI-Y-C0
-   3                              PPI-Y-C3
-   4                              PPI-Z-C0
-   5                              PPI-Z-C3
-
-When an interrupt source is enabled in the interrupt source enable
-register, a rising edge on the source signal latches the corresponding
-bit to 1 in the interrupt status register.
-
-When the interrupt status register value as a whole (actually, just the
-6 least significant bits) goes from zero to non-zero, the board will
-generate an interrupt.  For level-triggered hardware interrupts (PCI
-card), the interrupt will remain asserted until the interrupt status
-register is cleared to zero.  For edge-triggered hardware interrupts
-(ISA card), no further interrupts will occur until the interrupt status
-register is cleared to zero.  To clear a bit to zero in the interrupt
-status register, the corresponding interrupt source must be disabled
-in the interrupt source enable register (there is no separate interrupt
-clear register).
-
-The PC214E does not have an interrupt source enable register or an
-interrupt status register; its 'INTERRUPT' subdevice has a single
-channel and its interrupt source is selected by the position of jumper
-J5.
-
-COMMANDS
-
-The driver supports a read streaming acquisition command on the
-'INTERRUPT' subdevice.  The channel list selects the interrupt sources
-to be enabled.  All channels will be sampled together (convert_src ==
-TRIG_NOW).  The scan begins a short time after the hardware interrupt
-occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
-scan_begin_arg == 0).  The value read from the interrupt status register
-is packed into a short value, one bit per requested channel, in the
-order they appear in the channel list.
-*/
+ * Driver: amplc_dio200
+ * Description: Amplicon 200 Series Digital I/O
+ * Author: Ian Abbott <abbotti@mev.co.uk>
+ * Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
+ *   PCI215 (pci215 or amplc_dio200), PC218E (pc218e), PC272E (pc272e),
+ *   PCI272 (pci272 or amplc_dio200)
+ * Updated: Wed, 22 Oct 2008 13:36:02 +0100
+ * Status: works
+ *
+ * Configuration options - PC212E, PC214E, PC215E, PC218E, PC272E:
+ *   [0] - I/O port base address
+ *   [1] - IRQ (optional, but commands won't work without it)
+ *
+ * Configuration options - PCI215, PCI272:
+ *   [0] - PCI bus of device (optional)
+ *   [1] - PCI slot of device (optional)
+ *   If bus/slot is not specified, the first available PCI device will
+ *   be used.
+ *
+ * Passing a zero for an option is the same as leaving it unspecified.
+ *
+ * SUBDEVICES
+ *
+ *                     PC218E         PC212E      PC215E/PCI215
+ *                  -------------  -------------  -------------
+ *   Subdevices           7              6              5
+ *    0                 CTR-X1         PPI-X          PPI-X
+ *    1                 CTR-X2         CTR-Y1         PPI-Y
+ *    2                 CTR-Y1         CTR-Y2         CTR-Z1
+ *    3                 CTR-Y2         CTR-Z1         CTR-Z2
+ *    4                 CTR-Z1         CTR-Z2       INTERRUPT
+ *    5                 CTR-Z2       INTERRUPT
+ *    6               INTERRUPT
+ *
+ *                     PC214E      PC272E/PCI272
+ *                  -------------  -------------
+ *   Subdevices           4              4
+ *    0                 PPI-X          PPI-X
+ *    1                 PPI-Y          PPI-Y
+ *    2                 CTR-Z1*        PPI-Z
+ *    3               INTERRUPT*     INTERRUPT
+ *
+ * Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
+ * are configurable as inputs or outputs in four groups:
+ *
+ *   Port A  - channels  0 to  7
+ *   Port B  - channels  8 to 15
+ *   Port CL - channels 16 to 19
+ *   Port CH - channels 20 to 23
+ *
+ * Only mode 0 of the 8255 chips is supported.
+ *
+ * Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
+ * channel is configured individually with INSN_CONFIG instructions.  The
+ * specific type of configuration instruction is specified in data[0].
+ * Some configuration instructions expect an additional parameter in
+ * data[1]; others return a value in data[1].  The following configuration
+ * instructions are supported:
+ *
+ *   INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
+ *     BCD/binary setting specified in data[1].
+ *
+ *   INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
+ *     counter channel into data[1].
+ *
+ *   INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
+ *     specified in data[1] (this is a hardware-specific value).  Not
+ *     supported on PC214E.  For the other boards, valid clock sources are
+ *     0 to 7 as follows:
+ *
+ *       0.  CLK n, the counter channel's dedicated CLK input from the SK1
+ *         connector.  (N.B. for other values, the counter channel's CLKn
+ *         pin on the SK1 connector is an output!)
+ *       1.  Internal 10 MHz clock.
+ *       2.  Internal 1 MHz clock.
+ *       3.  Internal 100 kHz clock.
+ *       4.  Internal 10 kHz clock.
+ *       5.  Internal 1 kHz clock.
+ *       6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
+ *       7.  Ext Clock, the counter chip's dedicated Ext Clock input from
+ *         the SK1 connector.  This pin is shared by all three counter
+ *         channels on the chip.
+ *
+ *   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
+ *     clock source in data[1].  For internal clock sources, data[2] is set
+ *     to the period in ns.
+ *
+ *   INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
+ *     specified in data[2] (this is a hardware-specific value).  Not
+ *     supported on PC214E.  For the other boards, valid gate sources are 0
+ *     to 7 as follows:
+ *
+ *       0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
+ *       1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
+ *       2.  GAT n, the counter channel's dedicated GAT input from the SK1
+ *         connector.  (N.B. for other values, the counter channel's GATn
+ *         pin on the SK1 connector is an output!)
+ *       3.  /OUT n-2, the inverted output of counter channel n-2 (see note
+ *         2 below).
+ *       4.  Reserved.
+ *       5.  Reserved.
+ *       6.  Reserved.
+ *       7.  Reserved.
+ *
+ *   INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
+ *     source in data[2].
+ *
+ * Clock and gate interconnection notes:
+ *
+ *   1.  Clock source OUT n-1 is the output of the preceding channel on the
+ *   same counter subdevice if n > 0, or the output of channel 2 on the
+ *   preceding counter subdevice (see note 3) if n = 0.
+ *
+ *   2.  Gate source /OUT n-2 is the inverted output of channel 0 on the
+ *   same counter subdevice if n = 2, or the inverted output of channel n+1
+ *   on the preceding counter subdevice (see note 3) if n < 2.
+ *
+ *   3.  The counter subdevices are connected in a ring, so the highest
+ *   counter subdevice precedes the lowest.
+ *
+ * The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
+ * digital inputs come from the interrupt status register.  The number of
+ * channels matches the number of interrupt sources.  The PC214E does not
+ * have an interrupt status register; see notes on 'INTERRUPT SOURCES'
+ * below.
+ *
+ * INTERRUPT SOURCES
+ *
+ *                     PC218E         PC212E      PC215E/PCI215
+ *                  -------------  -------------  -------------
+ *   Sources              6              6              6
+ *    0              CTR-X1-OUT      PPI-X-C0       PPI-X-C0
+ *    1              CTR-X2-OUT      PPI-X-C3       PPI-X-C3
+ *    2              CTR-Y1-OUT     CTR-Y1-OUT      PPI-Y-C0
+ *    3              CTR-Y2-OUT     CTR-Y2-OUT      PPI-Y-C3
+ *    4              CTR-Z1-OUT     CTR-Z1-OUT     CTR-Z1-OUT
+ *    5              CTR-Z2-OUT     CTR-Z2-OUT     CTR-Z2-OUT
+ *
+ *                     PC214E      PC272E/PCI272
+ *                  -------------  -------------
+ *   Sources              1              6
+ *    0               JUMPER-J5      PPI-X-C0
+ *    1                              PPI-X-C3
+ *    2                              PPI-Y-C0
+ *    3                              PPI-Y-C3
+ *    4                              PPI-Z-C0
+ *    5                              PPI-Z-C3
+ *
+ * When an interrupt source is enabled in the interrupt source enable
+ * register, a rising edge on the source signal latches the corresponding
+ * bit to 1 in the interrupt status register.
+ *
+ * When the interrupt status register value as a whole (actually, just the
+ * 6 least significant bits) goes from zero to non-zero, the board will
+ * generate an interrupt.  For level-triggered hardware interrupts (PCI
+ * card), the interrupt will remain asserted until the interrupt status
+ * register is cleared to zero.  For edge-triggered hardware interrupts
+ * (ISA card), no further interrupts will occur until the interrupt status
+ * register is cleared to zero.  To clear a bit to zero in the interrupt
+ * status register, the corresponding interrupt source must be disabled
+ * in the interrupt source enable register (there is no separate interrupt
+ * clear register).
+ *
+ * The PC214E does not have an interrupt source enable register or an
+ * interrupt status register; its 'INTERRUPT' subdevice has a single
+ * channel and its interrupt source is selected by the position of jumper
+ * J5.
+ *
+ * COMMANDS
+ *
+ * The driver supports a read streaming acquisition command on the
+ * 'INTERRUPT' subdevice.  The channel list selects the interrupt sources
+ * to be enabled.  All channels will be sampled together (convert_src ==
+ * TRIG_NOW).  The scan begins a short time after the hardware interrupt
+ * occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
+ * scan_begin_arg == 0).  The value read from the interrupt status register
+ * is packed into a short value, one bit per requested channel, in the
+ * order they appear in the channel list.
+ */
 
 #include <linux/interrupt.h>
 #include <linux/slab.h>

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 556c63304324..35cd3cbb3bec 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1339,10 +1339,10 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	/* Process options and reserve resources according to bus type. */
 	if (is_isa_board(thisboard)) {
@@ -1378,7 +1378,6 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
 	struct dio200_private *devpriv;
-	int ret;
 
 	if (!DO_PCI)
 		return -EINVAL;
@@ -1386,10 +1385,10 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
 		 pci_name(pci_dev));
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	dev->board_ptr = dio200_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {

commit 9a1a6cf8ae5ca58171e117335b9983e3cfa2185c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Oct 15 10:15:52 2012 -0700

    staging: comedi: drivers: remove remaining devpriv macros
    
    The remaining comedi drivers that still have a devpriv macro
    are all pretty straight forward for removing the devpriv
    macro.
    
    This macro relies on a local variable having a specific name.
    Remove its use by replacing it with a local variable where
    used.
    
    The inline function alloc_private(), used to kzalloc the
    dev->private memory, returns non-zero if there is an error.
    Fix all the alloc_private() calls accordingly and remove any
    kernel messages or obvious comments that still exist in the
    drivers. Leave a comment in the skel driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 08f305210a69..556c63304324 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1334,15 +1334,15 @@ static int dio200_pci_common_attach(struct comedi_device *dev,
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv;
 	int ret;
 
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
 
-	ret = alloc_private(dev, sizeof(struct dio200_private));
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
-	}
+	devpriv = dev->private;
 
 	/* Process options and reserve resources according to bus type. */
 	if (is_isa_board(thisboard)) {
@@ -1377,6 +1377,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 static int __devinit dio200_attach_pci(struct comedi_device *dev,
 				       struct pci_dev *pci_dev)
 {
+	struct dio200_private *devpriv;
 	int ret;
 
 	if (!DO_PCI)
@@ -1384,11 +1385,12 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
 		 pci_name(pci_dev));
-	ret = alloc_private(dev, sizeof(struct dio200_private));
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
 		return ret;
-	}
+	devpriv = dev->private;
+
 	dev->board_ptr = dio200_find_pci_board(pci_dev);
 	if (dev->board_ptr == NULL) {
 		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index b7cfc13a951f..08f305210a69 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -210,6 +210,7 @@ order they appear in the channel list.
 
 #include "../comedidev.h"
 
+#include "comedi_fc.h"
 #include "8255.h"
 #include "8253.h"
 
@@ -771,52 +772,24 @@ dio200_subdev_intr_cmdtest(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
-	unsigned int tmp;
 
-	/* step 1: make sure trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= (TRIG_NOW | TRIG_INT);
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually
-		   compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
-		err++;
-	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit 6b680f90c3300505a62e456b3c0e56de358f5d9a
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:29:25 2012 -0700

    staging: comedi: amplc_dio200: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Use a local variable for the subdevice pointer to keep the line
    < 80 chars.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 585889282b25..b7cfc13a951f 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -978,15 +978,15 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct dio200_private *devpriv = dev->private;
+	struct comedi_subdevice *s;
 	int handled;
 
 	if (!dev->attached)
 		return IRQ_NONE;
 
 	if (devpriv->intr_sd >= 0) {
-		handled = dio200_handle_read_intr(dev,
-						  dev->subdevices +
-						  devpriv->intr_sd);
+		s = &dev->subdevices[devpriv->intr_sd];
+		handled = dio200_handle_read_intr(dev, s);
 	} else {
 		handled = 0;
 	}

commit 4d480efacee65eba9b6301dd02d679458d5ce447
Merge: 9ac6eb40510b 4a7a4f95a5e1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 4 11:46:38 2012 -0700

    Merge branch 'staging-linus' into staging-next
    
    This gets the 6 staging comedi patches that are needed for further
    patches that Ian sent.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1a6671d208bb8f558dc12b6a7d2f55e80cf5828d
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Sep 3 16:39:39 2012 +0100

    staging: comedi: amplc_dio200: Fix PCI ref count
    
    When attaching a PCI device manually via the comedi driver `attach` hook
    (`dio200_attach()`) (called by the comedi core for the
    `COMEDI_DEVCONFIG` ioctl), its reference count is incremented in the
    `for_each_pci_dev` loop (in `dio200_find_pci_dev()`).  It is decremented
    when the `detach` hook (`dio200_detach()`) is called to detach the
    device.  However, when the PCI device is attached automatically via the
    `attach_pci` hook (`dio200_attach_pci()`, called at probe time via
    `comedi_pci_auto_config()`) it's reference count is not incremented so
    there will be an unmatched decrement when detaching the device.
    
    Increment the PCI device reference count in `dio200_attach_pci()` to
    correct the mismatch.
    
    Once support for manual configuration has been removed from this driver,
    the calls to `pci_dev_get()` and `pci_dev_put()` can be removed.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6c81e377262c..cc8931fde839 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1412,6 +1412,13 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
+	/*
+	 * Need to 'get' the PCI device to match the 'put' in dio200_detach().
+	 * TODO: Remove the pci_dev_get() and matching pci_dev_put() once
+	 * support for manual attachment of PCI devices via dio200_attach()
+	 * has been removed.
+	 */
+	pci_dev_get(pci_dev);
 	return dio200_pci_common_attach(dev, pci_dev);
 }
 

commit c2dea97429788d920bf51d33cba6c4cf72617726
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Aug 15 15:31:41 2012 +0100

    staging: comedi: amplc_dio200: replace macros with inline functions
    
    Replace the IS_ISA_BOARD() and IS_PCI_BOARD() functionlike macros with
    inline functions is_isa_board() and is_pci_board().  Also call
    is_pci_board() in dio200_find_pci_board() instead of an explicit
    comparison operator.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f31d79893457..9c8fbf1b15f0 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -294,9 +294,6 @@ struct dio200_board {
 	enum dio200_layout layout;
 };
 
-#define IS_ISA_BOARD(board)	(DO_ISA && (board)->bustype == isa_bustype)
-#define IS_PCI_BOARD(board)	(DO_PCI && (board)->bustype == pci_bustype)
-
 static const struct dio200_board dio200_boards[] = {
 #if DO_ISA
 	{
@@ -455,6 +452,16 @@ struct dio200_subdev_intr {
 	int continuous;
 };
 
+static inline bool is_pci_board(const struct dio200_board *board)
+{
+	return DO_PCI && board->bustype == pci_bustype;
+}
+
+static inline bool is_isa_board(const struct dio200_board *board)
+{
+	return DO_ISA && board->bustype == isa_bustype;
+}
+
 /*
  * This function looks for a board matching the supplied PCI device.
  */
@@ -464,7 +471,7 @@ dio200_find_pci_board(struct pci_dev *pci_dev)
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(dio200_boards); i++)
-		if (dio200_boards[i].bustype == pci_bustype &&
+		if (is_pci_board(&dio200_boards[i]) &&
 		    pci_dev->device == dio200_boards[i].devid)
 			return &dio200_boards[i];
 	return NULL;
@@ -1234,10 +1241,10 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	char tmpbuf[60];
 	int tmplen;
 
-	if (IS_ISA_BOARD(thisboard))
+	if (is_isa_board(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(base %#lx) ", dev->iobase);
-	else if (IS_PCI_BOARD(thisboard))
+	else if (is_pci_board(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(pci %s) ", pci_name(pcidev));
 	else
@@ -1365,7 +1372,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* Process options and reserve resources according to bus type. */
-	if (IS_ISA_BOARD(thisboard)) {
+	if (is_isa_board(thisboard)) {
 		unsigned long iobase;
 		unsigned int irq;
 
@@ -1375,7 +1382,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret < 0)
 			return ret;
 		return dio200_common_attach(dev, iobase, irq, 0);
-	} else if (IS_PCI_BOARD(thisboard)) {
+	} else if (is_pci_board(thisboard)) {
 		struct pci_dev *pci_dev;
 
 		pci_dev = dio200_find_pci_dev(dev, it);
@@ -1444,10 +1451,10 @@ static void dio200_detach(struct comedi_device *dev)
 			}
 		}
 	}
-	if (IS_ISA_BOARD(thisboard)) {
+	if (is_isa_board(thisboard)) {
 		if (dev->iobase)
 			release_region(dev->iobase, DIO200_IO_SIZE);
-	} else if (IS_PCI_BOARD(thisboard)) {
+	} else if (is_pci_board(thisboard)) {
 		struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 		if (pcidev) {
 			if (dev->iobase)

commit 858c8ada41c5ff9700f23c6b41adb9586f2983b8
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 14 16:31:28 2012 +0100

    staging: comedi: amplc_dio200: add helper macros to check bus type
    
    Add helper macro IS_ISA_BOARD(board) to check if the driver supports ISA
    boards and this is an ISA board, and IS_PCI_BOARD(board) to check if the
    driver supports PCI boards and this is a PCI board.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 7a61831132be..f31d79893457 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -294,6 +294,9 @@ struct dio200_board {
 	enum dio200_layout layout;
 };
 
+#define IS_ISA_BOARD(board)	(DO_ISA && (board)->bustype == isa_bustype)
+#define IS_PCI_BOARD(board)	(DO_PCI && (board)->bustype == pci_bustype)
+
 static const struct dio200_board dio200_boards[] = {
 #if DO_ISA
 	{
@@ -1231,10 +1234,10 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	char tmpbuf[60];
 	int tmplen;
 
-	if (DO_ISA && thisboard->bustype == isa_bustype)
+	if (IS_ISA_BOARD(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(base %#lx) ", dev->iobase);
-	else if (DO_PCI && thisboard->bustype == pci_bustype)
+	else if (IS_PCI_BOARD(thisboard))
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(pci %s) ", pci_name(pcidev));
 	else
@@ -1362,7 +1365,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* Process options and reserve resources according to bus type. */
-	if (DO_ISA && thisboard->bustype == isa_bustype) {
+	if (IS_ISA_BOARD(thisboard)) {
 		unsigned long iobase;
 		unsigned int irq;
 
@@ -1372,7 +1375,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret < 0)
 			return ret;
 		return dio200_common_attach(dev, iobase, irq, 0);
-	} else if (DO_PCI && thisboard->bustype == pci_bustype) {
+	} else if (IS_PCI_BOARD(thisboard)) {
 		struct pci_dev *pci_dev;
 
 		pci_dev = dio200_find_pci_dev(dev, it);

commit b7518888afc14e3d1e988837fef4471cd2b3c820
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 14 16:31:29 2012 +0100

    staging: comedi: amplc_dio200: check bus type in detach routine
    
    When detaching the device in dio200_detach() mirror the bus type checks
    performed by dio200_attach().  The existing tests are safe but rely on
    dev->iobase being 0 when comedi_to_pci_dev(dev) is NULL.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 0905e40de192..7a61831132be 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1417,7 +1417,6 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct dio200_layout_struct *layout;
 	unsigned n;
 
@@ -1442,13 +1441,16 @@ static void dio200_detach(struct comedi_device *dev)
 			}
 		}
 	}
-	if (pcidev) {
-		if (dev->iobase)
-			comedi_pci_disable(pcidev);
-		pci_dev_put(pcidev);
-	} else {
+	if (IS_ISA_BOARD(thisboard)) {
 		if (dev->iobase)
 			release_region(dev->iobase, DIO200_IO_SIZE);
+	} else if (IS_PCI_BOARD(thisboard)) {
+		struct pci_dev *pcidev = comedi_to_pci_dev(dev);
+		if (pcidev) {
+			if (dev->iobase)
+				comedi_pci_disable(pcidev);
+			pci_dev_put(pcidev);
+		}
 	}
 }
 

commit d99ff52ef1da75053de9e42a620930f74615f8ea
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Aug 14 16:31:27 2012 +0100

    staging: comedi: amplc_dio200: abbreviate IS_ENABLED()
    
    The IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) and
    IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) macro calls are a bit
    long-winded.  Define a couple of macros DO_ISA and DO_PCI as
    abbreviations for them.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6c81e377262c..0905e40de192 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -215,6 +215,9 @@ order they appear in the channel list.
 
 #define DIO200_DRIVER_NAME	"amplc_dio200"
 
+#define DO_ISA	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#define DO_PCI	IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
+
 /* PCI IDs */
 #define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
@@ -272,12 +275,12 @@ enum dio200_model {
 };
 
 enum dio200_layout {
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#if DO_ISA
 	pc212_layout,
 	pc214_layout,
 #endif
 	pc215_layout,
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#if DO_ISA
 	pc218_layout,
 #endif
 	pc272_layout
@@ -292,7 +295,7 @@ struct dio200_board {
 };
 
 static const struct dio200_board dio200_boards[] = {
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#if DO_ISA
 	{
 	 .name = "pc212e",
 	 .bustype = isa_bustype,
@@ -324,7 +327,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .layout = pc272_layout,
 	 },
 #endif
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
+#if DO_PCI
 	{
 	 .name = "pci215",
 	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
@@ -367,7 +370,7 @@ struct dio200_layout_struct {
 };
 
 static const struct dio200_layout_struct dio200_layouts[] = {
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#if DO_ISA
 	[pc212_layout] = {
 			  .n_subdevs = 6,
 			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
@@ -396,7 +399,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
 			  },
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
+#if DO_ISA
 	[pc218_layout] = {
 			  .n_subdevs = 7,
 			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
@@ -1228,12 +1231,10 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	char tmpbuf[60];
 	int tmplen;
 
-	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
-	    thisboard->bustype == isa_bustype)
+	if (DO_ISA && thisboard->bustype == isa_bustype)
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(base %#lx) ", dev->iobase);
-	else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
-		 thisboard->bustype == pci_bustype)
+	else if (DO_PCI && thisboard->bustype == pci_bustype)
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
 				   "(pci %s) ", pci_name(pcidev));
 	else
@@ -1361,8 +1362,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	/* Process options and reserve resources according to bus type. */
-	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
-	    thisboard->bustype == isa_bustype) {
+	if (DO_ISA && thisboard->bustype == isa_bustype) {
 		unsigned long iobase;
 		unsigned int irq;
 
@@ -1372,8 +1372,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		if (ret < 0)
 			return ret;
 		return dio200_common_attach(dev, iobase, irq, 0);
-	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
-		   thisboard->bustype == pci_bustype) {
+	} else if (DO_PCI && thisboard->bustype == pci_bustype) {
 		struct pci_dev *pci_dev;
 
 		pci_dev = dio200_find_pci_dev(dev, it);
@@ -1397,7 +1396,7 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 {
 	int ret;
 
-	if (!IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI))
+	if (!DO_PCI)
 		return -EINVAL;
 
 	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
@@ -1470,7 +1469,7 @@ static struct comedi_driver amplc_dio200_driver = {
 	.num_names = ARRAY_SIZE(dio200_boards),
 };
 
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
+#if DO_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },

commit b5e6df11f4820179573637e05c132b4561da92ce
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:37:50 2012 -0700

    staging: comedi: amplc_dio200: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Since the pci_dev is no longer held in the provate data, we can
    also cleanup the detach a bit. Remove the IS_ENABLED() tests in
    the detach. If the pci_dev is non NULL it's a PCI device otherwise
    it's an ISA device. Using IS_ENABLED() to omit the code paths
    makes the code a bit confusing and doesn't save much.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index ca9d4f253c02..6c81e377262c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -424,7 +424,6 @@ static const struct dio200_layout_struct dio200_layouts[] = {
    feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct dio200_private {
-	struct pci_dev *pci_dev;	/* PCI device */
 	int intr_sd;
 };
 
@@ -1225,7 +1224,7 @@ dio200_subdev_8254_cleanup(struct comedi_device *dev,
 static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	char tmpbuf[60];
 	int tmplen;
 
@@ -1236,7 +1235,7 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
 		 thisboard->bustype == pci_bustype)
 		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
-				   "(pci %s) ", pci_name(devpriv->pci_dev));
+				   "(pci %s) ", pci_name(pcidev));
 	else
 		tmplen = 0;
 	if (irq)
@@ -1327,11 +1326,11 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 static int dio200_pci_common_attach(struct comedi_device *dev,
 				    struct pci_dev *pci_dev)
 {
-	struct dio200_private *devpriv = dev->private;
 	unsigned long iobase;
 	int ret;
 
-	devpriv->pci_dev = pci_dev;
+	comedi_set_hw_dev(dev, &pci_dev->dev);
+
 	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 	if (ret < 0) {
 		dev_err(dev->class_dev,
@@ -1419,7 +1418,7 @@ static int __devinit dio200_attach_pci(struct comedi_device *dev,
 static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct dio200_layout_struct *layout;
 	unsigned n;
 
@@ -1444,19 +1443,13 @@ static void dio200_detach(struct comedi_device *dev)
 			}
 		}
 	}
-	if (devpriv) {
-		if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
-		    thisboard->bustype == pci_bustype) {
-			if (devpriv->pci_dev) {
-				if (dev->iobase)
-					comedi_pci_disable(devpriv->pci_dev);
-				pci_dev_put(devpriv->pci_dev);
-			}
-		} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
-			   thisboard->bustype == isa_bustype) {
-			if (dev->iobase)
-				release_region(dev->iobase, DIO200_IO_SIZE);
-		}
+	if (pcidev) {
+		if (dev->iobase)
+			comedi_pci_disable(pcidev);
+		pci_dev_put(pcidev);
+	} else {
+		if (dev->iobase)
+			release_region(dev->iobase, DIO200_IO_SIZE);
 	}
 }
 

commit dd90576838a6f9eb51ffe11796073bdd733847df
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:37:31 2012 -0700

    staging: comedi: amplc_dio200: cleanup "find pci device" code
    
    For aesthetic reasons, rename the function and pass the
    comedi_devconfig struct instead of pre-parsing out the bus/slot
    information.
    
    Use for_each_pci_dev() instead of open-coding the loop using
    pci_get_device().
    
    Consolidate the dev_err messages when a pci device is not found.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 55f30507e9e8..ca9d4f253c02 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -469,23 +469,23 @@ dio200_find_pci_board(struct pci_dev *pci_dev)
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-static struct pci_dev *
-dio200_find_pci(struct comedi_device *dev, int bus, int slot)
+static struct pci_dev *dio200_find_pci_dev(struct comedi_device *dev,
+					   struct comedi_devconfig *it)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
 	struct pci_dev *pci_dev = NULL;
+	int bus = it->options[0];
+	int slot = it->options[1];
 
-	/* Look for matching PCI device. */
-	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-	     pci_dev != NULL;
-	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
-				      PCI_ANY_ID, pci_dev)) {
-		/* If bus/slot specified, check them. */
+	for_each_pci_dev(pci_dev) {
 		if (bus || slot) {
-			if (bus != pci_dev->bus->number
-			    || slot != PCI_SLOT(pci_dev->devfn))
+			if (bus != pci_dev->bus->number ||
+			    slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
+		if (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)
+			continue;
+
 		if (thisboard->model == anypci_model) {
 			/* Wildcard board matches any supported PCI board. */
 			const struct dio200_board *foundboard;
@@ -495,25 +495,16 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot)
 				continue;
 			/* Replace wildcard board_ptr. */
 			dev->board_ptr = foundboard;
-			thisboard = comedi_board(dev);
 		} else {
 			/* Match specific model name. */
 			if (pci_dev->device != thisboard->devid)
 				continue;
 		}
-
-		/* Found a match. */
 		return pci_dev;
 	}
-	/* No match found. */
-	if (bus || slot) {
-		dev_err(dev->class_dev,
-			"error! no %s found at pci %02x:%02x!\n",
-			thisboard->name, bus, slot);
-	} else {
-		dev_err(dev->class_dev, "error! no %s found!\n",
-			thisboard->name);
-	}
+	dev_err(dev->class_dev,
+		"No supported board found! (req. bus %d, slot %d)\n",
+		bus, slot);
 	return NULL;
 }
 
@@ -1385,12 +1376,9 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
 		   thisboard->bustype == pci_bustype) {
 		struct pci_dev *pci_dev;
-		int bus, slot;
 
-		bus = it->options[0];
-		slot = it->options[1];
-		pci_dev = dio200_find_pci(dev, bus, slot);
-		if (pci_dev == NULL)
+		pci_dev = dio200_find_pci_dev(dev, it);
+		if (!pci_dev)
 			return -EIO;
 		return dio200_pci_common_attach(dev, pci_dev);
 	} else {

commit a2714e3e42e746d6c8525c35fdcc58fb60c2830d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 18 13:16:35 2012 -0700

    staging: comedi: fix return value for insn_bits functions
    
    The comedi_subdevice 'insn_bits' functions return the number of data
    elements used to perform the command. Most of the insn_bits functions
    return an open coded '2' to indicate this. The same value is available
    as 'insn->n'. Return that instead to better indicate what the return
    means.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index c67b09ff37d7..55f30507e9e8 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -551,7 +551,7 @@ dio200_subdev_intr_insn_bits(struct comedi_device *dev,
 		data[0] = 0;
 	}
 
-	return 2;
+	return insn->n;
 }
 
 /*

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 17d3489b7f98..c67b09ff37d7 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1273,9 +1273,11 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 	devpriv->intr_sd = -1;
 	dev->iobase = iobase;
 	dev->board_name = thisboard->name;
+
 	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
-	if (ret < 0)
+	if (ret)
 		return ret;
+
 	for (n = 0; n < dev->n_subdevices; n++) {
 		s = &dev->subdevices[n];
 		switch (layout->sdtype[n]) {

commit 0e4039f3112326d73f66b00fd18468a3804ed29e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:58:45 2012 -0700

    staging: comedi: remove the comed_alloc_subdevices "allocation failed" messages
    
    Remove all the "allocation failed" debug messages that are displayed
    when the comedi_alloc_subdevices call fails.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbot <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index d7d056e20c02..17d3489b7f98 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1274,10 +1274,8 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 	dev->iobase = iobase;
 	dev->board_name = thisboard->name;
 	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
+	if (ret < 0)
 		return ret;
-	}
 	for (n = 0; n < dev->n_subdevices; n++) {
 		s = &dev->subdevices[n];
 		switch (layout->sdtype[n]) {

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 3afebb24b26b..d7d056e20c02 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1273,7 +1273,7 @@ static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
 	devpriv->intr_sd = -1;
 	dev->iobase = iobase;
 	dev->board_name = thisboard->name;
-	ret = alloc_subdevices(dev, layout->n_subdevs);
+	ret = comedi_alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;

commit c894ec8da05aa8a58830297d1564675f3e1174cc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:37 2012 +0100

    staging: comedi: amplc_dio200: Add attach_pci() hook
    
    Implement the attach_pci() hook as function dio200_attach_pci().  This
    is called by comedi_pci_auto_config() in preference to the old attach()
    hook (implemented by dio200_attach()) and avoids searching for the
    probed PCI device.
    
    Factor out code common to dio200_find_pci() and dio200_attach_pci() into
    new function dio200_find_pci_board().  Factor out most code common to
    dio200_attach() and dio200_attach_pci() into new functions
    dio200_pci_common_attach() and dio200_common_attach().
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 5b8c6775dbc9..3afebb24b26b 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -450,6 +450,21 @@ struct dio200_subdev_intr {
 	int continuous;
 };
 
+/*
+ * This function looks for a board matching the supplied PCI device.
+ */
+static const struct dio200_board *
+dio200_find_pci_board(struct pci_dev *pci_dev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(dio200_boards); i++)
+		if (dio200_boards[i].bustype == pci_bustype &&
+		    pci_dev->device == dio200_boards[i].devid)
+			return &dio200_boards[i];
+	return NULL;
+}
+
 /*
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
@@ -472,21 +487,15 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot)
 				continue;
 		}
 		if (thisboard->model == anypci_model) {
-			/* Match any supported model. */
-			int i;
-
-			for (i = 0; i < ARRAY_SIZE(dio200_boards); i++) {
-				if (dio200_boards[i].bustype != pci_bustype)
-					continue;
-				if (pci_dev->device == dio200_boards[i].devid) {
-					/* Change board_ptr to matched board. */
-					dev->board_ptr = &dio200_boards[i];
-					thisboard = comedi_board(dev);
-					break;
-				}
-			}
-			if (i == ARRAY_SIZE(dio200_boards))
+			/* Wildcard board matches any supported PCI board. */
+			const struct dio200_board *foundboard;
+
+			foundboard = dio200_find_pci_board(pci_dev);
+			if (foundboard == NULL)
 				continue;
+			/* Replace wildcard board_ptr. */
+			dev->board_ptr = foundboard;
+			thisboard = comedi_board(dev);
 		} else {
 			/* Match specific model name. */
 			if (pci_dev->device != thisboard->devid)
@@ -1249,82 +1258,26 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 	dev_info(dev->class_dev, "%s %sattached\n", dev->board_name, tmpbuf);
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.  If you specified a board_name array
- * in the driver structure, dev->board_ptr contains that
- * address.
- */
-static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int dio200_common_attach(struct comedi_device *dev, unsigned long iobase,
+				unsigned int irq, unsigned long req_irq_flags)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
-	struct dio200_private *devpriv;
+	struct dio200_private *devpriv = dev->private;
+	const struct dio200_layout_struct *layout =
+		&dio200_layouts[thisboard->layout];
 	struct comedi_subdevice *s;
-	unsigned long iobase = 0;
-	unsigned int irq = 0;
-	const struct dio200_layout_struct *layout;
-	int share_irq = 0;
 	int sdx;
-	unsigned n;
+	unsigned int n;
 	int ret;
 
-	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
-
-	ret = alloc_private(dev, sizeof(struct dio200_private));
-	if (ret < 0) {
-		dev_err(dev->class_dev, "error! out of memory!\n");
-		return ret;
-	}
-	devpriv = dev->private;
-
-	/* Process options and reserve resources according to bus type. */
-	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
-	    thisboard->bustype == isa_bustype) {
-		iobase = it->options[0];
-		irq = it->options[1];
-		share_irq = 0;
-		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
-		if (ret < 0)
-			return ret;
-	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
-		   thisboard->bustype == pci_bustype) {
-		struct pci_dev *pci_dev;
-		int bus, slot;
-
-		bus = it->options[0];
-		slot = it->options[1];
-		share_irq = 1;
-		pci_dev = dio200_find_pci(dev, bus, slot);
-		if (pci_dev == NULL)
-			return -EIO;
-		thisboard = comedi_board(dev);	/* replaced wildcard board */
-		devpriv->pci_dev = pci_dev;
-		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
-		if (ret < 0) {
-			dev_err(dev->class_dev,
-				"error! cannot enable PCI device and request regions!\n");
-			return ret;
-		}
-		iobase = pci_resource_start(pci_dev, 2);
-		irq = pci_dev->irq;
-	} else {
-		dev_err(dev->class_dev, DIO200_DRIVER_NAME
-			": BUG! cannot determine board type!\n");
-		return -EINVAL;
-	}
-
 	devpriv->intr_sd = -1;
-
 	dev->iobase = iobase;
-
-	layout = &dio200_layouts[thisboard->layout];
-
+	dev->board_name = thisboard->name;
 	ret = alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
-
 	for (n = 0; n < dev->n_subdevices; n++) {
 		s = &dev->subdevices[n];
 		switch (layout->sdtype[n]) {
@@ -1335,7 +1288,6 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 						      layout->has_clk_gat_sce);
 			if (ret < 0)
 				return ret;
-
 			break;
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
@@ -1343,7 +1295,6 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 					       iobase + layout->sdinfo[n]);
 			if (ret < 0)
 				return ret;
-
 			break;
 		case sd_intr:
 			/* 'INTERRUPT' subdevice */
@@ -1356,7 +1307,6 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 							      has_int_sce);
 				if (ret < 0)
 					return ret;
-
 				devpriv->intr_sd = n;
 			} else {
 				s->type = COMEDI_SUBD_UNUSED;
@@ -1367,17 +1317,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			break;
 		}
 	}
-
 	sdx = devpriv->intr_sd;
 	if (sdx >= 0 && sdx < dev->n_subdevices)
 		dev->read_subdev = &dev->subdevices[sdx];
-
-	dev->board_name = thisboard->name;
-
 	if (irq) {
-		unsigned long flags = share_irq ? IRQF_SHARED : 0;
-
-		if (request_irq(irq, dio200_interrupt, flags,
+		if (request_irq(irq, dio200_interrupt, req_irq_flags,
 				DIO200_DRIVER_NAME, dev) >= 0) {
 			dev->irq = irq;
 		} else {
@@ -1385,11 +1329,105 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				 "warning! irq %u unavailable!\n", irq);
 		}
 	}
-
 	dio200_report_attach(dev, irq);
 	return 1;
 }
 
+static int dio200_pci_common_attach(struct comedi_device *dev,
+				    struct pci_dev *pci_dev)
+{
+	struct dio200_private *devpriv = dev->private;
+	unsigned long iobase;
+	int ret;
+
+	devpriv->pci_dev = pci_dev;
+	ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
+	if (ret < 0) {
+		dev_err(dev->class_dev,
+			"error! cannot enable PCI device and request regions!\n");
+		return ret;
+	}
+	iobase = pci_resource_start(pci_dev, 2);
+	return dio200_common_attach(dev, iobase, pci_dev->irq, IRQF_SHARED);
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+{
+	const struct dio200_board *thisboard = comedi_board(dev);
+	int ret;
+
+	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
+
+	ret = alloc_private(dev, sizeof(struct dio200_private));
+	if (ret < 0) {
+		dev_err(dev->class_dev, "error! out of memory!\n");
+		return ret;
+	}
+
+	/* Process options and reserve resources according to bus type. */
+	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
+	    thisboard->bustype == isa_bustype) {
+		unsigned long iobase;
+		unsigned int irq;
+
+		iobase = it->options[0];
+		irq = it->options[1];
+		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
+		if (ret < 0)
+			return ret;
+		return dio200_common_attach(dev, iobase, irq, 0);
+	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
+		   thisboard->bustype == pci_bustype) {
+		struct pci_dev *pci_dev;
+		int bus, slot;
+
+		bus = it->options[0];
+		slot = it->options[1];
+		pci_dev = dio200_find_pci(dev, bus, slot);
+		if (pci_dev == NULL)
+			return -EIO;
+		return dio200_pci_common_attach(dev, pci_dev);
+	} else {
+		dev_err(dev->class_dev, DIO200_DRIVER_NAME
+			": BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+}
+
+/*
+ * The attach_pci hook (if non-NULL) is called at PCI probe time in preference
+ * to the "manual" attach hook.  dev->board_ptr is NULL on entry.  There should
+ * be a board entry matching the supplied PCI device.
+ */
+static int __devinit dio200_attach_pci(struct comedi_device *dev,
+				       struct pci_dev *pci_dev)
+{
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI))
+		return -EINVAL;
+
+	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach pci %s\n",
+		 pci_name(pci_dev));
+	ret = alloc_private(dev, sizeof(struct dio200_private));
+	if (ret < 0) {
+		dev_err(dev->class_dev, "error! out of memory!\n");
+		return ret;
+	}
+	dev->board_ptr = dio200_find_pci_board(pci_dev);
+	if (dev->board_ptr == NULL) {
+		dev_err(dev->class_dev, "BUG! cannot determine board type!\n");
+		return -EINVAL;
+	}
+	return dio200_pci_common_attach(dev, pci_dev);
+}
+
 static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_board *thisboard = comedi_board(dev);
@@ -1444,6 +1482,7 @@ static struct comedi_driver amplc_dio200_driver = {
 	.driver_name = DIO200_DRIVER_NAME,
 	.module = THIS_MODULE,
 	.attach = dio200_attach,
+	.attach_pci = dio200_attach_pci,
 	.detach = dio200_detach,
 	.board_name = &dio200_boards[0].name,
 	.offset = sizeof(struct dio200_board),

commit adb4601a82343e846997320b41d5b7d49137fe42
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:36 2012 +0100

    staging: comedi: amplc_dio200: Remove thisboard, thislayout and devpriv macros
    
    The 'thisboard', 'thislayout' and 'devpriv' macros rely on a local
    variable having a specific name and yield pointers derived from that
    local variable.  Replace the macros with local variables wherever they
    occur.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6d04378f553f..5b8c6775dbc9 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -419,13 +419,6 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct dio200_board *)dev->board_ptr)
-#define thislayout (&dio200_layouts[((struct dio200_board *) \
-		    dev->board_ptr)->layout])
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.
@@ -435,8 +428,6 @@ struct dio200_private {
 	int intr_sd;
 };
 
-#define devpriv ((struct dio200_private *)dev->private)
-
 struct dio200_subdev_8254 {
 	unsigned long iobase;	/* Counter base address */
 	unsigned long clk_sce_iobase;	/* CLK_SCE base address */
@@ -466,6 +457,7 @@ struct dio200_subdev_intr {
 static struct pci_dev *
 dio200_find_pci(struct comedi_device *dev, int bus, int slot)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
 	struct pci_dev *pci_dev = NULL;
 
 	/* Look for matching PCI device. */
@@ -489,6 +481,7 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot)
 				if (pci_dev->device == dio200_boards[i].devid) {
 					/* Change board_ptr to matched board. */
 					dev->board_ptr = &dio200_boards[i];
+					thisboard = comedi_board(dev);
 					break;
 				}
 			}
@@ -972,6 +965,7 @@ dio200_subdev_intr_cleanup(struct comedi_device *dev,
 static irqreturn_t dio200_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
+	struct dio200_private *devpriv = dev->private;
 	int handled;
 
 	if (!dev->attached)
@@ -1230,6 +1224,8 @@ dio200_subdev_8254_cleanup(struct comedi_device *dev,
 
 static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
 	char tmpbuf[60];
 	int tmplen;
 
@@ -1261,6 +1257,8 @@ static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
  */
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv;
 	struct comedi_subdevice *s;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
@@ -1277,6 +1275,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
+	devpriv = dev->private;
 
 	/* Process options and reserve resources according to bus type. */
 	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
@@ -1298,6 +1297,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		pci_dev = dio200_find_pci(dev, bus, slot);
 		if (pci_dev == NULL)
 			return -EIO;
+		thisboard = comedi_board(dev);	/* replaced wildcard board */
 		devpriv->pci_dev = pci_dev;
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
@@ -1317,7 +1317,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	dev->iobase = iobase;
 
-	layout = thislayout;
+	layout = &dio200_layouts[thisboard->layout];
 
 	ret = alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
@@ -1392,13 +1392,15 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 static void dio200_detach(struct comedi_device *dev)
 {
+	const struct dio200_board *thisboard = comedi_board(dev);
+	struct dio200_private *devpriv = dev->private;
 	const struct dio200_layout_struct *layout;
 	unsigned n;
 
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices) {
-		layout = thislayout;
+		layout = &dio200_layouts[thisboard->layout];
 		for (n = 0; n < dev->n_subdevices; n++) {
 			struct comedi_subdevice *s = &dev->subdevices[n];
 			switch (layout->sdtype[n]) {

commit 181ad5edbf6d3c244263b770e9dd4eda645de5bf
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:35 2012 +0100

    staging: comedi: amplc_dio200: Change return type of dio200_find_pci()
    
    dio200_find_pci() finds a supported PCI device, returning 0 on success
    or -EIO on failure and returning the pointer to the PCI device via a
    struct pci_dev ** parameter.  Change it to return the struct pci_dev *
    on success or NULL on failure.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index be932e88895a..6d04378f553f 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -463,14 +463,11 @@ struct dio200_subdev_intr {
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-static int
-dio200_find_pci(struct comedi_device *dev, int bus, int slot,
-		struct pci_dev **pci_dev_p)
+static struct pci_dev *
+dio200_find_pci(struct comedi_device *dev, int bus, int slot)
 {
 	struct pci_dev *pci_dev = NULL;
 
-	*pci_dev_p = NULL;
-
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
 	     pci_dev != NULL;
@@ -504,8 +501,7 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 		}
 
 		/* Found a match. */
-		*pci_dev_p = pci_dev;
-		return 0;
+		return pci_dev;
 	}
 	/* No match found. */
 	if (bus || slot) {
@@ -516,7 +512,7 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 		dev_err(dev->class_dev, "error! no %s found!\n",
 			thisboard->name);
 	}
-	return -EIO;
+	return NULL;
 }
 
 /*
@@ -1293,15 +1289,15 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			return ret;
 	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
 		   thisboard->bustype == pci_bustype) {
-		struct pci_dev *pci_dev = NULL;
+		struct pci_dev *pci_dev;
 		int bus, slot;
 
 		bus = it->options[0];
 		slot = it->options[1];
 		share_irq = 1;
-		ret = dio200_find_pci(dev, bus, slot, &pci_dev);
-		if (ret < 0)
-			return ret;
+		pci_dev = dio200_find_pci(dev, bus, slot);
+		if (pci_dev == NULL)
+			return -EIO;
 		devpriv->pci_dev = pci_dev;
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {

commit 485455d01b26e849d30c2b20ce20a4d6fc50555e
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:34 2012 +0100

    staging: comedi: amplc_dio200: Replace printk calls
    
    Replace the printk calls with dev_info, dev_err, etc.  There were some
    consecutive printk calls without newlines which now scnprintf into a
    temporary buffer and this bit of code has been factored out into new
    function dio200_report_attach().
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 8b31ab9ce90f..be932e88895a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -509,12 +509,12 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 	}
 	/* No match found. */
 	if (bus || slot) {
-		printk(KERN_ERR
-		       "comedi%d: error! no %s found at pci %02x:%02x!\n",
-		       dev->minor, thisboard->name, bus, slot);
+		dev_err(dev->class_dev,
+			"error! no %s found at pci %02x:%02x!\n",
+			thisboard->name, bus, slot);
 	} else {
-		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-		       dev->minor, thisboard->name);
+		dev_err(dev->class_dev, "error! no %s found!\n",
+			thisboard->name);
 	}
 	return -EIO;
 }
@@ -524,11 +524,12 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
  * if there is a conflict.
  */
 static int
-dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
+dio200_request_region(struct comedi_device *dev,
+		      unsigned long from, unsigned long extent)
 {
 	if (!from || !request_region(from, extent, DIO200_DRIVER_NAME)) {
-		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
-		       minor, from, extent);
+		dev_err(dev->class_dev, "I/O port conflict (%#lx,%lu)!\n",
+			from, extent);
 		return -EIO;
 	}
 	return 0;
@@ -926,8 +927,7 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return -ENOMEM;
 	}
 	subpriv->iobase = iobase;
@@ -1180,8 +1180,7 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return -ENOMEM;
 	}
 
@@ -1233,6 +1232,31 @@ dio200_subdev_8254_cleanup(struct comedi_device *dev,
 	kfree(subpriv);
 }
 
+static void dio200_report_attach(struct comedi_device *dev, unsigned int irq)
+{
+	char tmpbuf[60];
+	int tmplen;
+
+	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
+	    thisboard->bustype == isa_bustype)
+		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
+				   "(base %#lx) ", dev->iobase);
+	else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
+		 thisboard->bustype == pci_bustype)
+		tmplen = scnprintf(tmpbuf, sizeof(tmpbuf),
+				   "(pci %s) ", pci_name(devpriv->pci_dev));
+	else
+		tmplen = 0;
+	if (irq)
+		tmplen += scnprintf(&tmpbuf[tmplen], sizeof(tmpbuf) - tmplen,
+				    "(irq %u%s) ", irq,
+				    (dev->irq ? "" : " UNAVAILABLE"));
+	else
+		tmplen += scnprintf(&tmpbuf[tmplen], sizeof(tmpbuf) - tmplen,
+				    "(no irq) ");
+	dev_info(dev->class_dev, "%s %sattached\n", dev->board_name, tmpbuf);
+}
+
 /*
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.  If you specified a board_name array
@@ -1250,13 +1274,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	unsigned n;
 	int ret;
 
-	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
-	       DIO200_DRIVER_NAME);
+	dev_info(dev->class_dev, DIO200_DRIVER_NAME ": attach\n");
 
 	ret = alloc_private(dev, sizeof(struct dio200_private));
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
@@ -1266,7 +1288,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		iobase = it->options[0];
 		irq = it->options[1];
 		share_irq = 0;
-		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
+		ret = dio200_request_region(dev, iobase, DIO200_IO_SIZE);
 		if (ret < 0)
 			return ret;
 	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
@@ -1283,17 +1305,15 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		devpriv->pci_dev = pci_dev;
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
-			printk(KERN_ERR
-			       "comedi%d: error! cannot enable PCI device and request regions!\n",
-			       dev->minor);
+			dev_err(dev->class_dev,
+				"error! cannot enable PCI device and request regions!\n");
 			return ret;
 		}
 		iobase = pci_resource_start(pci_dev, 2);
 		irq = pci_dev->irq;
 	} else {
-		printk(KERN_ERR
-		       "comedi%d: %s: BUG! cannot determine board type!\n",
-		       dev->minor, DIO200_DRIVER_NAME);
+		dev_err(dev->class_dev, DIO200_DRIVER_NAME
+			": BUG! cannot determine board type!\n");
 		return -EINVAL;
 	}
 
@@ -1305,8 +1325,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	ret = alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
-		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-		       dev->minor);
+		dev_err(dev->class_dev, "error! out of memory!\n");
 		return ret;
 	}
 
@@ -1366,26 +1385,12 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 				DIO200_DRIVER_NAME, dev) >= 0) {
 			dev->irq = irq;
 		} else {
-			printk(KERN_WARNING
-			       "comedi%d: warning! irq %u unavailable!\n",
-			       dev->minor, irq);
+			dev_warn(dev->class_dev,
+				 "warning! irq %u unavailable!\n", irq);
 		}
 	}
 
-	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
-	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
-	    thisboard->bustype == isa_bustype)
-		printk("(base %#lx) ", iobase);
-	else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
-		 thisboard->bustype == pci_bustype)
-		printk("(pci %s) ", pci_name(devpriv->pci_dev));
-	if (irq)
-		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
-	else
-		printk("(no irq) ");
-
-	printk("attached\n");
-
+	dio200_report_attach(dev, irq);
 	return 1;
 }
 

commit fd97962b4142fc3460d3628c3842be6d33b9aa94
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:33 2012 +0100

    staging: comedi: amplc_dio200: Remove forward function declarations
    
    Moved some functions and variables to avoid forward declarations.  Moved
    PCI table closer to the struct pci_driver that refers to it.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 598e51a0cd21..8b31ab9ce90f 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -419,20 +419,6 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  },
 };
 
-/*
- * PCI driver table.
- */
-
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
-static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
-	{0}
-};
-
-MODULE_DEVICE_TABLE(pci, dio200_pci_table);
-#endif /* CONFIG_COMEDI_AMPLC_DIO200_PCI */
-
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -473,49 +459,6 @@ struct dio200_subdev_intr {
 	int continuous;
 };
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int dio200_attach(struct comedi_device *dev,
-			 struct comedi_devconfig *it);
-static void dio200_detach(struct comedi_device *dev);
-static struct comedi_driver amplc_dio200_driver = {
-	.driver_name = DIO200_DRIVER_NAME,
-	.module = THIS_MODULE,
-	.attach = dio200_attach,
-	.detach = dio200_detach,
-	.board_name = &dio200_boards[0].name,
-	.offset = sizeof(struct dio200_board),
-	.num_names = ARRAY_SIZE(dio200_boards),
-};
-
-#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
-static int __devinit amplc_dio200_pci_probe(struct pci_dev *dev,
-						   const struct pci_device_id
-						   *ent)
-{
-	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
-}
-
-static void __devexit amplc_dio200_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
-static struct pci_driver amplc_dio200_pci_driver = {
-	.name = DIO200_DRIVER_NAME,
-	.id_table = dio200_pci_table,
-	.probe = &amplc_dio200_pci_probe,
-	.remove = __devexit_p(&amplc_dio200_pci_remove)
-};
-module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
-#else
-module_comedi_driver(amplc_dio200_driver);
-#endif
-
 /*
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
@@ -1488,6 +1431,54 @@ static void dio200_detach(struct comedi_device *dev)
 	}
 }
 
+/*
+ * The struct comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static struct comedi_driver amplc_dio200_driver = {
+	.driver_name = DIO200_DRIVER_NAME,
+	.module = THIS_MODULE,
+	.attach = dio200_attach,
+	.detach = dio200_detach,
+	.board_name = &dio200_boards[0].name,
+	.offset = sizeof(struct dio200_board),
+	.num_names = ARRAY_SIZE(dio200_boards),
+};
+
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
+static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, dio200_pci_table);
+
+static int __devinit amplc_dio200_pci_probe(struct pci_dev *dev,
+						   const struct pci_device_id
+						   *ent)
+{
+	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
+}
+
+static void __devexit amplc_dio200_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver amplc_dio200_pci_driver = {
+	.name = DIO200_DRIVER_NAME,
+	.id_table = dio200_pci_table,
+	.probe = &amplc_dio200_pci_probe,
+	.remove = __devexit_p(&amplc_dio200_pci_remove)
+};
+module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
+#else
+module_comedi_driver(amplc_dio200_driver);
+#endif
+
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");
 MODULE_LICENSE("GPL");

commit d22e9306c3e119ebc058d5b77306042d6603b231
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:32 2012 +0100

    staging: comedi: amplc_dio200: Use module_comedi_{pci,}_driver()
    
    If PCI boards are supported, use the module_comedi_pci_driver() macro to
    register the module as a comedi driver and a PCI driver.  Otherwise,
    only ISA boards are supported so use the module_comedi_driver() macro to
    register the module as a comedi driver.
    
    Renamed 'driver_amplc_dio200' to 'amplc_dio200_driver' and removed
    'driver_' prefix from PCI related functions and variables, purely for
    aesthetic reasons.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 95d4370bf7af..598e51a0cd21 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -482,7 +482,7 @@ struct dio200_subdev_intr {
 static int dio200_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
 static void dio200_detach(struct comedi_device *dev);
-static struct comedi_driver driver_amplc_dio200 = {
+static struct comedi_driver amplc_dio200_driver = {
 	.driver_name = DIO200_DRIVER_NAME,
 	.module = THIS_MODULE,
 	.attach = dio200_attach,
@@ -493,58 +493,27 @@ static struct comedi_driver driver_amplc_dio200 = {
 };
 
 #if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
-static int __devinit driver_amplc_dio200_pci_probe(struct pci_dev *dev,
+static int __devinit amplc_dio200_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {
-	return comedi_pci_auto_config(dev, &driver_amplc_dio200);
+	return comedi_pci_auto_config(dev, &amplc_dio200_driver);
 }
 
-static void __devexit driver_amplc_dio200_pci_remove(struct pci_dev *dev)
+static void __devexit amplc_dio200_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }
 
-static struct pci_driver driver_amplc_dio200_pci_driver = {
+static struct pci_driver amplc_dio200_pci_driver = {
+	.name = DIO200_DRIVER_NAME,
 	.id_table = dio200_pci_table,
-	.probe = &driver_amplc_dio200_pci_probe,
-	.remove = __devexit_p(&driver_amplc_dio200_pci_remove)
+	.probe = &amplc_dio200_pci_probe,
+	.remove = __devexit_p(&amplc_dio200_pci_remove)
 };
-
-static int __init driver_amplc_dio200_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_amplc_dio200);
-	if (retval < 0)
-		return retval;
-
-	driver_amplc_dio200_pci_driver.name =
-	    (char *)driver_amplc_dio200.driver_name;
-	return pci_register_driver(&driver_amplc_dio200_pci_driver);
-}
-
-static void __exit driver_amplc_dio200_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_amplc_dio200_pci_driver);
-	comedi_driver_unregister(&driver_amplc_dio200);
-}
-
-module_init(driver_amplc_dio200_init_module);
-module_exit(driver_amplc_dio200_cleanup_module);
+module_comedi_pci_driver(amplc_dio200_driver, amplc_dio200_pci_driver);
 #else
-static int __init driver_amplc_dio200_init_module(void)
-{
-	return comedi_driver_register(&driver_amplc_dio200);
-}
-
-static void __exit driver_amplc_dio200_cleanup_module(void)
-{
-	comedi_driver_unregister(&driver_amplc_dio200);
-}
-
-module_init(driver_amplc_dio200_init_module);
-module_exit(driver_amplc_dio200_cleanup_module);
+module_comedi_driver(amplc_dio200_driver);
 #endif
 
 /*

commit a6e11e3b9ffe994f1f2f8ab74ebdc9d1937c16e0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Thu May 31 14:08:31 2012 +0100

    staging: comedi: amplc_dio200: Use IS_ENABLED()
    
    Change conditional compilation on kernel options to use the IS_ENABLED()
    macro.  Remove most of the #ifdef lines and add extra if
    (IS_ENABLED(xxx)) tests so the compiler can remove unreachable code.
    The pci_driver stuff and device table and some of the static const data
    is still conditionally compiled.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f6f6144344b4..95d4370bf7af 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -215,14 +215,6 @@ order they appear in the channel list.
 
 #define DIO200_DRIVER_NAME	"amplc_dio200"
 
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE
-#define CONFIG_COMEDI_AMPLC_DIO200_ISA
-#endif
-
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE
-#define CONFIG_COMEDI_AMPLC_DIO200_PCI
-#endif
-
 /* PCI IDs */
 #define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
@@ -280,12 +272,12 @@ enum dio200_model {
 };
 
 enum dio200_layout {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 	pc212_layout,
 	pc214_layout,
 #endif
 	pc215_layout,
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 	pc218_layout,
 #endif
 	pc272_layout
@@ -300,7 +292,7 @@ struct dio200_board {
 };
 
 static const struct dio200_board dio200_boards[] = {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 	{
 	 .name = "pc212e",
 	 .bustype = isa_bustype,
@@ -332,7 +324,7 @@ static const struct dio200_board dio200_boards[] = {
 	 .layout = pc272_layout,
 	 },
 #endif
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
 	{
 	 .name = "pci215",
 	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
@@ -375,7 +367,7 @@ struct dio200_layout_struct {
 };
 
 static const struct dio200_layout_struct dio200_layouts[] = {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 	[pc212_layout] = {
 			  .n_subdevs = 6,
 			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
@@ -404,7 +396,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
 			  },
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA)
 	[pc218_layout] = {
 			  .n_subdevs = 7,
 			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
@@ -431,7 +423,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
  * PCI driver table.
  */
 
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
@@ -453,9 +445,7 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
    feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct dio200_private {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 	struct pci_dev *pci_dev;	/* PCI device */
-#endif
 	int intr_sd;
 };
 
@@ -502,7 +492,7 @@ static struct comedi_driver driver_amplc_dio200 = {
 	.num_names = ARRAY_SIZE(dio200_boards),
 };
 
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
+#if IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI)
 static int __devinit driver_amplc_dio200_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
@@ -561,7 +551,6 @@ module_exit(driver_amplc_dio200_cleanup_module);
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 static int
 dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 		struct pci_dev **pci_dev_p)
@@ -617,13 +606,11 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 	}
 	return -EIO;
 }
-#endif
 
 /*
  * This function checks and requests an I/O region, reporting an error
  * if there is a conflict.
  */
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 static int
 dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
 {
@@ -634,7 +621,6 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
 	}
 	return 0;
 }
-#endif
 
 /*
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
@@ -1346,10 +1332,6 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
-	struct pci_dev *pci_dev = NULL;
-	int bus = 0, slot = 0;
-#endif
 	const struct dio200_layout_struct *layout;
 	int share_irq = 0;
 	int sdx;
@@ -1366,40 +1348,27 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		return ret;
 	}
 
-	/* Process options. */
-	switch (thisboard->bustype) {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
-	case isa_bustype:
+	/* Process options and reserve resources according to bus type. */
+	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
+	    thisboard->bustype == isa_bustype) {
 		iobase = it->options[0];
 		irq = it->options[1];
 		share_irq = 0;
-		break;
-#endif
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
-	case pci_bustype:
+		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
+		if (ret < 0)
+			return ret;
+	} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
+		   thisboard->bustype == pci_bustype) {
+		struct pci_dev *pci_dev = NULL;
+		int bus, slot;
+
 		bus = it->options[0];
 		slot = it->options[1];
 		share_irq = 1;
-
 		ret = dio200_find_pci(dev, bus, slot, &pci_dev);
 		if (ret < 0)
 			return ret;
 		devpriv->pci_dev = pci_dev;
-		break;
-#endif
-	default:
-		printk(KERN_ERR
-		       "comedi%d: %s: BUG! cannot determine board type!\n",
-		       dev->minor, DIO200_DRIVER_NAME);
-		return -EINVAL;
-		break;
-	}
-
-	devpriv->intr_sd = -1;
-
-	/* Enable device and reserve I/O spaces. */
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
-	if (pci_dev) {
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
 			printk(KERN_ERR
@@ -1409,15 +1378,15 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		}
 		iobase = pci_resource_start(pci_dev, 2);
 		irq = pci_dev->irq;
-	} else
-#endif
-	{
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
-		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
-		if (ret < 0)
-			return ret;
-#endif
+	} else {
+		printk(KERN_ERR
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, DIO200_DRIVER_NAME);
+		return -EINVAL;
 	}
+
+	devpriv->intr_sd = -1;
+
 	dev->iobase = iobase;
 
 	layout = thislayout;
@@ -1492,20 +1461,12 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
-	switch (thisboard->bustype) {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
-	case isa_bustype:
+	if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
+	    thisboard->bustype == isa_bustype)
 		printk("(base %#lx) ", iobase);
-		break;
-#endif
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
-	case pci_bustype:
-		printk("(pci %s) ", pci_name(pci_dev));
-		break;
-#endif
-	default:
-		break;
-	}
+	else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
+		 thisboard->bustype == pci_bustype)
+		printk("(pci %s) ", pci_name(devpriv->pci_dev));
 	if (irq)
 		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
 	else
@@ -1543,18 +1504,17 @@ static void dio200_detach(struct comedi_device *dev)
 		}
 	}
 	if (devpriv) {
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
-		if (devpriv->pci_dev) {
-			if (dev->iobase)
-				comedi_pci_disable(devpriv->pci_dev);
-			pci_dev_put(devpriv->pci_dev);
-		} else
-#endif
-		{
-#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+		if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_PCI) &&
+		    thisboard->bustype == pci_bustype) {
+			if (devpriv->pci_dev) {
+				if (dev->iobase)
+					comedi_pci_disable(devpriv->pci_dev);
+				pci_dev_put(devpriv->pci_dev);
+			}
+		} else if (IS_ENABLED(CONFIG_COMEDI_AMPLC_DIO200_ISA) &&
+			   thisboard->bustype == isa_bustype) {
 			if (dev->iobase)
 				release_region(dev->iobase, DIO200_IO_SIZE);
-#endif
 		}
 	}
 }

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index c9c5d97b3ca2..f6f6144344b4 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -210,8 +210,6 @@ order they appear in the channel list.
 
 #include "../comedidev.h"
 
-#include "comedi_pci.h"
-
 #include "8255.h"
 #include "8253.h"
 

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index cbfa0cd6a1d5..c9c5d97b3ca2 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -493,7 +493,7 @@ struct dio200_subdev_intr {
  */
 static int dio200_attach(struct comedi_device *dev,
 			 struct comedi_devconfig *it);
-static int dio200_detach(struct comedi_device *dev);
+static void dio200_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_dio200 = {
 	.driver_name = DIO200_DRIVER_NAME,
 	.module = THIS_MODULE,
@@ -1518,22 +1518,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	return 1;
 }
 
-/*
- * _detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int dio200_detach(struct comedi_device *dev)
+static void dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_layout_struct *layout;
 	unsigned n;
 
-	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
-	       DIO200_DRIVER_NAME);
-
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices) {
@@ -1570,11 +1559,6 @@ static int dio200_detach(struct comedi_device *dev)
 #endif
 		}
 	}
-	if (dev->board_name)
-		printk(KERN_INFO "comedi%d: %s removed\n",
-		       dev->minor, dev->board_name);
-
-	return 0;
 }
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 7e8828f100d4..cbfa0cd6a1d5 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -509,7 +509,7 @@ static int __devinit driver_amplc_dio200_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
 {
-	return comedi_pci_auto_config(dev, driver_amplc_dio200.driver_name);
+	return comedi_pci_auto_config(dev, &driver_amplc_dio200);
 }
 
 static void __devexit driver_amplc_dio200_pci_remove(struct pci_dev *dev)

commit 8c287d2053c28b838de557ce5319acbd6e4bb627
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Mar 26 16:57:26 2012 +0100

    staging: comedi: amplc_dio200: separately configure ISA and PCI
    
    The amplc_dio200 driver supports both ISA and PCI cards, but currently
    it is only possible to select the driver if PCI is configured.  This
    patch splits the configuration to make the ISA and PCI parts seperately
    selectable, and changes the driver to only include the selected ISA
    and/or PCI board types.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 566cc4411452..7e8828f100d4 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -217,6 +217,14 @@ order they appear in the channel list.
 
 #define DIO200_DRIVER_NAME	"amplc_dio200"
 
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE
+#define CONFIG_COMEDI_AMPLC_DIO200_ISA
+#endif
+
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE
+#define CONFIG_COMEDI_AMPLC_DIO200_PCI
+#endif
+
 /* PCI IDs */
 #define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
@@ -274,10 +282,14 @@ enum dio200_model {
 };
 
 enum dio200_layout {
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	pc212_layout,
 	pc214_layout,
+#endif
 	pc215_layout,
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	pc218_layout,
+#endif
 	pc272_layout
 };
 
@@ -290,6 +302,7 @@ struct dio200_board {
 };
 
 static const struct dio200_board dio200_boards[] = {
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	{
 	 .name = "pc212e",
 	 .bustype = isa_bustype,
@@ -308,15 +321,6 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pc215e_model,
 	 .layout = pc215_layout,
 	 },
-#ifdef CONFIG_COMEDI_PCI
-	{
-	 .name = "pci215",
-	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
-	 .bustype = pci_bustype,
-	 .model = pci215_model,
-	 .layout = pc215_layout,
-	 },
-#endif
 	{
 	 .name = "pc218e",
 	 .bustype = isa_bustype,
@@ -329,7 +333,15 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pc272e_model,
 	 .layout = pc272_layout,
 	 },
-#ifdef CONFIG_COMEDI_PCI
+#endif
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
+	{
+	 .name = "pci215",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
+	 .bustype = pci_bustype,
+	 .model = pci215_model,
+	 .layout = pc215_layout,
+	 },
 	{
 	 .name = "pci272",
 	 .devid = PCI_DEVICE_ID_AMPLICON_PCI272,
@@ -337,8 +349,6 @@ static const struct dio200_board dio200_boards[] = {
 	 .model = pci272_model,
 	 .layout = pc272_layout,
 	 },
-#endif
-#ifdef CONFIG_COMEDI_PCI
 	{
 	 .name = DIO200_DRIVER_NAME,
 	 .devid = PCI_DEVICE_ID_INVALID,
@@ -367,6 +377,7 @@ struct dio200_layout_struct {
 };
 
 static const struct dio200_layout_struct dio200_layouts[] = {
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	[pc212_layout] = {
 			  .n_subdevs = 6,
 			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
@@ -385,6 +396,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  .has_int_sce = 0,
 			  .has_clk_gat_sce = 0,
 			  },
+#endif
 	[pc215_layout] = {
 			  .n_subdevs = 5,
 			  .sdtype = {sd_8255, sd_8255, sd_8254,
@@ -394,6 +406,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
 			  },
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	[pc218_layout] = {
 			  .n_subdevs = 7,
 			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
@@ -405,6 +418,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 			  .has_int_sce = 1,
 			  .has_clk_gat_sce = 1,
 			  },
+#endif
 	[pc272_layout] = {
 			  .n_subdevs = 4,
 			  .sdtype = {sd_8255, sd_8255, sd_8255,
@@ -419,7 +433,7 @@ static const struct dio200_layout_struct dio200_layouts[] = {
  * PCI driver table.
  */
 
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
@@ -427,7 +441,7 @@ static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
 };
 
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);
-#endif /* CONFIG_COMEDI_PCI */
+#endif /* CONFIG_COMEDI_AMPLC_DIO200_PCI */
 
 /*
  * Useful for shorthand access to the particular board structure
@@ -441,7 +455,7 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
    feel free to suggest moving the variable to the struct comedi_device struct.
  */
 struct dio200_private {
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 	struct pci_dev *pci_dev;	/* PCI device */
 #endif
 	int intr_sd;
@@ -490,7 +504,7 @@ static struct comedi_driver driver_amplc_dio200 = {
 	.num_names = ARRAY_SIZE(dio200_boards),
 };
 
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 static int __devinit driver_amplc_dio200_pci_probe(struct pci_dev *dev,
 						   const struct pci_device_id
 						   *ent)
@@ -549,7 +563,7 @@ module_exit(driver_amplc_dio200_cleanup_module);
  * This function looks for a PCI device matching the requested board name,
  * bus and slot.
  */
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 static int
 dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 		struct pci_dev **pci_dev_p)
@@ -611,6 +625,7 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
  * This function checks and requests an I/O region, reporting an error
  * if there is a conflict.
  */
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 static int
 dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
 {
@@ -621,6 +636,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
 	}
 	return 0;
 }
+#endif
 
 /*
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
@@ -1332,7 +1348,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	struct comedi_subdevice *s;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 	struct pci_dev *pci_dev = NULL;
 	int bus = 0, slot = 0;
 #endif
@@ -1354,12 +1370,14 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/* Process options. */
 	switch (thisboard->bustype) {
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 	case isa_bustype:
 		iobase = it->options[0];
 		irq = it->options[1];
 		share_irq = 0;
 		break;
-#ifdef CONFIG_COMEDI_PCI
+#endif
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 	case pci_bustype:
 		bus = it->options[0];
 		slot = it->options[1];
@@ -1382,7 +1400,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	devpriv->intr_sd = -1;
 
 	/* Enable device and reserve I/O spaces. */
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 	if (pci_dev) {
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
@@ -1396,9 +1414,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	} else
 #endif
 	{
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
 		if (ret < 0)
 			return ret;
+#endif
 	}
 	dev->iobase = iobase;
 
@@ -1474,12 +1494,19 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
-	if (thisboard->bustype == isa_bustype) {
+	switch (thisboard->bustype) {
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
+	case isa_bustype:
 		printk("(base %#lx) ", iobase);
-	} else {
-#ifdef CONFIG_COMEDI_PCI
+		break;
+#endif
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
+	case pci_bustype:
 		printk("(pci %s) ", pci_name(pci_dev));
+		break;
 #endif
+	default:
+		break;
 	}
 	if (irq)
 		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
@@ -1529,7 +1556,7 @@ static int dio200_detach(struct comedi_device *dev)
 		}
 	}
 	if (devpriv) {
-#ifdef CONFIG_COMEDI_PCI
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_PCI
 		if (devpriv->pci_dev) {
 			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
@@ -1537,8 +1564,10 @@ static int dio200_detach(struct comedi_device *dev)
 		} else
 #endif
 		{
+#ifdef CONFIG_COMEDI_AMPLC_DIO200_ISA
 			if (dev->iobase)
 				release_region(dev->iobase, DIO200_IO_SIZE);
+#endif
 		}
 	}
 	if (dev->board_name)

commit 7b0be12b26d86ea2bd5079f0d723289e2f5a43a9
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Mon Nov 7 00:54:02 2011 +0100

    staging/comedi/amplc: Convert pci_table entries to PCI_DEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries to use the PCI_DEVICE macro,
    if .subvendor and .subdevice are set to PCI_ANY_ID,
    and thus improves readablity.
    
    Since the driver_data field isn't used anywhere we can also drop the
    assignments for class, class_mask and driver_data.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 93bbe4ec318d..566cc4411452 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -421,12 +421,9 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
-		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
-		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272) },
+	{0}
 };
 
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 674cf1df7e2c..93bbe4ec318d 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -494,7 +494,45 @@ static struct comedi_driver driver_amplc_dio200 = {
 };
 
 #ifdef CONFIG_COMEDI_PCI
-COMEDI_PCI_INITCLEANUP(driver_amplc_dio200, dio200_pci_table);
+static int __devinit driver_amplc_dio200_pci_probe(struct pci_dev *dev,
+						   const struct pci_device_id
+						   *ent)
+{
+	return comedi_pci_auto_config(dev, driver_amplc_dio200.driver_name);
+}
+
+static void __devexit driver_amplc_dio200_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_amplc_dio200_pci_driver = {
+	.id_table = dio200_pci_table,
+	.probe = &driver_amplc_dio200_pci_probe,
+	.remove = __devexit_p(&driver_amplc_dio200_pci_remove)
+};
+
+static int __init driver_amplc_dio200_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_amplc_dio200);
+	if (retval < 0)
+		return retval;
+
+	driver_amplc_dio200_pci_driver.name =
+	    (char *)driver_amplc_dio200.driver_name;
+	return pci_register_driver(&driver_amplc_dio200_pci_driver);
+}
+
+static void __exit driver_amplc_dio200_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_amplc_dio200_pci_driver);
+	comedi_driver_unregister(&driver_amplc_dio200);
+}
+
+module_init(driver_amplc_dio200_init_module);
+module_exit(driver_amplc_dio200_cleanup_module);
 #else
 static int __init driver_amplc_dio200_init_module(void)
 {

commit 7114a28011f9d5f3d981731ad341177c21f9d948
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:30 2010 +0200

    Staging: comedi: Remove COMEDI_INITCLEANUP macro
    
    Move the init/exit routines to the respective C source files
    instead of calling COMEDI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 9a60c214373e..674cf1df7e2c 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -496,7 +496,18 @@ static struct comedi_driver driver_amplc_dio200 = {
 #ifdef CONFIG_COMEDI_PCI
 COMEDI_PCI_INITCLEANUP(driver_amplc_dio200, dio200_pci_table);
 #else
-COMEDI_INITCLEANUP(driver_amplc_dio200);
+static int __init driver_amplc_dio200_init_module(void)
+{
+	return comedi_driver_register(&driver_amplc_dio200);
+}
+
+static void __exit driver_amplc_dio200_cleanup_module(void)
+{
+	comedi_driver_unregister(&driver_amplc_dio200);
+}
+
+module_init(driver_amplc_dio200_init_module);
+module_exit(driver_amplc_dio200_cleanup_module);
 #endif
 
 /*

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index bf27617aa62d..9a60c214373e 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1501,3 +1501,7 @@ static int dio200_detach(struct comedi_device *dev)
 
 	return 0;
 }
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit ee4063fa6bd801fa6ea045f23a2934db009b3dac
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed May 19 16:59:40 2010 +0100

    Staging: comedi: amplc_dio200: Protect counter subdevice with spinlock
    
    The internal state of an 82C54 counter timer chip will get messed up if
    several threads read, write, configure, or check the status of the chip
    simultaneously.  Protect the register access sequences with a spin lock.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 8eb67651486a..bf27617aa62d 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -460,6 +460,7 @@ struct dio200_subdev_8254 {
 	int has_clk_gat_sce;
 	unsigned clock_src[3];	/* Current clock sources */
 	unsigned gate_src[3];	/* Current gate sources */
+	spinlock_t spinlock;
 };
 
 struct dio200_subdev_intr {
@@ -1042,8 +1043,11 @@ dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
+	unsigned long flags;
 
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	data[0] = i8254_read(subpriv->iobase, 0, chan);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
 }
@@ -1057,8 +1061,11 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
+	unsigned long flags;
 
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	i8254_write(subpriv->iobase, 0, chan, data[0]);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 1;
 }
@@ -1151,14 +1158,16 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
-	int ret;
+	int ret = 0;
 	int chan = CR_CHAN(insn->chanspec);
+	unsigned long flags;
 
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	switch (data[0]) {
 	case INSN_CONFIG_SET_COUNTER_MODE:
 		ret = i8254_set_mode(subpriv->iobase, 0, chan, data[1]);
 		if (ret < 0)
-			return -EINVAL;
+			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_8254_READ_STATUS:
 		data[1] = i8254_status(subpriv->iobase, 0, chan);
@@ -1166,30 +1175,35 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
 	case INSN_CONFIG_SET_GATE_SRC:
 		ret = dio200_set_gate_src(subpriv, chan, data[2]);
 		if (ret < 0)
-			return -EINVAL;
+			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_GET_GATE_SRC:
 		ret = dio200_get_gate_src(subpriv, chan);
-		if (ret < 0)
-			return -EINVAL;
+		if (ret < 0) {
+			ret = -EINVAL;
+			break;
+		}
 		data[2] = ret;
 		break;
 	case INSN_CONFIG_SET_CLOCK_SRC:
 		ret = dio200_set_clock_src(subpriv, chan, data[1]);
 		if (ret < 0)
-			return -EINVAL;
+			ret = -EINVAL;
 		break;
 	case INSN_CONFIG_GET_CLOCK_SRC:
 		ret = dio200_get_clock_src(subpriv, chan, &data[2]);
-		if (ret < 0)
-			return -EINVAL;
+		if (ret < 0) {
+			ret = -EINVAL;
+			break;
+		}
 		data[1] = ret;
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
 		break;
 	}
-	return insn->n;
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	return ret < 0 ? ret : insn->n;
 }
 
 /*
@@ -1222,6 +1236,7 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	s->insn_write = dio200_subdev_8254_write;
 	s->insn_config = dio200_subdev_8254_config;
 
+	spin_lock_init(&subpriv->spinlock);
 	subpriv->iobase = offset + iobase;
 	subpriv->has_clk_gat_sce = has_clk_gat_sce;
 	if (has_clk_gat_sce) {

commit a7f22a84ba2e5a99b874bf36a772b5d7424cec11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 4 16:07:43 2010 -0700

    Staging: comedi: amplc_dio200.c: fix NULL sparse warnings
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6a87652e7e2a..8eb67651486a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -661,7 +661,7 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	subpriv = s->private;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	s->async->inttrig = 0;
+	s->async->inttrig = NULL;
 	if (subpriv->active)
 		event = dio200_start_intr(dev, s);
 
@@ -1364,7 +1364,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			break;
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
-			ret = subdev_8255_init(dev, s, 0,
+			ret = subdev_8255_init(dev, s, NULL,
 					       iobase + layout->sdinfo[n]);
 			if (ret < 0)
 				return ret;

commit 6608224c9e5c8aacf88914697be2d5f1fc7a0be6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 30 17:36:52 2010 -0700

    Staging: comedi: remove another vendor id
    
    This id was already in the drivers, so just use it there
    instead of in a common header file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 92bcc205dd4b..6a87652e7e2a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -218,7 +218,7 @@ order they appear in the channel list.
 #define DIO200_DRIVER_NAME	"amplc_dio200"
 
 /* PCI IDs */
-/* #define PCI_VENDOR_ID_AMPLICON 0x14dc */
+#define PCI_VENDOR_ID_AMPLICON 0x14dc
 #define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
 #define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
 #define PCI_DEVICE_ID_INVALID 0xffff

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 204f30ef6e96..92bcc205dd4b 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -206,6 +206,7 @@ order they appear in the channel list.
 */
 
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 
 #include "../comedidev.h"
 

commit 669c930c8fe266917865f923db51c3b654ab78a3
Author: Benjamin Adolphi <b.adolphi@googlemail.com>
Date:   Sun Feb 21 21:44:57 2010 +0100

    Staging: comedi: amplc_dio200: Checkpatch cleanups
    
    This fixes all checkpatch issues in the amplc_dio200 comedi driver.
    
    Signed-off-by: Benjamin Adolphi <b.adolphi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 69ab2813dd2e..204f30ef6e96 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -48,8 +48,8 @@ Passing a zero for an option is the same as leaving it unspecified.
 
 SUBDEVICES
 
-                    PC218E         PC212E      PC215E/PCI215
-                 -------------  -------------  -------------
+		    PC218E         PC212E      PC215E/PCI215
+		 -------------  -------------  -------------
   Subdevices           7              6              5
    0                 CTR-X1         PPI-X          PPI-X
    1                 CTR-X2         CTR-Y1         PPI-Y
@@ -59,8 +59,8 @@ SUBDEVICES
    5                 CTR-Z2       INTERRUPT
    6               INTERRUPT
 
-                    PC214E      PC272E/PCI272
-                 -------------  -------------
+		    PC214E      PC272E/PCI272
+		 -------------  -------------
   Subdevices           4              4
    0                 PPI-X          PPI-X
    1                 PPI-Y          PPI-Y
@@ -96,8 +96,8 @@ instructions are supported:
     0 to 7 as follows:
 
       0.  CLK n, the counter channel's dedicated CLK input from the SK1
-        connector.  (N.B. for other values, the counter channel's CLKn
-        pin on the SK1 connector is an output!)
+	connector.  (N.B. for other values, the counter channel's CLKn
+	pin on the SK1 connector is an output!)
       1.  Internal 10 MHz clock.
       2.  Internal 1 MHz clock.
       3.  Internal 100 kHz clock.
@@ -105,8 +105,8 @@ instructions are supported:
       5.  Internal 1 kHz clock.
       6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
       7.  Ext Clock, the counter chip's dedicated Ext Clock input from
-        the SK1 connector.  This pin is shared by all three counter
-        channels on the chip.
+	the SK1 connector.  This pin is shared by all three counter
+	channels on the chip.
 
   INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
     clock source in data[1].  For internal clock sources, data[2] is set
@@ -120,10 +120,10 @@ instructions are supported:
       0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
       1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
       2.  GAT n, the counter channel's dedicated GAT input from the SK1
-        connector.  (N.B. for other values, the counter channel's GATn
-        pin on the SK1 connector is an output!)
+	connector.  (N.B. for other values, the counter channel's GATn
+	pin on the SK1 connector is an output!)
       3.  /OUT n-2, the inverted output of counter channel n-2 (see note
-        2 below).
+	2 below).
       4.  Reserved.
       5.  Reserved.
       6.  Reserved.
@@ -153,8 +153,8 @@ below.
 
 INTERRUPT SOURCES
 
-                    PC218E         PC212E      PC215E/PCI215
-                 -------------  -------------  -------------
+		    PC218E         PC212E      PC215E/PCI215
+		 -------------  -------------  -------------
   Sources              6              6              6
    0              CTR-X1-OUT      PPI-X-C0       PPI-X-C0
    1              CTR-X2-OUT      PPI-X-C3       PPI-X-C3
@@ -163,8 +163,8 @@ INTERRUPT SOURCES
    4              CTR-Z1-OUT     CTR-Z1-OUT     CTR-Z1-OUT
    5              CTR-Z2-OUT     CTR-Z2-OUT     CTR-Z2-OUT
 
-                    PC214E      PC272E/PCI272
-                 -------------  -------------
+		    PC214E      PC272E/PCI272
+		 -------------  -------------
   Sources              1              6
    0               JUMPER-J5      PPI-X-C0
    1                              PPI-X-C3
@@ -435,11 +435,13 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
  * Useful for shorthand access to the particular board structure
  */
 #define thisboard ((const struct dio200_board *)dev->board_ptr)
-#define thislayout (&dio200_layouts[((struct dio200_board *)dev->board_ptr)->layout])
+#define thislayout (&dio200_layouts[((struct dio200_board *) \
+		    dev->board_ptr)->layout])
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.
+ */
 struct dio200_private {
 #ifdef CONFIG_COMEDI_PCI
 	struct pci_dev *pci_dev;	/* PCI device */
@@ -603,9 +605,8 @@ static void dio200_stop_intr(struct comedi_device *dev,
 
 	subpriv->active = 0;
 	subpriv->enabled_isns = 0;
-	if (subpriv->has_int_sce) {
+	if (subpriv->has_int_sce)
 		outb(0, subpriv->iobase);
-	}
 }
 
 /*
@@ -629,16 +630,14 @@ static int dio200_start_intr(struct comedi_device *dev,
 		/* Determine interrupt sources to enable. */
 		isn_bits = 0;
 		if (cmd->chanlist) {
-			for (n = 0; n < cmd->chanlist_len; n++) {
+			for (n = 0; n < cmd->chanlist_len; n++)
 				isn_bits |= (1U << CR_CHAN(cmd->chanlist[n]));
-			}
 		}
 		isn_bits &= subpriv->valid_isns;
 		/* Enable interrupt sources. */
 		subpriv->enabled_isns = isn_bits;
-		if (subpriv->has_int_sce) {
+		if (subpriv->has_int_sce)
 			outb(isn_bits, subpriv->iobase);
-		}
 	}
 
 	return retval;
@@ -662,14 +661,13 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
 	s->async->inttrig = 0;
-	if (subpriv->active) {
+	if (subpriv->active)
 		event = dio200_start_intr(dev, s);
-	}
+
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 1;
 }
@@ -726,9 +724,8 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 		 * Reenable them NOW to minimize the time they are disabled.
 		 */
 		cur_enabled = subpriv->enabled_isns;
-		if (subpriv->has_int_sce) {
+		if (subpriv->has_int_sce)
 			outb(cur_enabled, subpriv->iobase);
-		}
 
 		if (subpriv->active) {
 			/*
@@ -747,9 +744,8 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 				len = s->async->cmd.chanlist_len;
 				for (n = 0; n < len; n++) {
 					ch = CR_CHAN(s->async->cmd.chanlist[n]);
-					if (triggered & (1U << ch)) {
+					if (triggered & (1U << ch))
 						val |= (1U << n);
-					}
 				}
 				/* Write the scan to the buffer. */
 				if (comedi_buf_put(s->async, val)) {
@@ -781,9 +777,8 @@ static int dio200_handle_read_intr(struct comedi_device *dev,
 	}
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
-	if (oldevents != s->async->events) {
+	if (oldevents != s->async->events)
 		comedi_event(dev, s);
-	}
 
 	return (triggered != 0);
 }
@@ -798,9 +793,9 @@ static int dio200_subdev_intr_cancel(struct comedi_device *dev,
 	unsigned long flags;
 
 	spin_lock_irqsave(&subpriv->spinlock, flags);
-	if (subpriv->active) {
+	if (subpriv->active)
 		dio200_stop_intr(dev, s);
-	}
+
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
@@ -846,7 +841,8 @@ dio200_subdev_intr_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* step 2: make sure trigger sources are unique and mutually
+		   compatible */
 
 	/* these tests are true if more than one _src bit is set */
 	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
@@ -952,9 +948,8 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev,
 	}
 	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
-	if (event) {
+	if (event)
 		comedi_event(dev, s);
-	}
 
 	return 0;
 }
@@ -980,9 +975,8 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	subpriv->valid_isns = valid_isns;
 	spin_lock_init(&subpriv->spinlock);
 
-	if (has_int_sce) {
+	if (has_int_sce)
 		outb(0, subpriv->iobase);	/* Disable interrupt sources. */
-	}
 
 	s->private = subpriv;
 	s->type = COMEDI_SUBD_DI;
@@ -1013,10 +1007,7 @@ dio200_subdev_intr_cleanup(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
-
-	if (subpriv) {
-		kfree(subpriv);
-	}
+	kfree(subpriv);
 }
 
 /*
@@ -1027,9 +1018,8 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	int handled;
 
-	if (!dev->attached) {
+	if (!dev->attached)
 		return IRQ_NONE;
-	}
 
 	if (devpriv->intr_sd >= 0) {
 		handled = dio200_handle_read_intr(dev,
@@ -1266,10 +1256,7 @@ dio200_subdev_8254_cleanup(struct comedi_device *dev,
 			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
-
-	if (subpriv) {
-		kfree(subpriv);
-	}
+	kfree(subpriv);
 }
 
 /*
@@ -1348,9 +1335,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	{
 		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
-		if (ret < 0) {
+		if (ret < 0)
 			return ret;
-		}
 	}
 	dev->iobase = iobase;
 
@@ -1371,17 +1357,17 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			ret = dio200_subdev_8254_init(dev, s, iobase,
 						      layout->sdinfo[n],
 						      layout->has_clk_gat_sce);
-			if (ret < 0) {
+			if (ret < 0)
 				return ret;
-			}
+
 			break;
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
 			ret = subdev_8255_init(dev, s, 0,
 					       iobase + layout->sdinfo[n]);
-			if (ret < 0) {
+			if (ret < 0)
 				return ret;
-			}
+
 			break;
 		case sd_intr:
 			/* 'INTERRUPT' subdevice */
@@ -1392,9 +1378,9 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 							      layout->sdinfo[n],
 							      layout->
 							      has_int_sce);
-				if (ret < 0) {
+				if (ret < 0)
 					return ret;
-				}
+
 				devpriv->intr_sd = n;
 			} else {
 				s->type = COMEDI_SUBD_UNUSED;
@@ -1407,9 +1393,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 
 	sdx = devpriv->intr_sd;
-	if (sdx >= 0 && sdx < dev->n_subdevices) {
+	if (sdx >= 0 && sdx < dev->n_subdevices)
 		dev->read_subdev = &dev->subdevices[sdx];
-	}
 
 	dev->board_name = thisboard->name;
 
@@ -1434,11 +1419,10 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		printk("(pci %s) ", pci_name(pci_dev));
 #endif
 	}
-	if (irq) {
+	if (irq)
 		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
-	} else {
+	else
 		printk("(no irq) ");
-	}
 
 	printk("attached\n");
 
@@ -1461,9 +1445,8 @@ static int dio200_detach(struct comedi_device *dev)
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
 	       DIO200_DRIVER_NAME);
 
-	if (dev->irq) {
+	if (dev->irq)
 		free_irq(dev->irq, dev);
-	}
 	if (dev->subdevices) {
 		layout = thislayout;
 		for (n = 0; n < dev->n_subdevices; n++) {
@@ -1486,22 +1469,19 @@ static int dio200_detach(struct comedi_device *dev)
 	if (devpriv) {
 #ifdef CONFIG_COMEDI_PCI
 		if (devpriv->pci_dev) {
-			if (dev->iobase) {
+			if (dev->iobase)
 				comedi_pci_disable(devpriv->pci_dev);
-			}
 			pci_dev_put(devpriv->pci_dev);
 		} else
 #endif
 		{
-			if (dev->iobase) {
+			if (dev->iobase)
 				release_region(dev->iobase, DIO200_IO_SIZE);
-			}
 		}
 	}
-	if (dev->board_name) {
+	if (dev->board_name)
 		printk(KERN_INFO "comedi%d: %s removed\n",
 		       dev->minor, dev->board_name);
-	}
 
 	return 0;
 }

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 744680059faf..69ab2813dd2e 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -290,60 +290,60 @@ struct dio200_board {
 
 static const struct dio200_board dio200_boards[] = {
 	{
-	.name = "pc212e",
-	.bustype = isa_bustype,
-	.model = pc212e_model,
-	.layout = pc212_layout,
-		},
+	 .name = "pc212e",
+	 .bustype = isa_bustype,
+	 .model = pc212e_model,
+	 .layout = pc212_layout,
+	 },
 	{
-	.name = "pc214e",
-	.bustype = isa_bustype,
-	.model = pc214e_model,
-	.layout = pc214_layout,
-		},
+	 .name = "pc214e",
+	 .bustype = isa_bustype,
+	 .model = pc214e_model,
+	 .layout = pc214_layout,
+	 },
 	{
-	.name = "pc215e",
-	.bustype = isa_bustype,
-	.model = pc215e_model,
-	.layout = pc215_layout,
-		},
+	 .name = "pc215e",
+	 .bustype = isa_bustype,
+	 .model = pc215e_model,
+	 .layout = pc215_layout,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci215",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI215,
-	.bustype = pci_bustype,
-	.model = pci215_model,
-	.layout = pc215_layout,
-		},
+	 .name = "pci215",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI215,
+	 .bustype = pci_bustype,
+	 .model = pci215_model,
+	 .layout = pc215_layout,
+	 },
 #endif
 	{
-	.name = "pc218e",
-	.bustype = isa_bustype,
-	.model = pc218e_model,
-	.layout = pc218_layout,
-		},
+	 .name = "pc218e",
+	 .bustype = isa_bustype,
+	 .model = pc218e_model,
+	 .layout = pc218_layout,
+	 },
 	{
-	.name = "pc272e",
-	.bustype = isa_bustype,
-	.model = pc272e_model,
-	.layout = pc272_layout,
-		},
+	 .name = "pc272e",
+	 .bustype = isa_bustype,
+	 .model = pc272e_model,
+	 .layout = pc272_layout,
+	 },
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = "pci272",
-	.devid = PCI_DEVICE_ID_AMPLICON_PCI272,
-	.bustype = pci_bustype,
-	.model = pci272_model,
-	.layout = pc272_layout,
-		},
+	 .name = "pci272",
+	 .devid = PCI_DEVICE_ID_AMPLICON_PCI272,
+	 .bustype = pci_bustype,
+	 .model = pci272_model,
+	 .layout = pc272_layout,
+	 },
 #endif
 #ifdef CONFIG_COMEDI_PCI
 	{
-	.name = DIO200_DRIVER_NAME,
-	.devid = PCI_DEVICE_ID_INVALID,
-	.bustype = pci_bustype,
-	.model = anypci_model,	/* wildcard */
-		},
+	 .name = DIO200_DRIVER_NAME,
+	 .devid = PCI_DEVICE_ID_INVALID,
+	 .bustype = pci_bustype,
+	 .model = anypci_model,	/* wildcard */
+	 },
 #endif
 };
 
@@ -367,51 +367,51 @@ struct dio200_layout_struct {
 
 static const struct dio200_layout_struct dio200_layouts[] = {
 	[pc212_layout] = {
-	.n_subdevs = 6,
-	.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
-				0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 6,
+			  .sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
+				     0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc214_layout] = {
-	.n_subdevs = 4,
-	.sdtype = {sd_8255, sd_8255, sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x01},
-	.has_int_sce = 0,
-	.has_clk_gat_sce = 0,
-		},
+			  .n_subdevs = 4,
+			  .sdtype = {sd_8255, sd_8255, sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x01},
+			  .has_int_sce = 0,
+			  .has_clk_gat_sce = 0,
+			  },
 	[pc215_layout] = {
-	.n_subdevs = 5,
-	.sdtype = {sd_8255, sd_8255, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 5,
+			  .sdtype = {sd_8255, sd_8255, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc218_layout] = {
-	.n_subdevs = 7,
-	.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
-					sd_8254,
-				sd_intr},
-	.sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
-					0x14,
-				0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 1,
-		},
+			  .n_subdevs = 7,
+			  .sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
+				     sd_8254,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
+				     0x14,
+				     0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 1,
+			  },
 	[pc272_layout] = {
-	.n_subdevs = 4,
-	.sdtype = {sd_8255, sd_8255, sd_8255,
-				sd_intr},
-	.sdinfo = {0x00, 0x08, 0x10, 0x3F},
-	.has_int_sce = 1,
-	.has_clk_gat_sce = 0,
-		},
+			  .n_subdevs = 4,
+			  .sdtype = {sd_8255, sd_8255, sd_8255,
+				     sd_intr},
+			  .sdinfo = {0x00, 0x08, 0x10, 0x3F},
+			  .has_int_sce = 1,
+			  .has_clk_gat_sce = 0,
+			  },
 };
 
 /*
@@ -420,11 +420,12 @@ static const struct dio200_layout_struct dio200_layouts[] = {
 
 #ifdef CONFIG_COMEDI_PCI
 static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
+		    PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, dio200_pci_table);
@@ -475,7 +476,8 @@ struct dio200_subdev_intr {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dio200_attach(struct comedi_device *dev,
+			 struct comedi_devconfig *it);
 static int dio200_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_dio200 = {
 	.driver_name = DIO200_DRIVER_NAME,
@@ -500,7 +502,7 @@ COMEDI_INITCLEANUP(driver_amplc_dio200);
 #ifdef CONFIG_COMEDI_PCI
 static int
 dio200_find_pci(struct comedi_device *dev, int bus, int slot,
-	struct pci_dev **pci_dev_p)
+		struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
 
@@ -508,13 +510,13 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 
 	/* Look for matching PCI device. */
 	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
-		pci_dev != NULL;
-		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
-			PCI_ANY_ID, pci_dev)) {
+	     pci_dev != NULL;
+	     pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
+				      PCI_ANY_ID, pci_dev)) {
 		/* If bus/slot specified, check them. */
 		if (bus || slot) {
 			if (bus != pci_dev->bus->number
-				|| slot != PCI_SLOT(pci_dev->devfn))
+			    || slot != PCI_SLOT(pci_dev->devfn))
 				continue;
 		}
 		if (thisboard->model == anypci_model) {
@@ -545,11 +547,11 @@ dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 	/* No match found. */
 	if (bus || slot) {
 		printk(KERN_ERR
-			"comedi%d: error! no %s found at pci %02x:%02x!\n",
-			dev->minor, thisboard->name, bus, slot);
+		       "comedi%d: error! no %s found at pci %02x:%02x!\n",
+		       dev->minor, thisboard->name, bus, slot);
 	} else {
 		printk(KERN_ERR "comedi%d: error! no %s found!\n",
-			dev->minor, thisboard->name);
+		       dev->minor, thisboard->name);
 	}
 	return -EIO;
 }
@@ -564,7 +566,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
 {
 	if (!from || !request_region(from, extent, DIO200_DRIVER_NAME)) {
 		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
-			minor, from, extent);
+		       minor, from, extent);
 		return -EIO;
 	}
 	return 0;
@@ -574,8 +576,9 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+dio200_subdev_intr_insn_bits(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -593,7 +596,8 @@ dio200_subdev_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice
 /*
  * Called to stop acquisition for an 'INTERRUPT' subdevice.
  */
-static void dio200_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static void dio200_stop_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -607,7 +611,8 @@ static void dio200_stop_intr(struct comedi_device *dev, struct comedi_subdevice
 /*
  * Called to start acquisition for an 'INTERRUPT' subdevice.
  */
-static int dio200_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_start_intr(struct comedi_device *dev,
+			     struct comedi_subdevice *s)
 {
 	unsigned int n;
 	unsigned isn_bits;
@@ -644,7 +649,7 @@ static int dio200_start_intr(struct comedi_device *dev, struct comedi_subdevice
  */
 static int
 dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned int trignum)
+			  unsigned int trignum)
 {
 	struct dio200_subdev_intr *subpriv;
 	unsigned long flags;
@@ -673,7 +678,8 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
  */
-static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_handle_read_intr(struct comedi_device *dev,
+				   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
@@ -699,7 +705,7 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 		 */
 		cur_enabled = subpriv->enabled_isns;
 		while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
-					& ~triggered)) != 0) {
+				   & ~triggered)) != 0) {
 			triggered |= intstat;
 			cur_enabled &= ~triggered;
 			outb(cur_enabled, subpriv->iobase);
@@ -748,12 +754,12 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 				/* Write the scan to the buffer. */
 				if (comedi_buf_put(s->async, val)) {
 					s->async->events |= (COMEDI_CB_BLOCK |
-						COMEDI_CB_EOS);
+							     COMEDI_CB_EOS);
 				} else {
 					/* Error!  Stop acquisition.  */
 					dio200_stop_intr(dev, s);
 					s->async->events |= COMEDI_CB_ERROR
-						| COMEDI_CB_OVERFLOW;
+					    | COMEDI_CB_OVERFLOW;
 					comedi_error(dev, "buffer overflow");
 				}
 
@@ -764,9 +770,9 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 						subpriv->stopcount--;
 						if (subpriv->stopcount == 0) {
 							s->async->events |=
-								COMEDI_CB_EOA;
+							    COMEDI_CB_EOA;
 							dio200_stop_intr(dev,
-								s);
+									 s);
 						}
 					}
 				}
@@ -785,7 +791,8 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 /*
  * 'cancel' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_subdev_intr_cancel(struct comedi_device *dev,
+				     struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
@@ -803,8 +810,8 @@ static int dio200_subdev_intr_cancel(struct comedi_device *dev, struct comedi_su
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+dio200_subdev_intr_cmdtest(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -909,7 +916,8 @@ dio200_subdev_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int dio200_subdev_intr_cmd(struct comedi_device *dev,
+				  struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct dio200_subdev_intr *subpriv = s->private;
@@ -956,14 +964,15 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subde
  */
 static int
 dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long iobase, unsigned valid_isns, int has_int_sce)
+			unsigned long iobase, unsigned valid_isns,
+			int has_int_sce)
 {
 	struct dio200_subdev_intr *subpriv;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return -ENOMEM;
 	}
 	subpriv->iobase = iobase;
@@ -1000,7 +1009,8 @@ dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
  * This function cleans up an 'INTERRUPT' subdevice.
  */
 static void
-dio200_subdev_intr_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
+dio200_subdev_intr_cleanup(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1023,7 +1033,8 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
 
 	if (devpriv->intr_sd >= 0) {
 		handled = dio200_handle_read_intr(dev,
-			dev->subdevices + devpriv->intr_sd);
+						  dev->subdevices +
+						  devpriv->intr_sd);
 	} else {
 		handled = 0;
 	}
@@ -1036,7 +1047,7 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
  */
 static int
 dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1051,7 +1062,7 @@ dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int
 dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			 struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1065,8 +1076,8 @@ dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
  * Set gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int gate_src)
+dio200_set_gate_src(struct dio200_subdev_8254 *subpriv,
+		    unsigned int counter_number, unsigned int gate_src)
 {
 	unsigned char byte;
 
@@ -1088,7 +1099,8 @@ dio200_set_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_num
  * Get gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number)
+dio200_get_gate_src(struct dio200_subdev_8254 *subpriv,
+		    unsigned int counter_number)
 {
 	if (!subpriv->has_clk_gat_sce)
 		return -1;
@@ -1102,8 +1114,8 @@ dio200_get_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_num
  * Set clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int clock_src)
+dio200_set_clock_src(struct dio200_subdev_8254 *subpriv,
+		     unsigned int counter_number, unsigned int clock_src)
 {
 	unsigned char byte;
 
@@ -1125,8 +1137,8 @@ dio200_set_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_nu
  * Get clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
-	unsigned int *period_ns)
+dio200_get_clock_src(struct dio200_subdev_8254 *subpriv,
+		     unsigned int counter_number, unsigned int *period_ns)
 {
 	unsigned clock_src;
 
@@ -1145,7 +1157,7 @@ dio200_get_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_nu
  */
 static int
 dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int ret;
@@ -1197,7 +1209,8 @@ dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
  */
 static int
 dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
-	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
+			unsigned long iobase, unsigned offset,
+			int has_clk_gat_sce)
 {
 	struct dio200_subdev_8254 *subpriv;
 	unsigned int chan;
@@ -1205,7 +1218,7 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return -ENOMEM;
 	}
 
@@ -1224,16 +1237,16 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 		/* Derive CLK_SCE and GAT_SCE register offsets from
 		 * 8254 offset. */
 		subpriv->clk_sce_iobase =
-			DIO200_XCLK_SCE + (offset >> 3) + iobase;
+		    DIO200_XCLK_SCE + (offset >> 3) + iobase;
 		subpriv->gat_sce_iobase =
-			DIO200_XGAT_SCE + (offset >> 3) + iobase;
+		    DIO200_XGAT_SCE + (offset >> 3) + iobase;
 		subpriv->which = (offset >> 2) & 1;
 	}
 
 	/* Initialize channels. */
 	for (chan = 0; chan < 3; chan++) {
 		i8254_set_mode(subpriv->iobase, 0, chan,
-			I8254_MODE0 | I8254_BINARY);
+			       I8254_MODE0 | I8254_BINARY);
 		if (subpriv->has_clk_gat_sce) {
 			/* Gate source 0 is VCC (logic 1). */
 			dio200_set_gate_src(subpriv, chan, 0);
@@ -1249,7 +1262,8 @@ dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
  * This function cleans up an '8254' counter subdevice.
  */
 static void
-dio200_subdev_8254_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
+dio200_subdev_8254_cleanup(struct comedi_device *dev,
+			   struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1280,12 +1294,12 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	int ret;
 
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
-		DIO200_DRIVER_NAME);
+	       DIO200_DRIVER_NAME);
 
 	ret = alloc_private(dev, sizeof(struct dio200_private));
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1310,8 +1324,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 #endif
 	default:
 		printk(KERN_ERR
-			"comedi%d: %s: BUG! cannot determine board type!\n",
-			dev->minor, DIO200_DRIVER_NAME);
+		       "comedi%d: %s: BUG! cannot determine board type!\n",
+		       dev->minor, DIO200_DRIVER_NAME);
 		return -EINVAL;
 		break;
 	}
@@ -1324,8 +1338,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
 		if (ret < 0) {
 			printk(KERN_ERR
-				"comedi%d: error! cannot enable PCI device and request regions!\n",
-				dev->minor);
+			       "comedi%d: error! cannot enable PCI device and request regions!\n",
+			       dev->minor);
 			return ret;
 		}
 		iobase = pci_resource_start(pci_dev, 2);
@@ -1345,7 +1359,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	ret = alloc_subdevices(dev, layout->n_subdevs);
 	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
-			dev->minor);
+		       dev->minor);
 		return ret;
 	}
 
@@ -1355,7 +1369,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		case sd_8254:
 			/* counter subdevice (8254) */
 			ret = dio200_subdev_8254_init(dev, s, iobase,
-				layout->sdinfo[n], layout->has_clk_gat_sce);
+						      layout->sdinfo[n],
+						      layout->has_clk_gat_sce);
 			if (ret < 0) {
 				return ret;
 			}
@@ -1363,7 +1378,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		case sd_8255:
 			/* digital i/o subdevice (8255) */
 			ret = subdev_8255_init(dev, s, 0,
-				iobase + layout->sdinfo[n]);
+					       iobase + layout->sdinfo[n]);
 			if (ret < 0) {
 				return ret;
 			}
@@ -1372,8 +1387,11 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			/* 'INTERRUPT' subdevice */
 			if (irq) {
 				ret = dio200_subdev_intr_init(dev, s,
-					iobase + DIO200_INT_SCE,
-					layout->sdinfo[n], layout->has_int_sce);
+							      iobase +
+							      DIO200_INT_SCE,
+							      layout->sdinfo[n],
+							      layout->
+							      has_int_sce);
 				if (ret < 0) {
 					return ret;
 				}
@@ -1403,8 +1421,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			dev->irq = irq;
 		} else {
 			printk(KERN_WARNING
-				"comedi%d: warning! irq %u unavailable!\n",
-				dev->minor, irq);
+			       "comedi%d: warning! irq %u unavailable!\n",
+			       dev->minor, irq);
 		}
 	}
 
@@ -1441,7 +1459,7 @@ static int dio200_detach(struct comedi_device *dev)
 	unsigned n;
 
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
-		DIO200_DRIVER_NAME);
+	       DIO200_DRIVER_NAME);
 
 	if (dev->irq) {
 		free_irq(dev->irq, dev);
@@ -1482,7 +1500,7 @@ static int dio200_detach(struct comedi_device *dev)
 	}
 	if (dev->board_name) {
 		printk(KERN_INFO "comedi%d: %s removed\n",
-			dev->minor, dev->board_name);
+		       dev->minor, dev->board_name);
 	}
 
 	return 0;

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index ddf58d4866eb..744680059faf 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -655,12 +655,12 @@ dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 
 	subpriv = s->private;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	s->async->inttrig = 0;
 	if (subpriv->active) {
 		event = dio200_start_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -684,7 +684,7 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 
 	triggered = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	oldevents = s->async->events;
 	if (subpriv->has_int_sce) {
 		/*
@@ -773,7 +773,7 @@ static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subd
 			}
 		}
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (oldevents != s->async->events) {
 		comedi_event(dev, s);
@@ -790,11 +790,11 @@ static int dio200_subdev_intr_cancel(struct comedi_device *dev, struct comedi_su
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	if (subpriv->active) {
 		dio200_stop_intr(dev, s);
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	return 0;
 }
@@ -916,7 +916,7 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subde
 	unsigned long flags;
 	int event = 0;
 
-	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	spin_lock_irqsave(&subpriv->spinlock, flags);
 	subpriv->active = 1;
 
 	/* Set up end of acquisition. */
@@ -942,7 +942,7 @@ static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subde
 		event = dio200_start_intr(dev, s);
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+	spin_unlock_irqrestore(&subpriv->spinlock, flags);
 
 	if (event) {
 		comedi_event(dev, s);
@@ -1398,7 +1398,7 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	if (irq) {
 		unsigned long flags = share_irq ? IRQF_SHARED : 0;
 
-		if (comedi_request_irq(irq, dio200_interrupt, flags,
+		if (request_irq(irq, dio200_interrupt, flags,
 				DIO200_DRIVER_NAME, dev) >= 0) {
 			dev->irq = irq;
 		} else {
@@ -1444,7 +1444,7 @@ static int dio200_detach(struct comedi_device *dev)
 		DIO200_DRIVER_NAME);
 
 	if (dev->irq) {
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	}
 	if (dev->subdevices) {
 		layout = thislayout;

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 582d6a2cfef6..ddf58d4866eb 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -484,7 +484,7 @@ static struct comedi_driver driver_amplc_dio200 = {
 	.detach = dio200_detach,
 	.board_name = &dio200_boards[0].name,
 	.offset = sizeof(struct dio200_board),
-	.num_names = sizeof(dio200_boards) / sizeof(struct dio200_board),
+	.num_names = ARRAY_SIZE(dio200_boards),
 };
 
 #ifdef CONFIG_COMEDI_PCI

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 7c323e242835..582d6a2cfef6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -290,59 +290,59 @@ struct dio200_board {
 
 static const struct dio200_board dio200_boards[] = {
 	{
-	      name:	"pc212e",
-	      bustype:	isa_bustype,
-	      model:	pc212e_model,
-	      layout:	pc212_layout,
+	.name = "pc212e",
+	.bustype = isa_bustype,
+	.model = pc212e_model,
+	.layout = pc212_layout,
 		},
 	{
-	      name:	"pc214e",
-	      bustype:	isa_bustype,
-	      model:	pc214e_model,
-	      layout:	pc214_layout,
+	.name = "pc214e",
+	.bustype = isa_bustype,
+	.model = pc214e_model,
+	.layout = pc214_layout,
 		},
 	{
-	      name:	"pc215e",
-	      bustype:	isa_bustype,
-	      model:	pc215e_model,
-	      layout:	pc215_layout,
+	.name = "pc215e",
+	.bustype = isa_bustype,
+	.model = pc215e_model,
+	.layout = pc215_layout,
 		},
 #ifdef CONFIG_COMEDI_PCI
 	{
-	      name:	"pci215",
-	      devid:	PCI_DEVICE_ID_AMPLICON_PCI215,
-	      bustype:	pci_bustype,
-	      model:	pci215_model,
-	      layout:	pc215_layout,
+	.name = "pci215",
+	.devid = PCI_DEVICE_ID_AMPLICON_PCI215,
+	.bustype = pci_bustype,
+	.model = pci215_model,
+	.layout = pc215_layout,
 		},
 #endif
 	{
-	      name:	"pc218e",
-	      bustype:	isa_bustype,
-	      model:	pc218e_model,
-	      layout:	pc218_layout,
+	.name = "pc218e",
+	.bustype = isa_bustype,
+	.model = pc218e_model,
+	.layout = pc218_layout,
 		},
 	{
-	      name:	"pc272e",
-	      bustype:	isa_bustype,
-	      model:	pc272e_model,
-	      layout:	pc272_layout,
+	.name = "pc272e",
+	.bustype = isa_bustype,
+	.model = pc272e_model,
+	.layout = pc272_layout,
 		},
 #ifdef CONFIG_COMEDI_PCI
 	{
-	      name:	"pci272",
-	      devid:	PCI_DEVICE_ID_AMPLICON_PCI272,
-	      bustype:	pci_bustype,
-	      model:	pci272_model,
-	      layout:	pc272_layout,
+	.name = "pci272",
+	.devid = PCI_DEVICE_ID_AMPLICON_PCI272,
+	.bustype = pci_bustype,
+	.model = pci272_model,
+	.layout = pc272_layout,
 		},
 #endif
 #ifdef CONFIG_COMEDI_PCI
 	{
-	      name:	DIO200_DRIVER_NAME,
-	      devid:	PCI_DEVICE_ID_INVALID,
-	      bustype:	pci_bustype,
-	      model:	anypci_model,	/* wildcard */
+	.name = DIO200_DRIVER_NAME,
+	.devid = PCI_DEVICE_ID_INVALID,
+	.bustype = pci_bustype,
+	.model = anypci_model,	/* wildcard */
 		},
 #endif
 };
@@ -367,50 +367,50 @@ struct dio200_layout_struct {
 
 static const struct dio200_layout_struct dio200_layouts[] = {
 	[pc212_layout] = {
-	      n_subdevs:6,
-	      sdtype:	{sd_8255, sd_8254, sd_8254, sd_8254,
+	.n_subdevs = 6,
+	.sdtype = {sd_8255, sd_8254, sd_8254, sd_8254,
 					sd_8254,
 				sd_intr},
-	      sdinfo:	{0x00, 0x08, 0x0C, 0x10, 0x14,
+	.sdinfo = {0x00, 0x08, 0x0C, 0x10, 0x14,
 				0x3F},
-	      has_int_sce:1,
-	      has_clk_gat_sce:1,
+	.has_int_sce = 1,
+	.has_clk_gat_sce = 1,
 		},
 	[pc214_layout] = {
-	      n_subdevs:4,
-	      sdtype:	{sd_8255, sd_8255, sd_8254,
+	.n_subdevs = 4,
+	.sdtype = {sd_8255, sd_8255, sd_8254,
 				sd_intr},
-	      sdinfo:	{0x00, 0x08, 0x10, 0x01},
-	      has_int_sce:0,
-	      has_clk_gat_sce:0,
+	.sdinfo = {0x00, 0x08, 0x10, 0x01},
+	.has_int_sce = 0,
+	.has_clk_gat_sce = 0,
 		},
 	[pc215_layout] = {
-	      n_subdevs:5,
-	      sdtype:	{sd_8255, sd_8255, sd_8254,
+	.n_subdevs = 5,
+	.sdtype = {sd_8255, sd_8255, sd_8254,
 					sd_8254,
 				sd_intr},
-	      sdinfo:	{0x00, 0x08, 0x10, 0x14, 0x3F},
-	      has_int_sce:1,
-	      has_clk_gat_sce:1,
+	.sdinfo = {0x00, 0x08, 0x10, 0x14, 0x3F},
+	.has_int_sce = 1,
+	.has_clk_gat_sce = 1,
 		},
 	[pc218_layout] = {
-	      n_subdevs:7,
-	      sdtype:	{sd_8254, sd_8254, sd_8255, sd_8254,
+	.n_subdevs = 7,
+	.sdtype = {sd_8254, sd_8254, sd_8255, sd_8254,
 					sd_8254,
 				sd_intr},
-	      sdinfo:	{0x00, 0x04, 0x08, 0x0C, 0x10,
+	.sdinfo = {0x00, 0x04, 0x08, 0x0C, 0x10,
 					0x14,
 				0x3F},
-	      has_int_sce:1,
-	      has_clk_gat_sce:1,
+	.has_int_sce = 1,
+	.has_clk_gat_sce = 1,
 		},
 	[pc272_layout] = {
-	      n_subdevs:4,
-	      sdtype:	{sd_8255, sd_8255, sd_8255,
+	.n_subdevs = 4,
+	.sdtype = {sd_8255, sd_8255, sd_8255,
 				sd_intr},
-	      sdinfo:	{0x00, 0x08, 0x10, 0x3F},
-	      has_int_sce:1,
-	      has_clk_gat_sce:0,
+	.sdinfo = {0x00, 0x08, 0x10, 0x3F},
+	.has_int_sce = 1,
+	.has_clk_gat_sce = 0,
 		},
 };
 
@@ -478,13 +478,13 @@ struct dio200_subdev_intr {
 static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int dio200_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_dio200 = {
-      driver_name:DIO200_DRIVER_NAME,
-      module:THIS_MODULE,
-      attach:dio200_attach,
-      detach:dio200_detach,
-      board_name:&dio200_boards[0].name,
-      offset:sizeof(struct dio200_board),
-      num_names:sizeof(dio200_boards) / sizeof(struct dio200_board),
+	.driver_name = DIO200_DRIVER_NAME,
+	.module = THIS_MODULE,
+	.attach = dio200_attach,
+	.detach = dio200_detach,
+	.board_name = &dio200_boards[0].name,
+	.offset = sizeof(struct dio200_board),
+	.num_names = sizeof(dio200_boards) / sizeof(struct dio200_board),
 };
 
 #ifdef CONFIG_COMEDI_PCI

commit c3744138715045adb316284ee7a1e608f0278f6c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:47 2009 -0400

    Staging: comedi: remove assignment in conditionals
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 563fb0ba06e8..7c323e242835 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -1282,7 +1282,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
 		DIO200_DRIVER_NAME);
 
-	if ((ret = alloc_private(dev, sizeof(struct dio200_private))) < 0) {
+	ret = alloc_private(dev, sizeof(struct dio200_private));
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;
@@ -1301,7 +1302,8 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		slot = it->options[1];
 		share_irq = 1;
 
-		if ((ret = dio200_find_pci(dev, bus, slot, &pci_dev)) < 0)
+		ret = dio200_find_pci(dev, bus, slot, &pci_dev);
+		if (ret < 0)
 			return ret;
 		devpriv->pci_dev = pci_dev;
 		break;
@@ -1339,7 +1341,9 @@ static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	dev->iobase = iobase;
 
 	layout = thislayout;
-	if ((ret = alloc_subdevices(dev, layout->n_subdevs)) < 0) {
+
+	ret = alloc_subdevices(dev, layout->n_subdevs);
+	if (ret < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 771e88ca873d..563fb0ba06e8 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -475,8 +475,8 @@ struct dio200_subdev_intr {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int dio200_detach(struct comedi_device * dev);
+static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int dio200_detach(struct comedi_device *dev);
 static struct comedi_driver driver_amplc_dio200 = {
       driver_name:DIO200_DRIVER_NAME,
       module:THIS_MODULE,
@@ -499,7 +499,7 @@ COMEDI_INITCLEANUP(driver_amplc_dio200);
  */
 #ifdef CONFIG_COMEDI_PCI
 static int
-dio200_find_pci(struct comedi_device * dev, int bus, int slot,
+dio200_find_pci(struct comedi_device *dev, int bus, int slot,
 	struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
@@ -574,8 +574,8 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+dio200_subdev_intr_insn_bits(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -593,7 +593,7 @@ dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice
 /*
  * Called to stop acquisition for an 'INTERRUPT' subdevice.
  */
-static void dio200_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static void dio200_stop_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -607,7 +607,7 @@ static void dio200_stop_intr(struct comedi_device * dev, struct comedi_subdevice
 /*
  * Called to start acquisition for an 'INTERRUPT' subdevice.
  */
-static int dio200_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dio200_start_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned int n;
 	unsigned isn_bits;
@@ -643,7 +643,7 @@ static int dio200_start_intr(struct comedi_device * dev, struct comedi_subdevice
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
+dio200_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned int trignum)
 {
 	struct dio200_subdev_intr *subpriv;
@@ -673,7 +673,7 @@ dio200_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
  */
-static int dio200_handle_read_intr(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dio200_handle_read_intr(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
@@ -785,7 +785,7 @@ static int dio200_handle_read_intr(struct comedi_device * dev, struct comedi_sub
 /*
  * 'cancel' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dio200_subdev_intr_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
@@ -803,8 +803,8 @@ static int dio200_subdev_intr_cancel(struct comedi_device * dev, struct comedi_s
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+dio200_subdev_intr_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -909,7 +909,7 @@ dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int dio200_subdev_intr_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
 	struct dio200_subdev_intr *subpriv = s->private;
@@ -955,7 +955,7 @@ static int dio200_subdev_intr_cmd(struct comedi_device * dev, struct comedi_subd
  * This function initializes an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_init(struct comedi_device * dev, struct comedi_subdevice * s,
+dio200_subdev_intr_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long iobase, unsigned valid_isns, int has_int_sce)
 {
 	struct dio200_subdev_intr *subpriv;
@@ -1000,7 +1000,7 @@ dio200_subdev_intr_init(struct comedi_device * dev, struct comedi_subdevice * s,
  * This function cleans up an 'INTERRUPT' subdevice.
  */
 static void
-dio200_subdev_intr_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
+dio200_subdev_intr_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1035,8 +1035,8 @@ static irqreturn_t dio200_interrupt(int irq, void *d)
  * Handle 'insn_read' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+dio200_subdev_8254_read(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1050,8 +1050,8 @@ dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
  * Handle 'insn_write' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+dio200_subdev_8254_write(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1065,7 +1065,7 @@ dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s
  * Set gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
+dio200_set_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
 	unsigned int gate_src)
 {
 	unsigned char byte;
@@ -1088,7 +1088,7 @@ dio200_set_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_nu
  * Get gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number)
+dio200_get_gate_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number)
 {
 	if (!subpriv->has_clk_gat_sce)
 		return -1;
@@ -1102,7 +1102,7 @@ dio200_get_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_nu
  * Set clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
+dio200_set_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
 	unsigned int clock_src)
 {
 	unsigned char byte;
@@ -1125,8 +1125,8 @@ dio200_set_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_n
  * Get clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
-	unsigned int * period_ns)
+dio200_get_clock_src(struct dio200_subdev_8254 *subpriv, unsigned int counter_number,
+	unsigned int *period_ns)
 {
 	unsigned clock_src;
 
@@ -1144,8 +1144,8 @@ dio200_get_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_n
  * Handle 'insn_config' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+dio200_subdev_8254_config(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	struct dio200_subdev_8254 *subpriv = s->private;
 	int ret;
@@ -1196,7 +1196,7 @@ dio200_subdev_8254_config(struct comedi_device * dev, struct comedi_subdevice *
  * offset is the offset to the 8254 chip.
  */
 static int
-dio200_subdev_8254_init(struct comedi_device * dev, struct comedi_subdevice * s,
+dio200_subdev_8254_init(struct comedi_device *dev, struct comedi_subdevice *s,
 	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
 {
 	struct dio200_subdev_8254 *subpriv;
@@ -1249,7 +1249,7 @@ dio200_subdev_8254_init(struct comedi_device * dev, struct comedi_subdevice * s,
  * This function cleans up an '8254' counter subdevice.
  */
 static void
-dio200_subdev_8254_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
+dio200_subdev_8254_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct dio200_subdev_intr *subpriv = s->private;
 
@@ -1264,7 +1264,7 @@ dio200_subdev_8254_cleanup(struct comedi_device * dev, struct comedi_subdevice *
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int dio200_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = 0;
@@ -1431,7 +1431,7 @@ static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * i
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int dio200_detach(struct comedi_device * dev)
+static int dio200_detach(struct comedi_device *dev)
 {
 	const struct dio200_layout_struct *layout;
 	unsigned n;

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 8555e272a861..771e88ca873d 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -205,6 +205,8 @@ is packed into a short value, one bit per requested channel, in the
 order they appear in the channel list.
 */
 
+#include <linux/interrupt.h>
+
 #include "../comedidev.h"
 
 #include "comedi_pci.h"
@@ -1010,7 +1012,7 @@ dio200_subdev_intr_cleanup(struct comedi_device * dev, struct comedi_subdevice *
 /*
  * Interrupt service routine.
  */
-static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t dio200_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	int handled;

commit d9752ee071117f32495da04d3cc9cb4453b5a46e
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:45 2009 -0400

    Staging: comedi: Remove dio200_subdev_intr typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index e8faf2b61a05..8555e272a861 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -456,7 +456,7 @@ struct dio200_subdev_8254 {
 	unsigned gate_src[3];	/* Current gate sources */
 };
 
-typedef struct {
+struct dio200_subdev_intr {
 	unsigned long iobase;
 	spinlock_t spinlock;
 	int active;
@@ -465,7 +465,7 @@ typedef struct {
 	unsigned int enabled_isns;
 	unsigned int stopcount;
 	int continuous;
-} dio200_subdev_intr;
+};
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -575,7 +575,7 @@ static int
 dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 
 	if (subpriv->has_int_sce) {
 		/* Just read the interrupt status register.  */
@@ -593,7 +593,7 @@ dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice
  */
 static void dio200_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 
 	subpriv->active = 0;
 	subpriv->enabled_isns = 0;
@@ -609,7 +609,7 @@ static int dio200_start_intr(struct comedi_device * dev, struct comedi_subdevice
 {
 	unsigned int n;
 	unsigned isn_bits;
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval = 0;
 
@@ -644,7 +644,7 @@ static int
 dio200_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
-	dio200_subdev_intr *subpriv;
+	struct dio200_subdev_intr *subpriv;
 	unsigned long flags;
 	int event = 0;
 
@@ -673,7 +673,7 @@ dio200_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice *
  */
 static int dio200_handle_read_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
 	unsigned intstat;
 	unsigned cur_enabled;
@@ -785,7 +785,7 @@ static int dio200_handle_read_intr(struct comedi_device * dev, struct comedi_sub
  */
 static int dio200_subdev_intr_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
@@ -910,7 +910,7 @@ dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
 static int dio200_subdev_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_cmd *cmd = &s->async->cmd;
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
 	int event = 0;
 
@@ -956,7 +956,7 @@ static int
 dio200_subdev_intr_init(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned long iobase, unsigned valid_isns, int has_int_sce)
 {
-	dio200_subdev_intr *subpriv;
+	struct dio200_subdev_intr *subpriv;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
 	if (!subpriv) {
@@ -1000,7 +1000,7 @@ dio200_subdev_intr_init(struct comedi_device * dev, struct comedi_subdevice * s,
 static void
 dio200_subdev_intr_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 
 	if (subpriv) {
 		kfree(subpriv);
@@ -1249,7 +1249,7 @@ dio200_subdev_8254_init(struct comedi_device * dev, struct comedi_subdevice * s,
 static void
 dio200_subdev_8254_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	dio200_subdev_intr *subpriv = s->private;
+	struct dio200_subdev_intr *subpriv = s->private;
 
 	if (subpriv) {
 		kfree(subpriv);

commit 93ba42e9093718729291dd6332d92a99f041eb78
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:39 2009 -0400

    Staging: comedi: Remove dio200_subdev_8254 typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index dad65e40095b..e8faf2b61a05 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -446,7 +446,7 @@ struct dio200_private {
 
 #define devpriv ((struct dio200_private *)dev->private)
 
-typedef struct {
+struct dio200_subdev_8254 {
 	unsigned long iobase;	/* Counter base address */
 	unsigned long clk_sce_iobase;	/* CLK_SCE base address */
 	unsigned long gat_sce_iobase;	/* GAT_SCE base address */
@@ -454,7 +454,7 @@ typedef struct {
 	int has_clk_gat_sce;
 	unsigned clock_src[3];	/* Current clock sources */
 	unsigned gate_src[3];	/* Current gate sources */
-} dio200_subdev_8254;
+};
 
 typedef struct {
 	unsigned long iobase;
@@ -1036,7 +1036,7 @@ static int
 dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	dio200_subdev_8254 *subpriv = s->private;
+	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
 
 	data[0] = i8254_read(subpriv->iobase, 0, chan);
@@ -1051,7 +1051,7 @@ static int
 dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	dio200_subdev_8254 *subpriv = s->private;
+	struct dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
 
 	i8254_write(subpriv->iobase, 0, chan, data[0]);
@@ -1063,7 +1063,7 @@ dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s
  * Set gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+dio200_set_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
 	unsigned int gate_src)
 {
 	unsigned char byte;
@@ -1086,7 +1086,7 @@ dio200_set_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  * Get gate source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number)
+dio200_get_gate_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number)
 {
 	if (!subpriv->has_clk_gat_sce)
 		return -1;
@@ -1100,7 +1100,7 @@ dio200_get_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number)
  * Set clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_set_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+dio200_set_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
 	unsigned int clock_src)
 {
 	unsigned char byte;
@@ -1123,7 +1123,7 @@ dio200_set_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  * Get clock source for an '8254' counter subdevice channel.
  */
 static int
-dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+dio200_get_clock_src(struct dio200_subdev_8254 * subpriv, unsigned int counter_number,
 	unsigned int * period_ns)
 {
 	unsigned clock_src;
@@ -1145,7 +1145,7 @@ static int
 dio200_subdev_8254_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
-	dio200_subdev_8254 *subpriv = s->private;
+	struct dio200_subdev_8254 *subpriv = s->private;
 	int ret;
 	int chan = CR_CHAN(insn->chanspec);
 
@@ -1197,7 +1197,7 @@ static int
 dio200_subdev_8254_init(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
 {
-	dio200_subdev_8254 *subpriv;
+	struct dio200_subdev_8254 *subpriv;
 	unsigned int chan;
 
 	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);

commit 692560db4187c5c5e906f95c287d75e1b96e4846
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:34 2009 -0400

    Staging: comedi: Remove dio200_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 7ad70ae47404..dad65e40095b 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -437,14 +437,14 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct dio200_private {
 #ifdef CONFIG_COMEDI_PCI
 	struct pci_dev *pci_dev;	/* PCI device */
 #endif
 	int intr_sd;
-} dio200_private;
+};
 
-#define devpriv ((dio200_private *)dev->private)
+#define devpriv ((struct dio200_private *)dev->private)
 
 typedef struct {
 	unsigned long iobase;	/* Counter base address */
@@ -1280,7 +1280,7 @@ static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
 		DIO200_DRIVER_NAME);
 
-	if ((ret = alloc_private(dev, sizeof(dio200_private))) < 0) {
+	if ((ret = alloc_private(dev, sizeof(struct dio200_private))) < 0) {
 		printk(KERN_ERR "comedi%d: error! out of memory!\n",
 			dev->minor);
 		return ret;

commit af105ad3f57421a36dd60c8f54edcebc7a09256b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:29 2009 -0400

    Staging: comedi: Remove dio200_layout typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 2a46e7eb59f6..7ad70ae47404 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -355,15 +355,15 @@ enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254 };
 #define DIO200_MAX_SUBDEVS	7
 #define DIO200_MAX_ISNS		6
 
-typedef struct dio200_layout_struct {
+struct dio200_layout_struct {
 	unsigned short n_subdevs;	/* number of subdevices */
 	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
 	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
 	char has_int_sce;	/* has interrupt enable/status register */
 	char has_clk_gat_sce;	/* has clock/gate selection registers */
-} dio200_layout;
+};
 
-static const dio200_layout dio200_layouts[] = {
+static const struct dio200_layout_struct dio200_layouts[] = {
 	[pc212_layout] = {
 	      n_subdevs:6,
 	      sdtype:	{sd_8255, sd_8254, sd_8254, sd_8254,
@@ -1271,7 +1271,7 @@ static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	struct pci_dev *pci_dev = NULL;
 	int bus = 0, slot = 0;
 #endif
-	const dio200_layout *layout;
+	const struct dio200_layout_struct *layout;
 	int share_irq = 0;
 	int sdx;
 	unsigned n;
@@ -1431,7 +1431,7 @@ static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * i
  */
 static int dio200_detach(struct comedi_device * dev)
 {
-	const dio200_layout *layout;
+	const struct dio200_layout_struct *layout;
 	unsigned n;
 
 	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,

commit 3d7a42ef60e93352b49c5da7cba00f20ce255afc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:09:23 2009 -0400

    Staging: comedi: Remove dio200_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f5f20edddae0..2a46e7eb59f6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -278,15 +278,15 @@ enum dio200_layout {
 	pc272_layout
 };
 
-typedef struct dio200_board_struct {
+struct dio200_board {
 	const char *name;
 	unsigned short devid;
 	enum dio200_bustype bustype;
 	enum dio200_model model;
 	enum dio200_layout layout;
-} dio200_board;
+};
 
-static const dio200_board dio200_boards[] = {
+static const struct dio200_board dio200_boards[] = {
 	{
 	      name:	"pc212e",
 	      bustype:	isa_bustype,
@@ -431,8 +431,8 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const dio200_board *)dev->board_ptr)
-#define thislayout (&dio200_layouts[((dio200_board *)dev->board_ptr)->layout])
+#define thisboard ((const struct dio200_board *)dev->board_ptr)
+#define thislayout (&dio200_layouts[((struct dio200_board *)dev->board_ptr)->layout])
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
@@ -481,8 +481,8 @@ static struct comedi_driver driver_amplc_dio200 = {
       attach:dio200_attach,
       detach:dio200_detach,
       board_name:&dio200_boards[0].name,
-      offset:sizeof(dio200_board),
-      num_names:sizeof(dio200_boards) / sizeof(dio200_board),
+      offset:sizeof(struct dio200_board),
+      num_names:sizeof(dio200_boards) / sizeof(struct dio200_board),
 };
 
 #ifdef CONFIG_COMEDI_PCI

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 88c127566b8a..f5f20edddae0 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -473,7 +473,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int dio200_detach(struct comedi_device * dev);
 static struct comedi_driver driver_amplc_dio200 = {
       driver_name:DIO200_DRIVER_NAME,
@@ -1262,7 +1262,7 @@ dio200_subdev_8254_cleanup(struct comedi_device * dev, struct comedi_subdevice *
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int dio200_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	unsigned long iobase = 0;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 25b8f4fa1c1a..88c127566b8a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -573,7 +573,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  */
 static int
 dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -1034,7 +1034,7 @@ static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
  */
 static int
 dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1049,7 +1049,7 @@ dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
  */
 static int
 dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1143,7 +1143,7 @@ dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  */
 static int
 dio200_subdev_8254_config(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int ret;

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 6323b571f61e..25b8f4fa1c1a 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -610,7 +610,7 @@ static int dio200_start_intr(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int n;
 	unsigned isn_bits;
 	dio200_subdev_intr *subpriv = s->private;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	int retval = 0;
 
 	if (!subpriv->continuous && subpriv->stopcount == 0) {
@@ -802,7 +802,7 @@ static int dio200_subdev_intr_cancel(struct comedi_device * dev, struct comedi_s
  */
 static int
 dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	unsigned int tmp;
@@ -909,7 +909,7 @@ dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice *
  */
 static int dio200_subdev_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
 	int event = 0;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index f34e45028256..6323b571f61e 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -468,14 +468,14 @@ typedef struct {
 } dio200_subdev_intr;
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int dio200_detach(struct comedi_device * dev);
-static comedi_driver driver_amplc_dio200 = {
+static struct comedi_driver driver_amplc_dio200 = {
       driver_name:DIO200_DRIVER_NAME,
       module:THIS_MODULE,
       attach:dio200_attach,

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 642071a92971..f34e45028256 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -572,7 +572,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_insn_bits(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_intr *subpriv = s->private;
@@ -591,7 +591,7 @@ dio200_subdev_intr_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 /*
  * Called to stop acquisition for an 'INTERRUPT' subdevice.
  */
-static void dio200_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
+static void dio200_stop_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -605,7 +605,7 @@ static void dio200_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 /*
  * Called to start acquisition for an 'INTERRUPT' subdevice.
  */
-static int dio200_start_intr(struct comedi_device * dev, comedi_subdevice * s)
+static int dio200_start_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int n;
 	unsigned isn_bits;
@@ -641,7 +641,7 @@ static int dio200_start_intr(struct comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
+dio200_inttrig_start_intr(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trignum)
 {
 	dio200_subdev_intr *subpriv;
@@ -671,7 +671,7 @@ dio200_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
  */
-static int dio200_handle_read_intr(struct comedi_device * dev, comedi_subdevice * s)
+static int dio200_handle_read_intr(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
@@ -783,7 +783,7 @@ static int dio200_handle_read_intr(struct comedi_device * dev, comedi_subdevice
 /*
  * 'cancel' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int dio200_subdev_intr_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
@@ -801,7 +801,7 @@ static int dio200_subdev_intr_cancel(struct comedi_device * dev, comedi_subdevic
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -907,7 +907,7 @@ dio200_subdev_intr_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int dio200_subdev_intr_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	dio200_subdev_intr *subpriv = s->private;
@@ -953,7 +953,7 @@ static int dio200_subdev_intr_cmd(struct comedi_device * dev, comedi_subdevice *
  * This function initializes an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_init(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_init(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned long iobase, unsigned valid_isns, int has_int_sce)
 {
 	dio200_subdev_intr *subpriv;
@@ -998,7 +998,7 @@ dio200_subdev_intr_init(struct comedi_device * dev, comedi_subdevice * s,
  * This function cleans up an 'INTERRUPT' subdevice.
  */
 static void
-dio200_subdev_intr_cleanup(struct comedi_device * dev, comedi_subdevice * s)
+dio200_subdev_intr_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -1033,7 +1033,7 @@ static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
  * Handle 'insn_read' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_read(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_read(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1048,7 +1048,7 @@ dio200_subdev_8254_read(struct comedi_device * dev, comedi_subdevice * s,
  * Handle 'insn_write' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_write(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_write(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1142,7 +1142,7 @@ dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  * Handle 'insn_config' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_config(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_config(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1194,7 +1194,7 @@ dio200_subdev_8254_config(struct comedi_device * dev, comedi_subdevice * s,
  * offset is the offset to the 8254 chip.
  */
 static int
-dio200_subdev_8254_init(struct comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_init(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
 {
 	dio200_subdev_8254 *subpriv;
@@ -1247,7 +1247,7 @@ dio200_subdev_8254_init(struct comedi_device * dev, comedi_subdevice * s,
  * This function cleans up an '8254' counter subdevice.
  */
 static void
-dio200_subdev_8254_cleanup(struct comedi_device * dev, comedi_subdevice * s)
+dio200_subdev_8254_cleanup(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -1264,7 +1264,7 @@ dio200_subdev_8254_cleanup(struct comedi_device * dev, comedi_subdevice * s)
  */
 static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	unsigned long iobase = 0;
 	unsigned int irq = 0;
 #ifdef CONFIG_COMEDI_PCI
@@ -1443,7 +1443,7 @@ static int dio200_detach(struct comedi_device * dev)
 	if (dev->subdevices) {
 		layout = thislayout;
 		for (n = 0; n < dev->n_subdevices; n++) {
-			comedi_subdevice *s = &dev->subdevices[n];
+			struct comedi_subdevice *s = &dev->subdevices[n];
 			switch (layout->sdtype[n]) {
 			case sd_8254:
 				dio200_subdev_8254_cleanup(dev, s);

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 8c8e58f71ec6..642071a92971 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -436,7 +436,7 @@ MODULE_DEVICE_TABLE(pci, dio200_pci_table);
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 #ifdef CONFIG_COMEDI_PCI
 	struct pci_dev *pci_dev;	/* PCI device */
@@ -473,8 +473,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int dio200_attach(comedi_device * dev, comedi_devconfig * it);
-static int dio200_detach(comedi_device * dev);
+static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int dio200_detach(struct comedi_device * dev);
 static comedi_driver driver_amplc_dio200 = {
       driver_name:DIO200_DRIVER_NAME,
       module:THIS_MODULE,
@@ -497,7 +497,7 @@ COMEDI_INITCLEANUP(driver_amplc_dio200);
  */
 #ifdef CONFIG_COMEDI_PCI
 static int
-dio200_find_pci(comedi_device * dev, int bus, int slot,
+dio200_find_pci(struct comedi_device * dev, int bus, int slot,
 	struct pci_dev **pci_dev_p)
 {
 	struct pci_dev *pci_dev = NULL;
@@ -572,7 +572,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  * 'insn_bits' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_insn_bits(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_insn_bits(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_intr *subpriv = s->private;
@@ -591,7 +591,7 @@ dio200_subdev_intr_insn_bits(comedi_device * dev, comedi_subdevice * s,
 /*
  * Called to stop acquisition for an 'INTERRUPT' subdevice.
  */
-static void dio200_stop_intr(comedi_device * dev, comedi_subdevice * s)
+static void dio200_stop_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -605,7 +605,7 @@ static void dio200_stop_intr(comedi_device * dev, comedi_subdevice * s)
 /*
  * Called to start acquisition for an 'INTERRUPT' subdevice.
  */
-static int dio200_start_intr(comedi_device * dev, comedi_subdevice * s)
+static int dio200_start_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned int n;
 	unsigned isn_bits;
@@ -641,7 +641,7 @@ static int dio200_start_intr(comedi_device * dev, comedi_subdevice * s)
  * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+dio200_inttrig_start_intr(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trignum)
 {
 	dio200_subdev_intr *subpriv;
@@ -671,7 +671,7 @@ dio200_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
  * This is called from the interrupt service routine to handle a read
  * scan on an 'INTERRUPT' subdevice.
  */
-static int dio200_handle_read_intr(comedi_device * dev, comedi_subdevice * s)
+static int dio200_handle_read_intr(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 	unsigned triggered;
@@ -783,7 +783,7 @@ static int dio200_handle_read_intr(comedi_device * dev, comedi_subdevice * s)
 /*
  * 'cancel' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cancel(comedi_device * dev, comedi_subdevice * s)
+static int dio200_subdev_intr_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 	unsigned long flags;
@@ -801,7 +801,7 @@ static int dio200_subdev_intr_cancel(comedi_device * dev, comedi_subdevice * s)
  * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_cmdtest(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -907,7 +907,7 @@ dio200_subdev_intr_cmdtest(comedi_device * dev, comedi_subdevice * s,
 /*
  * 'do_cmd' function for an 'INTERRUPT' subdevice.
  */
-static int dio200_subdev_intr_cmd(comedi_device * dev, comedi_subdevice * s)
+static int dio200_subdev_intr_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	dio200_subdev_intr *subpriv = s->private;
@@ -953,7 +953,7 @@ static int dio200_subdev_intr_cmd(comedi_device * dev, comedi_subdevice * s)
  * This function initializes an 'INTERRUPT' subdevice.
  */
 static int
-dio200_subdev_intr_init(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_intr_init(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned long iobase, unsigned valid_isns, int has_int_sce)
 {
 	dio200_subdev_intr *subpriv;
@@ -998,7 +998,7 @@ dio200_subdev_intr_init(comedi_device * dev, comedi_subdevice * s,
  * This function cleans up an 'INTERRUPT' subdevice.
  */
 static void
-dio200_subdev_intr_cleanup(comedi_device * dev, comedi_subdevice * s)
+dio200_subdev_intr_cleanup(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -1012,7 +1012,7 @@ dio200_subdev_intr_cleanup(comedi_device * dev, comedi_subdevice * s)
  */
 static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = d;
+	struct comedi_device *dev = d;
 	int handled;
 
 	if (!dev->attached) {
@@ -1033,7 +1033,7 @@ static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
  * Handle 'insn_read' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_read(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_read(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1048,7 +1048,7 @@ dio200_subdev_8254_read(comedi_device * dev, comedi_subdevice * s,
  * Handle 'insn_write' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_write(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_write(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1142,7 +1142,7 @@ dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  * Handle 'insn_config' for an '8254' counter subdevice.
  */
 static int
-dio200_subdev_8254_config(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_config(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
@@ -1194,7 +1194,7 @@ dio200_subdev_8254_config(comedi_device * dev, comedi_subdevice * s,
  * offset is the offset to the 8254 chip.
  */
 static int
-dio200_subdev_8254_init(comedi_device * dev, comedi_subdevice * s,
+dio200_subdev_8254_init(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
 {
 	dio200_subdev_8254 *subpriv;
@@ -1247,7 +1247,7 @@ dio200_subdev_8254_init(comedi_device * dev, comedi_subdevice * s,
  * This function cleans up an '8254' counter subdevice.
  */
 static void
-dio200_subdev_8254_cleanup(comedi_device * dev, comedi_subdevice * s)
+dio200_subdev_8254_cleanup(struct comedi_device * dev, comedi_subdevice * s)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -1262,7 +1262,7 @@ dio200_subdev_8254_cleanup(comedi_device * dev, comedi_subdevice * s)
  * in the driver structure, dev->board_ptr contains that
  * address.
  */
-static int dio200_attach(comedi_device * dev, comedi_devconfig * it)
+static int dio200_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	unsigned long iobase = 0;
@@ -1429,7 +1429,7 @@ static int dio200_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int dio200_detach(comedi_device * dev)
+static int dio200_detach(struct comedi_device * dev)
 {
 	const dio200_layout *layout;
 	unsigned n;

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
index 2f5f94050180..8c8e58f71ec6 100644
--- a/drivers/staging/comedi/drivers/amplc_dio200.c
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -201,7 +201,7 @@ to be enabled.  All channels will be sampled together (convert_src ==
 TRIG_NOW).  The scan begins a short time after the hardware interrupt
 occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
 scan_begin_arg == 0).  The value read from the interrupt status register
-is packed into a sampl_t value, one bit per requested channel, in the
+is packed into a short value, one bit per requested channel, in the
 order they appear in the channel list.
 */
 
@@ -573,7 +573,7 @@ dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
  */
 static int
 dio200_subdev_intr_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_intr *subpriv = s->private;
 
@@ -732,7 +732,7 @@ static int dio200_handle_read_intr(comedi_device * dev, comedi_subdevice * s)
 			 */
 			if (triggered & subpriv->enabled_isns) {
 				/* Collect scan data. */
-				sampl_t val;
+				short val;
 				unsigned int n, ch, len;
 
 				val = 0;
@@ -1034,7 +1034,7 @@ static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
  */
 static int
 dio200_subdev_8254_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1049,7 +1049,7 @@ dio200_subdev_8254_read(comedi_device * dev, comedi_subdevice * s,
  */
 static int
 dio200_subdev_8254_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int chan = CR_CHAN(insn->chanspec);
@@ -1124,7 +1124,7 @@ dio200_set_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  */
 static int
 dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
-	lsampl_t * period_ns)
+	unsigned int * period_ns)
 {
 	unsigned clock_src;
 
@@ -1143,7 +1143,7 @@ dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
  */
 static int
 dio200_subdev_8254_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	dio200_subdev_8254 *subpriv = s->private;
 	int ret;

commit e948cb522499441996a9580b55bde1585b5c22c5
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Feb 18 15:23:36 2009 -0800

    Staging: comedi: add ampl_dio200 driver
    
    Driver for Amplicon PC272E and PCI272 DIO boards
    
    From: Ian Abbott <abbotti@mev.co.uk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/amplc_dio200.c b/drivers/staging/comedi/drivers/amplc_dio200.c
new file mode 100644
index 000000000000..2f5f94050180
--- /dev/null
+++ b/drivers/staging/comedi/drivers/amplc_dio200.c
@@ -0,0 +1,1483 @@
+/*
+    comedi/drivers/amplc_dio200.c
+    Driver for Amplicon PC272E and PCI272 DIO boards.
+    (Support for other boards in Amplicon 200 series may be added at
+    a later date, e.g. PCI215.)
+
+    Copyright (C) 2005 MEV Ltd. <http://www.mev.co.uk/>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1998,2000 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+/*
+Driver: amplc_dio200
+Description: Amplicon 200 Series Digital I/O
+Author: Ian Abbott <abbotti@mev.co.uk>
+Devices: [Amplicon] PC212E (pc212e), PC214E (pc214e), PC215E (pc215e),
+  PCI215 (pci215 or amplc_dio200), PC218E (pc218e), PC272E (pc272e),
+  PCI272 (pci272 or amplc_dio200)
+Updated: Wed, 22 Oct 2008 13:36:02 +0100
+Status: works
+
+Configuration options - PC212E, PC214E, PC215E, PC218E, PC272E:
+  [0] - I/O port base address
+  [1] - IRQ (optional, but commands won't work without it)
+
+Configuration options - PCI215, PCI272:
+  [0] - PCI bus of device (optional)
+  [1] - PCI slot of device (optional)
+  If bus/slot is not specified, the first available PCI device will
+  be used.
+
+Passing a zero for an option is the same as leaving it unspecified.
+
+SUBDEVICES
+
+                    PC218E         PC212E      PC215E/PCI215
+                 -------------  -------------  -------------
+  Subdevices           7              6              5
+   0                 CTR-X1         PPI-X          PPI-X
+   1                 CTR-X2         CTR-Y1         PPI-Y
+   2                 CTR-Y1         CTR-Y2         CTR-Z1
+   3                 CTR-Y2         CTR-Z1         CTR-Z2
+   4                 CTR-Z1         CTR-Z2       INTERRUPT
+   5                 CTR-Z2       INTERRUPT
+   6               INTERRUPT
+
+                    PC214E      PC272E/PCI272
+                 -------------  -------------
+  Subdevices           4              4
+   0                 PPI-X          PPI-X
+   1                 PPI-Y          PPI-Y
+   2                 CTR-Z1*        PPI-Z
+   3               INTERRUPT*     INTERRUPT
+
+Each PPI is a 8255 chip providing 24 DIO channels.  The DIO channels
+are configurable as inputs or outputs in four groups:
+
+  Port A  - channels  0 to  7
+  Port B  - channels  8 to 15
+  Port CL - channels 16 to 19
+  Port CH - channels 20 to 23
+
+Only mode 0 of the 8255 chips is supported.
+
+Each CTR is a 8254 chip providing 3 16-bit counter channels.  Each
+channel is configured individually with INSN_CONFIG instructions.  The
+specific type of configuration instruction is specified in data[0].
+Some configuration instructions expect an additional parameter in
+data[1]; others return a value in data[1].  The following configuration
+instructions are supported:
+
+  INSN_CONFIG_SET_COUNTER_MODE.  Sets the counter channel's mode and
+    BCD/binary setting specified in data[1].
+
+  INSN_CONFIG_8254_READ_STATUS.  Reads the status register value for the
+    counter channel into data[1].
+
+  INSN_CONFIG_SET_CLOCK_SRC.  Sets the counter channel's clock source as
+    specified in data[1] (this is a hardware-specific value).  Not
+    supported on PC214E.  For the other boards, valid clock sources are
+    0 to 7 as follows:
+
+      0.  CLK n, the counter channel's dedicated CLK input from the SK1
+        connector.  (N.B. for other values, the counter channel's CLKn
+        pin on the SK1 connector is an output!)
+      1.  Internal 10 MHz clock.
+      2.  Internal 1 MHz clock.
+      3.  Internal 100 kHz clock.
+      4.  Internal 10 kHz clock.
+      5.  Internal 1 kHz clock.
+      6.  OUT n-1, the output of counter channel n-1 (see note 1 below).
+      7.  Ext Clock, the counter chip's dedicated Ext Clock input from
+        the SK1 connector.  This pin is shared by all three counter
+        channels on the chip.
+
+  INSN_CONFIG_GET_CLOCK_SRC.  Returns the counter channel's current
+    clock source in data[1].  For internal clock sources, data[2] is set
+    to the period in ns.
+
+  INSN_CONFIG_SET_GATE_SRC.  Sets the counter channel's gate source as
+    specified in data[2] (this is a hardware-specific value).  Not
+    supported on PC214E.  For the other boards, valid gate sources are 0
+    to 7 as follows:
+
+      0.  VCC (internal +5V d.c.), i.e. gate permanently enabled.
+      1.  GND (internal 0V d.c.), i.e. gate permanently disabled.
+      2.  GAT n, the counter channel's dedicated GAT input from the SK1
+        connector.  (N.B. for other values, the counter channel's GATn
+        pin on the SK1 connector is an output!)
+      3.  /OUT n-2, the inverted output of counter channel n-2 (see note
+        2 below).
+      4.  Reserved.
+      5.  Reserved.
+      6.  Reserved.
+      7.  Reserved.
+
+  INSN_CONFIG_GET_GATE_SRC.  Returns the counter channel's current gate
+    source in data[2].
+
+Clock and gate interconnection notes:
+
+  1.  Clock source OUT n-1 is the output of the preceding channel on the
+  same counter subdevice if n > 0, or the output of channel 2 on the
+  preceding counter subdevice (see note 3) if n = 0.
+
+  2.  Gate source /OUT n-2 is the inverted output of channel 0 on the
+  same counter subdevice if n = 2, or the inverted output of channel n+1
+  on the preceding counter subdevice (see note 3) if n < 2.
+
+  3.  The counter subdevices are connected in a ring, so the highest
+  counter subdevice precedes the lowest.
+
+The 'INTERRUPT' subdevice pretends to be a digital input subdevice.  The
+digital inputs come from the interrupt status register.  The number of
+channels matches the number of interrupt sources.  The PC214E does not
+have an interrupt status register; see notes on 'INTERRUPT SOURCES'
+below.
+
+INTERRUPT SOURCES
+
+                    PC218E         PC212E      PC215E/PCI215
+                 -------------  -------------  -------------
+  Sources              6              6              6
+   0              CTR-X1-OUT      PPI-X-C0       PPI-X-C0
+   1              CTR-X2-OUT      PPI-X-C3       PPI-X-C3
+   2              CTR-Y1-OUT     CTR-Y1-OUT      PPI-Y-C0
+   3              CTR-Y2-OUT     CTR-Y2-OUT      PPI-Y-C3
+   4              CTR-Z1-OUT     CTR-Z1-OUT     CTR-Z1-OUT
+   5              CTR-Z2-OUT     CTR-Z2-OUT     CTR-Z2-OUT
+
+                    PC214E      PC272E/PCI272
+                 -------------  -------------
+  Sources              1              6
+   0               JUMPER-J5      PPI-X-C0
+   1                              PPI-X-C3
+   2                              PPI-Y-C0
+   3                              PPI-Y-C3
+   4                              PPI-Z-C0
+   5                              PPI-Z-C3
+
+When an interrupt source is enabled in the interrupt source enable
+register, a rising edge on the source signal latches the corresponding
+bit to 1 in the interrupt status register.
+
+When the interrupt status register value as a whole (actually, just the
+6 least significant bits) goes from zero to non-zero, the board will
+generate an interrupt.  For level-triggered hardware interrupts (PCI
+card), the interrupt will remain asserted until the interrupt status
+register is cleared to zero.  For edge-triggered hardware interrupts
+(ISA card), no further interrupts will occur until the interrupt status
+register is cleared to zero.  To clear a bit to zero in the interrupt
+status register, the corresponding interrupt source must be disabled
+in the interrupt source enable register (there is no separate interrupt
+clear register).
+
+The PC214E does not have an interrupt source enable register or an
+interrupt status register; its 'INTERRUPT' subdevice has a single
+channel and its interrupt source is selected by the position of jumper
+J5.
+
+COMMANDS
+
+The driver supports a read streaming acquisition command on the
+'INTERRUPT' subdevice.  The channel list selects the interrupt sources
+to be enabled.  All channels will be sampled together (convert_src ==
+TRIG_NOW).  The scan begins a short time after the hardware interrupt
+occurs, subject to interrupt latencies (scan_begin_src == TRIG_EXT,
+scan_begin_arg == 0).  The value read from the interrupt status register
+is packed into a sampl_t value, one bit per requested channel, in the
+order they appear in the channel list.
+*/
+
+#include "../comedidev.h"
+
+#include "comedi_pci.h"
+
+#include "8255.h"
+#include "8253.h"
+
+#define DIO200_DRIVER_NAME	"amplc_dio200"
+
+/* PCI IDs */
+/* #define PCI_VENDOR_ID_AMPLICON 0x14dc */
+#define PCI_DEVICE_ID_AMPLICON_PCI272 0x000a
+#define PCI_DEVICE_ID_AMPLICON_PCI215 0x000b
+#define PCI_DEVICE_ID_INVALID 0xffff
+
+/* 200 series registers */
+#define DIO200_IO_SIZE		0x20
+#define DIO200_XCLK_SCE		0x18	/* Group X clock selection register */
+#define DIO200_YCLK_SCE		0x19	/* Group Y clock selection register */
+#define DIO200_ZCLK_SCE		0x1a	/* Group Z clock selection register */
+#define DIO200_XGAT_SCE		0x1b	/* Group X gate selection register */
+#define DIO200_YGAT_SCE		0x1c	/* Group Y gate selection register */
+#define DIO200_ZGAT_SCE		0x1d	/* Group Z gate selection register */
+#define DIO200_INT_SCE		0x1e	/* Interrupt enable/status register */
+
+/*
+ * Macros for constructing value for DIO_200_?CLK_SCE and
+ * DIO_200_?GAT_SCE registers:
+ *
+ * 'which' is: 0 for CTR-X1, CTR-Y1, CTR-Z1; 1 for CTR-X2, CTR-Y2 or CTR-Z2.
+ * 'chan' is the channel: 0, 1 or 2.
+ * 'source' is the signal source: 0 to 7.
+ */
+#define CLK_SCE(which, chan, source) (((which) << 5) | ((chan) << 3) | (source))
+#define GAT_SCE(which, chan, source) (((which) << 5) | ((chan) << 3) | (source))
+
+/*
+ * Periods of the internal clock sources in nanoseconds.
+ */
+static const unsigned clock_period[8] = {
+	0,			/* dedicated clock input/output pin */
+	100,			/* 10 MHz */
+	1000,			/* 1 MHz */
+	10000,			/* 100 kHz */
+	100000,			/* 10 kHz */
+	1000000,		/* 1 kHz */
+	0,			/* OUT N-1 */
+	0			/* group clock input pin */
+};
+
+/*
+ * Board descriptions.
+ */
+
+enum dio200_bustype { isa_bustype, pci_bustype };
+
+enum dio200_model {
+	pc212e_model,
+	pc214e_model,
+	pc215e_model, pci215_model,
+	pc218e_model,
+	pc272e_model, pci272_model,
+	anypci_model
+};
+
+enum dio200_layout {
+	pc212_layout,
+	pc214_layout,
+	pc215_layout,
+	pc218_layout,
+	pc272_layout
+};
+
+typedef struct dio200_board_struct {
+	const char *name;
+	unsigned short devid;
+	enum dio200_bustype bustype;
+	enum dio200_model model;
+	enum dio200_layout layout;
+} dio200_board;
+
+static const dio200_board dio200_boards[] = {
+	{
+	      name:	"pc212e",
+	      bustype:	isa_bustype,
+	      model:	pc212e_model,
+	      layout:	pc212_layout,
+		},
+	{
+	      name:	"pc214e",
+	      bustype:	isa_bustype,
+	      model:	pc214e_model,
+	      layout:	pc214_layout,
+		},
+	{
+	      name:	"pc215e",
+	      bustype:	isa_bustype,
+	      model:	pc215e_model,
+	      layout:	pc215_layout,
+		},
+#ifdef CONFIG_COMEDI_PCI
+	{
+	      name:	"pci215",
+	      devid:	PCI_DEVICE_ID_AMPLICON_PCI215,
+	      bustype:	pci_bustype,
+	      model:	pci215_model,
+	      layout:	pc215_layout,
+		},
+#endif
+	{
+	      name:	"pc218e",
+	      bustype:	isa_bustype,
+	      model:	pc218e_model,
+	      layout:	pc218_layout,
+		},
+	{
+	      name:	"pc272e",
+	      bustype:	isa_bustype,
+	      model:	pc272e_model,
+	      layout:	pc272_layout,
+		},
+#ifdef CONFIG_COMEDI_PCI
+	{
+	      name:	"pci272",
+	      devid:	PCI_DEVICE_ID_AMPLICON_PCI272,
+	      bustype:	pci_bustype,
+	      model:	pci272_model,
+	      layout:	pc272_layout,
+		},
+#endif
+#ifdef CONFIG_COMEDI_PCI
+	{
+	      name:	DIO200_DRIVER_NAME,
+	      devid:	PCI_DEVICE_ID_INVALID,
+	      bustype:	pci_bustype,
+	      model:	anypci_model,	/* wildcard */
+		},
+#endif
+};
+
+/*
+ * Layout descriptions - some ISA and PCI board descriptions share the same
+ * layout.
+ */
+
+enum dio200_sdtype { sd_none, sd_intr, sd_8255, sd_8254 };
+
+#define DIO200_MAX_SUBDEVS	7
+#define DIO200_MAX_ISNS		6
+
+typedef struct dio200_layout_struct {
+	unsigned short n_subdevs;	/* number of subdevices */
+	unsigned char sdtype[DIO200_MAX_SUBDEVS];	/* enum dio200_sdtype */
+	unsigned char sdinfo[DIO200_MAX_SUBDEVS];	/* depends on sdtype */
+	char has_int_sce;	/* has interrupt enable/status register */
+	char has_clk_gat_sce;	/* has clock/gate selection registers */
+} dio200_layout;
+
+static const dio200_layout dio200_layouts[] = {
+	[pc212_layout] = {
+	      n_subdevs:6,
+	      sdtype:	{sd_8255, sd_8254, sd_8254, sd_8254,
+					sd_8254,
+				sd_intr},
+	      sdinfo:	{0x00, 0x08, 0x0C, 0x10, 0x14,
+				0x3F},
+	      has_int_sce:1,
+	      has_clk_gat_sce:1,
+		},
+	[pc214_layout] = {
+	      n_subdevs:4,
+	      sdtype:	{sd_8255, sd_8255, sd_8254,
+				sd_intr},
+	      sdinfo:	{0x00, 0x08, 0x10, 0x01},
+	      has_int_sce:0,
+	      has_clk_gat_sce:0,
+		},
+	[pc215_layout] = {
+	      n_subdevs:5,
+	      sdtype:	{sd_8255, sd_8255, sd_8254,
+					sd_8254,
+				sd_intr},
+	      sdinfo:	{0x00, 0x08, 0x10, 0x14, 0x3F},
+	      has_int_sce:1,
+	      has_clk_gat_sce:1,
+		},
+	[pc218_layout] = {
+	      n_subdevs:7,
+	      sdtype:	{sd_8254, sd_8254, sd_8255, sd_8254,
+					sd_8254,
+				sd_intr},
+	      sdinfo:	{0x00, 0x04, 0x08, 0x0C, 0x10,
+					0x14,
+				0x3F},
+	      has_int_sce:1,
+	      has_clk_gat_sce:1,
+		},
+	[pc272_layout] = {
+	      n_subdevs:4,
+	      sdtype:	{sd_8255, sd_8255, sd_8255,
+				sd_intr},
+	      sdinfo:	{0x00, 0x08, 0x10, 0x3F},
+	      has_int_sce:1,
+	      has_clk_gat_sce:0,
+		},
+};
+
+/*
+ * PCI driver table.
+ */
+
+#ifdef CONFIG_COMEDI_PCI
+static DEFINE_PCI_DEVICE_TABLE(dio200_pci_table) = {
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI215,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_AMPLICON_PCI272,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, dio200_pci_table);
+#endif /* CONFIG_COMEDI_PCI */
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const dio200_board *)dev->board_ptr)
+#define thislayout (&dio200_layouts[((dio200_board *)dev->board_ptr)->layout])
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+#ifdef CONFIG_COMEDI_PCI
+	struct pci_dev *pci_dev;	/* PCI device */
+#endif
+	int intr_sd;
+} dio200_private;
+
+#define devpriv ((dio200_private *)dev->private)
+
+typedef struct {
+	unsigned long iobase;	/* Counter base address */
+	unsigned long clk_sce_iobase;	/* CLK_SCE base address */
+	unsigned long gat_sce_iobase;	/* GAT_SCE base address */
+	int which;		/* Bit 5 of CLK_SCE or GAT_SCE */
+	int has_clk_gat_sce;
+	unsigned clock_src[3];	/* Current clock sources */
+	unsigned gate_src[3];	/* Current gate sources */
+} dio200_subdev_8254;
+
+typedef struct {
+	unsigned long iobase;
+	spinlock_t spinlock;
+	int active;
+	int has_int_sce;
+	unsigned int valid_isns;
+	unsigned int enabled_isns;
+	unsigned int stopcount;
+	int continuous;
+} dio200_subdev_intr;
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int dio200_attach(comedi_device * dev, comedi_devconfig * it);
+static int dio200_detach(comedi_device * dev);
+static comedi_driver driver_amplc_dio200 = {
+      driver_name:DIO200_DRIVER_NAME,
+      module:THIS_MODULE,
+      attach:dio200_attach,
+      detach:dio200_detach,
+      board_name:&dio200_boards[0].name,
+      offset:sizeof(dio200_board),
+      num_names:sizeof(dio200_boards) / sizeof(dio200_board),
+};
+
+#ifdef CONFIG_COMEDI_PCI
+COMEDI_PCI_INITCLEANUP(driver_amplc_dio200, dio200_pci_table);
+#else
+COMEDI_INITCLEANUP(driver_amplc_dio200);
+#endif
+
+/*
+ * This function looks for a PCI device matching the requested board name,
+ * bus and slot.
+ */
+#ifdef CONFIG_COMEDI_PCI
+static int
+dio200_find_pci(comedi_device * dev, int bus, int slot,
+	struct pci_dev **pci_dev_p)
+{
+	struct pci_dev *pci_dev = NULL;
+
+	*pci_dev_p = NULL;
+
+	/* Look for matching PCI device. */
+	for (pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON, PCI_ANY_ID, NULL);
+		pci_dev != NULL;
+		pci_dev = pci_get_device(PCI_VENDOR_ID_AMPLICON,
+			PCI_ANY_ID, pci_dev)) {
+		/* If bus/slot specified, check them. */
+		if (bus || slot) {
+			if (bus != pci_dev->bus->number
+				|| slot != PCI_SLOT(pci_dev->devfn))
+				continue;
+		}
+		if (thisboard->model == anypci_model) {
+			/* Match any supported model. */
+			int i;
+
+			for (i = 0; i < ARRAY_SIZE(dio200_boards); i++) {
+				if (dio200_boards[i].bustype != pci_bustype)
+					continue;
+				if (pci_dev->device == dio200_boards[i].devid) {
+					/* Change board_ptr to matched board. */
+					dev->board_ptr = &dio200_boards[i];
+					break;
+				}
+			}
+			if (i == ARRAY_SIZE(dio200_boards))
+				continue;
+		} else {
+			/* Match specific model name. */
+			if (pci_dev->device != thisboard->devid)
+				continue;
+		}
+
+		/* Found a match. */
+		*pci_dev_p = pci_dev;
+		return 0;
+	}
+	/* No match found. */
+	if (bus || slot) {
+		printk(KERN_ERR
+			"comedi%d: error! no %s found at pci %02x:%02x!\n",
+			dev->minor, thisboard->name, bus, slot);
+	} else {
+		printk(KERN_ERR "comedi%d: error! no %s found!\n",
+			dev->minor, thisboard->name);
+	}
+	return -EIO;
+}
+#endif
+
+/*
+ * This function checks and requests an I/O region, reporting an error
+ * if there is a conflict.
+ */
+static int
+dio200_request_region(unsigned minor, unsigned long from, unsigned long extent)
+{
+	if (!from || !request_region(from, extent, DIO200_DRIVER_NAME)) {
+		printk(KERN_ERR "comedi%d: I/O port conflict (%#lx,%lu)!\n",
+			minor, from, extent);
+		return -EIO;
+	}
+	return 0;
+}
+
+/*
+ * 'insn_bits' function for an 'INTERRUPT' subdevice.
+ */
+static int
+dio200_subdev_intr_insn_bits(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	dio200_subdev_intr *subpriv = s->private;
+
+	if (subpriv->has_int_sce) {
+		/* Just read the interrupt status register.  */
+		data[1] = inb(subpriv->iobase) & subpriv->valid_isns;
+	} else {
+		/* No interrupt status register. */
+		data[0] = 0;
+	}
+
+	return 2;
+}
+
+/*
+ * Called to stop acquisition for an 'INTERRUPT' subdevice.
+ */
+static void dio200_stop_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	dio200_subdev_intr *subpriv = s->private;
+
+	subpriv->active = 0;
+	subpriv->enabled_isns = 0;
+	if (subpriv->has_int_sce) {
+		outb(0, subpriv->iobase);
+	}
+}
+
+/*
+ * Called to start acquisition for an 'INTERRUPT' subdevice.
+ */
+static int dio200_start_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned int n;
+	unsigned isn_bits;
+	dio200_subdev_intr *subpriv = s->private;
+	comedi_cmd *cmd = &s->async->cmd;
+	int retval = 0;
+
+	if (!subpriv->continuous && subpriv->stopcount == 0) {
+		/* An empty acquisition! */
+		s->async->events |= COMEDI_CB_EOA;
+		subpriv->active = 0;
+		retval = 1;
+	} else {
+		/* Determine interrupt sources to enable. */
+		isn_bits = 0;
+		if (cmd->chanlist) {
+			for (n = 0; n < cmd->chanlist_len; n++) {
+				isn_bits |= (1U << CR_CHAN(cmd->chanlist[n]));
+			}
+		}
+		isn_bits &= subpriv->valid_isns;
+		/* Enable interrupt sources. */
+		subpriv->enabled_isns = isn_bits;
+		if (subpriv->has_int_sce) {
+			outb(isn_bits, subpriv->iobase);
+		}
+	}
+
+	return retval;
+}
+
+/*
+ * Internal trigger function to start acquisition for an 'INTERRUPT' subdevice.
+ */
+static int
+dio200_inttrig_start_intr(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trignum)
+{
+	dio200_subdev_intr *subpriv;
+	unsigned long flags;
+	int event = 0;
+
+	if (trignum != 0)
+		return -EINVAL;
+
+	subpriv = s->private;
+
+	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	s->async->inttrig = 0;
+	if (subpriv->active) {
+		event = dio200_start_intr(dev, s);
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 1;
+}
+
+/*
+ * This is called from the interrupt service routine to handle a read
+ * scan on an 'INTERRUPT' subdevice.
+ */
+static int dio200_handle_read_intr(comedi_device * dev, comedi_subdevice * s)
+{
+	dio200_subdev_intr *subpriv = s->private;
+	unsigned triggered;
+	unsigned intstat;
+	unsigned cur_enabled;
+	unsigned int oldevents;
+	unsigned long flags;
+
+	triggered = 0;
+
+	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	oldevents = s->async->events;
+	if (subpriv->has_int_sce) {
+		/*
+		 * Collect interrupt sources that have triggered and disable
+		 * them temporarily.  Loop around until no extra interrupt
+		 * sources have triggered, at which point, the valid part of
+		 * the interrupt status register will read zero, clearing the
+		 * cause of the interrupt.
+		 *
+		 * Mask off interrupt sources already seen to avoid infinite
+		 * loop in case of misconfiguration.
+		 */
+		cur_enabled = subpriv->enabled_isns;
+		while ((intstat = (inb(subpriv->iobase) & subpriv->valid_isns
+					& ~triggered)) != 0) {
+			triggered |= intstat;
+			cur_enabled &= ~triggered;
+			outb(cur_enabled, subpriv->iobase);
+		}
+	} else {
+		/*
+		 * No interrupt status register.  Assume the single interrupt
+		 * source has triggered.
+		 */
+		triggered = subpriv->enabled_isns;
+	}
+
+	if (triggered) {
+		/*
+		 * Some interrupt sources have triggered and have been
+		 * temporarily disabled to clear the cause of the interrupt.
+		 *
+		 * Reenable them NOW to minimize the time they are disabled.
+		 */
+		cur_enabled = subpriv->enabled_isns;
+		if (subpriv->has_int_sce) {
+			outb(cur_enabled, subpriv->iobase);
+		}
+
+		if (subpriv->active) {
+			/*
+			 * The command is still active.
+			 *
+			 * Ignore interrupt sources that the command isn't
+			 * interested in (just in case there's a race
+			 * condition).
+			 */
+			if (triggered & subpriv->enabled_isns) {
+				/* Collect scan data. */
+				sampl_t val;
+				unsigned int n, ch, len;
+
+				val = 0;
+				len = s->async->cmd.chanlist_len;
+				for (n = 0; n < len; n++) {
+					ch = CR_CHAN(s->async->cmd.chanlist[n]);
+					if (triggered & (1U << ch)) {
+						val |= (1U << n);
+					}
+				}
+				/* Write the scan to the buffer. */
+				if (comedi_buf_put(s->async, val)) {
+					s->async->events |= (COMEDI_CB_BLOCK |
+						COMEDI_CB_EOS);
+				} else {
+					/* Error!  Stop acquisition.  */
+					dio200_stop_intr(dev, s);
+					s->async->events |= COMEDI_CB_ERROR
+						| COMEDI_CB_OVERFLOW;
+					comedi_error(dev, "buffer overflow");
+				}
+
+				/* Check for end of acquisition. */
+				if (!subpriv->continuous) {
+					/* stop_src == TRIG_COUNT */
+					if (subpriv->stopcount > 0) {
+						subpriv->stopcount--;
+						if (subpriv->stopcount == 0) {
+							s->async->events |=
+								COMEDI_CB_EOA;
+							dio200_stop_intr(dev,
+								s);
+						}
+					}
+				}
+			}
+		}
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+
+	if (oldevents != s->async->events) {
+		comedi_event(dev, s);
+	}
+
+	return (triggered != 0);
+}
+
+/*
+ * 'cancel' function for an 'INTERRUPT' subdevice.
+ */
+static int dio200_subdev_intr_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	dio200_subdev_intr *subpriv = s->private;
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	if (subpriv->active) {
+		dio200_stop_intr(dev, s);
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+
+	return 0;
+}
+
+/*
+ * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
+ */
+static int
+dio200_subdev_intr_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= (TRIG_NOW | TRIG_INT);
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= (TRIG_COUNT | TRIG_NONE);
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd->start_src & (cmd->start_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd->convert_src & (cmd->convert_src - 1)) != 0)
+		err++;
+	if ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd->stop_src & (cmd->stop_src - 1)) != 0)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	/* cmd->start_src == TRIG_NOW || cmd->start_src == TRIG_INT */
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_begin_src == TRIG_EXT */
+	if (cmd->scan_begin_arg != 0) {
+		cmd->scan_begin_arg = 0;
+		err++;
+	}
+
+	/* cmd->convert_src == TRIG_NOW */
+	if (cmd->convert_arg != 0) {
+		cmd->convert_arg = 0;
+		err++;
+	}
+
+	/* cmd->scan_end_src == TRIG_COUNT */
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
+}
+
+/*
+ * 'do_cmd' function for an 'INTERRUPT' subdevice.
+ */
+static int dio200_subdev_intr_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_cmd *cmd = &s->async->cmd;
+	dio200_subdev_intr *subpriv = s->private;
+	unsigned long flags;
+	int event = 0;
+
+	comedi_spin_lock_irqsave(&subpriv->spinlock, flags);
+	subpriv->active = 1;
+
+	/* Set up end of acquisition. */
+	switch (cmd->stop_src) {
+	case TRIG_COUNT:
+		subpriv->continuous = 0;
+		subpriv->stopcount = cmd->stop_arg;
+		break;
+	default:
+		/* TRIG_NONE */
+		subpriv->continuous = 1;
+		subpriv->stopcount = 0;
+		break;
+	}
+
+	/* Set up start of acquisition. */
+	switch (cmd->start_src) {
+	case TRIG_INT:
+		s->async->inttrig = dio200_inttrig_start_intr;
+		break;
+	default:
+		/* TRIG_NOW */
+		event = dio200_start_intr(dev, s);
+		break;
+	}
+	comedi_spin_unlock_irqrestore(&subpriv->spinlock, flags);
+
+	if (event) {
+		comedi_event(dev, s);
+	}
+
+	return 0;
+}
+
+/*
+ * This function initializes an 'INTERRUPT' subdevice.
+ */
+static int
+dio200_subdev_intr_init(comedi_device * dev, comedi_subdevice * s,
+	unsigned long iobase, unsigned valid_isns, int has_int_sce)
+{
+	dio200_subdev_intr *subpriv;
+
+	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
+	if (!subpriv) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return -ENOMEM;
+	}
+	subpriv->iobase = iobase;
+	subpriv->has_int_sce = has_int_sce;
+	subpriv->valid_isns = valid_isns;
+	spin_lock_init(&subpriv->spinlock);
+
+	if (has_int_sce) {
+		outb(0, subpriv->iobase);	/* Disable interrupt sources. */
+	}
+
+	s->private = subpriv;
+	s->type = COMEDI_SUBD_DI;
+	s->subdev_flags = SDF_READABLE | SDF_CMD_READ;
+	if (has_int_sce) {
+		s->n_chan = DIO200_MAX_ISNS;
+		s->len_chanlist = DIO200_MAX_ISNS;
+	} else {
+		/* No interrupt source register.  Support single channel. */
+		s->n_chan = 1;
+		s->len_chanlist = 1;
+	}
+	s->range_table = &range_digital;
+	s->maxdata = 1;
+	s->insn_bits = dio200_subdev_intr_insn_bits;
+	s->do_cmdtest = dio200_subdev_intr_cmdtest;
+	s->do_cmd = dio200_subdev_intr_cmd;
+	s->cancel = dio200_subdev_intr_cancel;
+
+	return 0;
+}
+
+/*
+ * This function cleans up an 'INTERRUPT' subdevice.
+ */
+static void
+dio200_subdev_intr_cleanup(comedi_device * dev, comedi_subdevice * s)
+{
+	dio200_subdev_intr *subpriv = s->private;
+
+	if (subpriv) {
+		kfree(subpriv);
+	}
+}
+
+/*
+ * Interrupt service routine.
+ */
+static irqreturn_t dio200_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = d;
+	int handled;
+
+	if (!dev->attached) {
+		return IRQ_NONE;
+	}
+
+	if (devpriv->intr_sd >= 0) {
+		handled = dio200_handle_read_intr(dev,
+			dev->subdevices + devpriv->intr_sd);
+	} else {
+		handled = 0;
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+/*
+ * Handle 'insn_read' for an '8254' counter subdevice.
+ */
+static int
+dio200_subdev_8254_read(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	dio200_subdev_8254 *subpriv = s->private;
+	int chan = CR_CHAN(insn->chanspec);
+
+	data[0] = i8254_read(subpriv->iobase, 0, chan);
+
+	return 1;
+}
+
+/*
+ * Handle 'insn_write' for an '8254' counter subdevice.
+ */
+static int
+dio200_subdev_8254_write(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	dio200_subdev_8254 *subpriv = s->private;
+	int chan = CR_CHAN(insn->chanspec);
+
+	i8254_write(subpriv->iobase, 0, chan, data[0]);
+
+	return 1;
+}
+
+/*
+ * Set gate source for an '8254' counter subdevice channel.
+ */
+static int
+dio200_set_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+	unsigned int gate_src)
+{
+	unsigned char byte;
+
+	if (!subpriv->has_clk_gat_sce)
+		return -1;
+	if (counter_number > 2)
+		return -1;
+	if (gate_src > 7)
+		return -1;
+
+	subpriv->gate_src[counter_number] = gate_src;
+	byte = GAT_SCE(subpriv->which, counter_number, gate_src);
+	outb(byte, subpriv->gat_sce_iobase);
+
+	return 0;
+}
+
+/*
+ * Get gate source for an '8254' counter subdevice channel.
+ */
+static int
+dio200_get_gate_src(dio200_subdev_8254 * subpriv, unsigned int counter_number)
+{
+	if (!subpriv->has_clk_gat_sce)
+		return -1;
+	if (counter_number > 2)
+		return -1;
+
+	return subpriv->gate_src[counter_number];
+}
+
+/*
+ * Set clock source for an '8254' counter subdevice channel.
+ */
+static int
+dio200_set_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+	unsigned int clock_src)
+{
+	unsigned char byte;
+
+	if (!subpriv->has_clk_gat_sce)
+		return -1;
+	if (counter_number > 2)
+		return -1;
+	if (clock_src > 7)
+		return -1;
+
+	subpriv->clock_src[counter_number] = clock_src;
+	byte = CLK_SCE(subpriv->which, counter_number, clock_src);
+	outb(byte, subpriv->clk_sce_iobase);
+
+	return 0;
+}
+
+/*
+ * Get clock source for an '8254' counter subdevice channel.
+ */
+static int
+dio200_get_clock_src(dio200_subdev_8254 * subpriv, unsigned int counter_number,
+	lsampl_t * period_ns)
+{
+	unsigned clock_src;
+
+	if (!subpriv->has_clk_gat_sce)
+		return -1;
+	if (counter_number > 2)
+		return -1;
+
+	clock_src = subpriv->clock_src[counter_number];
+	*period_ns = clock_period[clock_src];
+	return clock_src;
+}
+
+/*
+ * Handle 'insn_config' for an '8254' counter subdevice.
+ */
+static int
+dio200_subdev_8254_config(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	dio200_subdev_8254 *subpriv = s->private;
+	int ret;
+	int chan = CR_CHAN(insn->chanspec);
+
+	switch (data[0]) {
+	case INSN_CONFIG_SET_COUNTER_MODE:
+		ret = i8254_set_mode(subpriv->iobase, 0, chan, data[1]);
+		if (ret < 0)
+			return -EINVAL;
+		break;
+	case INSN_CONFIG_8254_READ_STATUS:
+		data[1] = i8254_status(subpriv->iobase, 0, chan);
+		break;
+	case INSN_CONFIG_SET_GATE_SRC:
+		ret = dio200_set_gate_src(subpriv, chan, data[2]);
+		if (ret < 0)
+			return -EINVAL;
+		break;
+	case INSN_CONFIG_GET_GATE_SRC:
+		ret = dio200_get_gate_src(subpriv, chan);
+		if (ret < 0)
+			return -EINVAL;
+		data[2] = ret;
+		break;
+	case INSN_CONFIG_SET_CLOCK_SRC:
+		ret = dio200_set_clock_src(subpriv, chan, data[1]);
+		if (ret < 0)
+			return -EINVAL;
+		break;
+	case INSN_CONFIG_GET_CLOCK_SRC:
+		ret = dio200_get_clock_src(subpriv, chan, &data[2]);
+		if (ret < 0)
+			return -EINVAL;
+		data[1] = ret;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return insn->n;
+}
+
+/*
+ * This function initializes an '8254' counter subdevice.
+ *
+ * Note: iobase is the base address of the board, not the subdevice;
+ * offset is the offset to the 8254 chip.
+ */
+static int
+dio200_subdev_8254_init(comedi_device * dev, comedi_subdevice * s,
+	unsigned long iobase, unsigned offset, int has_clk_gat_sce)
+{
+	dio200_subdev_8254 *subpriv;
+	unsigned int chan;
+
+	subpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);
+	if (!subpriv) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return -ENOMEM;
+	}
+
+	s->private = subpriv;
+	s->type = COMEDI_SUBD_COUNTER;
+	s->subdev_flags = SDF_WRITABLE | SDF_READABLE;
+	s->n_chan = 3;
+	s->maxdata = 0xFFFF;
+	s->insn_read = dio200_subdev_8254_read;
+	s->insn_write = dio200_subdev_8254_write;
+	s->insn_config = dio200_subdev_8254_config;
+
+	subpriv->iobase = offset + iobase;
+	subpriv->has_clk_gat_sce = has_clk_gat_sce;
+	if (has_clk_gat_sce) {
+		/* Derive CLK_SCE and GAT_SCE register offsets from
+		 * 8254 offset. */
+		subpriv->clk_sce_iobase =
+			DIO200_XCLK_SCE + (offset >> 3) + iobase;
+		subpriv->gat_sce_iobase =
+			DIO200_XGAT_SCE + (offset >> 3) + iobase;
+		subpriv->which = (offset >> 2) & 1;
+	}
+
+	/* Initialize channels. */
+	for (chan = 0; chan < 3; chan++) {
+		i8254_set_mode(subpriv->iobase, 0, chan,
+			I8254_MODE0 | I8254_BINARY);
+		if (subpriv->has_clk_gat_sce) {
+			/* Gate source 0 is VCC (logic 1). */
+			dio200_set_gate_src(subpriv, chan, 0);
+			/* Clock source 0 is the dedicated clock input. */
+			dio200_set_clock_src(subpriv, chan, 0);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * This function cleans up an '8254' counter subdevice.
+ */
+static void
+dio200_subdev_8254_cleanup(comedi_device * dev, comedi_subdevice * s)
+{
+	dio200_subdev_intr *subpriv = s->private;
+
+	if (subpriv) {
+		kfree(subpriv);
+	}
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.  If you specified a board_name array
+ * in the driver structure, dev->board_ptr contains that
+ * address.
+ */
+static int dio200_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	unsigned long iobase = 0;
+	unsigned int irq = 0;
+#ifdef CONFIG_COMEDI_PCI
+	struct pci_dev *pci_dev = NULL;
+	int bus = 0, slot = 0;
+#endif
+	const dio200_layout *layout;
+	int share_irq = 0;
+	int sdx;
+	unsigned n;
+	int ret;
+
+	printk(KERN_DEBUG "comedi%d: %s: attach\n", dev->minor,
+		DIO200_DRIVER_NAME);
+
+	if ((ret = alloc_private(dev, sizeof(dio200_private))) < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return ret;
+	}
+
+	/* Process options. */
+	switch (thisboard->bustype) {
+	case isa_bustype:
+		iobase = it->options[0];
+		irq = it->options[1];
+		share_irq = 0;
+		break;
+#ifdef CONFIG_COMEDI_PCI
+	case pci_bustype:
+		bus = it->options[0];
+		slot = it->options[1];
+		share_irq = 1;
+
+		if ((ret = dio200_find_pci(dev, bus, slot, &pci_dev)) < 0)
+			return ret;
+		devpriv->pci_dev = pci_dev;
+		break;
+#endif
+	default:
+		printk(KERN_ERR
+			"comedi%d: %s: BUG! cannot determine board type!\n",
+			dev->minor, DIO200_DRIVER_NAME);
+		return -EINVAL;
+		break;
+	}
+
+	devpriv->intr_sd = -1;
+
+	/* Enable device and reserve I/O spaces. */
+#ifdef CONFIG_COMEDI_PCI
+	if (pci_dev) {
+		ret = comedi_pci_enable(pci_dev, DIO200_DRIVER_NAME);
+		if (ret < 0) {
+			printk(KERN_ERR
+				"comedi%d: error! cannot enable PCI device and request regions!\n",
+				dev->minor);
+			return ret;
+		}
+		iobase = pci_resource_start(pci_dev, 2);
+		irq = pci_dev->irq;
+	} else
+#endif
+	{
+		ret = dio200_request_region(dev->minor, iobase, DIO200_IO_SIZE);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	dev->iobase = iobase;
+
+	layout = thislayout;
+	if ((ret = alloc_subdevices(dev, layout->n_subdevs)) < 0) {
+		printk(KERN_ERR "comedi%d: error! out of memory!\n",
+			dev->minor);
+		return ret;
+	}
+
+	for (n = 0; n < dev->n_subdevices; n++) {
+		s = &dev->subdevices[n];
+		switch (layout->sdtype[n]) {
+		case sd_8254:
+			/* counter subdevice (8254) */
+			ret = dio200_subdev_8254_init(dev, s, iobase,
+				layout->sdinfo[n], layout->has_clk_gat_sce);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case sd_8255:
+			/* digital i/o subdevice (8255) */
+			ret = subdev_8255_init(dev, s, 0,
+				iobase + layout->sdinfo[n]);
+			if (ret < 0) {
+				return ret;
+			}
+			break;
+		case sd_intr:
+			/* 'INTERRUPT' subdevice */
+			if (irq) {
+				ret = dio200_subdev_intr_init(dev, s,
+					iobase + DIO200_INT_SCE,
+					layout->sdinfo[n], layout->has_int_sce);
+				if (ret < 0) {
+					return ret;
+				}
+				devpriv->intr_sd = n;
+			} else {
+				s->type = COMEDI_SUBD_UNUSED;
+			}
+			break;
+		default:
+			s->type = COMEDI_SUBD_UNUSED;
+			break;
+		}
+	}
+
+	sdx = devpriv->intr_sd;
+	if (sdx >= 0 && sdx < dev->n_subdevices) {
+		dev->read_subdev = &dev->subdevices[sdx];
+	}
+
+	dev->board_name = thisboard->name;
+
+	if (irq) {
+		unsigned long flags = share_irq ? IRQF_SHARED : 0;
+
+		if (comedi_request_irq(irq, dio200_interrupt, flags,
+				DIO200_DRIVER_NAME, dev) >= 0) {
+			dev->irq = irq;
+		} else {
+			printk(KERN_WARNING
+				"comedi%d: warning! irq %u unavailable!\n",
+				dev->minor, irq);
+		}
+	}
+
+	printk(KERN_INFO "comedi%d: %s ", dev->minor, dev->board_name);
+	if (thisboard->bustype == isa_bustype) {
+		printk("(base %#lx) ", iobase);
+	} else {
+#ifdef CONFIG_COMEDI_PCI
+		printk("(pci %s) ", pci_name(pci_dev));
+#endif
+	}
+	if (irq) {
+		printk("(irq %u%s) ", irq, (dev->irq ? "" : " UNAVAILABLE"));
+	} else {
+		printk("(no irq) ");
+	}
+
+	printk("attached\n");
+
+	return 1;
+}
+
+/*
+ * _detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int dio200_detach(comedi_device * dev)
+{
+	const dio200_layout *layout;
+	unsigned n;
+
+	printk(KERN_DEBUG "comedi%d: %s: detach\n", dev->minor,
+		DIO200_DRIVER_NAME);
+
+	if (dev->irq) {
+		comedi_free_irq(dev->irq, dev);
+	}
+	if (dev->subdevices) {
+		layout = thislayout;
+		for (n = 0; n < dev->n_subdevices; n++) {
+			comedi_subdevice *s = &dev->subdevices[n];
+			switch (layout->sdtype[n]) {
+			case sd_8254:
+				dio200_subdev_8254_cleanup(dev, s);
+				break;
+			case sd_8255:
+				subdev_8255_cleanup(dev, s);
+				break;
+			case sd_intr:
+				dio200_subdev_intr_cleanup(dev, s);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	if (devpriv) {
+#ifdef CONFIG_COMEDI_PCI
+		if (devpriv->pci_dev) {
+			if (dev->iobase) {
+				comedi_pci_disable(devpriv->pci_dev);
+			}
+			pci_dev_put(devpriv->pci_dev);
+		} else
+#endif
+		{
+			if (dev->iobase) {
+				release_region(dev->iobase, DIO200_IO_SIZE);
+			}
+		}
+	}
+	if (dev->board_name) {
+		printk(KERN_INFO "comedi%d: %s removed\n",
+			dev->minor, dev->board_name);
+	}
+
+	return 0;
+}
