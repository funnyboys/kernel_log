commit 3dbf37c03bc6b1a460e88e1864f7fc184d206496
Author: Amir Mahdi Ghorbanian <indigoomega021@gmail.com>
Date:   Thu Dec 13 10:26:24 2018 -0800

    Staging: comedi: cb_pcidas: fixed a spelling mistake coding style issue
    
    Fixed a coding style issue.
    
    Signed-off-by: Amir Mahdi Ghorbanian <indigoomega021@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 8429d57087fd..02ae00c95313 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -116,7 +116,7 @@
 #define PCIDAS_TRIG_SEL_ANALOG	PCIDAS_TRIG_SEL(3) /* ext. analog trigger */
 #define PCIDAS_TRIG_SEL_MASK	PCIDAS_TRIG_SEL(3) /* start trigger mask */
 #define PCIDAS_TRIG_POL		BIT(2)	/* invert trigger (1602 only) */
-#define PCIDAS_TRIG_MODE	BIT(3)	/* edge/level trigerred (1602 only) */
+#define PCIDAS_TRIG_MODE	BIT(3)	/* edge/level triggered (1602 only) */
 #define PCIDAS_TRIG_EN		BIT(4)	/* enable external start trigger */
 #define PCIDAS_TRIG_BURSTE	BIT(5)	/* burst mode enable */
 #define PCIDAS_TRIG_CLR		BIT(7)	/* clear external trigger */

commit b69839391d444882d83c85a531da8b4e75a2b2e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:44 2017 +0100

    staging: comedi: drivers: Remove redundant license text
    
    Now that the SPDX tag is in all comedi files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0d1d71289d91..8429d57087fd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -9,16 +9,6 @@
  *
  * COMEDI - Linux Control and Measurement Device Interface
  * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /*

commit e184e2bed8fc895ce930624524d319289c1f1082
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:43 2017 +0100

    staging: comedi: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/comedi files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3cd008acb657..0d1d71289d91 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * cb_pcidas.c
  * Developed by Ivan Martinez and Frank Mori Hess, with valuable help from

commit 64289a650656d7307832376fdfaf1e7131236a4b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:44:02 2015 -0700

    staging: comedi: cb_pcidas: update MODULE_DESCRIPTION
    
    Change the MODULE_DESCRIPTION to something more useful than the
    generic "Comedi low-level driver".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 58ba5533dc49..3cd008acb657 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1503,5 +1503,5 @@ static struct pci_driver cb_pcidas_pci_driver = {
 module_comedi_pci_driver(cb_pcidas_driver, cb_pcidas_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
-MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_DESCRIPTION("Comedi driver for MeasurementComputing PCI-DAS series");
 MODULE_LICENSE("GPL");

commit d52688055c9cdc81475882009e437248f073edf9
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:44:01 2015 -0700

    staging: comedi: cb_pcidas: fix cb_pcidas_ao_nofifo_insn_write()
    
    The comedi core expects (*insn_write) functions to write insn->n
    data values to the hardware. Fix this function to work like the
    core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9e82fd24255f..58ba5533dc49 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -417,7 +417,9 @@ static int cb_pcidas_ao_nofifo_insn_write(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = s->readback[chan];
 	unsigned long flags;
+	int i;
 
 	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -427,11 +429,12 @@ static int cb_pcidas_ao_nofifo_insn_write(struct comedi_device *dev,
 	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/* remember value for readback */
-	s->readback[chan] = data[0];
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		outw(val, devpriv->pcibar4 + PCIDAS_AO_DATA_REG(chan));
+	}
 
-	/* send data */
-	outw(data[0], devpriv->pcibar4 + PCIDAS_AO_DATA_REG(chan));
+	s->readback[chan] = val;
 
 	return insn->n;
 }

commit ef7e20934ec906e7986566d45ea8ae652a64ba09
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:44:00 2015 -0700

    staging: comedi: cb_pcidas: fix cb_pcidas_ao_fifo_insn_write()
    
    The comedi core expects (*insn_write) functions to write insn->n
    data values to the hardware. Fix this function to work like the
    core expects.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1e43c1a759d1..9e82fd24255f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -445,7 +445,9 @@ static int cb_pcidas_ao_fifo_insn_write(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int val = s->readback[chan];
 	unsigned long flags;
+	int i;
 
 	/* clear dac fifo */
 	outw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);
@@ -459,11 +461,12 @@ static int cb_pcidas_ao_fifo_insn_write(struct comedi_device *dev,
 	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/* remember value for readback */
-	s->readback[chan] = data[0];
+	for (i = 0; i < insn->n; i++) {
+		val = data[i];
+		outw(val, devpriv->pcibar4 + PCIDAS_AO_FIFO_REG);
+	}
 
-	/* send data */
-	outw(data[0], devpriv->pcibar4 + PCIDAS_AO_FIFO_REG);
+	s->readback[chan] = val;
 
 	return insn->n;
 }

commit f92738ca2fa4f8ca30424ac2b770e2c8a8a7b364
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:43:59 2015 -0700

    staging: comedi: cb_pcidas: remove superfluous comment
    
    The ao (*cancel) function does not need commented.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b763f25acad7..1e43c1a759d1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1085,7 +1085,6 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	return 0;
 }
 
-/* cancel analog output command */
 static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s)
 {

commit 042bac563b28c8067fa958470dd5c1dc31d42cb2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:43:58 2015 -0700

    staging: comedi: cb_pcidas: absorb cal_enable_bits()
    
    This inline function just returns the bits needd to enable
    a calibration source. For aethetics, absorb it into the callers.
    Sorten the variable name in the private data used to hold the
    current calibration source.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c334e4baeeda..b763f25acad7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -313,16 +313,9 @@ struct cb_pcidas_private {
 	/* fifo buffers */
 	unsigned short ai_buffer[AI_BUFFER_SIZE];
 	unsigned short ao_buffer[AO_BUFFER_SIZE];
-	unsigned int calibration_source;
+	unsigned int calib_src;
 };
 
-static inline unsigned int cal_enable_bits(struct comedi_device *dev)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	return PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calibration_source);
-}
-
 static int cb_pcidas_ai_eoc(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn,
@@ -352,7 +345,7 @@ static int cb_pcidas_ai_insn_read(struct comedi_device *dev,
 
 	/* enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
-		outw(cal_enable_bits(dev),
+		outw(PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src),
 		     devpriv->pcibar1 + PCIDAS_CALIB_REG);
 		chan = 0;
 	} else {
@@ -407,7 +400,7 @@ static int cb_pcidas_ai_insn_config(struct comedi_device *dev,
 				source);
 			return -EINVAL;
 		}
-		devpriv->calibration_source = source;
+		devpriv->calib_src = source;
 		break;
 	default:
 		return -EINVAL;
@@ -532,9 +525,10 @@ static void cb_pcidas_calib_write(struct comedi_device *dev,
 				  bool trimpot)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned int calib_bits = cal_enable_bits(dev);
+	unsigned int calib_bits;
 	unsigned int bit;
 
+	calib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);
 	if (trimpot) {
 		/* select trimpot */
 		calib_bits |= PCIDAS_CALIB_TRIM_SEL;
@@ -552,7 +546,7 @@ static void cb_pcidas_calib_write(struct comedi_device *dev,
 	}
 	udelay(1);
 
-	calib_bits = cal_enable_bits(dev);
+	calib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);
 
 	if (!trimpot) {
 		/* select caldac */
@@ -590,7 +584,7 @@ static void cb_pcidas_dac08_write(struct comedi_device *dev, unsigned int val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	val |= cal_enable_bits(dev);
+	val |= PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);
 
 	/* latch the new value into the caldac */
 	outw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);

commit 46c95d970fc2a2c9e7abc0560bbba7155f615982
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:43:57 2015 -0700

    staging: comedi: cb_pcidas: consolidate interrupt clear code
    
    The analog output and analog input interrupts are currently cleared
    as they are handled. Refactor the code to gather all the bits needed
    to clear the interrupts and do it once at the end of the interrupt
    handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 403405be2557..c334e4baeeda 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1111,22 +1111,19 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_ao_interrupt(struct comedi_device *dev,
-				   unsigned int status)
+static unsigned int cb_pcidas_ao_interrupt(struct comedi_device *dev,
+					   unsigned int status)
 {
 	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned long flags;
+	unsigned int irq_clr = 0;
 
 	if (status & PCIDAS_CTRL_DAEMI) {
-		/*  clear dac empty interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_DAEMI,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
+		irq_clr |= PCIDAS_CTRL_DAEMI;
+
 		if (inw(devpriv->pcibar4 + PCIDAS_AO_REG) & PCIDAS_AO_EMPTY) {
 			if (cmd->stop_src == TRIG_COUNT &&
 			    async->scans_done >= cmd->stop_arg) {
@@ -1137,33 +1134,32 @@ static void cb_pcidas_ao_interrupt(struct comedi_device *dev,
 			}
 		}
 	} else if (status & PCIDAS_CTRL_DAHFI) {
-		cb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);
+		irq_clr |= PCIDAS_CTRL_DAHFI;
 
-		/*  clear half-full interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_DAHFI,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
+		cb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);
 	}
 
 	comedi_handle_events(dev, s);
+
+	return irq_clr;
 }
 
-static void cb_pcidas_ai_interrupt(struct comedi_device *dev,
-				   unsigned int status)
+static unsigned int cb_pcidas_ai_interrupt(struct comedi_device *dev,
+					   unsigned int status)
 {
 	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned long flags;
+	unsigned int irq_clr = 0;
 
-	/*  if fifo half-full */
 	if (status & PCIDAS_CTRL_ADHFI) {
 		unsigned int num_samples;
 
-		/*  read data */
+		irq_clr |= PCIDAS_CTRL_INT_CLR;
+
+		/* FIFO is half-full - read data */
 		num_samples = comedi_nsamples_left(s, board->fifo_size / 2);
 		insw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,
 		     devpriv->ai_buffer, num_samples);
@@ -1172,16 +1168,12 @@ static void cb_pcidas_ai_interrupt(struct comedi_device *dev,
 		if (cmd->stop_src == TRIG_COUNT &&
 		    async->scans_done >= cmd->stop_arg)
 			async->events |= COMEDI_CB_EOA;
-
-		/*  clear half-full interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_INT_CLR,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		/*  else if fifo not empty */
 	} else if (status & (PCIDAS_CTRL_ADNEI | PCIDAS_CTRL_EOBI)) {
 		unsigned int i;
 
+		irq_clr |= PCIDAS_CTRL_INT_CLR;
+
+		/* FIFO is not empty - read data until empty or timeoout */
 		for (i = 0; i < 10000; i++) {
 			unsigned short val;
 
@@ -1198,38 +1190,31 @@ static void cb_pcidas_ai_interrupt(struct comedi_device *dev,
 				break;
 			}
 		}
-		/*  clear not-empty interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_INT_CLR,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & PCIDAS_CTRL_EOAI) {
+		irq_clr |= PCIDAS_CTRL_EOAI;
+
 		dev_err(dev->class_dev,
 			"bug! encountered end of acquisition interrupt?\n");
-		/*  clear EOA interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_EOAI,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
+
 	/* check for fifo overflow */
 	if (status & PCIDAS_CTRL_LADFUL) {
+		irq_clr |= PCIDAS_CTRL_LADFUL;
+
 		dev_err(dev->class_dev, "fifo overflow\n");
-		/*  clear overflow interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->ctrl | PCIDAS_CTRL_LADFUL,
-		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
 		async->events |= COMEDI_CB_ERROR;
 	}
 
 	comedi_handle_events(dev, s);
+
+	return irq_clr;
 }
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = d;
 	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int irq_clr = 0;
 	unsigned int amcc_status;
 	unsigned int status;
 
@@ -1251,11 +1236,20 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	/* handle analog output interrupts */
 	if (status & PCIDAS_CTRL_AO_INT)
-		cb_pcidas_ao_interrupt(dev, status);
+		irq_clr |= cb_pcidas_ao_interrupt(dev, status);
 
 	/* handle analog input interrupts */
 	if (status & PCIDAS_CTRL_AI_INT)
-		cb_pcidas_ai_interrupt(dev, status);
+		irq_clr |= cb_pcidas_ai_interrupt(dev, status);
+
+	if (irq_clr) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->ctrl | irq_clr,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
 
 	return IRQ_HANDLED;
 }

commit 7d783469871f48c765c5684dc99fcc409b944754
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Oct 19 09:43:56 2015 -0700

    staging: comedi: cb_pcidas: split ai code out of interrupt handler
    
    Clarify the interrupt handler by splitting the analog input handling
    into a new function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4aa2742641c0..403405be2557 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -97,6 +97,11 @@
 #define PCIDAS_CTRL_LADFUL	BIT(13)	/* fifo overflow / clear */
 #define PCIDAS_CTRL_DAEMI	BIT(14)	/* dac fifo empty int status / clear */
 
+#define PCIDAS_CTRL_AI_INT	(PCIDAS_CTRL_EOAI | PCIDAS_CTRL_EOBI |   \
+				 PCIDAS_CTRL_ADHFI | PCIDAS_CTRL_ADNEI | \
+				 PCIDAS_CTRL_LADFUL)
+#define PCIDAS_CTRL_AO_INT	(PCIDAS_CTRL_DAHFI | PCIDAS_CTRL_DAEMI)
+
 #define PCIDAS_AI_REG		0x02	/* ADC CHANNEL MUX AND CONTROL reg */
 #define PCIDAS_AI_FIRST(x)	((x) & 0xf)
 #define PCIDAS_AI_LAST(x)	(((x) & 0xf) << 4)
@@ -1144,47 +1149,22 @@ static void cb_pcidas_ao_interrupt(struct comedi_device *dev,
 	comedi_handle_events(dev, s);
 }
 
-static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
+static void cb_pcidas_ai_interrupt(struct comedi_device *dev,
+				   unsigned int status)
 {
-	struct comedi_device *dev = d;
 	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
-	struct comedi_async *async;
-	struct comedi_cmd *cmd;
-	int status, s5933_status;
-	int half_fifo = board->fifo_size / 2;
-	unsigned int num_samples, i;
-	static const int timeout = 10000;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long flags;
 
-	if (!dev->attached)
-		return IRQ_NONE;
-
-	async = s->async;
-	cmd = &async->cmd;
-
-	s5933_status = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);
-
-	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
-		return IRQ_NONE;
-
-	/*  make sure mailbox 4 is empty */
-	inl_p(devpriv->amcc + AMCC_OP_REG_IMB4);
-	/*  clear interrupt on amcc s5933 */
-	outl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,
-	     devpriv->amcc + AMCC_OP_REG_INTCSR);
-
-	status = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);
-
-	/*  check for analog output interrupt */
-	if (status & (PCIDAS_CTRL_DAHFI | PCIDAS_CTRL_DAEMI))
-		cb_pcidas_ao_interrupt(dev, status);
-	/*  check for analog input interrupts */
 	/*  if fifo half-full */
 	if (status & PCIDAS_CTRL_ADHFI) {
+		unsigned int num_samples;
+
 		/*  read data */
-		num_samples = comedi_nsamples_left(s, half_fifo);
+		num_samples = comedi_nsamples_left(s, board->fifo_size / 2);
 		insw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,
 		     devpriv->ai_buffer, num_samples);
 		comedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);
@@ -1200,7 +1180,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (PCIDAS_CTRL_ADNEI | PCIDAS_CTRL_EOBI)) {
-		for (i = 0; i < timeout; i++) {
+		unsigned int i;
+
+		for (i = 0; i < 10000; i++) {
 			unsigned short val;
 
 			/*  break if fifo is empty */
@@ -1242,6 +1224,38 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	}
 
 	comedi_handle_events(dev, s);
+}
+
+static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
+{
+	struct comedi_device *dev = d;
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int amcc_status;
+	unsigned int status;
+
+	if (!dev->attached)
+		return IRQ_NONE;
+
+	amcc_status = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);
+
+	if ((INTCSR_INTR_ASSERTED & amcc_status) == 0)
+		return IRQ_NONE;
+
+	/*  make sure mailbox 4 is empty */
+	inl_p(devpriv->amcc + AMCC_OP_REG_IMB4);
+	/*  clear interrupt on amcc s5933 */
+	outl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,
+	     devpriv->amcc + AMCC_OP_REG_INTCSR);
+
+	status = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);
+
+	/* handle analog output interrupts */
+	if (status & PCIDAS_CTRL_AO_INT)
+		cb_pcidas_ao_interrupt(dev, status);
+
+	/* handle analog input interrupts */
+	if (status & PCIDAS_CTRL_AI_INT)
+		cb_pcidas_ai_interrupt(dev, status);
 
 	return IRQ_HANDLED;
 }

commit edebf6199bfec7cdefc69a4178b760d09165a926
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:48:02 2015 -0700

    staging: comedi: cb_pcidas: rename handle_ao_interrupt()
    
    Rename this function so it has namespace associated with the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 268ec777342a..4aa2742641c0 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1106,7 +1106,8 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
+static void cb_pcidas_ao_interrupt(struct comedi_device *dev,
+				   unsigned int status)
 {
 	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
@@ -1178,7 +1179,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	/*  check for analog output interrupt */
 	if (status & (PCIDAS_CTRL_DAHFI | PCIDAS_CTRL_DAEMI))
-		handle_ao_interrupt(dev, status);
+		cb_pcidas_ao_interrupt(dev, status);
 	/*  check for analog input interrupts */
 	/*  if fifo half-full */
 	if (status & PCIDAS_CTRL_ADHFI) {

commit 790b2f06249602ee2560bb94cce4b934abcba6e4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:48:01 2015 -0700

    staging: comedi: cb_pcidas: tidy up analog input subdevice init
    
    For aesthetics, add some whitespace to the subdevice initialization
    and rename the subdevice functions to follow the normal form in
    comedi drivers.
    
    Async command support uses interrupts. For clarity, make sure the
    driver has an IRQ before initializing command support.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4c192fc04be5..268ec777342a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -332,9 +332,10 @@ static int cb_pcidas_ai_eoc(struct comedi_device *dev,
 	return -EBUSY;
 }
 
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ai_insn_read(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -384,8 +385,10 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ai_insn_config(struct comedi_device *dev,
+				    struct comedi_subdevice *s,
+				    struct comedi_insn *insn,
+				    unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	int id = data[0];
@@ -960,9 +963,8 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-/* cancel analog input command */
-static int cb_pcidas_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
+static int cb_pcidas_ai_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long flags;
@@ -1303,22 +1305,24 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
+	/* Analog Input subdevice */
 	s = &dev->subdevices[0];
-	/* analog input subdevice */
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	/* WARNING: Number of inputs in differential mode is ignored */
-	s->n_chan = 16;
-	s->len_chanlist = s->n_chan;
-	s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
+	s->type		= COMEDI_SUBD_AI;
+	s->subdev_flags	= SDF_READABLE | SDF_GROUND | SDF_DIFF;
+	s->n_chan	= 16;
+	s->maxdata	= board->is_16bit ? 0xffff : 0x0fff;
 	s->range_table	= board->use_alt_range ? &cb_pcidas_alt_ranges
 					       : &cb_pcidas_ranges;
-	s->insn_read = cb_pcidas_ai_rinsn;
-	s->insn_config = ai_config_insn;
-	s->do_cmd = cb_pcidas_ai_cmd;
-	s->do_cmdtest = cb_pcidas_ai_cmdtest;
-	s->cancel = cb_pcidas_cancel;
+	s->insn_read	= cb_pcidas_ai_insn_read;
+	s->insn_config	= cb_pcidas_ai_insn_config;
+	if (dev->irq) {
+		dev->read_subdev = s;
+		s->subdev_flags	|= SDF_CMD_READ;
+		s->len_chanlist	= s->n_chan;
+		s->do_cmd	= cb_pcidas_ai_cmd;
+		s->do_cmdtest	= cb_pcidas_ai_cmdtest;
+		s->cancel	= cb_pcidas_ai_cancel;
+	}
 
 	/* Analog Output subdevice */
 	s = &dev->subdevices[1];

commit c5c51b1d6a7629a3efd413fc9f6a6e5d553d5f24
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:48:00 2015 -0700

    staging: comedi: cb_pcidas: tidy up analog output subdevice init
    
    For aesthetics, add some whitespace to the subdevice initialization
    and rename the (*insn_write) functions to follow the normal form
    in comedi drivers.
    
    It's not possible to actually read the analog outpus. For convienence
    the subdevice readback provided by the core is used to return the
    last value written to the subdevice. Remove the SDF_READABLE flag
    from the subdev_flags.
    
    Async command support uses interrupts. For clarity, make sure the
    driver has an IRQ before initializing command support.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 58f20d597700..4c192fc04be5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -408,10 +408,10 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 /* analog output insn for pcidas-1000 and 1200 series */
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data)
+static int cb_pcidas_ao_nofifo_insn_write(struct comedi_device *dev,
+					  struct comedi_subdevice *s,
+					  struct comedi_insn *insn,
+					  unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -436,9 +436,10 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 }
 
 /* analog output insn for pcidas-1602 series */
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_fifo_insn_write(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
@@ -1319,32 +1320,31 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->do_cmdtest = cb_pcidas_ai_cmdtest;
 	s->cancel = cb_pcidas_cancel;
 
-	/* analog output subdevice */
+	/* Analog Output subdevice */
 	s = &dev->subdevices[1];
 	if (board->has_ao) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = 2;
-		s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
-		s->range_table = &cb_pcidas_ao_ranges;
-		/* default to no fifo (*insn_write) */
-		s->insn_write = cb_pcidas_ao_nofifo_winsn;
+		s->type		= COMEDI_SUBD_AO;
+		s->subdev_flags	= SDF_WRITABLE | SDF_GROUND;
+		s->n_chan	= 2;
+		s->maxdata	= board->is_16bit ? 0xffff : 0x0fff;
+		s->range_table	= &cb_pcidas_ao_ranges;
+		s->insn_write	= (board->has_ao_fifo)
+					? cb_pcidas_ao_fifo_insn_write
+					: cb_pcidas_ao_nofifo_insn_write;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)
 			return ret;
 
-		if (board->has_ao_fifo) {
+		if (dev->irq && board->has_ao_fifo) {
 			dev->write_subdev = s;
-			s->subdev_flags |= SDF_CMD_WRITE;
-			/* use fifo (*insn_write) instead */
-			s->insn_write = cb_pcidas_ao_fifo_winsn;
-			s->do_cmdtest = cb_pcidas_ao_cmdtest;
-			s->do_cmd = cb_pcidas_ao_cmd;
-			s->cancel = cb_pcidas_ao_cancel;
+			s->subdev_flags	|= SDF_CMD_WRITE;
+			s->do_cmdtest	= cb_pcidas_ao_cmdtest;
+			s->do_cmd	= cb_pcidas_ao_cmd;
+			s->cancel	= cb_pcidas_ao_cancel;
 		}
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/* 8255 */

commit b4008c7207e832d14414f76774a8ebc7067f2154
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:59 2015 -0700

    staging: comedi: cb_pcidas: rename private data 's5933_intcsr_bits'
    
    For aesthetics, rename this member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 5305d60e5a41..58f20d597700 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -303,7 +303,7 @@ struct cb_pcidas_private {
 	unsigned long pcibar4;
 	/* bits to write to registers */
 	unsigned int ctrl;
-	unsigned int s5933_intcsr_bits;
+	unsigned int amcc_intcsr;
 	unsigned int ao_ctrl;
 	/* fifo buffers */
 	unsigned short ai_buffer[AI_BUFFER_SIZE];
@@ -1168,7 +1168,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	/*  make sure mailbox 4 is empty */
 	inl_p(devpriv->amcc + AMCC_OP_REG_IMB4);
 	/*  clear interrupt on amcc s5933 */
-	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
+	outl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	status = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);
@@ -1433,11 +1433,10 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	/*  make sure mailbox 4 is empty */
 	inl(devpriv->amcc + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
-	devpriv->s5933_intcsr_bits =
-	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
-	    INTCSR_INBOX_FULL_INT;
+	devpriv->amcc_intcsr = INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
+			       INTCSR_INBOX_FULL_INT;
 	/*  clear and enable interrupt on amcc s5933 */
-	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
+	outl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	return 0;

commit 8499ad694a20de85a9e37da4a1aa57869f368fb2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:58 2015 -0700

    staging: comedi: cb_pcidas: rename private data 's5933_config'
    
    For aesthetics, rename this member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c0ae92dc9fa2..5305d60e5a41 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -297,7 +297,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 struct cb_pcidas_private {
 	struct comedi_8254 *ao_pacer;
 	/* base addresses */
-	unsigned long s5933_config;
+	unsigned long amcc;	/* pcibar0 */
 	unsigned long pcibar1;
 	unsigned long pcibar2;
 	unsigned long pcibar4;
@@ -474,7 +474,7 @@ static int cb_pcidas_eeprom_ready(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int status;
 
-	status = inb(devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+	status = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);
 	if ((status & MCSR_NV_BUSY) == 0)
 		return 0;
 	return -EBUSY;
@@ -498,22 +498,21 @@ static int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,
 
 		/* set address (chan) and read operation */
 		outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
-		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
-		outb(chan & 0xff,
-		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+		     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);
+		outb(chan & 0xff, devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);
 		outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
-		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+		     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);
 		outb((chan >> 8) & 0xff,
-		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+		     devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);
 		outb(MCSR_NV_ENABLE | MCSR_NV_READ,
-		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+		     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);
 
 		/* wait for data to be returned */
 		ret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);
 		if (ret)
 			return ret;
 
-		data[i] = inb(devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+		data[i] = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);
 	}
 
 	return insn->n;
@@ -1161,16 +1160,16 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	async = s->async;
 	cmd = &async->cmd;
 
-	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	s5933_status = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
 		return IRQ_NONE;
 
 	/*  make sure mailbox 4 is empty */
-	inl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);
+	inl_p(devpriv->amcc + AMCC_OP_REG_IMB4);
 	/*  clear interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	status = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
@@ -1268,7 +1267,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	devpriv->s5933_config = pci_resource_start(pcidev, 0);
+	devpriv->amcc = pci_resource_start(pcidev, 0);
 	devpriv->pcibar1 = pci_resource_start(pcidev, 1);
 	devpriv->pcibar2 = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
@@ -1277,7 +1276,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
-	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	ret = request_irq(pcidev->irq, cb_pcidas_interrupt, IRQF_SHARED,
 			  dev->board_name, dev);
@@ -1432,14 +1431,14 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	}
 
 	/*  make sure mailbox 4 is empty */
-	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
+	inl(devpriv->amcc + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
 	devpriv->s5933_intcsr_bits =
 	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
 	    INTCSR_INBOX_FULL_INT;
 	/*  clear and enable interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->amcc + AMCC_OP_REG_INTCSR);
 
 	return 0;
 }
@@ -1449,9 +1448,9 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 	struct cb_pcidas_private *devpriv = dev->private;
 
 	if (devpriv) {
-		if (devpriv->s5933_config)
+		if (devpriv->amcc)
 			outl(INTCSR_INBOX_INTR_STATUS,
-			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+			     devpriv->amcc + AMCC_OP_REG_INTCSR);
 		kfree(devpriv->ao_pacer);
 	}
 	comedi_pci_detach(dev);

commit 16ded01b69b10d09659e61f0703979c63dcd385f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:57 2015 -0700

    staging: comedi: cb_pcidas: fix cb_pcidas_eeprom_insn_read()
    
    The comedi core expects (*insn_read) operations to return insn->n
    data values. Refactor this function to work like the core expects.
    
    For aesthetics, nvram_read() and use the comedi_timeout() helper
    to handle the busy wait for the eeprom to be "ready".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3238cabca7ac..c0ae92dc9fa2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -466,44 +466,18 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int wait_for_nvram_ready(unsigned long s5933_base_addr)
-{
-	static const int timeout = 1000;
-	unsigned int i;
-
-	for (i = 0; i < timeout; i++) {
-		if ((inb(s5933_base_addr +
-			 AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
-		    == 0)
-			return 0;
-		udelay(1);
-	}
-	return -1;
-}
-
-static int nvram_read(struct comedi_device *dev, unsigned int address,
-		      u8 *data)
+static int cb_pcidas_eeprom_ready(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned long context)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long iobase = devpriv->s5933_config;
-
-	if (wait_for_nvram_ready(iobase) < 0)
-		return -ETIMEDOUT;
-
-	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
-	     iobase + AMCC_OP_REG_MCSR_NVCMD);
-	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
-	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
-	     iobase + AMCC_OP_REG_MCSR_NVCMD);
-	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
-	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
-
-	if (wait_for_nvram_ready(iobase) < 0)
-		return -ETIMEDOUT;
-
-	*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);
+	unsigned int status;
 
-	return 0;
+	status = inb(devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+	if ((status & MCSR_NV_BUSY) == 0)
+		return 0;
+	return -EBUSY;
 }
 
 static int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,
@@ -511,16 +485,38 @@ static int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,
 				      struct comedi_insn *insn,
 				      unsigned int *data)
 {
-	u8 nvram_data;
-	int retval;
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	int ret;
+	int i;
 
-	retval = nvram_read(dev, CR_CHAN(insn->chanspec), &nvram_data);
-	if (retval < 0)
-		return retval;
+	for (i = 0; i < insn->n; i++) {
+		/* make sure eeprom is ready */
+		ret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);
+		if (ret)
+			return ret;
+
+		/* set address (chan) and read operation */
+		outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
+		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+		outb(chan & 0xff,
+		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+		outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
+		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+		outb((chan >> 8) & 0xff,
+		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+		outb(MCSR_NV_ENABLE | MCSR_NV_READ,
+		     devpriv->s5933_config + AMCC_OP_REG_MCSR_NVCMD);
+
+		/* wait for data to be returned */
+		ret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);
+		if (ret)
+			return ret;
 
-	data[0] = nvram_data;
+		data[i] = inb(devpriv->s5933_config + AMCC_OP_REG_MCSR_NVDATA);
+	}
 
-	return 1;
+	return insn->n;
 }
 
 static void cb_pcidas_calib_write(struct comedi_device *dev,

commit 73d38effd10b8e399790aa67d6eace855f2d81ce
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:56 2015 -0700

    staging: comedi: cb_pcidas: tidy up memory subdevice init
    
    For aesthetics, add some whitespace to the initialization of this
    subdevice.
    
    Rename the (*insn_read) function so it has namespace associated with
    the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f34a615df841..3238cabca7ac 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -506,9 +506,10 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
 	return 0;
 }
 
-static int eeprom_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	u8 nvram_data;
 	int retval;
@@ -1357,13 +1358,13 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	/*  serial EEPROM, */
+	/* Memory subdevice - serial EEPROM */
 	s = &dev->subdevices[3];
-	s->type = COMEDI_SUBD_MEMORY;
-	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-	s->n_chan = 256;
-	s->maxdata = 0xff;
-	s->insn_read = eeprom_read_insn;
+	s->type		= COMEDI_SUBD_MEMORY;
+	s->subdev_flags	= SDF_READABLE | SDF_INTERNAL;
+	s->n_chan	= 256;
+	s->maxdata	= 0xff;
+	s->insn_read	= cb_pcidas_eeprom_insn_read;
 
 	/* Calibration subdevice - 8800 caldac */
 	s = &dev->subdevices[4];

commit d9b0cde41992bbd9047b435354bd5e2317158748
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:55 2015 -0700

    staging: comedi: cb_pcidas: tidy up 8800 caldac calibration subdevice
    
    For aesthetics, add some whitespace to the subdevice init.
    
    It's not possible to actually read from the caldac. For convienence
    the subdevice readback provided by the core is used to return the
    last value written to the subdevice. Remove the SDF_READABLE flag
    from the subdev_flags.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 04d12bf1f6cd..f34a615df841 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1365,13 +1365,13 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->maxdata = 0xff;
 	s->insn_read = eeprom_read_insn;
 
-	/*  8800 caldac */
+	/* Calibration subdevice - 8800 caldac */
 	s = &dev->subdevices[4];
-	s->type = COMEDI_SUBD_CALIB;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	s->n_chan = 8;
-	s->maxdata = 0xff;
-	s->insn_write = cb_pcidas_caldac_insn_write;
+	s->type		= COMEDI_SUBD_CALIB;
+	s->subdev_flags	= SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan	= 8;
+	s->maxdata	= 0xff;
+	s->insn_write	= cb_pcidas_caldac_insn_write;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit a266cd7992e7d2920a40a27c8192884fee261c21
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:54 2015 -0700

    staging: comedi: cb_pcidas: tidy up dac08_write()
    
    Rename this function so it has namespace associated with the driver.
    Also rename the 'value' parameter to avoid having to split the line
    to keep it under 80 chars.
    
    Remove the unnecessary masking on the 'value'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b5c7dc3a9c6b..04d12bf1f6cd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -581,21 +581,19 @@ static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-/* 1602/16 pregain offset */
-static void dac08_write(struct comedi_device *dev, unsigned int value)
+static void cb_pcidas_dac08_write(struct comedi_device *dev, unsigned int val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	value &= 0xff;
-	value |= cal_enable_bits(dev);
+	val |= cal_enable_bits(dev);
 
 	/* latch the new value into the caldac */
-	outw(value, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	outw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
-	outw(value | PCIDAS_CALIB_DAC08_SEL,
+	outw(val | PCIDAS_CALIB_DAC08_SEL,
 	     devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
-	outw(value, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	outw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
 }
 
@@ -610,7 +608,7 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 		unsigned int val = data[insn->n - 1];
 
 		if (s->readback[chan] != val) {
-			dac08_write(dev, val);
+			cb_pcidas_dac08_write(dev, val);
 			s->readback[chan] = val;
 		}
 	}
@@ -1415,7 +1413,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->readback[i] = s->maxdata / 2;
 	}
 
-	/* Calibration subdevice - dac08 caldac */
+	/* Calibration subdevice - pci-das1602/16 pregain offset (dac08) */
 	s = &dev->subdevices[6];
 	if (board->has_dac08) {
 		s->type		= COMEDI_SUBD_CALIB;
@@ -1429,7 +1427,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 			return ret;
 
 		for (i = 0; i < s->n_chan; i++) {
-			dac08_write(dev, s->maxdata / 2);
+			cb_pcidas_dac08_write(dev, s->maxdata / 2);
 			s->readback[i] = s->maxdata / 2;
 		}
 	} else {

commit e56aaa24a0347d6e0f3be83eb31252855cadba93
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:53 2015 -0700

    staging: comedi: cb_pcidas: tidy up dac08 calibration subdevice
    
    For aesthetics, add some whitespace to the subdevice init.
    
    It's not possible to actually read from the dac08. For convienence
    the subdevice readback provided by the core is used to return the
    last value written to the subdevice. Remove the SDF_READABLE flag
    from the subdev_flags.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index fc972e56a623..b5c7dc3a9c6b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1415,14 +1415,14 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->readback[i] = s->maxdata / 2;
 	}
 
-	/*  dac08 caldac */
+	/* Calibration subdevice - dac08 caldac */
 	s = &dev->subdevices[6];
 	if (board->has_dac08) {
-		s->type = COMEDI_SUBD_CALIB;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = 1;
-		s->maxdata = 0xff;
-		s->insn_write = cb_pcidas_dac08_insn_write;
+		s->type		= COMEDI_SUBD_CALIB;
+		s->subdev_flags	= SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan	= 1;
+		s->maxdata	= 0xff;
+		s->insn_write	= cb_pcidas_dac08_insn_write;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)
@@ -1433,7 +1433,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 			s->readback[i] = s->maxdata / 2;
 		}
 	} else {
-		s->type = COMEDI_SUBD_UNUSED;
+		s->type		= COMEDI_SUBD_UNUSED;
 	}
 
 	/*  make sure mailbox 4 is empty */

commit fe970e4d2d75497a7fed75cea0acd7150e92ed92
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:52 2015 -0700

    staging: comedi: cb_pcidas: refactor 'trimpot' boardinfo
    
    Only the pci-das1602/16 boards have an AD8402 trimpot. The rest of
    the boards supported by this driver have an AD7376 trimpot.
    
    Replace the 'enum trimpot_module' in the boardinfo with a bit-field
    flag 'has_ad8402' to save a bit of space.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2c6ef6eae095..fc972e56a623 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -207,11 +207,6 @@ static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	}
 };
 
-enum trimpot_model {
-	AD7376,
-	AD8402,
-};
-
 enum cb_pcidas_boardid {
 	BOARD_PCIDAS1602_16,
 	BOARD_PCIDAS1200,
@@ -228,11 +223,11 @@ struct cb_pcidas_board {
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_scan_speed;	/*  analog output scan speed for 1602 series */
 	int fifo_size;		/*  number of samples fifo can hold */
-	enum trimpot_model trimpot;
 	unsigned int is_16bit;		/* ai/ao is 1=16-bit; 0=12-bit */
 	unsigned int use_alt_range:1;	/* use alternate ai range table */
 	unsigned int has_ao:1;		/* has 2 analog output channels */
 	unsigned int has_ao_fifo:1;	/* analog output has fifo */
+	unsigned int has_ad8402:1;	/* trimpot type 1=AD8402; 0=AD7376 */
 	unsigned int has_dac08:1;
 	unsigned int is_1602:1;
 };
@@ -243,10 +238,10 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_speed	= 5000,
 		.ao_scan_speed	= 10000,
 		.fifo_size	= 512,
-		.trimpot	= AD8402,
 		.is_16bit	= 1,
 		.has_ao		= 1,
 		.has_ao_fifo	= 1,
+		.has_ad8402	= 1,
 		.has_dac08	= 1,
 		.is_1602	= 1,
 	},
@@ -254,7 +249,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200",
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 		.has_ao		= 1,
 	},
 	[BOARD_PCIDAS1602_12] = {
@@ -262,7 +256,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_speed	= 3200,
 		.ao_scan_speed	= 4000,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 		.has_ao		= 1,
 		.has_ao_fifo	= 1,
 		.is_1602	= 1,
@@ -271,14 +264,13 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200/jr",
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 	},
 	[BOARD_PCIDAS1602_16_JR] = {
 		.name		= "pci-das1602/16/jr",
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
-		.trimpot	= AD8402,
 		.is_16bit	= 1,
+		.has_ad8402	= 1,
 		.has_dac08	= 1,
 		.is_1602	= 1,
 	},
@@ -286,13 +278,11 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1000",
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 	},
 	[BOARD_PCIDAS1001] = {
 		.name		= "pci-das1001",
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 		.use_alt_range	= 1,
 		.has_ao		= 1,
 	},
@@ -300,7 +290,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1002",
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
-		.trimpot	= AD7376,
 		.has_ao		= 1,
 	},
 };
@@ -634,12 +623,12 @@ static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 {
 	const struct cb_pcidas_board *board = dev->board_ptr;
 
-	if (board->trimpot == AD7376) {
-		/* write 7-bit value to trimpot */
-		cb_pcidas_calib_write(dev, val, 7, true);
-	} else {	/* AD8402 */
-		/* write 10-bit channel/value to trimpot */
+	if (board->has_ad8402) {
+		/* write 10-bit channel/value to AD8402 trimpot */
 		cb_pcidas_calib_write(dev, (chan << 8) | val, 10, true);
+	} else {
+		/* write 7-bit value to AD7376 trimpot */
+		cb_pcidas_calib_write(dev, val, 7, true);
 	}
 }
 
@@ -1402,17 +1391,18 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[5];
 	s->type		= COMEDI_SUBD_CALIB;
 	s->subdev_flags	= SDF_WRITABLE | SDF_INTERNAL;
-	if (board->trimpot == AD7376) {
-		s->n_chan	= 1;
-		s->maxdata	= 0x7f;
-	} else {	/* AD8402 */
+	if (board->has_ad8402) {
 		/*
-		 * For pci-das1602/16:
+		 * pci-das1602/16 have an AD8402 trimpot:
 		 *   chan 0 : adc gain
 		 *   chan 1 : adc postgain offset
 		 */
 		s->n_chan	= 2;
 		s->maxdata	= 0xff;
+	} else {
+		/* all other boards have an AD7376 trimpot */
+		s->n_chan	= 1;
+		s->maxdata	= 0x7f;
 	}
 	s->insn_write	= cb_pcidas_trimpot_insn_write;
 

commit 873524c8517cf0986768685358d124aae7f7e495
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:51 2015 -0700

    staging: comedi: cb_pcidas: tidy up cb_pcidas_trimpot_write()
    
    All the boards supported by this driver have an AD7376 or AD8402
    trimpot. Replace the switch () with and if () and remove the
    unreachable dev_err() noise.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f22611b3edcd..2c6ef6eae095 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -634,18 +634,12 @@ static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 {
 	const struct cb_pcidas_board *board = dev->board_ptr;
 
-	switch (board->trimpot) {
-	case AD7376:
+	if (board->trimpot == AD7376) {
 		/* write 7-bit value to trimpot */
 		cb_pcidas_calib_write(dev, val, 7, true);
-		break;
-	case AD8402:
+	} else {	/* AD8402 */
 		/* write 10-bit channel/value to trimpot */
 		cb_pcidas_calib_write(dev, (chan << 8) | val, 10, true);
-		break;
-	default:
-		dev_err(dev->class_dev, "driver bug?\n");
-		break;
 	}
 }
 

commit 2d71464fd137d4a830dddfc799de8158e9ddc97c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:50 2015 -0700

    staging: comedi: cb_pcidas: absorb caldac/trimpot write functions
    
    These functions are all just wrappers for cb_pcidas_calib_write().
    Remove them and absorb the code into the callers.
    
    Remove the unnecessary masking of the 'chan'. It will always be in
    range due to the subdevice initialization.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c034de3fca42..f22611b3edcd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -571,13 +571,6 @@ static void cb_pcidas_calib_write(struct comedi_device *dev,
 	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 }
 
-static void cb_pcidas_caldac_8800_write(struct comedi_device *dev,
-					unsigned int chan, unsigned int val)
-{
-	/* write 11-bit value to caldac */
-	cb_pcidas_calib_write(dev, ((chan & 0x7) << 8) | val, 11, false);
-}
-
 static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 				       struct comedi_subdevice *s,
 				       struct comedi_insn *insn,
@@ -589,7 +582,9 @@ static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 		unsigned int val = data[insn->n - 1];
 
 		if (s->readback[chan] != val) {
-			cb_pcidas_caldac_8800_write(dev, chan, val);
+			/* write 11-bit channel/value to caldac */
+			cb_pcidas_calib_write(dev, (chan << 8) | val, 11,
+					      false);
 			s->readback[chan] = val;
 		}
 	}
@@ -634,20 +629,6 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static void cb_pcidas_trimpot_7376_write(struct comedi_device *dev,
-					 unsigned int val)
-{
-	/* write 7-bit value to trimpot */
-	cb_pcidas_calib_write(dev, val, 7, true);
-}
-
-static void cb_pcidas_trimpot_8402_write(struct comedi_device *dev,
-					 unsigned int chan, unsigned int val)
-{
-	/* write 10-bit value to trimpot */
-	cb_pcidas_calib_write(dev, ((chan & 0x3) << 8) | val, 10, true);
-}
-
 static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 				    unsigned int chan, unsigned int val)
 {
@@ -655,10 +636,12 @@ static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 
 	switch (board->trimpot) {
 	case AD7376:
-		cb_pcidas_trimpot_7376_write(dev, val);
+		/* write 7-bit value to trimpot */
+		cb_pcidas_calib_write(dev, val, 7, true);
 		break;
 	case AD8402:
-		cb_pcidas_trimpot_8402_write(dev, chan, val);
+		/* write 10-bit channel/value to trimpot */
+		cb_pcidas_calib_write(dev, (chan << 8) | val, 10, true);
 		break;
 	default:
 		dev_err(dev->class_dev, "driver bug?\n");
@@ -1414,8 +1397,11 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	for (i = 0; i < s->n_chan; i++) {
-		cb_pcidas_caldac_8800_write(dev, i, s->maxdata / 2);
-		s->readback[i] = s->maxdata / 2;
+		unsigned int val = s->maxdata / 2;
+
+		/* write 11-bit channel/value to caldac */
+		cb_pcidas_calib_write(dev, (i << 8) | val, 11, false);
+		s->readback[i] = val;
 	}
 
 	/* Calibration subdevice - trim potentiometer */

commit eddd2a4c675c95f19da79b5adbf46851b2441212
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:49 2015 -0700

    staging: comedi: cb_pcidas: refactor write_calibration_bitstream()
    
    Refactor this function to handle the common code used to select the
    calibration device (trimpot or caldac) and latch the data after
    sending the bitstream.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index fb10fe6d3806..c034de3fca42 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -533,42 +533,49 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
-static void write_calibration_bitstream(struct comedi_device *dev,
-					unsigned int register_bits,
-					unsigned int bitstream,
-					unsigned int bitstream_length)
+static void cb_pcidas_calib_write(struct comedi_device *dev,
+				  unsigned int val, unsigned int len,
+				  bool trimpot)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	static const int write_delay = 1;
+	unsigned int calib_bits = cal_enable_bits(dev);
 	unsigned int bit;
 
-	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
-		if (bitstream & bit)
-			register_bits |= PCIDAS_CALIB_DATA;
+	if (trimpot) {
+		/* select trimpot */
+		calib_bits |= PCIDAS_CALIB_TRIM_SEL;
+		outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	}
+
+	/* write bitstream to calibration device */
+	for (bit = 1 << (len - 1); bit; bit >>= 1) {
+		if (val & bit)
+			calib_bits |= PCIDAS_CALIB_DATA;
 		else
-			register_bits &= ~PCIDAS_CALIB_DATA;
-		udelay(write_delay);
-		outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+			calib_bits &= ~PCIDAS_CALIB_DATA;
+		udelay(1);
+		outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	}
+	udelay(1);
+
+	calib_bits = cal_enable_bits(dev);
+
+	if (!trimpot) {
+		/* select caldac */
+		outw(calib_bits | PCIDAS_CALIB_8800_SEL,
+		     devpriv->pcibar1 + PCIDAS_CALIB_REG);
+		udelay(1);
 	}
+
+	/* latch value to trimpot/caldac */
+	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 }
 
 static void cb_pcidas_caldac_8800_write(struct comedi_device *dev,
 					unsigned int chan, unsigned int val)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	/* write 11-bit value */
-	write_calibration_bitstream(dev, cal_enable_bits(dev),
-				    ((chan & 0x7) << 8) | val, 11);
-	udelay(1);
-
-	/* select caldac */
-	outw(cal_enable_bits(dev) | PCIDAS_CALIB_8800_SEL,
-	     devpriv->pcibar1 + PCIDAS_CALIB_REG);
-	udelay(1);
-
-	/* latch value */
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	/* write 11-bit value to caldac */
+	cb_pcidas_calib_write(dev, ((chan & 0x7) << 8) | val, 11, false);
 }
 
 static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
@@ -630,40 +637,15 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 static void cb_pcidas_trimpot_7376_write(struct comedi_device *dev,
 					 unsigned int val)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned int calib_bits;
-
-	/* select trimpot */
-	calib_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
-	udelay(1);
-	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
-
-	/* write 7-bit value */
-	write_calibration_bitstream(dev, calib_bits, val, 7);
-	udelay(1);
-
-	/* latch value */
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	/* write 7-bit value to trimpot */
+	cb_pcidas_calib_write(dev, val, 7, true);
 }
 
 static void cb_pcidas_trimpot_8402_write(struct comedi_device *dev,
 					 unsigned int chan, unsigned int val)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned int calib_bits;
-
-	/* select trimpot */
-	calib_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
-	udelay(1);
-	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
-
-	/* write 10-bit value */
-	write_calibration_bitstream(dev, calib_bits,
-				    ((chan & 0x3) << 8) | val, 10);
-	udelay(1);
-
-	/* latch value */
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	/* write 10-bit value to trimpot */
+	cb_pcidas_calib_write(dev, ((chan & 0x3) << 8) | val, 10, true);
 }
 
 static void cb_pcidas_trimpot_write(struct comedi_device *dev,

commit 2285cd513128d8765334083a997eaa4df4e08791
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:48 2015 -0700

    staging: comedi: cb_pcidas: tidy up caldac_8800_write()
    
    Rename this function so it has namespace associated with the driver.
    
    For aesthetics, remove the 'static const' local variables. They don't
    add any significant value.
    
    Remove the 'bitstream' local variable. Change the type of the 'value'
    param to match the callers type and write_calibration_bitstream()'s
    type.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3c1a747ea1ad..fb10fe6d3806 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -552,21 +552,22 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 	}
 }
 
-static void caldac_8800_write(struct comedi_device *dev,
-			      unsigned int chan, u8 val)
+static void cb_pcidas_caldac_8800_write(struct comedi_device *dev,
+					unsigned int chan, unsigned int val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	static const int bitstream_length = 11;
-	unsigned int bitstream = ((chan & 0x7) << 8) | val;
-	static const int caldac_8800_udelay = 1;
 
-	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
-				    bitstream_length);
+	/* write 11-bit value */
+	write_calibration_bitstream(dev, cal_enable_bits(dev),
+				    ((chan & 0x7) << 8) | val, 11);
+	udelay(1);
 
-	udelay(caldac_8800_udelay);
+	/* select caldac */
 	outw(cal_enable_bits(dev) | PCIDAS_CALIB_8800_SEL,
 	     devpriv->pcibar1 + PCIDAS_CALIB_REG);
-	udelay(caldac_8800_udelay);
+	udelay(1);
+
+	/* latch value */
 	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
 }
 
@@ -581,7 +582,7 @@ static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 		unsigned int val = data[insn->n - 1];
 
 		if (s->readback[chan] != val) {
-			caldac_8800_write(dev, chan, val);
+			cb_pcidas_caldac_8800_write(dev, chan, val);
 			s->readback[chan] = val;
 		}
 	}
@@ -1431,7 +1432,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	for (i = 0; i < s->n_chan; i++) {
-		caldac_8800_write(dev, i, s->maxdata / 2);
+		cb_pcidas_caldac_8800_write(dev, i, s->maxdata / 2);
 		s->readback[i] = s->maxdata / 2;
 	}
 

commit 6eb2455dcf1353408c7525ad8617314b3c084efc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:47 2015 -0700

    staging: comedi: cb_pcidas: tidy up trimpot_8402_write()
    
    Rename this function so it has namespace associated with the driver.
    Change the return type to void, it always returns '0' and the return
    value is never checked.
    
    For aesthetics, remove the 'static const' local variables. They don't
    add any significant value.
    
    Remove the 'bitstream' local variable. The 'value' passed to this
    function will always be in the correct range due to s->maxdata so
    the masking is not necessary. Change the type of the 'value' param
    to match the callers type and write_calibration_bitstream()'s type.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 84bc3defcc2d..3c1a747ea1ad 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -645,26 +645,24 @@ static void cb_pcidas_trimpot_7376_write(struct comedi_device *dev,
 	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
 }
 
-static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-			      u8 value)
+static void cb_pcidas_trimpot_8402_write(struct comedi_device *dev,
+					 unsigned int chan, unsigned int val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	static const int bitstream_length = 10;
-	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
-	unsigned int register_bits;
-	static const int ad8402_udelay = 1;
+	unsigned int calib_bits;
 
-	register_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
-	udelay(ad8402_udelay);
-	outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	/* select trimpot */
+	calib_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
+	udelay(1);
+	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
-	write_calibration_bitstream(dev, register_bits, bitstream,
-				    bitstream_length);
+	/* write 10-bit value */
+	write_calibration_bitstream(dev, calib_bits,
+				    ((chan & 0x3) << 8) | val, 10);
+	udelay(1);
 
-	udelay(ad8402_udelay);
+	/* latch value */
 	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
-
-	return 0;
 }
 
 static void cb_pcidas_trimpot_write(struct comedi_device *dev,
@@ -677,7 +675,7 @@ static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 		cb_pcidas_trimpot_7376_write(dev, val);
 		break;
 	case AD8402:
-		trimpot_8402_write(dev, chan, val);
+		cb_pcidas_trimpot_8402_write(dev, chan, val);
 		break;
 	default:
 		dev_err(dev->class_dev, "driver bug?\n");

commit 8c11f4772c54d9bea4448ae9de1d4b99695ee72a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:46 2015 -0700

    staging: comedi: cb_pcidas: tidy up trimpot_7376_write()
    
    Rename this function so it has namespace associated with the driver.
    Change the return type to void, it always returns '0' and the return
    value is never checked.
    
    For aesthetics, remove the 'static const' local variables. They don't
    add any significant value.
    
    Remove the 'bitstream' local variable. The 'value' passed to this
    function will always be in the correct range due to s->maxdata so
    the masking is not necessary. Change the type of the 'value' param
    to match the callers type and write_calibration_bitstream()'s type.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 99a95c2ccaa9..84bc3defcc2d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -626,25 +626,23 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int trimpot_7376_write(struct comedi_device *dev, u8 value)
+static void cb_pcidas_trimpot_7376_write(struct comedi_device *dev,
+					 unsigned int val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	static const int bitstream_length = 7;
-	unsigned int bitstream = value & 0x7f;
-	unsigned int register_bits;
-	static const int ad7376_udelay = 1;
+	unsigned int calib_bits;
 
-	register_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
-	udelay(ad7376_udelay);
-	outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
+	/* select trimpot */
+	calib_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
+	udelay(1);
+	outw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
-	write_calibration_bitstream(dev, register_bits, bitstream,
-				    bitstream_length);
+	/* write 7-bit value */
+	write_calibration_bitstream(dev, calib_bits, val, 7);
+	udelay(1);
 
-	udelay(ad7376_udelay);
+	/* latch value */
 	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
-
-	return 0;
 }
 
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
@@ -676,7 +674,7 @@ static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 
 	switch (board->trimpot) {
 	case AD7376:
-		trimpot_7376_write(dev, val);
+		cb_pcidas_trimpot_7376_write(dev, val);
 		break;
 	case AD8402:
 		trimpot_8402_write(dev, chan, val);

commit 19ce5d61528a464d97f7cfa17f01bcdc86ded8ae
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:45 2015 -0700

    staging: comedi: cb_pcidas: tidy up calibration trimpot subdevice
    
    For aesthetics, add some whitespace to the subdevice init.
    
    It's not possible to actually read from the trimpot. For convienence
    the subdevice readback provided by the core is used to return the
    last value written to the subdevice. Remove the SDF_READABLE flag
    from the subdev_flags.
    
    Move the comment about the channels from trimpot_8402_write() to
    the subdevice init and fix the checkpatch.pl issue about:
    
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2df80f6631f1..99a95c2ccaa9 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -647,9 +647,6 @@ static int trimpot_7376_write(struct comedi_device *dev, u8 value)
 	return 0;
 }
 
-/* For 1602/16 only
- * ch 0 : adc gain
- * ch 1 : adc postgain offset */
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 			      u8 value)
 {
@@ -1442,18 +1439,23 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->readback[i] = s->maxdata / 2;
 	}
 
-	/*  trim potentiometer */
+	/* Calibration subdevice - trim potentiometer */
 	s = &dev->subdevices[5];
-	s->type = COMEDI_SUBD_CALIB;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->type		= COMEDI_SUBD_CALIB;
+	s->subdev_flags	= SDF_WRITABLE | SDF_INTERNAL;
 	if (board->trimpot == AD7376) {
-		s->n_chan = 1;
-		s->maxdata = 0x7f;
-	} else {
-		s->n_chan = 2;
-		s->maxdata = 0xff;
+		s->n_chan	= 1;
+		s->maxdata	= 0x7f;
+	} else {	/* AD8402 */
+		/*
+		 * For pci-das1602/16:
+		 *   chan 0 : adc gain
+		 *   chan 1 : adc postgain offset
+		 */
+		s->n_chan	= 2;
+		s->maxdata	= 0xff;
 	}
-	s->insn_write = cb_pcidas_trimpot_insn_write;
+	s->insn_write	= cb_pcidas_trimpot_insn_write;
 
 	ret = comedi_alloc_subdev_readback(s);
 	if (ret)

commit 53cb50aae6fea6af83bde3c773a34abf3469377c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:44 2015 -0700

    staging: comedi: cb_pcidas: use preferred kernel types
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2eae7054067f..2df80f6631f1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -493,7 +493,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 }
 
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-		      uint8_t *data)
+		      u8 *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long iobase = devpriv->s5933_config;
@@ -521,7 +521,7 @@ static int eeprom_read_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	uint8_t nvram_data;
+	u8 nvram_data;
 	int retval;
 
 	retval = nvram_read(dev, CR_CHAN(insn->chanspec), &nvram_data);
@@ -553,7 +553,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 }
 
 static void caldac_8800_write(struct comedi_device *dev,
-			      unsigned int chan, uint8_t val)
+			      unsigned int chan, u8 val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 11;
@@ -626,7 +626,7 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
+static int trimpot_7376_write(struct comedi_device *dev, u8 value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 7;
@@ -651,7 +651,7 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
  * ch 0 : adc gain
  * ch 1 : adc postgain offset */
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-			      uint8_t value)
+			      u8 value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 10;

commit be3a7688753b18986c10de5fb99a40b9c639cc59
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:43 2015 -0700

    staging: comedi: cb_pcidas: tidy up DAC control/status register
    
    Rename this register and its bit defines so they have namespace
    associated with the driver. Use the BIT macro to define the bits.
    
    For aesthetics, rename the associated member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 751cb6fd3313..2eae7054067f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -133,22 +133,21 @@
 #define PCIDAS_CALIB_EN		BIT(14)	/* calibration source enable */
 #define PCIDAS_CALIB_DATA	BIT(15)	/* serial data bit going to caldac */
 
-#define DAC_CSR			0x8	/* dac control and status register */
-#define   DACEN			0x02	/* dac enable */
-#define   DAC_MODE_UPDATE_BOTH	0x80	/* update both dacs */
-
-#define   DAC_RANGE(c, r)	(((r) & 0x3) << (8 + 2 * ((c) & 0x1)))
-#define   DAC_RANGE_MASK(c)	DAC_RANGE((c), 0x3)
-
-/* bits for 1602 series only */
-#define   DAC_EMPTY		0x1	/* fifo empty, read, write clear */
-#define   DAC_START		0x4	/* start/arm fifo operations */
-#define   DAC_PACER_MASK	0x18	/* bits that set pacer source */
-#define   DAC_PACER_INT		0x8	/* int. pacing */
-#define   DAC_PACER_EXT_FALL	0x10	/* ext. pacing, falling edge */
-#define   DAC_PACER_EXT_RISE	0x18	/* ext. pacing, rising edge */
-
-#define   DAC_CHAN_EN(c)	BIT(5 + ((c) & 0x1))
+#define PCIDAS_AO_REG		0x08	/* dac control and status register */
+#define PCIDAS_AO_EMPTY		BIT(0)	/* fifo empty, write clear (1602) */
+#define PCIDAS_AO_DACEN		BIT(1)	/* dac enable */
+#define PCIDAS_AO_START		BIT(2)	/* start/arm fifo (1602) */
+#define PCIDAS_AO_PACER(x)	(((x) & 0x3) << 3) /* (1602) */
+#define PCIDAS_AO_PACER_SW	PCIDAS_AO_PACER(0) /* software pacer */
+#define PCIDAS_AO_PACER_INT	PCIDAS_AO_PACER(1) /* int. pacer */
+#define PCIDAS_AO_PACER_EXTN	PCIDAS_AO_PACER(2) /* ext. falling edge */
+#define PCIDAS_AO_PACER_EXTP	PCIDAS_AO_PACER(3) /* ext. rising edge */
+#define PCIDAS_AO_PACER_MASK	PCIDAS_AO_PACER(3) /* pacer source bits */
+#define PCIDAS_AO_CHAN_EN(c)	BIT(5 + ((c) & 0x1))
+#define PCIDAS_AO_CHAN_MASK	(PCIDAS_AO_CHAN_EN(0) | PCIDAS_AO_CHAN_EN(1))
+#define PCIDAS_AO_UPDATE_BOTH	BIT(7)	/* update both dacs */
+#define PCIDAS_AO_RANGE(c, r)	(((r) & 0x3) << (8 + 2 * ((c) & 0x1)))
+#define PCIDAS_AO_RANGE_MASK(c)	PCIDAS_AO_RANGE((c), 0x3)
 
 /*
  * PCI BAR2 Register map (devpriv->pcibar2)
@@ -316,7 +315,7 @@ struct cb_pcidas_private {
 	/* bits to write to registers */
 	unsigned int ctrl;
 	unsigned int s5933_intcsr_bits;
-	unsigned int ao_control_bits;
+	unsigned int ao_ctrl;
 	/* fifo buffers */
 	unsigned short ai_buffer[AI_BUFFER_SIZE];
 	unsigned short ao_buffer[AO_BUFFER_SIZE];
@@ -432,10 +431,10 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 
 	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->ao_control_bits &= (~DAC_MODE_UPDATE_BOTH &
-				     ~DAC_RANGE_MASK(chan));
-	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range));
-	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
+	devpriv->ao_ctrl &= ~(PCIDAS_AO_UPDATE_BOTH |
+			      PCIDAS_AO_RANGE_MASK(chan));
+	devpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range);
+	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
@@ -462,11 +461,11 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 
 	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->ao_control_bits &= (~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) &
-				     ~DAC_RANGE_MASK(chan) & ~DAC_PACER_MASK);
-	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range) |
-				     DAC_CHAN_EN(chan) | DAC_START);
-	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
+	devpriv->ao_ctrl &= ~(PCIDAS_AO_CHAN_MASK | PCIDAS_AO_RANGE_MASK(chan) |
+			      PCIDAS_AO_PACER_MASK);
+	devpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range) |
+			    PCIDAS_AO_CHAN_EN(chan) | PCIDAS_AO_START;
+	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
@@ -1083,8 +1082,8 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
 	/*  start dac */
-	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
-	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
+	devpriv->ao_ctrl |= PCIDAS_AO_START | PCIDAS_AO_DACEN | PCIDAS_AO_EMPTY;
+	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1109,13 +1108,13 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 		unsigned int range = CR_RANGE(cmd->chanlist[i]);
 
 		/*  enable channel */
-		devpriv->ao_control_bits |= DAC_CHAN_EN(chan);
+		devpriv->ao_ctrl |= PCIDAS_AO_CHAN_EN(chan);
 		/*  set range */
-		devpriv->ao_control_bits |= DAC_RANGE(chan, range);
+		devpriv->ao_ctrl |= PCIDAS_AO_RANGE(chan, range);
 	}
 
 	/*  disable analog out before settings pacer source and count values */
-	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
+	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
@@ -1131,10 +1130,10 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
-		devpriv->ao_control_bits |= DAC_PACER_INT;
+		devpriv->ao_ctrl |= PCIDAS_AO_PACER_INT;
 		break;
 	case TRIG_EXT:
-		devpriv->ao_control_bits |= DAC_PACER_EXT_RISE;
+		devpriv->ao_ctrl |= PCIDAS_AO_PACER_EXTP;
 		break;
 	default:
 		spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -1161,8 +1160,8 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	outw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
 	/*  disable output */
-	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
-	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
+	devpriv->ao_ctrl &= ~(PCIDAS_AO_DACEN | PCIDAS_AO_PACER_MASK);
+	outw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
@@ -1183,7 +1182,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		outw(devpriv->ctrl | PCIDAS_CTRL_DAEMI,
 		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		if (inw(devpriv->pcibar4 + DAC_CSR) & DAC_EMPTY) {
+		if (inw(devpriv->pcibar4 + PCIDAS_AO_REG) & PCIDAS_AO_EMPTY) {
 			if (cmd->stop_src == TRIG_COUNT &&
 			    async->scans_done >= cmd->stop_arg) {
 				async->events |= COMEDI_CB_EOA;

commit 21b6476af98672f8c784a40817793fe17504f978
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:42 2015 -0700

    staging: comedi: cb_pcidas: tidy up calibration register
    
    Rename this register and its bit defines so they have namespace
    associated with the driver. Use the BIT macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 423a2e1fc307..751cb6fd3313 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -125,13 +125,13 @@
 #define PCIDAS_TRIG_BURSTE	BIT(5)	/* burst mode enable */
 #define PCIDAS_TRIG_CLR		BIT(7)	/* clear external trigger */
 
-#define CALIBRATION_REG		6	/* CALIBRATION register */
-#define   SELECT_8800_BIT	0x100	/* select 8800 caldac */
-#define   SELECT_TRIMPOT_BIT	0x200	/* select ad7376 trim pot */
-#define   SELECT_DAC08_BIT	0x400	/* select dac08 caldac */
-#define   CAL_SRC_BITS(x)	(((x) & 0x7) << 11)
-#define   CAL_EN_BIT		0x4000	/* calibration source enable */
-#define   SERIAL_DATA_IN_BIT	0x8000	/* serial data bit going to caldac */
+#define PCIDAS_CALIB_REG	0x06	/* CALIBRATION register */
+#define PCIDAS_CALIB_8800_SEL	BIT(8)	/* select 8800 caldac */
+#define PCIDAS_CALIB_TRIM_SEL	BIT(9)	/* select ad7376 trim pot */
+#define PCIDAS_CALIB_DAC08_SEL	BIT(10)	/* select dac08 caldac */
+#define PCIDAS_CALIB_SRC(x)	(((x) & 0x7) << 11)
+#define PCIDAS_CALIB_EN		BIT(14)	/* calibration source enable */
+#define PCIDAS_CALIB_DATA	BIT(15)	/* serial data bit going to caldac */
 
 #define DAC_CSR			0x8	/* dac control and status register */
 #define   DACEN			0x02	/* dac enable */
@@ -327,7 +327,7 @@ static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
+	return PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calibration_source);
 }
 
 static int cb_pcidas_ai_eoc(struct comedi_device *dev,
@@ -359,10 +359,10 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	/* enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
-		     devpriv->pcibar1 + CALIBRATION_REG);
+		     devpriv->pcibar1 + PCIDAS_CALIB_REG);
 		chan = 0;
 	} else {
-		outw(0, devpriv->pcibar1 + CALIBRATION_REG);
+		outw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	}
 
 	/* set mux limits and gain */
@@ -545,11 +545,11 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 
 	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
 		if (bitstream & bit)
-			register_bits |= SERIAL_DATA_IN_BIT;
+			register_bits |= PCIDAS_CALIB_DATA;
 		else
-			register_bits &= ~SERIAL_DATA_IN_BIT;
+			register_bits &= ~PCIDAS_CALIB_DATA;
 		udelay(write_delay);
-		outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
+		outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	}
 }
 
@@ -565,10 +565,10 @@ static void caldac_8800_write(struct comedi_device *dev,
 				    bitstream_length);
 
 	udelay(caldac_8800_udelay);
-	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
-	     devpriv->pcibar1 + CALIBRATION_REG);
+	outw(cal_enable_bits(dev) | PCIDAS_CALIB_8800_SEL,
+	     devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(caldac_8800_udelay);
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
 }
 
 static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
@@ -599,12 +599,12 @@ static void dac08_write(struct comedi_device *dev, unsigned int value)
 	value |= cal_enable_bits(dev);
 
 	/* latch the new value into the caldac */
-	outw(value, devpriv->pcibar1 + CALIBRATION_REG);
+	outw(value, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
-	outw(value | SELECT_DAC08_BIT,
-	     devpriv->pcibar1 + CALIBRATION_REG);
+	outw(value | PCIDAS_CALIB_DAC08_SEL,
+	     devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
-	outw(value, devpriv->pcibar1 + CALIBRATION_REG);
+	outw(value, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	udelay(1);
 }
 
@@ -635,15 +635,15 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 	unsigned int register_bits;
 	static const int ad7376_udelay = 1;
 
-	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	register_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
 	udelay(ad7376_udelay);
-	outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
+	outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 				    bitstream_length);
 
 	udelay(ad7376_udelay);
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
 	return 0;
 }
@@ -660,15 +660,15 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int register_bits;
 	static const int ad8402_udelay = 1;
 
-	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	register_bits = cal_enable_bits(dev) | PCIDAS_CALIB_TRIM_SEL;
 	udelay(ad8402_udelay);
-	outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
+	outw(register_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 				    bitstream_length);
 
 	udelay(ad8402_udelay);
-	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + PCIDAS_CALIB_REG);
 
 	return 0;
 }
@@ -858,8 +858,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	unsigned int bits;
 	unsigned long flags;
 
-	/*  make sure CAL_EN_BIT is disabled */
-	outw(0, devpriv->pcibar1 + CALIBRATION_REG);
+	/*  make sure PCIDAS_CALIB_EN is disabled */
+	outw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);
 	/*  initialize before settings pacer source and count values */
 	outw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);
 	/*  clear fifo */

commit 1a55808d6245a294d1785778de7d80cab3d14136
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:41 2015 -0700

    staging: comedi: cb_pcidas: tidy up trigger control/status register
    
    Rename this register and its bit defines so they have namespace
    associated with the driver. Use the BIT macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 72395ea2876c..423a2e1fc307 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -112,16 +112,18 @@
 #define PCIDAS_AI_PACER_MASK	PCIDAS_AI_PACER(3) /* pacer source bits */
 #define PCIDAS_AI_EOC		BIT(14)	/* adc not busy */
 
-#define TRIG_CONTSTAT		 4	/* TRIGGER CONTROL/STATUS register */
-#define   SW_TRIGGER		0x1	/* software start trigger */
-#define   EXT_TRIGGER		0x2	/* ext. start trigger */
-#define   ANALOG_TRIGGER	0x3	/* ext. analog trigger */
-#define   TRIGGER_MASK		0x3	/* start trigger mask */
-#define   TGPOL			0x04	/* invert trigger (1602 only) */
-#define   TGSEL			0x08	/* edge/level trigerred (1602 only) */
-#define   TGEN			0x10	/* enable external start trigger */
-#define   BURSTE		0x20	/* burst mode enable */
-#define   XTRCL			0x80	/* clear external trigger */
+#define PCIDAS_TRIG_REG		0x04	/* TRIGGER CONTROL/STATUS register */
+#define PCIDAS_TRIG_SEL(x)	(((x) & 0x3) << 0)
+#define PCIDAS_TRIG_SEL_NONE	PCIDAS_TRIG_SEL(0) /* no start trigger */
+#define PCIDAS_TRIG_SEL_SW	PCIDAS_TRIG_SEL(1) /* software start trigger */
+#define PCIDAS_TRIG_SEL_EXT	PCIDAS_TRIG_SEL(2) /* ext. start trigger */
+#define PCIDAS_TRIG_SEL_ANALOG	PCIDAS_TRIG_SEL(3) /* ext. analog trigger */
+#define PCIDAS_TRIG_SEL_MASK	PCIDAS_TRIG_SEL(3) /* start trigger mask */
+#define PCIDAS_TRIG_POL		BIT(2)	/* invert trigger (1602 only) */
+#define PCIDAS_TRIG_MODE	BIT(3)	/* edge/level trigerred (1602 only) */
+#define PCIDAS_TRIG_EN		BIT(4)	/* enable external start trigger */
+#define PCIDAS_TRIG_BURSTE	BIT(5)	/* burst mode enable */
+#define PCIDAS_TRIG_CLR		BIT(7)	/* clear external trigger */
 
 #define CALIBRATION_REG		6	/* CALIBRATION register */
 #define   SELECT_8800_BIT	0x100	/* select 8800 caldac */
@@ -859,7 +861,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	/*  make sure CAL_EN_BIT is disabled */
 	outw(0, devpriv->pcibar1 + CALIBRATION_REG);
 	/*  initialize before settings pacer source and count values */
-	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
+	outw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);
 	/*  clear fifo */
 	outw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);
 
@@ -913,19 +915,19 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	/*  set start trigger and burst mode */
 	bits = 0;
 	if (cmd->start_src == TRIG_NOW) {
-		bits |= SW_TRIGGER;
+		bits |= PCIDAS_TRIG_SEL_SW;
 	} else {	/* TRIG_EXT */
-		bits |= EXT_TRIGGER | TGEN | XTRCL;
+		bits |= PCIDAS_TRIG_SEL_EXT | PCIDAS_TRIG_EN | PCIDAS_TRIG_CLR;
 		if (board->is_1602) {
 			if (cmd->start_arg & CR_INVERT)
-				bits |= TGPOL;
+				bits |= PCIDAS_TRIG_POL;
 			if (cmd->start_arg & CR_EDGE)
-				bits |= TGSEL;
+				bits |= PCIDAS_TRIG_MODE;
 		}
 	}
 	if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
-		bits |= BURSTE;
-	outw(bits, devpriv->pcibar1 + TRIG_CONTSTAT);
+		bits |= PCIDAS_TRIG_BURSTE;
+	outw(bits, devpriv->pcibar1 + PCIDAS_TRIG_REG);
 
 	return 0;
 }
@@ -1036,7 +1038,7 @@ static int cb_pcidas_cancel(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable start trigger source and burst mode */
-	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
+	outw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);
 	outw(PCIDAS_AI_PACER_SW, devpriv->pcibar1 + PCIDAS_AI_REG);
 
 	return 0;

commit 1f9cb9424e406551e32cd203c2fab37c00943935
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:40 2015 -0700

    staging: comedi: cb_pcidas: tidy up ADC mux/control register
    
    Rename this register and its bit defines so they have namespace
    associated with the driver. Use the BIT macro to define the bits.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 830904659a66..72395ea2876c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -97,17 +97,20 @@
 #define PCIDAS_CTRL_LADFUL	BIT(13)	/* fifo overflow / clear */
 #define PCIDAS_CTRL_DAEMI	BIT(14)	/* dac fifo empty int status / clear */
 
-#define ADCMUX_CONT		2	/* ADC CHANNEL MUX AND CONTROL reg */
-#define   BEGIN_SCAN(x)		((x) & 0xf)
-#define   END_SCAN(x)		(((x) & 0xf) << 4)
-#define   GAIN_BITS(x)		(((x) & 0x3) << 8)
-#define   UNIP			0x800	/* Analog front-end unipolar mode */
-#define   SE			0x400	/* Inputs in single-ended mode */
-#define   PACER_MASK		0x3000	/* pacer source bits */
-#define   PACER_INT		0x1000	/* int. pacer */
-#define   PACER_EXT_FALL	0x2000	/* ext. falling edge */
-#define   PACER_EXT_RISE	0x3000	/* ext. rising edge */
-#define   EOC			0x4000	/* adc not busy */
+#define PCIDAS_AI_REG		0x02	/* ADC CHANNEL MUX AND CONTROL reg */
+#define PCIDAS_AI_FIRST(x)	((x) & 0xf)
+#define PCIDAS_AI_LAST(x)	(((x) & 0xf) << 4)
+#define PCIDAS_AI_CHAN(x)	(PCIDAS_AI_FIRST(x) | PCIDAS_AI_LAST(x))
+#define PCIDAS_AI_GAIN(x)	(((x) & 0x3) << 8)
+#define PCIDAS_AI_SE		BIT(10)	/* Inputs in single-ended mode */
+#define PCIDAS_AI_UNIP		BIT(11)	/* Analog front-end unipolar mode */
+#define PCIDAS_AI_PACER(x)	(((x) & 0x3) << 12)
+#define PCIDAS_AI_PACER_SW	PCIDAS_AI_PACER(0) /* software pacer */
+#define PCIDAS_AI_PACER_INT	PCIDAS_AI_PACER(1) /* int. pacer */
+#define PCIDAS_AI_PACER_EXTN	PCIDAS_AI_PACER(2) /* ext. falling edge */
+#define PCIDAS_AI_PACER_EXTP	PCIDAS_AI_PACER(3) /* ext. rising edge */
+#define PCIDAS_AI_PACER_MASK	PCIDAS_AI_PACER(3) /* pacer source bits */
+#define PCIDAS_AI_EOC		BIT(14)	/* adc not busy */
 
 #define TRIG_CONTSTAT		 4	/* TRIGGER CONTROL/STATUS register */
 #define   SW_TRIGGER		0x1	/* software start trigger */
@@ -333,8 +336,8 @@ static int cb_pcidas_ai_eoc(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int status;
 
-	status = inw(devpriv->pcibar1 + ADCMUX_CONT);
-	if (status & EOC)
+	status = inw(devpriv->pcibar1 + PCIDAS_AI_REG);
+	if (status & PCIDAS_AI_EOC)
 		return 0;
 	return -EBUSY;
 }
@@ -361,14 +364,14 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	}
 
 	/* set mux limits and gain */
-	bits = BEGIN_SCAN(chan) | END_SCAN(chan) | GAIN_BITS(range);
+	bits = PCIDAS_AI_CHAN(chan) | PCIDAS_AI_GAIN(range);
 	/* set unipolar/bipolar */
 	if (comedi_range_is_unipolar(s, range))
-		bits |= UNIP;
+		bits |= PCIDAS_AI_UNIP;
 	/* set single-ended/differential */
 	if (aref != AREF_DIFF)
-		bits |= SE;
-	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
+		bits |= PCIDAS_AI_SE;
+	outw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);
 
 	/* clear fifo */
 	outw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);
@@ -861,21 +864,21 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	outw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);
 
 	/*  set mux limits, gain and pacer source */
-	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
-	    END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
-	    GAIN_BITS(range0);
+	bits = PCIDAS_AI_FIRST(CR_CHAN(cmd->chanlist[0])) |
+	       PCIDAS_AI_LAST(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
+	       PCIDAS_AI_GAIN(range0);
 	/*  set unipolar/bipolar */
 	if (comedi_range_is_unipolar(s, range0))
-		bits |= UNIP;
+		bits |= PCIDAS_AI_UNIP;
 	/*  set singleended/differential */
 	if (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)
-		bits |= SE;
+		bits |= PCIDAS_AI_SE;
 	/*  set pacer source */
 	if (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)
-		bits |= PACER_EXT_RISE;
+		bits |= PCIDAS_AI_PACER_EXTP;
 	else
-		bits |= PACER_INT;
-	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
+		bits |= PCIDAS_AI_PACER_INT;
+	outw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER ||
@@ -1034,8 +1037,7 @@ static int cb_pcidas_cancel(struct comedi_device *dev,
 
 	/*  disable start trigger source and burst mode */
 	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
-	/*  software pacer source */
-	outw(0, devpriv->pcibar1 + ADCMUX_CONT);
+	outw(PCIDAS_AI_PACER_SW, devpriv->pcibar1 + PCIDAS_AI_REG);
 
 	return 0;
 }

commit 56a160b0ca481c6f2b56894b5a43862b0103fd93
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:39 2015 -0700

    staging: comedi: cb_pcidas: tidy up interrupt/ADC FIFO register
    
    Rename this register and its bit defines so they have namespace
    associated with the driver. Use the BIT macro to define the bits.
    
    For aesthetics, rename the associated member of the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 8ed747da613f..830904659a66 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -76,24 +76,26 @@
 /*
  * PCI BAR1 Register map (devpriv->pcibar1)
  */
-#define INT_ADCFIFO		0	/* INTERRUPT / ADC FIFO register */
-#define   INT_EOS		0x1	/* int end of scan */
-#define   INT_FHF		0x2	/* int fifo half full */
-#define   INT_FNE		0x3	/* int fifo not empty */
-#define   INT_MASK		0x3	/* mask of int select bits */
-#define   INTE			0x4	/* int enable */
-#define   DAHFIE		0x8	/* dac half full int enable */
-#define   EOAIE			0x10	/* end of acq. int enable */
-#define   DAHFI			0x20	/* dac half full status / clear */
-#define   EOAI			0x40	/* end of acq. int status / clear */
-#define   INT			0x80	/* int status / clear */
-#define   EOBI			0x200	/* end of burst int status */
-#define   ADHFI			0x400	/* half-full int status */
-#define   ADNEI			0x800	/* fifo not empty int status (latch) */
-#define   ADNE			0x1000	/* fifo not empty status (realtime) */
-#define   DAEMIE		0x1000	/* dac empty int enable */
-#define   LADFUL		0x2000	/* fifo overflow / clear */
-#define   DAEMI			0x4000	/* dac fifo empty int status / clear */
+#define PCIDAS_CTRL_REG		0x00	/* INTERRUPT / ADC FIFO register */
+#define PCIDAS_CTRL_INT(x)	(((x) & 0x3) << 0)
+#define PCIDAS_CTRL_INT_NONE	PCIDAS_CTRL_INT(0) /* no int selected */
+#define PCIDAS_CTRL_INT_EOS	PCIDAS_CTRL_INT(1) /* int on end of scan */
+#define PCIDAS_CTRL_INT_FHF	PCIDAS_CTRL_INT(2) /* int on fifo half full */
+#define PCIDAS_CTRL_INT_FNE	PCIDAS_CTRL_INT(3) /* int on fifo not empty */
+#define PCIDAS_CTRL_INT_MASK	PCIDAS_CTRL_INT(3) /* mask of int select bits */
+#define PCIDAS_CTRL_INTE	BIT(2)	/* int enable */
+#define PCIDAS_CTRL_DAHFIE	BIT(3)	/* dac half full int enable */
+#define PCIDAS_CTRL_EOAIE	BIT(4)	/* end of acq. int enable */
+#define PCIDAS_CTRL_DAHFI	BIT(5)	/* dac half full status / clear */
+#define PCIDAS_CTRL_EOAI	BIT(6)	/* end of acq. int status / clear */
+#define PCIDAS_CTRL_INT_CLR	BIT(7)	/* int status / clear */
+#define PCIDAS_CTRL_EOBI	BIT(9)	/* end of burst int status */
+#define PCIDAS_CTRL_ADHFI	BIT(10)	/* half-full int status */
+#define PCIDAS_CTRL_ADNEI	BIT(11)	/* fifo not empty int status (latch) */
+#define PCIDAS_CTRL_ADNE	BIT(12)	/* fifo not empty status (realtime) */
+#define PCIDAS_CTRL_DAEMIE	BIT(12)	/* dac empty int enable */
+#define PCIDAS_CTRL_LADFUL	BIT(13)	/* fifo overflow / clear */
+#define PCIDAS_CTRL_DAEMI	BIT(14)	/* dac fifo empty int status / clear */
 
 #define ADCMUX_CONT		2	/* ADC CHANNEL MUX AND CONTROL reg */
 #define   BEGIN_SCAN(x)		((x) & 0xf)
@@ -307,7 +309,7 @@ struct cb_pcidas_private {
 	unsigned long pcibar2;
 	unsigned long pcibar4;
 	/* bits to write to registers */
-	unsigned int adc_fifo_bits;
+	unsigned int ctrl;
 	unsigned int s5933_intcsr_bits;
 	unsigned int ao_control_bits;
 	/* fifo buffers */
@@ -884,24 +886,25 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 
 	/*  enable interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->adc_fifo_bits |= INTE;
-	devpriv->adc_fifo_bits &= ~INT_MASK;
+	devpriv->ctrl |= PCIDAS_CTRL_INTE;
+	devpriv->ctrl &= ~PCIDAS_CTRL_INT_MASK;
 	if (cmd->flags & CMDF_WAKE_EOS) {
 		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {
 			/* interrupt end of burst */
-			devpriv->adc_fifo_bits |= INT_EOS;
+			devpriv->ctrl |= PCIDAS_CTRL_INT_EOS;
 		} else {
 			/* interrupt fifo not empty */
-			devpriv->adc_fifo_bits |= INT_FNE;
+			devpriv->ctrl |= PCIDAS_CTRL_INT_FNE;
 		}
 	} else {
 		/* interrupt fifo half full */
-		devpriv->adc_fifo_bits |= INT_FHF;
+		devpriv->ctrl |= PCIDAS_CTRL_INT_FHF;
 	}
 
 	/*  enable (and clear) interrupts */
-	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
-	     devpriv->pcibar1 + INT_ADCFIFO);
+	outw(devpriv->ctrl |
+	     PCIDAS_CTRL_EOAI | PCIDAS_CTRL_INT_CLR | PCIDAS_CTRL_LADFUL,
+	     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
@@ -1025,8 +1028,8 @@ static int cb_pcidas_cancel(struct comedi_device *dev,
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
-	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
-	outw(devpriv->adc_fifo_bits, devpriv->pcibar1 + INT_ADCFIFO);
+	devpriv->ctrl &= ~(PCIDAS_CTRL_INTE | PCIDAS_CTRL_EOAIE);
+	outw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable start trigger source and burst mode */
@@ -1069,11 +1072,11 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 
 	/*  enable dac half-full and empty interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
+	devpriv->ctrl |= PCIDAS_CTRL_DAEMIE | PCIDAS_CTRL_DAHFIE;
 
 	/*  enable and clear interrupts */
-	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
-	     devpriv->pcibar1 + INT_ADCFIFO);
+	outw(devpriv->ctrl | PCIDAS_CTRL_DAEMI | PCIDAS_CTRL_DAHFI,
+	     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
 	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
@@ -1150,8 +1153,8 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
-	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
-	outw(devpriv->adc_fifo_bits, devpriv->pcibar1 + INT_ADCFIFO);
+	devpriv->ctrl &= ~(PCIDAS_CTRL_DAHFIE | PCIDAS_CTRL_DAEMIE);
+	outw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
 	/*  disable output */
 	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
@@ -1170,11 +1173,11 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long flags;
 
-	if (status & DAEMI) {
+	if (status & PCIDAS_CTRL_DAEMI) {
 		/*  clear dac empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | DAEMI,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_DAEMI,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->pcibar4 + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_COUNT &&
@@ -1185,13 +1188,13 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 				async->events |= COMEDI_CB_ERROR;
 			}
 		}
-	} else if (status & DAHFI) {
+	} else if (status & PCIDAS_CTRL_DAHFI) {
 		cb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);
 
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | DAHFI,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_DAHFI,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
@@ -1229,14 +1232,14 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	status = inw(devpriv->pcibar1 + INT_ADCFIFO);
+	status = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);
 
 	/*  check for analog output interrupt */
-	if (status & (DAHFI | DAEMI))
+	if (status & (PCIDAS_CTRL_DAHFI | PCIDAS_CTRL_DAEMI))
 		handle_ao_interrupt(dev, status);
 	/*  check for analog input interrupts */
 	/*  if fifo half-full */
-	if (status & ADHFI) {
+	if (status & PCIDAS_CTRL_ADHFI) {
 		/*  read data */
 		num_samples = comedi_nsamples_left(s, half_fifo);
 		insw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,
@@ -1249,17 +1252,17 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | INT,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_INT_CLR,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
-	} else if (status & (ADNEI | EOBI)) {
+	} else if (status & (PCIDAS_CTRL_ADNEI | PCIDAS_CTRL_EOBI)) {
 		for (i = 0; i < timeout; i++) {
 			unsigned short val;
 
 			/*  break if fifo is empty */
-			if ((ADNE & inw(devpriv->pcibar1 +
-					INT_ADCFIFO)) == 0)
+			if ((inw(devpriv->pcibar1 + PCIDAS_CTRL_REG) &
+			    PCIDAS_CTRL_ADNE) == 0)
 				break;
 			val = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);
 			comedi_buf_write_samples(s, &val, 1);
@@ -1272,25 +1275,25 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		}
 		/*  clear not-empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | INT,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_INT_CLR,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-	} else if (status & EOAI) {
+	} else if (status & PCIDAS_CTRL_EOAI) {
 		dev_err(dev->class_dev,
 			"bug! encountered end of acquisition interrupt?\n");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | EOAI,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_EOAI,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
-	if (status & LADFUL) {
+	if (status & PCIDAS_CTRL_LADFUL) {
 		dev_err(dev->class_dev, "fifo overflow\n");
 		/*  clear overflow interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | LADFUL,
-		     devpriv->pcibar1 + INT_ADCFIFO);
+		outw(devpriv->ctrl | PCIDAS_CTRL_LADFUL,
+		     devpriv->pcibar1 + PCIDAS_CTRL_REG);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		async->events |= COMEDI_CB_ERROR;
 	}

commit f5c65f0298c9d2776f91a769ba880b4c6704b939
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:38 2015 -0700

    staging: comedi: cb_pcidas: convert inline DAC bit helpers to macros
    
    For aesthetics, convert the inline functions that return the bits
    used to set the DAC range and enable bits to macros.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 8a288ed3df87..8ed747da613f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -130,15 +130,8 @@
 #define   DACEN			0x02	/* dac enable */
 #define   DAC_MODE_UPDATE_BOTH	0x80	/* update both dacs */
 
-static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
-{
-	return (range & 0x3) << (8 + 2 * (channel & 0x1));
-}
-
-static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
-{
-	return 0x3 << (8 + 2 * (channel & 0x1));
-};
+#define   DAC_RANGE(c, r)	(((r) & 0x3) << (8 + 2 * ((c) & 0x1)))
+#define   DAC_RANGE_MASK(c)	DAC_RANGE((c), 0x3)
 
 /* bits for 1602 series only */
 #define   DAC_EMPTY		0x1	/* fifo empty, read, write clear */
@@ -148,10 +141,7 @@ static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 #define   DAC_PACER_EXT_FALL	0x10	/* ext. pacing, falling edge */
 #define   DAC_PACER_EXT_RISE	0x18	/* ext. pacing, rising edge */
 
-static inline unsigned int DAC_CHAN_EN(unsigned int channel)
-{
-	return 1 << (5 + (channel & 0x1));	/*  enable channel 0 or 1 */
-};
+#define   DAC_CHAN_EN(c)	BIT(5 + ((c) & 0x1))
 
 /*
  * PCI BAR2 Register map (devpriv->pcibar2)
@@ -1108,13 +1098,13 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	/*  set channel limits, gain */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	for (i = 0; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
 		/*  enable channel */
-		devpriv->ao_control_bits |=
-		    DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
+		devpriv->ao_control_bits |= DAC_CHAN_EN(chan);
 		/*  set range */
-		devpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),
-						      CR_RANGE(cmd->
-							       chanlist[i]));
+		devpriv->ao_control_bits |= DAC_RANGE(chan, range);
 	}
 
 	/*  disable analog out before settings pacer source and count values */

commit 964db7469f3b7cae5acd49f863fd612271322bf6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:37 2015 -0700

    staging: comedi: cb_pcidas: tidy up PCI BAR2 register defines
    
    Rename the defines for the PCI BAR2 register offsets so they have
    namespace associated with the driver and convert the offsets to
    hex.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index df4fd3c51174..8a288ed3df87 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -156,8 +156,8 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 /*
  * PCI BAR2 Register map (devpriv->pcibar2)
  */
-#define ADCDATA			0	/* ADC DATA register */
-#define ADCFIFOCLR		2	/* ADC FIFO CLEAR */
+#define PCIDAS_AI_DATA_REG	0x00
+#define PCIDAS_AI_FIFO_CLR_REG	0x02
 
 /*
  * PCI BAR3 Register map (dev->iobase)
@@ -379,12 +379,12 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
 
 	/* clear fifo */
-	outw(0, devpriv->pcibar2 + ADCFIFOCLR);
+	outw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
-		outw(0, devpriv->pcibar2 + ADCDATA);
+		outw(0, devpriv->pcibar2 + PCIDAS_AI_DATA_REG);
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);
@@ -392,7 +392,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			return ret;
 
 		/* read data */
-		data[n] = inw(devpriv->pcibar2 + ADCDATA);
+		data[n] = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);
 	}
 
 	/* return the number of samples read/written */
@@ -866,7 +866,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	/*  initialize before settings pacer source and count values */
 	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
 	/*  clear fifo */
-	outw(0, devpriv->pcibar2 + ADCFIFOCLR);
+	outw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);
 
 	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
@@ -1249,8 +1249,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	if (status & ADHFI) {
 		/*  read data */
 		num_samples = comedi_nsamples_left(s, half_fifo);
-		insw(devpriv->pcibar2 + ADCDATA, devpriv->ai_buffer,
-		     num_samples);
+		insw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,
+		     devpriv->ai_buffer, num_samples);
 		comedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);
 
 		if (cmd->stop_src == TRIG_COUNT &&
@@ -1271,7 +1271,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			if ((ADNE & inw(devpriv->pcibar1 +
 					INT_ADCFIFO)) == 0)
 				break;
-			val = inw(devpriv->pcibar2 + ADCDATA);
+			val = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);
 			comedi_buf_write_samples(s, &val, 1);
 
 			if (cmd->stop_src == TRIG_COUNT &&

commit 1532421f4128414aa1e86885de8377b28d5bb079
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:36 2015 -0700

    staging: comedi: cb_pcidas: tidy up PCI BAR3 register defines
    
    Rename the defines for the PCI BAR3 register offsets so they have
    namespace associated with the driver and convert the offsets to
    hex.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 5757dacec094..df4fd3c51174 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -159,10 +159,12 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 #define ADCDATA			0	/* ADC DATA register */
 #define ADCFIFOCLR		2	/* ADC FIFO CLEAR */
 
-/* pacer, counter, dio registers */
-#define ADC8254			0
-#define DIO_8255		4
-#define DAC8254			8
+/*
+ * PCI BAR3 Register map (dev->iobase)
+ */
+#define PCIDAS_AI_8254_BASE	0x00
+#define PCIDAS_8255_BASE	0x04
+#define PCIDAS_AO_8254_BASE	0x08
 
 /*
  * PCI BAR4 Register map (devpriv->pcibar4)
@@ -1353,12 +1355,12 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	}
 	dev->irq = pcidev->irq;
 
-	dev->pacer = comedi_8254_init(dev->iobase + ADC8254,
+	dev->pacer = comedi_8254_init(dev->iobase + PCIDAS_AI_8254_BASE,
 				      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);
 	if (!dev->pacer)
 		return -ENOMEM;
 
-	devpriv->ao_pacer = comedi_8254_init(dev->iobase + DAC8254,
+	devpriv->ao_pacer = comedi_8254_init(dev->iobase + PCIDAS_AO_8254_BASE,
 					     I8254_OSC_BASE_10MHZ,
 					     I8254_IO8, 0);
 	if (!devpriv->ao_pacer)
@@ -1415,7 +1417,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/* 8255 */
 	s = &dev->subdevices[2];
-	ret = subdev_8255_init(dev, s, NULL, DIO_8255);
+	ret = subdev_8255_init(dev, s, NULL, PCIDAS_8255_BASE);
 	if (ret)
 		return ret;
 

commit 19aab073245923e8b8b4876dbc2d0287e9e9f700
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:35 2015 -0700

    staging: comedi: cb_pcidas: use comedi_range_is_unipolar()
    
    Instead of relying on the IS_UNIPOLAR mask value, use the comedi
    helper function to check if the range is unipolar.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f5db76c50f5e..5757dacec094 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -171,8 +171,6 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 #define PCIDAS_AO_FIFO_REG	0x00
 #define PCIDAS_AO_FIFO_CLR_REG	0x02
 
-#define IS_UNIPOLAR		0x4	/* unipolar range mask */
-
 /* analog input ranges for most boards */
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8, {
@@ -371,7 +369,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	/* set mux limits and gain */
 	bits = BEGIN_SCAN(chan) | END_SCAN(chan) | GAIN_BITS(range);
 	/* set unipolar/bipolar */
-	if (range & IS_UNIPOLAR)
+	if (comedi_range_is_unipolar(s, range))
 		bits |= UNIP;
 	/* set single-ended/differential */
 	if (aref != AREF_DIFF)
@@ -857,6 +855,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
 	unsigned int bits;
 	unsigned long flags;
 
@@ -870,9 +869,9 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
 	    END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
-	    GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
+	    GAIN_BITS(range0);
 	/*  set unipolar/bipolar */
-	if (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)
+	if (comedi_range_is_unipolar(s, range0))
 		bits |= UNIP;
 	/*  set singleended/differential */
 	if (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)

commit 9846ec3a48e1ef4be619478d0822467dbfe79ec4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:34 2015 -0700

    staging: comedi: cb_pcidas: tidy up PCI BAR4 register defines
    
    Convert the inline function DAC_DATA_REG() into a simple macro.
    
    Rename the defines for the PCI BAR4 register offsets so they have
    namespace associated with the driver and convert the offsets to
    hex.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3c1b80a6f937..f5db76c50f5e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -167,16 +167,9 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 /*
  * PCI BAR4 Register map (devpriv->pcibar4)
  */
-
-/* analog output registers for 100x, 1200 series */
-static inline unsigned int DAC_DATA_REG(unsigned int channel)
-{
-	return 2 * (channel & 0x1);
-}
-
-/* analog output registers for 1602 series*/
-#define DACDATA			0	/* DAC DATA register */
-#define DACFIFOCLR		2	/* DAC FIFO CLEAR */
+#define PCIDAS_AO_DATA_REG(x)	(0x00 + ((x) * 2))
+#define PCIDAS_AO_FIFO_REG	0x00
+#define PCIDAS_AO_FIFO_CLR_REG	0x02
 
 #define IS_UNIPOLAR		0x4	/* unipolar range mask */
 
@@ -452,7 +445,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 	s->readback[chan] = data[0];
 
 	/* send data */
-	outw(data[0], devpriv->pcibar4 + DAC_DATA_REG(chan));
+	outw(data[0], devpriv->pcibar4 + PCIDAS_AO_DATA_REG(chan));
 
 	return insn->n;
 }
@@ -468,7 +461,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	unsigned long flags;
 
 	/* clear dac fifo */
-	outw(0, devpriv->pcibar4 + DACFIFOCLR);
+	outw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);
 
 	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -483,7 +476,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	s->readback[chan] = data[0];
 
 	/* send data */
-	outw(data[0], devpriv->pcibar4 + DACDATA);
+	outw(data[0], devpriv->pcibar4 + PCIDAS_AO_FIFO_REG);
 
 	return insn->n;
 }
@@ -1064,7 +1057,8 @@ static void cb_pcidas_ao_load_fifo(struct comedi_device *dev,
 	nbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);
 
 	nsamples = comedi_bytes_to_samples(s, nbytes);
-	outsw(devpriv->pcibar4 + DACDATA, devpriv->ao_buffer, nsamples);
+	outsw(devpriv->pcibar4 + PCIDAS_AO_FIFO_REG,
+	      devpriv->ao_buffer, nsamples);
 }
 
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
@@ -1127,7 +1121,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
-	outw(0, devpriv->pcibar4 + DACFIFOCLR);
+	outw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {

commit 71c1d717b3d0318edafc91c45e84140379c86e8d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:33 2015 -0700

    staging: comedi: cb_pcidas: rename private data 'ao_registers'
    
    This member of the private data holds the PCI BAR4 resource starting
    address. For aesthetics, rename this member to 'pcibar4'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 47827513b8ea..3c1b80a6f937 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -164,6 +164,10 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 #define DIO_8255		4
 #define DAC8254			8
 
+/*
+ * PCI BAR4 Register map (devpriv->pcibar4)
+ */
+
 /* analog output registers for 100x, 1200 series */
 static inline unsigned int DAC_DATA_REG(unsigned int channel)
 {
@@ -318,7 +322,7 @@ struct cb_pcidas_private {
 	unsigned long s5933_config;
 	unsigned long pcibar1;
 	unsigned long pcibar2;
-	unsigned long ao_registers;
+	unsigned long pcibar4;
 	/* bits to write to registers */
 	unsigned int adc_fifo_bits;
 	unsigned int s5933_intcsr_bits;
@@ -448,7 +452,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 	s->readback[chan] = data[0];
 
 	/* send data */
-	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(chan));
+	outw(data[0], devpriv->pcibar4 + DAC_DATA_REG(chan));
 
 	return insn->n;
 }
@@ -464,7 +468,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	unsigned long flags;
 
 	/* clear dac fifo */
-	outw(0, devpriv->ao_registers + DACFIFOCLR);
+	outw(0, devpriv->pcibar4 + DACFIFOCLR);
 
 	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -479,7 +483,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	s->readback[chan] = data[0];
 
 	/* send data */
-	outw(data[0], devpriv->ao_registers + DACDATA);
+	outw(data[0], devpriv->pcibar4 + DACDATA);
 
 	return insn->n;
 }
@@ -1060,7 +1064,7 @@ static void cb_pcidas_ao_load_fifo(struct comedi_device *dev,
 	nbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);
 
 	nsamples = comedi_bytes_to_samples(s, nbytes);
-	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, nsamples);
+	outsw(devpriv->pcibar4 + DACDATA, devpriv->ao_buffer, nsamples);
 }
 
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
@@ -1123,7 +1127,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
-	outw(0, devpriv->ao_registers + DACFIFOCLR);
+	outw(0, devpriv->pcibar4 + DACFIFOCLR);
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -1187,7 +1191,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		outw(devpriv->adc_fifo_bits | DAEMI,
 		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
+		if (inw(devpriv->pcibar4 + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_COUNT &&
 			    async->scans_done >= cmd->stop_arg) {
 				async->events |= COMEDI_CB_EOA;
@@ -1341,7 +1345,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	devpriv->pcibar2 = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
 	if (board->has_ao)
-		devpriv->ao_registers = pci_resource_start(pcidev, 4);
+		devpriv->pcibar4 = pci_resource_start(pcidev, 4);
 
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,

commit 800235b64ef3440a77af019a3f6ffd5a42cff785
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:32 2015 -0700

    staging: comedi: cb_pcidas: rename private data 'adc_fifo'
    
    This member of the private data holds the PCI BAR2 resource starting
    address. For aesthetics, rename this member to 'pcibar2'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3a17611173d0..47827513b8ea 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -153,7 +153,9 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 	return 1 << (5 + (channel & 0x1));	/*  enable channel 0 or 1 */
 };
 
-/* analog input fifo */
+/*
+ * PCI BAR2 Register map (devpriv->pcibar2)
+ */
 #define ADCDATA			0	/* ADC DATA register */
 #define ADCFIFOCLR		2	/* ADC FIFO CLEAR */
 
@@ -315,7 +317,7 @@ struct cb_pcidas_private {
 	/* base addresses */
 	unsigned long s5933_config;
 	unsigned long pcibar1;
-	unsigned long adc_fifo;
+	unsigned long pcibar2;
 	unsigned long ao_registers;
 	/* bits to write to registers */
 	unsigned int adc_fifo_bits;
@@ -380,12 +382,12 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
 
 	/* clear fifo */
-	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
+	outw(0, devpriv->pcibar2 + ADCFIFOCLR);
 
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 		/* trigger conversion */
-		outw(0, devpriv->adc_fifo + ADCDATA);
+		outw(0, devpriv->pcibar2 + ADCDATA);
 
 		/* wait for conversion to end */
 		ret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);
@@ -393,7 +395,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			return ret;
 
 		/* read data */
-		data[n] = inw(devpriv->adc_fifo + ADCDATA);
+		data[n] = inw(devpriv->pcibar2 + ADCDATA);
 	}
 
 	/* return the number of samples read/written */
@@ -866,7 +868,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	/*  initialize before settings pacer source and count values */
 	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
 	/*  clear fifo */
-	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
+	outw(0, devpriv->pcibar2 + ADCFIFOCLR);
 
 	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
@@ -1248,7 +1250,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	if (status & ADHFI) {
 		/*  read data */
 		num_samples = comedi_nsamples_left(s, half_fifo);
-		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
+		insw(devpriv->pcibar2 + ADCDATA, devpriv->ai_buffer,
 		     num_samples);
 		comedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);
 
@@ -1270,7 +1272,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			if ((ADNE & inw(devpriv->pcibar1 +
 					INT_ADCFIFO)) == 0)
 				break;
-			val = inw(devpriv->adc_fifo);
+			val = inw(devpriv->pcibar2 + ADCDATA);
 			comedi_buf_write_samples(s, &val, 1);
 
 			if (cmd->stop_src == TRIG_COUNT &&
@@ -1336,7 +1338,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
 	devpriv->pcibar1 = pci_resource_start(pcidev, 1);
-	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
+	devpriv->pcibar2 = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
 	if (board->has_ao)
 		devpriv->ao_registers = pci_resource_start(pcidev, 4);

commit 9d39f185130432452ba8cead55ec7c4a914133bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:31 2015 -0700

    staging: comedi: cb_pcidas: rename private data 'control_status'
    
    This member of the private data holds the PCI BAR1 resource starting
    address. For aesthetics, rename this member to 'pcibar1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a844103c92f2..3a17611173d0 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -73,7 +73,9 @@
 #define AI_BUFFER_SIZE		1024	/* max ai fifo size */
 #define AO_BUFFER_SIZE		1024	/* max ao fifo size */
 
-/* Control/Status registers */
+/*
+ * PCI BAR1 Register map (devpriv->pcibar1)
+ */
 #define INT_ADCFIFO		0	/* INTERRUPT / ADC FIFO register */
 #define   INT_EOS		0x1	/* int end of scan */
 #define   INT_FHF		0x2	/* int fifo half full */
@@ -312,7 +314,7 @@ struct cb_pcidas_private {
 	struct comedi_8254 *ao_pacer;
 	/* base addresses */
 	unsigned long s5933_config;
-	unsigned long control_status;
+	unsigned long pcibar1;
 	unsigned long adc_fifo;
 	unsigned long ao_registers;
 	/* bits to write to registers */
@@ -340,7 +342,7 @@ static int cb_pcidas_ai_eoc(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int status;
 
-	status = inw(devpriv->control_status + ADCMUX_CONT);
+	status = inw(devpriv->pcibar1 + ADCMUX_CONT);
 	if (status & EOC)
 		return 0;
 	return -EBUSY;
@@ -361,10 +363,10 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	/* enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
-		     devpriv->control_status + CALIBRATION_REG);
+		     devpriv->pcibar1 + CALIBRATION_REG);
 		chan = 0;
 	} else {
-		outw(0, devpriv->control_status + CALIBRATION_REG);
+		outw(0, devpriv->pcibar1 + CALIBRATION_REG);
 	}
 
 	/* set mux limits and gain */
@@ -375,7 +377,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	/* set single-ended/differential */
 	if (aref != AREF_DIFF)
 		bits |= SE;
-	outw(bits, devpriv->control_status + ADCMUX_CONT);
+	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
 
 	/* clear fifo */
 	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
@@ -437,7 +439,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 	devpriv->ao_control_bits &= (~DAC_MODE_UPDATE_BOTH &
 				     ~DAC_RANGE_MASK(chan));
 	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range));
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
@@ -468,7 +470,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 				     ~DAC_RANGE_MASK(chan) & ~DAC_PACER_MASK);
 	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range) |
 				     DAC_CHAN_EN(chan) | DAC_START);
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
@@ -551,7 +553,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
 		udelay(write_delay);
-		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+		outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
 	}
 }
 
@@ -568,9 +570,9 @@ static void caldac_8800_write(struct comedi_device *dev,
 
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
-	     devpriv->control_status + CALIBRATION_REG);
+	     devpriv->pcibar1 + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
 }
 
 static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
@@ -601,12 +603,12 @@ static void dac08_write(struct comedi_device *dev, unsigned int value)
 	value |= cal_enable_bits(dev);
 
 	/* latch the new value into the caldac */
-	outw(value, devpriv->control_status + CALIBRATION_REG);
+	outw(value, devpriv->pcibar1 + CALIBRATION_REG);
 	udelay(1);
 	outw(value | SELECT_DAC08_BIT,
-	     devpriv->control_status + CALIBRATION_REG);
+	     devpriv->pcibar1 + CALIBRATION_REG);
 	udelay(1);
-	outw(value, devpriv->control_status + CALIBRATION_REG);
+	outw(value, devpriv->pcibar1 + CALIBRATION_REG);
 	udelay(1);
 }
 
@@ -639,13 +641,13 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
 	udelay(ad7376_udelay);
-	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+	outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 				    bitstream_length);
 
 	udelay(ad7376_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
 
 	return 0;
 }
@@ -664,13 +666,13 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
 	udelay(ad8402_udelay);
-	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+	outw(register_bits, devpriv->pcibar1 + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 				    bitstream_length);
 
 	udelay(ad8402_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+	outw(cal_enable_bits(dev), devpriv->pcibar1 + CALIBRATION_REG);
 
 	return 0;
 }
@@ -860,9 +862,9 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	unsigned long flags;
 
 	/*  make sure CAL_EN_BIT is disabled */
-	outw(0, devpriv->control_status + CALIBRATION_REG);
+	outw(0, devpriv->pcibar1 + CALIBRATION_REG);
 	/*  initialize before settings pacer source and count values */
-	outw(0, devpriv->control_status + TRIG_CONTSTAT);
+	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
 	/*  clear fifo */
 	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
 
@@ -881,7 +883,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= PACER_EXT_RISE;
 	else
 		bits |= PACER_INT;
-	outw(bits, devpriv->control_status + ADCMUX_CONT);
+	outw(bits, devpriv->pcibar1 + ADCMUX_CONT);
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER ||
@@ -909,7 +911,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
-	     devpriv->control_status + INT_ADCFIFO);
+	     devpriv->pcibar1 + INT_ADCFIFO);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
@@ -927,7 +929,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	}
 	if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
 		bits |= BURSTE;
-	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
+	outw(bits, devpriv->pcibar1 + TRIG_CONTSTAT);
 
 	return 0;
 }
@@ -1034,13 +1036,13 @@ static int cb_pcidas_cancel(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
-	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+	outw(devpriv->adc_fifo_bits, devpriv->pcibar1 + INT_ADCFIFO);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable start trigger source and burst mode */
-	outw(0, devpriv->control_status + TRIG_CONTSTAT);
+	outw(0, devpriv->pcibar1 + TRIG_CONTSTAT);
 	/*  software pacer source */
-	outw(0, devpriv->control_status + ADCMUX_CONT);
+	outw(0, devpriv->pcibar1 + ADCMUX_CONT);
 
 	return 0;
 }
@@ -1080,11 +1082,11 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
-	     devpriv->control_status + INT_ADCFIFO);
+	     devpriv->pcibar1 + INT_ADCFIFO);
 
 	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1115,7 +1117,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	}
 
 	/*  disable analog out before settings pacer source and count values */
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
@@ -1158,11 +1160,11 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
-	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+	outw(devpriv->adc_fifo_bits, devpriv->pcibar1 + INT_ADCFIFO);
 
 	/*  disable output */
 	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	outw(devpriv->ao_control_bits, devpriv->pcibar1 + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
@@ -1181,7 +1183,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		/*  clear dac empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_COUNT &&
@@ -1198,7 +1200,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
@@ -1236,7 +1238,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	status = inw(devpriv->control_status + INT_ADCFIFO);
+	status = inw(devpriv->pcibar1 + INT_ADCFIFO);
 
 	/*  check for analog output interrupt */
 	if (status & (DAHFI | DAEMI))
@@ -1257,7 +1259,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
@@ -1265,7 +1267,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			unsigned short val;
 
 			/*  break if fifo is empty */
-			if ((ADNE & inw(devpriv->control_status +
+			if ((ADNE & inw(devpriv->pcibar1 +
 					INT_ADCFIFO)) == 0)
 				break;
 			val = inw(devpriv->adc_fifo);
@@ -1280,7 +1282,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear not-empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		dev_err(dev->class_dev,
@@ -1288,7 +1290,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
@@ -1297,7 +1299,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear overflow interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
-		     devpriv->control_status + INT_ADCFIFO);
+		     devpriv->pcibar1 + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		async->events |= COMEDI_CB_ERROR;
 	}
@@ -1333,7 +1335,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		return ret;
 
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
-	devpriv->control_status = pci_resource_start(pcidev, 1);
+	devpriv->pcibar1 = pci_resource_start(pcidev, 1);
 	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
 	if (board->has_ao)

commit c368e6687066c0dcaddacdd1bcdf7999caa21fa4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:30 2015 -0700

    staging: comedi: cb_pcidas: refactor 'ranges' boardinfo
    
    All the boards, except the 'pci-das1001', use the normal analog input
    range table 'cb_pcidas_ranges'. Convert the 'ranges' boardinfo into
    a bit-field flag 'use_alt_range' to save a bit of space.
    
    For aesthetics, reword the comments in the boardinfo for the bit-field
    members so they align.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 46c47ed7be9b..a844103c92f2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -231,11 +231,11 @@ struct cb_pcidas_board {
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_scan_speed;	/*  analog output scan speed for 1602 series */
 	int fifo_size;		/*  number of samples fifo can hold */
-	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
-	unsigned int is_16bit;	/*  ADC/DAC resolution 1=16-bit; 0=12-bit */
-	unsigned int has_ao:1;	/*  has 2 analog output channels */
-	unsigned int has_ao_fifo:1;	/*  analog output has fifo */
+	unsigned int is_16bit;		/* ai/ao is 1=16-bit; 0=12-bit */
+	unsigned int use_alt_range:1;	/* use alternate ai range table */
+	unsigned int has_ao:1;		/* has 2 analog output channels */
+	unsigned int has_ao_fifo:1;	/* analog output has fifo */
 	unsigned int has_dac08:1;
 	unsigned int is_1602:1;
 };
@@ -246,7 +246,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_speed	= 5000,
 		.ao_scan_speed	= 10000,
 		.fifo_size	= 512,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
 		.is_16bit	= 1,
 		.has_ao		= 1,
@@ -258,7 +257,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200",
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 		.has_ao		= 1,
 	},
@@ -267,7 +265,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_speed	= 3200,
 		.ao_scan_speed	= 4000,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 		.has_ao		= 1,
 		.has_ao_fifo	= 1,
@@ -277,14 +274,12 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200/jr",
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 	},
 	[BOARD_PCIDAS1602_16_JR] = {
 		.name		= "pci-das1602/16/jr",
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
 		.is_16bit	= 1,
 		.has_dac08	= 1,
@@ -294,22 +289,20 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1000",
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 	},
 	[BOARD_PCIDAS1001] = {
 		.name		= "pci-das1001",
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_alt_ranges,
 		.trimpot	= AD7376,
+		.use_alt_range	= 1,
 		.has_ao		= 1,
 	},
 	[BOARD_PCIDAS1002] = {
 		.name		= "pci-das1002",
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
-		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 		.has_ao		= 1,
 	},
@@ -1383,7 +1376,8 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->n_chan = 16;
 	s->len_chanlist = s->n_chan;
 	s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
-	s->range_table = board->ranges;
+	s->range_table	= board->use_alt_range ? &cb_pcidas_alt_ranges
+					       : &cb_pcidas_ranges;
 	s->insn_read = cb_pcidas_ai_rinsn;
 	s->insn_config = ai_config_insn;
 	s->do_cmd = cb_pcidas_ai_cmd;

commit 2743803dc4fce84365204a494ef94edd81c8320b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:29 2015 -0700

    staging: comedi: cb_pcidas: all boards have 16 analog input channels
    
    All the boards supported by this driver have 16 analog input channels.
    Remove this unnecessary information from the boardinfo.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f6309c9c034e..46c47ed7be9b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -228,7 +228,6 @@ enum cb_pcidas_boardid {
 
 struct cb_pcidas_board {
 	const char *name;
-	int ai_nchan;		/*  Inputs in single-ended mode */
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_scan_speed;	/*  analog output scan speed for 1602 series */
 	int fifo_size;		/*  number of samples fifo can hold */
@@ -244,7 +243,6 @@ struct cb_pcidas_board {
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1602_16] = {
 		.name		= "pci-das1602/16",
-		.ai_nchan	= 16,
 		.ai_speed	= 5000,
 		.ao_scan_speed	= 10000,
 		.fifo_size	= 512,
@@ -258,7 +256,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1200] = {
 		.name		= "pci-das1200",
-		.ai_nchan	= 16,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -267,7 +264,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1602_12] = {
 		.name		= "pci-das1602/12",
-		.ai_nchan	= 16,
 		.ai_speed	= 3200,
 		.ao_scan_speed	= 4000,
 		.fifo_size	= 1024,
@@ -279,7 +275,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1200_JR] = {
 		.name		= "pci-das1200/jr",
-		.ai_nchan	= 16,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -287,7 +282,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1602_16_JR] = {
 		.name		= "pci-das1602/16/jr",
-		.ai_nchan	= 16,
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
 		.ranges		= &cb_pcidas_ranges,
@@ -298,7 +292,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1000] = {
 		.name		= "pci-das1000",
-		.ai_nchan	= 16,
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -306,7 +299,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1001] = {
 		.name		= "pci-das1001",
-		.ai_nchan	= 16,
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_alt_ranges,
@@ -315,7 +307,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 	[BOARD_PCIDAS1002] = {
 		.name		= "pci-das1002",
-		.ai_nchan	= 16,
 		.ai_speed	= 6800,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -1389,8 +1380,8 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
 	/* WARNING: Number of inputs in differential mode is ignored */
-	s->n_chan = board->ai_nchan;
-	s->len_chanlist = board->ai_nchan;
+	s->n_chan = 16;
+	s->len_chanlist = s->n_chan;
 	s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
 	s->range_table = board->ranges;
 	s->insn_read = cb_pcidas_ai_rinsn;

commit fe97f142bb18903f91cde3de73c6b14ae031d4b4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:28 2015 -0700

    staging: comedi: cb_pcidas: refactor analog output boardinfo
    
    Only some of the boards supported by this driver have analog outputs
    but they always have 2 channels. Refactor the 'ao_nchan' member of
    the boardinfo into a bit-field flag 'has_ao' to save a bit of space.
    Also, convert the 'has_ao_fifo' member into a bit-field flag.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 99f12dce8666..f6309c9c034e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -230,13 +230,13 @@ struct cb_pcidas_board {
 	const char *name;
 	int ai_nchan;		/*  Inputs in single-ended mode */
 	int ai_speed;		/*  fastest conversion period in ns */
-	int ao_nchan;		/*  number of analog out channels */
-	int has_ao_fifo;	/*  analog output has fifo */
 	int ao_scan_speed;	/*  analog output scan speed for 1602 series */
 	int fifo_size;		/*  number of samples fifo can hold */
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned int is_16bit;	/*  ADC/DAC resolution 1=16-bit; 0=12-bit */
+	unsigned int has_ao:1;	/*  has 2 analog output channels */
+	unsigned int has_ao_fifo:1;	/*  analog output has fifo */
 	unsigned int has_dac08:1;
 	unsigned int is_1602:1;
 };
@@ -246,13 +246,13 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1602/16",
 		.ai_nchan	= 16,
 		.ai_speed	= 5000,
-		.ao_nchan	= 2,
-		.has_ao_fifo	= 1,
 		.ao_scan_speed	= 10000,
 		.fifo_size	= 512,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
 		.is_16bit	= 1,
+		.has_ao		= 1,
+		.has_ao_fifo	= 1,
 		.has_dac08	= 1,
 		.is_1602	= 1,
 	},
@@ -260,21 +260,21 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200",
 		.ai_nchan	= 16,
 		.ai_speed	= 3200,
-		.ao_nchan	= 2,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
+		.has_ao		= 1,
 	},
 	[BOARD_PCIDAS1602_12] = {
 		.name		= "pci-das1602/12",
 		.ai_nchan	= 16,
 		.ai_speed	= 3200,
-		.ao_nchan	= 2,
-		.has_ao_fifo	= 1,
 		.ao_scan_speed	= 4000,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
+		.has_ao		= 1,
+		.has_ao_fifo	= 1,
 		.is_1602	= 1,
 	},
 	[BOARD_PCIDAS1200_JR] = {
@@ -308,19 +308,19 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1001",
 		.ai_nchan	= 16,
 		.ai_speed	= 6800,
-		.ao_nchan	= 2,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_alt_ranges,
 		.trimpot	= AD7376,
+		.has_ao		= 1,
 	},
 	[BOARD_PCIDAS1002] = {
 		.name		= "pci-das1002",
 		.ai_nchan	= 16,
 		.ai_speed	= 6800,
-		.ao_nchan	= 2,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
+		.has_ao		= 1,
 	},
 };
 
@@ -1352,7 +1352,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	devpriv->control_status = pci_resource_start(pcidev, 1);
 	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
-	if (board->ao_nchan)
+	if (board->has_ao)
 		devpriv->ao_registers = pci_resource_start(pcidev, 4);
 
 	/*  disable and clear interrupts on amcc s5933 */
@@ -1401,10 +1401,10 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/* analog output subdevice */
 	s = &dev->subdevices[1];
-	if (board->ao_nchan) {
+	if (board->has_ao) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = board->ao_nchan;
+		s->n_chan = 2;
 		s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
 		s->range_table = &cb_pcidas_ao_ranges;
 		/* default to no fifo (*insn_write) */

commit bfd2eb8d2077776fab9dbd2d91082990908480ab
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:27 2015 -0700

    staging: comedi: cb_pcidas: refactor 'ai_bits' boardinfo
    
    The boards supported by this driver either have 16-bit or 12-bit
    analog input/output resolution. For aesthetics, replace the 'ai_bits'
    member of the boardinfo with a bit-field flag 'is_16bit'. Also,
    change the types of the other bit-field flags to unsigned int.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index dee4f8ef6a67..99f12dce8666 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -229,7 +229,6 @@ enum cb_pcidas_boardid {
 struct cb_pcidas_board {
 	const char *name;
 	int ai_nchan;		/*  Inputs in single-ended mode */
-	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_nchan;		/*  number of analog out channels */
 	int has_ao_fifo;	/*  analog output has fifo */
@@ -237,15 +236,15 @@ struct cb_pcidas_board {
 	int fifo_size;		/*  number of samples fifo can hold */
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
-	unsigned has_dac08:1;
-	unsigned is_1602:1;
+	unsigned int is_16bit;	/*  ADC/DAC resolution 1=16-bit; 0=12-bit */
+	unsigned int has_dac08:1;
+	unsigned int is_1602:1;
 };
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1602_16] = {
 		.name		= "pci-das1602/16",
 		.ai_nchan	= 16,
-		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.ao_nchan	= 2,
 		.has_ao_fifo	= 1,
@@ -253,13 +252,13 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.fifo_size	= 512,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
+		.is_16bit	= 1,
 		.has_dac08	= 1,
 		.is_1602	= 1,
 	},
 	[BOARD_PCIDAS1200] = {
 		.name		= "pci-das1200",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
 		.fifo_size	= 1024,
@@ -269,7 +268,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1602_12] = {
 		.name		= "pci-das1602/12",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
 		.has_ao_fifo	= 1,
@@ -282,7 +280,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1200_JR] = {
 		.name		= "pci-das1200/jr",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -291,18 +288,17 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1602_16_JR] = {
 		.name		= "pci-das1602/16/jr",
 		.ai_nchan	= 16,
-		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
+		.is_16bit	= 1,
 		.has_dac08	= 1,
 		.is_1602	= 1,
 	},
 	[BOARD_PCIDAS1000] = {
 		.name		= "pci-das1000",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
@@ -311,7 +307,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1001] = {
 		.name		= "pci-das1001",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
 		.fifo_size	= 1024,
@@ -321,7 +316,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	[BOARD_PCIDAS1002] = {
 		.name		= "pci-das1002",
 		.ai_nchan	= 16,
-		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
 		.fifo_size	= 1024,
@@ -1397,7 +1391,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	/* WARNING: Number of inputs in differential mode is ignored */
 	s->n_chan = board->ai_nchan;
 	s->len_chanlist = board->ai_nchan;
-	s->maxdata = (1 << board->ai_bits) - 1;
+	s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
 	s->range_table = board->ranges;
 	s->insn_read = cb_pcidas_ai_rinsn;
 	s->insn_config = ai_config_insn;
@@ -1411,11 +1405,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = board->ao_nchan;
-		/*
-		 * analog out resolution is the same as
-		 * analog input resolution, so use ai_bits
-		 */
-		s->maxdata = (1 << board->ai_bits) - 1;
+		s->maxdata = board->is_16bit ? 0xffff : 0x0fff;
 		s->range_table = &cb_pcidas_ao_ranges;
 		/* default to no fifo (*insn_write) */
 		s->insn_write = cb_pcidas_ao_nofifo_winsn;

commit 3ab2733b7ce9e20be53f483f626f3d06ff507de3
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:26 2015 -0700

    staging: comedi: cb_pcidas: remove NUM_CHANNELS_* defines
    
    These defines don't add any additional clarity to the driver. Just
    remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f27090dc90cb..dee4f8ef6a67 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -72,10 +72,6 @@
 
 #define AI_BUFFER_SIZE		1024	/* max ai fifo size */
 #define AO_BUFFER_SIZE		1024	/* max ao fifo size */
-#define NUM_CHANNELS_8800	8
-#define NUM_CHANNELS_7376	1
-#define NUM_CHANNELS_8402	2
-#define NUM_CHANNELS_DAC08	1
 
 /* Control/Status registers */
 #define INT_ADCFIFO		0	/* INTERRUPT / ADC FIFO register */
@@ -1459,7 +1455,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[4];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	s->n_chan = NUM_CHANNELS_8800;
+	s->n_chan = 8;
 	s->maxdata = 0xff;
 	s->insn_write = cb_pcidas_caldac_insn_write;
 
@@ -1477,10 +1473,10 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	if (board->trimpot == AD7376) {
-		s->n_chan = NUM_CHANNELS_7376;
+		s->n_chan = 1;
 		s->maxdata = 0x7f;
 	} else {
-		s->n_chan = NUM_CHANNELS_8402;
+		s->n_chan = 2;
 		s->maxdata = 0xff;
 	}
 	s->insn_write = cb_pcidas_trimpot_insn_write;
@@ -1499,7 +1495,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	if (board->has_dac08) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = NUM_CHANNELS_DAC08;
+		s->n_chan = 1;
 		s->maxdata = 0xff;
 		s->insn_write = cb_pcidas_dac08_insn_write;
 

commit d41af47d9f3adb49c4328f1b6c769926478679c4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Oct 13 17:47:25 2015 -0700

    staging: comedi: cb_pcidas: tidy up multi-line comments
    
    Reformat the multi-line comments in the kernel CodingStyle.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b589e17379cc..f27090dc90cb 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1,65 +1,64 @@
 /*
-    comedi/drivers/cb_pcidas.c
+ * cb_pcidas.c
+ * Developed by Ivan Martinez and Frank Mori Hess, with valuable help from
+ * David Schleef and the rest of the Comedi developers comunity.
+ *
+ * Copyright (C) 2001-2003 Ivan Martinez <imr@oersted.dtu.dk>
+ * Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+ *
+ * COMEDI - Linux Control and Measurement Device Interface
+ * Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
 
-    Developed by Ivan Martinez and Frank Mori Hess, with valuable help from
-    David Schleef and the rest of the Comedi developers comunity.
-
-    Copyright (C) 2001-2003 Ivan Martinez <imr@oersted.dtu.dk>
-    Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
-
-    COMEDI - Linux Control and Measurement Device Interface
-    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-*/
 /*
-Driver: cb_pcidas
-Description: MeasurementComputing PCI-DAS series
-  with the AMCC S5933 PCI controller
-Author: Ivan Martinez <imr@oersted.dtu.dk>,
-  Frank Mori Hess <fmhess@users.sourceforge.net>
-Updated: 2003-3-11
-Devices: [Measurement Computing] PCI-DAS1602/16 (cb_pcidas),
-  PCI-DAS1602/16jr, PCI-DAS1602/12, PCI-DAS1200, PCI-DAS1200jr,
-  PCI-DAS1000, PCI-DAS1001, PCI_DAS1002
-
-Status:
-  There are many reports of the driver being used with most of the
-  supported cards. Despite no detailed log is maintained, it can
-  be said that the driver is quite tested and stable.
-
-  The boards may be autocalibrated using the comedi_calibrate
-  utility.
-
-Configuration options: not applicable, uses PCI auto config
-
-For commands, the scanned channels must be consecutive
-(i.e. 4-5-6-7, 2-3-4,...), and must all have the same
-range and aref.
-
-AI Triggering:
-   For start_src == TRIG_EXT, the A/D EXTERNAL TRIGGER IN (pin 45) is used.
-   For 1602 series, the start_arg is interpreted as follows:
-     start_arg == 0                   => gated trigger (level high)
-     start_arg == CR_INVERT           => gated trigger (level low)
-     start_arg == CR_EDGE             => Rising edge
-     start_arg == CR_EDGE | CR_INVERT => Falling edge
-   For the other boards the trigger will be done on rising edge
-*/
-/*
-
-TODO:
+ * Driver: cb_pcidas
+ * Description: MeasurementComputing PCI-DAS series
+ *   with the AMCC S5933 PCI controller
+ * Devices: [Measurement Computing] PCI-DAS1602/16 (cb_pcidas),
+ *   PCI-DAS1602/16jr, PCI-DAS1602/12, PCI-DAS1200, PCI-DAS1200jr,
+ *   PCI-DAS1000, PCI-DAS1001, PCI_DAS1002
+ * Author: Ivan Martinez <imr@oersted.dtu.dk>,
+ *   Frank Mori Hess <fmhess@users.sourceforge.net>
+ * Updated: 2003-3-11
+ *
+ * Status:
+ * There are many reports of the driver being used with most of the
+ * supported cards. Despite no detailed log is maintained, it can
+ * be said that the driver is quite tested and stable.
+ *
+ * The boards may be autocalibrated using the comedi_calibrate
+ * utility.
+ *
+ * Configuration options: not applicable, uses PCI auto config
+ *
+ * For commands, the scanned channels must be consecutive
+ * (i.e. 4-5-6-7, 2-3-4,...), and must all have the same
+ * range and aref.
+ *
+ * AI Triggering:
+ * For start_src == TRIG_EXT, the A/D EXTERNAL TRIGGER IN (pin 45) is used.
+ * For 1602 series, the start_arg is interpreted as follows:
+ *	start_arg == 0                   => gated trigger (level high)
+ *	start_arg == CR_INVERT           => gated trigger (level low)
+ *	start_arg == CR_EDGE             => Rising edge
+ *	start_arg == CR_EDGE | CR_INVERT => Falling edge
+ * For the other boards the trigger will be done on rising edge
+ */
 
-analog triggering on 1602 series
-*/
+/*
+ * TODO:
+ * analog triggering on 1602 series
+ */
 
 #include <linux/module.h>
 #include <linux/delay.h>

commit e4c0c6bc0c3baa6ba8cce4db5568fe9db5ad3c5f
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Thu Oct 15 00:58:26 2015 +0530

    Staging: comedi: Remove unnecessary cast on void pointer
    
    void pointers do not need to be cast to other pointer types.
    
    The semantic patch used to find this:
    
    @r@
    expression x;
    void* e;
    type T;
    identifier f;
    @@
    
    (
      *((T *)e)
    |
      ((T *)x)[...]
    |
      ((T *)x)->f
    |
    - (T *)
      e
    )
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b43e836575fd..b589e17379cc 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1234,7 +1234,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *)d;
+	struct comedi_device *dev = d;
 	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;

commit 164c224812f04f49afdc47b89a25593ba22c26d7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jun 18 10:54:52 2015 -0700

    staging: comedi: cb_pcidas: rename 'thisboard' variables
    
    For aesthetics, rename the 'thisboard' variables to 'board'. That name
    is more commonly used for the boardinfo pointer in comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e3591a5824fe..b43e836575fd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -705,9 +705,9 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 static void cb_pcidas_trimpot_write(struct comedi_device *dev,
 				    unsigned int chan, unsigned int val)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 
-	switch (thisboard->trimpot) {
+	switch (board->trimpot) {
 	case AD7376:
 		trimpot_7376_write(dev, val);
 		break;
@@ -770,7 +770,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	int err = 0;
 	unsigned int arg;
 
@@ -821,7 +821,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 						~(CR_EDGE | CR_INVERT));
 			err |= -EINVAL;
 		}
-		if (!thisboard->is_1602 && (cmd->start_arg & CR_INVERT)) {
+		if (!board->is_1602 && (cmd->start_arg & CR_INVERT)) {
 			cmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);
 			err |= -EINVAL;
 		}
@@ -830,13 +830,13 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
-						    thisboard->ai_speed *
+						    board->ai_speed *
 						    cmd->chanlist_len);
 	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
-						    thisboard->ai_speed);
+						    board->ai_speed);
 	}
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
@@ -879,7 +879,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -945,7 +945,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= SW_TRIGGER;
 	} else {	/* TRIG_EXT */
 		bits |= EXT_TRIGGER | TGEN | XTRCL;
-		if (thisboard->is_1602) {
+		if (board->is_1602) {
 			if (cmd->start_arg & CR_INVERT)
 				bits |= TGPOL;
 			if (cmd->start_arg & CR_EDGE)
@@ -982,7 +982,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 
@@ -1014,7 +1014,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
-						    thisboard->ao_scan_speed);
+						    board->ao_scan_speed);
 	}
 
 	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
@@ -1090,7 +1090,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int trig_num)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1099,7 +1099,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	cb_pcidas_ao_load_fifo(dev, s, thisboard->fifo_size);
+	cb_pcidas_ao_load_fifo(dev, s, board->fifo_size);
 
 	/*  enable dac half-full and empty interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1197,7 +1197,7 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 {
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
@@ -1220,7 +1220,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 			}
 		}
 	} else if (status & DAHFI) {
-		cb_pcidas_ao_load_fifo(dev, s, thisboard->fifo_size / 2);
+		cb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);
 
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
@@ -1235,13 +1235,13 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *)d;
-	const struct cb_pcidas_board *thisboard = dev->board_ptr;
+	const struct cb_pcidas_board *board = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	struct comedi_cmd *cmd;
 	int status, s5933_status;
-	int half_fifo = thisboard->fifo_size / 2;
+	int half_fifo = board->fifo_size / 2;
 	unsigned int num_samples, i;
 	static const int timeout = 10000;
 	unsigned long flags;
@@ -1338,18 +1338,18 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 				 unsigned long context)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct cb_pcidas_board *thisboard = NULL;
+	const struct cb_pcidas_board *board = NULL;
 	struct cb_pcidas_private *devpriv;
 	struct comedi_subdevice *s;
 	int i;
 	int ret;
 
 	if (context < ARRAY_SIZE(cb_pcidas_boards))
-		thisboard = &cb_pcidas_boards[context];
-	if (!thisboard)
+		board = &cb_pcidas_boards[context];
+	if (!board)
 		return -ENODEV;
-	dev->board_ptr  = thisboard;
-	dev->board_name = thisboard->name;
+	dev->board_ptr  = board;
+	dev->board_name = board->name;
 
 	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
@@ -1363,7 +1363,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	devpriv->control_status = pci_resource_start(pcidev, 1);
 	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
 	dev->iobase = pci_resource_start(pcidev, 3);
-	if (thisboard->ao_nchan)
+	if (board->ao_nchan)
 		devpriv->ao_registers = pci_resource_start(pcidev, 4);
 
 	/*  disable and clear interrupts on amcc s5933 */
@@ -1400,10 +1400,10 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
 	/* WARNING: Number of inputs in differential mode is ignored */
-	s->n_chan = thisboard->ai_nchan;
-	s->len_chanlist = thisboard->ai_nchan;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ranges;
+	s->n_chan = board->ai_nchan;
+	s->len_chanlist = board->ai_nchan;
+	s->maxdata = (1 << board->ai_bits) - 1;
+	s->range_table = board->ranges;
 	s->insn_read = cb_pcidas_ai_rinsn;
 	s->insn_config = ai_config_insn;
 	s->do_cmd = cb_pcidas_ai_cmd;
@@ -1412,15 +1412,15 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/* analog output subdevice */
 	s = &dev->subdevices[1];
-	if (thisboard->ao_nchan) {
+	if (board->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = thisboard->ao_nchan;
+		s->n_chan = board->ao_nchan;
 		/*
 		 * analog out resolution is the same as
 		 * analog input resolution, so use ai_bits
 		 */
-		s->maxdata = (1 << thisboard->ai_bits) - 1;
+		s->maxdata = (1 << board->ai_bits) - 1;
 		s->range_table = &cb_pcidas_ao_ranges;
 		/* default to no fifo (*insn_write) */
 		s->insn_write = cb_pcidas_ao_nofifo_winsn;
@@ -1429,7 +1429,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		if (ret)
 			return ret;
 
-		if (thisboard->has_ao_fifo) {
+		if (board->has_ao_fifo) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;
 			/* use fifo (*insn_write) instead */
@@ -1477,7 +1477,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s = &dev->subdevices[5];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	if (thisboard->trimpot == AD7376) {
+	if (board->trimpot == AD7376) {
 		s->n_chan = NUM_CHANNELS_7376;
 		s->maxdata = 0x7f;
 	} else {
@@ -1497,7 +1497,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/*  dac08 caldac */
 	s = &dev->subdevices[6];
-	if (thisboard->has_dac08) {
+	if (board->has_dac08) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = NUM_CHANNELS_DAC08;

commit 3b339d322b279e234533a98cbc644e95e8077198
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 19:14:05 2015 +0000

    staging: comedi: cb_pcidas: remove #include "comedi_fc.h"
    
    As preparation for removal of "comedi_fc.h", replace calls to the
    `cfc_check_trigger_...` functions from "comedi_fc.h" with the
    replacement `comedi_check_trigger_...` functions from "../comedidev.h"
    and remove the inclusion of "comedi_fc.h".
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index bad04d99190b..e3591a5824fe 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -70,7 +70,6 @@ analog triggering on 1602 series
 #include "comedi_8254.h"
 #include "8255.h"
 #include "amcc_s5933.h"
-#include "comedi_fc.h"
 
 #define AI_BUFFER_SIZE		1024	/* max ai fifo size */
 #define AO_BUFFER_SIZE		1024	/* max ao fifo size */
@@ -777,23 +776,23 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src,
+	err |= comedi_check_trigger_src(&cmd->convert_src,
 					TRIG_TIMER | TRIG_NOW | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->start_src);
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->convert_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->start_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->convert_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -812,7 +811,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	switch (cmd->start_src) {
 	case TRIG_NOW:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	case TRIG_EXT:
 		/* External trigger, only CR_EDGE and CR_INVERT flags allowed */
@@ -829,20 +828,24 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 		break;
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-				thisboard->ai_speed * cmd->chanlist_len);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    thisboard->ai_speed *
+						    cmd->chanlist_len);
+	}
 
-	if (cmd->convert_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
-						 thisboard->ai_speed);
+	if (cmd->convert_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->convert_arg,
+						    thisboard->ai_speed);
+	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -852,12 +855,12 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
 		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)
@@ -985,20 +988,20 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 1 : check if triggers are trivially valid */
 
-	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
-	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+	err |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= comedi_check_trigger_src(&cmd->scan_begin_src,
 					TRIG_TIMER | TRIG_EXT);
-	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
-	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
-	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
+	err |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
 	/* Step 2a : make sure trigger sources are unique */
 
-	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
-	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+	err |= comedi_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= comedi_check_trigger_is_unique(cmd->stop_src);
 
 	/* Step 2b : and mutually compatible */
 
@@ -1007,18 +1010,20 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 	/* Step 3: check if arguments are trivially valid */
 
-	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+	err |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
-						 thisboard->ao_scan_speed);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		err |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,
+						    thisboard->ao_scan_speed);
+	}
 
-	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+	err |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,
+					   cmd->chanlist_len);
 
 	if (cmd->stop_src == TRIG_COUNT)
-		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+		err |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);
 	else	/* TRIG_NONE */
-		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
+		err |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -1030,7 +1035,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 		comedi_8254_cascade_ns_to_timer(devpriv->ao_pacer,
 						&arg, cmd->flags);
-		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
+		err |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit 29e0a3db395e98a2f79555bbd4101c431e460102
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Mar 10 16:10:48 2015 +0000

    staging: comedi: cb_pcidas: include new "comedi_pci.h" header
    
    Include the new "../comedi_pci.h" header instead of <linux/pci.h> and
    "../comedidev.h", which will now get included indirectly.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 6fdf975daa19..bad04d99190b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -62,11 +62,10 @@ analog triggering on 1602 series
 */
 
 #include <linux/module.h>
-#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#include "../comedidev.h"
+#include "../comedi_pci.h"
 
 #include "comedi_8254.h"
 #include "8255.h"

commit 6ac986d098ee81b75973a0c2f46a9a4edef2a8c6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:18 2015 -0700

    staging: comedi: drivers/*.c: add missing braces {} to if/else branches
    
    According to the CodingStyle, braces should  be used on all branches
    if thet are used on any branch,
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 112627d24d41..6fdf975daa19 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1508,8 +1508,9 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 			dac08_write(dev, s->maxdata / 2);
 			s->readback[i] = s->maxdata / 2;
 		}
-	} else
+	} else {
 		s->type = COMEDI_SUBD_UNUSED;
+	}
 
 	/*  make sure mailbox 4 is empty */
 	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);

commit 6c7d2c8b5230272b394d51462c8cae46df09f126
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Mar 5 13:21:16 2015 -0700

    staging: comedi: drivers/*.c: alignment should match open parenthesis
    
    Fix the alignment issues in all the comedi drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b6ef4b47c673..112627d24d41 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -525,7 +525,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 }
 
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-			uint8_t *data)
+		      uint8_t *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long iobase = devpriv->s5933_config;

commit 96e5624411f99c532175df37c1d8ad8cd908e68a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 23 14:57:36 2015 -0700

    staging: comedi: cb_pcidas: convert driver to use the comedi_8254 module
    
    This driver uses two 8254 timers to generate the pacer clocks. One for analog
    input acquisition and one for analog output data conversion. Convert it to use
    the comedi_8254 module to provide support for the 8254 timers.
    
    Use the comedi_device 'pacer' member for the 8254 timer used for analog input.
    This data is freed automatically by the core during the detach of the driver.
    
    Store the data for the 8254 timer used for analog output in the private data.
    This data needs to be freed by the driver when it is detached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index dd0c65a5b5a0..b6ef4b47c673 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -68,7 +68,7 @@ analog triggering on 1602 series
 
 #include "../comedidev.h"
 
-#include "8253.h"
+#include "comedi_8254.h"
 #include "8255.h"
 #include "amcc_s5933.h"
 #include "comedi_fc.h"
@@ -338,14 +338,12 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 };
 
 struct cb_pcidas_private {
+	struct comedi_8254 *ao_pacer;
 	/* base addresses */
 	unsigned long s5933_config;
 	unsigned long control_status;
 	unsigned long adc_fifo;
 	unsigned long ao_registers;
-	/* divisors of master clock for analog input pacing */
-	unsigned int divisor1;
-	unsigned int divisor2;
 	/* bits to write to registers */
 	unsigned int adc_fifo_bits;
 	unsigned int s5933_intcsr_bits;
@@ -353,9 +351,6 @@ struct cb_pcidas_private {
 	/* fifo buffers */
 	unsigned short ai_buffer[AI_BUFFER_SIZE];
 	unsigned short ao_buffer[AO_BUFFER_SIZE];
-	/* divisors of master clock for analog output pacing */
-	unsigned int ao_divisor1;
-	unsigned int ao_divisor2;
 	unsigned int calibration_source;
 };
 
@@ -778,7 +773,6 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 				struct comedi_cmd *cmd)
 {
 	const struct cb_pcidas_board *thisboard = dev->board_ptr;
-	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
 
@@ -858,18 +852,12 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		arg = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		arg = cmd->convert_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->divisor1,
-					  &devpriv->divisor2,
-					  &arg, cmd->flags);
+		comedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
@@ -886,18 +874,6 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_ai_load_counters(struct comedi_device *dev)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + ADC8254;
-
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-
-	i8254_write(timer_base, 0, 1, devpriv->divisor1);
-	i8254_write(timer_base, 0, 2, devpriv->divisor2);
-}
-
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -933,8 +909,11 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 	/*  load counters */
-	if (cmd->scan_begin_src == TRIG_TIMER || cmd->convert_src == TRIG_TIMER)
-		cb_pcidas_ai_load_counters(dev);
+	if (cmd->scan_begin_src == TRIG_TIMER ||
+	    cmd->convert_src == TRIG_TIMER) {
+		comedi_8254_update_divisors(dev->pacer);
+		comedi_8254_pacer_enable(dev->pacer, 1, 2, true);
+	}
 
 	/*  enable interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1004,7 +983,6 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
-	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -1049,11 +1027,10 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		arg = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->ao_divisor1,
-					  &devpriv->ao_divisor2,
-					  &arg, cmd->flags);
+		unsigned int arg = cmd->scan_begin_arg;
+
+		comedi_8254_cascade_ns_to_timer(devpriv->ao_pacer,
+						&arg, cmd->flags);
 		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
@@ -1139,18 +1116,6 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_ao_load_counters(struct comedi_device *dev)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long timer_base = dev->iobase + DAC8254;
-
-	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
-	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
-
-	i8254_write(timer_base, 0, 1, devpriv->ao_divisor1);
-	i8254_write(timer_base, 0, 2, devpriv->ao_divisor2);
-}
-
 static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -1180,8 +1145,10 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
 
 	/*  load counters */
-	if (cmd->scan_begin_src == TRIG_TIMER)
-		cb_pcidas_ao_load_counters(dev);
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		comedi_8254_update_divisors(devpriv->ao_pacer);
+		comedi_8254_pacer_enable(devpriv->ao_pacer, 1, 2, true);
+	}
 
 	/*  set pacer source */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1408,6 +1375,17 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	}
 	dev->irq = pcidev->irq;
 
+	dev->pacer = comedi_8254_init(dev->iobase + ADC8254,
+				      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);
+	if (!dev->pacer)
+		return -ENOMEM;
+
+	devpriv->ao_pacer = comedi_8254_init(dev->iobase + DAC8254,
+					     I8254_OSC_BASE_10MHZ,
+					     I8254_IO8, 0);
+	if (!devpriv->ao_pacer)
+		return -ENOMEM;
+
 	ret = comedi_alloc_subdevices(dev, 7);
 	if (ret)
 		return ret;
@@ -1550,9 +1528,11 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	if (devpriv && devpriv->s5933_config) {
-		outl(INTCSR_INBOX_INTR_STATUS,
-		     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	if (devpriv) {
+		if (devpriv->s5933_config)
+			outl(INTCSR_INBOX_INTR_STATUS,
+			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+		kfree(devpriv->ao_pacer);
 	}
 	comedi_pci_detach(dev);
 }

commit 3e6cb74f5632e1ac2b4209b4d2c64fca43e2838b
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jan 20 12:06:02 2015 -0700

    staging: comedi: drivers: remove inappropriate COMEDI_CB_EOA events
    
    Hardware errors should be reported with the COMEDI_CB_ERROR event. This event
    will cause the async command to cancel. It's not necessary to also set the
    COMEDI_CB_EOA event. Remove these events.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 669b1703eb99..dd0c65a5b5a0 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1355,7 +1355,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		outw(devpriv->adc_fifo_bits | LADFUL,
 		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+		async->events |= COMEDI_CB_ERROR;
 	}
 
 	comedi_handle_events(dev, s);

commit e42151f945f7b45e6a1634fc3b665b36f5e42a03
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:29 2014 -0700

    staging: comedi: cb_pcidas: use subdevice readback for 'dac08_value'
    
    Use the comedi_subdevice 'readback' member and the core provided (*insn_read)
    to handle the readback of the write-only dac08 calib subdevice. Remove the
    then unused 'dac08_value' member from the private data.
    
    The dac08 calib subdevice only has one channel. For consistency in the driver,
    modify the subdevice init so that a loop is used to initialize the channels and
    readback values.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 04b6d39d1051..669b1703eb99 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -356,7 +356,6 @@ struct cb_pcidas_private {
 	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	unsigned int dac08_value;
 	unsigned int calibration_source;
 };
 
@@ -650,31 +649,20 @@ static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
 				      struct comedi_insn *insn,
 				      unsigned int *data)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
 
 	if (insn->n) {
 		unsigned int val = data[insn->n - 1];
 
-		if (devpriv->dac08_value != val) {
+		if (s->readback[chan] != val) {
 			dac08_write(dev, val);
-			devpriv->dac08_value = val;
+			s->readback[chan] = val;
 		}
 	}
 
 	return insn->n;
 }
 
-static int dac08_read_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	data[0] = devpriv->dac08_value;
-
-	return 1;
-}
-
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
@@ -1531,11 +1519,17 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = NUM_CHANNELS_DAC08;
-		s->insn_read = dac08_read_insn;
-		s->insn_write = cb_pcidas_dac08_insn_write;
 		s->maxdata = 0xff;
-		dac08_write(dev, s->maxdata / 2);
-		devpriv->dac08_value = s->maxdata / 2;
+		s->insn_write = cb_pcidas_dac08_insn_write;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
+
+		for (i = 0; i < s->n_chan; i++) {
+			dac08_write(dev, s->maxdata / 2);
+			s->readback[i] = s->maxdata / 2;
+		}
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 

commit 9c034da124d08237fe973ca0073f5f70297b20fb
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:28 2014 -0700

    staging: comedi: cb_pcidas: tidy up dac08_write_insn()
    
    For consistency with the other calib subdevices, refactor this (*insn_write)
    function so that it only writes the final data value to the hardware.,
    
    For aesthetics, rename the function so it has namespace associated with the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 86e3d200bb21..04b6d39d1051 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -631,34 +631,35 @@ static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 static void dac08_write(struct comedi_device *dev, unsigned int value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long cal_reg;
 
-	if (devpriv->dac08_value != value) {
-		devpriv->dac08_value = value;
+	value &= 0xff;
+	value |= cal_enable_bits(dev);
 
-		cal_reg = devpriv->control_status + CALIBRATION_REG;
-
-		value &= 0xff;
-		value |= cal_enable_bits(dev);
-
-		/* latch the new value into the caldac */
-		outw(value, cal_reg);
-		udelay(1);
-		outw(value | SELECT_DAC08_BIT, cal_reg);
-		udelay(1);
-		outw(value, cal_reg);
-		udelay(1);
-	}
+	/* latch the new value into the caldac */
+	outw(value, devpriv->control_status + CALIBRATION_REG);
+	udelay(1);
+	outw(value | SELECT_DAC08_BIT,
+	     devpriv->control_status + CALIBRATION_REG);
+	udelay(1);
+	outw(value, devpriv->control_status + CALIBRATION_REG);
+	udelay(1);
 }
 
-static int dac08_write_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_dac08_insn_write(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
-	int i;
+	struct cb_pcidas_private *devpriv = dev->private;
+
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
 
-	for (i = 0; i < insn->n; i++)
-		dac08_write(dev, data[i]);
+		if (devpriv->dac08_value != val) {
+			dac08_write(dev, val);
+			devpriv->dac08_value = val;
+		}
+	}
 
 	return insn->n;
 }
@@ -1531,9 +1532,10 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 		s->n_chan = NUM_CHANNELS_DAC08;
 		s->insn_read = dac08_read_insn;
-		s->insn_write = dac08_write_insn;
+		s->insn_write = cb_pcidas_dac08_insn_write;
 		s->maxdata = 0xff;
 		dac08_write(dev, s->maxdata / 2);
+		devpriv->dac08_value = s->maxdata / 2;
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 

commit a1c76758987eac334a7dffcb0b50e597da4ded77
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:27 2014 -0700

    staging: comedi: cb_pcidas: use subdevice readback for 'trimpot_value'
    
    Use the comedi_subdevice 'readback' member and the core provided (*insn_read)
    to handle the readback of the write-only trimpot calib subdevice. Remove the
    then unused 'trimpot_value' member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index d5edb5f31ef6..86e3d200bb21 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -356,7 +356,6 @@ struct cb_pcidas_private {
 	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;
 	unsigned int calibration_source;
 };
@@ -744,33 +743,20 @@ static int cb_pcidas_trimpot_insn_write(struct comedi_device *dev,
 					struct comedi_insn *insn,
 					unsigned int *data)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 
 	if (insn->n) {
 		unsigned int val = data[insn->n - 1];
 
-		if (devpriv->trimpot_value[chan] != val) {
+		if (s->readback[chan] != val) {
 			cb_pcidas_trimpot_write(dev, chan, val);
-			devpriv->trimpot_value[chan] = val;
+			s->readback[chan] = val;
 		}
 	}
 
 	return insn->n;
 }
 
-static int trimpot_read_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned int channel = CR_CHAN(insn->chanspec);
-
-	data[0] = devpriv->trimpot_value[channel];
-
-	return 1;
-}
-
 static int cb_pcidas_ai_check_chanlist(struct comedi_device *dev,
 				       struct comedi_subdevice *s,
 				       struct comedi_cmd *cmd)
@@ -1527,11 +1513,15 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->n_chan = NUM_CHANNELS_8402;
 		s->maxdata = 0xff;
 	}
-	s->insn_read = trimpot_read_insn;
 	s->insn_write = cb_pcidas_trimpot_insn_write;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
 	for (i = 0; i < s->n_chan; i++) {
 		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
-		devpriv->trimpot_value[i] = s->maxdata / 2;
+		s->readback[i] = s->maxdata / 2;
 	}
 
 	/*  dac08 caldac */

commit 7a82a2c4e4aa0cdace951cf35c266d02fb96039f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:26 2014 -0700

    staging: comedi: cb_pcidas: fix trimpot_write_insn()
    
    The comedi core expects the (*insn_write) functions to write 'insn->n'
    values to the hardware and return the number of values written. Currently
    this function only writes the first value. For this subdevice it only makes
    sense to write the final data value.
    
    Fix the function to work like the core expects. For aesthetics, rename the
    function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f92ad26d38ff..d5edb5f31ef6 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -721,38 +721,42 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	return 0;
 }
 
-static int cb_pcidas_trimpot_write(struct comedi_device *dev,
-				   unsigned int channel, unsigned int value)
+static void cb_pcidas_trimpot_write(struct comedi_device *dev,
+				    unsigned int chan, unsigned int val)
 {
 	const struct cb_pcidas_board *thisboard = dev->board_ptr;
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	if (devpriv->trimpot_value[channel] == value)
-		return 1;
 
-	devpriv->trimpot_value[channel] = value;
 	switch (thisboard->trimpot) {
 	case AD7376:
-		trimpot_7376_write(dev, value);
+		trimpot_7376_write(dev, val);
 		break;
 	case AD8402:
-		trimpot_8402_write(dev, channel, value);
+		trimpot_8402_write(dev, chan, val);
 		break;
 	default:
 		dev_err(dev->class_dev, "driver bug?\n");
-		return -1;
+		break;
 	}
-
-	return 1;
 }
 
-static int trimpot_write_insn(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_trimpot_insn_write(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data)
 {
-	unsigned int channel = CR_CHAN(insn->chanspec);
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
+
+		if (devpriv->trimpot_value[chan] != val) {
+			cb_pcidas_trimpot_write(dev, chan, val);
+			devpriv->trimpot_value[chan] = val;
+		}
+	}
 
-	return cb_pcidas_trimpot_write(dev, channel, data[0]);
+	return insn->n;
 }
 
 static int trimpot_read_insn(struct comedi_device *dev,
@@ -1524,9 +1528,11 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->maxdata = 0xff;
 	}
 	s->insn_read = trimpot_read_insn;
-	s->insn_write = trimpot_write_insn;
-	for (i = 0; i < s->n_chan; i++)
+	s->insn_write = cb_pcidas_trimpot_insn_write;
+	for (i = 0; i < s->n_chan; i++) {
 		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
+		devpriv->trimpot_value[i] = s->maxdata / 2;
+	}
 
 	/*  dac08 caldac */
 	s = &dev->subdevices[6];

commit 3f5ced0d0241d64b43c33402e714198824d5b0de
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:25 2014 -0700

    staging: comedi: cb_pcidas: use subdevice readback for 'caldac_value'
    
    Use the comedi_subdevice 'readback' member and the core provided (*insn_read)
    to handle the readback of the write-only caldac subdevice. Remove the then
    unused 'caldac_value' member from the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index d33b37c83ee8..f92ad26d38ff 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -356,7 +356,6 @@ struct cb_pcidas_private {
 	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	unsigned int caldac_value[NUM_CHANNELS_8800];
 	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;
 	unsigned int calibration_source;
@@ -615,32 +614,20 @@ static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
 				       struct comedi_insn *insn,
 				       unsigned int *data)
 {
-	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int chan = CR_CHAN(insn->chanspec);
 
 	if (insn->n) {
 		unsigned int val = data[insn->n - 1];
 
-		if (devpriv->caldac_value[chan] != val) {
+		if (s->readback[chan] != val) {
 			caldac_8800_write(dev, chan, val);
-			devpriv->caldac_value[chan] = val;
+			s->readback[chan] = val;
 		}
 	}
 
 	return insn->n;
 }
 
-static int caldac_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
 /* 1602/16 pregain offset */
 static void dac08_write(struct comedi_device *dev, unsigned int value)
 {
@@ -1514,11 +1501,15 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = NUM_CHANNELS_8800;
 	s->maxdata = 0xff;
-	s->insn_read = caldac_read_insn;
 	s->insn_write = cb_pcidas_caldac_insn_write;
+
+	ret = comedi_alloc_subdev_readback(s);
+	if (ret)
+		return ret;
+
 	for (i = 0; i < s->n_chan; i++) {
 		caldac_8800_write(dev, i, s->maxdata / 2);
-		devpriv->caldac_value[i] = s->maxdata / 2;
+		s->readback[i] = s->maxdata / 2;
 	}
 
 	/*  trim potentiometer */

commit f52e5e44a9eedc1649bf65f28d6ad69a46c54f10
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:24 2014 -0700

    staging: comedi: cb_pcidas: fix caldac_write_insn()
    
    The comedi core expects the (*insn_write) functions to write 'insn->n'
    values to the hardware and return the number of values written. Currently
    this function only writes the first value. For this subdevice it only makes
    sense to write the final data value.
    
    Fix the function to work like the core expects. For aesthetics, rename the
    function so it has namespace associated with the driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1296ccd8a798..d33b37c83ee8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -592,19 +592,14 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 	}
 }
 
-static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value)
+static void caldac_8800_write(struct comedi_device *dev,
+			      unsigned int chan, uint8_t val)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 11;
-	unsigned int bitstream = ((address & 0x7) << 8) | value;
+	unsigned int bitstream = ((chan & 0x7) << 8) | val;
 	static const int caldac_8800_udelay = 1;
 
-	if (value == devpriv->caldac_value[address])
-		return 1;
-
-	devpriv->caldac_value[address] = value;
-
 	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
 				    bitstream_length);
 
@@ -613,17 +608,26 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	     devpriv->control_status + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
-
-	return 1;
 }
 
-static int caldac_write_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_caldac_insn_write(struct comedi_device *dev,
+				       struct comedi_subdevice *s,
+				       struct comedi_insn *insn,
+				       unsigned int *data)
 {
-	const unsigned int channel = CR_CHAN(insn->chanspec);
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+
+	if (insn->n) {
+		unsigned int val = data[insn->n - 1];
+
+		if (devpriv->caldac_value[chan] != val) {
+			caldac_8800_write(dev, chan, val);
+			devpriv->caldac_value[chan] = val;
+		}
+	}
 
-	return caldac_8800_write(dev, channel, data[0]);
+	return insn->n;
 }
 
 static int caldac_read_insn(struct comedi_device *dev,
@@ -1511,9 +1515,11 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	s->n_chan = NUM_CHANNELS_8800;
 	s->maxdata = 0xff;
 	s->insn_read = caldac_read_insn;
-	s->insn_write = caldac_write_insn;
-	for (i = 0; i < s->n_chan; i++)
+	s->insn_write = cb_pcidas_caldac_insn_write;
+	for (i = 0; i < s->n_chan; i++) {
 		caldac_8800_write(dev, i, s->maxdata / 2);
+		devpriv->caldac_value[i] = s->maxdata / 2;
+	}
 
 	/*  trim potentiometer */
 	s = &dev->subdevices[5];

commit 06b66dc22b83fd3d9e4de42011dc5de04a226971
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Nov 20 15:07:23 2014 -0700

    staging: comedi: cb_pcidas: remove unnecessary check in caldac_8800_write()
    
    The 'address' passed to this function is actually the comedi channel. This
    value will always be less than the subdevice n_chan (which is 8). Remove
    the unnecessary sanity check in caldac_8800_write().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 35c63059df4b..1296ccd8a798 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -596,16 +596,10 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
 	unsigned int bitstream = ((address & 0x7) << 8) | value;
 	static const int caldac_8800_udelay = 1;
 
-	if (address >= num_caldac_channels) {
-		dev_err(dev->class_dev, "illegal caldac channel\n");
-		return -1;
-	}
-
 	if (value == devpriv->caldac_value[address])
 		return 1;
 

commit aa11672ef43c05d4ff5580ad41ceae9867e5430d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Nov 21 10:19:10 2014 -0700

    staging: comedi: drivers: have core hook up default (*insn_read) for readback
    
    Most of the comedi drivers that provide readback for write only subdevices now
    use the comedi core comedi_alloc_subdev_readback() helper to allocate the subdevice
    'reaback' member instead of using some member in their private data. These drivers
    also hook up the (*insn_read) callback to the comedi_readback_insn_read() helper to
    provide the readback.
    
    Have the core automatically hook up the (*insn_read) callback after allocating the
    memory if the driver has not already hooked it up to a private function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 10c67fec75a0..35c63059df4b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1478,7 +1478,6 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		s->range_table = &cb_pcidas_ao_ranges;
 		/* default to no fifo (*insn_write) */
 		s->insn_write = cb_pcidas_ao_nofifo_winsn;
-		s->insn_read = comedi_readback_insn_read;
 
 		ret = comedi_alloc_subdev_readback(s);
 		if (ret)

commit 9e4d755cdf0e98daa186733765e5fa14395717af
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:37 2014 -0700

    staging: comedi: cb_pcidas: use comedi_async 'scans_done' to detect AO EOA
    
    Remove the private data member 'ao_count' and use the comedi_async 'scans_done'
    member to detect the analog output end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    read from the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e211ef8650c4..10c67fec75a0 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -356,8 +356,6 @@ struct cb_pcidas_private {
 	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	/* number of analog output samples remaining */
-	unsigned int ao_count;
 	unsigned int caldac_value[NUM_CHANNELS_8800];
 	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;
@@ -1134,17 +1132,12 @@ static void cb_pcidas_ao_load_fifo(struct comedi_device *dev,
 				   unsigned int nsamples)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned int nbytes;
 
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < nsamples)
-		nsamples = devpriv->ao_count;
-
+	nsamples = comedi_nsamples_left(s, nsamples);
 	nbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);
-	nsamples = comedi_bytes_to_samples(s, nbytes);
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_count -= nsamples;
 
+	nsamples = comedi_bytes_to_samples(s, nbytes);
 	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, nsamples);
 }
 
@@ -1226,9 +1219,6 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER)
 		cb_pcidas_ao_load_counters(dev);
 
-	/*  set number of conversions */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
 	/*  set pacer source */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
@@ -1286,13 +1276,13 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
-			if (cmd->stop_src == TRIG_NONE ||
-			    (cmd->stop_src == TRIG_COUNT
-			     && devpriv->ao_count)) {
+			if (cmd->stop_src == TRIG_COUNT &&
+			    async->scans_done >= cmd->stop_arg) {
+				async->events |= COMEDI_CB_EOA;
+			} else {
 				dev_err(dev->class_dev, "dac fifo underflow\n");
 				async->events |= COMEDI_CB_ERROR;
 			}
-			async->events |= COMEDI_CB_EOA;
 		}
 	} else if (status & DAHFI) {
 		cb_pcidas_ao_load_fifo(dev, s, thisboard->fifo_size / 2);

commit f9f983821691fde4539c18e43634d5f9cfa8c011
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Nov 5 10:31:36 2014 -0700

    staging: comedi: cb_pcidas: use comedi_async 'scans_done' to detect AI EOA
    
    Remove the private data member 'count' and use the comedi_async 'scans_done'
    member to detect the analog input end-of-acquisition.
    
    Use the comedi_nsamples_left() helper to get the number of samples to actually
    add to the async buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1c38cd5f846c..e211ef8650c4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -346,8 +346,6 @@ struct cb_pcidas_private {
 	/* divisors of master clock for analog input pacing */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	/* number of analog input samples remaining */
-	unsigned int count;
 	/* bits to write to registers */
 	unsigned int adc_fifo_bits;
 	unsigned int s5933_intcsr_bits;
@@ -976,9 +974,6 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	if (cmd->scan_begin_src == TRIG_TIMER || cmd->convert_src == TRIG_TIMER)
 		cb_pcidas_ai_load_counters(dev);
 
-	/*  set number of conversions */
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
 	/*  enable interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
@@ -1352,17 +1347,15 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	/*  if fifo half-full */
 	if (status & ADHFI) {
 		/*  read data */
-		num_samples = half_fifo;
-		if (cmd->stop_src == TRIG_COUNT &&
-		    num_samples > devpriv->count) {
-			num_samples = devpriv->count;
-		}
+		num_samples = comedi_nsamples_left(s, half_fifo);
 		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
 		     num_samples);
 		comedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);
-		devpriv->count -= num_samples;
-		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
+
+		if (cmd->stop_src == TRIG_COUNT &&
+		    async->scans_done >= cmd->stop_arg)
 			async->events |= COMEDI_CB_EOA;
+
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
@@ -1379,9 +1372,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 				break;
 			val = inw(devpriv->adc_fifo);
 			comedi_buf_write_samples(s, &val, 1);
+
 			if (cmd->stop_src == TRIG_COUNT &&
-			    --devpriv->count == 0) {
-				/* end of acquisition */
+			    async->scans_done >= cmd->stop_arg) {
 				async->events |= COMEDI_CB_EOA;
 				break;
 			}

commit c39e050d21d107d26183be0f22b89eccccdbe61c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Oct 31 12:04:28 2014 -0700

    staging: comedi: remove use of 'bytes_per_sample()'
    
    This inline helper function has been replaced with comedi_bytes_per_sample().
    The same commit (bf33eb4b4f57) introduced a couple other related helper
    functions a manipulate the sample size.
    
    Use the new helper functions to remove the use of 'bytes_per_sample()' and
    remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 53afae093c4c..1c38cd5f846c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1146,7 +1146,7 @@ static void cb_pcidas_ao_load_fifo(struct comedi_device *dev,
 		nsamples = devpriv->ao_count;
 
 	nbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);
-	nsamples = nbytes / bytes_per_sample(s);
+	nsamples = comedi_bytes_to_samples(s, nbytes);
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_count -= nsamples;
 

commit 8d47c085e855da6ce24fa7d9fe3cbb2868f3d8b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 15:36:33 2014 -0700

    staging: comedi: cb_pcidas: use comedi_buf_write_samples()
    
    Use comedi_buf_write_samples() to add the samples to the async buffer.
    That function will handle single and multi samples writes by determining
    the number of bytes to add based on the number of samples and the
    bytes_per_sample().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a0d462fecf20..53afae093c4c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1359,8 +1359,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		}
 		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
 		     num_samples);
-		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
-					  num_samples * sizeof(short));
+		comedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);
 		devpriv->count -= num_samples;
 		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
 			async->events |= COMEDI_CB_EOA;
@@ -1372,11 +1371,14 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
+			unsigned short val;
+
 			/*  break if fifo is empty */
 			if ((ADNE & inw(devpriv->control_status +
 					INT_ADCFIFO)) == 0)
 				break;
-			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
+			val = inw(devpriv->adc_fifo);
+			comedi_buf_write_samples(s, &val, 1);
 			if (cmd->stop_src == TRIG_COUNT &&
 			    --devpriv->count == 0) {
 				/* end of acquisition */

commit 2cc9854caf92526199935bc29685e253349362bc
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Oct 22 14:36:36 2014 -0700

    staging: comedi: cb_pcidas: introduce cb_pcidas_ao_load_fifo()
    
    Introduce a helper function to load the analog output FIFO.
    
    This fixes a bug in cb_pcidas_ao_inttrig(). That function was writing
    'num_bytes' data values to the FIFO instead of 'num_points'. This results
    in twice the number of data values getting written to the FIFO.
    
    Use comedi_buf_read_samples() read the analog output samples from the async
    buffer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e7ab6bcfa90b..a0d462fecf20 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1134,32 +1134,39 @@ static int cb_pcidas_cancel(struct comedi_device *dev,
 	return 0;
 }
 
+static void cb_pcidas_ao_load_fifo(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   unsigned int nsamples)
+{
+	struct cb_pcidas_private *devpriv = dev->private;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned int nbytes;
+
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < nsamples)
+		nsamples = devpriv->ao_count;
+
+	nbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);
+	nsamples = nbytes / bytes_per_sample(s);
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->ao_count -= nsamples;
+
+	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, nsamples);
+}
+
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int trig_num)
 {
 	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned int num_bytes, num_points = thisboard->fifo_size;
 	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned long flags;
 
 	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
-	/*  load up fifo */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)
-		num_points = devpriv->ao_count;
-
-	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-					       num_points * sizeof(short));
-	num_points = num_bytes / sizeof(short);
-
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_count -= num_points;
-	/*  write data to board's fifo */
-	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
+	cb_pcidas_ao_load_fifo(dev, s, thisboard->fifo_size);
 
 	/*  enable dac half-full and empty interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1275,8 +1282,6 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int half_fifo = thisboard->fifo_size / 2;
-	unsigned int num_points;
 	unsigned long flags;
 
 	if (status & DAEMI) {
@@ -1295,23 +1300,8 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 			async->events |= COMEDI_CB_EOA;
 		}
 	} else if (status & DAHFI) {
-		unsigned int num_bytes;
+		cb_pcidas_ao_load_fifo(dev, s, thisboard->fifo_size / 2);
 
-		/*  figure out how many points we are writing to fifo */
-		num_points = half_fifo;
-		if (cmd->stop_src == TRIG_COUNT &&
-		    devpriv->ao_count < num_points)
-			num_points = devpriv->ao_count;
-		num_bytes =
-		    cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-					       num_points * sizeof(short));
-		num_points = num_bytes / sizeof(short);
-
-		if (cmd->stop_src == TRIG_COUNT)
-			devpriv->ao_count -= num_points;
-		/*  write data to board's fifo */
-		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
-		      num_points);
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,

commit f923f780704b810d31b62b2ad4e19198e6be0b63
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 18 11:11:18 2014 -0700

    staging: comedi: cb_pcidas: use comedi_handle_events()
    
    cfc_handle_events() is just a wrapper around comedi_handle_events().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1ec363b7505c..e7ab6bcfa90b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1319,7 +1319,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 }
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
@@ -1419,7 +1419,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 
-	cfc_handle_events(dev, s);
+	comedi_handle_events(dev, s);
 
 	return IRQ_HANDLED;
 }

commit c5d9973b046fb8e0b0f3a8ad925d0033eec59856
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Sep 9 16:15:45 2014 -0700

    staging: comedi: cb_pcidas: prevent "empty acquisition" async commands
    
    This driver currently allows a cmd->stop_src == TRIG_COUNT with a cmd->stop_arg
    of 0 for both the analog input and output async commands. The (*do_cmd) for
    both subdevices sets up and starts the command without handling the "empty
    acquisition". This results in the interrupt functions trying to transfer 0 data
    samples.
    
    Validate that the cmd->stop_arg is >= 1 in the (*do_cmdtest) to prevent the
    "empty acquisition".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 961903e1860d..1ec363b7505c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -886,7 +886,9 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
@@ -1079,7 +1081,9 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
 
-	if (cmd->stop_src == TRIG_NONE)
+	if (cmd->stop_src == TRIG_COUNT)
+		err |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);
+	else	/* TRIG_NONE */
 		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)

commit fa8e8c8b4f5b3f3d57b75817a4a3b54cb9fac596
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Sep 9 11:26:24 2014 +0100

    staging: comedi: cb_pcidas: replace comedi_board() calls
    
    The `comedi_board(dev)` inline function calls just return
    `dev->board_ptr`.  Expand the inline function calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f5dd7dd7d60a..961903e1860d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -743,7 +743,7 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 				   unsigned int channel, unsigned int value)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 
 	if (devpriv->trimpot_value[channel] == value)
@@ -817,7 +817,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -939,7 +939,7 @@ static void cb_pcidas_ai_load_counters(struct comedi_device *dev)
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1042,7 +1042,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	unsigned int arg;
@@ -1134,7 +1134,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int trig_num)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
 	struct comedi_async *async = s->async;
@@ -1266,7 +1266,7 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 {
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
@@ -1321,7 +1321,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *)d;
-	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	const struct cb_pcidas_board *thisboard = dev->board_ptr;
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;

commit 07b2eb0e844377cf55dbf828ab817160ca6275fc
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Sep 3 13:45:35 2014 +0100

    staging: comedi: cb_pcidas: use CMDF_WAKE_EOS
    
    Replace use of `TRIG_WAKE_EOS` command flag with the new name
    `CMDF_WAKE_EOS`.  The numeric value is unchanged.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a0bb4c869044..f5dd7dd7d60a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -981,7 +981,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
 	devpriv->adc_fifo_bits &= ~INT_MASK;
-	if (cmd->flags & TRIG_WAKE_EOS) {
+	if (cmd->flags & CMDF_WAKE_EOS) {
 		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {
 			/* interrupt end of burst */
 			devpriv->adc_fifo_bits |= INT_EOS;

commit aac307f9dd5ce1fe651140a036ab4b0a0571b54a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 17:55:48 2014 -0700

    staging: comedi: comedi_pci: introduce comedi_pci_detach()
    
    Introduce a generic (*detach) function for comedi PCI drivers to handle
    the boilerplate code needed to detach a PCI driver.
    
    This function works similar to comedi_legacy_detach() where it will:
    
      * free the dev->irq if it has been requested
      * iounmap the dev->mmio addres if it has been ioremap'ed
    
    The helper then calls comedi_pci_disable() to release the regions and
    disable the PCI device.
    
    Use the new helper directly for the (*detach) in the following cases:
    
      * where comedi_pci_disable() is used directly for the (*detach)
      * where the detach function is just boilerplate
    
    Use the new helper in the (*detach) of the simpler PCI drivers. Call
    the helper after disabling interrupts (reset) and before any additional
    cleanup (kfree) to avoid any race conditions with the interrupt handler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b2be8f3251e1..a0bb4c869044 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1589,15 +1589,11 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	if (devpriv) {
-		if (devpriv->s5933_config) {
-			outl(INTCSR_INBOX_INTR_STATUS,
-			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-		}
+	if (devpriv && devpriv->s5933_config) {
+		outl(INTCSR_INBOX_INTR_STATUS,
+		     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 	}
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	comedi_pci_disable(dev);
+	comedi_pci_detach(dev);
 }
 
 static struct comedi_driver cb_pcidas_driver = {

commit 46da1c8fe35026756154a11909dcc4e3fd4bcf00
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Aug 25 16:04:50 2014 -0700

    staging: comedi: cb_pcidas: use comedi_subdevice 'readback'
    
    Use the new comedi_subdevice 'readback' member and the core provided
    (*insn_read) for the readback of the analog output subdevice channels.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f372b0306b38..b2be8f3251e1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -360,8 +360,6 @@ struct cb_pcidas_private {
 	unsigned int ao_divisor2;
 	/* number of analog output samples remaining */
 	unsigned int ao_count;
-	/* cached values for readback */
-	unsigned short ao_value[2];
 	unsigned int caldac_value[NUM_CHANNELS_8800];
 	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;
@@ -484,7 +482,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
-	devpriv->ao_value[chan] = data[0];
+	s->readback[chan] = data[0];
 
 	/* send data */
 	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(chan));
@@ -515,7 +513,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/* remember value for readback */
-	devpriv->ao_value[chan] = data[0];
+	s->readback[chan] = data[0];
 
 	/* send data */
 	outw(data[0], devpriv->ao_registers + DACDATA);
@@ -523,18 +521,6 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	return insn->n;
 }
 
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      struct comedi_insn *insn,
-				      unsigned int *data)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-
-	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
-
-	return 1;
-}
-
 static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 {
 	static const int timeout = 1000;
@@ -1511,16 +1497,22 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		 */
 		s->maxdata = (1 << thisboard->ai_bits) - 1;
 		s->range_table = &cb_pcidas_ao_ranges;
-		s->insn_read = cb_pcidas_ao_readback_insn;
+		/* default to no fifo (*insn_write) */
+		s->insn_write = cb_pcidas_ao_nofifo_winsn;
+		s->insn_read = comedi_readback_insn_read;
+
+		ret = comedi_alloc_subdev_readback(s);
+		if (ret)
+			return ret;
+
 		if (thisboard->has_ao_fifo) {
 			dev->write_subdev = s;
 			s->subdev_flags |= SDF_CMD_WRITE;
+			/* use fifo (*insn_write) instead */
 			s->insn_write = cb_pcidas_ao_fifo_winsn;
 			s->do_cmdtest = cb_pcidas_ao_cmdtest;
 			s->do_cmd = cb_pcidas_ao_cmd;
 			s->cancel = cb_pcidas_ao_cancel;
-		} else {
-			s->insn_write = cb_pcidas_ao_nofifo_winsn;
 		}
 	} else {
 		s->type = COMEDI_SUBD_UNUSED;

commit 4085e93b9fecfad454159694c19efc36e7ac1cdf
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:26 2014 -0700

    staging: comedi: 8255: refactor how the (*io) function works
    
    Currently, all users of is module that use the default (*io) function
    pass an 'iobase' to subdev_8255_init() of the form:
    
      dev->iobase + OFFSET_TO_8255_BASE_REG
    
    Now that the (*io) callback includes the comedi_device 'dev' pointer
    the 'dev->iobase' does not need to be included.
    
    Modify the default (*io) function, subdev_8255_io(), to automatically
    add the dev->iobase to the address when reading/writing the port.
    
    For aesthetics, rename the subdevice private data member to 'regbase'.
    Also, rename the local variables in this module that are used to
    access this member.
    
    Add a comment in dev_8255_attach() about the 'iobase' that is passed
    to subdev_8255_init(). For manually attached 8255 devices the io
    region is requested with __comedi_request_region() which does not
    set dev->iobase. For these devices the 'regbase' is actually the
    'iobase'.
    
    Remove the, now unnecessary, dev->iobase from all the callers of
    subdev_8255_init(). There are a couple drivers that only passed the
    dev->iobase. For those drivers pass a 'regbase' of 0x00.
    
    Note that the das16m1 driver is a bit goofy. The devpriv->extra_iobase
    is requested using __comedi_request_region() which does not set the
    dev->iobase. But the starting address passed is dev->iobase + DAS16M1_82C55
    so a 'regbase' of DAS16M1_82C55 is passed to subdev_8255_init().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b48540b3b66c..f372b0306b38 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1528,7 +1528,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/* 8255 */
 	s = &dev->subdevices[2];
-	ret = subdev_8255_init(dev, s, NULL, dev->iobase + DIO_8255);
+	ret = subdev_8255_init(dev, s, NULL, DIO_8255);
 	if (ret)
 		return ret;
 

commit 3a94180cf224cf0c3136c09b3cde69561ba94bda
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Aug 12 11:41:15 2014 -0700

    staging: comedi: cb_pcidas: use dev->iobase for PCI bar 3
    
    Currently the base address of the 8254 and 8255 devices, found in
    PCI bar 3, is saved in the private data as 'pacer_counter_dio'.
    The 'iobase' in the comedi_device is currently unused.
    
    Save the address from PCI bar 3 in the comedi_device and remove
    the unnecessary member from the private data.
    
    This will help with some cleanup of the 8255 module.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4a7bd4e5dd72..b48540b3b66c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -342,7 +342,6 @@ struct cb_pcidas_private {
 	unsigned long s5933_config;
 	unsigned long control_status;
 	unsigned long adc_fifo;
-	unsigned long pacer_counter_dio;
 	unsigned long ao_registers;
 	/* divisors of master clock for analog input pacing */
 	unsigned int divisor1;
@@ -942,7 +941,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 static void cb_pcidas_ai_load_counters(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long timer_base = devpriv->pacer_counter_dio + ADC8254;
+	unsigned long timer_base = dev->iobase + ADC8254;
 
 	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
@@ -1194,7 +1193,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 static void cb_pcidas_ao_load_counters(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	unsigned long timer_base = devpriv->pacer_counter_dio + DAC8254;
+	unsigned long timer_base = dev->iobase + DAC8254;
 
 	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
 	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
@@ -1463,7 +1462,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
 	devpriv->control_status = pci_resource_start(pcidev, 1);
 	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
-	devpriv->pacer_counter_dio = pci_resource_start(pcidev, 3);
+	dev->iobase = pci_resource_start(pcidev, 3);
 	if (thisboard->ao_nchan)
 		devpriv->ao_registers = pci_resource_start(pcidev, 4);
 
@@ -1529,8 +1528,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 
 	/* 8255 */
 	s = &dev->subdevices[2];
-	ret = subdev_8255_init(dev, s, NULL,
-			       devpriv->pacer_counter_dio + DIO_8255);
+	ret = subdev_8255_init(dev, s, NULL, dev->iobase + DIO_8255);
 	if (ret)
 		return ret;
 

commit 71e068743a5e4061a7a3c42cc3ac6dbda7a7f76e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Jul 18 17:01:24 2014 -0700

    staging: comedi: drivers: use dev->board_name in request_irq()
    
    Most of the comedi drivers use the dev->board_name for the id string
    passed to request_irq(). Fix the couple that still pass something
    else.
    
    Also, propogate the errno from request_irq().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 8e82383d2fb8..4a7bd4e5dd72 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1471,11 +1471,12 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	outl(INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	if (request_irq(pcidev->irq, cb_pcidas_interrupt,
-			IRQF_SHARED, dev->driver->driver_name, dev)) {
+	ret = request_irq(pcidev->irq, cb_pcidas_interrupt, IRQF_SHARED,
+			  dev->board_name, dev);
+	if (ret) {
 		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
 			pcidev->irq);
-		return -EINVAL;
+		return ret;
 	}
 	dev->irq = pcidev->irq;
 

commit 7ef2890428165abd1936173360f672fda16dda8e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Jul 17 11:57:46 2014 -0700

    staging: comedi: cb_pcidas: remove use of comedi_error()
    
    The comedi_error() function is just a wrapper around dev_err() that adds
    the dev->driver->driver_name prefix to the message and a terminating
    new-line character. The addition of the driver_name is just added noise
    and some of the users of comedi_error() add unnecessary additional new-line
    characters.
    
    Use dev_err() directly instead of comedi_error() to avoid any confusion
    and so that all the comedi generated kernel messages have the same format.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9badd1938b5d..8e82383d2fb8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -621,7 +621,7 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	static const int caldac_8800_udelay = 1;
 
 	if (address >= num_caldac_channels) {
-		comedi_error(dev, "illegal caldac channel");
+		dev_err(dev->class_dev, "illegal caldac channel\n");
 		return -1;
 	}
 
@@ -773,7 +773,7 @@ static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 		trimpot_8402_write(dev, channel, value);
 		break;
 	default:
-		comedi_error(dev, "driver bug?");
+		dev_err(dev->class_dev, "driver bug?\n");
 		return -1;
 	}
 
@@ -1249,7 +1249,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 		break;
 	default:
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		comedi_error(dev, "error setting dac pacer source");
+		dev_err(dev->class_dev, "error setting dac pacer source\n");
 		return -1;
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -1300,7 +1300,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 			if (cmd->stop_src == TRIG_NONE ||
 			    (cmd->stop_src == TRIG_COUNT
 			     && devpriv->ao_count)) {
-				comedi_error(dev, "dac fifo underflow");
+				dev_err(dev->class_dev, "dac fifo underflow\n");
 				async->events |= COMEDI_CB_ERROR;
 			}
 			async->events |= COMEDI_CB_EOA;
@@ -1411,8 +1411,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
-		comedi_error(dev,
-			     "bug! encountered end of acquisition interrupt?");
+		dev_err(dev->class_dev,
+			"bug! encountered end of acquisition interrupt?\n");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
@@ -1421,7 +1421,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	}
 	/* check for fifo overflow */
 	if (status & LADFUL) {
-		comedi_error(dev, "fifo overflow");
+		dev_err(dev->class_dev, "fifo overflow\n");
 		/*  clear overflow interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,

commit 57ec1abf4d59c7a2490ed113b41e3b0b147f0e12
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jul 16 10:43:29 2014 -0700

    staging: comedi: cb_pcidas: checkpatch.pl cleanup (break not useful)
    
    Fix the checkpatch.pl warnings:
    
    WARNING: break is not useful after a goto or return
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7377da1aff7c..9badd1938b5d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -461,7 +461,6 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 		break;
 	default:
 		return -EINVAL;
-		break;
 	}
 	return insn->n;
 }
@@ -776,7 +775,6 @@ static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 	default:
 		comedi_error(dev, "driver bug?");
 		return -1;
-		break;
 	}
 
 	return 1;
@@ -1253,7 +1251,6 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		comedi_error(dev, "error setting dac pacer source");
 		return -1;
-		break;
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 

commit bedd62fc6d35a99e19710f05aabaec9d6c19575d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:30:50 2014 -0700

    staging: comedi: cb_pcidas: use comedi_cmd pointer
    
    Use the local variable to access the comedi_cmd as a pointer instead
    of getting to it from the comedi_async pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7b029596b11f..7377da1aff7c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1321,7 +1321,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 					       num_points * sizeof(short));
 		num_points = num_bytes / sizeof(short);
 
-		if (async->cmd.stop_src == TRIG_COUNT)
+		if (cmd->stop_src == TRIG_COUNT)
 			devpriv->ao_count -= num_points;
 		/*  write data to board's fifo */
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
@@ -1343,6 +1343,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
+	struct comedi_cmd *cmd;
 	int status, s5933_status;
 	int half_fifo = thisboard->fifo_size / 2;
 	unsigned int num_samples, i;
@@ -1353,6 +1354,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	async = s->async;
+	cmd = &async->cmd;
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -1375,7 +1377,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	if (status & ADHFI) {
 		/*  read data */
 		num_samples = half_fifo;
-		if (async->cmd.stop_src == TRIG_COUNT &&
+		if (cmd->stop_src == TRIG_COUNT &&
 		    num_samples > devpriv->count) {
 			num_samples = devpriv->count;
 		}
@@ -1384,7 +1386,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
 					  num_samples * sizeof(short));
 		devpriv->count -= num_samples;
-		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0)
+		if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)
 			async->events |= COMEDI_CB_EOA;
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
@@ -1399,7 +1401,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 					INT_ADCFIFO)) == 0)
 				break;
 			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
-			if (async->cmd.stop_src == TRIG_COUNT &&
+			if (cmd->stop_src == TRIG_COUNT &&
 			    --devpriv->count == 0) {
 				/* end of acquisition */
 				async->events |= COMEDI_CB_EOA;

commit 815bb5b5c9778a9ee019475911db02cc395e676a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue May 27 10:12:43 2014 -0700

    staging: comedi: cb_pcidas: use comedi_fc helpers to validate timer args
    
    Use the comedi_fc helper cfc_check_trigger_arg_is() to validate the
    trigger arguments when the source is TRIG_TIMER.
    
    All the arguments are unsigned int, change the local variable to an
    unsigned int and rename it for aesthetic reasons.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0df55dd0fb53..7b029596b11f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -837,7 +837,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	const struct cb_pcidas_board *thisboard = comedi_board(dev);
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -912,22 +912,20 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
+		arg = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->scan_begin_arg, cmd->flags);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
-		tmp = cmd->convert_arg;
+		arg = cmd->convert_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &devpriv->divisor1,
 					  &devpriv->divisor2,
-					  &cmd->convert_arg, cmd->flags);
-		if (tmp != cmd->convert_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->convert_arg, arg);
 	}
 
 	if (err)
@@ -1064,7 +1062,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	const struct cb_pcidas_board *thisboard = comedi_board(dev);
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
-	int tmp;
+	unsigned int arg;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -1107,13 +1105,12 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	/* step 4: fix up any arguments */
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		tmp = cmd->scan_begin_arg;
+		arg = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
 					  &devpriv->ao_divisor1,
 					  &devpriv->ao_divisor2,
-					  &cmd->scan_begin_arg, cmd->flags);
-		if (tmp != cmd->scan_begin_arg)
-			err++;
+					  &arg, cmd->flags);
+		err |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, arg);
 	}
 
 	if (err)

commit 33eafb7761d244a3d41a25b56dd17ba05634907e
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:29 2014 -0700

    staging: comedi: cb_pcidas: don't calc ao pacer divisors twice
    
    The analog output async command can use the pacer for the scan_begin_src.
    The (*do_cmdtest) calculates the divisors when validating the cmd argument.
    
    There is no reason to recalc the divisors in the (*do_cmd). Just use the
    values from the private data.
    
    For aesthetics, factor out the code that loads the counters to match the
    analog input. Refactor the code to use the i8254_set_mode() and i8254_write()
    helpers instead of i8254_load(). This allows us to use the I8254_* defines
    when setting the mode to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 48ac1f43a3d4..0df55dd0fb53 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -943,7 +943,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_load_counters(struct comedi_device *dev)
+static void cb_pcidas_ai_load_counters(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long timer_base = devpriv->pacer_counter_dio + ADC8254;
@@ -991,7 +991,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER || cmd->convert_src == TRIG_TIMER)
-		cb_pcidas_load_counters(dev);
+		cb_pcidas_ai_load_counters(dev);
 
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT)
@@ -1196,6 +1196,18 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	return 0;
 }
 
+static void cb_pcidas_ao_load_counters(struct comedi_device *dev)
+{
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned long timer_base = devpriv->pacer_counter_dio + DAC8254;
+
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
+
+	i8254_write(timer_base, 0, 1, devpriv->ao_divisor1);
+	i8254_write(timer_base, 0, 2, devpriv->ao_divisor2);
+}
+
 static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -1225,18 +1237,9 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
 
 	/*  load counters */
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-					  &devpriv->ao_divisor1,
-					  &devpriv->ao_divisor2,
-					  &cmd->scan_begin_arg, cmd->flags);
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		cb_pcidas_ao_load_counters(dev);
 
-		/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,
-			   devpriv->ao_divisor1, 2);
-		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,
-			   devpriv->ao_divisor2, 2);
-	}
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;

commit f513b63f73e8bebc67a74dd46917788bfdf9c7cd
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Apr 29 12:59:28 2014 -0700

    staging: comedi: cb_pcidas: don't calc ai pacer divisors twice
    
    The analog input async command can use the pacer for the scan_bagin_src
    or the convert_src. The (*do_cmdtest) validates that only one of these
    sources has the TRIG_TIMER selected and calculates the divisors when
    validating the cmd argument.
    
    There is no reason to recalc the divisors in the (*do_cmd). Just use
    the values from the private data.
    
    Also, refactor cb_pcidas_load_counters() to use the i8254_set_mode()
    and i8254_write() helpers instead of i8254_load(). This allows us to
    use the I8254_* defines when setting the mode to clarify the code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 26fc00e552a8..48ac1f43a3d4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -943,20 +943,16 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-				    int rounding_flags)
+static void cb_pcidas_load_counters(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned long timer_base = devpriv->pacer_counter_dio + ADC8254;
 
-	i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
-				  &devpriv->divisor1, &devpriv->divisor2,
-				  ns, rounding_flags);
+	i8254_set_mode(timer_base, 0, 1, I8254_MODE2 | I8254_BINARY);
+	i8254_set_mode(timer_base, 0, 2, I8254_MODE2 | I8254_BINARY);
 
-	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
-		   devpriv->divisor1, 2);
-	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
-		   devpriv->divisor2, 2);
+	i8254_write(timer_base, 0, 1, devpriv->divisor1);
+	i8254_write(timer_base, 0, 2, devpriv->divisor2);
 }
 
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
@@ -994,12 +990,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 	/*  load counters */
-	if (cmd->convert_src == TRIG_TIMER)
-		cb_pcidas_load_counters(dev, &cmd->convert_arg,
-					cmd->flags & TRIG_ROUND_MASK);
-	else if (cmd->scan_begin_src == TRIG_TIMER)
-		cb_pcidas_load_counters(dev, &cmd->scan_begin_arg,
-					cmd->flags & TRIG_ROUND_MASK);
+	if (cmd->scan_begin_src == TRIG_TIMER || cmd->convert_src == TRIG_TIMER)
+		cb_pcidas_load_counters(dev);
 
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT)

commit 384e483fb9d487bb318acc7098f61d3feffa4d79
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:57 2014 -0700

    staging: comedi: cb_pcidas: fix the ao cmd->start_arg use for TRIG_INT
    
    This driver only supports a cmd->start_src of TRIG_INT for ai commands. The
    cmd->start_arg is trivially validated to be 0. For TRIG_INT source, the
    cmd->start_arg is actually the valid trig_num that is passed to the async
    (*inttrig) callback.
    
    Refactor the (*inttrig) function so that the cmd->start_arg is used to check
    the trig_num instead of the open coded value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 523378fbf302..26fc00e552a8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1169,7 +1169,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 
-	if (trig_num != 0)
+	if (trig_num != cmd->start_arg)
 		return -EINVAL;
 
 	/*  load up fifo */

commit 96997b0efa8b82162f78a294669de44320a8c87f
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Apr 17 10:07:56 2014 -0700

    staging: comedi: cb_pcidas: clarify the ai cmd->start_arg validation
    
    This driver supports two cmd->start_src values, TRIG_NOW and TRIG_EXT.
    
    For aesthetics, replace the default case when validating the cmd->start_arg
    with the proper case statement.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 70d926707777..523378fbf302 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -872,9 +872,12 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
 	switch (cmd->start_src) {
+	case TRIG_NOW:
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
+		break;
 	case TRIG_EXT:
 		/* External trigger, only CR_EDGE and CR_INVERT flags allowed */
 		if ((cmd->start_arg
@@ -888,9 +891,6 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 			err |= -EINVAL;
 		}
 		break;
-	default:
-		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
-		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER)

commit e74592e0c01c6b9dc9c87146b7a894cfcb84d382
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 16 14:19:10 2014 -0700

    staging: comedi: cb_pcidas: factor out chanlist checking from (*do_cmdtest)
    
    Step 5 of the (*do_cmdtest) validates that the cmd->chanlist is compatible
    with the hardware.
    
    For aesthetics, factor out the step 5 code for the analog input and analog
    output async command support. Tidy up the factored out code.
    
    To minimize the noise, change the comedi_error(), which is a wrapper around
    dev_err(), to dev_dbg().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 83a265f3408c..70d926707777 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -803,6 +803,33 @@ static int trimpot_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
+static int cb_pcidas_ai_check_chanlist(struct comedi_device *dev,
+				       struct comedi_subdevice *s,
+				       struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+	unsigned int range0 = CR_RANGE(cmd->chanlist[0]);
+	int i;
+
+	for (i = 1; i < cmd->chanlist_len; i++) {
+		unsigned int chan = CR_CHAN(cmd->chanlist[i]);
+		unsigned int range = CR_RANGE(cmd->chanlist[i]);
+
+		if (chan != (chan0 + i) % s->n_chan) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must be consecutive channels, counting upwards\n");
+			return -EINVAL;
+		}
+
+		if (range != range0) {
+			dev_dbg(dev->class_dev,
+				"entries in chanlist must all have the same gain\n");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
 static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -811,7 +838,6 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
-	int i, gain, start_chan;
 
 	/* Step 1 : check if triggers are trivially valid */
 
@@ -907,24 +933,9 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/*  check channel/gain list against card's limitations */
-	if (cmd->chanlist) {
-		gain = CR_RANGE(cmd->chanlist[0]);
-		start_chan = CR_CHAN(cmd->chanlist[0]);
-		for (i = 1; i < cmd->chanlist_len; i++) {
-			if (CR_CHAN(cmd->chanlist[i]) !=
-			    (start_chan + i) % s->n_chan) {
-				comedi_error(dev,
-					     "entries in chanlist must be consecutive channels, counting upwards\n");
-				err++;
-			}
-			if (CR_RANGE(cmd->chanlist[i]) != gain) {
-				comedi_error(dev,
-					     "entries in chanlist must all have the same gain\n");
-				err++;
-			}
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= cb_pcidas_ai_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;
@@ -1035,6 +1046,25 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static int cb_pcidas_ao_check_chanlist(struct comedi_device *dev,
+				       struct comedi_subdevice *s,
+				       struct comedi_cmd *cmd)
+{
+	unsigned int chan0 = CR_CHAN(cmd->chanlist[0]);
+
+	if (cmd->chanlist_len > 1) {
+		unsigned int chan1 = CR_CHAN(cmd->chanlist[1]);
+
+		if (chan0 != 0 || chan1 != 1) {
+			dev_dbg(dev->class_dev,
+				"channels must be ordered channel 0, channel 1 in chanlist\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
@@ -1097,15 +1127,9 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 4;
 
-	/*  check channel/gain list against card's limitations */
-	if (cmd->chanlist && cmd->chanlist_len > 1) {
-		if (CR_CHAN(cmd->chanlist[0]) != 0 ||
-		    CR_CHAN(cmd->chanlist[1]) != 1) {
-			comedi_error(dev,
-				     "channels must be ordered channel 0, channel 1 in chanlist\n");
-			err++;
-		}
-	}
+	/* Step 5: check channel list if it exists */
+	if (cmd->chanlist && cmd->chanlist_len > 0)
+		err |= cb_pcidas_ao_check_chanlist(dev, s, cmd);
 
 	if (err)
 		return 5;

commit 38255b623e50640eee2ef63d2a1d34589a90ef76
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Fri Mar 7 17:31:37 2014 -0700

    staging: comedi: cb_pcidas: use cfc_handle_events()
    
    Use the comedi_fc helper function to automatically call the subdevice
    (*cancel) function when needed and call comedi_event().
    
    Also, remove the clearing of the events, comedi_event() does that.
    
    In the Kconfig, COMEDI_CB_PCIDAS already selects COMEDI_FC.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 5452b718f93f..83a265f3408c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1277,8 +1277,6 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 	unsigned int num_points;
 	unsigned long flags;
 
-	async->events = 0;
-
 	if (status & DAEMI) {
 		/*  clear dac empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
@@ -1290,7 +1288,6 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 			    (cmd->stop_src == TRIG_COUNT
 			     && devpriv->ao_count)) {
 				comedi_error(dev, "dac fifo underflow");
-				cb_pcidas_ao_cancel(dev, s);
 				async->events |= COMEDI_CB_ERROR;
 			}
 			async->events |= COMEDI_CB_EOA;
@@ -1320,7 +1317,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 }
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
@@ -1340,7 +1337,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		return IRQ_NONE;
 
 	async = s->async;
-	async->events = 0;
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -1372,10 +1368,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
 					  num_samples * sizeof(short));
 		devpriv->count -= num_samples;
-		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {
+		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0)
 			async->events |= COMEDI_CB_EOA;
-			cb_pcidas_cancel(dev, s);
-		}
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
@@ -1392,7 +1386,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			if (async->cmd.stop_src == TRIG_COUNT &&
 			    --devpriv->count == 0) {
 				/* end of acquisition */
-				cb_pcidas_cancel(dev, s);
 				async->events |= COMEDI_CB_EOA;
 				break;
 			}
@@ -1419,11 +1412,10 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		outw(devpriv->adc_fifo_bits | LADFUL,
 		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
-		cb_pcidas_cancel(dev, s);
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
 
-	comedi_event(dev, s);
+	cfc_handle_events(dev, s);
 
 	return IRQ_HANDLED;
 }

commit 8abc7287f6ada9f8378941b81434242db832b5f4
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 15:20:33 2014 -0700

    staging: comedi: cb_pcidas: trigger sources are validated in (*do_cmdtest)
    
    The trigger sources were already validataed in the (*do_cmdtest) before the
    (*do_cmd) is called. Refactor the code in cb_pcidas_ai_cmd() to remove the
    final else which can never be reached.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7d068ebe0575..5452b718f93f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1017,9 +1017,9 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 
 	/*  set start trigger and burst mode */
 	bits = 0;
-	if (cmd->start_src == TRIG_NOW)
+	if (cmd->start_src == TRIG_NOW) {
 		bits |= SW_TRIGGER;
-	else if (cmd->start_src == TRIG_EXT) {
+	} else {	/* TRIG_EXT */
 		bits |= EXT_TRIGGER | TGEN | XTRCL;
 		if (thisboard->is_1602) {
 			if (cmd->start_arg & CR_INVERT)
@@ -1027,9 +1027,6 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			if (cmd->start_arg & CR_EDGE)
 				bits |= TGSEL;
 		}
-	} else {
-		comedi_error(dev, "bug!");
-		return -1;
 	}
 	if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
 		bits |= BURSTE;

commit 06cb9ba887d07e80ac51d8a233d56e5fd39bc175
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 10 11:49:15 2014 -0700

    staging: comedi: cb_pcidas: use comedi_timeout()
    
    Use comedi_timeout() to wait for the analog input end-of-conversion.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 69fbda7e3bc2..7d068ebe0575 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -376,6 +376,20 @@ static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }
 
+static int cb_pcidas_ai_eoc(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn,
+			    unsigned long context)
+{
+	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned int status;
+
+	status = inw(devpriv->control_status + ADCMUX_CONT);
+	if (status & EOC)
+		return 0;
+	return -EBUSY;
+}
+
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
@@ -385,7 +399,8 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned int aref = CR_AREF(insn->chanspec);
 	unsigned int bits;
-	int n, i;
+	int ret;
+	int n;
 
 	/* enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
@@ -415,13 +430,9 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 		outw(0, devpriv->adc_fifo + ADCDATA);
 
 		/* wait for conversion to end */
-		/* return -ETIMEDOUT if there is a timeout */
-		for (i = 0; i < 10000; i++) {
-			if (inw(devpriv->control_status + ADCMUX_CONT) & EOC)
-				break;
-		}
-		if (i == 10000)
-			return -ETIMEDOUT;
+		ret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);
+		if (ret)
+			return ret;
 
 		/* read data */
 		data[n] = inw(devpriv->adc_fifo + ADCDATA);

commit c93999c21319439c4fe2da85f2ec40ed477379ac
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Feb 3 11:26:50 2014 -0700

    staging: comedi: drivers: remove final 'attach' messages
    
    These messages are just added noise. Remove them.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9819be092f8d..69fbda7e3bc2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1576,9 +1576,6 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	dev_info(dev->class_dev, "%s: %s attached\n",
-		dev->driver->driver_name, dev->board_name);
-
 	return 0;
 }
 

commit 1491ca0d9a3ffb289dbd2ee725af448abb34a6b2
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Dec 9 17:31:05 2013 -0700

    staging: comedi: cb_pcidas: tidy up comedi_lrange tables
    
    Tidy up the whitespace in the comedi_lrange tables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 22c1623c048b..9819be092f8d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -181,43 +181,40 @@ static inline unsigned int DAC_DATA_REG(unsigned int channel)
 
 /* analog input ranges for most boards */
 static const struct comedi_lrange cb_pcidas_ranges = {
-	8,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(5),
-	 BIP_RANGE(2.5),
-	 BIP_RANGE(1.25),
-	 UNI_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(2.5),
-	 UNI_RANGE(1.25)
-	 }
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(5),
+		BIP_RANGE(2.5),
+		BIP_RANGE(1.25),
+		UNI_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(2.5),
+		UNI_RANGE(1.25)
+	}
 };
 
 /* pci-das1001 input ranges */
 static const struct comedi_lrange cb_pcidas_alt_ranges = {
-	8,
-	{
-	 BIP_RANGE(10),
-	 BIP_RANGE(1),
-	 BIP_RANGE(0.1),
-	 BIP_RANGE(0.01),
-	 UNI_RANGE(10),
-	 UNI_RANGE(1),
-	 UNI_RANGE(0.1),
-	 UNI_RANGE(0.01)
-	 }
+	8, {
+		BIP_RANGE(10),
+		BIP_RANGE(1),
+		BIP_RANGE(0.1),
+		BIP_RANGE(0.01),
+		UNI_RANGE(10),
+		UNI_RANGE(1),
+		UNI_RANGE(0.1),
+		UNI_RANGE(0.01)
+	}
 };
 
 /* analog output ranges */
 static const struct comedi_lrange cb_pcidas_ao_ranges = {
-	4,
-	{
-	 BIP_RANGE(5),
-	 BIP_RANGE(10),
-	 UNI_RANGE(5),
-	 UNI_RANGE(10),
-	 }
+	4, {
+		BIP_RANGE(5),
+		BIP_RANGE(10),
+		UNI_RANGE(5),
+		UNI_RANGE(10)
+	}
 };
 
 enum trimpot_model {

commit 41e043fcfa2236bb2c4a8335eb09f4c8cee224b3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Dec 3 08:26:00 2013 +0900

    staging: remove DEFINE_PCI_DEVICE_TABLE macro
    
    Don't use DEFINE_PCI_DEVICE_TABLE macro, because this macro
    is not preferred.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e72a403db17c..22c1623c048b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1614,7 +1614,7 @@ static int cb_pcidas_pci_probe(struct pci_dev *dev,
 				      id->driver_data);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
+static const struct pci_device_id cb_pcidas_pci_table[] = {
 	{ PCI_VDEVICE(CB, 0x0001), BOARD_PCIDAS1602_16 },
 	{ PCI_VDEVICE(CB, 0x000f), BOARD_PCIDAS1200 },
 	{ PCI_VDEVICE(CB, 0x0010), BOARD_PCIDAS1602_12 },

commit 79e3b119870122c38dc474af8f6a7526735f23b2
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Wed Oct 16 14:40:14 2013 +0100

    staging: comedi: cb_pcidas: sample types are unsigned
    
    Sample values in comedi are generally represented by unsigned values.
    Change the element types of `ai_buffer[]`, `ao_buffer[]` and
    `ao_value[]` in `struct cb_pcidas_private` to `unsigned short` for
    consistency.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0891659f9eb5..e72a403db17c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -357,15 +357,15 @@ struct cb_pcidas_private {
 	unsigned int s5933_intcsr_bits;
 	unsigned int ao_control_bits;
 	/* fifo buffers */
-	short ai_buffer[AI_BUFFER_SIZE];
-	short ao_buffer[AO_BUFFER_SIZE];
+	unsigned short ai_buffer[AI_BUFFER_SIZE];
+	unsigned short ao_buffer[AO_BUFFER_SIZE];
 	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
 	/* number of analog output samples remaining */
 	unsigned int ao_count;
 	/* cached values for readback */
-	int ao_value[2];
+	unsigned short ao_value[2];
 	unsigned int caldac_value[NUM_CHANNELS_8800];
 	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;

commit cb9cfd7ed3f6ed4c40167b4251cdb382b6b3ba1c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Thu Sep 26 11:40:15 2013 -0700

    staging: comedi: 8253.h: tidy up the i8253_cascade_ns_to_timer*() users
    
    Introduce a couple defines for the common 8254 oscillator base values
    used in the comedi drivers and remove the custom defines and open
    coded values.
    
    Change the i8253_cascade_ns_to_timer_2div() calls in the drivers to
    the more generic i8253_cascade_ns_to_timer(). They are identical due
    to the #define in the 8253.h header.
    
    Remove the extra mask by TRIG_ROUND_MASK of the 'round_mode' parameter
    to i8253_cascade_ns_to_timer(). That function already handles the mask.
    
    Tidy up all the calls to i8253_cascade_ns_to_timer().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 41d89ee7fa33..0891659f9eb5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -73,7 +73,6 @@ analog triggering on 1602 series
 #include "amcc_s5933.h"
 #include "comedi_fc.h"
 
-#define TIMER_BASE		100	/* 10MHz master clock */
 #define AI_BUFFER_SIZE		1024	/* max ai fifo size */
 #define AO_BUFFER_SIZE		1024	/* max ao fifo size */
 #define NUM_CHANNELS_8800	8
@@ -880,21 +879,19 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					       &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd->scan_begin_arg),
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->scan_begin_arg, cmd->flags);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					       &(devpriv->divisor1),
-					       &(devpriv->divisor2),
-					       &(cmd->convert_arg),
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					  &devpriv->divisor1,
+					  &devpriv->divisor2,
+					  &cmd->convert_arg, cmd->flags);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -932,9 +929,9 @@ static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 
-	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-				       &(devpriv->divisor2), ns,
-				       rounding_flags & TRIG_ROUND_MASK);
+	i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+				  &devpriv->divisor1, &devpriv->divisor2,
+				  ns, rounding_flags);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
@@ -1084,11 +1081,10 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					       &(devpriv->ao_divisor1),
-					       &(devpriv->ao_divisor2),
-					       &(cmd->scan_begin_arg),
-					       cmd->flags & TRIG_ROUND_MASK);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					  &devpriv->ao_divisor1,
+					  &devpriv->ao_divisor2,
+					  &cmd->scan_begin_arg, cmd->flags);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1209,11 +1205,10 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-					       &(devpriv->ao_divisor1),
-					       &(devpriv->ao_divisor2),
-					       &(cmd->scan_begin_arg),
-					       cmd->flags);
+		i8253_cascade_ns_to_timer(I8254_OSC_BASE_10MHZ,
+					  &devpriv->ao_divisor1,
+					  &devpriv->ao_divisor2,
+					  &cmd->scan_begin_arg, cmd->flags);
 
 		/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,

commit ce157f8032bbd46d9427034c335b0afd751da25d
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 17:04:43 2013 -0700

    staging: comedi: don't rely on comedidev.h to include headers
    
    comedidev.h is the main kernel header for comedi. Every comedi
    driver includes this header which then includes a number of
    <linux/*> headers. All the drivers need <linux/module.h> and some
    of them need <linux/delay.h>. The rest are not needed by any of
    the drivers.
    
    Remove all the includes in comedidev.h except for <linux/dma-mapping.h>,
    which is needed to pick up the enum dma_data_direction for the
    comedi_subdevice definition, and "comedi.h", which is the uapi
    header for comedi.
    
    Add <linux/module.h> to all the comedi drivers and <linux/delay.h>
    to the couple that need it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index d70d1dd30502..41d89ee7fa33 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -61,6 +61,7 @@ AI Triggering:
 analog triggering on 1602 series
 */
 
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 0bdab509bf9c6d838dc0a3b1d68bbf841fc20b5a
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Jun 24 16:55:44 2013 -0700

    staging: comedi: use comedi_alloc_devpriv()
    
    Use the helper function to allocate memory and set the comedi_device
    private data pointer.
    
    This removes the dependency on slab.h from most of the drivers so
    remove the global #include in comedidev.h and the local #include
    in some of the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 58bca184bf22..d70d1dd30502 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1444,10 +1444,9 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	dev->board_ptr  = thisboard;
 	dev->board_name = thisboard->name;
 
-	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	devpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));
 	if (!devpriv)
 		return -ENOMEM;
-	dev->private = devpriv;
 
 	ret = comedi_pci_enable(dev);
 	if (ret)

commit 588ba6dc5fb4bdca47a3da38c2718fbb82d3eee1
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Jun 11 11:32:29 2013 -0700

    staging: comedi: drivers: let core handle freeing s->private
    
    Introduce a new subdevice runflags, SRF_FREE_SPRIV, and a new helper
    function, comedi_set_spriv(), that the drivers can use to set the
    comedi_subdevice private data pointer. The helper function will also
    set SRF_FREE_SPRIV to allow the comedi core to automatically free the
    subdevice private data during the cleanup_device() stage of the detach.
    
    Currently s->private is only allocated by the 8255, addi_watchdog,
    amplc_dio200_common, and ni_65xx drivers. All users of those drivers
    can then have the comedi_spriv_free() calls removed and in many cases
    the (*detach) can then simply be the appropriate comedi core provided
    function.
    
    The ni_65xx driver uses a helper function, ni_65xx_alloc_subdevice_private(),
    to allocate the private data. Refactor the function to return an errno
    or call comedi_set_spriv() instead of returning a pointer to the private
    data and requiring the caller to handle it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 172f459b0af2..58bca184bf22 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1602,7 +1602,6 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	comedi_spriv_free(dev, 2);
 	comedi_pci_disable(dev);
 }
 

commit 641f064e5df6fb3aaeb6256031a153a5efb16ca6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Apr 24 18:13:24 2013 -0700

    staging: comedi: remove FSF address from boilerplate text
    
    Addresses change...
    
    Remove the paragraph with the FSF address from all the comedi source
    files.
    
    Also, remove the paragraph about the finding the complete GPL in the
    COPYING file since it's unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 53dd298d2b54..172f459b0af2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -19,12 +19,6 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-************************************************************************
 */
 /*
 Driver: cb_pcidas

commit 2f69915c728c3be41e12dbbbdd4eeb8d3388d58c
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Mon Apr 15 16:41:57 2013 -0700

    staging: comedi: introduce, and use, comedi_spriv_free()
    
    The comedi_subdevice 'private' variable is a void * that is available
    for the subdevice to use in manner. It's common in comedi drivers for
    the driver to allocate memory for a subdevice and store the pointer
    to that memory in the 'private' variable. It's then the responsibility
    of the driver to free that memory when the device is detached.
    
    Due to how the attach/detach works in comedi, the drivers need to do
    some sanity checking before they can free the allocated memory during
    the detach.
    
    Introduce a helper function, comedi_spriv_free(), to handle freeing
    the private data allocated for a subdevice. This allows moving all the
    sanity checks into the helper function and makes it safe to call
    with any context. It also allows removing some of the boilerplate
    code in the (*detach) functions.
    
    Remove the subdev_8255_cleanup() export in the 8255 subdevice driver
    as well as the addi_watchdog_cleanup() export in the addi_watchdog
    driver and use the new helper instead.
    
    The amplc_dio200_common driver uses a number of local helper functions
    to free the private data for it's subdevices. Remove those as well and
    use the new helper.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index cdbeb0833d0b..53dd298d2b54 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1608,8 +1608,7 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 	}
 	if (dev->irq)
 		free_irq(dev->irq, dev);
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, &dev->subdevices[2]);
+	comedi_spriv_free(dev, 2);
 	comedi_pci_disable(dev);
 }
 

commit 84b44d08993ffe762d9a86ee2243239350b871a4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:36 2013 +0000

    staging: comedi: remove unneeded settings of `dev->iobase`
    
    Some PCI drivers use the "spare" `iobase` member of `struct
    comedi_device` as a flag to indicate that the call to
    `comedi_pci_enable()` was successful.  This is no longer necessary now
    that `comedi_pci_enable()` and `comedi_pci_disable()` use the
    `ioenabled` member of `struct comedi_device` themselves to keep track of
    what needs to be done.
    
    Remove the unnecessary assignments to the `iobase` member in the
    relevant drivers.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c19e4b2004f8..cdbeb0833d0b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1458,7 +1458,6 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
-	dev->iobase = 1;
 
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
 	devpriv->control_status = pci_resource_start(pcidev, 1);

commit a7401cddcdf739d3cb9598c9b3787a732fc87809
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 15 13:15:33 2013 +0000

    staging: comedi: make 'dev->attached' a bool bit-field
    
    Change the `attached` member of `struct comedi_device` to a 1-bit
    bit-field of type `bool`.  Change assigned values to `true` and `false`
    and replace or remove comparison operations with simple boolean tests.
    
    We'll put some extra bit-fields in the gap later to save space.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7a23d56645e7..c19e4b2004f8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1341,7 +1341,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	static const int timeout = 10000;
 	unsigned long flags;
 
-	if (dev->attached == 0)
+	if (!dev->attached)
 		return IRQ_NONE;
 
 	async = s->async;

commit 818f569fe930c5b8a05d1a44ece3c63c99c13c88
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:36:31 2013 -0700

    staging: comedi_pci: pass comedi_device to comedi_pci_enable()
    
    Make comedi_pci_enable() use the same parameter type as
    comedi_pci_disable(). This also allows comedi_pci_enable
    to automatically determine the resource name passed to
    pci_request_regions().
    
    Make sure the errno value returned is passed on instead of
    assuming an errno. Also, remove any kernel noise that is
    generated when the call fails.
    
    The National Instruments drivers that use the mite module
    currently enable the PCI device in the mite module. For
    those drivers move the call to comedi_pci_enable into the
    driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 04aa8d948a8b..7a23d56645e7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1455,7 +1455,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	dev->private = devpriv;
 
-	ret = comedi_pci_enable(pcidev, dev->board_name);
+	ret = comedi_pci_enable(dev);
 	if (ret)
 		return ret;
 	dev->iobase = 1;

commit 7f072f54ae5dc9965cbe450419b1389d13e2b849
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Mar 13 10:35:51 2013 -0700

    staging: comedi_pci: make comedi_pci_disable() safe to call
    
    Currently all the comedi PCI drivers need to do some checking in
    their (*detach) before calling comedi_pci_disable() in order to
    make sure the PCI device has actually be enabled.
    
    Change the parameter passed to comedi_pci_disable() from a struct
    pci_dev pointer to a comedi_device pointer and have comedi_pci_disable()
    handle all the checking.
    
    For most comedi PCI drivers this also allows removing the local
    variable holding the pointer to the pci_dev. For some of the drivers
    comedi_pci_disable can now be used directly as the (*detach) function.
    
    The National Instruments drivers that use the mite module currently
    enable/disable the PCI device in the mite module. For those drivers
    move the call to comedi_pci_disable into the driver and make sure
    dev->iobase is set to a non-zero value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1f9316996951..04aa8d948a8b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1458,6 +1458,7 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)
 		return ret;
+	dev->iobase = 1;
 
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
 	devpriv->control_status = pci_resource_start(pcidev, 1);
@@ -1599,7 +1600,6 @@ static int cb_pcidas_auto_attach(struct comedi_device *dev,
 static void cb_pcidas_detach(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (devpriv) {
 		if (devpriv->s5933_config) {
@@ -1611,10 +1611,7 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, &dev->subdevices[2]);
-	if (pcidev) {
-		if (devpriv->s5933_config)
-			comedi_pci_disable(pcidev);
-	}
+	comedi_pci_disable(dev);
 }
 
 static struct comedi_driver cb_pcidas_driver = {

commit 9b315bcb6f1d45938658dec82ee356546745b217
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 10:00:15 2013 -0700

    staging: comedi: cb_pcidas: use the pci id_table 'driver_data'
    
    Create an enum to the boardinfo and pass that enum in the pci_driver
    id_table as the driver_data.
    
    Change the macro used to fill in the device table from PCI_DEVICE() to
    PCI_VDEVICE(). This allows passing the enum as the next field.
    
    This allows removing the 'device_id' data from the boardinfo as well
    the search function that was used to locate the boardinfo for the PCI
    device.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 425a5a18a787..1f9316996951 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -231,9 +231,19 @@ enum trimpot_model {
 	AD8402,
 };
 
+enum cb_pcidas_boardid {
+	BOARD_PCIDAS1602_16,
+	BOARD_PCIDAS1200,
+	BOARD_PCIDAS1602_12,
+	BOARD_PCIDAS1200_JR,
+	BOARD_PCIDAS1602_16_JR,
+	BOARD_PCIDAS1000,
+	BOARD_PCIDAS1001,
+	BOARD_PCIDAS1002,
+};
+
 struct cb_pcidas_board {
 	const char *name;
-	unsigned short device_id;
 	int ai_nchan;		/*  Inputs in single-ended mode */
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
@@ -248,9 +258,8 @@ struct cb_pcidas_board {
 };
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
-	{
+	[BOARD_PCIDAS1602_16] = {
 		.name		= "pci-das1602/16",
-		.device_id	= 0x1,
 		.ai_nchan	= 16,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
@@ -262,9 +271,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.trimpot	= AD8402,
 		.has_dac08	= 1,
 		.is_1602	= 1,
-	}, {
+	},
+	[BOARD_PCIDAS1200] = {
 		.name		= "pci-das1200",
-		.device_id	= 0xF,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
@@ -272,9 +281,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-	}, {
+	},
+	[BOARD_PCIDAS1602_12] = {
 		.name		= "pci-das1602/12",
-		.device_id	= 0x10,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
@@ -285,18 +294,18 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
 		.is_1602	= 1,
-	}, {
+	},
+	[BOARD_PCIDAS1200_JR] = {
 		.name		= "pci-das1200/jr",
-		.device_id	= 0x19,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-	}, {
+	},
+	[BOARD_PCIDAS1602_16_JR] = {
 		.name		= "pci-das1602/16/jr",
-		.device_id	= 0x1C,
 		.ai_nchan	= 16,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
@@ -305,18 +314,18 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.trimpot	= AD8402,
 		.has_dac08	= 1,
 		.is_1602	= 1,
-	}, {
+	},
+	[BOARD_PCIDAS1000] = {
 		.name		= "pci-das1000",
-		.device_id	= 0x4C,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-	}, {
+	},
+	[BOARD_PCIDAS1001] = {
 		.name		= "pci-das1001",
-		.device_id	= 0x1a,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
@@ -324,9 +333,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_alt_ranges,
 		.trimpot	= AD7376,
-	}, {
+	},
+	[BOARD_PCIDAS1002] = {
 		.name		= "pci-das1002",
-		.device_id	= 0x1b,
 		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
@@ -1424,31 +1433,18 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static const void *cb_pcidas_find_boardinfo(struct comedi_device *dev,
-					    struct pci_dev *pcidev)
-{
-	const struct cb_pcidas_board *thisboard;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(cb_pcidas_boards); i++) {
-		thisboard = &cb_pcidas_boards[i];
-		if (thisboard->device_id == pcidev->device)
-			return thisboard;
-	}
-	return NULL;
-}
-
 static int cb_pcidas_auto_attach(struct comedi_device *dev,
-					   unsigned long context_unused)
+				 unsigned long context)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
-	const struct cb_pcidas_board *thisboard;
+	const struct cb_pcidas_board *thisboard = NULL;
 	struct cb_pcidas_private *devpriv;
 	struct comedi_subdevice *s;
 	int i;
 	int ret;
 
-	thisboard = cb_pcidas_find_boardinfo(dev, pcidev);
+	if (context < ARRAY_SIZE(cb_pcidas_boards))
+		thisboard = &cb_pcidas_boards[context];
 	if (!thisboard)
 		return -ENODEV;
 	dev->board_ptr  = thisboard;
@@ -1636,14 +1632,14 @@ static int cb_pcidas_pci_probe(struct pci_dev *dev,
 }
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0001) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x000f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0010) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0019) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001c) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x004c) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001a) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001b) },
+	{ PCI_VDEVICE(CB, 0x0001), BOARD_PCIDAS1602_16 },
+	{ PCI_VDEVICE(CB, 0x000f), BOARD_PCIDAS1200 },
+	{ PCI_VDEVICE(CB, 0x0010), BOARD_PCIDAS1602_12 },
+	{ PCI_VDEVICE(CB, 0x0019), BOARD_PCIDAS1200_JR },
+	{ PCI_VDEVICE(CB, 0x001c), BOARD_PCIDAS1602_16_JR },
+	{ PCI_VDEVICE(CB, 0x004c), BOARD_PCIDAS1000 },
+	{ PCI_VDEVICE(CB, 0x001a), BOARD_PCIDAS1001 },
+	{ PCI_VDEVICE(CB, 0x001b), BOARD_PCIDAS1002 },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);

commit b8f4ac237e382accd4b30c75043939f7ed9e79a6
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Tue Mar 5 09:53:41 2013 -0700

    staging: comedi: comedi_pci: change the comedi_pci_auto_config() 'context'
    
    The comedi_pci_auto_config() function is used to allow the PCI driver
    (*probe) function to automatically call the comedi driver (*auto_attach).
    This allows the comedi driver to be part of the PnP process when the
    PCI device is detected.
    
    Currently the comedi_pci_auto_config() always passes a 'context' of '0'
    to comedi_auto_config(). This makes the 'context' a bit useless.
    
    Modify comedi_pci_auto_config() to allow the comedi pci drivers to pass
    a 'context' from the PCI driver.
    
    Make all the comedi pci drivers pass the pci_device_id 'driver_data' as
    the 'context'. Since none of the comedi pci drivers currently set the
    'driver_data' the 'context' will still be '0'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 79c72118a090..425a5a18a787 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1629,9 +1629,10 @@ static struct comedi_driver cb_pcidas_driver = {
 };
 
 static int cb_pcidas_pci_probe(struct pci_dev *dev,
-					 const struct pci_device_id *ent)
+			       const struct pci_device_id *id)
 {
-	return comedi_pci_auto_config(dev, &cb_pcidas_driver);
+	return comedi_pci_auto_config(dev, &cb_pcidas_driver,
+				      id->driver_data);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {

commit 33782dd5edf8db3cdb7c81a3523bf743dd0209b7
Author: H Hartley Sweeten <hsweeten@visionengravers.com>
Date:   Wed Jan 30 15:22:21 2013 -0700

    staging: comedi: conditionally build in PCI driver support
    
    Separate the comedi_pci_* functions out of drivers.c into a new
    source file, comedi_pci.c. This allows conditionally building
    support for comedi PCI drivers into the comedi core. Fix the
    Kconfig and Makefile appropriately.
    
    Group all the comedi_pci_* prototypes and related defines into one
    place in comedidev.h. Protect these prototypes with an #ifdef and
    provide some dummy functions so that the mixed ISA/PCI comedi
    drivers will still build correctly.
    
    Remove the #include <linux/pci.h> from comedidev.h and drivers.c. This
    include is only needed by the comedi PCI driver support code and the
    PCI drivers. The include should occur in those files.
    
    Also, remove the #include <linux/pci.h> from a couple non-PCI drivers
    since it's not needed.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0fd6fcf0cefe..79c72118a090 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -67,10 +67,12 @@ AI Triggering:
 analog triggering on 1602 series
 */
 
-#include "../comedidev.h"
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
+#include "../comedidev.h"
+
 #include "8253.h"
 #include "8255.h"
 #include "amcc_s5933.h"

commit 9901a4d75d007686e8f6473189cafc4b216b7449
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Tue Jan 22 23:40:03 2013 +0100

    staging/comedi: Use comedi_pci_auto_unconfig directly for pci_driver.remove
    
    (Almost) all comedi pci drivers have some wrapper for their
    pci_driver.remove function which simply calls comedi_pci_auto_unconfig
    which has the same function prototype as the wrapper.
    
    -> we can remove these wrappers and call comedi_pci_auto_unconfig
    directly. This removes a lot some boilerplate code and saves some bytes.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index aed68639cc9a..0fd6fcf0cefe 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1632,11 +1632,6 @@ static int cb_pcidas_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &cb_pcidas_driver);
 }
 
-static void cb_pcidas_pci_remove(struct pci_dev *dev)
-{
-	comedi_pci_auto_unconfig(dev);
-}
-
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0001) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x000f) },
@@ -1654,7 +1649,7 @@ static struct pci_driver cb_pcidas_pci_driver = {
 	.name		= "cb_pcidas",
 	.id_table	= cb_pcidas_pci_table,
 	.probe		= cb_pcidas_pci_probe,
-	.remove		= cb_pcidas_pci_remove
+	.remove		= comedi_pci_auto_unconfig,
 };
 module_comedi_pci_driver(cb_pcidas_driver, cb_pcidas_pci_driver);
 

commit 53b800198592b0ff96577ecc5f116f7d902a4362
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:36 2012 -0500

    staging: comedi: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 87201c4a90ee..aed68639cc9a 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1632,7 +1632,7 @@ static int cb_pcidas_pci_probe(struct pci_dev *dev,
 	return comedi_pci_auto_config(dev, &cb_pcidas_driver);
 }
 
-static void __devexit cb_pcidas_pci_remove(struct pci_dev *dev)
+static void cb_pcidas_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }

commit a690b7e535f2f97a3a05ee570715abeb60a8910f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:58 2012 -0500

    staging: comedi: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 857a8d63c9fd..87201c4a90ee 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1436,7 +1436,7 @@ static const void *cb_pcidas_find_boardinfo(struct comedi_device *dev,
 	return NULL;
 }
 
-static int __devinit cb_pcidas_auto_attach(struct comedi_device *dev,
+static int cb_pcidas_auto_attach(struct comedi_device *dev,
 					   unsigned long context_unused)
 {
 	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
@@ -1626,7 +1626,7 @@ static struct comedi_driver cb_pcidas_driver = {
 	.detach		= cb_pcidas_detach,
 };
 
-static int __devinit cb_pcidas_pci_probe(struct pci_dev *dev,
+static int cb_pcidas_pci_probe(struct pci_dev *dev,
 					 const struct pci_device_id *ent)
 {
 	return comedi_pci_auto_config(dev, &cb_pcidas_driver);

commit a471eace7baa40cdf16d3f26b2f78ddce613ca8f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:37 2012 -0500

    staging: comedi: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9c45e85ec304..857a8d63c9fd 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1654,7 +1654,7 @@ static struct pci_driver cb_pcidas_pci_driver = {
 	.name		= "cb_pcidas",
 	.id_table	= cb_pcidas_pci_table,
 	.probe		= cb_pcidas_pci_probe,
-	.remove		= __devexit_p(cb_pcidas_pci_remove)
+	.remove		= cb_pcidas_pci_remove
 };
 module_comedi_pci_driver(cb_pcidas_driver, cb_pcidas_pci_driver);
 

commit 00d9c8cb5f88cc4dd059511a57f25160c7af0a83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Nov 13 17:53:40 2012 -0700

    staging: comedi: cb_pcidas: use cfc_check_trigger_arg_*() helpers
    
    Use the new helpers in the step 3 tests of cb_pcidas_{ai,ao}_cmdtest().
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e7314e5f7264..9c45e85ec304 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -840,49 +840,32 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 		/* External trigger, only CR_EDGE and CR_INVERT flags allowed */
 		if ((cmd->start_arg
 		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
-			cmd->start_arg &=
-			    ~(CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
-			err++;
+			cmd->start_arg &= ~(CR_FLAGS_MASK &
+						~(CR_EDGE | CR_INVERT));
+			err |= -EINVAL;
 		}
 		if (!thisboard->is_1602 && (cmd->start_arg & CR_INVERT)) {
 			cmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);
-			err++;
+			err |= -EINVAL;
 		}
 		break;
 	default:
-		if (cmd->start_arg != 0) {
-			cmd->start_arg = 0;
-			err++;
-		}
+		err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 		break;
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg <
-		    thisboard->ai_speed * cmd->chanlist_len) {
-			cmd->scan_begin_arg =
-			    thisboard->ai_speed * cmd->chanlist_len;
-			err++;
-		}
-	}
-	if (cmd->convert_src == TRIG_TIMER) {
-		if (cmd->convert_arg < thisboard->ai_speed) {
-			cmd->convert_arg = thisboard->ai_speed;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+				thisboard->ai_speed * cmd->chanlist_len);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_NONE) {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	if (cmd->convert_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->convert_arg,
+						 thisboard->ai_speed);
+
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;
@@ -1075,31 +1058,18 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: arguments are trivially compatible */
+	/* Step 3: check if arguments are trivially valid */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
-		if (cmd->scan_begin_arg < thisboard->ao_scan_speed) {
-			cmd->scan_begin_arg = thisboard->ao_scan_speed;
-			err++;
-		}
-	}
+	if (cmd->scan_begin_src == TRIG_TIMER)
+		err |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,
+						 thisboard->ao_scan_speed);
 
-	if (cmd->scan_end_arg != cmd->chanlist_len) {
-		cmd->scan_end_arg = cmd->chanlist_len;
-		err++;
-	}
-	if (cmd->stop_src == TRIG_NONE) {
-		/* TRIG_NONE */
-		if (cmd->stop_arg != 0) {
-			cmd->stop_arg = 0;
-			err++;
-		}
-	}
+	err |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);
+
+	if (cmd->stop_src == TRIG_NONE)
+		err |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);
 
 	if (err)
 		return 3;

commit 750af5e568d060ec6994cdcb4e86cdddfcd473c0
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Tue Oct 30 13:30:04 2012 +0000

    staging: comedi/drivers: use auto_attach instead of attach_pci
    
    Change comedi drivers for PCI boards to use the new `auto_attach()`
    method instead of the `attach_pci()` method.  I plan to remove the
    `attach_pci()` and `attach_usb()` methods from `struct comedi_driver`
    once nothing is using them.
    
    Tag the functions with `__devinit` where they are not already so tagged,
    as they are only called during PCI probe.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 8e88573d270f..e7314e5f7264 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1466,9 +1466,10 @@ static const void *cb_pcidas_find_boardinfo(struct comedi_device *dev,
 	return NULL;
 }
 
-static int cb_pcidas_attach_pci(struct comedi_device *dev,
-				struct pci_dev *pcidev)
+static int __devinit cb_pcidas_auto_attach(struct comedi_device *dev,
+					   unsigned long context_unused)
 {
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 	const struct cb_pcidas_board *thisboard;
 	struct cb_pcidas_private *devpriv;
 	struct comedi_subdevice *s;
@@ -1651,7 +1652,7 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 static struct comedi_driver cb_pcidas_driver = {
 	.driver_name	= "cb_pcidas",
 	.module		= THIS_MODULE,
-	.attach_pci	= cb_pcidas_attach_pci,
+	.auto_attach	= cb_pcidas_auto_attach,
 	.detach		= cb_pcidas_detach,
 };
 

commit cb3e9d86945181a2d9154543f402dccf35d8dd58
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Oct 24 16:29:32 2012 -0700

    staging: comedi: comedidev.h: add PCI_VENDOR_ID_CB
    
    Add a define for the ComputerBoards/Measurement Computing PCI
    vendor id. Remove the duplicates in the drivers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0e4d189d1951..8e88573d270f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -76,9 +76,6 @@ analog triggering on 1602 series
 #include "amcc_s5933.h"
 #include "comedi_fc.h"
 
-/* PCI vendor number of ComputerBoards/MeasurementComputing */
-#define PCI_VENDOR_ID_CB	0x1307
-
 #define TIMER_BASE		100	/* 10MHz master clock */
 #define AI_BUFFER_SIZE		1024	/* max ai fifo size */
 #define AO_BUFFER_SIZE		1024	/* max ao fifo size */

commit 7fc465b106b40a598d83a0c98d0e8c2a1b4653ff
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:43:11 2012 -0700

    staging: comedi: auto-config drivers do not need to set hw_dev
    
    The comedi core now sets the 'hw_dev' pointer in the function
    comedi_auto_config_helper() before calling the auto attach
    function in the driver.
    
    Remove the now unnecessary call to comedi_set_hw_dev() in the
    drivers that use the auto-config attach mechanism.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3f4f8bef692b..0e4d189d1951 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1478,8 +1478,6 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	int i;
 	int ret;
 
-	comedi_set_hw_dev(dev, &pcidev->dev);
-
 	thisboard = cb_pcidas_find_boardinfo(dev, pcidev);
 	if (!thisboard)
 		return -ENODEV;

commit c34fa261b0ac3a862ccd3f71ee55a16b920dfc83
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Oct 23 13:22:37 2012 -0700

    staging: comedi: remove inline alloc_private()
    
    This inline function has a very generic name and it's only a
    wrapper around a simple kzalloc(). Since the inline function
    does not save any lines-of-code, instead of renaming it just
    remove it and do the kzalloc() directly.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index de21a261ff45..3f4f8bef692b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1486,10 +1486,10 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	dev->board_ptr  = thisboard;
 	dev->board_name = thisboard->name;
 
-	ret = alloc_private(dev, sizeof(*devpriv));
-	if (ret)
-		return ret;
-	devpriv = dev->private;
+	devpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);
+	if (!devpriv)
+		return -ENOMEM;
+	dev->private = devpriv;
 
 	ret = comedi_pci_enable(pcidev, dev->board_name);
 	if (ret)

commit 27020ffed9166d65ce1e5b523051d13bfa2329b0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 26 14:11:10 2012 -0700

    staging: comedi: drivers: use comedi_fc.h cmdtest helpers
    
    Use the cfc_check_trigger_src() helper for Step 1 in all the
    driver cmdtest functions.
    
    Use the cfc_check_trigger_is_unique() helper for Step 2 in all
    the driver cmdtest functions. Note that single source triggers
    do not need to be checked, they are already unique if they pass
    Step 1.
    
    For aesthetic reasons, change the comments in the cmdtest
    functions for steps 1 and 2 so that they are all the same.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4dd87c28ca20..de21a261ff45 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -803,58 +803,35 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	int tmp;
 	int i, gain, start_chan;
 
-	/* step 1: trigger sources are trivially valid */
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_NOW | TRIG_EXT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_TIMER | TRIG_NOW | TRIG_EXT;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
-
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src,
+					TRIG_TIMER | TRIG_NOW | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
-		err++;
-	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-	    cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->convert_src != TRIG_TIMER &&
-	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->start_src);
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->convert_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
-	/*  make sure trigger sources are compatible with each other */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
-		err++;
+		err |= -EINVAL;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
-		err++;
+		err |= -EINVAL;
 	if (cmd->start_src == TRIG_EXT &&
 	    (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))
-		err++;
+		err |= -EINVAL;
 
 	if (err)
 		return 2;
@@ -1079,43 +1056,24 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* step 1: trigger sources are trivially valid */
-
-	tmp = cmd->start_src;
-	cmd->start_src &= TRIG_INT;
-	if (!cmd->start_src || tmp != cmd->start_src)
-		err++;
-
-	tmp = cmd->scan_begin_src;
-	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
-	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
-		err++;
-
-	tmp = cmd->convert_src;
-	cmd->convert_src &= TRIG_NOW;
-	if (!cmd->convert_src || tmp != cmd->convert_src)
-		err++;
-
-	tmp = cmd->scan_end_src;
-	cmd->scan_end_src &= TRIG_COUNT;
-	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
-		err++;
+	/* Step 1 : check if triggers are trivially valid */
 
-	tmp = cmd->stop_src;
-	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
-	if (!cmd->stop_src || tmp != cmd->stop_src)
-		err++;
+	err |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);
+	err |= cfc_check_trigger_src(&cmd->scan_begin_src,
+					TRIG_TIMER | TRIG_EXT);
+	err |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);
+	err |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);
+	err |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);
 
 	if (err)
 		return 1;
 
-	/* step 2: trigger sources are unique and mutually compatible */
+	/* Step 2a : make sure trigger sources are unique */
 
-	if (cmd->scan_begin_src != TRIG_TIMER &&
-	    cmd->scan_begin_src != TRIG_EXT)
-		err++;
-	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
-		err++;
+	err |= cfc_check_trigger_is_unique(cmd->scan_begin_src);
+	err |= cfc_check_trigger_is_unique(cmd->stop_src);
+
+	/* Step 2b : and mutually compatible */
 
 	if (err)
 		return 2;

commit e89c61b989229c194d532d4bc4fbe1a8bb55112e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 5 18:31:45 2012 -0700

    staging: comedi: cb_pcidas: remove subdevice pointer math
    
    Convert the comedi_subdevice access from pointer math to array
    access.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4b6fb8813648..4dd87c28ca20 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1560,7 +1560,7 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	if (ret)
 		return ret;
 
-	s = dev->subdevices + 0;
+	s = &dev->subdevices[0];
 	/* analog input subdevice */
 	dev->read_subdev = s;
 	s->type = COMEDI_SUBD_AI;
@@ -1577,7 +1577,7 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	s->cancel = cb_pcidas_cancel;
 
 	/* analog output subdevice */
-	s = dev->subdevices + 1;
+	s = &dev->subdevices[1];
 	if (thisboard->ao_nchan) {
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
@@ -1604,14 +1604,14 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	}
 
 	/* 8255 */
-	s = dev->subdevices + 2;
+	s = &dev->subdevices[2];
 	ret = subdev_8255_init(dev, s, NULL,
 			       devpriv->pacer_counter_dio + DIO_8255);
 	if (ret)
 		return ret;
 
 	/*  serial EEPROM, */
-	s = dev->subdevices + 3;
+	s = &dev->subdevices[3];
 	s->type = COMEDI_SUBD_MEMORY;
 	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
 	s->n_chan = 256;
@@ -1619,7 +1619,7 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 	s->insn_read = eeprom_read_insn;
 
 	/*  8800 caldac */
-	s = dev->subdevices + 4;
+	s = &dev->subdevices[4];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	s->n_chan = NUM_CHANNELS_8800;
@@ -1630,7 +1630,7 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 		caldac_8800_write(dev, i, s->maxdata / 2);
 
 	/*  trim potentiometer */
-	s = dev->subdevices + 5;
+	s = &dev->subdevices[5];
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
 	if (thisboard->trimpot == AD7376) {
@@ -1646,7 +1646,7 @@ static int cb_pcidas_attach_pci(struct comedi_device *dev,
 		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
 
 	/*  dac08 caldac */
-	s = dev->subdevices + 6;
+	s = &dev->subdevices[6];
 	if (thisboard->has_dac08) {
 		s->type = COMEDI_SUBD_CALIB;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -1688,7 +1688,7 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 	if (dev->irq)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices)
-		subdev_8255_cleanup(dev, dev->subdevices + 2);
+		subdev_8255_cleanup(dev, &dev->subdevices[2]);
 	if (pcidev) {
 		if (devpriv->s5933_config)
 			comedi_pci_disable(pcidev);

commit 3b96f250ba086109241261337751ade2833ac333
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Aug 16 19:43:29 2012 -0700

    staging: comedi: cb_pcidas: use attach_pci callback
    
    Convert this PCI driver to use the comedi PCI auto config attach
    mechanism by adding an 'attach_pci' callback function. Since the
    driver does not require any external configuration options, and
    the legacy 'attach' callback is now optional, remove it.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2b6a637c3499..4b6fb8813648 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -45,11 +45,7 @@ Devices: [Measurement Computing] PCI-DAS1602/16 (cb_pcidas),
   The boards may be autocalibrated using the comedi_calibrate
   utility.
 
-Configuration options:
-  [0] - PCI bus of device (optional)
-  [1] - PCI slot of device (optional)
-  If bus/slot is not specified, the first supported
-  PCI device found will be used.
+Configuration options: not applicable, uses PCI auto config
 
 For commands, the scanned channels must be consecutive
 (i.e. 4-5-6-7, 2-3-4,...), and must all have the same
@@ -1501,69 +1497,45 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static struct pci_dev *cb_pcidas_find_pci_device(struct comedi_device *dev,
-						 struct comedi_devconfig *it)
+static const void *cb_pcidas_find_boardinfo(struct comedi_device *dev,
+					    struct pci_dev *pcidev)
 {
 	const struct cb_pcidas_board *thisboard;
-	struct pci_dev *pcidev = NULL;
-	int bus = it->options[0];
-	int slot = it->options[1];
 	int i;
 
-	for_each_pci_dev(pcidev) {
-		/*  is it not a computer boards card? */
-		if (pcidev->vendor != PCI_VENDOR_ID_CB)
-			continue;
-		/*  loop through cards supported by this driver */
-		for (i = 0; i < ARRAY_SIZE(cb_pcidas_boards); i++) {
-			thisboard = &cb_pcidas_boards[i];
-			if (thisboard->device_id != pcidev->device)
-				continue;
-			/*  was a particular bus/slot requested? */
-			if (bus || slot) {
-				/*  are we on the wrong bus/slot? */
-				if (pcidev->bus->number != bus ||
-				    PCI_SLOT(pcidev->devfn) != slot) {
-					continue;
-				}
-			}
-			dev_dbg(dev->class_dev,
-				"Found %s on bus %i, slot %i\n",
-				thisboard->name,
-				pcidev->bus->number, PCI_SLOT(pcidev->devfn));
-			dev->board_ptr = thisboard;
-			return pcidev;
-		}
+	for (i = 0; i < ARRAY_SIZE(cb_pcidas_boards); i++) {
+		thisboard = &cb_pcidas_boards[i];
+		if (thisboard->device_id == pcidev->device)
+			return thisboard;
 	}
-	dev_err(dev->class_dev, "No supported card found\n");
 	return NULL;
 }
 
-static int cb_pcidas_attach(struct comedi_device *dev,
-			    struct comedi_devconfig *it)
+static int cb_pcidas_attach_pci(struct comedi_device *dev,
+				struct pci_dev *pcidev)
 {
 	const struct cb_pcidas_board *thisboard;
 	struct cb_pcidas_private *devpriv;
-	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
 	int i;
 	int ret;
 
-	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
-		return -ENOMEM;
-	devpriv = dev->private;
-
-	pcidev = cb_pcidas_find_pci_device(dev, it);
-	if (!pcidev)
-		return -EIO;
 	comedi_set_hw_dev(dev, &pcidev->dev);
-	thisboard = comedi_board(dev);
 
-	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
-		dev_err(dev->class_dev,
-			"Failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
+	thisboard = cb_pcidas_find_boardinfo(dev, pcidev);
+	if (!thisboard)
+		return -ENODEV;
+	dev->board_ptr  = thisboard;
+	dev->board_name = thisboard->name;
+
+	ret = alloc_private(dev, sizeof(*devpriv));
+	if (ret)
+		return ret;
+	devpriv = dev->private;
+
+	ret = comedi_pci_enable(pcidev, dev->board_name);
+	if (ret)
+		return ret;
 
 	devpriv->s5933_config = pci_resource_start(pcidev, 0);
 	devpriv->control_status = pci_resource_start(pcidev, 1);
@@ -1584,8 +1556,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	}
 	dev->irq = pcidev->irq;
 
-	dev->board_name = thisboard->name;
-
 	ret = comedi_alloc_subdevices(dev, 7);
 	if (ret)
 		return ret;
@@ -1698,7 +1668,10 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	return 1;
+	dev_info(dev->class_dev, "%s: %s attached\n",
+		dev->driver->driver_name, dev->board_name);
+
+	return 0;
 }
 
 static void cb_pcidas_detach(struct comedi_device *dev)
@@ -1719,14 +1692,13 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 	if (pcidev) {
 		if (devpriv->s5933_config)
 			comedi_pci_disable(pcidev);
-		pci_dev_put(pcidev);
 	}
 }
 
 static struct comedi_driver cb_pcidas_driver = {
 	.driver_name	= "cb_pcidas",
 	.module		= THIS_MODULE,
-	.attach		= cb_pcidas_attach,
+	.attach_pci	= cb_pcidas_attach_pci,
 	.detach		= cb_pcidas_detach,
 };
 

commit ba36b9ba768b5d617f0729eeebef16dc8416c750
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jul 18 18:35:38 2012 -0700

    staging: comedi: cb_pcidas: store the pci_dev in the comedi_device
    
    Use the hw_dev pointer in the comedi_device struct to hold the
    pci_dev instead of carrying it in the private data.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 301444e09433..2b6a637c3499 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -343,7 +343,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 };
 
 struct cb_pcidas_private {
-	struct pci_dev *pci_dev;
 	/* base addresses */
 	unsigned long s5933_config;
 	unsigned long control_status;
@@ -1545,6 +1544,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 {
 	const struct cb_pcidas_board *thisboard;
 	struct cb_pcidas_private *devpriv;
+	struct pci_dev *pcidev;
 	struct comedi_subdevice *s;
 	int i;
 	int ret;
@@ -1553,35 +1553,36 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		return -ENOMEM;
 	devpriv = dev->private;
 
-	devpriv->pci_dev = cb_pcidas_find_pci_device(dev, it);
-	if (!devpriv->pci_dev)
+	pcidev = cb_pcidas_find_pci_device(dev, it);
+	if (!pcidev)
 		return -EIO;
+	comedi_set_hw_dev(dev, &pcidev->dev);
 	thisboard = comedi_board(dev);
 
-	if (comedi_pci_enable(devpriv->pci_dev, dev->driver->driver_name)) {
+	if (comedi_pci_enable(pcidev, dev->driver->driver_name)) {
 		dev_err(dev->class_dev,
 			"Failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 
-	devpriv->s5933_config = pci_resource_start(devpriv->pci_dev, 0);
-	devpriv->control_status = pci_resource_start(devpriv->pci_dev, 1);
-	devpriv->adc_fifo = pci_resource_start(devpriv->pci_dev, 2);
-	devpriv->pacer_counter_dio = pci_resource_start(devpriv->pci_dev, 3);
+	devpriv->s5933_config = pci_resource_start(pcidev, 0);
+	devpriv->control_status = pci_resource_start(pcidev, 1);
+	devpriv->adc_fifo = pci_resource_start(pcidev, 2);
+	devpriv->pacer_counter_dio = pci_resource_start(pcidev, 3);
 	if (thisboard->ao_nchan)
-		devpriv->ao_registers = pci_resource_start(devpriv->pci_dev, 4);
+		devpriv->ao_registers = pci_resource_start(pcidev, 4);
 
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
+	if (request_irq(pcidev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, dev->driver->driver_name, dev)) {
 		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
-			devpriv->pci_dev->irq);
+			pcidev->irq);
 		return -EINVAL;
 	}
-	dev->irq = devpriv->pci_dev->irq;
+	dev->irq = pcidev->irq;
 
 	dev->board_name = thisboard->name;
 
@@ -1703,6 +1704,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 static void cb_pcidas_detach(struct comedi_device *dev)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
+	struct pci_dev *pcidev = comedi_to_pci_dev(dev);
 
 	if (devpriv) {
 		if (devpriv->s5933_config) {
@@ -1714,10 +1716,10 @@ static void cb_pcidas_detach(struct comedi_device *dev)
 		free_irq(dev->irq, dev);
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
-	if (devpriv && devpriv->pci_dev) {
+	if (pcidev) {
 		if (devpriv->s5933_config)
-			comedi_pci_disable(devpriv->pci_dev);
-		pci_dev_put(devpriv->pci_dev);
+			comedi_pci_disable(pcidev);
+		pci_dev_put(pcidev);
 	}
 }
 

commit ac55ca32ca40de3cb52a1ca73ca4a9250e07eefd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Jun 27 09:17:17 2012 -0700

    staging: comedi: cb_pcidas: fix dac08_write_insn()
    
    As pointed out by Ian Abbott, the comedi INSN_WRITE instructions
    are meant to iterate over, and write, all the data[] passed from
    the comedi core. Modify dac08_write_insn() to work as intended.
    
    Since doc08_write_insn() now returns the proper response to the
    core, make the dac08_write() helper return void.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reported-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3ba75afe4e05..301444e09433 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -659,7 +659,7 @@ static int caldac_read_insn(struct comedi_device *dev,
 }
 
 /* 1602/16 pregain offset */
-static int dac08_write(struct comedi_device *dev, unsigned int value)
+static void dac08_write(struct comedi_device *dev, unsigned int value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long cal_reg;
@@ -680,14 +680,18 @@ static int dac08_write(struct comedi_device *dev, unsigned int value)
 		outw(value, cal_reg);
 		udelay(1);
 	}
-	return 1;	/* insn->n */
 }
 
 static int dac08_write_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
-	return dac08_write(dev, data[0]);
+	int i;
+
+	for (i = 0; i < insn->n; i++)
+		dac08_write(dev, data[i]);
+
+	return insn->n;
 }
 
 static int dac08_read_insn(struct comedi_device *dev,

commit b436356dcc67a665da07441ab113e9a5652073e5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:12:15 2012 -0700

    staging: comedi: cb_pcidas: cleanup dac08_write()
    
    Reverse the logic of the test against the cached value so that
    the function only has one exit point.
    
    Make the logic of the dac write a bit clearer by create a local
    variable for the address used in the outw() calls and masking the
    value to write and setting the enable bits before doing the outw()
    calls. Add a comment just to make sure it's clear.
    
    Also, add a comment about the 'return 1;'.  This should be
    insn->n which is the number of data parameters used to do the
    dac08_write_insn() but the insn is not a parameter to this
    function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1479325ab7ea..3ba75afe4e05 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -662,23 +662,25 @@ static int caldac_read_insn(struct comedi_device *dev,
 static int dac08_write(struct comedi_device *dev, unsigned int value)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
+	unsigned long cal_reg;
 
-	if (devpriv->dac08_value == value)
-		return 1;
+	if (devpriv->dac08_value != value) {
+		devpriv->dac08_value = value;
 
-	devpriv->dac08_value = value;
+		cal_reg = devpriv->control_status + CALIBRATION_REG;
 
-	outw(cal_enable_bits(dev) | (value & 0xff),
-	     devpriv->control_status + CALIBRATION_REG);
-	udelay(1);
-	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
-	     devpriv->control_status + CALIBRATION_REG);
-	udelay(1);
-	outw(cal_enable_bits(dev) | (value & 0xff),
-	     devpriv->control_status + CALIBRATION_REG);
-	udelay(1);
+		value &= 0xff;
+		value |= cal_enable_bits(dev);
 
-	return 1;
+		/* latch the new value into the caldac */
+		outw(value, cal_reg);
+		udelay(1);
+		outw(value | SELECT_DAC08_BIT, cal_reg);
+		udelay(1);
+		outw(value, cal_reg);
+		udelay(1);
+	}
+	return 1;	/* insn->n */
 }
 
 static int dac08_write_insn(struct comedi_device *dev,

commit f66faa576f084bed49d4a34e0bc2289ff0d07a70
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:11:38 2012 -0700

    staging: comedi: cb_pcidas: cleanup cb_pcidas_ai_rinsn()
    
    Create local variables for the channel, range, and aref in order
    to make the remaining code a bit cleaner.
    
    Remove the extra space in all the comments.
    
    Remove the 'static const int timeout' and just use the open
    coded value in the loop.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b00ccad6022b..1479325ab7ea 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -382,36 +382,33 @@ static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }
 
-/*
- * "instructions" read/write data in "one-shot" or "software-triggered"
- * mode.
- */
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	int n, i;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
+	unsigned int aref = CR_AREF(insn->chanspec);
 	unsigned int bits;
-	static const int timeout = 10000;
-	int channel;
-	/*  enable calibration input if appropriate */
+	int n, i;
+
+	/* enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
 		     devpriv->control_status + CALIBRATION_REG);
-		channel = 0;
+		chan = 0;
 	} else {
 		outw(0, devpriv->control_status + CALIBRATION_REG);
-		channel = CR_CHAN(insn->chanspec);
 	}
-	/*  set mux limits and gain */
-	bits = BEGIN_SCAN(channel) |
-	    END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
-	/*  set unipolar/bipolar */
-	if (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)
+
+	/* set mux limits and gain */
+	bits = BEGIN_SCAN(chan) | END_SCAN(chan) | GAIN_BITS(range);
+	/* set unipolar/bipolar */
+	if (range & IS_UNIPOLAR)
 		bits |= UNIP;
-	/*  set singleended/differential */
-	if (CR_AREF(insn->chanspec) != AREF_DIFF)
+	/* set single-ended/differential */
+	if (aref != AREF_DIFF)
 		bits |= SE;
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
@@ -425,11 +422,11 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 
 		/* wait for conversion to end */
 		/* return -ETIMEDOUT if there is a timeout */
-		for (i = 0; i < timeout; i++) {
+		for (i = 0; i < 10000; i++) {
 			if (inw(devpriv->control_status + ADCMUX_CONT) & EOC)
 				break;
 		}
-		if (i == timeout)
+		if (i == 10000)
 			return -ETIMEDOUT;
 
 		/* read data */

commit 7671896c4f7f66116798d7314a03995eddac4134
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:10:59 2012 -0700

    staging: comedi: cb_pcidas: cleanup cb_pcidas_ao_nofifo_winsn()
    
    Create local variables for the channel and range in order to
    cleanup to mask/set of the ao_control_bits.
    
    Remove the extra space in all the comments.
    
    Return the number of data parameters used (insn->n) to indicate
    success instead of the open coded '1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index bbbb9e43d504..b00ccad6022b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -471,25 +471,25 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 				     unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	int channel;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned long flags;
 
-	/*  set channel and range */
-	channel = CR_CHAN(insn->chanspec);
+	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->ao_control_bits &=
-	    ~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
-	devpriv->ao_control_bits |=
-	    DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
+	devpriv->ao_control_bits &= (~DAC_MODE_UPDATE_BOTH &
+				     ~DAC_RANGE_MASK(chan));
+	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range));
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  remember value for readback */
-	devpriv->ao_value[channel] = data[0];
-	/*  send data */
-	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(channel));
+	/* remember value for readback */
+	devpriv->ao_value[chan] = data[0];
+
+	/* send data */
+	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(chan));
 
-	return 1;
+	return insn->n;
 }
 
 /* analog output insn for pcidas-1602 series */

commit b78332daf47b624bef6220f1acf64ee49d38c1ad
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:10:22 2012 -0700

    staging: comedi: cb_pcidas: cleanup cb_pcidas_ao_fifo_winsn()
    
    Create local variables for the channel and range in order to
    cleanup to mask/set of the ao_control_bits.
    
    Remove the extra space in all the comments.
    
    Return the number of data parameters used (insn->n) to indicate
    success instead of the open coded '1'.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2a282d3c9c2c..bbbb9e43d504 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -498,32 +498,29 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 				   struct comedi_insn *insn, unsigned int *data)
 {
 	struct cb_pcidas_private *devpriv = dev->private;
-	int channel;
+	unsigned int chan = CR_CHAN(insn->chanspec);
+	unsigned int range = CR_RANGE(insn->chanspec);
 	unsigned long flags;
 
-	/*  clear dac fifo */
+	/* clear dac fifo */
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
 
-	/*  set channel and range */
-	channel = CR_CHAN(insn->chanspec);
+	/* set channel and range */
 	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->ao_control_bits &=
-	    ~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
-	    ~DAC_PACER_MASK;
-	devpriv->ao_control_bits |=
-	    DACEN | DAC_RANGE(channel,
-			      CR_RANGE(insn->
-				       chanspec)) | DAC_CHAN_EN(channel) |
-	    DAC_START;
+	devpriv->ao_control_bits &= (~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) &
+				     ~DAC_RANGE_MASK(chan) & ~DAC_PACER_MASK);
+	devpriv->ao_control_bits |= (DACEN | DAC_RANGE(chan, range) |
+				     DAC_CHAN_EN(chan) | DAC_START);
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  remember value for readback */
-	devpriv->ao_value[channel] = data[0];
-	/*  send data */
+	/* remember value for readback */
+	devpriv->ao_value[chan] = data[0];
+
+	/* send data */
 	outw(data[0], devpriv->ao_registers + DACDATA);
 
-	return 1;
+	return insn->n;
 }
 
 static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,

commit d478b5f6f4d48a130533efb8da98b5526772f219
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:09:40 2012 -0700

    staging: comedi: cb_pcidas: fix remaining checkpatch.pl issues
    
    Fix the remaining three "WARNING: line over 80 characters" issues
    reported by checkpatch.pl.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c0d934097e54..2a282d3c9c2c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -28,7 +28,8 @@
 */
 /*
 Driver: cb_pcidas
-Description: MeasurementComputing PCI-DAS series with the AMCC S5933 PCI controller
+Description: MeasurementComputing PCI-DAS series
+  with the AMCC S5933 PCI controller
 Author: Ivan Martinez <imr@oersted.dtu.dk>,
   Frank Mori Hess <fmhess@users.sourceforge.net>
 Updated: 2003-3-11
@@ -243,7 +244,7 @@ struct cb_pcidas_board {
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_nchan;		/*  number of analog out channels */
 	int has_ao_fifo;	/*  analog output has fifo */
-	int ao_scan_speed;	/*  analog output speed for 1602 series (for a scan, not conversion) */
+	int ao_scan_speed;	/*  analog output scan speed for 1602 series */
 	int fifo_size;		/*  number of samples fifo can hold */
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
@@ -525,8 +526,6 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 	return 1;
 }
 
-/* analog output readback insn */
-/* XXX loses track of analog output value back after an analog ouput command is executed */
 static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
 				      struct comedi_subdevice *s,
 				      struct comedi_insn *insn,

commit 6993197b75686f79a2b6107d51ba57180ba33212
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:09:01 2012 -0700

    staging: comedi: cb_pcidas: add whitespace to all the #define's
    
    Add whitespace to all the #define's in the driver in order to
    improve the readability. Fix all the comments that are, or
    already were, > 80 characters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0188cf17cecb..c0d934097e54 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -81,64 +81,65 @@ analog triggering on 1602 series
 
 /* PCI vendor number of ComputerBoards/MeasurementComputing */
 #define PCI_VENDOR_ID_CB	0x1307
-#define TIMER_BASE 100		/*  10MHz master clock */
-#define AI_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
-#define AO_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
-#define NUM_CHANNELS_8800 8
-#define NUM_CHANNELS_7376 1
-#define NUM_CHANNELS_8402 2
-#define NUM_CHANNELS_DAC08 1
+
+#define TIMER_BASE		100	/* 10MHz master clock */
+#define AI_BUFFER_SIZE		1024	/* max ai fifo size */
+#define AO_BUFFER_SIZE		1024	/* max ao fifo size */
+#define NUM_CHANNELS_8800	8
+#define NUM_CHANNELS_7376	1
+#define NUM_CHANNELS_8402	2
+#define NUM_CHANNELS_DAC08	1
 
 /* Control/Status registers */
-#define INT_ADCFIFO	0	/*  INTERRUPT / ADC FIFO register */
-#define   INT_EOS 0x1		/*  interrupt end of scan */
-#define   INT_FHF 0x2		/*  interrupt fifo half full */
-#define   INT_FNE 0x3		/*  interrupt fifo not empty */
-#define   INT_MASK 0x3		/*  mask of interrupt select bits */
-#define   INTE 0x4		/*  interrupt enable */
-#define   DAHFIE 0x8		/*  dac half full interrupt enable */
-#define   EOAIE	0x10		/*  end of acquisition interrupt enable */
-#define   DAHFI	0x20		/*  dac half full read status / write interrupt clear */
-#define   EOAI 0x40		/*  read end of acq. interrupt status / write clear */
-#define   INT 0x80		/*  read interrupt status / write clear */
-#define   EOBI 0x200		/*  read end of burst interrupt status */
-#define   ADHFI 0x400		/*  read half-full interrupt status */
-#define   ADNEI 0x800		/*  read fifo not empty interrupt latch status */
-#define   ADNE 0x1000		/*  read, fifo not empty (realtime, not latched) status */
-#define   DAEMIE	0x1000	/*  write, dac empty interrupt enable */
-#define   LADFUL 0x2000		/*  read fifo overflow / write clear */
-#define   DAEMI 0x4000		/*  dac fifo empty interrupt status / write clear */
-
-#define ADCMUX_CONT	2	/*  ADC CHANNEL MUX AND CONTROL register */
-#define   BEGIN_SCAN(x)	((x) & 0xf)
-#define   END_SCAN(x)	(((x) & 0xf) << 4)
-#define   GAIN_BITS(x)	(((x) & 0x3) << 8)
-#define   UNIP	0x800		/*  Analog front-end unipolar for range */
-#define   SE	0x400		/*  Inputs in single-ended mode */
-#define   PACER_MASK	0x3000	/*  pacer source bits */
-#define   PACER_INT 0x1000	/*  internal pacer */
-#define   PACER_EXT_FALL	0x2000	/*  external falling edge */
-#define   PACER_EXT_RISE	0x3000	/*  external rising edge */
-#define   EOC	0x4000		/*  adc not busy */
-
-#define TRIG_CONTSTAT 4		/*  TRIGGER CONTROL/STATUS register */
-#define   SW_TRIGGER 0x1	/*  software start trigger */
-#define   EXT_TRIGGER 0x2	/*  external start trigger */
-#define   ANALOG_TRIGGER 0x3	/*  external analog trigger */
-#define   TRIGGER_MASK	0x3	/*  mask of bits that determine start trigger */
-#define   TGPOL	0x04		/*  invert the edge/level of the external trigger (1602 only) */
-#define   TGSEL	0x08		/*  if set edge triggered, otherwise level trigerred (1602 only) */
-#define   TGEN	0x10		/*  enable external start trigger */
-#define   BURSTE 0x20		/*  burst mode enable */
-#define   XTRCL	0x80		/*  clear external trigger */
-
-#define CALIBRATION_REG	6	/*  CALIBRATION register */
-#define   SELECT_8800_BIT	0x100	/*  select 8800 caldac */
-#define   SELECT_TRIMPOT_BIT	0x200	/*  select ad7376 trim pot */
-#define   SELECT_DAC08_BIT	0x400	/*  select dac08 caldac */
+#define INT_ADCFIFO		0	/* INTERRUPT / ADC FIFO register */
+#define   INT_EOS		0x1	/* int end of scan */
+#define   INT_FHF		0x2	/* int fifo half full */
+#define   INT_FNE		0x3	/* int fifo not empty */
+#define   INT_MASK		0x3	/* mask of int select bits */
+#define   INTE			0x4	/* int enable */
+#define   DAHFIE		0x8	/* dac half full int enable */
+#define   EOAIE			0x10	/* end of acq. int enable */
+#define   DAHFI			0x20	/* dac half full status / clear */
+#define   EOAI			0x40	/* end of acq. int status / clear */
+#define   INT			0x80	/* int status / clear */
+#define   EOBI			0x200	/* end of burst int status */
+#define   ADHFI			0x400	/* half-full int status */
+#define   ADNEI			0x800	/* fifo not empty int status (latch) */
+#define   ADNE			0x1000	/* fifo not empty status (realtime) */
+#define   DAEMIE		0x1000	/* dac empty int enable */
+#define   LADFUL		0x2000	/* fifo overflow / clear */
+#define   DAEMI			0x4000	/* dac fifo empty int status / clear */
+
+#define ADCMUX_CONT		2	/* ADC CHANNEL MUX AND CONTROL reg */
+#define   BEGIN_SCAN(x)		((x) & 0xf)
+#define   END_SCAN(x)		(((x) & 0xf) << 4)
+#define   GAIN_BITS(x)		(((x) & 0x3) << 8)
+#define   UNIP			0x800	/* Analog front-end unipolar mode */
+#define   SE			0x400	/* Inputs in single-ended mode */
+#define   PACER_MASK		0x3000	/* pacer source bits */
+#define   PACER_INT		0x1000	/* int. pacer */
+#define   PACER_EXT_FALL	0x2000	/* ext. falling edge */
+#define   PACER_EXT_RISE	0x3000	/* ext. rising edge */
+#define   EOC			0x4000	/* adc not busy */
+
+#define TRIG_CONTSTAT		 4	/* TRIGGER CONTROL/STATUS register */
+#define   SW_TRIGGER		0x1	/* software start trigger */
+#define   EXT_TRIGGER		0x2	/* ext. start trigger */
+#define   ANALOG_TRIGGER	0x3	/* ext. analog trigger */
+#define   TRIGGER_MASK		0x3	/* start trigger mask */
+#define   TGPOL			0x04	/* invert trigger (1602 only) */
+#define   TGSEL			0x08	/* edge/level trigerred (1602 only) */
+#define   TGEN			0x10	/* enable external start trigger */
+#define   BURSTE		0x20	/* burst mode enable */
+#define   XTRCL			0x80	/* clear external trigger */
+
+#define CALIBRATION_REG		6	/* CALIBRATION register */
+#define   SELECT_8800_BIT	0x100	/* select 8800 caldac */
+#define   SELECT_TRIMPOT_BIT	0x200	/* select ad7376 trim pot */
+#define   SELECT_DAC08_BIT	0x400	/* select dac08 caldac */
 #define   CAL_SRC_BITS(x)	(((x) & 0x7) << 11)
-#define   CAL_EN_BIT	0x4000	/*  read calibration source instead of analog input channel 0 */
-#define   SERIAL_DATA_IN_BIT	0x8000	/*  serial data stream going to 8800 and 7376 */
+#define   CAL_EN_BIT		0x4000	/* calibration source enable */
+#define   SERIAL_DATA_IN_BIT	0x8000	/* serial data bit going to caldac */
 
 #define DAC_CSR			0x8	/* dac control and status register */
 #define   DACEN			0x02	/* dac enable */
@@ -155,12 +156,12 @@ static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 };
 
 /* bits for 1602 series only */
-#define   DAC_EMPTY		0x1	/*  fifo empty, read, write clear */
-#define   DAC_START		0x4	/*  start/arm fifo operations */
-#define   DAC_PACER_MASK	0x18	/*  bits that set pacer source */
-#define   DAC_PACER_INT		0x8	/*  int. pacing */
-#define   DAC_PACER_EXT_FALL	0x10	/*  ext. pacing, falling edge */
-#define   DAC_PACER_EXT_RISE	0x18	/*  ext. pacing, rising edge */
+#define   DAC_EMPTY		0x1	/* fifo empty, read, write clear */
+#define   DAC_START		0x4	/* start/arm fifo operations */
+#define   DAC_PACER_MASK	0x18	/* bits that set pacer source */
+#define   DAC_PACER_INT		0x8	/* int. pacing */
+#define   DAC_PACER_EXT_FALL	0x10	/* ext. pacing, falling edge */
+#define   DAC_PACER_EXT_RISE	0x18	/* ext. pacing, rising edge */
 
 static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 {
@@ -168,13 +169,13 @@ static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 };
 
 /* analog input fifo */
-#define ADCDATA	0		/*  ADC DATA register */
-#define ADCFIFOCLR	2	/*  ADC FIFO CLEAR */
+#define ADCDATA			0	/* ADC DATA register */
+#define ADCFIFOCLR		2	/* ADC FIFO CLEAR */
 
 /* pacer, counter, dio registers */
-#define ADC8254 0
-#define DIO_8255 4
-#define DAC8254 8
+#define ADC8254			0
+#define DIO_8255		4
+#define DAC8254			8
 
 /* analog output registers for 100x, 1200 series */
 static inline unsigned int DAC_DATA_REG(unsigned int channel)
@@ -183,11 +184,11 @@ static inline unsigned int DAC_DATA_REG(unsigned int channel)
 }
 
 /* analog output registers for 1602 series*/
-#define DACDATA	0		/*  DAC DATA register */
-#define DACFIFOCLR	2	/*  DAC FIFO CLEAR */
+#define DACDATA			0	/* DAC DATA register */
+#define DACFIFOCLR		2	/* DAC FIFO CLEAR */
+
+#define IS_UNIPOLAR		0x4	/* unipolar range mask */
 
-/* bit in hexadecimal representation of range index that indicates unipolar input range */
-#define IS_UNIPOLAR 0x4
 /* analog input ranges for most boards */
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8,

commit 7368348ccb51f652fea3f2554874ad11456fb9fc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:08:17 2012 -0700

    staging: comedi: cb_pcidas: change dac bit enums into defines
    
    The 'bits' for the DAC_CSR register are currently defined as
    enums. All the other registers use defines for the bit definitions.
    Change the dac bit enums to defines to follow the other registers.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9e21e6818415..0188cf17cecb 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -140,11 +140,10 @@ analog triggering on 1602 series
 #define   CAL_EN_BIT	0x4000	/*  read calibration source instead of analog input channel 0 */
 #define   SERIAL_DATA_IN_BIT	0x8000	/*  serial data stream going to 8800 and 7376 */
 
-#define DAC_CSR	0x8		/*  dac control and status register */
-enum dac_csr_bits {
-	DACEN = 0x2,		/*  dac enable */
-	DAC_MODE_UPDATE_BOTH = 0x80,	/*  update both dacs when dac0 is written */
-};
+#define DAC_CSR			0x8	/* dac control and status register */
+#define   DACEN			0x02	/* dac enable */
+#define   DAC_MODE_UPDATE_BOTH	0x80	/* update both dacs */
+
 static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
 {
 	return (range & 0x3) << (8 + 2 * (channel & 0x1));
@@ -156,14 +155,13 @@ static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 };
 
 /* bits for 1602 series only */
-enum dac_csr_bits_1602 {
-	DAC_EMPTY = 0x1,	/*  dac fifo empty, read, write clear */
-	DAC_START = 0x4,	/*  start/arm dac fifo operations */
-	DAC_PACER_MASK = 0x18,	/*  bits that set dac pacer source */
-	DAC_PACER_INT = 0x8,	/*  dac internal pacing */
-	DAC_PACER_EXT_FALL = 0x10,	/*  dac external pacing, falling edge */
-	DAC_PACER_EXT_RISE = 0x18,	/*  dac external pacing, rising edge */
-};
+#define   DAC_EMPTY		0x1	/*  fifo empty, read, write clear */
+#define   DAC_START		0x4	/*  start/arm fifo operations */
+#define   DAC_PACER_MASK	0x18	/*  bits that set pacer source */
+#define   DAC_PACER_INT		0x8	/*  int. pacing */
+#define   DAC_PACER_EXT_FALL	0x10	/*  ext. pacing, falling edge */
+#define   DAC_PACER_EXT_RISE	0x18	/*  ext. pacing, rising edge */
+
 static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 {
 	return 1 << (5 + (channel & 0x1));	/*  enable channel 0 or 1 */

commit 0cdfbe157cd2244951568e6d3ffe3423ce7f2f50
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:07:32 2012 -0700

    staging: comedi: cb_pcidas: fix comments in private data struct
    
    A number of the comments in the private data struct definition
    are causing checkpatch.pl to complain about "WARNING: line over
    80 characters". Fix the comments.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index eba39b4f7247..9e21e6818415 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -342,34 +342,35 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	},
 };
 
-/* this structure is for data unique to this hardware driver.  If
-   several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
 struct cb_pcidas_private {
-	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
-	/*  base addresses */
+	/* base addresses */
 	unsigned long s5933_config;
 	unsigned long control_status;
 	unsigned long adc_fifo;
 	unsigned long pacer_counter_dio;
 	unsigned long ao_registers;
-	/*  divisors of master clock for analog input pacing */
+	/* divisors of master clock for analog input pacing */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	unsigned int count;	/*  number of analog input samples remaining */
-	unsigned int adc_fifo_bits;	/*  bits to write to interrupt/adcfifo register */
-	unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
-	unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
+	/* number of analog input samples remaining */
+	unsigned int count;
+	/* bits to write to registers */
+	unsigned int adc_fifo_bits;
+	unsigned int s5933_intcsr_bits;
+	unsigned int ao_control_bits;
+	/* fifo buffers */
 	short ai_buffer[AI_BUFFER_SIZE];
 	short ao_buffer[AO_BUFFER_SIZE];
-	/*  divisors of master clock for analog output pacing */
+	/* divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	unsigned int ao_count;	/*  number of analog output samples remaining */
-	int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
-	unsigned int caldac_value[NUM_CHANNELS_8800];	/*  for readback of caldac */
-	unsigned int trimpot_value[NUM_CHANNELS_8402];	/*  for readback of trimpot */
+	/* number of analog output samples remaining */
+	unsigned int ao_count;
+	/* cached values for readback */
+	int ao_value[2];
+	unsigned int caldac_value[NUM_CHANNELS_8800];
+	unsigned int trimpot_value[NUM_CHANNELS_8402];
 	unsigned int dac08_value;
 	unsigned int calibration_source;
 };

commit f6cf9a02600aa23780bc75da6ee7d315ce027db0
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:06:52 2012 -0700

    staging: comedi: cb_pcidas: remove 'volatile' on private data variables
    
    As indicated by checkpatch.pl, "WARNING: Use of volatile is usually
    wrong: ...". The variables in the private data that are marked
    volatile don't need to be. Remove the volatile.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Ian Abbott <abbbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 95ce54635932..eba39b4f7247 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -357,16 +357,16 @@ struct cb_pcidas_private {
 	/*  divisors of master clock for analog input pacing */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	volatile unsigned int count;	/*  number of analog input samples remaining */
-	volatile unsigned int adc_fifo_bits;	/*  bits to write to interrupt/adcfifo register */
-	volatile unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
-	volatile unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
+	unsigned int count;	/*  number of analog input samples remaining */
+	unsigned int adc_fifo_bits;	/*  bits to write to interrupt/adcfifo register */
+	unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
+	unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
 	short ai_buffer[AI_BUFFER_SIZE];
 	short ao_buffer[AO_BUFFER_SIZE];
 	/*  divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	volatile unsigned int ao_count;	/*  number of analog output samples remaining */
+	unsigned int ao_count;	/*  number of analog output samples remaining */
 	int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
 	unsigned int caldac_value[NUM_CHANNELS_8800];	/*  for readback of caldac */
 	unsigned int trimpot_value[NUM_CHANNELS_8402];	/*  for readback of trimpot */

commit 0c4ef0b90c4f77bb397e30c408118a1e0edbaddb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:06:08 2012 -0700

    staging: comedi: cb_pcidas: fix comments in *_cmdtest functions
    
    Remove some cut-and-paste comments from the skel driver in the
    *_cmdtest functions. Shorten some others to fix the checkpatch.pl
    complaints about WARNING: line over 80 characters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 12fb087f2b47..95ce54635932 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -809,14 +809,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	int tmp;
 	int i, gain, start_chan;
 
-	/* cmdtest tests a particular command to see if it is valid.
-	 * Using the cmdtest ioctl, a user can create a valid cmd
-	 * and then have it executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
-	 * the command passes. */
-
-	/* step 1: make sure trigger sources are trivially valid */
+	/* step 1: trigger sources are trivially valid */
 
 	tmp = cmd->start_src;
 	cmd->start_src &= TRIG_NOW | TRIG_EXT;
@@ -846,7 +839,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* step 2: trigger sources are unique and mutually compatible */
 
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
@@ -872,7 +865,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* step 3: arguments are trivially compatible */
 
 	switch (cmd->start_src) {
 	case TRIG_EXT:
@@ -1092,14 +1085,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	int err = 0;
 	int tmp;
 
-	/* cmdtest tests a particular command to see if it is valid.
-	 * Using the cmdtest ioctl, a user can create a valid cmd
-	 * and then have it executes by the cmd ioctl.
-	 *
-	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
-	 * the command passes. */
-
-	/* step 1: make sure trigger sources are trivially valid */
+	/* step 1: trigger sources are trivially valid */
 
 	tmp = cmd->start_src;
 	cmd->start_src &= TRIG_INT;
@@ -1129,7 +1115,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/* step 2: trigger sources are unique and mutually compatible */
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
 	    cmd->scan_begin_src != TRIG_EXT)
@@ -1140,7 +1126,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	if (err)
 		return 2;
 
-	/* step 3: make sure arguments are trivially compatible */
+	/* step 3: arguments are trivially compatible */
 
 	if (cmd->start_arg != 0) {
 		cmd->start_arg = 0;

commit 55acaf2d10d268d7db59877615955f910add5b1b
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:05:12 2012 -0700

    staging: comedi: cb_pcidas: fix some > 80 char lines
    
    Fix some of the comments that cause checkpatch.pl to complain
    about WARNING: line over 80 characters.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index ff08f9ec72df..12fb087f2b47 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1043,12 +1043,16 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	devpriv->adc_fifo_bits |= INTE;
 	devpriv->adc_fifo_bits &= ~INT_MASK;
 	if (cmd->flags & TRIG_WAKE_EOS) {
-		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
-			devpriv->adc_fifo_bits |= INT_EOS;	/*  interrupt end of burst */
-		else
-			devpriv->adc_fifo_bits |= INT_FNE;	/*  interrupt fifo not empty */
+		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {
+			/* interrupt end of burst */
+			devpriv->adc_fifo_bits |= INT_EOS;
+		} else {
+			/* interrupt fifo not empty */
+			devpriv->adc_fifo_bits |= INT_FNE;
+		}
 	} else {
-		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
+		/* interrupt fifo half full */
+		devpriv->adc_fifo_bits |= INT_FHF;
 	}
 
 	/*  enable (and clear) interrupts */
@@ -1474,7 +1478,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 					INT_ADCFIFO)) == 0)
 				break;
 			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
-			if (async->cmd.stop_src == TRIG_COUNT && --devpriv->count == 0) {	/* end of acquisition */
+			if (async->cmd.stop_src == TRIG_COUNT &&
+			    --devpriv->count == 0) {
+				/* end of acquisition */
 				cb_pcidas_cancel(dev, s);
 				async->events |= COMEDI_CB_EOA;
 				break;
@@ -1620,7 +1626,10 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = thisboard->ao_nchan;
-		/*  analog out resolution is the same as analog input resolution, so use ai_bits */
+		/*
+		 * analog out resolution is the same as
+		 * analog input resolution, so use ai_bits
+		 */
 		s->maxdata = (1 << thisboard->ai_bits) - 1;
 		s->range_table = &cb_pcidas_ao_ranges;
 		s->insn_read = cb_pcidas_ao_readback_insn;

commit 93c58378b5498f6810a2f269dc3c9a13731c3cf7
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:04:26 2012 -0700

    staging: comedi: cb_pcidas: fix a space before tab issue
    
    As reported by checkpatch.pl, spaces should not be used before
    tabs.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a0330714dd55..ff08f9ec72df 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1063,7 +1063,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	else if (cmd->start_src == TRIG_EXT) {
 		bits |= EXT_TRIGGER | TGEN | XTRCL;
 		if (thisboard->is_1602) {
-		    	if (cmd->start_arg & CR_INVERT)
+			if (cmd->start_arg & CR_INVERT)
 				bits |= TGPOL;
 			if (cmd->start_arg & CR_EDGE)
 				bits |= TGSEL;

commit 4f0036ef09387a49b709d9b319ad93492e53d790
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:03:34 2012 -0700

    staging: comedi: cb_pcidas: check for failure of subdev_8255_init
    
    It's possible for subdev_8255_init() to fail due to its kzalloc().
    Make sure to check for this failure and pass on the error code.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9379d2517702..a0330714dd55 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1640,7 +1640,10 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 
 	/* 8255 */
 	s = dev->subdevices + 2;
-	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);
+	ret = subdev_8255_init(dev, s, NULL,
+			       devpriv->pacer_counter_dio + DIO_8255);
+	if (ret)
+		return ret;
 
 	/*  serial EEPROM, */
 	s = dev->subdevices + 3;

commit 0a5aed487645b13531b876775c1390afd20296a5
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:02:40 2012 -0700

    staging: comedi: cb_pcidas: use the driver_name for the resource name
    
    Use the dev->driver->driver_name for the resource name passed
    to pci_request_regions(), by way of comedi_pci_enable(), and
    to request_irq() instead of the open coded "cb_pcidas".
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9f883dd77b34..9379d2517702 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1567,7 +1567,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		return -EIO;
 	thisboard = comedi_board(dev);
 
-	if (comedi_pci_enable(devpriv->pci_dev, "cb_pcidas")) {
+	if (comedi_pci_enable(devpriv->pci_dev, dev->driver->driver_name)) {
 		dev_err(dev->class_dev,
 			"Failed to enable PCI device and request regions\n");
 		return -EIO;
@@ -1585,7 +1585,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
-			IRQF_SHARED, "cb_pcidas", dev)) {
+			IRQF_SHARED, dev->driver->driver_name, dev)) {
 		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
 			devpriv->pci_dev->irq);
 		return -EINVAL;

commit b8ac8c63429e8b354067e3dcaa549dc0b53be5d4
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:01:51 2012 -0700

    staging: comedi: cb_pcidas: move the "find pci" dev_printk messages
    
    Move the dev_printk messages associated with the "find pci device"
    from the *attach function into the *find_pci_device function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a2901bb50e01..9f883dd77b34 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1537,10 +1537,15 @@ static struct pci_dev *cb_pcidas_find_pci_device(struct comedi_device *dev,
 					continue;
 				}
 			}
+			dev_dbg(dev->class_dev,
+				"Found %s on bus %i, slot %i\n",
+				thisboard->name,
+				pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 			dev->board_ptr = thisboard;
 			return pcidev;
 		}
 	}
+	dev_err(dev->class_dev, "No supported card found\n");
 	return NULL;
 }
 
@@ -1558,15 +1563,9 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	devpriv = dev->private;
 
 	devpriv->pci_dev = cb_pcidas_find_pci_device(dev, it);
-	if (!devpriv->pci_dev) {
-		dev_err(dev->class_dev, "No supported card found\n");
+	if (!devpriv->pci_dev)
 		return -EIO;
-	}
-
 	thisboard = comedi_board(dev);
-	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
-		thisboard->name, devpriv->pci_dev->bus->number,
-		PCI_SLOT(devpriv->pci_dev->devfn));
 
 	if (comedi_pci_enable(devpriv->pci_dev, "cb_pcidas")) {
 		dev_err(dev->class_dev,

commit f3c34b2fc6ccc36f171633fa86b3d59a36792c25
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:01:05 2012 -0700

    staging: comedi: cb_pcidas: cleanup ai_config_insn()
    
    Absorb the helper function ai_config_calibration_source() into
    ai_config_insn() and remove the static const variable that
    was in the helper function.
    
    Return an error code (-EINVAL) when appropriate and the number
    of data values used (insn->n) for success.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3cdd026767c1..a2901bb50e01 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -439,38 +439,28 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device *dev,
-					unsigned int *data)
-{
-	struct cb_pcidas_private *devpriv = dev->private;
-	static const int num_calibration_sources = 8;
-	unsigned int source = data[1];
-
-	if (source >= num_calibration_sources) {
-		dev_err(dev->class_dev, "invalid calibration source: %i\n",
-			source);
-		return -EINVAL;
-	}
-
-	devpriv->calibration_source = source;
-
-	return 2;
-}
-
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 			  struct comedi_insn *insn, unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	int id = data[0];
+	unsigned int source = data[1];
 
 	switch (id) {
 	case INSN_CONFIG_ALT_SOURCE:
-		return ai_config_calibration_source(dev, data);
+		if (source >= 8) {
+			dev_err(dev->class_dev,
+				"invalid calibration source: %i\n",
+				source);
+			return -EINVAL;
+		}
+		devpriv->calibration_source = source;
 		break;
 	default:
 		return -EINVAL;
 		break;
 	}
-	return -EINVAL;
+	return insn->n;
 }
 
 /* analog output insn for pcidas-1000 and 1200 series */

commit 8f608fc8eefc9bff17a7139801eb4b4f571f262d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 18:00:19 2012 -0700

    staging: comedi: cb_pcidas: cleanup the boardinfo 4
    
    For aesthetic reasons, rename the ai_se_chans variable to
    ai_nchan. It's a bit shorter and provides the necessary
    information about the variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 59b0f9116cd8..3cdd026767c1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -239,7 +239,7 @@ enum trimpot_model {
 struct cb_pcidas_board {
 	const char *name;
 	unsigned short device_id;
-	int ai_se_chans;	/*  Inputs in single-ended mode */
+	int ai_nchan;		/*  Inputs in single-ended mode */
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_nchan;		/*  number of analog out channels */
@@ -256,7 +256,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
 		.name		= "pci-das1602/16",
 		.device_id	= 0x1,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.ao_nchan	= 2,
@@ -270,7 +270,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1200",
 		.device_id	= 0xF,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
@@ -280,7 +280,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1602/12",
 		.device_id	= 0x10,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
@@ -293,7 +293,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1200/jr",
 		.device_id	= 0x19,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
@@ -302,7 +302,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1602/16/jr",
 		.device_id	= 0x1C,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
@@ -313,7 +313,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1000",
 		.device_id	= 0x4C,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
@@ -322,7 +322,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1001",
 		.device_id	= 0x1a,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
@@ -332,7 +332,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	}, {
 		.name		= "pci-das1002",
 		.device_id	= 0x1b,
-		.ai_se_chans	= 16,
+		.ai_nchan	= 16,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
@@ -1615,8 +1615,8 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	s->type = COMEDI_SUBD_AI;
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
 	/* WARNING: Number of inputs in differential mode is ignored */
-	s->n_chan = thisboard->ai_se_chans;
-	s->len_chanlist = thisboard->ai_se_chans;
+	s->n_chan = thisboard->ai_nchan;
+	s->len_chanlist = thisboard->ai_nchan;
 	s->maxdata = (1 << thisboard->ai_bits) - 1;
 	s->range_table = thisboard->ranges;
 	s->insn_read = cb_pcidas_ai_rinsn;

commit a605be0c68f4c7585255bdb5a8ddbc1782d829ad
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:59:17 2012 -0700

    staging: comedi: cb_pcidas: cleanup the boardinfo 3
    
    Remove the ai_diff_chans variable. This option is not used in
    the driver. If it is used later, the value can be easily found
    by using ai_se_chans/2.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f7090dec71c3..59b0f9116cd8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -240,7 +240,6 @@ struct cb_pcidas_board {
 	const char *name;
 	unsigned short device_id;
 	int ai_se_chans;	/*  Inputs in single-ended mode */
-	int ai_diff_chans;	/*  Inputs in differential mode */
 	int ai_bits;		/*  analog input resolution */
 	int ai_speed;		/*  fastest conversion period in ns */
 	int ao_nchan;		/*  number of analog out channels */
@@ -258,7 +257,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1602/16",
 		.device_id	= 0x1,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.ao_nchan	= 2,
@@ -273,7 +271,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200",
 		.device_id	= 0xF,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
@@ -284,7 +281,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1602/12",
 		.device_id	= 0x10,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
@@ -298,7 +294,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1200/jr",
 		.device_id	= 0x19,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.fifo_size	= 1024,
@@ -308,7 +303,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1602/16/jr",
 		.device_id	= 0x1C,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
 		.fifo_size	= 512,
@@ -320,7 +314,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1000",
 		.device_id	= 0x4C,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 4000,
 		.fifo_size	= 1024,
@@ -330,7 +323,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1001",
 		.device_id	= 0x1a,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
@@ -341,7 +333,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.name		= "pci-das1002",
 		.device_id	= 0x1b,
 		.ai_se_chans	= 16,
-		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,

commit 0c5ecbb0b77833e8ac5c90b7652684ae5f16480f
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:58:27 2012 -0700

    staging: comedi: cb_pcidas: cleanup the boardinfo 2
    
    Remove all the boardinfo values that are = 0. They will
    default to that value.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a5b3659bc1ca..f7090dec71c3 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -277,12 +277,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
 		.ao_nchan	= 2,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
-		.is_1602	= 0,
 	}, {
 		.name		= "pci-das1602/12",
 		.device_id	= 0x10,
@@ -296,7 +293,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
 		.is_1602	= 1,
 	}, {
 		.name		= "pci-das1200/jr",
@@ -305,13 +301,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 3200,
-		.ao_nchan	= 0,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
-		.is_1602	= 0,
 	}, {
 		.name		= "pci-das1602/16/jr",
 		.device_id	= 0x1C,
@@ -319,8 +311,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_diff_chans	= 8,
 		.ai_bits	= 16,
 		.ai_speed	= 5000,
-		.ao_nchan	= 0,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 512,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD8402,
@@ -333,13 +323,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_diff_chans	= 8,
 		.ai_bits	= 12,
 		.ai_speed	= 4000,
-		.ao_nchan	= 0,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
-		.is_1602	= 0,
 	}, {
 		.name		= "pci-das1001",
 		.device_id	= 0x1a,
@@ -348,12 +334,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_alt_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
-		.is_1602	= 0,
 	}, {
 		.name		= "pci-das1002",
 		.device_id	= 0x1b,
@@ -362,12 +345,9 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		.ai_bits	= 12,
 		.ai_speed	= 6800,
 		.ao_nchan	= 2,
-		.has_ao_fifo	= 0,
 		.fifo_size	= 1024,
 		.ranges		= &cb_pcidas_ranges,
 		.trimpot	= AD7376,
-		.has_dac08	= 0,
-		.is_1602	= 0,
 	},
 };
 

commit 17883d63b32390098e42cb1a0739d361e38b528e
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:57:20 2012 -0700

    staging: comedi: cb_pcidas: cleanup the boardinfo 1
    
    For aesthetic reasons, add whitespace to the boardinfo to
    improve readability.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0c14582085f8..a5b3659bc1ca 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -255,127 +255,120 @@ struct cb_pcidas_board {
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
-	 .name = "pci-das1602/16",
-	 .device_id = 0x1,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 2,
-	 .has_ao_fifo = 1,
-	 .ao_scan_speed = 10000,
-	 .fifo_size = 512,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD8402,
-	 .has_dac08 = 1,
-	 .is_1602 = 1,
-	 },
-	{
-	 .name = "pci-das1200",
-	 .device_id = 0xF,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 3200,
-	 .ao_nchan = 2,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 0,
-	 },
-	{
-	 .name = "pci-das1602/12",
-	 .device_id = 0x10,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 3200,
-	 .ao_nchan = 2,
-	 .has_ao_fifo = 1,
-	 .ao_scan_speed = 4000,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 1,
-	 },
-	{
-	 .name = "pci-das1200/jr",
-	 .device_id = 0x19,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 3200,
-	 .ao_nchan = 0,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 0,
-	 },
-	{
-	 .name = "pci-das1602/16/jr",
-	 .device_id = 0x1C,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 16,
-	 .ai_speed = 5000,
-	 .ao_nchan = 0,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 512,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD8402,
-	 .has_dac08 = 1,
-	 .is_1602 = 1,
-	 },
-	{
-	 .name = "pci-das1000",
-	 .device_id = 0x4C,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 4000,
-	 .ao_nchan = 0,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 0,
-	 },
-	{
-	 .name = "pci-das1001",
-	 .device_id = 0x1a,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 6800,
-	 .ao_nchan = 2,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_alt_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 0,
-	 },
-	{
-	 .name = "pci-das1002",
-	 .device_id = 0x1b,
-	 .ai_se_chans = 16,
-	 .ai_diff_chans = 8,
-	 .ai_bits = 12,
-	 .ai_speed = 6800,
-	 .ao_nchan = 2,
-	 .has_ao_fifo = 0,
-	 .fifo_size = 1024,
-	 .ranges = &cb_pcidas_ranges,
-	 .trimpot = AD7376,
-	 .has_dac08 = 0,
-	 .is_1602 = 0,
-	 },
+		.name		= "pci-das1602/16",
+		.device_id	= 0x1,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 2,
+		.has_ao_fifo	= 1,
+		.ao_scan_speed	= 10000,
+		.fifo_size	= 512,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD8402,
+		.has_dac08	= 1,
+		.is_1602	= 1,
+	}, {
+		.name		= "pci-das1200",
+		.device_id	= 0xF,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 3200,
+		.ao_nchan	= 2,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 0,
+	}, {
+		.name		= "pci-das1602/12",
+		.device_id	= 0x10,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 3200,
+		.ao_nchan	= 2,
+		.has_ao_fifo	= 1,
+		.ao_scan_speed	= 4000,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 1,
+	}, {
+		.name		= "pci-das1200/jr",
+		.device_id	= 0x19,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 3200,
+		.ao_nchan	= 0,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 0,
+	}, {
+		.name		= "pci-das1602/16/jr",
+		.device_id	= 0x1C,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 16,
+		.ai_speed	= 5000,
+		.ao_nchan	= 0,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 512,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD8402,
+		.has_dac08	= 1,
+		.is_1602	= 1,
+	}, {
+		.name		= "pci-das1000",
+		.device_id	= 0x4C,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 4000,
+		.ao_nchan	= 0,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 0,
+	}, {
+		.name		= "pci-das1001",
+		.device_id	= 0x1a,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 6800,
+		.ao_nchan	= 2,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_alt_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 0,
+	}, {
+		.name		= "pci-das1002",
+		.device_id	= 0x1b,
+		.ai_se_chans	= 16,
+		.ai_diff_chans	= 8,
+		.ai_bits	= 12,
+		.ai_speed	= 6800,
+		.ao_nchan	= 2,
+		.has_ao_fifo	= 0,
+		.fifo_size	= 1024,
+		.ranges		= &cb_pcidas_ranges,
+		.trimpot	= AD7376,
+		.has_dac08	= 0,
+		.is_1602	= 0,
+	},
 };
 
 /* this structure is for data unique to this hardware driver.  If

commit 23e3cce3270b5f0d9c094c9bcb34d919713e02eb
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:56:43 2012 -0700

    staging: comedi: cb_pcidas: simplify the boardinfo
    
    The boardinfo values 'has_ai_trig_gated' and 'has_ai_trig_invert'
    are both only set for the "1602" versions of the boards supported
    by this driver.
    
    Simplify the boardinfo, and the code, by replacing these two
    variables with one "is_1602" variable.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4b653c5edf53..0c14582085f8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -250,8 +250,7 @@ struct cb_pcidas_board {
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
-	unsigned has_ai_trig_gated:1;	/* Tells if the AI trigger can be gated */
-	unsigned has_ai_trig_invert:1;	/* Tells if the AI trigger can be inverted */
+	unsigned is_1602:1;
 };
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
@@ -269,8 +268,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD8402,
 	 .has_dac08 = 1,
-	 .has_ai_trig_gated = 1,
-	 .has_ai_trig_invert = 1,
+	 .is_1602 = 1,
 	 },
 	{
 	 .name = "pci-das1200",
@@ -285,8 +283,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 0,
-	 .has_ai_trig_invert = 0,
+	 .is_1602 = 0,
 	 },
 	{
 	 .name = "pci-das1602/12",
@@ -302,8 +299,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 1,
-	 .has_ai_trig_invert = 1,
+	 .is_1602 = 1,
 	 },
 	{
 	 .name = "pci-das1200/jr",
@@ -318,8 +314,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 0,
-	 .has_ai_trig_invert = 0,
+	 .is_1602 = 0,
 	 },
 	{
 	 .name = "pci-das1602/16/jr",
@@ -334,8 +329,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD8402,
 	 .has_dac08 = 1,
-	 .has_ai_trig_gated = 1,
-	 .has_ai_trig_invert = 1,
+	 .is_1602 = 1,
 	 },
 	{
 	 .name = "pci-das1000",
@@ -350,8 +344,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 0,
-	 .has_ai_trig_invert = 0,
+	 .is_1602 = 0,
 	 },
 	{
 	 .name = "pci-das1001",
@@ -366,8 +359,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_alt_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 0,
-	 .has_ai_trig_invert = 0,
+	 .is_1602 = 0,
 	 },
 	{
 	 .name = "pci-das1002",
@@ -382,8 +374,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
-	 .has_ai_trig_gated = 0,
-	 .has_ai_trig_invert = 0,
+	 .is_1602 = 0,
 	 },
 };
 
@@ -938,8 +929,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 			    ~(CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
 			err++;
 		}
-		if (!thisboard->has_ai_trig_invert &&
-		    (cmd->start_arg & CR_INVERT)) {
+		if (!thisboard->is_1602 && (cmd->start_arg & CR_INVERT)) {
 			cmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);
 			err++;
 		}
@@ -1118,11 +1108,12 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= SW_TRIGGER;
 	else if (cmd->start_src == TRIG_EXT) {
 		bits |= EXT_TRIGGER | TGEN | XTRCL;
-		if (thisboard->has_ai_trig_invert
-		    && (cmd->start_arg & CR_INVERT))
-			bits |= TGPOL;
-		if (thisboard->has_ai_trig_gated && (cmd->start_arg & CR_EDGE))
-			bits |= TGSEL;
+		if (thisboard->is_1602) {
+		    	if (cmd->start_arg & CR_INVERT)
+				bits |= TGPOL;
+			if (cmd->start_arg & CR_EDGE)
+				bits |= TGSEL;
+		}
 	} else {
 		comedi_error(dev, "bug!");
 		return -1;

commit 4466fc45007c346971ae537cc64e82a8a4961160
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:56:04 2012 -0700

    staging: comedi: cb_pcidas: remove unused io region size defines
    
    The defines for the size of the io regions are not used in the
    driver. Also, this information can be found using the pci helper
    pci_resource_len(). Remove the defines.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e790ab0711c2..4b653c5edf53 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -89,12 +89,6 @@ analog triggering on 1602 series
 #define NUM_CHANNELS_8402 2
 #define NUM_CHANNELS_DAC08 1
 
-/* sizes of io regions */
-#define CONT_STAT_SIZE 10
-#define ADC_FIFO_SIZE 4
-#define PACER_SIZE 12
-#define AO_SIZE 4
-
 /* Control/Status registers */
 #define INT_ADCFIFO	0	/*  INTERRUPT / ADC FIFO register */
 #define   INT_EOS 0x1		/*  interrupt end of scan */

commit 193debd1987656a33773395e38c8427d2f02fbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:55:21 2012 -0700

    staging: comedi: cb_pcidas: remove CB_PCIDAS_DEBUG define
    
    This define enables some debug code that output a number
    of dev_dbg() messages. These might be useful for development
    but should not be in the final driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 4e5f1ba77ac7..e790ab0711c2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -79,9 +79,6 @@ analog triggering on 1602 series
 #include "amcc_s5933.h"
 #include "comedi_fc.h"
 
-#undef CB_PCIDAS_DEBUG		/*  disable debugging code */
-/* #define CB_PCIDAS_DEBUG         enable debugging code */
-
 /* PCI vendor number of ComputerBoards/MeasurementComputing */
 #define PCI_VENDOR_ID_CB	0x1307
 #define TIMER_BASE 100		/*  10MHz master clock */
@@ -1092,10 +1089,6 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= PACER_INT;
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "sent 0x%x to adcmux control\n", bits);
-#endif
-
 	/*  load counters */
 	if (cmd->convert_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->convert_arg,
@@ -1119,10 +1112,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	} else {
 		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
-		devpriv->adc_fifo_bits);
-#endif
+
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
 	     devpriv->control_status + INT_ADCFIFO);
@@ -1146,9 +1136,6 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
 		bits |= BURSTE;
 	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "sent 0x%x to trig control\n", bits);
-#endif
 
 	return 0;
 }
@@ -1322,10 +1309,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	/*  enable dac half-full and empty interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
-		devpriv->adc_fifo_bits);
-#endif
+
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
 	     devpriv->control_status + INT_ADCFIFO);
@@ -1333,10 +1317,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "sent 0x%x to dac control\n",
-		devpriv->ao_control_bits);
-#endif
+
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	async->inttrig = NULL;
@@ -1508,11 +1489,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	async->events = 0;
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "intcsr 0x%x\n", s5933_status);
-	dev_dbg(dev->class_dev, "mbef 0x%x\n",
-		inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
-#endif
 
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
 		return IRQ_NONE;
@@ -1524,10 +1500,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	status = inw(devpriv->control_status + INT_ADCFIFO);
-#ifdef CB_PCIDAS_DEBUG
-	if ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0)
-		comedi_error(dev, "spurious interrupt");
-#endif
 
 	/*  check for analog output interrupt */
 	if (status & (DAHFI | DAEMI))

commit 7302abef2ef3c6aae739f578a67504bb84974199
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:54:38 2012 -0700

    staging: comedi: cb_pcidas: remove the PCI BAR index defines
    
    The defines for the "indices of the base address regions" don't
    add much to the readability of the code. They are only used in
    the pci_resource_start() calls to get the base address for
    the various io regions and the names of the variables provide
    adequate documentation.
    
    Remove the defines and just use the open-coded values for the
    BARs. Also, remove the incomplete comment above the initialization
    of the variables.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 990e6aba9c0f..4e5f1ba77ac7 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -92,14 +92,6 @@ analog triggering on 1602 series
 #define NUM_CHANNELS_8402 2
 #define NUM_CHANNELS_DAC08 1
 
-/* PCI-DAS base addresses */
-
-/* indices of base address regions */
-#define S5933_BADRINDEX 0
-#define CONT_STAT_BADRINDEX 1
-#define ADC_FIFO_BADRINDEX 2
-#define PACER_BADRINDEX 3
-#define AO_BADRINDEX 4
 /* sizes of io regions */
 #define CONT_STAT_SIZE 10
 #define ADC_FIFO_SIZE 4
@@ -1670,22 +1662,14 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 			"Failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
-	/*
-	 * Initialize devpriv->control_status and devpriv->adc_fifo to point to
-	 * their base address.
-	 */
-	devpriv->s5933_config =
-	    pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
-	devpriv->control_status =
-	    pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
-	devpriv->adc_fifo =
-	    pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
-	devpriv->pacer_counter_dio =
-	    pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
-	if (thisboard->ao_nchan) {
-		devpriv->ao_registers =
-		    pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
-	}
+
+	devpriv->s5933_config = pci_resource_start(devpriv->pci_dev, 0);
+	devpriv->control_status = pci_resource_start(devpriv->pci_dev, 1);
+	devpriv->adc_fifo = pci_resource_start(devpriv->pci_dev, 2);
+	devpriv->pacer_counter_dio = pci_resource_start(devpriv->pci_dev, 3);
+	if (thisboard->ao_nchan)
+		devpriv->ao_registers = pci_resource_start(devpriv->pci_dev, 4);
+
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);

commit 9795f562bd72387da8c9e5bc99e2cce869aa1bc1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:53:55 2012 -0700

    staging: comedi: cb_pcidas: remove some obvious comments in the attach
    
    These comments are unnecessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 051c94cc01f8..990e6aba9c0f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1650,9 +1650,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	int i;
 	int ret;
 
-/*
- * Allocate the private structure area.
- */
 	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
 		return -ENOMEM;
 	devpriv = dev->private;
@@ -1668,9 +1665,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		thisboard->name, devpriv->pci_dev->bus->number,
 		PCI_SLOT(devpriv->pci_dev->devfn));
 
-	/*
-	 * Enable PCI device and reserve I/O ports.
-	 */
 	if (comedi_pci_enable(devpriv->pci_dev, "cb_pcidas")) {
 		dev_err(dev->class_dev,
 			"Failed to enable PCI device and request regions\n");
@@ -1696,7 +1690,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	outl(INTCSR_INBOX_INTR_STATUS,
 	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	/*  get irq */
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
 		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
@@ -1705,7 +1698,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	}
 	dev->irq = devpriv->pci_dev->irq;
 
-	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
 	ret = comedi_alloc_subdevices(dev, 7);

commit 327be979c1819d4404927af4b6e3ba8f22a4fa07
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:53:08 2012 -0700

    staging: comedi: cb_pcidas: factor out the find pci device code
    
    Factor the "find pci device" code out of the attach function.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 146d0788f3db..051c94cc01f8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1608,64 +1608,70 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int cb_pcidas_attach(struct comedi_device *dev,
-			    struct comedi_devconfig *it)
+static struct pci_dev *cb_pcidas_find_pci_device(struct comedi_device *dev,
+						 struct comedi_devconfig *it)
 {
 	const struct cb_pcidas_board *thisboard;
-	struct cb_pcidas_private *devpriv;
-	struct comedi_subdevice *s;
 	struct pci_dev *pcidev = NULL;
-	int index;
+	int bus = it->options[0];
+	int slot = it->options[1];
 	int i;
-	int ret;
-
-/*
- * Allocate the private structure area.
- */
-	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
-		return -ENOMEM;
-	devpriv = dev->private;
-
-/*
- * Probe the device to determine what device in the series it is.
- */
 
 	for_each_pci_dev(pcidev) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
 		/*  loop through cards supported by this driver */
-		for (index = 0; index < ARRAY_SIZE(cb_pcidas_boards); index++) {
-			if (cb_pcidas_boards[index].device_id != pcidev->device)
+		for (i = 0; i < ARRAY_SIZE(cb_pcidas_boards); i++) {
+			thisboard = &cb_pcidas_boards[i];
+			if (thisboard->device_id != pcidev->device)
 				continue;
 			/*  was a particular bus/slot requested? */
-			if (it->options[0] || it->options[1]) {
+			if (bus || slot) {
 				/*  are we on the wrong bus/slot? */
-				if (pcidev->bus->number != it->options[0] ||
-				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
+				if (pcidev->bus->number != bus ||
+				    PCI_SLOT(pcidev->devfn) != slot) {
 					continue;
 				}
 			}
-			devpriv->pci_dev = pcidev;
-			dev->board_ptr = cb_pcidas_boards + index;
-			goto found;
+			dev->board_ptr = thisboard;
+			return pcidev;
 		}
 	}
+	return NULL;
+}
+
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
+{
+	const struct cb_pcidas_board *thisboard;
+	struct cb_pcidas_private *devpriv;
+	struct comedi_subdevice *s;
+	int i;
+	int ret;
 
-	dev_err(dev->class_dev,
-		"No supported ComputerBoards/MeasurementComputing card found on requested position\n");
-	return -EIO;
+/*
+ * Allocate the private structure area.
+ */
+	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
+		return -ENOMEM;
+	devpriv = dev->private;
+
+	devpriv->pci_dev = cb_pcidas_find_pci_device(dev, it);
+	if (!devpriv->pci_dev) {
+		dev_err(dev->class_dev, "No supported card found\n");
+		return -EIO;
+	}
 
-found:
 	thisboard = comedi_board(dev);
 	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
-		cb_pcidas_boards[index].name, pcidev->bus->number,
-		PCI_SLOT(pcidev->devfn));
+		thisboard->name, devpriv->pci_dev->bus->number,
+		PCI_SLOT(devpriv->pci_dev->devfn));
 
 	/*
 	 * Enable PCI device and reserve I/O ports.
 	 */
-	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
+	if (comedi_pci_enable(devpriv->pci_dev, "cb_pcidas")) {
 		dev_err(dev->class_dev,
 			"Failed to enable PCI device and request regions\n");
 		return -EIO;

commit 82d8c74dcc75235740db3ed947267bfa5baa3117
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:52:29 2012 -0700

    staging: comedi: cb_pcidas: remove thisboard and devpriv macros
    
    The 'thisboard' and 'devpriv' macros rely on a local variable having
    a specific name and yield pointers derived from that local variable.
    Replace the macros with local variables where used. use the
    comedi_board() helper to get the 'thisboard' pointer.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 5c3758c49949..146d0788f3db 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -404,11 +404,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 },
 };
 
-/*
- * Useful for shorthand access to the particular board structure
- */
-#define thisboard ((const struct cb_pcidas_board *)dev->board_ptr)
-
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
@@ -441,14 +436,10 @@ struct cb_pcidas_private {
 	unsigned int calibration_source;
 };
 
-/*
- * most drivers define the following macro to make it easy to
- * access the private structure.
- */
-#define devpriv ((struct cb_pcidas_private *)dev->private)
-
 static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }
 
@@ -460,6 +451,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	int n, i;
 	unsigned int bits;
 	static const int timeout = 10000;
@@ -512,6 +504,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 static int ai_config_calibration_source(struct comedi_device *dev,
 					unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	static const int num_calibration_sources = 8;
 	unsigned int source = data[1];
 
@@ -548,6 +541,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
 				     struct comedi_insn *insn,
 				     unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	int channel;
 	unsigned long flags;
 
@@ -574,6 +568,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn, unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	int channel;
 	unsigned long flags;
 
@@ -609,6 +604,8 @@ static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
 				      struct comedi_insn *insn,
 				      unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -632,6 +629,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 static int nvram_read(struct comedi_device *dev, unsigned int address,
 			uint8_t *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long iobase = devpriv->s5933_config;
 
 	if (wait_for_nvram_ready(iobase) < 0)
@@ -674,6 +672,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 					unsigned int bitstream,
 					unsigned int bitstream_length)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	static const int write_delay = 1;
 	unsigned int bit;
 
@@ -690,6 +689,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
 	unsigned int bitstream = ((address & 0x7) << 8) | value;
@@ -730,6 +730,8 @@ static int caldac_read_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
@@ -738,6 +740,8 @@ static int caldac_read_insn(struct comedi_device *dev,
 /* 1602/16 pregain offset */
 static int dac08_write(struct comedi_device *dev, unsigned int value)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	if (devpriv->dac08_value == value)
 		return 1;
 
@@ -767,6 +771,8 @@ static int dac08_read_insn(struct comedi_device *dev,
 			   struct comedi_subdevice *s, struct comedi_insn *insn,
 			   unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	data[0] = devpriv->dac08_value;
 
 	return 1;
@@ -774,6 +780,7 @@ static int dac08_read_insn(struct comedi_device *dev,
 
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 7;
 	unsigned int bitstream = value & 0x7f;
 	unsigned int register_bits;
@@ -798,6 +805,7 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 			      uint8_t value)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	static const int bitstream_length = 10;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
 	unsigned int register_bits;
@@ -819,6 +827,9 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 				   unsigned int channel, unsigned int value)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	if (devpriv->trimpot_value[channel] == value)
 		return 1;
 
@@ -852,6 +863,7 @@ static int trimpot_read_insn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
 	data[0] = devpriv->trimpot_value[channel];
@@ -863,6 +875,8 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 	int i, gain, start_chan;
@@ -1039,6 +1053,8 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 				    int rounding_flags)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
 				       &(devpriv->divisor2), ns,
 				       rounding_flags & TRIG_ROUND_MASK);
@@ -1053,6 +1069,8 @@ static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int bits;
@@ -1147,6 +1165,8 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				struct comedi_cmd *cmd)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	int err = 0;
 	int tmp;
 
@@ -1263,6 +1283,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 static int cb_pcidas_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1283,6 +1304,8 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int trig_num)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &s->async->cmd;
@@ -1332,6 +1355,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
@@ -1399,6 +1423,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dev->spinlock, flags);
@@ -1416,6 +1441,8 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 {
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1472,6 +1499,8 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *)d;
+	const struct cb_pcidas_board *thisboard = comedi_board(dev);
+	struct cb_pcidas_private *devpriv = dev->private;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	int status, s5933_status;
@@ -1582,6 +1611,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 static int cb_pcidas_attach(struct comedi_device *dev,
 			    struct comedi_devconfig *it)
 {
+	const struct cb_pcidas_board *thisboard;
+	struct cb_pcidas_private *devpriv;
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev = NULL;
 	int index;
@@ -1593,6 +1624,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
  */
 	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
 		return -ENOMEM;
+	devpriv = dev->private;
 
 /*
  * Probe the device to determine what device in the series it is.
@@ -1625,7 +1657,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	return -EIO;
 
 found:
-
+	thisboard = comedi_board(dev);
 	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
 		cb_pcidas_boards[index].name, pcidev->bus->number,
 		PCI_SLOT(pcidev->devfn));
@@ -1781,6 +1813,8 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 
 static void cb_pcidas_detach(struct comedi_device *dev)
 {
+	struct cb_pcidas_private *devpriv = dev->private;
+
 	if (devpriv) {
 		if (devpriv->s5933_config) {
 			outl(INTCSR_INBOX_INTR_STATUS,

commit 536af69e90b03966928ed59448f5ccd95ebd13ea
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:51:53 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 9
    
    Move the nvram_read function, and its helper, to remove the need
    for the last of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 9c7f24aefd36..5c3758c49949 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,9 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int nvram_read(struct comedi_device *dev, unsigned int address,
-		      uint8_t *data);
-
 static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
@@ -617,6 +614,45 @@ static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
 	return 1;
 }
 
+static int wait_for_nvram_ready(unsigned long s5933_base_addr)
+{
+	static const int timeout = 1000;
+	unsigned int i;
+
+	for (i = 0; i < timeout; i++) {
+		if ((inb(s5933_base_addr +
+			 AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
+		    == 0)
+			return 0;
+		udelay(1);
+	}
+	return -1;
+}
+
+static int nvram_read(struct comedi_device *dev, unsigned int address,
+			uint8_t *data)
+{
+	unsigned long iobase = devpriv->s5933_config;
+
+	if (wait_for_nvram_ready(iobase) < 0)
+		return -ETIMEDOUT;
+
+	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
+	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
+	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
+	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
+	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
+
+	if (wait_for_nvram_ready(iobase) < 0)
+		return -ETIMEDOUT;
+
+	*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);
+
+	return 0;
+}
+
 static int eeprom_read_insn(struct comedi_device *dev,
 			    struct comedi_subdevice *s,
 			    struct comedi_insn *insn, unsigned int *data)
@@ -1543,45 +1579,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int wait_for_nvram_ready(unsigned long s5933_base_addr)
-{
-	static const int timeout = 1000;
-	unsigned int i;
-
-	for (i = 0; i < timeout; i++) {
-		if ((inb(s5933_base_addr +
-			 AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
-		    == 0)
-			return 0;
-		udelay(1);
-	}
-	return -1;
-}
-
-static int nvram_read(struct comedi_device *dev, unsigned int address,
-			uint8_t *data)
-{
-	unsigned long iobase = devpriv->s5933_config;
-
-	if (wait_for_nvram_ready(iobase) < 0)
-		return -ETIMEDOUT;
-
-	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
-	     iobase + AMCC_OP_REG_MCSR_NVCMD);
-	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
-	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
-	     iobase + AMCC_OP_REG_MCSR_NVCMD);
-	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
-	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
-
-	if (wait_for_nvram_ready(iobase) < 0)
-		return -ETIMEDOUT;
-
-	*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);
-
-	return 0;
-}
-
 static int cb_pcidas_attach(struct comedi_device *dev,
 			    struct comedi_devconfig *it)
 {

commit 20535c1f3c010fffd84e1d9dc24ac352a0b9ad36
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:51:14 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 8
    
    Move the trimpot_{7376,8402}_write functions to remove the need
    for the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 28bcb64cbf0f..9c7f24aefd36 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,9 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
-static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-			      uint8_t value);
 static int nvram_read(struct comedi_device *dev, unsigned int address,
 		      uint8_t *data);
 
@@ -739,6 +736,50 @@ static int dac08_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
+static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
+{
+	static const int bitstream_length = 7;
+	unsigned int bitstream = value & 0x7f;
+	unsigned int register_bits;
+	static const int ad7376_udelay = 1;
+
+	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	udelay(ad7376_udelay);
+	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+
+	write_calibration_bitstream(dev, register_bits, bitstream,
+				    bitstream_length);
+
+	udelay(ad7376_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 0;
+}
+
+/* For 1602/16 only
+ * ch 0 : adc gain
+ * ch 1 : adc postgain offset */
+static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
+			      uint8_t value)
+{
+	static const int bitstream_length = 10;
+	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
+	unsigned int register_bits;
+	static const int ad8402_udelay = 1;
+
+	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	udelay(ad8402_udelay);
+	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+
+	write_calibration_bitstream(dev, register_bits, bitstream,
+				    bitstream_length);
+
+	udelay(ad8402_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 0;
+}
+
 static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 				   unsigned int channel, unsigned int value)
 {
@@ -1502,50 +1543,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
-{
-	static const int bitstream_length = 7;
-	unsigned int bitstream = value & 0x7f;
-	unsigned int register_bits;
-	static const int ad7376_udelay = 1;
-
-	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	udelay(ad7376_udelay);
-	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
-
-	write_calibration_bitstream(dev, register_bits, bitstream,
-				    bitstream_length);
-
-	udelay(ad7376_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
-
-	return 0;
-}
-
-/* For 1602/16 only
- * ch 0 : adc gain
- * ch 1 : adc postgain offset */
-static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-			      uint8_t value)
-{
-	static const int bitstream_length = 10;
-	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
-	unsigned int register_bits;
-	static const int ad8402_udelay = 1;
-
-	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	udelay(ad8402_udelay);
-	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
-
-	write_calibration_bitstream(dev, register_bits, bitstream,
-				    bitstream_length);
-
-	udelay(ad8402_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
-
-	return 0;
-}
-
 static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 {
 	static const int timeout = 1000;

commit 0c15d553252657d895492252203bcccdbe4a9b21
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:50:36 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 7
    
    Move the caldac_8800_write function, and it's helper, to remove
    the need for the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1e5616e15fb5..28bcb64cbf0f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,8 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value);
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 			      uint8_t value);
@@ -638,6 +636,54 @@ static int eeprom_read_insn(struct comedi_device *dev,
 	return 1;
 }
 
+static void write_calibration_bitstream(struct comedi_device *dev,
+					unsigned int register_bits,
+					unsigned int bitstream,
+					unsigned int bitstream_length)
+{
+	static const int write_delay = 1;
+	unsigned int bit;
+
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		if (bitstream & bit)
+			register_bits |= SERIAL_DATA_IN_BIT;
+		else
+			register_bits &= ~SERIAL_DATA_IN_BIT;
+		udelay(write_delay);
+		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+	}
+}
+
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
+			     uint8_t value)
+{
+	static const int num_caldac_channels = 8;
+	static const int bitstream_length = 11;
+	unsigned int bitstream = ((address & 0x7) << 8) | value;
+	static const int caldac_8800_udelay = 1;
+
+	if (address >= num_caldac_channels) {
+		comedi_error(dev, "illegal caldac channel");
+		return -1;
+	}
+
+	if (value == devpriv->caldac_value[address])
+		return 1;
+
+	devpriv->caldac_value[address] = value;
+
+	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
+				    bitstream_length);
+
+	udelay(caldac_8800_udelay);
+	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
+	     devpriv->control_status + CALIBRATION_REG);
+	udelay(caldac_8800_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 1;
+}
+
 static int caldac_write_insn(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
@@ -1456,54 +1502,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void write_calibration_bitstream(struct comedi_device *dev,
-					unsigned int register_bits,
-					unsigned int bitstream,
-					unsigned int bitstream_length)
-{
-	static const int write_delay = 1;
-	unsigned int bit;
-
-	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
-		if (bitstream & bit)
-			register_bits |= SERIAL_DATA_IN_BIT;
-		else
-			register_bits &= ~SERIAL_DATA_IN_BIT;
-		udelay(write_delay);
-		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
-	}
-}
-
-static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-			     uint8_t value)
-{
-	static const int num_caldac_channels = 8;
-	static const int bitstream_length = 11;
-	unsigned int bitstream = ((address & 0x7) << 8) | value;
-	static const int caldac_8800_udelay = 1;
-
-	if (address >= num_caldac_channels) {
-		comedi_error(dev, "illegal caldac channel");
-		return -1;
-	}
-
-	if (value == devpriv->caldac_value[address])
-		return 1;
-
-	devpriv->caldac_value[address] = value;
-
-	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
-				    bitstream_length);
-
-	udelay(caldac_8800_udelay);
-	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
-	     devpriv->control_status + CALIBRATION_REG);
-	udelay(caldac_8800_udelay);
-	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
-
-	return 1;
-}
-
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 {
 	static const int bitstream_length = 7;

commit bb03694323561da47fb6a15d977a0b5275134cdd
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:49:58 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 6
    
    Move the cb_pcidas_load_counters function to remove the need for
    the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 24574082691e..1e5616e15fb5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,8 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-				    int round_flags);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value);
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
@@ -915,6 +913,20 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
+				    int rounding_flags)
+{
+	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
+				       &(devpriv->divisor2), ns,
+				       rounding_flags & TRIG_ROUND_MASK);
+
+	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
+	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
+		   devpriv->divisor1, 2);
+	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
+		   devpriv->divisor2, 2);
+}
+
 static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -1444,20 +1456,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-				    int rounding_flags)
-{
-	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-				       &(devpriv->divisor2), ns,
-				       rounding_flags & TRIG_ROUND_MASK);
-
-	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
-	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
-		   devpriv->divisor1, 2);
-	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
-		   devpriv->divisor2, 2);
-}
-
 static void write_calibration_bitstream(struct comedi_device *dev,
 					unsigned int register_bits,
 					unsigned int bitstream,

commit 0aa2030467e4dfad59aef42211728221a973c329
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:49:22 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 5
    
    Move the cb_pcida_ao_cancel function to remove the need for
    the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index fa3ed0e01b33..24574082691e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,8 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int cb_pcidas_ao_cancel(struct comedi_device *dev,
-			       struct comedi_subdevice *s);
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 				    int round_flags);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
@@ -1262,6 +1260,25 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+/* cancel analog output command */
+static int cb_pcidas_ao_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+	/*  disable interrupts */
+	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
+	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+
+	/*  disable output */
+	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return 0;
+}
+
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
@@ -1427,25 +1444,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* cancel analog output command */
-static int cb_pcidas_ao_cancel(struct comedi_device *dev,
-			       struct comedi_subdevice *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	/*  disable interrupts */
-	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
-	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
-
-	/*  disable output */
-	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	return 0;
-}
-
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 				    int rounding_flags)
 {

commit 9a0f7631f26cd9d9fc9f8fd1513427e13912a63c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:48:43 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 4
    
    Move the cb_pcida_cancel function to remove the need for
    the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 584f85b434e8..fa3ed0e01b33 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,8 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int cb_pcidas_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
 static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s);
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
@@ -1128,6 +1126,26 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+/* cancel analog input command */
+static int cb_pcidas_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+	/*  disable interrupts */
+	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
+	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	/*  disable start trigger source and burst mode */
+	outw(0, devpriv->control_status + TRIG_CONTSTAT);
+	/*  software pacer source */
+	outw(0, devpriv->control_status + ADCMUX_CONT);
+
+	return 0;
+}
+
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *s,
 				unsigned int trig_num)
@@ -1409,26 +1427,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-/* cancel analog input command */
-static int cb_pcidas_cancel(struct comedi_device *dev,
-			    struct comedi_subdevice *s)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev->spinlock, flags);
-	/*  disable interrupts */
-	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
-	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	/*  disable start trigger source and burst mode */
-	outw(0, devpriv->control_status + TRIG_CONTSTAT);
-	/*  software pacer source */
-	outw(0, devpriv->control_status + ADCMUX_CONT);
-
-	return 0;
-}
-
 /* cancel analog output command */
 static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s)

commit 9e11d05f89b44e5f2672a74e5fe0f7eced7a4cad
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:48:05 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 3
    
    Move the handle_ao_interrupt function to remove the need for
    the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e94a6b16a38b..584f85b434e8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,7 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
 static int cb_pcidas_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
 static int cb_pcidas_ao_cancel(struct comedi_device *dev,
@@ -1245,6 +1244,61 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	return 0;
 }
 
+static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
+{
+	struct comedi_subdevice *s = dev->write_subdev;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &async->cmd;
+	unsigned int half_fifo = thisboard->fifo_size / 2;
+	unsigned int num_points;
+	unsigned long flags;
+
+	async->events = 0;
+
+	if (status & DAEMI) {
+		/*  clear dac empty interrupt latch */
+		spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | DAEMI,
+		     devpriv->control_status + INT_ADCFIFO);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
+		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
+			if (cmd->stop_src == TRIG_NONE ||
+			    (cmd->stop_src == TRIG_COUNT
+			     && devpriv->ao_count)) {
+				comedi_error(dev, "dac fifo underflow");
+				cb_pcidas_ao_cancel(dev, s);
+				async->events |= COMEDI_CB_ERROR;
+			}
+			async->events |= COMEDI_CB_EOA;
+		}
+	} else if (status & DAHFI) {
+		unsigned int num_bytes;
+
+		/*  figure out how many points we are writing to fifo */
+		num_points = half_fifo;
+		if (cmd->stop_src == TRIG_COUNT &&
+		    devpriv->ao_count < num_points)
+			num_points = devpriv->ao_count;
+		num_bytes =
+		    cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+					       num_points * sizeof(short));
+		num_points = num_bytes / sizeof(short);
+
+		if (async->cmd.stop_src == TRIG_COUNT)
+			devpriv->ao_count -= num_points;
+		/*  write data to board's fifo */
+		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
+		      num_points);
+		/*  clear half-full interrupt latch */
+		spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | DAHFI,
+		     devpriv->control_status + INT_ADCFIFO);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
+
+	comedi_event(dev, s);
+}
+
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *)d;
@@ -1355,61 +1409,6 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
-{
-	struct comedi_subdevice *s = dev->write_subdev;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &async->cmd;
-	unsigned int half_fifo = thisboard->fifo_size / 2;
-	unsigned int num_points;
-	unsigned long flags;
-
-	async->events = 0;
-
-	if (status & DAEMI) {
-		/*  clear dac empty interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | DAEMI,
-		     devpriv->control_status + INT_ADCFIFO);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
-			if (cmd->stop_src == TRIG_NONE ||
-			    (cmd->stop_src == TRIG_COUNT
-			     && devpriv->ao_count)) {
-				comedi_error(dev, "dac fifo underflow");
-				cb_pcidas_ao_cancel(dev, s);
-				async->events |= COMEDI_CB_ERROR;
-			}
-			async->events |= COMEDI_CB_EOA;
-		}
-	} else if (status & DAHFI) {
-		unsigned int num_bytes;
-
-		/*  figure out how many points we are writing to fifo */
-		num_points = half_fifo;
-		if (cmd->stop_src == TRIG_COUNT &&
-		    devpriv->ao_count < num_points)
-			num_points = devpriv->ao_count;
-		num_bytes =
-		    cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-					       num_points * sizeof(short));
-		num_points = num_bytes / sizeof(short);
-
-		if (async->cmd.stop_src == TRIG_COUNT)
-			devpriv->ao_count -= num_points;
-		/*  write data to board's fifo */
-		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
-		      num_points);
-		/*  clear half-full interrupt latch */
-		spin_lock_irqsave(&dev->spinlock, flags);
-		outw(devpriv->adc_fifo_bits | DAHFI,
-		     devpriv->control_status + INT_ADCFIFO);
-		spin_unlock_irqrestore(&dev->spinlock, flags);
-	}
-
-	comedi_event(dev, s);
-}
-
 /* cancel analog input command */
 static int cb_pcidas_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s)

commit 1706fcc18b8e27f2e8895b6ced83112ab8a0ad20
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:47:28 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 2
    
    Move the cb_pcidas_ao_inttrig function to remove the need for
    the forward declaration.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 5460410e6c7c..e94a6b16a38b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,9 +447,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
-				struct comedi_subdevice *subdev,
-				unsigned int trig_num);
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
 static int cb_pcidas_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
@@ -1132,6 +1129,56 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
 	return 0;
 }
 
+static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int trig_num)
+{
+	unsigned int num_bytes, num_points = thisboard->fifo_size;
+	struct comedi_async *async = s->async;
+	struct comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	/*  load up fifo */
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)
+		num_points = devpriv->ao_count;
+
+	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+					       num_points * sizeof(short));
+	num_points = num_bytes / sizeof(short);
+
+	if (cmd->stop_src == TRIG_COUNT)
+		devpriv->ao_count -= num_points;
+	/*  write data to board's fifo */
+	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
+
+	/*  enable dac half-full and empty interrupts */
+	spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
+#ifdef CB_PCIDAS_DEBUG
+	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
+		devpriv->adc_fifo_bits);
+#endif
+	/*  enable and clear interrupts */
+	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
+	     devpriv->control_status + INT_ADCFIFO);
+
+	/*  start dac */
+	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+#ifdef CB_PCIDAS_DEBUG
+	dev_dbg(dev->class_dev, "sent 0x%x to dac control\n",
+		devpriv->ao_control_bits);
+#endif
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	async->inttrig = NULL;
+
+	return 0;
+}
+
 static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 			    struct comedi_subdevice *s)
 {
@@ -1198,56 +1245,6 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 	return 0;
 }
 
-static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				unsigned int trig_num)
-{
-	unsigned int num_bytes, num_points = thisboard->fifo_size;
-	struct comedi_async *async = s->async;
-	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned long flags;
-
-	if (trig_num != 0)
-		return -EINVAL;
-
-	/*  load up fifo */
-	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)
-		num_points = devpriv->ao_count;
-
-	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-					       num_points * sizeof(short));
-	num_points = num_bytes / sizeof(short);
-
-	if (cmd->stop_src == TRIG_COUNT)
-		devpriv->ao_count -= num_points;
-	/*  write data to board's fifo */
-	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
-
-	/*  enable dac half-full and empty interrupts */
-	spin_lock_irqsave(&dev->spinlock, flags);
-	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
-		devpriv->adc_fifo_bits);
-#endif
-	/*  enable and clear interrupts */
-	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
-	     devpriv->control_status + INT_ADCFIFO);
-
-	/*  start dac */
-	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
-	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-#ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->class_dev, "sent 0x%x to dac control\n",
-		devpriv->ao_control_bits);
-#endif
-	spin_unlock_irqrestore(&dev->spinlock, flags);
-
-	async->inttrig = NULL;
-
-	return 0;
-}
-
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *)d;

commit e74f209ca99568865dfca5a456a114734cb7ef8c
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 26 17:46:44 2012 -0700

    staging: comedi: cb_pcidas: remove forward declarations 1
    
    Move the attach/detach functions to remove the need for some
    of the forward declarations.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e2bf22270561..5460410e6c7c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -447,37 +447,9 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-			  struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
-				     struct comedi_subdevice *s,
-				     struct comedi_insn *insn,
-				     unsigned int *data);
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
-				   struct comedi_subdevice *s,
-				   struct comedi_insn *insn,
-				   unsigned int *data);
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
-				      struct comedi_subdevice *s,
-				      struct comedi_insn *insn,
-				      unsigned int *data);
-static int cb_pcidas_ai_cmd(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
-static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_cmd *cmd);
-static int cb_pcidas_ao_cmd(struct comedi_device *dev,
-			    struct comedi_subdevice *s);
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *subdev,
 				unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
-				struct comedi_subdevice *s,
-				struct comedi_cmd *cmd);
-static irqreturn_t cb_pcidas_interrupt(int irq, void *d);
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
 static int cb_pcidas_cancel(struct comedi_device *dev,
 			    struct comedi_subdevice *s);
@@ -485,30 +457,6 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 			       struct comedi_subdevice *s);
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 				    int round_flags);
-static int eeprom_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int caldac_read_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
-static int caldac_write_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
-static int trimpot_read_insn(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_trimpot_write(struct comedi_device *dev,
-				   unsigned int channel, unsigned int value);
-static int trimpot_write_insn(struct comedi_device *dev,
-			      struct comedi_subdevice *s,
-			      struct comedi_insn *insn, unsigned int *data);
-static int dac08_read_insn(struct comedi_device *dev,
-			   struct comedi_subdevice *s, struct comedi_insn *insn,
-			   unsigned int *data);
-static int dac08_write(struct comedi_device *dev, unsigned int value);
-static int dac08_write_insn(struct comedi_device *dev,
-			    struct comedi_subdevice *s,
-			    struct comedi_insn *insn, unsigned int *data);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 			     uint8_t value);
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
@@ -522,229 +470,6 @@ static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }
 
-/*
- * Attach is called by the Comedi core to configure the driver
- * for a particular board.
- */
-static int cb_pcidas_attach(struct comedi_device *dev,
-			    struct comedi_devconfig *it)
-{
-	struct comedi_subdevice *s;
-	struct pci_dev *pcidev = NULL;
-	int index;
-	int i;
-	int ret;
-
-/*
- * Allocate the private structure area.
- */
-	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
-		return -ENOMEM;
-
-/*
- * Probe the device to determine what device in the series it is.
- */
-
-	for_each_pci_dev(pcidev) {
-		/*  is it not a computer boards card? */
-		if (pcidev->vendor != PCI_VENDOR_ID_CB)
-			continue;
-		/*  loop through cards supported by this driver */
-		for (index = 0; index < ARRAY_SIZE(cb_pcidas_boards); index++) {
-			if (cb_pcidas_boards[index].device_id != pcidev->device)
-				continue;
-			/*  was a particular bus/slot requested? */
-			if (it->options[0] || it->options[1]) {
-				/*  are we on the wrong bus/slot? */
-				if (pcidev->bus->number != it->options[0] ||
-				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
-					continue;
-				}
-			}
-			devpriv->pci_dev = pcidev;
-			dev->board_ptr = cb_pcidas_boards + index;
-			goto found;
-		}
-	}
-
-	dev_err(dev->class_dev,
-		"No supported ComputerBoards/MeasurementComputing card found on requested position\n");
-	return -EIO;
-
-found:
-
-	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
-		cb_pcidas_boards[index].name, pcidev->bus->number,
-		PCI_SLOT(pcidev->devfn));
-
-	/*
-	 * Enable PCI device and reserve I/O ports.
-	 */
-	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
-		dev_err(dev->class_dev,
-			"Failed to enable PCI device and request regions\n");
-		return -EIO;
-	}
-	/*
-	 * Initialize devpriv->control_status and devpriv->adc_fifo to point to
-	 * their base address.
-	 */
-	devpriv->s5933_config =
-	    pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
-	devpriv->control_status =
-	    pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
-	devpriv->adc_fifo =
-	    pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
-	devpriv->pacer_counter_dio =
-	    pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
-	if (thisboard->ao_nchan) {
-		devpriv->ao_registers =
-		    pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
-	}
-	/*  disable and clear interrupts on amcc s5933 */
-	outl(INTCSR_INBOX_INTR_STATUS,
-	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-
-	/*  get irq */
-	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
-			IRQF_SHARED, "cb_pcidas", dev)) {
-		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
-			devpriv->pci_dev->irq);
-		return -EINVAL;
-	}
-	dev->irq = devpriv->pci_dev->irq;
-
-	/* Initialize dev->board_name */
-	dev->board_name = thisboard->name;
-
-	ret = comedi_alloc_subdevices(dev, 7);
-	if (ret)
-		return ret;
-
-	s = dev->subdevices + 0;
-	/* analog input subdevice */
-	dev->read_subdev = s;
-	s->type = COMEDI_SUBD_AI;
-	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
-	/* WARNING: Number of inputs in differential mode is ignored */
-	s->n_chan = thisboard->ai_se_chans;
-	s->len_chanlist = thisboard->ai_se_chans;
-	s->maxdata = (1 << thisboard->ai_bits) - 1;
-	s->range_table = thisboard->ranges;
-	s->insn_read = cb_pcidas_ai_rinsn;
-	s->insn_config = ai_config_insn;
-	s->do_cmd = cb_pcidas_ai_cmd;
-	s->do_cmdtest = cb_pcidas_ai_cmdtest;
-	s->cancel = cb_pcidas_cancel;
-
-	/* analog output subdevice */
-	s = dev->subdevices + 1;
-	if (thisboard->ao_nchan) {
-		s->type = COMEDI_SUBD_AO;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
-		s->n_chan = thisboard->ao_nchan;
-		/*  analog out resolution is the same as analog input resolution, so use ai_bits */
-		s->maxdata = (1 << thisboard->ai_bits) - 1;
-		s->range_table = &cb_pcidas_ao_ranges;
-		s->insn_read = cb_pcidas_ao_readback_insn;
-		if (thisboard->has_ao_fifo) {
-			dev->write_subdev = s;
-			s->subdev_flags |= SDF_CMD_WRITE;
-			s->insn_write = cb_pcidas_ao_fifo_winsn;
-			s->do_cmdtest = cb_pcidas_ao_cmdtest;
-			s->do_cmd = cb_pcidas_ao_cmd;
-			s->cancel = cb_pcidas_ao_cancel;
-		} else {
-			s->insn_write = cb_pcidas_ao_nofifo_winsn;
-		}
-	} else {
-		s->type = COMEDI_SUBD_UNUSED;
-	}
-
-	/* 8255 */
-	s = dev->subdevices + 2;
-	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);
-
-	/*  serial EEPROM, */
-	s = dev->subdevices + 3;
-	s->type = COMEDI_SUBD_MEMORY;
-	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
-	s->n_chan = 256;
-	s->maxdata = 0xff;
-	s->insn_read = eeprom_read_insn;
-
-	/*  8800 caldac */
-	s = dev->subdevices + 4;
-	s->type = COMEDI_SUBD_CALIB;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	s->n_chan = NUM_CHANNELS_8800;
-	s->maxdata = 0xff;
-	s->insn_read = caldac_read_insn;
-	s->insn_write = caldac_write_insn;
-	for (i = 0; i < s->n_chan; i++)
-		caldac_8800_write(dev, i, s->maxdata / 2);
-
-	/*  trim potentiometer */
-	s = dev->subdevices + 5;
-	s->type = COMEDI_SUBD_CALIB;
-	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-	if (thisboard->trimpot == AD7376) {
-		s->n_chan = NUM_CHANNELS_7376;
-		s->maxdata = 0x7f;
-	} else {
-		s->n_chan = NUM_CHANNELS_8402;
-		s->maxdata = 0xff;
-	}
-	s->insn_read = trimpot_read_insn;
-	s->insn_write = trimpot_write_insn;
-	for (i = 0; i < s->n_chan; i++)
-		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
-
-	/*  dac08 caldac */
-	s = dev->subdevices + 6;
-	if (thisboard->has_dac08) {
-		s->type = COMEDI_SUBD_CALIB;
-		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
-		s->n_chan = NUM_CHANNELS_DAC08;
-		s->insn_read = dac08_read_insn;
-		s->insn_write = dac08_write_insn;
-		s->maxdata = 0xff;
-		dac08_write(dev, s->maxdata / 2);
-	} else
-		s->type = COMEDI_SUBD_UNUSED;
-
-	/*  make sure mailbox 4 is empty */
-	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
-	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
-	devpriv->s5933_intcsr_bits =
-	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
-	    INTCSR_INBOX_FULL_INT;
-	/*  clear and enable interrupt on amcc s5933 */
-	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-
-	return 1;
-}
-
-static void cb_pcidas_detach(struct comedi_device *dev)
-{
-	if (devpriv) {
-		if (devpriv->s5933_config) {
-			outl(INTCSR_INBOX_INTR_STATUS,
-			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-		}
-	}
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-	if (dev->subdevices)
-		subdev_8255_cleanup(dev, dev->subdevices + 2);
-	if (devpriv && devpriv->pci_dev) {
-		if (devpriv->s5933_config)
-			comedi_pci_disable(devpriv->pci_dev);
-		pci_dev_put(devpriv->pci_dev);
-	}
-}
-
 /*
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
@@ -1872,6 +1597,225 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
 	return 0;
 }
 
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
+{
+	struct comedi_subdevice *s;
+	struct pci_dev *pcidev = NULL;
+	int index;
+	int i;
+	int ret;
+
+/*
+ * Allocate the private structure area.
+ */
+	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
+		return -ENOMEM;
+
+/*
+ * Probe the device to determine what device in the series it is.
+ */
+
+	for_each_pci_dev(pcidev) {
+		/*  is it not a computer boards card? */
+		if (pcidev->vendor != PCI_VENDOR_ID_CB)
+			continue;
+		/*  loop through cards supported by this driver */
+		for (index = 0; index < ARRAY_SIZE(cb_pcidas_boards); index++) {
+			if (cb_pcidas_boards[index].device_id != pcidev->device)
+				continue;
+			/*  was a particular bus/slot requested? */
+			if (it->options[0] || it->options[1]) {
+				/*  are we on the wrong bus/slot? */
+				if (pcidev->bus->number != it->options[0] ||
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
+					continue;
+				}
+			}
+			devpriv->pci_dev = pcidev;
+			dev->board_ptr = cb_pcidas_boards + index;
+			goto found;
+		}
+	}
+
+	dev_err(dev->class_dev,
+		"No supported ComputerBoards/MeasurementComputing card found on requested position\n");
+	return -EIO;
+
+found:
+
+	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
+		cb_pcidas_boards[index].name, pcidev->bus->number,
+		PCI_SLOT(pcidev->devfn));
+
+	/*
+	 * Enable PCI device and reserve I/O ports.
+	 */
+	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
+		dev_err(dev->class_dev,
+			"Failed to enable PCI device and request regions\n");
+		return -EIO;
+	}
+	/*
+	 * Initialize devpriv->control_status and devpriv->adc_fifo to point to
+	 * their base address.
+	 */
+	devpriv->s5933_config =
+	    pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
+	devpriv->control_status =
+	    pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
+	devpriv->adc_fifo =
+	    pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
+	devpriv->pacer_counter_dio =
+	    pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
+	if (thisboard->ao_nchan) {
+		devpriv->ao_registers =
+		    pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
+	}
+	/*  disable and clear interrupts on amcc s5933 */
+	outl(INTCSR_INBOX_INTR_STATUS,
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+
+	/*  get irq */
+	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
+			IRQF_SHARED, "cb_pcidas", dev)) {
+		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
+			devpriv->pci_dev->irq);
+		return -EINVAL;
+	}
+	dev->irq = devpriv->pci_dev->irq;
+
+	/* Initialize dev->board_name */
+	dev->board_name = thisboard->name;
+
+	ret = comedi_alloc_subdevices(dev, 7);
+	if (ret)
+		return ret;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	/* WARNING: Number of inputs in differential mode is ignored */
+	s->n_chan = thisboard->ai_se_chans;
+	s->len_chanlist = thisboard->ai_se_chans;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ranges;
+	s->insn_read = cb_pcidas_ai_rinsn;
+	s->insn_config = ai_config_insn;
+	s->do_cmd = cb_pcidas_ai_cmd;
+	s->do_cmdtest = cb_pcidas_ai_cmdtest;
+	s->cancel = cb_pcidas_cancel;
+
+	/* analog output subdevice */
+	s = dev->subdevices + 1;
+	if (thisboard->ao_nchan) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = thisboard->ao_nchan;
+		/*  analog out resolution is the same as analog input resolution, so use ai_bits */
+		s->maxdata = (1 << thisboard->ai_bits) - 1;
+		s->range_table = &cb_pcidas_ao_ranges;
+		s->insn_read = cb_pcidas_ao_readback_insn;
+		if (thisboard->has_ao_fifo) {
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->insn_write = cb_pcidas_ao_fifo_winsn;
+			s->do_cmdtest = cb_pcidas_ao_cmdtest;
+			s->do_cmd = cb_pcidas_ao_cmd;
+			s->cancel = cb_pcidas_ao_cancel;
+		} else {
+			s->insn_write = cb_pcidas_ao_nofifo_winsn;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* 8255 */
+	s = dev->subdevices + 2;
+	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);
+
+	/*  serial EEPROM, */
+	s = dev->subdevices + 3;
+	s->type = COMEDI_SUBD_MEMORY;
+	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+	s->n_chan = 256;
+	s->maxdata = 0xff;
+	s->insn_read = eeprom_read_insn;
+
+	/*  8800 caldac */
+	s = dev->subdevices + 4;
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = NUM_CHANNELS_8800;
+	s->maxdata = 0xff;
+	s->insn_read = caldac_read_insn;
+	s->insn_write = caldac_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		caldac_8800_write(dev, i, s->maxdata / 2);
+
+	/*  trim potentiometer */
+	s = dev->subdevices + 5;
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	if (thisboard->trimpot == AD7376) {
+		s->n_chan = NUM_CHANNELS_7376;
+		s->maxdata = 0x7f;
+	} else {
+		s->n_chan = NUM_CHANNELS_8402;
+		s->maxdata = 0xff;
+	}
+	s->insn_read = trimpot_read_insn;
+	s->insn_write = trimpot_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
+
+	/*  dac08 caldac */
+	s = dev->subdevices + 6;
+	if (thisboard->has_dac08) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = NUM_CHANNELS_DAC08;
+		s->insn_read = dac08_read_insn;
+		s->insn_write = dac08_write_insn;
+		s->maxdata = 0xff;
+		dac08_write(dev, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	/*  make sure mailbox 4 is empty */
+	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
+	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
+	devpriv->s5933_intcsr_bits =
+	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
+	    INTCSR_INBOX_FULL_INT;
+	/*  clear and enable interrupt on amcc s5933 */
+	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+
+	return 1;
+}
+
+static void cb_pcidas_detach(struct comedi_device *dev)
+{
+	if (devpriv) {
+		if (devpriv->s5933_config) {
+			outl(INTCSR_INBOX_INTR_STATUS,
+			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+		}
+	}
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 2);
+	if (devpriv && devpriv->pci_dev) {
+		if (devpriv->s5933_config)
+			comedi_pci_disable(devpriv->pci_dev);
+		pci_dev_put(devpriv->pci_dev);
+	}
+}
+
 static struct comedi_driver cb_pcidas_driver = {
 	.driver_name	= "cb_pcidas",
 	.module		= THIS_MODULE,

commit f41ad6675f2d5705a0fc1e210af8eb4a27dbacb4
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Mon Jun 18 14:05:34 2012 +0100

    staging: comedi: change device used in dev_...() calls
    
    A previous set of patches by Ravishankar Karkala Mallikarjunayya
    replaced a load of printk() calls with dev_info(), dev_err(), etc.
    Unfortunately, these used the 'struct device *hw_dev' member of 'struct
    comedi_device') as the first parameter of these dev_...() calls, but
    that pointer is usually NULL, so the kernel log messages come out a bit
    wrong (they contain the phrase "(NULL device *)").
    
    Use the 'struct device *class_dev' member of 'struct comedi_device'
    instead for these dev_...() calls.  It will be non-NULL and somewhat
    meaningful to users.  It's also consistent with those comedi drivers
    that already use the class_dev member in their dev_...() calls.
    
    Some of the messages included the format "comedi%d" with the minor
    device number used for the "%d".  This is now redundant as it will be
    the same as the dev_name() part of the kernel log message produced by
    the dev_...() calls.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2ca3fa0fc776..e2bf22270561 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -567,12 +567,13 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		}
 	}
 
-	dev_err(dev->hw_dev, "No supported ComputerBoards/MeasurementComputing card found on requested position\n");
+	dev_err(dev->class_dev,
+		"No supported ComputerBoards/MeasurementComputing card found on requested position\n");
 	return -EIO;
 
 found:
 
-	dev_dbg(dev->hw_dev, "Found %s on bus %i, slot %i\n",
+	dev_dbg(dev->class_dev, "Found %s on bus %i, slot %i\n",
 		cb_pcidas_boards[index].name, pcidev->bus->number,
 		PCI_SLOT(pcidev->devfn));
 
@@ -580,7 +581,8 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	 * Enable PCI device and reserve I/O ports.
 	 */
 	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
-		dev_err(dev->hw_dev, "Failed to enable PCI device and request regions\n");
+		dev_err(dev->class_dev,
+			"Failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	/*
@@ -606,7 +608,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	/*  get irq */
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
-		dev_dbg(dev->hw_dev, "unable to allocate irq %d\n",
+		dev_dbg(dev->class_dev, "unable to allocate irq %d\n",
 			devpriv->pci_dev->irq);
 		return -EINVAL;
 	}
@@ -807,7 +809,7 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 	unsigned int source = data[1];
 
 	if (source >= num_calibration_sources) {
-		dev_err(dev->hw_dev, "invalid calibration source: %i\n",
+		dev_err(dev->class_dev, "invalid calibration source: %i\n",
 			source);
 		return -EINVAL;
 	}
@@ -1229,7 +1231,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to adcmux control\n", bits);
+	dev_dbg(dev->class_dev, "sent 0x%x to adcmux control\n", bits);
 #endif
 
 	/*  load counters */
@@ -1256,7 +1258,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "comedi: adc_fifo_bits are 0x%x\n",
+	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
 		devpriv->adc_fifo_bits);
 #endif
 	/*  enable (and clear) interrupts */
@@ -1283,7 +1285,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= BURSTE;
 	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to trig control\n", bits);
+	dev_dbg(dev->class_dev, "sent 0x%x to trig control\n", bits);
 #endif
 
 	return 0;
@@ -1500,7 +1502,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "comedi: adc_fifo_bits are 0x%x\n",
+	dev_dbg(dev->class_dev, "adc_fifo_bits are 0x%x\n",
 		devpriv->adc_fifo_bits);
 #endif
 	/*  enable and clear interrupts */
@@ -1511,7 +1513,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to dac control\n",
+	dev_dbg(dev->class_dev, "sent 0x%x to dac control\n",
 		devpriv->ao_control_bits);
 #endif
 	spin_unlock_irqrestore(&dev->spinlock, flags);
@@ -1540,8 +1542,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-	dev_dbg(dev->hw_dev, "intcsr 0x%x\n", s5933_status);
-	dev_dbg(dev->hw_dev, "mbef 0x%x\n",
+	dev_dbg(dev->class_dev, "intcsr 0x%x\n", s5933_status);
+	dev_dbg(dev->class_dev, "mbef 0x%x\n",
 		inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
 #endif
 

commit 8b6c56949ffa83dbc2a6e8fa3f98b10a19372207
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:33 2012 -0700

    staging: comedi: propogate error code from comedi_alloc_subdevices
    
    comedi_alloc_subdevices can fail with -EINVAL or -ENOMEM. When it
    does fail make sure to pass the proper error code back.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbott@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index e1bd99a950e4..2ca3fa0fc776 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -533,6 +533,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	struct pci_dev *pcidev = NULL;
 	int index;
 	int i;
+	int ret;
 
 /*
  * Allocate the private structure area.
@@ -614,8 +615,9 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
-	if (comedi_alloc_subdevices(dev, 7) < 0)
-		return -ENOMEM;
+	ret = comedi_alloc_subdevices(dev, 7);
+	if (ret)
+		return ret;
 
 	s = dev->subdevices + 0;
 	/* analog input subdevice */

commit eea6838b1206b0ac90110f1a6f58e101aa496e99
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jun 12 11:59:15 2012 -0700

    staging: comedi: remove the "Allocate the subdevice..." comments
    
    These comments are redundant. The function name 'comedi_alloc_subdevices'
    provides this information.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <ian@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 435f3aaedf88..e1bd99a950e4 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -614,9 +614,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
-/*
- * Allocate the subdevice structures.
- */
 	if (comedi_alloc_subdevices(dev, 7) < 0)
 		return -ENOMEM;
 

commit 2f0b9d082e5d0056a3aca4be038483a564849196
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon Jun 11 17:45:15 2012 -0700

    staging: comedi: export alloc_subdevices as comedi_alloc_subdevices
    
    Move the inline alloc_subdevices() function from comedidev.h
    to drivers.c and rename it to comedi_alloc_subdevices(). The
    function is large enough to warrant being an exported symbol
    rather than being an inline in every driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 074feeef829b..435f3aaedf88 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -617,7 +617,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 /*
  * Allocate the subdevice structures.
  */
-	if (alloc_subdevices(dev, 7) < 0)
+	if (comedi_alloc_subdevices(dev, 7) < 0)
 		return -ENOMEM;
 
 	s = dev->subdevices + 0;

commit bc04bec0e0c982dfc90e206ea51f19bd650ccee2
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sun May 27 01:45:19 2012 +0900

    staging: comedi: Fix typo in comedi
    
    Correct spelling typo in comments within staging/comedi.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7f88d08ee579..074feeef829b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -57,8 +57,8 @@ range and aref.
 AI Triggering:
    For start_src == TRIG_EXT, the A/D EXTERNAL TRIGGER IN (pin 45) is used.
    For 1602 series, the start_arg is interpreted as follows:
-     start_arg == 0                   => gated triger (level high)
-     start_arg == CR_INVERT           => gated triger (level low)
+     start_arg == 0                   => gated trigger (level high)
+     start_arg == CR_INVERT           => gated trigger (level low)
      start_arg == CR_EDGE             => Rising edge
      start_arg == CR_EDGE | CR_INVERT => Falling edge
    For the other boards the trigger will be done on rising edge

commit 55c03cff7fd73349473cc0a964df9d55b312dbbc
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Mon May 21 17:12:12 2012 -0700

    staging: comedi: remove private header comedi_pci.h
    
    Remove the private header, comedi_pci.h, by moving the two
    helper functions into divers.c and providing the prototypes
    in comedidev.h.
    
    This allows the comedi_pci_enable/disable helper functions
    to be shared instead of having an inline version in every
    comedi pci driver.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index ee9e084bb96c..7f88d08ee579 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -77,7 +77,6 @@ analog triggering on 1602 series
 #include "8253.h"
 #include "8255.h"
 #include "amcc_s5933.h"
-#include "comedi_pci.h"
 #include "comedi_fc.h"
 
 #undef CB_PCIDAS_DEBUG		/*  disable debugging code */

commit 484ecc95d9cdfa8b2f7029e2f3409cf078aed4ab
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu May 17 17:11:14 2012 -0700

    staging: comedi: cleanup all the comedi_driver 'detach' functions
    
    1. Change the return type from int to void
    
    All the detach functions, except for the comedi usb drivers, simply
    return success (0). Plus, the return code is never checked in the
    comedi core.
    
    The comedi usb drivers do return error codes but the conditions can
    never happen.
    
    The first check is:
    
            if (!dev)
                    return -EFAULT;
    
    This checks that the passed comedi_device pointer is valid. The detach
    function itself is called using this pointer so it MUST always be valid
    or there is a bug in the core:
    
            if (dev->driver)
                    dev->driver->detach(dev);
    
    And the second check:
    
            usb = dev->private;
            if (!usb)
                    return -EFAULT;
    
    The dev->private pointer is setup in the attach function to point to the
    probed usb device. This value could be NULL if the attach fails. But,
    since the comedi core is going to unload the driver anyway and does not
    check for errors there is no gain by returning one.
    
    After removing these checks from the comedi usb drivers the detach
    functions required a bit of cleanup.
    
    2. Remove all the printk noise in the detach functions
    
    All of the printk output is really just noise. The user did a rmmod to
    unload the driver, we really don't need to tell them about it.
    
    Also, some of the messages are output using:
    
            dev_dbg(dev->hw_dev, ...
    or
            dev_info(dev->hw_dev, ...
    
    Unfortunately the hw_dev value is only used by drivers that are doing
    DMA. For most drivers this variable is going to be NULL so the output
    is not going to work as expected.
    
    3. Refactor a couple static 'free_resource' functions into the detach
       functions.
    
    The 'free_resource' function is only being called by the detach and it
    makes more sense to just absorb the code.
    
    4. Remove a couple unnecessary braces for single statements.
    
    5. Remove unnecessary comments.
    
    Most of the comedi drivers appear to be based on the comedi skel driver
    and have the comments from that driver included. These comments make
    sense in the skel driver for reference but they don't need to be in any
    of the actual drivers.
    
    6. Remove all the extra whitespace.
    
    It's not needed to make the functions any more readable.
    
    7. Remove the now unused 'attached_successfully' variable in the
       cb_pcimdda driver.
    
    This variable was only used to conditionally output some driver noise
    during the detach. Since all the printk's have been removed this
    variable is no longer necessary.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7e119104480f..ee9e084bb96c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -726,26 +726,12 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	return 1;
 }
 
-/*
- * cb_pcidas_detach is called to deconfigure a device.  It should deallocate
- * resources.
- * This function is also called when _attach() fails, so it should be
- * careful not to release resources that were not necessarily
- * allocated by _attach().  dev->private and dev->subdevices are
- * deallocated automatically by the core.
- */
-static int cb_pcidas_detach(struct comedi_device *dev)
+static void cb_pcidas_detach(struct comedi_device *dev)
 {
-
 	if (devpriv) {
 		if (devpriv->s5933_config) {
-			/*  disable and clear interrupts on amcc s5933 */
 			outl(INTCSR_INBOX_INTR_STATUS,
 			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
-#ifdef CB_PCIDAS_DEBUG
-			dev_dbg(dev->hw_dev, "detaching, incsr is 0x%x\n",
-				inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));
-#endif
 		}
 	}
 	if (dev->irq)
@@ -757,8 +743,6 @@ static int cb_pcidas_detach(struct comedi_device *dev)
 			comedi_pci_disable(devpriv->pci_dev);
 		pci_dev_put(devpriv->pci_dev);
 	}
-
-	return 0;
 }
 
 /*

commit 715b2284cdcd6d7f5e1eea779ea9316b40b9d6f1
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue May 15 14:48:04 2012 -0700

    staging: comedi: refactor cb_pcidas driver and use module_comedi_pci_driver
    
    Move the module_init/module_exit routines and the associated
    struct comedi_drive and struct pci_driver to the end of the
    source. This is more typical of how other drivers are written
    and removes the need for the forward declarations.
    
    Convert the driver to use the module_comedi_pci_driver() macro
    which makes the code smaller and a bit simpler.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f1ad286a0306..7e119104480f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -405,20 +405,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 },
 };
 
-static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0001) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x000f) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0010) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0019) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001c) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x004c) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001a) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001b) },
-	{ 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
-
 /*
  * Useful for shorthand access to the particular board structure
  */
@@ -462,22 +448,6 @@ struct cb_pcidas_private {
  */
 #define devpriv ((struct cb_pcidas_private *)dev->private)
 
-/*
- * The struct comedi_driver structure tells the Comedi core module
- * which functions to call to configure/deconfigure (attach/detach)
- * the board, and also about the kernel module that contains
- * the device code.
- */
-static int cb_pcidas_attach(struct comedi_device *dev,
-			    struct comedi_devconfig *it);
-static int cb_pcidas_detach(struct comedi_device *dev);
-static struct comedi_driver driver_cb_pcidas = {
-	.driver_name = "cb_pcidas",
-	.module = THIS_MODULE,
-	.attach = cb_pcidas_attach,
-	.detach = cb_pcidas_detach,
-};
-
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
 			      struct comedi_subdevice *s,
 			      struct comedi_insn *insn, unsigned int *data);
@@ -1918,47 +1888,44 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
 	return 0;
 }
 
-/*
- * A convenient macro that defines init_module() and cleanup_module(),
- * as necessary.
- */
-static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
-						const struct pci_device_id *ent)
+static struct comedi_driver cb_pcidas_driver = {
+	.driver_name	= "cb_pcidas",
+	.module		= THIS_MODULE,
+	.attach		= cb_pcidas_attach,
+	.detach		= cb_pcidas_detach,
+};
+
+static int __devinit cb_pcidas_pci_probe(struct pci_dev *dev,
+					 const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, &driver_cb_pcidas);
+	return comedi_pci_auto_config(dev, &cb_pcidas_driver);
 }
 
-static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)
+static void __devexit cb_pcidas_pci_remove(struct pci_dev *dev)
 {
 	comedi_pci_auto_unconfig(dev);
 }
 
-static struct pci_driver driver_cb_pcidas_pci_driver = {
-	.id_table = cb_pcidas_pci_table,
-	.probe = &driver_cb_pcidas_pci_probe,
-	.remove = __devexit_p(&driver_cb_pcidas_pci_remove)
+static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0001) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x000f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0010) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0019) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001c) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x004c) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001a) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001b) },
+	{ 0 }
 };
+MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 
-static int __init driver_cb_pcidas_init_module(void)
-{
-	int retval;
-
-	retval = comedi_driver_register(&driver_cb_pcidas);
-	if (retval < 0)
-		return retval;
-
-	driver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;
-	return pci_register_driver(&driver_cb_pcidas_pci_driver);
-}
-
-static void __exit driver_cb_pcidas_cleanup_module(void)
-{
-	pci_unregister_driver(&driver_cb_pcidas_pci_driver);
-	comedi_driver_unregister(&driver_cb_pcidas);
-}
-
-module_init(driver_cb_pcidas_init_module);
-module_exit(driver_cb_pcidas_cleanup_module);
+static struct pci_driver cb_pcidas_pci_driver = {
+	.name		= "cb_pcidas",
+	.id_table	= cb_pcidas_pci_table,
+	.probe		= cb_pcidas_pci_probe,
+	.remove		= __devexit_p(cb_pcidas_pci_remove)
+};
+module_comedi_pci_driver(cb_pcidas_driver, cb_pcidas_pci_driver);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 4c093a6dc2240fd54d71a25b284e02d51509e430
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 30 17:14:56 2012 +0100

    staging: comedi: pass 'struct comedi_driver *' to comedi_..._auto_config
    
    The comedi_pci_auto_config() and comedi_usb_auto_config() functions
    currently take a board name parameter which is actually a driver name
    parameter.  Replace it with a pointer to the struct comedi_driver.  This
    will allow comedi_pci_auto_config() and comedi_usb_auto_config() to call
    bus-type-specific auto-configuration hooks in the struct comedi_driver
    if they exist (they don't yet).  The idea is that these
    bus-type-specific auto-configuration hooks won't have to search the bus
    for the device being auto-configured like 'attach()' hook has to.
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7e4ffcfdac62..f1ad286a0306 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1925,7 +1925,7 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
 static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
 						const struct pci_device_id *ent)
 {
-	return comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);
+	return comedi_pci_auto_config(dev, &driver_cb_pcidas);
 }
 
 static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)

commit 94cc0b4a6ea924b69bb8e784eb977d6a61ae5ace
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:34 2011 +0530

    Staging: comedi: fix printk issue in cb_pcidas.c
    
    This is a patch to the cb_pcidas.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_<levels>..
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 757c96a5972d..7e4ffcfdac62 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -855,7 +855,8 @@ static int ai_config_calibration_source(struct comedi_device *dev,
 	unsigned int source = data[1];
 
 	if (source >= num_calibration_sources) {
-		printk("invalid calibration source: %i\n", source);
+		dev_err(dev->hw_dev, "invalid calibration source: %i\n",
+			source);
 		return -EINVAL;
 	}
 
@@ -1547,7 +1548,8 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	dev_dbg(dev->hw_dev, "comedi: adc_fifo_bits are 0x%x\n",
+		devpriv->adc_fifo_bits);
 #endif
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
@@ -1557,7 +1559,8 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: sent 0x%x to dac control\n", devpriv->ao_control_bits);
+	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to dac control\n",
+		devpriv->ao_control_bits);
 #endif
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1585,8 +1588,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-	printk("intcsr 0x%x\n", s5933_status);
-	printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
+	dev_dbg(dev->hw_dev, "intcsr 0x%x\n", s5933_status);
+	dev_dbg(dev->hw_dev, "mbef 0x%x\n",
+		inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
 #endif
 
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)

commit aa4b8c725884b15c1d1467d382162e151b13a612
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Mon Dec 12 10:49:33 2011 +0530

    Staging: comedi: fix printk issue in cb_pcidas.c
    
    This is a patch to the cb_pcidas.c file that fixes up a
    printk warning found by the checkpatch.pl tool.
    
    Converted printks to dev_dbg()..
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 74336464cfb8..757c96a5972d 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -773,8 +773,8 @@ static int cb_pcidas_detach(struct comedi_device *dev)
 			outl(INTCSR_INBOX_INTR_STATUS,
 			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-			printk("detaching, incsr is 0x%x\n",
-			       inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));
+			dev_dbg(dev->hw_dev, "detaching, incsr is 0x%x\n",
+				inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));
 #endif
 		}
 	}
@@ -1276,7 +1276,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: sent 0x%x to adcmux control\n", bits);
+	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to adcmux control\n", bits);
 #endif
 
 	/*  load counters */
@@ -1303,7 +1303,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	dev_dbg(dev->hw_dev, "comedi: adc_fifo_bits are 0x%x\n",
+		devpriv->adc_fifo_bits);
 #endif
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
@@ -1329,7 +1330,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 		bits |= BURSTE;
 	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: sent 0x%x to trig control\n", bits);
+	dev_dbg(dev->hw_dev, "comedi: sent 0x%x to trig control\n", bits);
 #endif
 
 	return 0;

commit 8bde85db943971ea57780823e25778068d77eead
Author: Ravishankar karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
Date:   Sat Nov 19 10:06:41 2011 +0530

    Staging: comedi: fix printk issue in cb_pcidas.c
    
    This is a patch to the cb_pcidas.c file that fixes up a printk
    warning found by the checkpatch.pl tool.
    
    converted printks to dev_printk and Removed unnecessary
    printk statements.
    
    Signed-off-by: Ravishankar Karkala Mallikarjunayya <ravishankar.km@greenturtles.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 61968a505f24..74336464cfb8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -565,8 +565,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	int index;
 	int i;
 
-	printk("comedi%d: cb_pcidas: ", dev->minor);
-
 /*
  * Allocate the private structure area.
  */
@@ -576,7 +574,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 /*
  * Probe the device to determine what device in the series it is.
  */
-	printk("\n");
 
 	for_each_pci_dev(pcidev) {
 		/*  is it not a computer boards card? */
@@ -600,20 +597,20 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 		}
 	}
 
-	printk("No supported ComputerBoards/MeasurementComputing card found on "
-	       "requested position\n");
+	dev_err(dev->hw_dev, "No supported ComputerBoards/MeasurementComputing card found on requested position\n");
 	return -EIO;
 
 found:
 
-	printk("Found %s on bus %i, slot %i\n", cb_pcidas_boards[index].name,
-	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	dev_dbg(dev->hw_dev, "Found %s on bus %i, slot %i\n",
+		cb_pcidas_boards[index].name, pcidev->bus->number,
+		PCI_SLOT(pcidev->devfn));
 
 	/*
 	 * Enable PCI device and reserve I/O ports.
 	 */
 	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
-		printk(" Failed to enable PCI device and request regions\n");
+		dev_err(dev->hw_dev, "Failed to enable PCI device and request regions\n");
 		return -EIO;
 	}
 	/*
@@ -639,7 +636,8 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 	/*  get irq */
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
-		printk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);
+		dev_dbg(dev->hw_dev, "unable to allocate irq %d\n",
+			devpriv->pci_dev->irq);
 		return -EINVAL;
 	}
 	dev->irq = devpriv->pci_dev->irq;
@@ -768,7 +766,6 @@ static int cb_pcidas_attach(struct comedi_device *dev,
  */
 static int cb_pcidas_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
 
 	if (devpriv) {
 		if (devpriv->s5933_config) {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0941643b3869..61968a505f24 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -115,7 +115,7 @@ analog triggering on 1602 series
 #define   INT_MASK 0x3		/*  mask of interrupt select bits */
 #define   INTE 0x4		/*  interrupt enable */
 #define   DAHFIE 0x8		/*  dac half full interrupt enable */
-#define   EOAIE	0x10		/*  end of aquisition interrupt enable */
+#define   EOAIE	0x10		/*  end of acquisition interrupt enable */
 #define   DAHFI	0x20		/*  dac half full read status / write interrupt clear */
 #define   EOAI 0x40		/*  read end of acq. interrupt status / write clear */
 #define   INT 0x80		/*  read interrupt status / write clear */
@@ -440,7 +440,7 @@ struct cb_pcidas_private {
 	unsigned int divisor1;
 	unsigned int divisor2;
 	volatile unsigned int count;	/*  number of analog input samples remaining */
-	volatile unsigned int adc_fifo_bits;	/*  bits to write to interupt/adcfifo register */
+	volatile unsigned int adc_fifo_bits;	/*  bits to write to interrupt/adcfifo register */
 	volatile unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
 	volatile unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
 	short ai_buffer[AI_BUFFER_SIZE];
@@ -1653,7 +1653,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
-			     "bug! encountered end of aquisition interrupt?");
+			     "bug! encountered end of acquisition interrupt?");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,

commit f1bc434398e8cf400374911357e89a13de366ce7
Author: Brice Dubost <dubost@crans.org>
Date:   Fri Jan 7 18:49:18 2011 +0100

    staging: comedi : Analog input trigerring modes for cb_pcidas
    
    This patch allows the possibility to choose between edgre triggering
    and level trigerring, for the analog input, on the Measurement
    Computing PCI-DAS* boards
    
    Signed-off-by: Brice Dubost <braice@braice.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 3275fc50615f..0941643b3869 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -53,6 +53,15 @@ Configuration options:
 For commands, the scanned channels must be consecutive
 (i.e. 4-5-6-7, 2-3-4,...), and must all have the same
 range and aref.
+
+AI Triggering:
+   For start_src == TRIG_EXT, the A/D EXTERNAL TRIGGER IN (pin 45) is used.
+   For 1602 series, the start_arg is interpreted as follows:
+     start_arg == 0                   => gated triger (level high)
+     start_arg == CR_INVERT           => gated triger (level low)
+     start_arg == CR_EDGE             => Rising edge
+     start_arg == CR_EDGE | CR_INVERT => Falling edge
+   For the other boards the trigger will be done on rising edge
 */
 /*
 
@@ -135,6 +144,8 @@ analog triggering on 1602 series
 #define   EXT_TRIGGER 0x2	/*  external start trigger */
 #define   ANALOG_TRIGGER 0x3	/*  external analog trigger */
 #define   TRIGGER_MASK	0x3	/*  mask of bits that determine start trigger */
+#define   TGPOL	0x04		/*  invert the edge/level of the external trigger (1602 only) */
+#define   TGSEL	0x08		/*  if set edge triggered, otherwise level trigerred (1602 only) */
 #define   TGEN	0x10		/*  enable external start trigger */
 #define   BURSTE 0x20		/*  burst mode enable */
 #define   XTRCL	0x80		/*  clear external trigger */
@@ -257,6 +268,8 @@ struct cb_pcidas_board {
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
+	unsigned has_ai_trig_gated:1;	/* Tells if the AI trigger can be gated */
+	unsigned has_ai_trig_invert:1;	/* Tells if the AI trigger can be inverted */
 };
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
@@ -274,6 +287,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD8402,
 	 .has_dac08 = 1,
+	 .has_ai_trig_gated = 1,
+	 .has_ai_trig_invert = 1,
 	 },
 	{
 	 .name = "pci-das1200",
@@ -288,6 +303,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 0,
+	 .has_ai_trig_invert = 0,
 	 },
 	{
 	 .name = "pci-das1602/12",
@@ -303,6 +320,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 1,
+	 .has_ai_trig_invert = 1,
 	 },
 	{
 	 .name = "pci-das1200/jr",
@@ -317,6 +336,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 0,
+	 .has_ai_trig_invert = 0,
 	 },
 	{
 	 .name = "pci-das1602/16/jr",
@@ -331,6 +352,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD8402,
 	 .has_dac08 = 1,
+	 .has_ai_trig_gated = 1,
+	 .has_ai_trig_invert = 1,
 	 },
 	{
 	 .name = "pci-das1000",
@@ -345,6 +368,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 0,
+	 .has_ai_trig_invert = 0,
 	 },
 	{
 	 .name = "pci-das1001",
@@ -359,6 +384,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_alt_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 0,
+	 .has_ai_trig_invert = 0,
 	 },
 	{
 	 .name = "pci-das1002",
@@ -373,6 +400,8 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	 .ranges = &cb_pcidas_ranges,
 	 .trimpot = AD7376,
 	 .has_dac08 = 0,
+	 .has_ai_trig_gated = 0,
+	 .has_ai_trig_invert = 0,
 	 },
 };
 
@@ -1113,9 +1142,27 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
 
 	/* step 3: make sure arguments are trivially compatible */
 
-	if (cmd->start_arg != 0) {
-		cmd->start_arg = 0;
-		err++;
+	switch (cmd->start_src) {
+	case TRIG_EXT:
+		/* External trigger, only CR_EDGE and CR_INVERT flags allowed */
+		if ((cmd->start_arg
+		     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {
+			cmd->start_arg &=
+			    ~(CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));
+			err++;
+		}
+		if (!thisboard->has_ai_trig_invert &&
+		    (cmd->start_arg & CR_INVERT)) {
+			cmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);
+			err++;
+		}
+		break;
+	default:
+		if (cmd->start_arg != 0) {
+			cmd->start_arg = 0;
+			err++;
+		}
+		break;
 	}
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
@@ -1270,9 +1317,14 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 	bits = 0;
 	if (cmd->start_src == TRIG_NOW)
 		bits |= SW_TRIGGER;
-	else if (cmd->start_src == TRIG_EXT)
+	else if (cmd->start_src == TRIG_EXT) {
 		bits |= EXT_TRIGGER | TGEN | XTRCL;
-	else {
+		if (thisboard->has_ai_trig_invert
+		    && (cmd->start_arg & CR_INVERT))
+			bits |= TGPOL;
+		if (thisboard->has_ai_trig_gated && (cmd->start_arg & CR_EDGE))
+			bits |= TGSEL;
+	} else {
 		comedi_error(dev, "bug!");
 		return -1;
 	}

commit 16f08494f4523de348988763b74e5756d482978b
Author: Javier Martinez Canillas <martinez.javier@gmail.com>
Date:   Sat Aug 7 02:31:07 2010 -0400

    staging: comedi (cb_pcidas): use PCI_DEVICE() macro
    
    This is the first of a patch series that uses PCI_DEVICE() macro for pci table entries on comedi drivers and thus improving readability.
    
    Signed-off-by: Javier Martinez Canillas <martinez.javier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 6530b6c9d98b..3275fc50615f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -377,16 +377,15 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 };
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
-	{
-	PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
-	0}
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0001) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x000f) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0010) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0019) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001c) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x004c) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001a) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x001b) },
+	{ 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);

commit 20fb2280815510533cbd7785b53821ca7209345b
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Sat Jul 3 19:20:47 2010 +0400

    Staging: comedi: use for_each_pci_dev()
    
    Use for_each_pci_dev() to simplify the code.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2d9ad537793e..6530b6c9d98b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -533,7 +533,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
 			    struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
-	struct pci_dev *pcidev;
+	struct pci_dev *pcidev = NULL;
 	int index;
 	int i;
 
@@ -550,9 +550,7 @@ static int cb_pcidas_attach(struct comedi_device *dev,
  */
 	printk("\n");
 
-	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-	     pcidev != NULL;
-	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	for_each_pci_dev(pcidev) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;

commit 727b286b44ea359d66f47d241cc2cdad36ed7bdc
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:31 2010 +0200

    Staging: comedi: Remove COMEDI_PCI_INITCLEANUP macro
    
    Move the PCI devinit/devexit routines to the respective C source files
    instead of calling COMEDI_PCI_INITCLEANUP
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 04c71704507f..2d9ad537793e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1871,7 +1871,43 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
  * A convenient macro that defines init_module() and cleanup_module(),
  * as necessary.
  */
-COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, cb_pcidas_pci_table);
+static int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,
+						const struct pci_device_id *ent)
+{
+	return comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);
+}
+
+static void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)
+{
+	comedi_pci_auto_unconfig(dev);
+}
+
+static struct pci_driver driver_cb_pcidas_pci_driver = {
+	.id_table = cb_pcidas_pci_table,
+	.probe = &driver_cb_pcidas_pci_probe,
+	.remove = __devexit_p(&driver_cb_pcidas_pci_remove)
+};
+
+static int __init driver_cb_pcidas_init_module(void)
+{
+	int retval;
+
+	retval = comedi_driver_register(&driver_cb_pcidas);
+	if (retval < 0)
+		return retval;
+
+	driver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;
+	return pci_register_driver(&driver_cb_pcidas_pci_driver);
+}
+
+static void __exit driver_cb_pcidas_cleanup_module(void)
+{
+	pci_unregister_driver(&driver_cb_pcidas_pci_driver);
+	comedi_driver_unregister(&driver_cb_pcidas);
+}
+
+module_init(driver_cb_pcidas_init_module);
+module_exit(driver_cb_pcidas_cleanup_module);
 
 MODULE_AUTHOR("Comedi http://www.comedi.org");
 MODULE_DESCRIPTION("Comedi low-level driver");

commit 90f703d30dd3e0c16ff80f35e34e511385a05ad5
Author: Arun Thomas <arun.thomas@gmail.com>
Date:   Sun Jun 6 22:23:29 2010 +0200

    Staging: comedi: Remove COMEDI_MODULES_MACRO
    
    Add MODULE_AUTHOR, MODULE_LICENSE, and MODULE_DESCRIPTION calls
    to the respective C source files instead of calling COMEDI_MODULES_MACRO
    
    Signed-off-by: Arun Thomas <arun.thomas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 434591de37c5..04c71704507f 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1872,3 +1872,7 @@ static int nvram_read(struct comedi_device *dev, unsigned int address,
  * as necessary.
  */
 COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, cb_pcidas_pci_table);
+
+MODULE_AUTHOR("Comedi http://www.comedi.org");
+MODULE_DESCRIPTION("Comedi low-level driver");
+MODULE_LICENSE("GPL");

commit 2d238b2972bf365153ae8d699177c7a19a5f3056
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Fri Feb 26 10:14:59 2010 +0100

    Staging: comedi: cb_pcidas.c: Checkpatch cleanup
    
    ERROR: "foo * bar" should be "foo *bar"
    +                     uint8_t * data);
    
    WARNING: braces {} are not necessary for single statement blocks
    +               if (devpriv->s5933_config) {
    +                       comedi_pci_disable(devpriv->pci_dev);
    +               }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (cmd->stop_src == TRIG_COUNT) {
    +               devpriv->count = cmd->chanlist_len * cmd->stop_arg;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (cmd->stop_src == TRIG_COUNT) {
    +               devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (cmd->stop_src == TRIG_COUNT) {
    +               devpriv->ao_count -= num_points;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (dev->attached == 0) {
    +               return IRQ_NONE;
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0) {
    +               comedi_error(dev, "spurious interrupt");
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +       if (status & (DAHFI | DAEMI)) {
    +               handle_ao_interrupt(dev, status);
    +       }
    
    WARNING: braces {} are not necessary for single statement blocks
    +               if (async->cmd.stop_src == TRIG_COUNT) {
    +                       devpriv->ao_count -= num_points;
    +               }
    
    ERROR: "foo * bar" should be "foo *bar"
    +                     uint8_t * data)
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f3e66c440a38..434591de37c5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -518,7 +518,7 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 			      uint8_t value);
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-		      uint8_t * data);
+		      uint8_t *data);
 
 static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
@@ -760,9 +760,8 @@ static int cb_pcidas_detach(struct comedi_device *dev)
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 	if (devpriv && devpriv->pci_dev) {
-		if (devpriv->s5933_config) {
+		if (devpriv->s5933_config)
 			comedi_pci_disable(devpriv->pci_dev);
-		}
 		pci_dev_put(devpriv->pci_dev);
 	}
 
@@ -1248,9 +1247,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev,
 					cmd->flags & TRIG_ROUND_MASK);
 
 	/*  set number of conversions */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
-	}
 	/*  enable interrupts */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
@@ -1449,9 +1447,8 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev,
 			   devpriv->ao_divisor2, 2);
 	}
 	/*  set number of conversions */
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
-	}
 	/*  set pacer source */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
@@ -1494,9 +1491,8 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 					       num_points * sizeof(short));
 	num_points = num_bytes / sizeof(short);
 
-	if (cmd->stop_src == TRIG_COUNT) {
+	if (cmd->stop_src == TRIG_COUNT)
 		devpriv->ao_count -= num_points;
-	}
 	/*  write data to board's fifo */
 	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
 
@@ -1534,9 +1530,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	static const int timeout = 10000;
 	unsigned long flags;
 
-	if (dev->attached == 0) {
+	if (dev->attached == 0)
 		return IRQ_NONE;
-	}
 
 	async = s->async;
 	async->events = 0;
@@ -1558,15 +1553,13 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	status = inw(devpriv->control_status + INT_ADCFIFO);
 #ifdef CB_PCIDAS_DEBUG
-	if ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0) {
+	if ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0)
 		comedi_error(dev, "spurious interrupt");
-	}
 #endif
 
 	/*  check for analog output interrupt */
-	if (status & (DAHFI | DAEMI)) {
+	if (status & (DAHFI | DAEMI))
 		handle_ao_interrupt(dev, status);
-	}
 	/*  check for analog input interrupts */
 	/*  if fifo half-full */
 	if (status & ADHFI) {
@@ -1675,9 +1668,8 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 					       num_points * sizeof(short));
 		num_points = num_bytes / sizeof(short);
 
-		if (async->cmd.stop_src == TRIG_COUNT) {
+		if (async->cmd.stop_src == TRIG_COUNT)
 			devpriv->ao_count -= num_points;
-		}
 		/*  write data to board's fifo */
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
 		      num_points);
@@ -1852,7 +1844,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 }
 
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-		      uint8_t * data)
+			uint8_t *data)
 {
 	unsigned long iobase = devpriv->s5933_config;
 

commit 0a85b6f0ab0d2edb0d41b32697111ce0e4f43496
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon Jun 8 21:04:41 2009 +0530

    Staging: Comedi: Lindent changes to comdi driver in staging tree
    
    Lindent changes to comdi driver in staging tree.
    This patch is followed by the checkpatch.pl error fixes.
    Did not make them part of this patch as the patch size is already huge.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 702de1571223..f3e66c440a38 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -156,6 +156,7 @@ static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
 {
 	return (range & 0x3) << (8 + 2 * (channel & 0x1));
 }
+
 static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 {
 	return 0x3 << (8 + 2 * (channel & 0x1));
@@ -200,41 +201,41 @@ static inline unsigned int DAC_DATA_REG(unsigned int channel)
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(5),
-			BIP_RANGE(2.5),
-			BIP_RANGE(1.25),
-			UNI_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(2.5),
-			UNI_RANGE(1.25)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(5),
+	 BIP_RANGE(2.5),
+	 BIP_RANGE(1.25),
+	 UNI_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(2.5),
+	 UNI_RANGE(1.25)
+	 }
 };
 
 /* pci-das1001 input ranges */
 static const struct comedi_lrange cb_pcidas_alt_ranges = {
 	8,
 	{
-			BIP_RANGE(10),
-			BIP_RANGE(1),
-			BIP_RANGE(0.1),
-			BIP_RANGE(0.01),
-			UNI_RANGE(10),
-			UNI_RANGE(1),
-			UNI_RANGE(0.1),
-			UNI_RANGE(0.01)
-		}
+	 BIP_RANGE(10),
+	 BIP_RANGE(1),
+	 BIP_RANGE(0.1),
+	 BIP_RANGE(0.01),
+	 UNI_RANGE(10),
+	 UNI_RANGE(1),
+	 UNI_RANGE(0.1),
+	 UNI_RANGE(0.01)
+	 }
 };
 
 /* analog output ranges */
 static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	4,
 	{
-			BIP_RANGE(5),
-			BIP_RANGE(10),
-			UNI_RANGE(5),
-			UNI_RANGE(10),
-		}
+	 BIP_RANGE(5),
+	 BIP_RANGE(10),
+	 UNI_RANGE(5),
+	 UNI_RANGE(10),
+	 }
 };
 
 enum trimpot_model {
@@ -260,131 +261,132 @@ struct cb_pcidas_board {
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
-	.name = "pci-das1602/16",
-	.device_id = 0x1,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 2,
-	.has_ao_fifo = 1,
-	.ao_scan_speed = 10000,
-	.fifo_size = 512,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD8402,
-	.has_dac08 = 1,
-		},
+	 .name = "pci-das1602/16",
+	 .device_id = 0x1,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 1,
+	 .ao_scan_speed = 10000,
+	 .fifo_size = 512,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD8402,
+	 .has_dac08 = 1,
+	 },
 	{
-	.name = "pci-das1200",
-	.device_id = 0xF,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1200",
+	 .device_id = 0xF,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1602/12",
-	.device_id = 0x10,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 2,
-	.has_ao_fifo = 1,
-	.ao_scan_speed = 4000,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1602/12",
+	 .device_id = 0x10,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 1,
+	 .ao_scan_speed = 4000,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1200/jr",
-	.device_id = 0x19,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 3200,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1200/jr",
+	 .device_id = 0x19,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 3200,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1602/16/jr",
-	.device_id = 0x1C,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 16,
-	.ai_speed = 5000,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 512,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD8402,
-	.has_dac08 = 1,
-		},
+	 .name = "pci-das1602/16/jr",
+	 .device_id = 0x1C,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 16,
+	 .ai_speed = 5000,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 512,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD8402,
+	 .has_dac08 = 1,
+	 },
 	{
-	.name = "pci-das1000",
-	.device_id = 0x4C,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 4000,
-	.ao_nchan = 0,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1000",
+	 .device_id = 0x4C,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 4000,
+	 .ao_nchan = 0,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1001",
-	.device_id = 0x1a,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 6800,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_alt_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1001",
+	 .device_id = 0x1a,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 6800,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_alt_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 	{
-	.name = "pci-das1002",
-	.device_id = 0x1b,
-	.ai_se_chans = 16,
-	.ai_diff_chans = 8,
-	.ai_bits = 12,
-	.ai_speed = 6800,
-	.ao_nchan = 2,
-	.has_ao_fifo = 0,
-	.fifo_size = 1024,
-	.ranges = &cb_pcidas_ranges,
-	.trimpot = AD7376,
-	.has_dac08 = 0,
-		},
+	 .name = "pci-das1002",
+	 .device_id = 0x1b,
+	 .ai_se_chans = 16,
+	 .ai_diff_chans = 8,
+	 .ai_bits = 12,
+	 .ai_speed = 6800,
+	 .ao_nchan = 2,
+	 .has_ao_fifo = 0,
+	 .fifo_size = 1024,
+	 .ranges = &cb_pcidas_ranges,
+	 .trimpot = AD7376,
+	 .has_dac08 = 0,
+	 },
 };
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
-	{PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0}
+	{
+	PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, {
+	0}
 };
 
 MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
@@ -438,7 +440,8 @@ struct cb_pcidas_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it);
 static int cb_pcidas_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
 	.driver_name = "cb_pcidas",
@@ -447,55 +450,75 @@ static struct comedi_driver driver_cb_pcidas = {
 	.detach = cb_pcidas_detach,
 };
 
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
-static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
-static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+			  struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data);
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn,
+				   unsigned int *data);
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data);
+static int cb_pcidas_ai_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
+static int cb_pcidas_ao_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *subdev,
 				unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd);
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d);
 static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
-static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
-static int cb_pcidas_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int cb_pcidas_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s);
+static int cb_pcidas_ao_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s);
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-	int round_flags);
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int cb_pcidas_trimpot_write(struct comedi_device *dev, unsigned int channel,
-	unsigned int value);
-static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
-static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+				    int round_flags);
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int caldac_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
+static int caldac_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int trimpot_read_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_trimpot_write(struct comedi_device *dev,
+				   unsigned int channel, unsigned int value);
+static int trimpot_write_insn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data);
+static int dac08_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data);
 static int dac08_write(struct comedi_device *dev, unsigned int value);
-static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data);
+static int dac08_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data);
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value);
+			     uint8_t value);
 static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-	uint8_t value);
+			      uint8_t value);
 static int nvram_read(struct comedi_device *dev, unsigned int address,
-	uint8_t *data);
+		      uint8_t * data);
 
 static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
@@ -506,7 +529,8 @@ static inline unsigned int cal_enable_bits(struct comedi_device *dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it)
+static int cb_pcidas_attach(struct comedi_device *dev,
+			    struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -527,8 +551,8 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 	printk("\n");
 
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
-		pcidev != NULL;
-		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+	     pcidev != NULL;
+	     pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
 		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
@@ -540,8 +564,7 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 			if (it->options[0] || it->options[1]) {
 				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
-					PCI_SLOT(pcidev->devfn) !=
-					it->options[1]) {
+				    PCI_SLOT(pcidev->devfn) != it->options[1]) {
 					continue;
 				}
 			}
@@ -552,13 +575,13 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 	}
 
 	printk("No supported ComputerBoards/MeasurementComputing card found on "
-		"requested position\n");
+	       "requested position\n");
 	return -EIO;
 
-      found:
+found:
 
 	printk("Found %s on bus %i, slot %i\n", cb_pcidas_boards[index].name,
-		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+	       pcidev->bus->number, PCI_SLOT(pcidev->devfn));
 
 	/*
 	 * Enable PCI device and reserve I/O ports.
@@ -572,20 +595,20 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 	 * their base address.
 	 */
 	devpriv->s5933_config =
-		pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
 	devpriv->control_status =
-		pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
 	devpriv->adc_fifo =
-		pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
 	devpriv->pacer_counter_dio =
-		pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
+	    pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
 	if (thisboard->ao_nchan) {
 		devpriv->ao_registers =
-			pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
+		    pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
 	}
 	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	/*  get irq */
 	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
@@ -700,11 +723,11 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
 	devpriv->s5933_intcsr_bits =
-		INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
-		INTCSR_INBOX_FULL_INT;
+	    INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
+	    INTCSR_INBOX_FULL_INT;
 	/*  clear and enable interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	return 1;
 }
@@ -725,11 +748,10 @@ static int cb_pcidas_detach(struct comedi_device *dev)
 		if (devpriv->s5933_config) {
 			/*  disable and clear interrupts on amcc s5933 */
 			outl(INTCSR_INBOX_INTR_STATUS,
-				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+			     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
 			printk("detaching, incsr is 0x%x\n",
-				inl(devpriv->s5933_config +
-					AMCC_OP_REG_INTCSR));
+			       inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR));
 #endif
 		}
 	}
@@ -751,8 +773,9 @@ static int cb_pcidas_detach(struct comedi_device *dev)
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int bits;
@@ -761,7 +784,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice
 	/*  enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
-			devpriv->control_status + CALIBRATION_REG);
+		     devpriv->control_status + CALIBRATION_REG);
 		channel = 0;
 	} else {
 		outw(0, devpriv->control_status + CALIBRATION_REG);
@@ -769,7 +792,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice
 	}
 	/*  set mux limits and gain */
 	bits = BEGIN_SCAN(channel) |
-		END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
+	    END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
 	/*  set unipolar/bipolar */
 	if (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)
 		bits |= UNIP;
@@ -803,7 +826,8 @@ static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
+static int ai_config_calibration_source(struct comedi_device *dev,
+					unsigned int *data)
 {
 	static const int num_calibration_sources = 8;
 	unsigned int source = data[1];
@@ -819,7 +843,7 @@ static int ai_config_calibration_source(struct comedi_device *dev, unsigned int
 }
 
 static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+			  struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -835,8 +859,10 @@ static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
 }
 
 /* analog output insn for pcidas-1000 and 1200 series */
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev,
+				     struct comedi_subdevice *s,
+				     struct comedi_insn *insn,
+				     unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -845,9 +871,9 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_su
 	channel = CR_CHAN(insn->chanspec);
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
-		~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
+	    ~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
 	devpriv->ao_control_bits |=
-		DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
+	    DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -860,8 +886,9 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_su
 }
 
 /* analog output insn for pcidas-1602 series */
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev,
+				   struct comedi_subdevice *s,
+				   struct comedi_insn *insn, unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -873,11 +900,13 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subd
 	channel = CR_CHAN(insn->chanspec);
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
-		~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
-		~DAC_PACER_MASK;
+	    ~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
+	    ~DAC_PACER_MASK;
 	devpriv->ao_control_bits |=
-		DACEN | DAC_RANGE(channel,
-		CR_RANGE(insn->chanspec)) | DAC_CHAN_EN(channel) | DAC_START;
+	    DACEN | DAC_RANGE(channel,
+			      CR_RANGE(insn->
+				       chanspec)) | DAC_CHAN_EN(channel) |
+	    DAC_START;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -891,16 +920,19 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subd
 
 /* analog output readback insn */
 /* XXX loses track of analog output value back after an analog ouput command is executed */
-static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int eeprom_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	uint8_t nvram_data;
 	int retval;
@@ -914,16 +946,18 @@ static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *
 	return 1;
 }
 
-static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int caldac_write_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return caldac_8800_write(dev, channel, data[0]);
 }
 
-static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int caldac_read_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
@@ -939,26 +973,28 @@ static int dac08_write(struct comedi_device *dev, unsigned int value)
 	devpriv->dac08_value = value;
 
 	outw(cal_enable_bits(dev) | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 	outw(cal_enable_bits(dev) | (value & 0xff),
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(1);
 
 	return 1;
 }
 
-static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dac08_write_insn(struct comedi_device *dev,
+			    struct comedi_subdevice *s,
+			    struct comedi_insn *insn, unsigned int *data)
 {
 	return dac08_write(dev, data[0]);
 }
 
-static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int dac08_read_insn(struct comedi_device *dev,
+			   struct comedi_subdevice *s, struct comedi_insn *insn,
+			   unsigned int *data)
 {
 	data[0] = devpriv->dac08_value;
 
@@ -966,7 +1002,7 @@ static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s
 }
 
 static int cb_pcidas_trimpot_write(struct comedi_device *dev,
-	unsigned int channel, unsigned int value)
+				   unsigned int channel, unsigned int value)
 {
 	if (devpriv->trimpot_value[channel] == value)
 		return 1;
@@ -988,16 +1024,18 @@ static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 	return 1;
 }
 
-static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int trimpot_write_insn(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return cb_pcidas_trimpot_write(dev, channel, data[0]);
 }
 
-static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+static int trimpot_read_insn(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -1006,8 +1044,9 @@ static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice
 	return 1;
 }
 
-static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1055,11 +1094,11 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW &&
-		cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_TIMER &&
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->convert_src != TRIG_TIMER &&
-		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+	    cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1070,8 +1109,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
 		err++;
 	if (cmd->start_src == TRIG_EXT &&
-		(cmd->convert_src == TRIG_EXT
-			|| cmd->scan_begin_src == TRIG_EXT))
+	    (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))
 		err++;
 
 	if (err)
@@ -1086,9 +1124,9 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		if (cmd->scan_begin_arg <
-			thisboard->ai_speed * cmd->chanlist_len) {
+		    thisboard->ai_speed * cmd->chanlist_len) {
 			cmd->scan_begin_arg =
-				thisboard->ai_speed * cmd->chanlist_len;
+			    thisboard->ai_speed * cmd->chanlist_len;
 			err++;
 		}
 	}
@@ -1119,16 +1157,20 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
 	if (cmd->convert_src == TRIG_TIMER) {
 		tmp = cmd->convert_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->divisor1), &(devpriv->divisor2),
-			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->divisor1),
+					       &(devpriv->divisor2),
+					       &(cmd->convert_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->convert_arg)
 			err++;
 	}
@@ -1142,14 +1184,14 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 		start_chan = CR_CHAN(cmd->chanlist[0]);
 		for (i = 1; i < cmd->chanlist_len; i++) {
 			if (CR_CHAN(cmd->chanlist[i]) !=
-				(start_chan + i) % s->n_chan) {
+			    (start_chan + i) % s->n_chan) {
 				comedi_error(dev,
-					"entries in chanlist must be consecutive channels, counting upwards\n");
+					     "entries in chanlist must be consecutive channels, counting upwards\n");
 				err++;
 			}
 			if (CR_RANGE(cmd->chanlist[i]) != gain) {
 				comedi_error(dev,
-					"entries in chanlist must all have the same gain\n");
+					     "entries in chanlist must all have the same gain\n");
 				err++;
 			}
 		}
@@ -1161,7 +1203,8 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	return 0;
 }
 
-static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_ai_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1177,8 +1220,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 
 	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
-		END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
-		GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
+	    END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
+	    GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
 	/*  set unipolar/bipolar */
 	if (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)
 		bits |= UNIP;
@@ -1199,10 +1242,10 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	/*  load counters */
 	if (cmd->convert_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->convert_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 	else if (cmd->scan_begin_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->scan_begin_arg,
-			cmd->flags & TRIG_ROUND_MASK);
+					cmd->flags & TRIG_ROUND_MASK);
 
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1225,7 +1268,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 #endif
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
-		devpriv->control_status + INT_ADCFIFO);
+	     devpriv->control_status + INT_ADCFIFO);
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
@@ -1248,8 +1291,9 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	return 0;
 }
 
-static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_cmd *cmd)
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1294,7 +1338,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
 	if (cmd->scan_begin_src != TRIG_TIMER &&
-		cmd->scan_begin_src != TRIG_EXT)
+	    cmd->scan_begin_src != TRIG_EXT)
 		err++;
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
@@ -1336,8 +1380,10 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		tmp = cmd->scan_begin_arg;
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
-			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+					       &(devpriv->ao_divisor1),
+					       &(devpriv->ao_divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags & TRIG_ROUND_MASK);
 		if (tmp != cmd->scan_begin_arg)
 			err++;
 	}
@@ -1348,9 +1394,9 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist && cmd->chanlist_len > 1) {
 		if (CR_CHAN(cmd->chanlist[0]) != 0 ||
-			CR_CHAN(cmd->chanlist[1]) != 1) {
+		    CR_CHAN(cmd->chanlist[1]) != 1) {
 			comedi_error(dev,
-				"channels must be ordered channel 0, channel 1 in chanlist\n");
+				     "channels must be ordered channel 0, channel 1 in chanlist\n");
 			err++;
 		}
 	}
@@ -1361,7 +1407,8 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevi
 	return 0;
 }
 
-static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_ao_cmd(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1373,10 +1420,11 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/*  enable channel */
 		devpriv->ao_control_bits |=
-			DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
+		    DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
 		/*  set range */
 		devpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),
-			CR_RANGE(cmd->chanlist[i]));
+						      CR_RANGE(cmd->
+							       chanlist[i]));
 	}
 
 	/*  disable analog out before settings pacer source and count values */
@@ -1389,14 +1437,16 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
-			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
-			&(cmd->scan_begin_arg), cmd->flags);
+					       &(devpriv->ao_divisor1),
+					       &(devpriv->ao_divisor2),
+					       &(cmd->scan_begin_arg),
+					       cmd->flags);
 
 		/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,
-			devpriv->ao_divisor1, 2);
+			   devpriv->ao_divisor1, 2);
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,
-			devpriv->ao_divisor2, 2);
+			   devpriv->ao_divisor2, 2);
 	}
 	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1441,7 +1491,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 		num_points = devpriv->ao_count;
 
 	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-		num_points * sizeof(short));
+					       num_points * sizeof(short));
 	num_points = num_bytes / sizeof(short);
 
 	if (cmd->stop_src == TRIG_COUNT) {
@@ -1458,14 +1508,13 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 #endif
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
-		devpriv->control_status + INT_ADCFIFO);
+	     devpriv->control_status + INT_ADCFIFO);
 
 	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	printk("comedi: sent 0x%x to dac control\n",
-		devpriv->ao_control_bits);
+	printk("comedi: sent 0x%x to dac control\n", devpriv->ao_control_bits);
 #endif
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
@@ -1476,7 +1525,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
-	struct comedi_device *dev = (struct comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *)d;
 	struct comedi_subdevice *s = dev->read_subdev;
 	struct comedi_async *async;
 	int status, s5933_status;
@@ -1505,7 +1554,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	inl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);
 	/*  clear interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
-		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+	     devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	status = inw(devpriv->control_status + INT_ADCFIFO);
 #ifdef CB_PCIDAS_DEBUG
@@ -1524,13 +1573,13 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  read data */
 		num_samples = half_fifo;
 		if (async->cmd.stop_src == TRIG_COUNT &&
-			num_samples > devpriv->count) {
+		    num_samples > devpriv->count) {
 			num_samples = devpriv->count;
 		}
 		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
-			num_samples);
+		     num_samples);
 		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
-			num_samples * sizeof(short));
+					  num_samples * sizeof(short));
 		devpriv->count -= num_samples;
 		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {
 			async->events |= COMEDI_CB_EOA;
@@ -1539,14 +1588,14 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
 			/*  break if fifo is empty */
 			if ((ADNE & inw(devpriv->control_status +
-						INT_ADCFIFO)) == 0)
+					INT_ADCFIFO)) == 0)
 				break;
 			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
 			if (async->cmd.stop_src == TRIG_COUNT && --devpriv->count == 0) {	/* end of acquisition */
@@ -1558,15 +1607,15 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear not-empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
-			"bug! encountered end of aquisition interrupt?");
+			     "bug! encountered end of aquisition interrupt?");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
@@ -1575,7 +1624,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		/*  clear overflow interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		cb_pcidas_cancel(dev, s);
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
@@ -1601,12 +1650,12 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		/*  clear dac empty interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_NONE ||
-				(cmd->stop_src == TRIG_COUNT
-					&& devpriv->ao_count)) {
+			    (cmd->stop_src == TRIG_COUNT
+			     && devpriv->ao_count)) {
 				comedi_error(dev, "dac fifo underflow");
 				cb_pcidas_ao_cancel(dev, s);
 				async->events |= COMEDI_CB_ERROR;
@@ -1619,11 +1668,11 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		/*  figure out how many points we are writing to fifo */
 		num_points = half_fifo;
 		if (cmd->stop_src == TRIG_COUNT &&
-			devpriv->ao_count < num_points)
+		    devpriv->ao_count < num_points)
 			num_points = devpriv->ao_count;
 		num_bytes =
-			cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-			num_points * sizeof(short));
+		    cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+					       num_points * sizeof(short));
 		num_points = num_bytes / sizeof(short);
 
 		if (async->cmd.stop_src == TRIG_COUNT) {
@@ -1631,11 +1680,11 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		}
 		/*  write data to board's fifo */
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
-			num_points);
+		      num_points);
 		/*  clear half-full interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
-			devpriv->control_status + INT_ADCFIFO);
+		     devpriv->control_status + INT_ADCFIFO);
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
@@ -1643,7 +1692,8 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 }
 
 /* cancel analog input command */
-static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
+static int cb_pcidas_cancel(struct comedi_device *dev,
+			    struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -1681,21 +1731,23 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 }
 
 static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
-	int rounding_flags)
+				    int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
-		&(devpriv->divisor2), ns, rounding_flags & TRIG_ROUND_MASK);
+				       &(devpriv->divisor2), ns,
+				       rounding_flags & TRIG_ROUND_MASK);
 
 	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
 	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
-		devpriv->divisor1, 2);
+		   devpriv->divisor1, 2);
 	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
-		devpriv->divisor2, 2);
+		   devpriv->divisor2, 2);
 }
 
 static void write_calibration_bitstream(struct comedi_device *dev,
-	unsigned int register_bits, unsigned int bitstream,
-	unsigned int bitstream_length)
+					unsigned int register_bits,
+					unsigned int bitstream,
+					unsigned int bitstream_length)
 {
 	static const int write_delay = 1;
 	unsigned int bit;
@@ -1711,7 +1763,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 }
 
 static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
-	uint8_t value)
+			     uint8_t value)
 {
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
@@ -1729,11 +1781,11 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	devpriv->caldac_value[address] = value;
 
 	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
-		devpriv->control_status + CALIBRATION_REG);
+	     devpriv->control_status + CALIBRATION_REG);
 	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
@@ -1752,7 +1804,7 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(ad7376_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
@@ -1764,7 +1816,7 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
  * ch 0 : adc gain
  * ch 1 : adc postgain offset */
 static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
-	uint8_t value)
+			      uint8_t value)
 {
 	static const int bitstream_length = 10;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
@@ -1776,7 +1828,7 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
-		bitstream_length);
+				    bitstream_length);
 
 	udelay(ad8402_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
@@ -1791,15 +1843,16 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 
 	for (i = 0; i < timeout; i++) {
 		if ((inb(s5933_base_addr +
-					AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
-			== 0)
+			 AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
+		    == 0)
 			return 0;
 		udelay(1);
 	}
 	return -1;
 }
 
-static int nvram_read(struct comedi_device *dev, unsigned int address, uint8_t *data)
+static int nvram_read(struct comedi_device *dev, unsigned int address,
+		      uint8_t * data)
 {
 	unsigned long iobase = devpriv->s5933_config;
 
@@ -1807,10 +1860,10 @@ static int nvram_read(struct comedi_device *dev, unsigned int address, uint8_t *
 		return -ETIMEDOUT;
 
 	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
-		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
 	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
 	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
-		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	     iobase + AMCC_OP_REG_MCSR_NVCMD);
 	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
 	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
 

commit 3a5e32ddcb04d7a2bed86323ca22da51d3a810bd
Author: Gerard Lledo <gerard.lledo@gmail.com>
Date:   Wed May 27 17:35:19 2009 +0300

    Staging: comedi: cb_pcidas.c: Fix build warning (type mismatch)
    
    spin_lock_irqsave expects flags to be unsigned long, not unsigned int.
    
    Signed-off-by: Gerard Lledo <gerard.lledo@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 28212ad6461b..702de1571223 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -1593,7 +1593,7 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int half_fifo = thisboard->fifo_size / 2;
 	unsigned int num_points;
-	unsigned int flags;
+	unsigned long flags;
 
 	async->events = 0;
 

commit 5f74ea14c07fee91d3bdbaad88bff6264c6200e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 14:44:31 2009 -0700

    Staging: comedi: remove comedi-specific wrappers
    
    There are a number of comedi "wrappers" for some RT functions that are
    about to go away.  This patch removes all of the wrapper calls within
    the comedi drivers and core in order to prepare for removing the RT
    comedi code.
    
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 11212b01d493..28212ad6461b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -588,7 +588,7 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
 	/*  get irq */
-	if (comedi_request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
+	if (request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
 		printk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);
 		return -EINVAL;
@@ -727,14 +727,14 @@ static int cb_pcidas_detach(struct comedi_device *dev)
 			outl(INTCSR_INBOX_INTR_STATUS,
 				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-			rt_printk("detaching, incsr is 0x%x\n",
+			printk("detaching, incsr is 0x%x\n",
 				inl(devpriv->s5933_config +
 					AMCC_OP_REG_INTCSR));
 #endif
 		}
 	}
 	if (dev->irq)
-		comedi_free_irq(dev->irq, dev);
+		free_irq(dev->irq, dev);
 	if (dev->subdevices)
 		subdev_8255_cleanup(dev, dev->subdevices + 2);
 	if (devpriv && devpriv->pci_dev) {
@@ -843,13 +843,13 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_su
 
 	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
 		~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
 	devpriv->ao_control_bits |=
 		DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
@@ -871,7 +871,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subd
 
 	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
 		~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
 		~DAC_PACER_MASK;
@@ -879,7 +879,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subd
 		DACEN | DAC_RANGE(channel,
 		CR_RANGE(insn->chanspec)) | DAC_CHAN_EN(channel) | DAC_START;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
@@ -940,13 +940,13 @@ static int dac08_write(struct comedi_device *dev, unsigned int value)
 
 	outw(cal_enable_bits(dev) | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 	outw(cal_enable_bits(dev) | (value & 0xff),
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(1);
+	udelay(1);
 
 	return 1;
 }
@@ -1193,7 +1193,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
 
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to adcmux control\n", bits);
+	printk("comedi: sent 0x%x to adcmux control\n", bits);
 #endif
 
 	/*  load counters */
@@ -1209,7 +1209,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
 	}
 	/*  enable interrupts */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
 	devpriv->adc_fifo_bits &= ~INT_MASK;
 	if (cmd->flags & TRIG_WAKE_EOS) {
@@ -1221,12 +1221,12 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
 	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
 		devpriv->control_status + INT_ADCFIFO);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  set start trigger and burst mode */
 	bits = 0;
@@ -1242,7 +1242,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		bits |= BURSTE;
 	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to trig control\n", bits);
+	printk("comedi: sent 0x%x to trig control\n", bits);
 #endif
 
 	return 0;
@@ -1369,7 +1369,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 	unsigned long flags;
 
 	/*  set channel limits, gain */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	for (i = 0; i < cmd->chanlist_len; i++) {
 		/*  enable channel */
 		devpriv->ao_control_bits |=
@@ -1381,7 +1381,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 
 	/*  disable analog out before settings pacer source and count values */
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  clear fifo */
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
@@ -1403,7 +1403,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
 	}
 	/*  set pacer source */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
 		devpriv->ao_control_bits |= DAC_PACER_INT;
@@ -1412,12 +1412,12 @@ static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *
 		devpriv->ao_control_bits |= DAC_PACER_EXT_RISE;
 		break;
 	default:
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		comedi_error(dev, "error setting dac pacer source");
 		return -1;
 		break;
 	}
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	async->inttrig = cb_pcidas_ao_inttrig;
 
@@ -1451,10 +1451,10 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
 
 	/*  enable dac half-full and empty interrupts */
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+	printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
 	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
@@ -1464,10 +1464,10 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("comedi: sent 0x%x to dac control\n",
+	printk("comedi: sent 0x%x to dac control\n",
 		devpriv->ao_control_bits);
 #endif
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	async->inttrig = NULL;
 
@@ -1494,8 +1494,8 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 
 	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
-	rt_printk("intcsr 0x%x\n", s5933_status);
-	rt_printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
+	printk("intcsr 0x%x\n", s5933_status);
+	printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
 #endif
 
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
@@ -1537,10 +1537,10 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			cb_pcidas_cancel(dev, s);
 		}
 		/*  clear half-full interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
@@ -1556,27 +1556,27 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 			}
 		}
 		/*  clear not-empty interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
 			"bug! encountered end of aquisition interrupt?");
 		/*  clear EOA interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 	/* check for fifo overflow */
 	if (status & LADFUL) {
 		comedi_error(dev, "fifo overflow");
 		/*  clear overflow interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		cb_pcidas_cancel(dev, s);
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
@@ -1599,10 +1599,10 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 
 	if (status & DAEMI) {
 		/*  clear dac empty interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
 			if (cmd->stop_src == TRIG_NONE ||
 				(cmd->stop_src == TRIG_COUNT
@@ -1633,10 +1633,10 @@ static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
 			num_points);
 		/*  clear half-full interrupt latch */
-		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
 			devpriv->control_status + INT_ADCFIFO);
-		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
 
 	comedi_event(dev, s);
@@ -1647,11 +1647,11 @@ static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	/*  disable start trigger source and burst mode */
 	outw(0, devpriv->control_status + TRIG_CONTSTAT);
@@ -1667,7 +1667,7 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 {
 	unsigned long flags;
 
-	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	spin_lock_irqsave(&dev->spinlock, flags);
 	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
@@ -1675,7 +1675,7 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	/*  disable output */
 	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
-	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
 
 	return 0;
 }
@@ -1705,7 +1705,7 @@ static void write_calibration_bitstream(struct comedi_device *dev,
 			register_bits |= SERIAL_DATA_IN_BIT;
 		else
 			register_bits &= ~SERIAL_DATA_IN_BIT;
-		comedi_udelay(write_delay);
+		udelay(write_delay);
 		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 	}
 }
@@ -1716,7 +1716,7 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	static const int num_caldac_channels = 8;
 	static const int bitstream_length = 11;
 	unsigned int bitstream = ((address & 0x7) << 8) | value;
-	static const int caldac_8800_comedi_udelay = 1;
+	static const int caldac_8800_udelay = 1;
 
 	if (address >= num_caldac_channels) {
 		comedi_error(dev, "illegal caldac channel");
@@ -1731,10 +1731,10 @@ static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
 		bitstream_length);
 
-	comedi_udelay(caldac_8800_comedi_udelay);
+	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
 		devpriv->control_status + CALIBRATION_REG);
-	comedi_udelay(caldac_8800_comedi_udelay);
+	udelay(caldac_8800_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 1;
@@ -1745,16 +1745,16 @@ static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 	static const int bitstream_length = 7;
 	unsigned int bitstream = value & 0x7f;
 	unsigned int register_bits;
-	static const int ad7376_comedi_udelay = 1;
+	static const int ad7376_udelay = 1;
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	comedi_udelay(ad7376_comedi_udelay);
+	udelay(ad7376_udelay);
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 		bitstream_length);
 
-	comedi_udelay(ad7376_comedi_udelay);
+	udelay(ad7376_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 0;
@@ -1769,16 +1769,16 @@ static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	static const int bitstream_length = 10;
 	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
 	unsigned int register_bits;
-	static const int ad8402_comedi_udelay = 1;
+	static const int ad8402_udelay = 1;
 
 	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
 
 	write_calibration_bitstream(dev, register_bits, bitstream,
 		bitstream_length);
 
-	comedi_udelay(ad8402_comedi_udelay);
+	udelay(ad8402_udelay);
 	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
 
 	return 0;
@@ -1794,7 +1794,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 					AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
 			== 0)
 			return 0;
-		comedi_udelay(1);
+		udelay(1);
 	}
 	return -1;
 }

commit 8629efa4cbf6f89a54a85af4b8bc31762af01800
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:56 2009 -0400

    Staging: comedi: make use of ARRAY_SIZE macro
    
    Replace instances of computing number of elements in an array with
    sizeof(foo)/sizeof(struct footype) with the ARRAY_SIZE macro.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 17dec7567481..11212b01d493 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -375,9 +375,6 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		},
 };
 
-/* Number of boards in cb_pcidas_boards */
-#define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(struct cb_pcidas_board))
-
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
 	{PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
@@ -536,7 +533,7 @@ static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
 		/*  loop through cards supported by this driver */
-		for (index = 0; index < N_BOARDS; index++) {
+		for (index = 0; index < ARRAY_SIZE(cb_pcidas_boards); index++) {
 			if (cb_pcidas_boards[index].device_id != pcidev->device)
 				continue;
 			/*  was a particular bus/slot requested? */

commit 814900c904140cfe7f3e48cabec06b3eec57e0ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 23 15:54:54 2009 -0400

    Staging: comedi: more fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 112480c969ab..17dec7567481 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -451,56 +451,56 @@ static struct comedi_driver driver_cb_pcidas = {
 };
 
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
-static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+	struct comedi_insn *insn, unsigned int *data);
+static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
+static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s);
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *subdev,
 				unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd);
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d);
-static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status);
-static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
-static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
+static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status);
+static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static int cb_pcidas_ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s);
+static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 	int round_flags);
-static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_trimpot_write(struct comedi_device * dev, unsigned int channel,
+static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int cb_pcidas_trimpot_write(struct comedi_device *dev, unsigned int channel,
 	unsigned int value);
-static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int dac08_write(struct comedi_device * dev, unsigned int value);
-static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data);
-static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
+static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int dac08_write(struct comedi_device *dev, unsigned int value);
+static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data);
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	uint8_t value);
-static int trimpot_7376_write(struct comedi_device * dev, uint8_t value);
-static int trimpot_8402_write(struct comedi_device * dev, unsigned int channel,
+static int trimpot_7376_write(struct comedi_device *dev, uint8_t value);
+static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	uint8_t value);
-static int nvram_read(struct comedi_device * dev, unsigned int address,
-	uint8_t * data);
+static int nvram_read(struct comedi_device *dev, unsigned int address,
+	uint8_t *data);
 
-static inline unsigned int cal_enable_bits(struct comedi_device * dev)
+static inline unsigned int cal_enable_bits(struct comedi_device *dev)
 {
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }

commit 68c3dbff9fc9f25872408d0e95980d41733d48d0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Apr 22 21:11:49 2009 -0400

    Staging: comedi: fix the way structs are initialized.
    
    Change from the foo: bar format to the .foo = bar format.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index a7b75808bda5..112480c969ab 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -260,118 +260,118 @@ struct cb_pcidas_board {
 
 static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
-	      name:	"pci-das1602/16",
-	      device_id:0x1,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:2,
-	      has_ao_fifo:1,
-	      ao_scan_speed:10000,
-	      fifo_size:512,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD8402,
-	      has_dac08:1,
+	.name = "pci-das1602/16",
+	.device_id = 0x1,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 2,
+	.has_ao_fifo = 1,
+	.ao_scan_speed = 10000,
+	.fifo_size = 512,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD8402,
+	.has_dac08 = 1,
 		},
 	{
-	      name:	"pci-das1200",
-	      device_id:0xF,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:3200,
-	      ao_nchan:2,
-	      has_ao_fifo:0,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1200",
+	.device_id = 0xF,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 3200,
+	.ao_nchan = 2,
+	.has_ao_fifo = 0,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 	{
-	      name:	"pci-das1602/12",
-	      device_id:0x10,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:3200,
-	      ao_nchan:2,
-	      has_ao_fifo:1,
-	      ao_scan_speed:4000,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1602/12",
+	.device_id = 0x10,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 3200,
+	.ao_nchan = 2,
+	.has_ao_fifo = 1,
+	.ao_scan_speed = 4000,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 	{
-	      name:	"pci-das1200/jr",
-	      device_id:0x19,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:3200,
-	      ao_nchan:0,
-	      has_ao_fifo:0,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1200/jr",
+	.device_id = 0x19,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 3200,
+	.ao_nchan = 0,
+	.has_ao_fifo = 0,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 	{
-	      name:	"pci-das1602/16/jr",
-	      device_id:0x1C,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	16,
-	      ai_speed:5000,
-	      ao_nchan:0,
-	      has_ao_fifo:0,
-	      fifo_size:512,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD8402,
-	      has_dac08:1,
+	.name = "pci-das1602/16/jr",
+	.device_id = 0x1C,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 16,
+	.ai_speed = 5000,
+	.ao_nchan = 0,
+	.has_ao_fifo = 0,
+	.fifo_size = 512,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD8402,
+	.has_dac08 = 1,
 		},
 	{
-	      name:	"pci-das1000",
-	      device_id:0x4C,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:4000,
-	      ao_nchan:0,
-	      has_ao_fifo:0,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1000",
+	.device_id = 0x4C,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 4000,
+	.ao_nchan = 0,
+	.has_ao_fifo = 0,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 	{
-	      name:	"pci-das1001",
-	      device_id:0x1a,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:6800,
-	      ao_nchan:2,
-	      has_ao_fifo:0,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_alt_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1001",
+	.device_id = 0x1a,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 6800,
+	.ao_nchan = 2,
+	.has_ao_fifo = 0,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_alt_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 	{
-	      name:	"pci-das1002",
-	      device_id:0x1b,
-	      ai_se_chans:16,
-	      ai_diff_chans:8,
-	      ai_bits:	12,
-	      ai_speed:6800,
-	      ao_nchan:2,
-	      has_ao_fifo:0,
-	      fifo_size:1024,
-	      ranges:	&cb_pcidas_ranges,
-	      trimpot:	AD7376,
-	      has_dac08:0,
+	.name = "pci-das1002",
+	.device_id = 0x1b,
+	.ai_se_chans = 16,
+	.ai_diff_chans = 8,
+	.ai_bits = 12,
+	.ai_speed = 6800,
+	.ao_nchan = 2,
+	.has_ao_fifo = 0,
+	.fifo_size = 1024,
+	.ranges = &cb_pcidas_ranges,
+	.trimpot = AD7376,
+	.has_dac08 = 0,
 		},
 };
 
@@ -444,10 +444,10 @@ struct cb_pcidas_private {
 static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it);
 static int cb_pcidas_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
-      driver_name:"cb_pcidas",
-      module:THIS_MODULE,
-      attach:cb_pcidas_attach,
-      detach:cb_pcidas_detach,
+	.driver_name = "cb_pcidas",
+	.module = THIS_MODULE,
+	.attach = cb_pcidas_attach,
+	.detach = cb_pcidas_detach,
 };
 
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,

commit da91b2692e0939b307f9047192d2b9fe07793e7a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Apr 9 16:07:03 2009 -0400

    Staging: comedi: fix "foo * bar" should be "foo *bar"
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0b09fc9bd4fb..a7b75808bda5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -441,8 +441,8 @@ struct cb_pcidas_private {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig * it);
-static int cb_pcidas_detach(struct comedi_device * dev);
+static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it);
+static int cb_pcidas_detach(struct comedi_device *dev);
 static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas",
       module:THIS_MODULE,
@@ -509,7 +509,7 @@ static inline unsigned int cal_enable_bits(struct comedi_device * dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig * it)
+static int cb_pcidas_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -720,7 +720,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int cb_pcidas_detach(struct comedi_device * dev)
+static int cb_pcidas_detach(struct comedi_device *dev)
 {
 	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
 
@@ -754,8 +754,8 @@ static int cb_pcidas_detach(struct comedi_device * dev)
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int n, i;
 	unsigned int bits;
@@ -806,7 +806,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevic
 	return n;
 }
 
-static int ai_config_calibration_source(struct comedi_device * dev, unsigned int * data)
+static int ai_config_calibration_source(struct comedi_device *dev, unsigned int *data)
 {
 	static const int num_calibration_sources = 8;
 	unsigned int source = data[1];
@@ -821,8 +821,8 @@ static int ai_config_calibration_source(struct comedi_device * dev, unsigned int
 	return 2;
 }
 
-static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int id = data[0];
 
@@ -838,8 +838,8 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 }
 
 /* analog output insn for pcidas-1000 and 1200 series */
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -863,8 +863,8 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_s
 }
 
 /* analog output insn for pcidas-1602 series */
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	int channel;
 	unsigned long flags;
@@ -894,16 +894,16 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_sub
 
 /* analog output readback insn */
 /* XXX loses track of analog output value back after an analog ouput command is executed */
-static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int cb_pcidas_ao_readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
 	return 1;
 }
 
-static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int eeprom_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	uint8_t nvram_data;
 	int retval;
@@ -917,16 +917,16 @@ static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int caldac_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return caldac_8800_write(dev, channel, data[0]);
 }
 
-static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int caldac_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
@@ -934,7 +934,7 @@ static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 /* 1602/16 pregain offset */
-static int dac08_write(struct comedi_device * dev, unsigned int value)
+static int dac08_write(struct comedi_device *dev, unsigned int value)
 {
 	if (devpriv->dac08_value == value)
 		return 1;
@@ -954,21 +954,21 @@ static int dac08_write(struct comedi_device * dev, unsigned int value)
 	return 1;
 }
 
-static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dac08_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	return dac08_write(dev, data[0]);
 }
 
-static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int dac08_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	data[0] = devpriv->dac08_value;
 
 	return 1;
 }
 
-static int cb_pcidas_trimpot_write(struct comedi_device * dev,
+static int cb_pcidas_trimpot_write(struct comedi_device *dev,
 	unsigned int channel, unsigned int value)
 {
 	if (devpriv->trimpot_value[channel] == value)
@@ -991,16 +991,16 @@ static int cb_pcidas_trimpot_write(struct comedi_device * dev,
 	return 1;
 }
 
-static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int trimpot_write_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
 	return cb_pcidas_trimpot_write(dev, channel, data[0]);
 }
 
-static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_insn * insn, unsigned int * data)
+static int trimpot_read_insn(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -1009,8 +1009,8 @@ static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice
 	return 1;
 }
 
-static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int cb_pcidas_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1164,7 +1164,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	return 0;
 }
 
-static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int cb_pcidas_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1251,8 +1251,8 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	struct comedi_cmd * cmd)
+static int cb_pcidas_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1364,7 +1364,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	return 0;
 }
 
-static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
+static int cb_pcidas_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
 	struct comedi_cmd *cmd = &async->cmd;
@@ -1589,7 +1589,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 	return IRQ_HANDLED;
 }
 
-static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
+static void handle_ao_interrupt(struct comedi_device *dev, unsigned int status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
@@ -1646,7 +1646,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 }
 
 /* cancel analog input command */
-static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+static int cb_pcidas_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	unsigned long flags;
 
@@ -1683,7 +1683,7 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	return 0;
 }
 
-static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
+static void cb_pcidas_load_counters(struct comedi_device *dev, unsigned int *ns,
 	int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
@@ -1696,7 +1696,7 @@ static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns
 		devpriv->divisor2, 2);
 }
 
-static void write_calibration_bitstream(struct comedi_device * dev,
+static void write_calibration_bitstream(struct comedi_device *dev,
 	unsigned int register_bits, unsigned int bitstream,
 	unsigned int bitstream_length)
 {
@@ -1713,7 +1713,7 @@ static void write_calibration_bitstream(struct comedi_device * dev,
 	}
 }
 
-static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device *dev, unsigned int address,
 	uint8_t value)
 {
 	static const int num_caldac_channels = 8;
@@ -1743,7 +1743,7 @@ static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	return 1;
 }
 
-static int trimpot_7376_write(struct comedi_device * dev, uint8_t value)
+static int trimpot_7376_write(struct comedi_device *dev, uint8_t value)
 {
 	static const int bitstream_length = 7;
 	unsigned int bitstream = value & 0x7f;
@@ -1766,7 +1766,7 @@ static int trimpot_7376_write(struct comedi_device * dev, uint8_t value)
 /* For 1602/16 only
  * ch 0 : adc gain
  * ch 1 : adc postgain offset */
-static int trimpot_8402_write(struct comedi_device * dev, unsigned int channel,
+static int trimpot_8402_write(struct comedi_device *dev, unsigned int channel,
 	uint8_t value)
 {
 	static const int bitstream_length = 10;
@@ -1802,7 +1802,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 	return -1;
 }
 
-static int nvram_read(struct comedi_device * dev, unsigned int address, uint8_t * data)
+static int nvram_read(struct comedi_device *dev, unsigned int address, uint8_t *data)
 {
 	unsigned long iobase = devpriv->s5933_config;
 

commit 70265d24e3404fe798b6edd55a02016b1edb49d7
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Mar 26 09:34:06 2009 +0100

    staging: comedi, remove interrupt.h
    
    Remove interrupt wraparound. Use defines from linux/interrupt.h
    instead.
    
    Change also parameter types of functions taking ISR to irq_handler_t.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: David Schleef <ds@schleef.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 93dac5110149..0b09fc9bd4fb 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -63,6 +63,7 @@ analog triggering on 1602 series
 
 #include "../comedidev.h"
 #include <linux/delay.h>
+#include <linux/interrupt.h>
 
 #include "8253.h"
 #include "8255.h"
@@ -468,7 +469,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				unsigned int trig_num);
 static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
-static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
+static irqreturn_t cb_pcidas_interrupt(int irq, void *d);
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status);
 static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -1476,7 +1477,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	return 0;
 }
 
-static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
+static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 {
 	struct comedi_device *dev = (struct comedi_device *) d;
 	struct comedi_subdevice *s = dev->read_subdev;

commit cf530aa4385c97f668d76c8268d509ef9edebb70
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Mar 27 11:30:44 2009 -0400

    Staging: comedi: remove C99 comments in cb_pcidas.c
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index fcc551651367..93dac5110149 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -70,14 +70,14 @@ analog triggering on 1602 series
 #include "comedi_pci.h"
 #include "comedi_fc.h"
 
-#undef CB_PCIDAS_DEBUG		// disable debugging code
-//#define CB_PCIDAS_DEBUG       // enable debugging code
+#undef CB_PCIDAS_DEBUG		/*  disable debugging code */
+/* #define CB_PCIDAS_DEBUG         enable debugging code */
 
-// PCI vendor number of ComputerBoards/MeasurementComputing
+/* PCI vendor number of ComputerBoards/MeasurementComputing */
 #define PCI_VENDOR_ID_CB	0x1307
-#define TIMER_BASE 100		// 10MHz master clock
-#define AI_BUFFER_SIZE 1024	// maximum fifo size of any supported board
-#define AO_BUFFER_SIZE 1024	// maximum fifo size of any supported board
+#define TIMER_BASE 100		/*  10MHz master clock */
+#define AI_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
+#define AO_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
 #define NUM_CHANNELS_8800 8
 #define NUM_CHANNELS_7376 1
 #define NUM_CHANNELS_8402 2
@@ -85,71 +85,71 @@ analog triggering on 1602 series
 
 /* PCI-DAS base addresses */
 
-// indices of base address regions
+/* indices of base address regions */
 #define S5933_BADRINDEX 0
 #define CONT_STAT_BADRINDEX 1
 #define ADC_FIFO_BADRINDEX 2
 #define PACER_BADRINDEX 3
 #define AO_BADRINDEX 4
-// sizes of io regions
+/* sizes of io regions */
 #define CONT_STAT_SIZE 10
 #define ADC_FIFO_SIZE 4
 #define PACER_SIZE 12
 #define AO_SIZE 4
 
 /* Control/Status registers */
-#define INT_ADCFIFO	0	// INTERRUPT / ADC FIFO register
-#define   INT_EOS 0x1		// interrupt end of scan
-#define   INT_FHF 0x2		// interrupt fifo half full
-#define   INT_FNE 0x3		// interrupt fifo not empty
-#define   INT_MASK 0x3		// mask of interrupt select bits
-#define   INTE 0x4		// interrupt enable
-#define   DAHFIE 0x8		// dac half full interrupt enable
-#define   EOAIE	0x10		// end of aquisition interrupt enable
-#define   DAHFI	0x20		// dac half full read status / write interrupt clear
-#define   EOAI 0x40		// read end of acq. interrupt status / write clear
-#define   INT 0x80		// read interrupt status / write clear
-#define   EOBI 0x200		// read end of burst interrupt status
-#define   ADHFI 0x400		// read half-full interrupt status
-#define   ADNEI 0x800		// read fifo not empty interrupt latch status
-#define   ADNE 0x1000		// read, fifo not empty (realtime, not latched) status
-#define   DAEMIE	0x1000	// write, dac empty interrupt enable
-#define   LADFUL 0x2000		// read fifo overflow / write clear
-#define   DAEMI 0x4000		// dac fifo empty interrupt status / write clear
-
-#define ADCMUX_CONT	2	// ADC CHANNEL MUX AND CONTROL register
+#define INT_ADCFIFO	0	/*  INTERRUPT / ADC FIFO register */
+#define   INT_EOS 0x1		/*  interrupt end of scan */
+#define   INT_FHF 0x2		/*  interrupt fifo half full */
+#define   INT_FNE 0x3		/*  interrupt fifo not empty */
+#define   INT_MASK 0x3		/*  mask of interrupt select bits */
+#define   INTE 0x4		/*  interrupt enable */
+#define   DAHFIE 0x8		/*  dac half full interrupt enable */
+#define   EOAIE	0x10		/*  end of aquisition interrupt enable */
+#define   DAHFI	0x20		/*  dac half full read status / write interrupt clear */
+#define   EOAI 0x40		/*  read end of acq. interrupt status / write clear */
+#define   INT 0x80		/*  read interrupt status / write clear */
+#define   EOBI 0x200		/*  read end of burst interrupt status */
+#define   ADHFI 0x400		/*  read half-full interrupt status */
+#define   ADNEI 0x800		/*  read fifo not empty interrupt latch status */
+#define   ADNE 0x1000		/*  read, fifo not empty (realtime, not latched) status */
+#define   DAEMIE	0x1000	/*  write, dac empty interrupt enable */
+#define   LADFUL 0x2000		/*  read fifo overflow / write clear */
+#define   DAEMI 0x4000		/*  dac fifo empty interrupt status / write clear */
+
+#define ADCMUX_CONT	2	/*  ADC CHANNEL MUX AND CONTROL register */
 #define   BEGIN_SCAN(x)	((x) & 0xf)
 #define   END_SCAN(x)	(((x) & 0xf) << 4)
 #define   GAIN_BITS(x)	(((x) & 0x3) << 8)
-#define   UNIP	0x800		// Analog front-end unipolar for range
-#define   SE	0x400		// Inputs in single-ended mode
-#define   PACER_MASK	0x3000	// pacer source bits
-#define   PACER_INT 0x1000	// internal pacer
-#define   PACER_EXT_FALL	0x2000	// external falling edge
-#define   PACER_EXT_RISE	0x3000	// external rising edge
-#define   EOC	0x4000		// adc not busy
-
-#define TRIG_CONTSTAT 4		// TRIGGER CONTROL/STATUS register
-#define   SW_TRIGGER 0x1	// software start trigger
-#define   EXT_TRIGGER 0x2	// external start trigger
-#define   ANALOG_TRIGGER 0x3	// external analog trigger
-#define   TRIGGER_MASK	0x3	// mask of bits that determine start trigger
-#define   TGEN	0x10		// enable external start trigger
-#define   BURSTE 0x20		// burst mode enable
-#define   XTRCL	0x80		// clear external trigger
-
-#define CALIBRATION_REG	6	// CALIBRATION register
-#define   SELECT_8800_BIT	0x100	// select 8800 caldac
-#define   SELECT_TRIMPOT_BIT	0x200	// select ad7376 trim pot
-#define   SELECT_DAC08_BIT	0x400	// select dac08 caldac
+#define   UNIP	0x800		/*  Analog front-end unipolar for range */
+#define   SE	0x400		/*  Inputs in single-ended mode */
+#define   PACER_MASK	0x3000	/*  pacer source bits */
+#define   PACER_INT 0x1000	/*  internal pacer */
+#define   PACER_EXT_FALL	0x2000	/*  external falling edge */
+#define   PACER_EXT_RISE	0x3000	/*  external rising edge */
+#define   EOC	0x4000		/*  adc not busy */
+
+#define TRIG_CONTSTAT 4		/*  TRIGGER CONTROL/STATUS register */
+#define   SW_TRIGGER 0x1	/*  software start trigger */
+#define   EXT_TRIGGER 0x2	/*  external start trigger */
+#define   ANALOG_TRIGGER 0x3	/*  external analog trigger */
+#define   TRIGGER_MASK	0x3	/*  mask of bits that determine start trigger */
+#define   TGEN	0x10		/*  enable external start trigger */
+#define   BURSTE 0x20		/*  burst mode enable */
+#define   XTRCL	0x80		/*  clear external trigger */
+
+#define CALIBRATION_REG	6	/*  CALIBRATION register */
+#define   SELECT_8800_BIT	0x100	/*  select 8800 caldac */
+#define   SELECT_TRIMPOT_BIT	0x200	/*  select ad7376 trim pot */
+#define   SELECT_DAC08_BIT	0x400	/*  select dac08 caldac */
 #define   CAL_SRC_BITS(x)	(((x) & 0x7) << 11)
-#define   CAL_EN_BIT	0x4000	// read calibration source instead of analog input channel 0
-#define   SERIAL_DATA_IN_BIT	0x8000	// serial data stream going to 8800 and 7376
+#define   CAL_EN_BIT	0x4000	/*  read calibration source instead of analog input channel 0 */
+#define   SERIAL_DATA_IN_BIT	0x8000	/*  serial data stream going to 8800 and 7376 */
 
-#define DAC_CSR	0x8		// dac control and status register
+#define DAC_CSR	0x8		/*  dac control and status register */
 enum dac_csr_bits {
-	DACEN = 0x2,		// dac enable
-	DAC_MODE_UPDATE_BOTH = 0x80,	// update both dacs when dac0 is written
+	DACEN = 0x2,		/*  dac enable */
+	DAC_MODE_UPDATE_BOTH = 0x80,	/*  update both dacs when dac0 is written */
 };
 static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
 {
@@ -160,42 +160,42 @@ static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 	return 0x3 << (8 + 2 * (channel & 0x1));
 };
 
-// bits for 1602 series only
+/* bits for 1602 series only */
 enum dac_csr_bits_1602 {
-	DAC_EMPTY = 0x1,	// dac fifo empty, read, write clear
-	DAC_START = 0x4,	// start/arm dac fifo operations
-	DAC_PACER_MASK = 0x18,	// bits that set dac pacer source
-	DAC_PACER_INT = 0x8,	// dac internal pacing
-	DAC_PACER_EXT_FALL = 0x10,	// dac external pacing, falling edge
-	DAC_PACER_EXT_RISE = 0x18,	// dac external pacing, rising edge
+	DAC_EMPTY = 0x1,	/*  dac fifo empty, read, write clear */
+	DAC_START = 0x4,	/*  start/arm dac fifo operations */
+	DAC_PACER_MASK = 0x18,	/*  bits that set dac pacer source */
+	DAC_PACER_INT = 0x8,	/*  dac internal pacing */
+	DAC_PACER_EXT_FALL = 0x10,	/*  dac external pacing, falling edge */
+	DAC_PACER_EXT_RISE = 0x18,	/*  dac external pacing, rising edge */
 };
 static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 {
-	return 1 << (5 + (channel & 0x1));	// enable channel 0 or 1
+	return 1 << (5 + (channel & 0x1));	/*  enable channel 0 or 1 */
 };
 
 /* analog input fifo */
-#define ADCDATA	0		// ADC DATA register
-#define ADCFIFOCLR	2	// ADC FIFO CLEAR
+#define ADCDATA	0		/*  ADC DATA register */
+#define ADCFIFOCLR	2	/*  ADC FIFO CLEAR */
 
-// pacer, counter, dio registers
+/* pacer, counter, dio registers */
 #define ADC8254 0
 #define DIO_8255 4
 #define DAC8254 8
 
-// analog output registers for 100x, 1200 series
+/* analog output registers for 100x, 1200 series */
 static inline unsigned int DAC_DATA_REG(unsigned int channel)
 {
 	return 2 * (channel & 0x1);
 }
 
 /* analog output registers for 1602 series*/
-#define DACDATA	0		// DAC DATA register
-#define DACFIFOCLR	2	// DAC FIFO CLEAR
+#define DACDATA	0		/*  DAC DATA register */
+#define DACFIFOCLR	2	/*  DAC FIFO CLEAR */
 
-// bit in hexadecimal representation of range index that indicates unipolar input range
+/* bit in hexadecimal representation of range index that indicates unipolar input range */
 #define IS_UNIPOLAR 0x4
-// analog input ranges for most boards
+/* analog input ranges for most boards */
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8,
 	{
@@ -210,7 +210,7 @@ static const struct comedi_lrange cb_pcidas_ranges = {
 		}
 };
 
-// pci-das1001 input ranges
+/* pci-das1001 input ranges */
 static const struct comedi_lrange cb_pcidas_alt_ranges = {
 	8,
 	{
@@ -225,7 +225,7 @@ static const struct comedi_lrange cb_pcidas_alt_ranges = {
 		}
 };
 
-// analog output ranges
+/* analog output ranges */
 static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	4,
 	{
@@ -244,14 +244,14 @@ enum trimpot_model {
 struct cb_pcidas_board {
 	const char *name;
 	unsigned short device_id;
-	int ai_se_chans;	// Inputs in single-ended mode
-	int ai_diff_chans;	// Inputs in differential mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
-	int ao_nchan;		// number of analog out channels
-	int has_ao_fifo;	// analog output has fifo
-	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
-	int fifo_size;		// number of samples fifo can hold
+	int ai_se_chans;	/*  Inputs in single-ended mode */
+	int ai_diff_chans;	/*  Inputs in differential mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
+	int ao_nchan;		/*  number of analog out channels */
+	int has_ao_fifo;	/*  analog output has fifo */
+	int ao_scan_speed;	/*  analog output speed for 1602 series (for a scan, not conversion) */
+	int fifo_size;		/*  number of samples fifo can hold */
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
@@ -374,7 +374,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		},
 };
 
-// Number of boards in cb_pcidas_boards
+/* Number of boards in cb_pcidas_boards */
 #define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(struct cb_pcidas_board))
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
@@ -402,28 +402,28 @@ MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 struct cb_pcidas_private {
 	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
-	// base addresses
+	/*  base addresses */
 	unsigned long s5933_config;
 	unsigned long control_status;
 	unsigned long adc_fifo;
 	unsigned long pacer_counter_dio;
 	unsigned long ao_registers;
-	// divisors of master clock for analog input pacing
+	/*  divisors of master clock for analog input pacing */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	volatile unsigned int count;	// number of analog input samples remaining
-	volatile unsigned int adc_fifo_bits;	// bits to write to interupt/adcfifo register
-	volatile unsigned int s5933_intcsr_bits;	// bits to write to amcc s5933 interrupt control/status register
-	volatile unsigned int ao_control_bits;	// bits to write to ao control and status register
+	volatile unsigned int count;	/*  number of analog input samples remaining */
+	volatile unsigned int adc_fifo_bits;	/*  bits to write to interupt/adcfifo register */
+	volatile unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
+	volatile unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
 	short ai_buffer[AI_BUFFER_SIZE];
 	short ao_buffer[AO_BUFFER_SIZE];
-	// divisors of master clock for analog output pacing
+	/*  divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	volatile unsigned int ao_count;	// number of analog output samples remaining
-	int ao_value[2];	// remember what the analog outputs are set to, to allow readback
-	unsigned int caldac_value[NUM_CHANNELS_8800];	// for readback of caldac
-	unsigned int trimpot_value[NUM_CHANNELS_8402];	// for readback of trimpot
+	volatile unsigned int ao_count;	/*  number of analog output samples remaining */
+	int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
+	unsigned int caldac_value[NUM_CHANNELS_8800];	/*  for readback of caldac */
+	unsigned int trimpot_value[NUM_CHANNELS_8402];	/*  for readback of trimpot */
 	unsigned int dac08_value;
 	unsigned int calibration_source;
 };
@@ -531,16 +531,16 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev->vendor != PCI_VENDOR_ID_CB)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index < N_BOARDS; index++) {
 			if (cb_pcidas_boards[index].device_id != pcidev->device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it->options[0] || it->options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev->bus->number != it->options[0] ||
 					PCI_SLOT(pcidev->devfn) !=
 					it->options[1]) {
@@ -585,11 +585,11 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 		devpriv->ao_registers =
 			pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
 	}
-	// disable and clear interrupts on amcc s5933
+	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
 		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
-	// get irq
+	/*  get irq */
 	if (comedi_request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
 		printk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);
@@ -597,7 +597,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	}
 	dev->irq = devpriv->pci_dev->irq;
 
-	//Initialize dev->board_name
+	/* Initialize dev->board_name */
 	dev->board_name = thisboard->name;
 
 /*
@@ -628,7 +628,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 		s->type = COMEDI_SUBD_AO;
 		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s->n_chan = thisboard->ao_nchan;
-		// analog out resolution is the same as analog input resolution, so use ai_bits
+		/*  analog out resolution is the same as analog input resolution, so use ai_bits */
 		s->maxdata = (1 << thisboard->ai_bits) - 1;
 		s->range_table = &cb_pcidas_ao_ranges;
 		s->insn_read = cb_pcidas_ao_readback_insn;
@@ -650,7 +650,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	s = dev->subdevices + 2;
 	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);
 
-	// serial EEPROM,
+	/*  serial EEPROM, */
 	s = dev->subdevices + 3;
 	s->type = COMEDI_SUBD_MEMORY;
 	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
@@ -658,7 +658,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	s->maxdata = 0xff;
 	s->insn_read = eeprom_read_insn;
 
-	// 8800 caldac
+	/*  8800 caldac */
 	s = dev->subdevices + 4;
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -669,7 +669,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (i = 0; i < s->n_chan; i++)
 		caldac_8800_write(dev, i, s->maxdata / 2);
 
-	// trim potentiometer
+	/*  trim potentiometer */
 	s = dev->subdevices + 5;
 	s->type = COMEDI_SUBD_CALIB;
 	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -685,7 +685,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (i = 0; i < s->n_chan; i++)
 		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
 
-	// dac08 caldac
+	/*  dac08 caldac */
 	s = dev->subdevices + 6;
 	if (thisboard->has_dac08) {
 		s->type = COMEDI_SUBD_CALIB;
@@ -698,13 +698,13 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	} else
 		s->type = COMEDI_SUBD_UNUSED;
 
-	// make sure mailbox 4 is empty
+	/*  make sure mailbox 4 is empty */
 	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
 	devpriv->s5933_intcsr_bits =
 		INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
 		INTCSR_INBOX_FULL_INT;
-	// clear and enable interrupt on amcc s5933
+	/*  clear and enable interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -725,7 +725,7 @@ static int cb_pcidas_detach(struct comedi_device * dev)
 
 	if (devpriv) {
 		if (devpriv->s5933_config) {
-			// disable and clear interrupts on amcc s5933
+			/*  disable and clear interrupts on amcc s5933 */
 			outl(INTCSR_INBOX_INTR_STATUS,
 				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
@@ -760,7 +760,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevic
 	unsigned int bits;
 	static const int timeout = 10000;
 	int channel;
-	// enable calibration input if appropriate
+	/*  enable calibration input if appropriate */
 	if (insn->chanspec & CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
 			devpriv->control_status + CALIBRATION_REG);
@@ -769,13 +769,13 @@ static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevic
 		outw(0, devpriv->control_status + CALIBRATION_REG);
 		channel = CR_CHAN(insn->chanspec);
 	}
-	// set mux limits and gain
+	/*  set mux limits and gain */
 	bits = BEGIN_SCAN(channel) |
 		END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
-	// set unipolar/bipolar
+	/*  set unipolar/bipolar */
 	if (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)
 		bits |= UNIP;
-	// set singleended/differential
+	/*  set singleended/differential */
 	if (CR_AREF(insn->chanspec) != AREF_DIFF)
 		bits |= SE;
 	outw(bits, devpriv->control_status + ADCMUX_CONT);
@@ -836,14 +836,14 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 	return -EINVAL;
 }
 
-// analog output insn for pcidas-1000 and 1200 series
+/* analog output insn for pcidas-1000 and 1200 series */
 static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
 
-	// set channel and range
+	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
@@ -853,25 +853,25 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_s
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
-	// send data
+	/*  send data */
 	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(channel));
 
 	return 1;
 }
 
-// analog output insn for pcidas-1602 series
+/* analog output insn for pcidas-1602 series */
 static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
 
-	// clear dac fifo
+	/*  clear dac fifo */
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
 
-	// set channel and range
+	/*  set channel and range */
 	channel = CR_CHAN(insn->chanspec);
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->ao_control_bits &=
@@ -883,16 +883,16 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_sub
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv->ao_value[channel] = data[0];
-	// send data
+	/*  send data */
 	outw(data[0], devpriv->ao_registers + DACDATA);
 
 	return 1;
 }
 
-// analog output readback insn
-// XXX loses track of analog output value back after an analog ouput command is executed
+/* analog output readback insn */
+/* XXX loses track of analog output value back after an analog ouput command is executed */
 static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1066,7 +1066,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	// make sure trigger sources are compatible with each other
+	/*  make sure trigger sources are compatible with each other */
 	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
 		err++;
 	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
@@ -1138,7 +1138,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		start_chan = CR_CHAN(cmd->chanlist[0]);
@@ -1170,24 +1170,24 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int bits;
 	unsigned long flags;
 
-	// make sure CAL_EN_BIT is disabled
+	/*  make sure CAL_EN_BIT is disabled */
 	outw(0, devpriv->control_status + CALIBRATION_REG);
-	// initialize before settings pacer source and count values
+	/*  initialize before settings pacer source and count values */
 	outw(0, devpriv->control_status + TRIG_CONTSTAT);
-	// clear fifo
+	/*  clear fifo */
 	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
 
-	// set mux limits, gain and pacer source
+	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
 		END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
 		GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
-	// set unipolar/bipolar
+	/*  set unipolar/bipolar */
 	if (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)
 		bits |= UNIP;
-	// set singleended/differential
+	/*  set singleended/differential */
 	if (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)
 		bits |= SE;
-	// set pacer source
+	/*  set pacer source */
 	if (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)
 		bits |= PACER_EXT_RISE;
 	else
@@ -1198,7 +1198,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 	rt_printk("comedi: sent 0x%x to adcmux control\n", bits);
 #endif
 
-	// load counters
+	/*  load counters */
 	if (cmd->convert_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &cmd->convert_arg,
 			cmd->flags & TRIG_ROUND_MASK);
@@ -1206,31 +1206,31 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 		cb_pcidas_load_counters(dev, &cmd->scan_begin_arg,
 			cmd->flags & TRIG_ROUND_MASK);
 
-	// set number of conversions
+	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
 	}
-	// enable interrupts
+	/*  enable interrupts */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= INTE;
 	devpriv->adc_fifo_bits &= ~INT_MASK;
 	if (cmd->flags & TRIG_WAKE_EOS) {
 		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
-			devpriv->adc_fifo_bits |= INT_EOS;	// interrupt end of burst
+			devpriv->adc_fifo_bits |= INT_EOS;	/*  interrupt end of burst */
 		else
-			devpriv->adc_fifo_bits |= INT_FNE;	// interrupt fifo not empty
+			devpriv->adc_fifo_bits |= INT_FNE;	/*  interrupt fifo not empty */
 	} else {
-		devpriv->adc_fifo_bits |= INT_FHF;	//interrupt fifo half full
+		devpriv->adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
 	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
-	// enable (and clear) interrupts
+	/*  enable (and clear) interrupts */
 	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
 		devpriv->control_status + INT_ADCFIFO);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// set start trigger and burst mode
+	/*  set start trigger and burst mode */
 	bits = 0;
 	if (cmd->start_src == TRIG_NOW)
 		bits |= SW_TRIGGER;
@@ -1347,7 +1347,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd->chanlist && cmd->chanlist_len > 1) {
 		if (CR_CHAN(cmd->chanlist[0]) != 0 ||
 			CR_CHAN(cmd->chanlist[1]) != 1) {
@@ -1370,25 +1370,25 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int i;
 	unsigned long flags;
 
-	// set channel limits, gain
+	/*  set channel limits, gain */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	for (i = 0; i < cmd->chanlist_len; i++) {
-		// enable channel
+		/*  enable channel */
 		devpriv->ao_control_bits |=
 			DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
-		// set range
+		/*  set range */
 		devpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),
 			CR_RANGE(cmd->chanlist[i]));
 	}
 
-	// disable analog out before settings pacer source and count values
+	/*  disable analog out before settings pacer source and count values */
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// clear fifo
+	/*  clear fifo */
 	outw(0, devpriv->ao_registers + DACFIFOCLR);
 
-	// load counters
+	/*  load counters */
 	if (cmd->scan_begin_src == TRIG_TIMER) {
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
 			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
@@ -1400,11 +1400,11 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice
 		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,
 			devpriv->ao_divisor2, 2);
 	}
-	// set number of conversions
+	/*  set number of conversions */
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
 	}
-	// set pacer source
+	/*  set pacer source */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	switch (cmd->scan_begin_src) {
 	case TRIG_TIMER:
@@ -1438,7 +1438,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	// load up fifo
+	/*  load up fifo */
 	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)
 		num_points = devpriv->ao_count;
 
@@ -1449,20 +1449,20 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_count -= num_points;
 	}
-	// write data to board's fifo
+	/*  write data to board's fifo */
 	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
 
-	// enable dac half-full and empty interrupts
+	/*  enable dac half-full and empty interrupts */
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
 	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
 #endif
-	// enable and clear interrupts
+	/*  enable and clear interrupts */
 	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
 		devpriv->control_status + INT_ADCFIFO);
 
-	// start dac
+	/*  start dac */
 	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
@@ -1503,9 +1503,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
 		return IRQ_NONE;
 
-	// make sure mailbox 4 is empty
+	/*  make sure mailbox 4 is empty */
 	inl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);
-	// clear interrupt on amcc s5933
+	/*  clear interrupt on amcc s5933 */
 	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -1516,14 +1516,14 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 #endif
 
-	// check for analog output interrupt
+	/*  check for analog output interrupt */
 	if (status & (DAHFI | DAEMI)) {
 		handle_ao_interrupt(dev, status);
 	}
-	// check for analog input interrupts
-	// if fifo half-full
+	/*  check for analog input interrupts */
+	/*  if fifo half-full */
 	if (status & ADHFI) {
-		// read data
+		/*  read data */
 		num_samples = half_fifo;
 		if (async->cmd.stop_src == TRIG_COUNT &&
 			num_samples > devpriv->count) {
@@ -1538,15 +1538,15 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 			async->events |= COMEDI_CB_EOA;
 			cb_pcidas_cancel(dev, s);
 		}
-		// clear half-full interrupt latch
+		/*  clear half-full interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
 		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
-		// else if fifo not empty
+		/*  else if fifo not empty */
 	} else if (status & (ADNEI | EOBI)) {
 		for (i = 0; i < timeout; i++) {
-			// break if fifo is empty
+			/*  break if fifo is empty */
 			if ((ADNE & inw(devpriv->control_status +
 						INT_ADCFIFO)) == 0)
 				break;
@@ -1557,7 +1557,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 				break;
 			}
 		}
-		// clear not-empty interrupt latch
+		/*  clear not-empty interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | INT,
 			devpriv->control_status + INT_ADCFIFO);
@@ -1565,16 +1565,16 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	} else if (status & EOAI) {
 		comedi_error(dev,
 			"bug! encountered end of aquisition interrupt?");
-		// clear EOA interrupt latch
+		/*  clear EOA interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
 			devpriv->control_status + INT_ADCFIFO);
 		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 	}
-	//check for fifo overflow
+	/* check for fifo overflow */
 	if (status & LADFUL) {
 		comedi_error(dev, "fifo overflow");
-		// clear overflow interrupt latch
+		/*  clear overflow interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | LADFUL,
 			devpriv->control_status + INT_ADCFIFO);
@@ -1600,7 +1600,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 	async->events = 0;
 
 	if (status & DAEMI) {
-		// clear dac empty interrupt latch
+		/*  clear dac empty interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAEMI,
 			devpriv->control_status + INT_ADCFIFO);
@@ -1618,7 +1618,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 	} else if (status & DAHFI) {
 		unsigned int num_bytes;
 
-		// figure out how many points we are writing to fifo
+		/*  figure out how many points we are writing to fifo */
 		num_points = half_fifo;
 		if (cmd->stop_src == TRIG_COUNT &&
 			devpriv->ao_count < num_points)
@@ -1631,10 +1631,10 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			devpriv->ao_count -= num_points;
 		}
-		// write data to board's fifo
+		/*  write data to board's fifo */
 		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
 			num_points);
-		// clear half-full interrupt latch
+		/*  clear half-full interrupt latch */
 		comedi_spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | DAHFI,
 			devpriv->control_status + INT_ADCFIFO);
@@ -1650,14 +1650,14 @@ static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
-	// disable interrupts
+	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	// disable start trigger source and burst mode
+	/*  disable start trigger source and burst mode */
 	outw(0, devpriv->control_status + TRIG_CONTSTAT);
-	// software pacer source
+	/*  software pacer source */
 	outw(0, devpriv->control_status + ADCMUX_CONT);
 
 	return 0;
@@ -1670,11 +1670,11 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&dev->spinlock, flags);
-	// disable interrupts
+	/*  disable interrupts */
 	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
 	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
 
-	// disable output
+	/*  disable output */
 	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
 	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);

commit c77e25898523395b56e1d120195e1ad2e3efa14d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:10:50 2009 -0400

    Staging: comedi: Remove cb_pcidas_private typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 2d73f64002b1..fcc551651367 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -399,7 +399,7 @@ MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
    feel free to suggest moving the variable to the struct comedi_device struct.  */
-typedef struct {
+struct cb_pcidas_private {
 	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
 	// base addresses
@@ -426,13 +426,13 @@ typedef struct {
 	unsigned int trimpot_value[NUM_CHANNELS_8402];	// for readback of trimpot
 	unsigned int dac08_value;
 	unsigned int calibration_source;
-} cb_pcidas_private;
+};
 
 /*
  * most drivers define the following macro to make it easy to
  * access the private structure.
  */
-#define devpriv ((cb_pcidas_private *)dev->private)
+#define devpriv ((struct cb_pcidas_private *)dev->private)
 
 /*
  * The struct comedi_driver structure tells the Comedi core module
@@ -520,7 +520,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 /*
  * Allocate the private structure area.
  */
-	if (alloc_private(dev, sizeof(cb_pcidas_private)) < 0)
+	if (alloc_private(dev, sizeof(struct cb_pcidas_private)) < 0)
 		return -ENOMEM;
 
 /*

commit 5c2670cba2a5fd1a27f938ae11b3a24518d999db
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:10:44 2009 -0400

    Staging: comedi: Remove cb_pcidas_board typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index b0366e81445c..2d73f64002b1 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -241,7 +241,7 @@ enum trimpot_model {
 	AD8402,
 };
 
-typedef struct cb_pcidas_board_struct {
+struct cb_pcidas_board {
 	const char *name;
 	unsigned short device_id;
 	int ai_se_chans;	// Inputs in single-ended mode
@@ -255,9 +255,9 @@ typedef struct cb_pcidas_board_struct {
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
-} cb_pcidas_board;
+};
 
-static const cb_pcidas_board cb_pcidas_boards[] = {
+static const struct cb_pcidas_board cb_pcidas_boards[] = {
 	{
 	      name:	"pci-das1602/16",
 	      device_id:0x1,
@@ -375,7 +375,7 @@ static const cb_pcidas_board cb_pcidas_boards[] = {
 };
 
 // Number of boards in cb_pcidas_boards
-#define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(cb_pcidas_board))
+#define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(struct cb_pcidas_board))
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
 	{PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
@@ -394,7 +394,7 @@ MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const cb_pcidas_board *)dev->board_ptr)
+#define thisboard ((const struct cb_pcidas_board *)dev->board_ptr)
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,

commit 0707bb04be89b18ee83b5a997e36cc585f0b988d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:06:20 2009 -0400

    Staging: comedi: Remove comedi_devconfig typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index f2d09e3e7fa8..b0366e81445c 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -440,7 +440,7 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 static int cb_pcidas_detach(struct comedi_device * dev);
 static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas",
@@ -508,7 +508,7 @@ static inline unsigned int cal_enable_bits(struct comedi_device * dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it)
+static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig * it)
 {
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;

commit 90035c0886b256d75bced13b3b3cea5234aff136
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:53 2009 -0400

    Staging: comedi: Remove comedi_insn typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 70cb220f6422..f2d09e3e7fa8 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -450,15 +450,15 @@ static struct comedi_driver driver_cb_pcidas = {
 };
 
 static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_cmd * cmd);
@@ -475,22 +475,22 @@ static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevi
 static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
 	int round_flags);
 static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_trimpot_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
 static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int dac08_write(struct comedi_device * dev, unsigned int value);
 static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data);
+	struct comedi_insn * insn, unsigned int * data);
 static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
 static int trimpot_7376_write(struct comedi_device * dev, uint8_t value);
@@ -754,7 +754,7 @@ static int cb_pcidas_detach(struct comedi_device * dev)
  * mode.
  */
 static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	unsigned int bits;
@@ -821,7 +821,7 @@ static int ai_config_calibration_source(struct comedi_device * dev, unsigned int
 }
 
 static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
 
@@ -838,7 +838,7 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 
 // analog output insn for pcidas-1000 and 1200 series
 static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
@@ -863,7 +863,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_s
 
 // analog output insn for pcidas-1602 series
 static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
@@ -894,7 +894,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_sub
 // analog output readback insn
 // XXX loses track of analog output value back after an analog ouput command is executed
 static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -902,7 +902,7 @@ static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_
 }
 
 static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	uint8_t nvram_data;
 	int retval;
@@ -917,7 +917,7 @@ static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -925,7 +925,7 @@ static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
@@ -954,13 +954,13 @@ static int dac08_write(struct comedi_device * dev, unsigned int value)
 }
 
 static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	return dac08_write(dev, data[0]);
 }
 
 static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->dac08_value;
 
@@ -991,7 +991,7 @@ static int cb_pcidas_trimpot_write(struct comedi_device * dev,
 }
 
 static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -999,7 +999,7 @@ static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevic
 }
 
 static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_insn * insn, unsigned int * data)
+	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 

commit ea6d0d4cab4f4f2d6a88f3bce4707fe92696fd3f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:47 2009 -0400

    Staging: comedi: Remove comedi_cmd typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 1dcf7dde78ee..70cb220f6422 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -461,13 +461,13 @@ static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_
 	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
 static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 				struct comedi_subdevice *subdev,
 				unsigned int trig_num);
 static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd);
+	struct comedi_cmd * cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status);
 static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
@@ -1009,7 +1009,7 @@ static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1166,7 +1166,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int bits;
 	unsigned long flags;
 
@@ -1251,7 +1251,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 }
 
 static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
-	comedi_cmd * cmd)
+	struct comedi_cmd * cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1366,7 +1366,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdev
 static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	unsigned long flags;
 
@@ -1432,7 +1432,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 {
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &s->async->cmd;
+	struct comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 
 	if (trig_num != 0)
@@ -1592,7 +1592,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
 	struct comedi_async *async = s->async;
-	comedi_cmd *cmd = &async->cmd;
+	struct comedi_cmd *cmd = &async->cmd;
 	unsigned int half_fifo = thisboard->fifo_size / 2;
 	unsigned int num_points;
 	unsigned int flags;

commit 9ced1de69125b60f40127eddaa3be2a92bb0a1df
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:31 2009 -0400

    Staging: comedi: Remove comedi_lrange typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 75bf1d173509..1dcf7dde78ee 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -196,7 +196,7 @@ static inline unsigned int DAC_DATA_REG(unsigned int channel)
 // bit in hexadecimal representation of range index that indicates unipolar input range
 #define IS_UNIPOLAR 0x4
 // analog input ranges for most boards
-static const comedi_lrange cb_pcidas_ranges = {
+static const struct comedi_lrange cb_pcidas_ranges = {
 	8,
 	{
 			BIP_RANGE(10),
@@ -211,7 +211,7 @@ static const comedi_lrange cb_pcidas_ranges = {
 };
 
 // pci-das1001 input ranges
-static const comedi_lrange cb_pcidas_alt_ranges = {
+static const struct comedi_lrange cb_pcidas_alt_ranges = {
 	8,
 	{
 			BIP_RANGE(10),
@@ -226,7 +226,7 @@ static const comedi_lrange cb_pcidas_alt_ranges = {
 };
 
 // analog output ranges
-static const comedi_lrange cb_pcidas_ao_ranges = {
+static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	4,
 	{
 			BIP_RANGE(5),
@@ -252,7 +252,7 @@ typedef struct cb_pcidas_board_struct {
 	int has_ao_fifo;	// analog output has fifo
 	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
 	int fifo_size;		// number of samples fifo can hold
-	const comedi_lrange *ranges;
+	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
 } cb_pcidas_board;

commit 139dfbdfacb02e3ef3df936d2fabd1ad5f14ea88
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:25 2009 -0400

    Staging: comedi: Remove comedi_driver typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 53fa8ee0fb7b..75bf1d173509 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -435,14 +435,14 @@ typedef struct {
 #define devpriv ((cb_pcidas_private *)dev->private)
 
 /*
- * The comedi_driver structure tells the Comedi core module
+ * The struct comedi_driver structure tells the Comedi core module
  * which functions to call to configure/deconfigure (attach/detach)
  * the board, and also about the kernel module that contains
  * the device code.
  */
 static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it);
 static int cb_pcidas_detach(struct comedi_device * dev);
-static comedi_driver driver_cb_pcidas = {
+static struct comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas",
       module:THIS_MODULE,
       attach:cb_pcidas_attach,

commit d163679ceec20c50f9aee880fa76c0c1185244a8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:20 2009 -0400

    Staging: comedi: Remove comedi_async typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index aa431466053e..53fa8ee0fb7b 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -449,7 +449,7 @@ static comedi_driver driver_cb_pcidas = {
       detach:cb_pcidas_detach,
 };
 
-static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
+static int cb_pcidas_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
@@ -463,8 +463,9 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
-static int cb_pcidas_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subdev,
-	unsigned int trig_num);
+static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
+				struct comedi_subdevice *subdev,
+				unsigned int trig_num);
 static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
@@ -1164,7 +1165,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 
 static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int bits;
 	unsigned long flags;
@@ -1364,7 +1365,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdev
 
 static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int i;
 	unsigned long flags;
@@ -1425,11 +1426,12 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-static int cb_pcidas_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
-	unsigned int trig_num)
+static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
+				struct comedi_subdevice *s,
+				unsigned int trig_num)
 {
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned long flags;
 
@@ -1478,7 +1480,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = (struct comedi_device *) d;
 	struct comedi_subdevice *s = dev->read_subdev;
-	comedi_async *async;
+	struct comedi_async *async;
 	int status, s5933_status;
 	int half_fifo = thisboard->fifo_size / 2;
 	unsigned int num_samples, i;
@@ -1589,7 +1591,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 {
 	struct comedi_subdevice *s = dev->write_subdev;
-	comedi_async *async = s->async;
+	struct comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int half_fifo = thisboard->fifo_size / 2;
 	unsigned int num_points;
@@ -1642,7 +1644,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 	comedi_event(dev, s);
 }
 
-// cancel analog input command
+/* cancel analog input command */
 static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
@@ -1661,8 +1663,9 @@ static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice
 	return 0;
 }
 
-// cancel analog output command
-static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
+/* cancel analog output command */
+static int cb_pcidas_ao_cancel(struct comedi_device *dev,
+			       struct comedi_subdevice *s)
 {
 	unsigned long flags;
 

commit 34c43922e62708d45e9660eee4b4f1fb7b4bf2c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:14 2009 -0400

    Staging: comedi: Remove comedi_subdevice typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 7a3564e51244..aa431466053e 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -449,46 +449,46 @@ static comedi_driver driver_cb_pcidas = {
       detach:cb_pcidas_detach,
 };
 
-static int cb_pcidas_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int cb_pcidas_ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ao_inttrig(struct comedi_device * dev, comedi_subdevice * subdev,
+static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s);
+static int cb_pcidas_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * subdev,
 	unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status);
-static int cb_pcidas_cancel(struct comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
+static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s);
 static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
 	int round_flags);
-static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int caldac_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int caldac_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int trimpot_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_trimpot_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
-static int trimpot_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dac08_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int dac08_write(struct comedi_device * dev, unsigned int value);
-static int dac08_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
 static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
@@ -509,7 +509,7 @@ static inline unsigned int cal_enable_bits(struct comedi_device * dev)
  */
 static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
-	comedi_subdevice *s;
+	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
 	int index;
 	int i;
@@ -752,7 +752,7 @@ static int cb_pcidas_detach(struct comedi_device * dev)
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcidas_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -819,7 +819,7 @@ static int ai_config_calibration_source(struct comedi_device * dev, unsigned int
 	return 2;
 }
 
-static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
@@ -836,7 +836,7 @@ static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output insn for pcidas-1000 and 1200 series
-static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
@@ -861,7 +861,7 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, comedi_subdevic
 }
 
 // analog output insn for pcidas-1602 series
-static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
@@ -892,7 +892,7 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, comedi_subdevice
 
 // analog output readback insn
 // XXX loses track of analog output value back after an analog ouput command is executed
-static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
@@ -900,7 +900,7 @@ static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, comedi_subdevi
 	return 1;
 }
 
-static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	uint8_t nvram_data;
@@ -915,7 +915,7 @@ static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int caldac_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int caldac_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
@@ -923,7 +923,7 @@ static int caldac_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return caldac_8800_write(dev, channel, data[0]);
 }
 
-static int caldac_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int caldac_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
@@ -952,13 +952,13 @@ static int dac08_write(struct comedi_device * dev, unsigned int value)
 	return 1;
 }
 
-static int dac08_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dac08_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	return dac08_write(dev, data[0]);
 }
 
-static int dac08_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int dac08_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->dac08_value;
@@ -989,7 +989,7 @@ static int cb_pcidas_trimpot_write(struct comedi_device * dev,
 	return 1;
 }
 
-static int trimpot_write_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int trimpot_write_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -997,7 +997,7 @@ static int trimpot_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return cb_pcidas_trimpot_write(dev, channel, data[0]);
 }
 
-static int trimpot_read_insn(struct comedi_device * dev, comedi_subdevice * s,
+static int trimpot_read_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -1007,7 +1007,7 @@ static int trimpot_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1162,7 +1162,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s
 	return 0;
 }
 
-static int cb_pcidas_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1249,7 +1249,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1362,7 +1362,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s
 	return 0;
 }
 
-static int cb_pcidas_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1425,7 +1425,7 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int cb_pcidas_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_inttrig(struct comedi_device * dev, struct comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
@@ -1477,7 +1477,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 {
 	struct comedi_device *dev = (struct comedi_device *) d;
-	comedi_subdevice *s = dev->read_subdev;
+	struct comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	int status, s5933_status;
 	int half_fifo = thisboard->fifo_size / 2;
@@ -1588,7 +1588,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 
 static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 {
-	comedi_subdevice *s = dev->write_subdev;
+	struct comedi_subdevice *s = dev->write_subdev;
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
 	unsigned int half_fifo = thisboard->fifo_size / 2;
@@ -1643,7 +1643,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 }
 
 // cancel analog input command
-static int cb_pcidas_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1662,7 +1662,7 @@ static int cb_pcidas_cancel(struct comedi_device * dev, comedi_subdevice * s)
 }
 
 // cancel analog output command
-static int cb_pcidas_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ao_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned long flags;
 

commit 71b5f4f11971dea972832ad63a994c7e5b45db6b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:08 2009 -0400

    Staging: comedi: Remove comedi_device typedef
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index c98fb6de3d41..7a3564e51244 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -398,7 +398,7 @@ MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device struct.  */
 typedef struct {
 	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
@@ -440,8 +440,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int cb_pcidas_attach(comedi_device * dev, comedi_devconfig * it);
-static int cb_pcidas_detach(comedi_device * dev);
+static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it);
+static int cb_pcidas_detach(struct comedi_device * dev);
 static comedi_driver driver_cb_pcidas = {
       driver_name:"cb_pcidas",
       module:THIS_MODULE,
@@ -449,56 +449,56 @@ static comedi_driver driver_cb_pcidas = {
       detach:cb_pcidas_detach,
 };
 
-static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
-static int cb_pcidas_ao_cmd(comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * subdev,
+static int cb_pcidas_ao_cmd(struct comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ao_inttrig(struct comedi_device * dev, comedi_subdevice * subdev,
 	unsigned int trig_num);
-static int cb_pcidas_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
-static void handle_ao_interrupt(comedi_device * dev, unsigned int status);
-static int cb_pcidas_cancel(comedi_device * dev, comedi_subdevice * s);
-static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s);
-static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
+static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status);
+static int cb_pcidas_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ao_cancel(struct comedi_device * dev, comedi_subdevice * s);
+static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
 	int round_flags);
-static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int caldac_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int caldac_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int trimpot_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int cb_pcidas_trimpot_write(comedi_device * dev, unsigned int channel,
+static int cb_pcidas_trimpot_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
-static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int trimpot_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int dac08_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int dac08_write(comedi_device * dev, unsigned int value);
-static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int dac08_write(struct comedi_device * dev, unsigned int value);
+static int dac08_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data);
-static int caldac_8800_write(comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
-static int trimpot_7376_write(comedi_device * dev, uint8_t value);
-static int trimpot_8402_write(comedi_device * dev, unsigned int channel,
+static int trimpot_7376_write(struct comedi_device * dev, uint8_t value);
+static int trimpot_8402_write(struct comedi_device * dev, unsigned int channel,
 	uint8_t value);
-static int nvram_read(comedi_device * dev, unsigned int address,
+static int nvram_read(struct comedi_device * dev, unsigned int address,
 	uint8_t * data);
 
-static inline unsigned int cal_enable_bits(comedi_device * dev)
+static inline unsigned int cal_enable_bits(struct comedi_device * dev)
 {
 	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
 }
@@ -507,7 +507,7 @@ static inline unsigned int cal_enable_bits(comedi_device * dev)
  * Attach is called by the Comedi core to configure the driver
  * for a particular board.
  */
-static int cb_pcidas_attach(comedi_device * dev, comedi_devconfig * it)
+static int cb_pcidas_attach(struct comedi_device * dev, comedi_devconfig * it)
 {
 	comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -718,7 +718,7 @@ static int cb_pcidas_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev->private and dev->subdevices are
  * deallocated automatically by the core.
  */
-static int cb_pcidas_detach(comedi_device * dev)
+static int cb_pcidas_detach(struct comedi_device * dev)
 {
 	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
 
@@ -752,7 +752,7 @@ static int cb_pcidas_detach(comedi_device * dev)
  * "instructions" read/write data in "one-shot" or "software-triggered"
  * mode.
  */
-static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_rinsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
@@ -804,7 +804,7 @@ static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ai_config_calibration_source(comedi_device * dev, unsigned int * data)
+static int ai_config_calibration_source(struct comedi_device * dev, unsigned int * data)
 {
 	static const int num_calibration_sources = 8;
 	unsigned int source = data[1];
@@ -819,7 +819,7 @@ static int ai_config_calibration_source(comedi_device * dev, unsigned int * data
 	return 2;
 }
 
-static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+static int ai_config_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
@@ -836,7 +836,7 @@ static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output insn for pcidas-1000 and 1200 series
-static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
@@ -861,7 +861,7 @@ static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
 }
 
 // analog output insn for pcidas-1602 series
-static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
@@ -892,7 +892,7 @@ static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
 
 // analog output readback insn
 // XXX loses track of analog output value back after an analog ouput command is executed
-static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
@@ -900,7 +900,7 @@ static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int eeprom_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	uint8_t nvram_data;
@@ -915,7 +915,7 @@ static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int caldac_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
@@ -923,7 +923,7 @@ static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
 	return caldac_8800_write(dev, channel, data[0]);
 }
 
-static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int caldac_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
@@ -932,7 +932,7 @@ static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* 1602/16 pregain offset */
-static int dac08_write(comedi_device * dev, unsigned int value)
+static int dac08_write(struct comedi_device * dev, unsigned int value)
 {
 	if (devpriv->dac08_value == value)
 		return 1;
@@ -952,13 +952,13 @@ static int dac08_write(comedi_device * dev, unsigned int value)
 	return 1;
 }
 
-static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int dac08_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	return dac08_write(dev, data[0]);
 }
 
-static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int dac08_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->dac08_value;
@@ -966,7 +966,7 @@ static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int cb_pcidas_trimpot_write(comedi_device * dev,
+static int cb_pcidas_trimpot_write(struct comedi_device * dev,
 	unsigned int channel, unsigned int value)
 {
 	if (devpriv->trimpot_value[channel] == value)
@@ -989,7 +989,7 @@ static int cb_pcidas_trimpot_write(comedi_device * dev,
 	return 1;
 }
 
-static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
+static int trimpot_write_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -997,7 +997,7 @@ static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
 	return cb_pcidas_trimpot_write(dev, channel, data[0]);
 }
 
-static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
+static int trimpot_read_insn(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
@@ -1007,7 +1007,7 @@ static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1162,7 +1162,7 @@ static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ai_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1249,7 +1249,7 @@ static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int cb_pcidas_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd)
 {
 	int err = 0;
@@ -1362,7 +1362,7 @@ static int cb_pcidas_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int cb_pcidas_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ao_cmd(struct comedi_device * dev, comedi_subdevice * s)
 {
 	comedi_async *async = s->async;
 	comedi_cmd *cmd = &async->cmd;
@@ -1425,7 +1425,7 @@ static int cb_pcidas_ao_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int cb_pcidas_ao_inttrig(struct comedi_device * dev, comedi_subdevice * s,
 	unsigned int trig_num)
 {
 	unsigned int num_bytes, num_points = thisboard->fifo_size;
@@ -1476,7 +1476,7 @@ static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 
 static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 {
-	comedi_device *dev = (comedi_device *) d;
+	struct comedi_device *dev = (struct comedi_device *) d;
 	comedi_subdevice *s = dev->read_subdev;
 	comedi_async *async;
 	int status, s5933_status;
@@ -1586,7 +1586,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static void handle_ao_interrupt(comedi_device * dev, unsigned int status)
+static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 {
 	comedi_subdevice *s = dev->write_subdev;
 	comedi_async *async = s->async;
@@ -1643,7 +1643,7 @@ static void handle_ao_interrupt(comedi_device * dev, unsigned int status)
 }
 
 // cancel analog input command
-static int cb_pcidas_cancel(comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1662,7 +1662,7 @@ static int cb_pcidas_cancel(comedi_device * dev, comedi_subdevice * s)
 }
 
 // cancel analog output command
-static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+static int cb_pcidas_ao_cancel(struct comedi_device * dev, comedi_subdevice * s)
 {
 	unsigned long flags;
 
@@ -1679,7 +1679,7 @@ static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
+static void cb_pcidas_load_counters(struct comedi_device * dev, unsigned int *ns,
 	int rounding_flags)
 {
 	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
@@ -1692,7 +1692,7 @@ static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
 		devpriv->divisor2, 2);
 }
 
-static void write_calibration_bitstream(comedi_device * dev,
+static void write_calibration_bitstream(struct comedi_device * dev,
 	unsigned int register_bits, unsigned int bitstream,
 	unsigned int bitstream_length)
 {
@@ -1709,7 +1709,7 @@ static void write_calibration_bitstream(comedi_device * dev,
 	}
 }
 
-static int caldac_8800_write(comedi_device * dev, unsigned int address,
+static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value)
 {
 	static const int num_caldac_channels = 8;
@@ -1739,7 +1739,7 @@ static int caldac_8800_write(comedi_device * dev, unsigned int address,
 	return 1;
 }
 
-static int trimpot_7376_write(comedi_device * dev, uint8_t value)
+static int trimpot_7376_write(struct comedi_device * dev, uint8_t value)
 {
 	static const int bitstream_length = 7;
 	unsigned int bitstream = value & 0x7f;
@@ -1762,7 +1762,7 @@ static int trimpot_7376_write(comedi_device * dev, uint8_t value)
 /* For 1602/16 only
  * ch 0 : adc gain
  * ch 1 : adc postgain offset */
-static int trimpot_8402_write(comedi_device * dev, unsigned int channel,
+static int trimpot_8402_write(struct comedi_device * dev, unsigned int channel,
 	uint8_t value)
 {
 	static const int bitstream_length = 10;
@@ -1798,7 +1798,7 @@ static int wait_for_nvram_ready(unsigned long s5933_base_addr)
 	return -1;
 }
 
-static int nvram_read(comedi_device * dev, unsigned int address, uint8_t * data)
+static int nvram_read(struct comedi_device * dev, unsigned int address, uint8_t * data)
 {
 	unsigned long iobase = devpriv->s5933_config;
 

commit 790c55415aa31f4c732729f94d2c3a54f7d3bfc2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Mar 16 22:05:02 2009 -0400

    Staging: comedi: Remove lsampl_t and sampl_t typedefs
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 63c8a802f599..c98fb6de3d41 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -415,8 +415,8 @@ typedef struct {
 	volatile unsigned int adc_fifo_bits;	// bits to write to interupt/adcfifo register
 	volatile unsigned int s5933_intcsr_bits;	// bits to write to amcc s5933 interrupt control/status register
 	volatile unsigned int ao_control_bits;	// bits to write to ao control and status register
-	sampl_t ai_buffer[AI_BUFFER_SIZE];
-	sampl_t ao_buffer[AO_BUFFER_SIZE];
+	short ai_buffer[AI_BUFFER_SIZE];
+	short ao_buffer[AO_BUFFER_SIZE];
 	// divisors of master clock for analog output pacing
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
@@ -450,15 +450,15 @@ static comedi_driver driver_cb_pcidas = {
 };
 
 static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
@@ -474,22 +474,22 @@ static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s);
 static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
 	int round_flags);
 static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int cb_pcidas_trimpot_write(comedi_device * dev, unsigned int channel,
-	lsampl_t value);
+	unsigned int value);
 static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int dac08_write(comedi_device * dev, lsampl_t value);
+	comedi_insn * insn, unsigned int * data);
+static int dac08_write(comedi_device * dev, unsigned int value);
 static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+	comedi_insn * insn, unsigned int * data);
 static int caldac_8800_write(comedi_device * dev, unsigned int address,
 	uint8_t value);
 static int trimpot_7376_write(comedi_device * dev, uint8_t value);
@@ -753,7 +753,7 @@ static int cb_pcidas_detach(comedi_device * dev)
  * mode.
  */
 static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int n, i;
 	unsigned int bits;
@@ -804,10 +804,10 @@ static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
+static int ai_config_calibration_source(comedi_device * dev, unsigned int * data)
 {
 	static const int num_calibration_sources = 8;
-	lsampl_t source = data[1];
+	unsigned int source = data[1];
 
 	if (source >= num_calibration_sources) {
 		printk("invalid calibration source: %i\n", source);
@@ -820,7 +820,7 @@ static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
 }
 
 static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int id = data[0];
 
@@ -837,7 +837,7 @@ static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
 
 // analog output insn for pcidas-1000 and 1200 series
 static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
@@ -862,7 +862,7 @@ static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
 
 // analog output insn for pcidas-1602 series
 static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
@@ -893,7 +893,7 @@ static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
 // analog output readback insn
 // XXX loses track of analog output value back after an analog ouput command is executed
 static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
 
@@ -901,7 +901,7 @@ static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	uint8_t nvram_data;
 	int retval;
@@ -916,7 +916,7 @@ static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	const unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -924,7 +924,7 @@ static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
 
@@ -932,7 +932,7 @@ static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 /* 1602/16 pregain offset */
-static int dac08_write(comedi_device * dev, lsampl_t value)
+static int dac08_write(comedi_device * dev, unsigned int value)
 {
 	if (devpriv->dac08_value == value)
 		return 1;
@@ -953,13 +953,13 @@ static int dac08_write(comedi_device * dev, lsampl_t value)
 }
 
 static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	return dac08_write(dev, data[0]);
 }
 
 static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	data[0] = devpriv->dac08_value;
 
@@ -967,7 +967,7 @@ static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int cb_pcidas_trimpot_write(comedi_device * dev,
-	unsigned int channel, lsampl_t value)
+	unsigned int channel, unsigned int value)
 {
 	if (devpriv->trimpot_value[channel] == value)
 		return 1;
@@ -990,7 +990,7 @@ static int cb_pcidas_trimpot_write(comedi_device * dev,
 }
 
 static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -998,7 +998,7 @@ static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
 }
 
 static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+	comedi_insn * insn, unsigned int * data)
 {
 	unsigned int channel = CR_CHAN(insn->chanspec);
 
@@ -1441,8 +1441,8 @@ static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
 		num_points = devpriv->ao_count;
 
 	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-		num_points * sizeof(sampl_t));
-	num_points = num_bytes / sizeof(sampl_t);
+		num_points * sizeof(short));
+	num_points = num_bytes / sizeof(short);
 
 	if (cmd->stop_src == TRIG_COUNT) {
 		devpriv->ao_count -= num_points;
@@ -1530,7 +1530,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
 			num_samples);
 		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
-			num_samples * sizeof(sampl_t));
+			num_samples * sizeof(short));
 		devpriv->count -= num_samples;
 		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {
 			async->events |= COMEDI_CB_EOA;
@@ -1623,8 +1623,8 @@ static void handle_ao_interrupt(comedi_device * dev, unsigned int status)
 			num_points = devpriv->ao_count;
 		num_bytes =
 			cfc_read_array_from_buffer(s, devpriv->ao_buffer,
-			num_points * sizeof(sampl_t));
-		num_points = num_bytes / sizeof(sampl_t);
+			num_points * sizeof(short));
+		num_points = num_bytes / sizeof(short);
 
 		if (async->cmd.stop_src == TRIG_COUNT) {
 			devpriv->ao_count -= num_points;

commit 59c7dd3dc37dc42339406d08f1cde4d6194a4ccf
Author: Ivan Martinez <imr@oersted.dtu.dk>
Date:   Thu Feb 12 15:47:34 2009 -0800

    Staging: comedi: add cb_pcidas driver
    
    For MeasurementComputing PCI-DAS series with the AMCC S5933 PCI
    controller
    
    From: Ivan Martinez <imr@oersted.dtu.dk>
    Cc: David Schleef <ds@schleef.org>
    Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
    Cc: Ian Abbott <abbotti@mev.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
new file mode 100644
index 000000000000..63c8a802f599
--- /dev/null
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -0,0 +1,1828 @@
+/*
+    comedi/drivers/cb_pcidas.c
+
+    Developed by Ivan Martinez and Frank Mori Hess, with valuable help from
+    David Schleef and the rest of the Comedi developers comunity.
+
+    Copyright (C) 2001-2003 Ivan Martinez <imr@oersted.dtu.dk>
+    Copyright (C) 2001,2002 Frank Mori Hess <fmhess@users.sourceforge.net>
+
+    COMEDI - Linux Control and Measurement Device Interface
+    Copyright (C) 1997-8 David A. Schleef <ds@schleef.org>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+************************************************************************
+*/
+/*
+Driver: cb_pcidas
+Description: MeasurementComputing PCI-DAS series with the AMCC S5933 PCI controller
+Author: Ivan Martinez <imr@oersted.dtu.dk>,
+  Frank Mori Hess <fmhess@users.sourceforge.net>
+Updated: 2003-3-11
+Devices: [Measurement Computing] PCI-DAS1602/16 (cb_pcidas),
+  PCI-DAS1602/16jr, PCI-DAS1602/12, PCI-DAS1200, PCI-DAS1200jr,
+  PCI-DAS1000, PCI-DAS1001, PCI_DAS1002
+
+Status:
+  There are many reports of the driver being used with most of the
+  supported cards. Despite no detailed log is maintained, it can
+  be said that the driver is quite tested and stable.
+
+  The boards may be autocalibrated using the comedi_calibrate
+  utility.
+
+Configuration options:
+  [0] - PCI bus of device (optional)
+  [1] - PCI slot of device (optional)
+  If bus/slot is not specified, the first supported
+  PCI device found will be used.
+
+For commands, the scanned channels must be consecutive
+(i.e. 4-5-6-7, 2-3-4,...), and must all have the same
+range and aref.
+*/
+/*
+
+TODO:
+
+analog triggering on 1602 series
+*/
+
+#include "../comedidev.h"
+#include <linux/delay.h>
+
+#include "8253.h"
+#include "8255.h"
+#include "amcc_s5933.h"
+#include "comedi_pci.h"
+#include "comedi_fc.h"
+
+#undef CB_PCIDAS_DEBUG		// disable debugging code
+//#define CB_PCIDAS_DEBUG       // enable debugging code
+
+// PCI vendor number of ComputerBoards/MeasurementComputing
+#define PCI_VENDOR_ID_CB	0x1307
+#define TIMER_BASE 100		// 10MHz master clock
+#define AI_BUFFER_SIZE 1024	// maximum fifo size of any supported board
+#define AO_BUFFER_SIZE 1024	// maximum fifo size of any supported board
+#define NUM_CHANNELS_8800 8
+#define NUM_CHANNELS_7376 1
+#define NUM_CHANNELS_8402 2
+#define NUM_CHANNELS_DAC08 1
+
+/* PCI-DAS base addresses */
+
+// indices of base address regions
+#define S5933_BADRINDEX 0
+#define CONT_STAT_BADRINDEX 1
+#define ADC_FIFO_BADRINDEX 2
+#define PACER_BADRINDEX 3
+#define AO_BADRINDEX 4
+// sizes of io regions
+#define CONT_STAT_SIZE 10
+#define ADC_FIFO_SIZE 4
+#define PACER_SIZE 12
+#define AO_SIZE 4
+
+/* Control/Status registers */
+#define INT_ADCFIFO	0	// INTERRUPT / ADC FIFO register
+#define   INT_EOS 0x1		// interrupt end of scan
+#define   INT_FHF 0x2		// interrupt fifo half full
+#define   INT_FNE 0x3		// interrupt fifo not empty
+#define   INT_MASK 0x3		// mask of interrupt select bits
+#define   INTE 0x4		// interrupt enable
+#define   DAHFIE 0x8		// dac half full interrupt enable
+#define   EOAIE	0x10		// end of aquisition interrupt enable
+#define   DAHFI	0x20		// dac half full read status / write interrupt clear
+#define   EOAI 0x40		// read end of acq. interrupt status / write clear
+#define   INT 0x80		// read interrupt status / write clear
+#define   EOBI 0x200		// read end of burst interrupt status
+#define   ADHFI 0x400		// read half-full interrupt status
+#define   ADNEI 0x800		// read fifo not empty interrupt latch status
+#define   ADNE 0x1000		// read, fifo not empty (realtime, not latched) status
+#define   DAEMIE	0x1000	// write, dac empty interrupt enable
+#define   LADFUL 0x2000		// read fifo overflow / write clear
+#define   DAEMI 0x4000		// dac fifo empty interrupt status / write clear
+
+#define ADCMUX_CONT	2	// ADC CHANNEL MUX AND CONTROL register
+#define   BEGIN_SCAN(x)	((x) & 0xf)
+#define   END_SCAN(x)	(((x) & 0xf) << 4)
+#define   GAIN_BITS(x)	(((x) & 0x3) << 8)
+#define   UNIP	0x800		// Analog front-end unipolar for range
+#define   SE	0x400		// Inputs in single-ended mode
+#define   PACER_MASK	0x3000	// pacer source bits
+#define   PACER_INT 0x1000	// internal pacer
+#define   PACER_EXT_FALL	0x2000	// external falling edge
+#define   PACER_EXT_RISE	0x3000	// external rising edge
+#define   EOC	0x4000		// adc not busy
+
+#define TRIG_CONTSTAT 4		// TRIGGER CONTROL/STATUS register
+#define   SW_TRIGGER 0x1	// software start trigger
+#define   EXT_TRIGGER 0x2	// external start trigger
+#define   ANALOG_TRIGGER 0x3	// external analog trigger
+#define   TRIGGER_MASK	0x3	// mask of bits that determine start trigger
+#define   TGEN	0x10		// enable external start trigger
+#define   BURSTE 0x20		// burst mode enable
+#define   XTRCL	0x80		// clear external trigger
+
+#define CALIBRATION_REG	6	// CALIBRATION register
+#define   SELECT_8800_BIT	0x100	// select 8800 caldac
+#define   SELECT_TRIMPOT_BIT	0x200	// select ad7376 trim pot
+#define   SELECT_DAC08_BIT	0x400	// select dac08 caldac
+#define   CAL_SRC_BITS(x)	(((x) & 0x7) << 11)
+#define   CAL_EN_BIT	0x4000	// read calibration source instead of analog input channel 0
+#define   SERIAL_DATA_IN_BIT	0x8000	// serial data stream going to 8800 and 7376
+
+#define DAC_CSR	0x8		// dac control and status register
+enum dac_csr_bits {
+	DACEN = 0x2,		// dac enable
+	DAC_MODE_UPDATE_BOTH = 0x80,	// update both dacs when dac0 is written
+};
+static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
+{
+	return (range & 0x3) << (8 + 2 * (channel & 0x1));
+}
+static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
+{
+	return 0x3 << (8 + 2 * (channel & 0x1));
+};
+
+// bits for 1602 series only
+enum dac_csr_bits_1602 {
+	DAC_EMPTY = 0x1,	// dac fifo empty, read, write clear
+	DAC_START = 0x4,	// start/arm dac fifo operations
+	DAC_PACER_MASK = 0x18,	// bits that set dac pacer source
+	DAC_PACER_INT = 0x8,	// dac internal pacing
+	DAC_PACER_EXT_FALL = 0x10,	// dac external pacing, falling edge
+	DAC_PACER_EXT_RISE = 0x18,	// dac external pacing, rising edge
+};
+static inline unsigned int DAC_CHAN_EN(unsigned int channel)
+{
+	return 1 << (5 + (channel & 0x1));	// enable channel 0 or 1
+};
+
+/* analog input fifo */
+#define ADCDATA	0		// ADC DATA register
+#define ADCFIFOCLR	2	// ADC FIFO CLEAR
+
+// pacer, counter, dio registers
+#define ADC8254 0
+#define DIO_8255 4
+#define DAC8254 8
+
+// analog output registers for 100x, 1200 series
+static inline unsigned int DAC_DATA_REG(unsigned int channel)
+{
+	return 2 * (channel & 0x1);
+}
+
+/* analog output registers for 1602 series*/
+#define DACDATA	0		// DAC DATA register
+#define DACFIFOCLR	2	// DAC FIFO CLEAR
+
+// bit in hexadecimal representation of range index that indicates unipolar input range
+#define IS_UNIPOLAR 0x4
+// analog input ranges for most boards
+static const comedi_lrange cb_pcidas_ranges = {
+	8,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(5),
+			BIP_RANGE(2.5),
+			BIP_RANGE(1.25),
+			UNI_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(2.5),
+			UNI_RANGE(1.25)
+		}
+};
+
+// pci-das1001 input ranges
+static const comedi_lrange cb_pcidas_alt_ranges = {
+	8,
+	{
+			BIP_RANGE(10),
+			BIP_RANGE(1),
+			BIP_RANGE(0.1),
+			BIP_RANGE(0.01),
+			UNI_RANGE(10),
+			UNI_RANGE(1),
+			UNI_RANGE(0.1),
+			UNI_RANGE(0.01)
+		}
+};
+
+// analog output ranges
+static const comedi_lrange cb_pcidas_ao_ranges = {
+	4,
+	{
+			BIP_RANGE(5),
+			BIP_RANGE(10),
+			UNI_RANGE(5),
+			UNI_RANGE(10),
+		}
+};
+
+enum trimpot_model {
+	AD7376,
+	AD8402,
+};
+
+typedef struct cb_pcidas_board_struct {
+	const char *name;
+	unsigned short device_id;
+	int ai_se_chans;	// Inputs in single-ended mode
+	int ai_diff_chans;	// Inputs in differential mode
+	int ai_bits;		// analog input resolution
+	int ai_speed;		// fastest conversion period in ns
+	int ao_nchan;		// number of analog out channels
+	int has_ao_fifo;	// analog output has fifo
+	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
+	int fifo_size;		// number of samples fifo can hold
+	const comedi_lrange *ranges;
+	enum trimpot_model trimpot;
+	unsigned has_dac08:1;
+} cb_pcidas_board;
+
+static const cb_pcidas_board cb_pcidas_boards[] = {
+	{
+	      name:	"pci-das1602/16",
+	      device_id:0x1,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:2,
+	      has_ao_fifo:1,
+	      ao_scan_speed:10000,
+	      fifo_size:512,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD8402,
+	      has_dac08:1,
+		},
+	{
+	      name:	"pci-das1200",
+	      device_id:0xF,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:3200,
+	      ao_nchan:2,
+	      has_ao_fifo:0,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+	{
+	      name:	"pci-das1602/12",
+	      device_id:0x10,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:3200,
+	      ao_nchan:2,
+	      has_ao_fifo:1,
+	      ao_scan_speed:4000,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+	{
+	      name:	"pci-das1200/jr",
+	      device_id:0x19,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:3200,
+	      ao_nchan:0,
+	      has_ao_fifo:0,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+	{
+	      name:	"pci-das1602/16/jr",
+	      device_id:0x1C,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	16,
+	      ai_speed:5000,
+	      ao_nchan:0,
+	      has_ao_fifo:0,
+	      fifo_size:512,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD8402,
+	      has_dac08:1,
+		},
+	{
+	      name:	"pci-das1000",
+	      device_id:0x4C,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:4000,
+	      ao_nchan:0,
+	      has_ao_fifo:0,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+	{
+	      name:	"pci-das1001",
+	      device_id:0x1a,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:6800,
+	      ao_nchan:2,
+	      has_ao_fifo:0,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_alt_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+	{
+	      name:	"pci-das1002",
+	      device_id:0x1b,
+	      ai_se_chans:16,
+	      ai_diff_chans:8,
+	      ai_bits:	12,
+	      ai_speed:6800,
+	      ao_nchan:2,
+	      has_ao_fifo:0,
+	      fifo_size:1024,
+	      ranges:	&cb_pcidas_ranges,
+	      trimpot:	AD7376,
+	      has_dac08:0,
+		},
+};
+
+// Number of boards in cb_pcidas_boards
+#define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(cb_pcidas_board))
+
+static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
+	{PCI_VENDOR_ID_CB, 0x0001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x000f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x0010, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x0019, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x001c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x004c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x001a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CB, 0x001b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
+
+/*
+ * Useful for shorthand access to the particular board structure
+ */
+#define thisboard ((const cb_pcidas_board *)dev->board_ptr)
+
+/* this structure is for data unique to this hardware driver.  If
+   several hardware drivers keep similar information in this structure,
+   feel free to suggest moving the variable to the comedi_device struct.  */
+typedef struct {
+	/* would be useful for a PCI device */
+	struct pci_dev *pci_dev;
+	// base addresses
+	unsigned long s5933_config;
+	unsigned long control_status;
+	unsigned long adc_fifo;
+	unsigned long pacer_counter_dio;
+	unsigned long ao_registers;
+	// divisors of master clock for analog input pacing
+	unsigned int divisor1;
+	unsigned int divisor2;
+	volatile unsigned int count;	// number of analog input samples remaining
+	volatile unsigned int adc_fifo_bits;	// bits to write to interupt/adcfifo register
+	volatile unsigned int s5933_intcsr_bits;	// bits to write to amcc s5933 interrupt control/status register
+	volatile unsigned int ao_control_bits;	// bits to write to ao control and status register
+	sampl_t ai_buffer[AI_BUFFER_SIZE];
+	sampl_t ao_buffer[AO_BUFFER_SIZE];
+	// divisors of master clock for analog output pacing
+	unsigned int ao_divisor1;
+	unsigned int ao_divisor2;
+	volatile unsigned int ao_count;	// number of analog output samples remaining
+	int ao_value[2];	// remember what the analog outputs are set to, to allow readback
+	unsigned int caldac_value[NUM_CHANNELS_8800];	// for readback of caldac
+	unsigned int trimpot_value[NUM_CHANNELS_8402];	// for readback of trimpot
+	unsigned int dac08_value;
+	unsigned int calibration_source;
+} cb_pcidas_private;
+
+/*
+ * most drivers define the following macro to make it easy to
+ * access the private structure.
+ */
+#define devpriv ((cb_pcidas_private *)dev->private)
+
+/*
+ * The comedi_driver structure tells the Comedi core module
+ * which functions to call to configure/deconfigure (attach/detach)
+ * the board, and also about the kernel module that contains
+ * the device code.
+ */
+static int cb_pcidas_attach(comedi_device * dev, comedi_devconfig * it);
+static int cb_pcidas_detach(comedi_device * dev);
+static comedi_driver driver_cb_pcidas = {
+      driver_name:"cb_pcidas",
+      module:THIS_MODULE,
+      attach:cb_pcidas_attach,
+      detach:cb_pcidas_detach,
+};
+
+static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static int cb_pcidas_ao_cmd(comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * subdev,
+	unsigned int trig_num);
+static int cb_pcidas_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd);
+static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG);
+static void handle_ao_interrupt(comedi_device * dev, unsigned int status);
+static int cb_pcidas_cancel(comedi_device * dev, comedi_subdevice * s);
+static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s);
+static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
+	int round_flags);
+static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int cb_pcidas_trimpot_write(comedi_device * dev, unsigned int channel,
+	lsampl_t value);
+static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int dac08_write(comedi_device * dev, lsampl_t value);
+static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data);
+static int caldac_8800_write(comedi_device * dev, unsigned int address,
+	uint8_t value);
+static int trimpot_7376_write(comedi_device * dev, uint8_t value);
+static int trimpot_8402_write(comedi_device * dev, unsigned int channel,
+	uint8_t value);
+static int nvram_read(comedi_device * dev, unsigned int address,
+	uint8_t * data);
+
+static inline unsigned int cal_enable_bits(comedi_device * dev)
+{
+	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
+}
+
+/*
+ * Attach is called by the Comedi core to configure the driver
+ * for a particular board.
+ */
+static int cb_pcidas_attach(comedi_device * dev, comedi_devconfig * it)
+{
+	comedi_subdevice *s;
+	struct pci_dev *pcidev;
+	int index;
+	int i;
+
+	printk("comedi%d: cb_pcidas: ", dev->minor);
+
+/*
+ * Allocate the private structure area.
+ */
+	if (alloc_private(dev, sizeof(cb_pcidas_private)) < 0)
+		return -ENOMEM;
+
+/*
+ * Probe the device to determine what device in the series it is.
+ */
+	printk("\n");
+
+	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
+		pcidev != NULL;
+		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
+		// is it not a computer boards card?
+		if (pcidev->vendor != PCI_VENDOR_ID_CB)
+			continue;
+		// loop through cards supported by this driver
+		for (index = 0; index < N_BOARDS; index++) {
+			if (cb_pcidas_boards[index].device_id != pcidev->device)
+				continue;
+			// was a particular bus/slot requested?
+			if (it->options[0] || it->options[1]) {
+				// are we on the wrong bus/slot?
+				if (pcidev->bus->number != it->options[0] ||
+					PCI_SLOT(pcidev->devfn) !=
+					it->options[1]) {
+					continue;
+				}
+			}
+			devpriv->pci_dev = pcidev;
+			dev->board_ptr = cb_pcidas_boards + index;
+			goto found;
+		}
+	}
+
+	printk("No supported ComputerBoards/MeasurementComputing card found on "
+		"requested position\n");
+	return -EIO;
+
+      found:
+
+	printk("Found %s on bus %i, slot %i\n", cb_pcidas_boards[index].name,
+		pcidev->bus->number, PCI_SLOT(pcidev->devfn));
+
+	/*
+	 * Enable PCI device and reserve I/O ports.
+	 */
+	if (comedi_pci_enable(pcidev, "cb_pcidas")) {
+		printk(" Failed to enable PCI device and request regions\n");
+		return -EIO;
+	}
+	/*
+	 * Initialize devpriv->control_status and devpriv->adc_fifo to point to
+	 * their base address.
+	 */
+	devpriv->s5933_config =
+		pci_resource_start(devpriv->pci_dev, S5933_BADRINDEX);
+	devpriv->control_status =
+		pci_resource_start(devpriv->pci_dev, CONT_STAT_BADRINDEX);
+	devpriv->adc_fifo =
+		pci_resource_start(devpriv->pci_dev, ADC_FIFO_BADRINDEX);
+	devpriv->pacer_counter_dio =
+		pci_resource_start(devpriv->pci_dev, PACER_BADRINDEX);
+	if (thisboard->ao_nchan) {
+		devpriv->ao_registers =
+			pci_resource_start(devpriv->pci_dev, AO_BADRINDEX);
+	}
+	// disable and clear interrupts on amcc s5933
+	outl(INTCSR_INBOX_INTR_STATUS,
+		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+
+	// get irq
+	if (comedi_request_irq(devpriv->pci_dev->irq, cb_pcidas_interrupt,
+			IRQF_SHARED, "cb_pcidas", dev)) {
+		printk(" unable to allocate irq %d\n", devpriv->pci_dev->irq);
+		return -EINVAL;
+	}
+	dev->irq = devpriv->pci_dev->irq;
+
+	//Initialize dev->board_name
+	dev->board_name = thisboard->name;
+
+/*
+ * Allocate the subdevice structures.
+ */
+	if (alloc_subdevices(dev, 7) < 0)
+		return -ENOMEM;
+
+	s = dev->subdevices + 0;
+	/* analog input subdevice */
+	dev->read_subdev = s;
+	s->type = COMEDI_SUBD_AI;
+	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;
+	/* WARNING: Number of inputs in differential mode is ignored */
+	s->n_chan = thisboard->ai_se_chans;
+	s->len_chanlist = thisboard->ai_se_chans;
+	s->maxdata = (1 << thisboard->ai_bits) - 1;
+	s->range_table = thisboard->ranges;
+	s->insn_read = cb_pcidas_ai_rinsn;
+	s->insn_config = ai_config_insn;
+	s->do_cmd = cb_pcidas_ai_cmd;
+	s->do_cmdtest = cb_pcidas_ai_cmdtest;
+	s->cancel = cb_pcidas_cancel;
+
+	/* analog output subdevice */
+	s = dev->subdevices + 1;
+	if (thisboard->ao_nchan) {
+		s->type = COMEDI_SUBD_AO;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
+		s->n_chan = thisboard->ao_nchan;
+		// analog out resolution is the same as analog input resolution, so use ai_bits
+		s->maxdata = (1 << thisboard->ai_bits) - 1;
+		s->range_table = &cb_pcidas_ao_ranges;
+		s->insn_read = cb_pcidas_ao_readback_insn;
+		if (thisboard->has_ao_fifo) {
+			dev->write_subdev = s;
+			s->subdev_flags |= SDF_CMD_WRITE;
+			s->insn_write = cb_pcidas_ao_fifo_winsn;
+			s->do_cmdtest = cb_pcidas_ao_cmdtest;
+			s->do_cmd = cb_pcidas_ao_cmd;
+			s->cancel = cb_pcidas_ao_cancel;
+		} else {
+			s->insn_write = cb_pcidas_ao_nofifo_winsn;
+		}
+	} else {
+		s->type = COMEDI_SUBD_UNUSED;
+	}
+
+	/* 8255 */
+	s = dev->subdevices + 2;
+	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255);
+
+	// serial EEPROM,
+	s = dev->subdevices + 3;
+	s->type = COMEDI_SUBD_MEMORY;
+	s->subdev_flags = SDF_READABLE | SDF_INTERNAL;
+	s->n_chan = 256;
+	s->maxdata = 0xff;
+	s->insn_read = eeprom_read_insn;
+
+	// 8800 caldac
+	s = dev->subdevices + 4;
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	s->n_chan = NUM_CHANNELS_8800;
+	s->maxdata = 0xff;
+	s->insn_read = caldac_read_insn;
+	s->insn_write = caldac_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		caldac_8800_write(dev, i, s->maxdata / 2);
+
+	// trim potentiometer
+	s = dev->subdevices + 5;
+	s->type = COMEDI_SUBD_CALIB;
+	s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+	if (thisboard->trimpot == AD7376) {
+		s->n_chan = NUM_CHANNELS_7376;
+		s->maxdata = 0x7f;
+	} else {
+		s->n_chan = NUM_CHANNELS_8402;
+		s->maxdata = 0xff;
+	}
+	s->insn_read = trimpot_read_insn;
+	s->insn_write = trimpot_write_insn;
+	for (i = 0; i < s->n_chan; i++)
+		cb_pcidas_trimpot_write(dev, i, s->maxdata / 2);
+
+	// dac08 caldac
+	s = dev->subdevices + 6;
+	if (thisboard->has_dac08) {
+		s->type = COMEDI_SUBD_CALIB;
+		s->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
+		s->n_chan = NUM_CHANNELS_DAC08;
+		s->insn_read = dac08_read_insn;
+		s->insn_write = dac08_write_insn;
+		s->maxdata = 0xff;
+		dac08_write(dev, s->maxdata / 2);
+	} else
+		s->type = COMEDI_SUBD_UNUSED;
+
+	// make sure mailbox 4 is empty
+	inl(devpriv->s5933_config + AMCC_OP_REG_IMB4);
+	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
+	devpriv->s5933_intcsr_bits =
+		INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
+		INTCSR_INBOX_FULL_INT;
+	// clear and enable interrupt on amcc s5933
+	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
+		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+
+	return 1;
+}
+
+/*
+ * cb_pcidas_detach is called to deconfigure a device.  It should deallocate
+ * resources.
+ * This function is also called when _attach() fails, so it should be
+ * careful not to release resources that were not necessarily
+ * allocated by _attach().  dev->private and dev->subdevices are
+ * deallocated automatically by the core.
+ */
+static int cb_pcidas_detach(comedi_device * dev)
+{
+	printk("comedi%d: cb_pcidas: remove\n", dev->minor);
+
+	if (devpriv) {
+		if (devpriv->s5933_config) {
+			// disable and clear interrupts on amcc s5933
+			outl(INTCSR_INBOX_INTR_STATUS,
+				devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+#ifdef CB_PCIDAS_DEBUG
+			rt_printk("detaching, incsr is 0x%x\n",
+				inl(devpriv->s5933_config +
+					AMCC_OP_REG_INTCSR));
+#endif
+		}
+	}
+	if (dev->irq)
+		comedi_free_irq(dev->irq, dev);
+	if (dev->subdevices)
+		subdev_8255_cleanup(dev, dev->subdevices + 2);
+	if (devpriv && devpriv->pci_dev) {
+		if (devpriv->s5933_config) {
+			comedi_pci_disable(devpriv->pci_dev);
+		}
+		pci_dev_put(devpriv->pci_dev);
+	}
+
+	return 0;
+}
+
+/*
+ * "instructions" read/write data in "one-shot" or "software-triggered"
+ * mode.
+ */
+static int cb_pcidas_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int n, i;
+	unsigned int bits;
+	static const int timeout = 10000;
+	int channel;
+	// enable calibration input if appropriate
+	if (insn->chanspec & CR_ALT_SOURCE) {
+		outw(cal_enable_bits(dev),
+			devpriv->control_status + CALIBRATION_REG);
+		channel = 0;
+	} else {
+		outw(0, devpriv->control_status + CALIBRATION_REG);
+		channel = CR_CHAN(insn->chanspec);
+	}
+	// set mux limits and gain
+	bits = BEGIN_SCAN(channel) |
+		END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn->chanspec));
+	// set unipolar/bipolar
+	if (CR_RANGE(insn->chanspec) & IS_UNIPOLAR)
+		bits |= UNIP;
+	// set singleended/differential
+	if (CR_AREF(insn->chanspec) != AREF_DIFF)
+		bits |= SE;
+	outw(bits, devpriv->control_status + ADCMUX_CONT);
+
+	/* clear fifo */
+	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
+
+	/* convert n samples */
+	for (n = 0; n < insn->n; n++) {
+		/* trigger conversion */
+		outw(0, devpriv->adc_fifo + ADCDATA);
+
+		/* wait for conversion to end */
+		/* return -ETIMEDOUT if there is a timeout */
+		for (i = 0; i < timeout; i++) {
+			if (inw(devpriv->control_status + ADCMUX_CONT) & EOC)
+				break;
+		}
+		if (i == timeout)
+			return -ETIMEDOUT;
+
+		/* read data */
+		data[n] = inw(devpriv->adc_fifo + ADCDATA);
+	}
+
+	/* return the number of samples read/written */
+	return n;
+}
+
+static int ai_config_calibration_source(comedi_device * dev, lsampl_t * data)
+{
+	static const int num_calibration_sources = 8;
+	lsampl_t source = data[1];
+
+	if (source >= num_calibration_sources) {
+		printk("invalid calibration source: %i\n", source);
+		return -EINVAL;
+	}
+
+	devpriv->calibration_source = source;
+
+	return 2;
+}
+
+static int ai_config_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int id = data[0];
+
+	switch (id) {
+	case INSN_CONFIG_ALT_SOURCE:
+		return ai_config_calibration_source(dev, data);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	return -EINVAL;
+}
+
+// analog output insn for pcidas-1000 and 1200 series
+static int cb_pcidas_ao_nofifo_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel;
+	unsigned long flags;
+
+	// set channel and range
+	channel = CR_CHAN(insn->chanspec);
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->ao_control_bits &=
+		~DAC_MODE_UPDATE_BOTH & ~DAC_RANGE_MASK(channel);
+	devpriv->ao_control_bits |=
+		DACEN | DAC_RANGE(channel, CR_RANGE(insn->chanspec));
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// remember value for readback
+	devpriv->ao_value[channel] = data[0];
+	// send data
+	outw(data[0], devpriv->ao_registers + DAC_DATA_REG(channel));
+
+	return 1;
+}
+
+// analog output insn for pcidas-1602 series
+static int cb_pcidas_ao_fifo_winsn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	int channel;
+	unsigned long flags;
+
+	// clear dac fifo
+	outw(0, devpriv->ao_registers + DACFIFOCLR);
+
+	// set channel and range
+	channel = CR_CHAN(insn->chanspec);
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->ao_control_bits &=
+		~DAC_CHAN_EN(0) & ~DAC_CHAN_EN(1) & ~DAC_RANGE_MASK(channel) &
+		~DAC_PACER_MASK;
+	devpriv->ao_control_bits |=
+		DACEN | DAC_RANGE(channel,
+		CR_RANGE(insn->chanspec)) | DAC_CHAN_EN(channel) | DAC_START;
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// remember value for readback
+	devpriv->ao_value[channel] = data[0];
+	// send data
+	outw(data[0], devpriv->ao_registers + DACDATA);
+
+	return 1;
+}
+
+// analog output readback insn
+// XXX loses track of analog output value back after an analog ouput command is executed
+static int cb_pcidas_ao_readback_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+static int eeprom_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	uint8_t nvram_data;
+	int retval;
+
+	retval = nvram_read(dev, CR_CHAN(insn->chanspec), &nvram_data);
+	if (retval < 0)
+		return retval;
+
+	data[0] = nvram_data;
+
+	return 1;
+}
+
+static int caldac_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	const unsigned int channel = CR_CHAN(insn->chanspec);
+
+	return caldac_8800_write(dev, channel, data[0]);
+}
+
+static int caldac_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->caldac_value[CR_CHAN(insn->chanspec)];
+
+	return 1;
+}
+
+/* 1602/16 pregain offset */
+static int dac08_write(comedi_device * dev, lsampl_t value)
+{
+	if (devpriv->dac08_value == value)
+		return 1;
+
+	devpriv->dac08_value = value;
+
+	outw(cal_enable_bits(dev) | (value & 0xff),
+		devpriv->control_status + CALIBRATION_REG);
+	comedi_udelay(1);
+	outw(cal_enable_bits(dev) | SELECT_DAC08_BIT | (value & 0xff),
+		devpriv->control_status + CALIBRATION_REG);
+	comedi_udelay(1);
+	outw(cal_enable_bits(dev) | (value & 0xff),
+		devpriv->control_status + CALIBRATION_REG);
+	comedi_udelay(1);
+
+	return 1;
+}
+
+static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	return dac08_write(dev, data[0]);
+}
+
+static int dac08_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	data[0] = devpriv->dac08_value;
+
+	return 1;
+}
+
+static int cb_pcidas_trimpot_write(comedi_device * dev,
+	unsigned int channel, lsampl_t value)
+{
+	if (devpriv->trimpot_value[channel] == value)
+		return 1;
+
+	devpriv->trimpot_value[channel] = value;
+	switch (thisboard->trimpot) {
+	case AD7376:
+		trimpot_7376_write(dev, value);
+		break;
+	case AD8402:
+		trimpot_8402_write(dev, channel, value);
+		break;
+	default:
+		comedi_error(dev, "driver bug?");
+		return -1;
+		break;
+	}
+
+	return 1;
+}
+
+static int trimpot_write_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int channel = CR_CHAN(insn->chanspec);
+
+	return cb_pcidas_trimpot_write(dev, channel, data[0]);
+}
+
+static int trimpot_read_insn(comedi_device * dev, comedi_subdevice * s,
+	comedi_insn * insn, lsampl_t * data)
+{
+	unsigned int channel = CR_CHAN(insn->chanspec);
+
+	data[0] = devpriv->trimpot_value[channel];
+
+	return 1;
+}
+
+static int cb_pcidas_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+	int i, gain, start_chan;
+
+	/* cmdtest tests a particular command to see if it is valid.
+	 * Using the cmdtest ioctl, a user can create a valid cmd
+	 * and then have it executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
+	 * the command passes. */
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_NOW | TRIG_EXT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_TIMER | TRIG_NOW | TRIG_EXT;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)
+		err++;
+	if (cmd->scan_begin_src != TRIG_FOLLOW &&
+		cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->convert_src != TRIG_TIMER &&
+		cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	// make sure trigger sources are compatible with each other
+	if (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)
+		err++;
+	if (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)
+		err++;
+	if (cmd->start_src == TRIG_EXT &&
+		(cmd->convert_src == TRIG_EXT
+			|| cmd->scan_begin_src == TRIG_EXT))
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg <
+			thisboard->ai_speed * cmd->chanlist_len) {
+			cmd->scan_begin_arg =
+				thisboard->ai_speed * cmd->chanlist_len;
+			err++;
+		}
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		if (cmd->convert_arg < thisboard->ai_speed) {
+			cmd->convert_arg = thisboard->ai_speed;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_NONE) {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+			&(devpriv->divisor1), &(devpriv->divisor2),
+			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+	if (cmd->convert_src == TRIG_TIMER) {
+		tmp = cmd->convert_arg;
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+			&(devpriv->divisor1), &(devpriv->divisor2),
+			&(cmd->convert_arg), cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->convert_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	// check channel/gain list against card's limitations
+	if (cmd->chanlist) {
+		gain = CR_RANGE(cmd->chanlist[0]);
+		start_chan = CR_CHAN(cmd->chanlist[0]);
+		for (i = 1; i < cmd->chanlist_len; i++) {
+			if (CR_CHAN(cmd->chanlist[i]) !=
+				(start_chan + i) % s->n_chan) {
+				comedi_error(dev,
+					"entries in chanlist must be consecutive channels, counting upwards\n");
+				err++;
+			}
+			if (CR_RANGE(cmd->chanlist[i]) != gain) {
+				comedi_error(dev,
+					"entries in chanlist must all have the same gain\n");
+				err++;
+			}
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int cb_pcidas_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int bits;
+	unsigned long flags;
+
+	// make sure CAL_EN_BIT is disabled
+	outw(0, devpriv->control_status + CALIBRATION_REG);
+	// initialize before settings pacer source and count values
+	outw(0, devpriv->control_status + TRIG_CONTSTAT);
+	// clear fifo
+	outw(0, devpriv->adc_fifo + ADCFIFOCLR);
+
+	// set mux limits, gain and pacer source
+	bits = BEGIN_SCAN(CR_CHAN(cmd->chanlist[0])) |
+		END_SCAN(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |
+		GAIN_BITS(CR_RANGE(cmd->chanlist[0]));
+	// set unipolar/bipolar
+	if (CR_RANGE(cmd->chanlist[0]) & IS_UNIPOLAR)
+		bits |= UNIP;
+	// set singleended/differential
+	if (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)
+		bits |= SE;
+	// set pacer source
+	if (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)
+		bits |= PACER_EXT_RISE;
+	else
+		bits |= PACER_INT;
+	outw(bits, devpriv->control_status + ADCMUX_CONT);
+
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("comedi: sent 0x%x to adcmux control\n", bits);
+#endif
+
+	// load counters
+	if (cmd->convert_src == TRIG_TIMER)
+		cb_pcidas_load_counters(dev, &cmd->convert_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+	else if (cmd->scan_begin_src == TRIG_TIMER)
+		cb_pcidas_load_counters(dev, &cmd->scan_begin_arg,
+			cmd->flags & TRIG_ROUND_MASK);
+
+	// set number of conversions
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->count = cmd->chanlist_len * cmd->stop_arg;
+	}
+	// enable interrupts
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->adc_fifo_bits |= INTE;
+	devpriv->adc_fifo_bits &= ~INT_MASK;
+	if (cmd->flags & TRIG_WAKE_EOS) {
+		if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
+			devpriv->adc_fifo_bits |= INT_EOS;	// interrupt end of burst
+		else
+			devpriv->adc_fifo_bits |= INT_FNE;	// interrupt fifo not empty
+	} else {
+		devpriv->adc_fifo_bits |= INT_FHF;	//interrupt fifo half full
+	}
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+#endif
+	// enable (and clear) interrupts
+	outw(devpriv->adc_fifo_bits | EOAI | INT | LADFUL,
+		devpriv->control_status + INT_ADCFIFO);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// set start trigger and burst mode
+	bits = 0;
+	if (cmd->start_src == TRIG_NOW)
+		bits |= SW_TRIGGER;
+	else if (cmd->start_src == TRIG_EXT)
+		bits |= EXT_TRIGGER | TGEN | XTRCL;
+	else {
+		comedi_error(dev, "bug!");
+		return -1;
+	}
+	if (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)
+		bits |= BURSTE;
+	outw(bits, devpriv->control_status + TRIG_CONTSTAT);
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("comedi: sent 0x%x to trig control\n", bits);
+#endif
+
+	return 0;
+}
+
+static int cb_pcidas_ao_cmdtest(comedi_device * dev, comedi_subdevice * s,
+	comedi_cmd * cmd)
+{
+	int err = 0;
+	int tmp;
+
+	/* cmdtest tests a particular command to see if it is valid.
+	 * Using the cmdtest ioctl, a user can create a valid cmd
+	 * and then have it executes by the cmd ioctl.
+	 *
+	 * cmdtest returns 1,2,3,4 or 0, depending on which tests
+	 * the command passes. */
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd->start_src;
+	cmd->start_src &= TRIG_INT;
+	if (!cmd->start_src || tmp != cmd->start_src)
+		err++;
+
+	tmp = cmd->scan_begin_src;
+	cmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;
+	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
+		err++;
+
+	tmp = cmd->convert_src;
+	cmd->convert_src &= TRIG_NOW;
+	if (!cmd->convert_src || tmp != cmd->convert_src)
+		err++;
+
+	tmp = cmd->scan_end_src;
+	cmd->scan_end_src &= TRIG_COUNT;
+	if (!cmd->scan_end_src || tmp != cmd->scan_end_src)
+		err++;
+
+	tmp = cmd->stop_src;
+	cmd->stop_src &= TRIG_COUNT | TRIG_NONE;
+	if (!cmd->stop_src || tmp != cmd->stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	if (cmd->scan_begin_src != TRIG_TIMER &&
+		cmd->scan_begin_src != TRIG_EXT)
+		err++;
+	if (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	if (cmd->start_arg != 0) {
+		cmd->start_arg = 0;
+		err++;
+	}
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		if (cmd->scan_begin_arg < thisboard->ao_scan_speed) {
+			cmd->scan_begin_arg = thisboard->ao_scan_speed;
+			err++;
+		}
+	}
+
+	if (cmd->scan_end_arg != cmd->chanlist_len) {
+		cmd->scan_end_arg = cmd->chanlist_len;
+		err++;
+	}
+	if (cmd->stop_src == TRIG_NONE) {
+		/* TRIG_NONE */
+		if (cmd->stop_arg != 0) {
+			cmd->stop_arg = 0;
+			err++;
+		}
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		tmp = cmd->scan_begin_arg;
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
+			&(cmd->scan_begin_arg), cmd->flags & TRIG_ROUND_MASK);
+		if (tmp != cmd->scan_begin_arg)
+			err++;
+	}
+
+	if (err)
+		return 4;
+
+	// check channel/gain list against card's limitations
+	if (cmd->chanlist && cmd->chanlist_len > 1) {
+		if (CR_CHAN(cmd->chanlist[0]) != 0 ||
+			CR_CHAN(cmd->chanlist[1]) != 1) {
+			comedi_error(dev,
+				"channels must be ordered channel 0, channel 1 in chanlist\n");
+			err++;
+		}
+	}
+
+	if (err)
+		return 5;
+
+	return 0;
+}
+
+static int cb_pcidas_ao_cmd(comedi_device * dev, comedi_subdevice * s)
+{
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int i;
+	unsigned long flags;
+
+	// set channel limits, gain
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	for (i = 0; i < cmd->chanlist_len; i++) {
+		// enable channel
+		devpriv->ao_control_bits |=
+			DAC_CHAN_EN(CR_CHAN(cmd->chanlist[i]));
+		// set range
+		devpriv->ao_control_bits |= DAC_RANGE(CR_CHAN(cmd->chanlist[i]),
+			CR_RANGE(cmd->chanlist[i]));
+	}
+
+	// disable analog out before settings pacer source and count values
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// clear fifo
+	outw(0, devpriv->ao_registers + DACFIFOCLR);
+
+	// load counters
+	if (cmd->scan_begin_src == TRIG_TIMER) {
+		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
+			&(devpriv->ao_divisor1), &(devpriv->ao_divisor2),
+			&(cmd->scan_begin_arg), cmd->flags);
+
+		/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
+		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 1,
+			devpriv->ao_divisor1, 2);
+		i8254_load(devpriv->pacer_counter_dio + DAC8254, 0, 2,
+			devpriv->ao_divisor2, 2);
+	}
+	// set number of conversions
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ao_count = cmd->chanlist_len * cmd->stop_arg;
+	}
+	// set pacer source
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	switch (cmd->scan_begin_src) {
+	case TRIG_TIMER:
+		devpriv->ao_control_bits |= DAC_PACER_INT;
+		break;
+	case TRIG_EXT:
+		devpriv->ao_control_bits |= DAC_PACER_EXT_RISE;
+		break;
+	default:
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		comedi_error(dev, "error setting dac pacer source");
+		return -1;
+		break;
+	}
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	async->inttrig = cb_pcidas_ao_inttrig;
+
+	return 0;
+}
+
+static int cb_pcidas_ao_inttrig(comedi_device * dev, comedi_subdevice * s,
+	unsigned int trig_num)
+{
+	unsigned int num_bytes, num_points = thisboard->fifo_size;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &s->async->cmd;
+	unsigned long flags;
+
+	if (trig_num != 0)
+		return -EINVAL;
+
+	// load up fifo
+	if (cmd->stop_src == TRIG_COUNT && devpriv->ao_count < num_points)
+		num_points = devpriv->ao_count;
+
+	num_bytes = cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+		num_points * sizeof(sampl_t));
+	num_points = num_bytes / sizeof(sampl_t);
+
+	if (cmd->stop_src == TRIG_COUNT) {
+		devpriv->ao_count -= num_points;
+	}
+	// write data to board's fifo
+	outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer, num_bytes);
+
+	// enable dac half-full and empty interrupts
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	devpriv->adc_fifo_bits |= DAEMIE | DAHFIE;
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv->adc_fifo_bits);
+#endif
+	// enable and clear interrupts
+	outw(devpriv->adc_fifo_bits | DAEMI | DAHFI,
+		devpriv->control_status + INT_ADCFIFO);
+
+	// start dac
+	devpriv->ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("comedi: sent 0x%x to dac control\n",
+		devpriv->ao_control_bits);
+#endif
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	async->inttrig = NULL;
+
+	return 0;
+}
+
+static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
+{
+	comedi_device *dev = (comedi_device *) d;
+	comedi_subdevice *s = dev->read_subdev;
+	comedi_async *async;
+	int status, s5933_status;
+	int half_fifo = thisboard->fifo_size / 2;
+	unsigned int num_samples, i;
+	static const int timeout = 10000;
+	unsigned long flags;
+
+	if (dev->attached == 0) {
+		return IRQ_NONE;
+	}
+
+	async = s->async;
+	async->events = 0;
+
+	s5933_status = inl(devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+#ifdef CB_PCIDAS_DEBUG
+	rt_printk("intcsr 0x%x\n", s5933_status);
+	rt_printk("mbef 0x%x\n", inl(devpriv->s5933_config + AMCC_OP_REG_MBEF));
+#endif
+
+	if ((INTCSR_INTR_ASSERTED & s5933_status) == 0)
+		return IRQ_NONE;
+
+	// make sure mailbox 4 is empty
+	inl_p(devpriv->s5933_config + AMCC_OP_REG_IMB4);
+	// clear interrupt on amcc s5933
+	outl(devpriv->s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
+		devpriv->s5933_config + AMCC_OP_REG_INTCSR);
+
+	status = inw(devpriv->control_status + INT_ADCFIFO);
+#ifdef CB_PCIDAS_DEBUG
+	if ((status & (INT | EOAI | LADFUL | DAHFI | DAEMI)) == 0) {
+		comedi_error(dev, "spurious interrupt");
+	}
+#endif
+
+	// check for analog output interrupt
+	if (status & (DAHFI | DAEMI)) {
+		handle_ao_interrupt(dev, status);
+	}
+	// check for analog input interrupts
+	// if fifo half-full
+	if (status & ADHFI) {
+		// read data
+		num_samples = half_fifo;
+		if (async->cmd.stop_src == TRIG_COUNT &&
+			num_samples > devpriv->count) {
+			num_samples = devpriv->count;
+		}
+		insw(devpriv->adc_fifo + ADCDATA, devpriv->ai_buffer,
+			num_samples);
+		cfc_write_array_to_buffer(s, devpriv->ai_buffer,
+			num_samples * sizeof(sampl_t));
+		devpriv->count -= num_samples;
+		if (async->cmd.stop_src == TRIG_COUNT && devpriv->count == 0) {
+			async->events |= COMEDI_CB_EOA;
+			cb_pcidas_cancel(dev, s);
+		}
+		// clear half-full interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | INT,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		// else if fifo not empty
+	} else if (status & (ADNEI | EOBI)) {
+		for (i = 0; i < timeout; i++) {
+			// break if fifo is empty
+			if ((ADNE & inw(devpriv->control_status +
+						INT_ADCFIFO)) == 0)
+				break;
+			cfc_write_to_buffer(s, inw(devpriv->adc_fifo));
+			if (async->cmd.stop_src == TRIG_COUNT && --devpriv->count == 0) {	/* end of acquisition */
+				cb_pcidas_cancel(dev, s);
+				async->events |= COMEDI_CB_EOA;
+				break;
+			}
+		}
+		// clear not-empty interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | INT,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	} else if (status & EOAI) {
+		comedi_error(dev,
+			"bug! encountered end of aquisition interrupt?");
+		// clear EOA interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | EOAI,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
+	//check for fifo overflow
+	if (status & LADFUL) {
+		comedi_error(dev, "fifo overflow");
+		// clear overflow interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | LADFUL,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		cb_pcidas_cancel(dev, s);
+		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
+	}
+
+	comedi_event(dev, s);
+
+	return IRQ_HANDLED;
+}
+
+static void handle_ao_interrupt(comedi_device * dev, unsigned int status)
+{
+	comedi_subdevice *s = dev->write_subdev;
+	comedi_async *async = s->async;
+	comedi_cmd *cmd = &async->cmd;
+	unsigned int half_fifo = thisboard->fifo_size / 2;
+	unsigned int num_points;
+	unsigned int flags;
+
+	async->events = 0;
+
+	if (status & DAEMI) {
+		// clear dac empty interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | DAEMI,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+		if (inw(devpriv->ao_registers + DAC_CSR) & DAC_EMPTY) {
+			if (cmd->stop_src == TRIG_NONE ||
+				(cmd->stop_src == TRIG_COUNT
+					&& devpriv->ao_count)) {
+				comedi_error(dev, "dac fifo underflow");
+				cb_pcidas_ao_cancel(dev, s);
+				async->events |= COMEDI_CB_ERROR;
+			}
+			async->events |= COMEDI_CB_EOA;
+		}
+	} else if (status & DAHFI) {
+		unsigned int num_bytes;
+
+		// figure out how many points we are writing to fifo
+		num_points = half_fifo;
+		if (cmd->stop_src == TRIG_COUNT &&
+			devpriv->ao_count < num_points)
+			num_points = devpriv->ao_count;
+		num_bytes =
+			cfc_read_array_from_buffer(s, devpriv->ao_buffer,
+			num_points * sizeof(sampl_t));
+		num_points = num_bytes / sizeof(sampl_t);
+
+		if (async->cmd.stop_src == TRIG_COUNT) {
+			devpriv->ao_count -= num_points;
+		}
+		// write data to board's fifo
+		outsw(devpriv->ao_registers + DACDATA, devpriv->ao_buffer,
+			num_points);
+		// clear half-full interrupt latch
+		comedi_spin_lock_irqsave(&dev->spinlock, flags);
+		outw(devpriv->adc_fifo_bits | DAHFI,
+			devpriv->control_status + INT_ADCFIFO);
+		comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+	}
+
+	comedi_event(dev, s);
+}
+
+// cancel analog input command
+static int cb_pcidas_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	// disable interrupts
+	devpriv->adc_fifo_bits &= ~INTE & ~EOAIE;
+	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	// disable start trigger source and burst mode
+	outw(0, devpriv->control_status + TRIG_CONTSTAT);
+	// software pacer source
+	outw(0, devpriv->control_status + ADCMUX_CONT);
+
+	return 0;
+}
+
+// cancel analog output command
+static int cb_pcidas_ao_cancel(comedi_device * dev, comedi_subdevice * s)
+{
+	unsigned long flags;
+
+	comedi_spin_lock_irqsave(&dev->spinlock, flags);
+	// disable interrupts
+	devpriv->adc_fifo_bits &= ~DAHFIE & ~DAEMIE;
+	outw(devpriv->adc_fifo_bits, devpriv->control_status + INT_ADCFIFO);
+
+	// disable output
+	devpriv->ao_control_bits &= ~DACEN & ~DAC_PACER_MASK;
+	outw(devpriv->ao_control_bits, devpriv->control_status + DAC_CSR);
+	comedi_spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	return 0;
+}
+
+static void cb_pcidas_load_counters(comedi_device * dev, unsigned int *ns,
+	int rounding_flags)
+{
+	i8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),
+		&(devpriv->divisor2), ns, rounding_flags & TRIG_ROUND_MASK);
+
+	/* Write the values of ctr1 and ctr2 into counters 1 and 2 */
+	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 1,
+		devpriv->divisor1, 2);
+	i8254_load(devpriv->pacer_counter_dio + ADC8254, 0, 2,
+		devpriv->divisor2, 2);
+}
+
+static void write_calibration_bitstream(comedi_device * dev,
+	unsigned int register_bits, unsigned int bitstream,
+	unsigned int bitstream_length)
+{
+	static const int write_delay = 1;
+	unsigned int bit;
+
+	for (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {
+		if (bitstream & bit)
+			register_bits |= SERIAL_DATA_IN_BIT;
+		else
+			register_bits &= ~SERIAL_DATA_IN_BIT;
+		comedi_udelay(write_delay);
+		outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+	}
+}
+
+static int caldac_8800_write(comedi_device * dev, unsigned int address,
+	uint8_t value)
+{
+	static const int num_caldac_channels = 8;
+	static const int bitstream_length = 11;
+	unsigned int bitstream = ((address & 0x7) << 8) | value;
+	static const int caldac_8800_comedi_udelay = 1;
+
+	if (address >= num_caldac_channels) {
+		comedi_error(dev, "illegal caldac channel");
+		return -1;
+	}
+
+	if (value == devpriv->caldac_value[address])
+		return 1;
+
+	devpriv->caldac_value[address] = value;
+
+	write_calibration_bitstream(dev, cal_enable_bits(dev), bitstream,
+		bitstream_length);
+
+	comedi_udelay(caldac_8800_comedi_udelay);
+	outw(cal_enable_bits(dev) | SELECT_8800_BIT,
+		devpriv->control_status + CALIBRATION_REG);
+	comedi_udelay(caldac_8800_comedi_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 1;
+}
+
+static int trimpot_7376_write(comedi_device * dev, uint8_t value)
+{
+	static const int bitstream_length = 7;
+	unsigned int bitstream = value & 0x7f;
+	unsigned int register_bits;
+	static const int ad7376_comedi_udelay = 1;
+
+	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	comedi_udelay(ad7376_comedi_udelay);
+	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+
+	write_calibration_bitstream(dev, register_bits, bitstream,
+		bitstream_length);
+
+	comedi_udelay(ad7376_comedi_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 0;
+}
+
+/* For 1602/16 only
+ * ch 0 : adc gain
+ * ch 1 : adc postgain offset */
+static int trimpot_8402_write(comedi_device * dev, unsigned int channel,
+	uint8_t value)
+{
+	static const int bitstream_length = 10;
+	unsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);
+	unsigned int register_bits;
+	static const int ad8402_comedi_udelay = 1;
+
+	register_bits = cal_enable_bits(dev) | SELECT_TRIMPOT_BIT;
+	comedi_udelay(ad8402_comedi_udelay);
+	outw(register_bits, devpriv->control_status + CALIBRATION_REG);
+
+	write_calibration_bitstream(dev, register_bits, bitstream,
+		bitstream_length);
+
+	comedi_udelay(ad8402_comedi_udelay);
+	outw(cal_enable_bits(dev), devpriv->control_status + CALIBRATION_REG);
+
+	return 0;
+}
+
+static int wait_for_nvram_ready(unsigned long s5933_base_addr)
+{
+	static const int timeout = 1000;
+	unsigned int i;
+
+	for (i = 0; i < timeout; i++) {
+		if ((inb(s5933_base_addr +
+					AMCC_OP_REG_MCSR_NVCMD) & MCSR_NV_BUSY)
+			== 0)
+			return 0;
+		comedi_udelay(1);
+	}
+	return -1;
+}
+
+static int nvram_read(comedi_device * dev, unsigned int address, uint8_t * data)
+{
+	unsigned long iobase = devpriv->s5933_config;
+
+	if (wait_for_nvram_ready(iobase) < 0)
+		return -ETIMEDOUT;
+
+	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,
+		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	outb(address & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
+	outb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,
+		iobase + AMCC_OP_REG_MCSR_NVCMD);
+	outb((address >> 8) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);
+	outb(MCSR_NV_ENABLE | MCSR_NV_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);
+
+	if (wait_for_nvram_ready(iobase) < 0)
+		return -ETIMEDOUT;
+
+	*data = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);
+
+	return 0;
+}
+
+/*
+ * A convenient macro that defines init_module() and cleanup_module(),
+ * as necessary.
+ */
+COMEDI_PCI_INITCLEANUP(driver_cb_pcidas, cb_pcidas_pci_table);
